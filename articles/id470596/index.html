<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃 😉 ☄️ Fitur Q dan KDB + pada contoh layanan real-time 👼 🧑‍🤝‍🧑 🈚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa itu KDB +, bahasa pemrograman Q, apa kekuatan dan kelemahannya, dapat ditemukan di artikel saya sebelumnya dan secara singkat dalam pengantar. Dal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur Q dan KDB + pada contoh layanan real-time</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/470596/">  Apa itu KDB +, bahasa pemrograman Q, apa kekuatan dan kelemahannya, dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya sebelumnya dan secara singkat dalam pengantar.  Dalam artikel tersebut, kami menerapkan layanan pada Q yang akan memproses aliran data yang masuk dan menghitung per menit berbagai fungsi agregasi dalam mode "waktu nyata" (yaitu, ia akan berhasil menghitung semuanya sampai bagian data berikutnya).  Fitur utama Q adalah bahwa ia adalah bahasa vektor yang memungkinkan Anda untuk beroperasi bukan dengan objek tunggal, tetapi dengan array, array array, dan objek kompleks lainnya.  Bahasa seperti Q dan K, J, APL yang terkait terkenal dengan singkatnya.  Seringkali sebuah program yang membentang beberapa layar kode dalam bahasa yang dikenal seperti Java dapat ditulis pada mereka dalam beberapa baris.  Inilah yang ingin saya tunjukkan dalam artikel ini. <br><br><img src="https://habrastorage.org/webt/wb/ej/zy/wbejzyzkg_-aypnh92it6kecrtq.jpeg"><br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  KDB + adalah basis data kolom yang berfokus pada volume data yang sangat besar, diurutkan dengan cara tertentu (terutama berdasarkan waktu).  Pertama-tama digunakan dalam organisasi keuangan - bank, dana investasi, perusahaan asuransi.  Bahasa Q adalah bahasa internal KDB + yang memungkinkan Anda untuk bekerja secara efektif dengan data ini.  Ideologi Q adalah singkatnya dan efisiensi, sementara kejelasan dikorbankan.  Ini dibenarkan oleh fakta bahwa dalam hal apa pun bahasa vektor akan sulit dipahami, dan singkatnya dan banyaknya rekaman memungkinkan Anda melihat lebih banyak program pada satu layar, yang pada akhirnya memudahkan pemahamannya. <br><br>  Pada artikel ini, kami menerapkan program Q yang lengkap dan Anda mungkin ingin mencobanya.  Untuk melakukan ini, Anda memerlukan Q yang sebenarnya. Anda dapat mengunduh versi 32-bit gratis di situs web perusahaan kx - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.kx.com</a> .  Di tempat yang sama, jika Anda tertarik, Anda akan menemukan informasi referensi tentang Q, buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Q For Mortals</a> dan berbagai artikel tentang topik ini. <br><br><h3>  Pernyataan masalah </h3><br>  Ada sumber yang mengirim tabel data setiap 25 milidetik.  Karena KDB + terutama digunakan dalam keuangan, kami menganggap bahwa ini adalah tabel perdagangan di mana terdapat kolom berikut: waktu (waktu dalam milidetik), sym (nama perusahaan pada pertukaran - <b>IBM</b> , <b>AAPL</b> , ...), harga (harga) dimana saham dibeli), ukuran (ukuran transaksi).  Interval 25 milidetik dipilih secara sewenang-wenang, tidak terlalu kecil dan tidak terlalu besar.  Kehadirannya berarti bahwa data yang tiba di layanan sudah buffer.  Akan mudah untuk menerapkan buffering di sisi layanan, termasuk buffering dinamis, tergantung pada beban saat ini, tetapi untuk kesederhanaan kami tinggal pada interval yang tetap. <br><br>  Layanan harus menghitung setiap menit untuk setiap karakter yang masuk dari kolom sym satu set fungsi agregasi - harga maks, harga rata-rata, ukuran jumlah, dll.  informasi yang berguna.  Untuk kesederhanaan, kami mengasumsikan bahwa semua fungsi dapat dihitung secara bertahap, mis.  untuk mendapatkan nilai baru, cukup mengetahui dua angka - yang lama dan nilai yang masuk.  Misalnya, fungsi maks, rata-rata, jumlah memiliki properti ini, tetapi fungsi median tidak. <br><br>  Kami juga menganggap bahwa aliran data yang masuk dipesan berdasarkan waktu.  Ini akan memberi kita kesempatan untuk bekerja hanya pada menit terakhir.  Dalam praktiknya, cukup untuk dapat bekerja dengan menit saat ini dan sebelumnya jika ada pembaruan yang terlambat.  Untuk mempermudah, kami tidak akan mempertimbangkan kasus ini. <br><br><h3>  Fungsi Agregat </h3><br>  Di bawah ini adalah fungsi agregat yang diperlukan.  Saya mengambilnya sebanyak mungkin untuk menambah beban pada layanan: <br><br><ul><li>  harga tinggi - maksimum - harga maksimum per menit. </li><li>  low - min price - harga minimum per menit. </li><li>  firstHarga - harga pertama - harga pertama per menit. </li><li>  lastPrice - harga terakhir - harga terakhir per menit. </li><li>  Ukuran pertama - ukuran pertama - ukuran kesepakatan pertama dalam satu menit. </li><li>  lastSize - ukuran terakhir - ukuran kesepakatan terakhir dalam satu menit. </li><li>  numTrades - hitung i - jumlah transaksi per menit. </li><li>  volume - jumlah ukuran - jumlah ukuran transaksi per menit. </li><li>  pvolume - harga jumlah - jumlah harga per menit, diperlukan untuk rata-rata Harga. </li><li>  omset - harga jumlah * ukuran - total volume transaksi per menit. </li><li>  avgPrice - pvolume% numTades - harga rata-rata per menit. </li><li>  avgSize - volume% numTrades - ukuran kesepakatan rata-rata per menit. </li><li>  vwap - omset% volume - harga rata-rata per menit yang dihitung berdasarkan ukuran transaksi. </li><li>  cumVolume - jumlah volume - akumulasi ukuran transaksi sepanjang waktu. </li></ul><br>  Segera bahas satu hal yang tidak jelas - bagaimana menginisialisasi kolom ini untuk pertama kali dan setiap menit berikutnya.  Beberapa kolom tipe firstPrice perlu diinisialisasi dengan null setiap kali, nilainya tidak didefinisikan.  Jenis volume lainnya harus selalu disetel ke 0. Masih ada kolom yang memerlukan pendekatan gabungan - misalnya, cumVolume harus disalin dari menit sebelumnya, dan untuk set pertama ke 0. Kami akan mengatur semua parameter ini menggunakan kamus tipe data (analog dari catatan): <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// list ! list –  , 0n – float null, 0N – long null, `sym –  , `sym1`sym2 –   initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;00:00;0n;0n;0n;0n;0N;0N;0;0;0.0;0.0;0n;0n;0n;0); aggCols:reverse key[initWith] except `sym`time; //    , reverse  </span></span></code> </pre> <br>  Saya menambahkan sym dan waktu ke kamus untuk kenyamanan, sekarang initWith adalah garis jadi dari tabel agregat akhir, di mana ia tetap untuk mengatur sym dan waktu yang benar.  Anda bisa menggunakannya untuk menambahkan baris baru ke tabel. <br><br>  aggCols yang kita butuhkan saat membuat fungsi agregat.  Daftar harus terbalik karena kekhasan urutan di mana ekspresi dihitung dalam Q (dari kanan ke kiri).  Tujuannya adalah untuk memberikan perhitungan dalam arah dari tinggi ke cumVolume, karena beberapa kolom bergantung pada yang sebelumnya. <br><br>  Kolom yang akan disalin ke menit baru dari yang sebelumnya, kolom sym ditambahkan untuk kenyamanan: <br><br><pre> <code class="cpp hljs">rollColumns:`sym`cumVolume;</code> </pre><br>  Sekarang kami membagi kolom ke dalam kelompok sesuai dengan bagaimana mereka harus diperbarui.  Tiga jenis dapat dibedakan: <br><br><ol><li>  Baterai (volume, turnover, ..) - kita harus menambahkan nilai input ke yang sebelumnya. </li><li>  Dengan titik khusus (tinggi, rendah, ..) - nilai pertama dalam satu menit diambil dari data input, sisanya dihitung menggunakan fungsi. </li><li>  Sisanya.  Selalu dihitung menggunakan fungsi. </li></ol><br>  Tentukan variabel untuk kelas-kelas ini: <br><br><pre> <code class="cpp hljs">accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize;</code> </pre><br><h3>  Pesanan perhitungan </h3><br>  Kami akan memperbarui tabel teragregasi dalam dua tahap.  Untuk efisiensi, pertama-tama kita akan mengecilkan tabel yang masuk sehingga ada satu baris tersisa untuk setiap karakter dan menit.  Fakta bahwa semua fungsi kita bersifat inkremental dan asosiatif menjamin kita bahwa hasil dari langkah tambahan ini tidak akan berubah.  Anda bisa memeras tabel menggunakan pilih: <br><br><pre> <code class="cpp hljs">select high:max price, low:min price … by sym,time.minute from table</code> </pre><br>  Metode ini memiliki minus - set kolom yang dihitung sudah ditentukan sebelumnya.  Untungnya, di Q, pemilihan juga diterapkan sebagai fungsi di mana Anda dapat mengganti argumen yang dibuat secara dinamis: <br><br><pre> <code class="cpp hljs">?[table;whereClause;byClause;selectClause]</code> </pre><br>  Saya tidak akan menjelaskan secara terperinci format argumen, dalam kasus kami hanya dengan dan pilih ekspresi yang tidak sepele dan mereka harus kamus dari kolom formulir! Ekspresi.  Dengan demikian, fungsi pembatas dapat didefinisikan sebagai berikut: <br><br><pre> <code class="cpp hljs">selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// each   map  Q    preprocess:?[;();`sym`time!`sym`time.minute;selExpression];</span></span></code> </pre><br>  Untuk kejelasan, saya menggunakan fungsi parse, yang mengubah string dengan ekspresi Q menjadi nilai yang dapat diteruskan ke fungsi eval dan yang diperlukan dalam fungsi pilih.  Perhatikan juga bahwa preprocess didefinisikan sebagai proyeksi (mis., Fungsi dengan argumen yang didefinisikan sebagian) dari fungsi yang dipilih, satu argumen (tabel) tidak ada.  Jika kami menerapkan preprocess ke sebuah tabel, kami mendapatkan tabel yang menyusut. <br><br>  Tahap kedua adalah memperbarui tabel agregat.  Pertama, kita menulis algoritma di pseudocode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each sym in inputTable idx: row index in agg table <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym+currentTime; aggTable[idx;`high]: aggTable[idx;`high] | inputTable[sym;`high]; aggTable[idx;`volume]: aggTable[idx;`volume] + inputTable[sym;`volume]; …</code> </pre><br>  Dalam Q, alih-alih loop, biasanya menggunakan peta / mengurangi fungsi.  Tetapi karena Q adalah bahasa vektor dan semua operasi, kita dapat dengan aman menerapkan semua simbol sekaligus, kemudian sebagai perkiraan pertama yang dapat kita lakukan tanpa siklus sama sekali, melakukan operasi dengan semua simbol sekaligus: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; row:aggTable idx; aggTable[idx;`high]: row[`high] | inputTable`high; aggTable[idx;`volume]: row[`volume] + inputTable`volume; …</code> </pre><br>  Tapi kita bisa melangkah lebih jauh, di Q ada operator yang unik dan sangat kuat - operator penugasan umum.  Ini memungkinkan Anda untuk mengubah set nilai dalam struktur data yang kompleks menggunakan daftar indeks, fungsi, dan argumen.  Dalam kasus kami, tampilannya seperti ini: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; rows:aggTable idx; <span class="hljs-comment"><span class="hljs-comment">// .[target;(idx0;idx1;..);function;argument] ~ target[idx 0;idx 1;…]: function[target[idx 0;idx 1;…];argument],     –   .[aggTable;(idx;aggCols);:;flip (row[`high] | inputTable`high;row[`volume] + inputTable`volume;…)];</span></span></code> </pre><br>  Sayangnya, untuk menetapkan ke tabel Anda perlu daftar baris, bukan kolom, dan Anda harus mengubah matriks (daftar kolom menjadi daftar baris) menggunakan fungsi flip.  Untuk tabel besar, ini tidak perlu, jadi alih-alih kami menerapkan penetapan umum untuk setiap kolom secara terpisah, menggunakan fungsi peta (yang terlihat seperti tanda kutip): <br><br><pre> <code class="sql hljs">.[aggTable;;:;]'[(idx;)each aggCols; (row[`high] | inputTable`high;row[`volume] + inputTable`volume;…)];</code> </pre><br>  Kami kembali menggunakan fungsi proyeksi.  Perhatikan juga bahwa di Q, membuat daftar juga merupakan fungsi dan kita dapat menyebutnya menggunakan fungsi masing-masing (peta) untuk mendapatkan daftar daftar. <br><br>  Agar kumpulan kolom yang dihitung tidak tetap, buat ekspresi di atas secara dinamis.  Pertama, kami mendefinisikan fungsi untuk menghitung setiap kolom, menggunakan variabel baris dan inp untuk referensi yang dikumpulkan dan memasukkan data: <br><br><pre> <code class="cpp hljs">aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume! (<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>);</code> </pre><br>  Beberapa kolom khusus, nilai pertamanya tidak boleh dihitung oleh suatu fungsi.  Kita dapat menentukan bahwa ini adalah yang pertama di baris kolom [`numTrades] - jika memiliki 0, maka nilainya adalah yang pertama.  Q memiliki fungsi pemilihan -? [Daftar Boolean; list1; list2] - yang memilih nilai dari daftar 1 atau 2 tergantung pada kondisi dalam argumen pertama: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// high -&gt; ?[isFirst;inp`high;row[`high]|inp`high] // @ -         @[`aggExpression;specialCols;{[x;y]"?[isFirst;inp`",y,";",x,"]"};string specialCols];</span></span></code> </pre><br>  Di sini saya memanggil tugas umum dengan fungsi saya (ekspresi dalam kurung kurawal).  Nilai saat ini (argumen pertama) dan argumen tambahan, yang saya sampaikan di parameter ke-4, diteruskan ke sana. <br><br>  Secara terpisah, kami menambahkan speaker baterai, karena bagi mereka fungsinya sama: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// volume -&gt; row[`volume]+inp`volume aggExpression[accumulatorCols]:{"row[`",x,"]+inp`",x } each string accumulatorCols;</span></span></code> </pre><br>  Ini adalah penugasan biasa dengan standar Q, saya hanya menetapkan daftar nilai sekaligus.  Akhirnya, buat fungsi utama: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ":",/:aggExprs ~ map[{":",x};aggExpr] =&gt; ":row[`high]|inp`high"    ,          // string[cols],'exprs ~ map[,;string[cols];exprs] =&gt; "high:row[`high]|inp`high"   . ,'   map[concat] // ";" sv exprs – String from Vector (sv),     “;”  updateAgg:value "{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;(",(";"sv string[aggCols],'":",/:aggExpression aggCols),")]}";</span></span></code> </pre><br>  Dengan ungkapan ini, saya secara dinamis membuat fungsi dari string yang berisi ekspresi yang saya kutip di atas.  Hasilnya akan terlihat seperti ini: <br><br><pre> <code class="sql hljs">{[aggTable;idx;inp] rows:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols ;(cumVolume:row[`cumVolume]+inp`cumVolume;… ; high:?[isFirst;inp`high;row[`high]|inp`high])]}</code> </pre><br>  Urutan perhitungan kolom terbalik, karena dalam Q urutan perhitungan dari kanan ke kiri. <br><br>  Sekarang kami memiliki dua fungsi utama yang diperlukan untuk perhitungan, tetap menambahkan sedikit infrastruktur dan layanan siap. <br><br><h3>  Langkah terakhir </h3><br>  Kami memiliki fungsi preprocess dan updateAgg yang melakukan semua pekerjaan.  Tetapi masih perlu untuk memastikan transisi yang benar dalam hitungan menit dan menghitung indeks untuk agregasi.  Pertama kita mendefinisikan fungsi init: <br><br><pre> <code class="cpp hljs">init:{ tradeAgg:: <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-meta"><span class="hljs-meta">#enlist[initWith]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    , enlist    ,  0#   0    currTime::00:00; //   0, :: ,      currSyms::`u#`symbol$(); // `u# -    ,     offset::0; //   tradeAgg,     rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; //     roll ,    sym }</span></span></span></span></code> </pre><br>  Kami juga menetapkan fungsi roll, yang akan mengubah menit saat ini: <br><br><pre> <code class="cpp hljs">roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; <span class="hljs-comment"><span class="hljs-comment">//    ,    init rollCache,::offset _ rollColumns#tradeAgg; //   –  roll   aggTable, ,   rollCache offset::count tradeAgg; currSyms::`u#`$(); }</span></span></code> </pre><br>  Kami membutuhkan fungsi untuk menambahkan karakter baru: <br><br><pre> <code class="java hljs">addSyms:{[syms] currSyms,::syms; <span class="hljs-comment"><span class="hljs-comment">//     //    sym, time  rollColumns   . //  ^      roll ,     . value flip table     . `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime), (initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }</span></span></code> </pre><br>  Dan akhirnya, fungsi pembaruan (nama tradisional fungsi ini untuk layanan Q), yang dipanggil oleh klien, untuk menambahkan data: <br><br><pre> <code class="cpp hljs">upd:{[tblName;data] <span class="hljs-comment"><span class="hljs-comment">// tblName   ,       tm:exec distinct time from data:() xkey preprocess data; // preprocess &amp; calc time updMinute[data] each tm; //      }; updMinute:{[data;tm] if[tm&lt;&gt;currTime; roll tm; currTime::tm]; //  ,   data:select from data where time=tm; //  if[count msyms:syms where not (syms:data`sym)in currSyms; addSyms msyms]; //   updateAgg[`tradeAgg;offset+currSyms?syms;data]; //   .  ?        . };</span></span></code> </pre><br>  Itu saja.  Berikut adalah kode lengkap layanan kami, seperti yang dijanjikan, hanya beberapa baris: <br><br><pre> <code class="cpp hljs">initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>); aggCols:reverse key[initWith] except `sym`time; rollColumns:`sym`cumVolume; accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize; selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; preprocess:?[;();`sym`time!`sym`time.minute;selExpression]; aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume!(<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>); @[`aggExpression;specialCols;{<span class="hljs-string"><span class="hljs-string">"?[isFirst;inp`"</span></span>,y,<span class="hljs-string"><span class="hljs-string">";"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]"</span></span>};<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> specialCols]; aggExpression[accumulatorCols]:{<span class="hljs-string"><span class="hljs-string">"row[`"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]+inp`"</span></span>,x } each <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> accumulatorCols; updateAgg:value <span class="hljs-string"><span class="hljs-string">"{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;("</span></span>,(<span class="hljs-string"><span class="hljs-string">";"</span></span>sv <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[aggCols],<span class="hljs-string"><span class="hljs-string">'":",/:aggExpression aggCols),")]}"; / '</span></span> init:{ tradeAgg::<span class="hljs-number"><span class="hljs-number">0</span></span>#enlist[initWith]; currTime::<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>; currSyms::`u#`symbol$(); offset::<span class="hljs-number"><span class="hljs-number">0</span></span>; rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; }; roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; rollCache,::offset _ rollColumns#tradeAgg; offset::count tradeAgg; currSyms::`u#`$(); }; addSyms:{[syms] currSyms,::syms; `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime),(initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }; upd:{[tblName;data] updMinute[data] each exec distinct time from data:() xkey preprocess data}; updMinute:{[data;tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[tm&lt;&gt;currTime; roll tm; currTime::tm]; data:select from data where time=tm; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[count msyms:syms where <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (syms:data`sym)in currSyms; addSyms msyms]; updateAgg[`tradeAgg;offset+currSyms?syms;data]; };</code> </pre><br><h3>  Pengujian </h3><br>  Periksa kinerja layanan.  Untuk melakukan ini, jalankan dalam proses terpisah (masukkan kode dalam file service.q) dan panggil fungsi init: <br><br><pre> <code class="plaintext hljs">q service.q –p 5566 q)init[]</code> </pre><br>  Di konsol lain, mulai proses Q kedua dan sambungkan ke yang pertama: <br><br><pre> <code class="cpp hljs">h:hopen `:host:<span class="hljs-number"><span class="hljs-number">5566</span></span> h:hopen <span class="hljs-number"><span class="hljs-number">5566</span></span> <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  Pertama, buat daftar karakter - 10.000 lembar dan tambahkan fungsi untuk membuat tabel acak.  Di konsol kedua: <br><br><pre> <code class="cpp hljs">syms:`IBM`AAPL`GOOG,<span class="hljs-number"><span class="hljs-number">-9997</span></span>?`<span class="hljs-number"><span class="hljs-number">8</span></span> rnd:{[n;t] ([] sym:n?syms; time:t+asc n#til <span class="hljs-number"><span class="hljs-number">25</span></span>; price:n?<span class="hljs-number"><span class="hljs-number">10f</span></span>; size:n?<span class="hljs-number"><span class="hljs-number">10</span></span>)}</code> </pre><br>  Saya menambahkan tiga karakter nyata ke daftar karakter untuk membuatnya lebih mudah untuk mencarinya di tabel.  Fungsi rnd membuat tabel acak dengan n rows, di mana waktu bervariasi dari t hingga t + 25 milidetik. <br><br>  Sekarang Anda dapat mencoba mengirim data ke layanan (tambahkan sepuluh jam pertama): <br><br><pre> <code class="cpp hljs">{h (`upd;`trade;rnd[<span class="hljs-number"><span class="hljs-number">10000</span></span>;x])} each `time$<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> + til <span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Anda dapat memeriksa dalam layanan bahwa tabel telah diperbarui: <br><br><pre> <code class="cpp hljs">\c <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> select from tradeAgg where sym=`AAPL <span class="hljs-number"><span class="hljs-number">-20</span></span>#select from tradeAgg where sym=`AAPL</code> </pre><br>  Hasil: <br><br><pre> <code class="1c hljs">sym<span class="hljs-string"><span class="hljs-string">|time|high|low|firstPrice|lastPrice|firstSize|lastSize|numTrades|volume|pvolume|turnover|avgPrice|avgSize|vwap|cumVolume --|--|--|--|--|-------------------------------- AAPL|09:27|9.258904|9.258904|9.258904|9.258904|8|8|1|8|9.258904|74.07123|9.258904|8|9.258904|2888 AAPL|09:28|9.068162|9.068162|9.068162|9.068162|7|7|1|7|9.068162|63.47713|9.068162|7|9.068162|2895 AAPL|09:31|4.680449|0.2011121|1.620827|0.2011121|1|5|4|14|9.569556|36.84342|2.392389|3.5|2.631673|2909 AAPL|09:33|2.812535|2.812535|2.812535|2.812535|6|6|1|6|2.812535|16.87521|2.812535|6|2.812535|2915 AAPL|09:34|5.099025|5.099025|5.099025|5.099025|4|4|1|4|5.099025|20.3961|5.099025|4|5.099025|2919</span></span></code> </pre> <br>  Kami sekarang akan melakukan pengujian beban untuk mengetahui berapa banyak data yang dapat diproses layanan per menit.  Biarkan saya mengingatkan Anda bahwa kami menetapkan interval untuk pembaruan menjadi 25 milidetik.  Oleh karena itu, suatu layanan harus (rata-rata) sesuai dengan setidaknya 20 milidetik per pembaruan untuk memberi pengguna waktu untuk meminta data.  Masukkan yang berikut ini di proses kedua: <br><br><pre> <code class="cpp hljs">tm:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.000</span></span> stressTest:{[n] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[tm],<span class="hljs-string"><span class="hljs-string">" "</span></span>; times,::h ({st:.zT; upd[`trade;x]; .zT-st};rnd[n;tm]); tm+:<span class="hljs-number"><span class="hljs-number">25</span></span>} start:{[n] times::(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>[<span class="hljs-number"><span class="hljs-number">4800</span></span>;stressTest[n]]; <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>; `min`avg`med`max!(min times;avg times;med times;max times)}</code> </pre><br>  4800 adalah dua menit.  Anda dapat mencoba memulai lebih dari 1000 baris setiap 25 milidetik: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre><br>  Dalam kasus saya, hasilnya adalah sekitar beberapa milidetik per pembaruan.  Jadi saya akan segera menambah jumlah baris menjadi 10.000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">10000</span></span></code> </pre><br>  Hasil: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.004</span></span> avg| <span class="hljs-number"><span class="hljs-number">9.191458</span></span> med| <span class="hljs-number"><span class="hljs-number">9f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.030</span></span></code> </pre><br>  Sekali lagi, tidak ada yang istimewa, tetapi ini adalah 24 juta baris per menit, 400 ribu per detik.  Selama lebih dari 25 milidetik, pembaruan melambat hanya 5 kali, tampaknya saat mengubah menit.  Tingkatkan menjadi 100.000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">100000</span></span></code> </pre><br>  Hasil: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.013</span></span> avg| <span class="hljs-number"><span class="hljs-number">25.11083</span></span> med| <span class="hljs-number"><span class="hljs-number">24f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.108</span></span> q)sum times <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">02</span></span>:<span class="hljs-number"><span class="hljs-number">00.532</span></span></code> </pre><br>  Seperti yang Anda lihat, layanan ini hampir tidak bisa, tetapi tetap berhasil bertahan.  Jumlah data ini (240 juta baris per menit) sangat besar, dalam kasus seperti itu biasa menjalankan beberapa klon (atau bahkan puluhan klon) dari layanan, yang masing-masing hanya memproses sebagian karakter.  Namun demikian, hasilnya mengesankan untuk bahasa yang ditafsirkan, yang terutama difokuskan pada penyimpanan data. <br><br>  Mungkin timbul pertanyaan, mengapa waktu tumbuh non-linear dengan ukuran setiap pembaruan.  Alasannya adalah bahwa fungsi pemerasan sebenarnya adalah fungsi C yang bekerja jauh lebih efisien daripada updateAgg.  Dimulai dengan beberapa ukuran pembaruan (sekitar 10.000), pembaruanAgg mencapai puncaknya dan kemudian waktu pelaksanaannya tidak tergantung pada ukuran pembaruan.  Ini karena langkah awal Q bahwa layanan ini dapat mencerna volume data seperti itu.  Ini menekankan betapa pentingnya ketika bekerja dengan data besar untuk memilih algoritma yang tepat.  Poin lainnya adalah penyimpanan data yang benar dalam memori.  Jika data tidak disimpan dalam kolom atau tidak dipesan berdasarkan waktu, maka kita akan berkenalan dengan hal seperti miss cache TLB - tidak adanya alamat halaman memori dalam cache alamat prosesor.  Menemukan alamat membutuhkan waktu sekitar 30 kali lebih lama jika terjadi kegagalan dan dalam kasus data yang tersebar dapat memperlambat layanan beberapa kali. <br><br><h3>  Kesimpulan </h3><br>  Dalam artikel ini, saya menunjukkan bahwa basis data KDB + dan Q cocok tidak hanya untuk menyimpan data besar dan akses mudah ke mereka melalui pilih, tetapi juga untuk membuat layanan pemrosesan data yang dapat mencerna ratusan juta baris / gigabyte data bahkan dalam satu proses Q tunggal .  Bahasa Q itu sendiri memungkinkan penerapan algoritma yang berhubungan dengan pemrosesan data yang sangat singkat dan efisien karena sifat vektornya, penafsir bawaan dari dialek SQL, dan serangkaian fungsi perpustakaan yang sangat berhasil. <br><br>  Saya akan perhatikan bahwa di atas hanya sebagian dari kemampuan Q, ia memiliki fitur unik lainnya.  Misalnya, protokol IPC yang sangat sederhana yang menghapus batas antara proses Q individual dan memungkinkan Anda untuk menggabungkan ratusan proses ini ke dalam jaringan tunggal, yang dapat ditemukan di lusinan server di berbagai belahan dunia. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470596/">https://habr.com/ru/post/id470596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470578/index.html">Bagaimana kami "memanusiakan" pembukuan di bank seluler</a></li>
<li><a href="../id470582/index.html">Memeriksa Telerik UI untuk UWP sebagai Cara Memulai dengan PVS-Studio</a></li>
<li><a href="../id470584/index.html">Periksa Telerik UI untuk UWP untuk berkenalan dengan PVS-Studio</a></li>
<li><a href="../id470592/index.html">Ulasan Plesk - hosting dan panel kontrol situs</a></li>
<li><a href="../id470594/index.html">Laporan dari pertunjukan cahaya "Lingkaran Cahaya" 2019 di Moskow</a></li>
<li><a href="../id470598/index.html">Buku "Jawa Modern. Ekspresi Lambda, Streaming, dan Pemrograman Fungsional ”</a></li>
<li><a href="../id470600/index.html">Tentang konsol noVNC aman, penskalaan di Kubernetes, Haproxy di Ostrovka, dan karya admin dengan programmer</a></li>
<li><a href="../id470602/index.html">Seperti apa metro Moskow di dunia tiga dimensi</a></li>
<li><a href="../id470604/index.html">Kecepatan pemuatan situs dalam e-commerce: analisis 48 toko online top di Rusia</a></li>
<li><a href="../id470608/index.html">Optimasi UI Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>