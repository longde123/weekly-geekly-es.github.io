<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîá üõÅ ‚õ™Ô∏è Erfahrung mit WebRTC. Yandex Vortrag üßôüèΩ üöÆ üôÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist bei der Entwicklung von Software besser - native oder Web-Technologien? Holivar zu diesem Thema wird nicht bald enden, aber nur wenige werden ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erfahrung mit WebRTC. Yandex Vortrag</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/419951/">  Was ist bei der Entwicklung von Software besser - native oder Web-Technologien?  Holivar zu diesem Thema wird nicht bald enden, aber nur wenige werden argumentieren, dass es n√ºtzlich ist, native Funktionen f√ºr die Verwendung in Browsern oder WebView zu duplizieren.  Und wenn Anwendungen f√ºr Anrufe fr√ºher ausschlie√ülich getrennt vom Browser existierten, sind sie jetzt einfach im Web zu implementieren.  Entwickler Grigory Kuznetsov erkl√§rte, wie die WebRTC-Technologie f√ºr P2P-Verbindungen verwendet wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_Jvdi--GtOg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Wie Sie alle wissen, gibt es in den letzten Jahren eine ganze Reihe von Anwendungen, die auf dem direkten Datenaustausch zwischen zwei Browsern basieren, dh P2P.  Dies sind alle Arten von Instant Messenger, Chats, Dialern und Videokonferenzen.  Es k√∂nnen auch Anwendungen sein, die eine Art verteiltes Rechnen ausf√ºhren.  Die Grenzen der Fantasie sind in keiner Weise begrenzt. <br><a name="habracut"></a><br>  Wie machen wir eine solche Technologie?  Stellen Sie sich vor, wir m√∂chten von einem Browser zum anderen telefonieren.  Und stellen Sie sich vor, welche Schritte wir brauchen, um dieses Ziel zu erreichen.  Zun√§chst scheint es, dass der Anruf unser Bild, unsere Stimme, unser Bild ist und wir Zugang zu den an den Computer angeschlossenen Medienger√§ten erhalten m√ºssen: zur Kamera und zum Mikrofon.  Nachdem Sie Zugriff erhalten haben, ben√∂tigen Sie Ihre beiden Browser, zwei Clients, um sich zu finden.  Es ist notwendig, ihnen zu helfen, sich irgendwie zu verbinden, zu erreichen und Metainformationen zu vermitteln. <br><br>  Wenn Sie erreichen, m√ºssen Sie mit der Daten√ºbertragung im P2P-Modus beginnen, um die √úbertragung von Medienstr√∂men sicherzustellen.  Wir haben alle notwendigen Dinge, wir sind bereit, unser cooles neues Fahrrad zu implementieren.  Aber das ist ein Witz, wir sind Ingenieure und wir verstehen, dass es teuer, ungerechtfertigt und riskant ist.  Lassen Sie uns als klassische Ingenieure zun√§chst dar√ºber nachdenken, welche L√∂sungen bereits existieren. <br><br>  Zuallererst die alte aussterbende Adobe Flash-Technologie.  Sie stirbt wirklich und Adobe wird es bis 2020 nicht mehr unterst√ºtzen.  Mit dieser Technologie k√∂nnen Sie wirklich auf Ihre Medienger√§te zugreifen. In ihr k√∂nnen Sie alle erforderlichen Mechanismen implementieren, um den Browsern die Verbindung zu erleichtern, sodass sie P2P-Informationen √ºbertragen k√∂nnen. Sie werden Ihr Fahrrad jedoch erneut erfinden, da es keinen einzigen Standard gibt, sondern nur einen einzigen Ansatz f√ºr die Implementierung dieser Methode Daten√ºbertragung. <br><br>  Sie k√∂nnen ein Browser-Plugin schreiben.  So funktioniert Skype f√ºr Browser, die keine moderneren Technologien unterst√ºtzen.  Sie m√ºssen Ihr Fahrrad implementieren, da es keinen einzigen Standard gibt und es auch f√ºr Benutzer schlecht ist, da der Benutzer eine Art Plug-In in seinem Browser installieren und zus√§tzliche Aktionen ausf√ºhren muss.  Benutzer m√∂gen dies nicht und wollen es nicht tun. <br><br>  Und es gibt WebRTC-Technologie - Google Hangouts und Facebook Messenger arbeiten damit.  Voximplant verwendet es, damit Sie Ihre Anrufe t√§tigen k√∂nnen.  Lassen Sie uns n√§her darauf eingehen.  Dies ist eine neue Entwicklungstechnologie, die 2011 erschien und sich weiterentwickelt.  Was erlaubt sie zu tun?  Erhalten Sie Zugang zu Kamera und Mikrofon.  Stellen Sie eine P2P-Verbindung zwischen zwei Computern und zwei Browsern her.  Nat√ºrlich k√∂nnen Sie Medienstr√∂me in Echtzeit √ºbertragen.  Dar√ºber hinaus k√∂nnen Sie Informationen √ºbertragen, dh jedes bin√§re Datum, Sie k√∂nnen auch P2P √ºbertragen, Sie k√∂nnen Ihr eigenes verteiltes Computersystem erstellen. <br><br>  Ein wichtiger Punkt: WebRTC bietet Browsern keine M√∂glichkeit, sich gegenseitig zu finden.  Wir k√∂nnen alle notwendigen Metainformationen √ºber unsere Lieben generieren, aber wie kann ein Browser etwas √ºber die Existenz eines anderen erfahren?  Wie verbinde ich sie?  Betrachten Sie ein Beispiel. <br><br><img src="https://habrastorage.org/webt/8l/dc/lu/8ldclukfmmhiyusud1ftwkmvmi0.png"><br><br>  Es gibt zwei Kunden.  Der erste Client m√∂chte den zweiten Client anrufen.  WebRTC bietet Ihnen alle Informationen, die Sie ben√∂tigen, um sich zu identifizieren.  Es bleibt jedoch die Frage, wie man einen anderen Browser findet, wie man diese Metainformationen sendet und wie man den Anruf initialisiert.  Dies bleibt den Entwicklern √ºberlassen, wir k√∂nnen absolut jede Methode anwenden, diese Metainformationen nehmen, auf ein St√ºck Papier drucken, per Kurier senden, ein anderer wird sie verwenden und alles wird funktionieren. <br><br>  Und wir k√∂nnen uns einen Signalmechanismus ausdenken.  In diesem Fall handelt es sich um einen Mechanismus von Drittanbietern, mit dem wir, wenn wir √ºber unsere Kunden Bescheid wissen, sicherstellen k√∂nnen, dass einige Informationen, die zum Herstellen einer Verbindung erforderlich sind, zwischen ihnen √ºbertragen werden. <br><br>  Betrachten Sie ein Beispiel mit einem Signalserver.  Es gibt einen Signalserver, der eine st√§ndige Verbindung zu unseren Clients aufrechterh√§lt, beispielsweise √ºber Web-Sockets oder √ºber HTTP.  Der erste Client generiert Metainformationen und sendet diese √ºber Web-Sockets oder HTTP an den Signalserver.  Es sendet auch einen Teil der Informationen, mit denen es eine Verbindung herstellen m√∂chte, z. B. einen Spitznamen oder andere Informationen. <br><br>  Der Signalserver, der diese Kennung verwendet, bestimmt, welcher Client unsere Metainformationen umleiten muss, und leitet sie weiter.  Der zweite Client nimmt es, verwendet es, installiert sich selbst, bildet eine Antwort und sendet es mithilfe des Signalisierungsmechanismus an den Signalserver, der es wiederum an den ersten Client weiterleitet.  Somit verf√ºgen beide Clients derzeit √ºber alle erforderlichen Datums- und Metainformationen, um eine P2P-Verbindung herzustellen.  Fertig. <br><br>  Schauen wir uns genau an, was die Clients austauschen: Sie tauschen ein SDP-Datagramm, Session Description Protocol, aus. <br><br><img src="https://habrastorage.org/webt/zl/e-/ok/zle-oknfv3cz36cwgdbt00ldc4q.png"><br><br>  Dies ist im Wesentlichen eine Textdatei, die alle erforderlichen Informationen zum Herstellen einer Verbindung enth√§lt.  Es gibt Informationen √ºber die IP-Adresse, √ºber die verwendeten Ports, dar√ºber, welche Art von Informationen zwischen Clients verfolgt werden, was es ist - Audio, Video, welche Codecs verwendet werden.  Alles was wir brauchen ist da. <br><br>  Achten Sie auf die zweite Zeile.  Es zeigt die IP-Adresse des Clients, 192.168.0.15.  Dies ist offensichtlich die IP-Adresse eines Computers, der sich in einem lokalen Netzwerk befindet.  Wenn wir zwei Computer haben, von denen sich jeder im lokalen Netzwerk befindet und von denen jeder seine IP-Adresse in diesem Netzwerk kennt, m√∂chten sie anrufen.  Werden sie dies mit einem solchen Datagramm tun k√∂nnen?  Offensichtlich nicht, sie kennen die externen IP-Adressen nicht.  Wie man ist <br><br><img src="https://habrastorage.org/webt/6j/ol/xu/6jolxumekywnyr1txfh6vdhjk-a.png"><br><br>  Lassen Sie uns beiseite treten und sehen, wie NAT funktioniert.  Im Internet sind viele Computer hinter Routern versteckt.  Es gibt lokale Netzwerke, in denen Computer ihre Adressen kennen, es gibt einen Router mit einer externen IP-Adresse, und alle diese Computer weisen die IP-Adresse dieses Routers auf.  Wenn ein Paket von einem Computer im lokalen Netzwerk an den Router gesendet wird, √ºberpr√ºft der Router, wohin es weitergeleitet werden soll.  Wenn er sich in einem anderen dieser lokalen Netzwerke befindet, leitet er es einfach weiter. Wenn Sie es nach drau√üen ins Internet senden m√ºssen, wird eine Routing-Tabelle erstellt. <br><br><img src="https://habrastorage.org/webt/0c/w3/vj/0cw3vj67zemxzrbjwe5cr0bfzvc.png"><br><br>  Wir geben die interne IP-Adresse des Computers ein, der das Paket weiterleiten m√∂chte, seinen Port, legen die externe IP-Adresse und die IP-Adresse des Routers fest und f√ºhren auch eine Port√§nderung durch.  Wof√ºr ist es?  Stellen Sie sich vor, zwei Computer greifen auf dieselbe Ressource zu, und wir m√ºssen die Antwortpakete korrekt weiterleiten.  Wir werden sie anhand des Ports identifizieren. Der Port ist f√ºr jeden Computer eindeutig, w√§hrend die externe IP-Adresse √ºbereinstimmt. <br><br>  Wie kann man leben, wenn es NAT gibt, wenn Computer unter derselben IP-Adresse herausragen, sich aber im Inneren voneinander kennen? <br><br>  Das ICE-Framework f√ºr die Einrichtung der Internetverbindung hilft dabei.  Es werden M√∂glichkeiten beschrieben, NAT zu umgehen und eine Verbindung herzustellen, wenn NAT vorhanden ist. <br><br>  Dieses Framework verwendet das sogenannte STUN-Serverattribut. <br><br><img src="https://habrastorage.org/webt/59/zv/am/59zvamcoxdislwvhlj3qkn2k_cq.png"><br><br>  Dies ist ein so spezieller Server, auf den Sie Ihre externe IP-Adresse herausfinden k√∂nnen.  Daher muss jeder Client beim Herstellen einer P2P-Verbindung eine Anfrage an diesen STUN-Server stellen, um seine IP-Adresse herauszufinden und zus√§tzliche Informationen zu generieren, IceCandidate und IceCandidate mit dem Signalisierungsmechanismus auszutauschen.  Dann kennen sich die Clients mit den richtigen IP-Adressen und k√∂nnen eine P2P-Verbindung herstellen. <br><br>  Es gibt jedoch kompliziertere F√§lle.  Zum Beispiel, wenn der Computer hinter Double NAT versteckt ist.  In diesem Fall erfordert das ICE-Framework die Verwendung eines TURN-Servers. <br><br><img src="https://habrastorage.org/webt/yd/0r/j3/yd0rj3j5touybbu9ji2yxajvu0w.png"><br><br>  Dies ist ein solcher spezieller Server, der eine Client-Client-Verbindung, P2P, in eine Client-Server-Client-Verbindung verwandelt, dh als Relay fungiert.  Die gute Nachricht f√ºr Entwickler ist, dass unabh√§ngig davon, zu welchem ‚Äã‚Äãder drei Szenarien die Verbindung hergestellt wurde, ob wir uns im lokalen Netzwerk befinden, ob wir uns an einen STUN- oder TURN-Server wenden m√ºssen, die API-Technologie f√ºr uns identisch ist.  Wir geben zu Beginn einfach die Konfiguration der ICE- und TURN-Server an, geben an, wie auf sie zugegriffen werden soll, und danach erledigt die Technologie alles f√ºr uns unter der Haube. <br><br><img src="https://habrastorage.org/webt/u5/gm/d3/u5gmd3hsoofg6zt_-gnop6nx0zs.png"><br><br>  Eine kurze Zusammenfassung.  Um eine Verbindung herzustellen, m√ºssen Sie einen Signalisierungsmechanismus ausw√§hlen und implementieren, einen bestimmten Vermittler, der uns beim Senden von Metainformationen hilft.  WebRTC wird uns daf√ºr alle notwendigen Meta geben. <br><br>  Wir m√ºssen mit NAT k√§mpfen, dies ist unser Hauptfeind in dieser Phase.  Um dies zu umgehen, verwenden wir den STUN-Server, um unsere externe IP-Adresse herauszufinden, und verwenden den TURN-Server als Relay. <br><br>  Was genau senden wir?  √úber Medienstr√∂me. <br><br><img src="https://habrastorage.org/webt/qd/5n/sh/qd5nsho7njp_zbptyvvgxzgyeyk.png"><br><br>  Medienstr√∂me sind Kan√§le, die Titel in sich enthalten.  Tracks innerhalb des Medienstroms werden synchronisiert.  Audio und Video werden nicht voneinander abweichen, sie werden mit einem einzigen Timing geliefert.  Sie k√∂nnen eine beliebige Anzahl von Spuren innerhalb des Medienstroms erstellen. Die Spuren k√∂nnen separat gesteuert werden. Sie k√∂nnen beispielsweise den Ton stummschalten und nur ein Bild hinterlassen.  Sie k√∂nnen auch eine beliebige Anzahl von Medienstr√∂men √ºbertragen, um beispielsweise eine Konferenz zu implementieren. <br><br>  Wie greife ich √ºber einen Browser auf Medien zu?  Lassen Sie uns √ºber die API sprechen. <br><br><img src="https://habrastorage.org/webt/xd/li/lw/xdlilwqq1hvfwsmpzbo2abyu22i.png"><br><br>  Es gibt eine getUserMedia-Methode, die eine Reihe von Konstanten als Eingabe akzeptiert.  Dies ist ein spezielles Objekt, in dem Sie angeben, auf welche Ger√§te Sie zugreifen m√∂chten, auf welche Kamera, auf welches Mikrofon.  Sie geben die Eigenschaften an, die Sie haben m√∂chten, welche Aufl√∂sung, und es gibt auch zwei Argumente - successCallback und errorCallback, die bei Erfolg oder Misserfolg aufgerufen werden.  Modernere Technologieimplementierungen verwenden Versprechen. <br><br>  Es gibt auch eine praktische enumerateDevices-Methode, die eine Liste aller an Ihren Computer angeschlossenen Medienger√§te zur√ºckgibt. Auf diese Weise k√∂nnen Sie sie dem Benutzer anzeigen und eine Art Auswahl zeichnen, damit der Benutzer die Kamera ausw√§hlt, die er verwenden m√∂chte. <br><br><img src="https://habrastorage.org/webt/ga/vp/uo/gavpuolkqqbou4mgkr5nkgyn_ga.png"><br><br>  Das zentrale Objekt in der API ist RTCPeerConnection.  Wenn wir die Verbindung herstellen, nehmen wir die RTCPeerConnection-Klasse, die das PeerConnection-Objekt zur√ºckgibt.  Als Konfiguration geben wir eine Reihe von ICE-Servern an, dh STUN- und TURN-Server, auf die wir w√§hrend des Installationsprozesses zugreifen.  Und es gibt ein wichtiges Ereignis, das jedes Mal ausgel√∂st wird, wenn wir die Hilfe unseres Signalmechanismus ben√∂tigen.  Das hei√üt, die WebRTC-Technologie hat beispielsweise eine Anfrage an einen STUN-Server gestellt. Wir haben unsere externe IP-Adresse erkannt, ein neuer ICEC-Kandidat wurde angezeigt, und wir m√ºssen ihn mithilfe eines Mechanismus eines Drittanbieters weiterleiten. Das Ereignis war st√§rker. <br><br><img src="https://habrastorage.org/webt/ou/lu/zp/ouluzpi6ahoovtpo1acf01pblbe.png"><br><br>  Wenn wir eine Verbindung herstellen und den Aufruf initialisieren m√∂chten, verwenden wir die Methode createOffer (), um das anf√§ngliche SDP zu bilden und SDP anzubieten, die gleichen Metainformationen, die an den Partner gesendet werden m√ºssen. <br><br>  Um es auf PeerConnection zu setzen, verwenden wir die Methode setLocalDescription ().  Der Gespr√§chspartner empf√§ngt diese Informationen √ºber den Signalisierungsmechanismus, setzt sie mithilfe der Methode setRemoteDescription () auf sich selbst und generiert mithilfe der Methode createAnswer () eine Antwort, die ebenfalls √ºber den Signalisierungsmechanismus an den ersten Client gesendet wird. <br><br><img src="https://habrastorage.org/webt/-z/tt/ns/-zttnspmlmdyfjgvn6koame5duw.png"><br><br>  Wenn wir Zugriff auf die Medien haben, den Medienstrom erhalten haben, √ºbertragen wir ihn mithilfe der addStream-Methode auf unsere P2P-Verbindung, und unser Gespr√§chspartner erf√§hrt davon, dass das Ereignis onaddstream abgeschnitten wurde.  Er wird unseren Stream empfangen und anzeigen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/e5/4m/ot/e54mot_c6nmcg60na7bj-k7kbro.png"><br><br>  Sie k√∂nnen auch mit Datenstr√∂men arbeiten.  Es ist der Bildung einer regul√§ren PeerConnection sehr √§hnlich. Geben Sie einfach RtpDataChannels: true an und rufen Sie die Methode createDataChannel () auf.  Ich werde nicht im Detail darauf eingehen, da solche Arbeiten der Arbeit mit Web-Sockets sehr √§hnlich sind. <br><br>  Ein paar Worte zur Sicherheit.  WebRTC funktioniert nur unter HTTPS. Ihre Site muss mit einem Zertifikat signiert sein.  Medienstr√∂me werden ebenfalls mit DTLS verschl√ºsselt.  Die Technologie erfordert keine zus√§tzliche Installation, keine Plug-Ins, und das ist gut so.  Und es wird nicht funktionieren, eine Spyware-Anwendung zu erstellen, die Site wird den Benutzer nicht belauschen oder ausspionieren, er wird dem Benutzer eine spezielle Eingabeaufforderung anzeigen, den Zugriff von ihm anfordern und diese nur erhalten, wenn der Benutzer den Zugriff auf Audio- und Medienger√§te zul√§sst. <br><br><img src="https://habrastorage.org/webt/4d/pf/mp/4dpfmps0b2axjq2kyrshvgf-xaa.png"><br><br>  Was die Browserunterst√ºtzung betrifft - IE bleibt und bleibt rot.  Ende letzten Jahres wurde die Safari-Unterst√ºtzung hinzugef√ºgt, dh alle modernen Browser k√∂nnen bereits mit dieser Technologie arbeiten und wir k√∂nnen sie sicher verwenden. <br><br>  Ich m√∂chte eine Reihe von Dienstprogrammen aller Art freigeben, die Ihnen bei der Arbeit mit WebRTC helfen.  Dies ist in erster Linie ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Adapter</a> .  Die Technologien entwickeln sich st√§ndig weiter und es gibt einen Unterschied bei den Browser-APIs.  Die Adapterbibliothek beseitigt diesen Unterschied und erleichtert die Arbeit.  Eine bequeme Bibliothek f√ºr die Arbeit mit Datenstr√∂men ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peerjs</a> .  Sie k√∂nnen sich auch die Open Source-Implementierungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Server</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STUN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TURN</a> ansehen.  Eine gro√üe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auswahl</a> an Tutorials, Beispielen und Artikeln befindet sich auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">awesome-webrtc-Seite</a> . Ich kann es nur empfehlen. <br><br>  Das letzte n√ºtzliche Tool zum Debuggen sind webrtc-internals.  W√§hrend der Entwicklung k√∂nnen Sie einen speziellen Befehl in die Adressleiste eingeben. Im Chrome-Browser ist dies beispielsweise Chrome: // webrtc-internals.  Sie sehen eine Seite mit allen Informationen zu Ihrer aktuellen WebRTC-Verbindung.  Es gibt Sequenzen von Aufrufen in Methoden und alle zwischen Browsern ausgetauschten Datagramme und Diagramme, die Ihre Verbindung irgendwie charakterisieren.  Im Allgemeinen werden alle Informationen vorhanden sein, die w√§hrend des Debuggens und der Entwicklung ben√∂tigt werden.  Vielen Dank f√ºr Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419951/">https://habr.com/ru/post/de419951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419941/index.html">Audiomania Office Fototour: Teil Eins</a></li>
<li><a href="../de419943/index.html">Was wir im Juli gelesen haben: Wie man Zeit zum Lesen findet, f√ºnf B√ºcher f√ºr Teamleiter und einige neue Artikel</a></li>
<li><a href="../de419945/index.html">So bereiten Sie sich auf ein Interview bei Google vor und geben es nicht weiter. Zweimal</a></li>
<li><a href="../de419947/index.html">Stellen Sie mit Raspbian Stretch Lite eine Verbindung zu PiZeroW her, ohne zus√§tzliche Adapter und einen Monitor</a></li>
<li><a href="../de419949/index.html">Welche Video-Codecs (nicht) verwenden Browser f√ºr Videoanrufe?</a></li>
<li><a href="../de419953/index.html">Ich schreibe ein Buch √ºber das erste ‚Äûunser‚Äú Startup, das die Welt erobert hat: Hilfe</a></li>
<li><a href="../de419955/index.html">Funktionen des FIFO-UART-Puffers in ESP32</a></li>
<li><a href="../de419961/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 265 (6. August - 12. August)</a></li>
<li><a href="../de419963/index.html">Wir stellen eine "intelligente" Steuerung f√ºr die Klimaanlage des ESP8266 her</a></li>
<li><a href="../de419965/index.html">Konfigurationsfunktionen f√ºr ExtremeXOS-Switches</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>