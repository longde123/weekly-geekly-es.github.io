<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèΩ ‚ûó üë©‚Äçüëß‚Äçüëß Manipulation spatiale 2D avec champs de distance sign√©s üèéÔ∏è ü§• ‚òÉÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lorsque vous travaillez avec des actifs polygonaux, vous ne pouvez dessiner qu'un seul objet √† la fois (si vous ne prenez pas en compte des techniques...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manipulation spatiale 2D avec champs de distance sign√©s</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439000/"> Lorsque vous travaillez avec des actifs polygonaux, vous ne pouvez dessiner qu'un seul objet √† la fois (si vous ne prenez pas en compte des techniques telles que le traitement par lots et l'instanciation), mais si vous utilisez des champs de distance avec un signe (champs de distance sign√©s, SDF), nous ne sommes pas limit√©s √† cela.  Si deux positions ont la m√™me coordonn√©e, les fonctions de distance sign√©es renverront la m√™me valeur, et dans un calcul, nous pouvons obtenir plusieurs chiffres.  Pour comprendre comment transformer l'espace utilis√© pour g√©n√©rer des champs de distance sign√©e, je vous recommande de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comprendre</a> comment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cr√©er des formes √† l'aide des fonctions de distance sign√©e</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combiner des formes sdf</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><a name="habracut"></a><br><h2>  La configuration </h2><br>  Pour ce tutoriel, je modifie l'association entre le carr√© et le cercle, mais vous pouvez l'utiliser pour n'importe quelle autre forme.  Ceci est similaire √† la configuration du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">didacticiel pr√©c√©dent</a> . <br><br>  Il est important ici que la partie modifiable soit avant d'utiliser des positions pour g√©n√©rer des figures. <br><br><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Type"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // manipulate position with cool methods here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" }</span></span></code> </pre> <br>  Et la fonction 2D_SDF.cginc situ√©e dans le m√™me dossier avec le shader, que nous allons d√©velopper, ressemble d'abord √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e60/788/36d/e6078836d9a222c4df1578609bdfaced.png"></div><br><h2>  R√©p√©tition de l'espace </h2><br><h3>  R√©flexion miroir </h3><br>  L'une des op√©rations les plus simples consiste √† mettre en miroir le monde autour d'un axe.  Pour le refl√©ter autour de l'axe y, nous prenons la valeur absolue de la composante x de notre position.  Ainsi, les coordonn√©es √† droite et √† gauche de l'axe seront les m√™mes.  <code>(-1, 1)</code> transforme en <code>(1, 1)</code> et se trouve √† l'int√©rieur d'un cercle en utilisant <code>(1, 1)</code> comme origine de coordonn√©es et avec un rayon sup√©rieur √† 0. <br><br>  Le plus souvent, le code utilisant cette fonction ressemblera √† quelque chose comme <code>position = mirror(position);</code>  afin que nous puissions simplifier un peu.  Nous allons simplement d√©clarer l'argument position comme inout.  Ainsi, lors de l'√©criture de l'argument, cela changera √©galement la variable que nous transmettons √† la fonction.  La valeur de retour peut alors √™tre de type void, car nous n'utilisons toujours pas la valeur de retour. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void mirror(inout float2 position){ position.x = abs(position.x); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function mirror(position);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62f/6b0/40e/62f6b040e1e648e7d6411ecf634571f4.png"></div><br>  Cela s'est d√©j√† bien pass√©, mais de cette fa√ßon, nous n'avons qu'un seul axe pour la mise en miroir.  Nous pouvons √©tendre la fonction en faisant pivoter l'espace comme nous l'avons fait lors de la rotation des figures.  Vous devez d'abord faire pivoter l'espace, puis le mettre en miroir, puis le retourner.  De cette fa√ßon, nous pouvons effectuer une mise en miroir par rapport √† n'importe quel angle.  La m√™me chose est possible lors du transfert d'espace et de l'ex√©cution d'un transfert inverse apr√®s la mise en miroir.  (Si vous effectuez les deux op√©rations, puis avant la mise en miroir, n'oubliez pas d'effectuer d'abord le transfert, puis de tourner, apr√®s quoi le tour commence en premier.) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float rotation = _Time.y * 0.25; position = rotate(position, rotation); mirror(position); position = rotate(position, -rotation);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23a/afd/284/23aafd284c90054af5e7d8b453aac212.gif"></div><br><h2>  Cellules </h2><br>  Si vous savez comment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctionne la g√©n√©ration de bruit</a> , vous comprenez que pour la g√©n√©ration proc√©durale, nous r√©p√©tons souvent la position et obtenons de petites cellules qui sont essentiellement les m√™mes, ne diff√©rant que par des param√®tres insignifiants.  Nous pouvons faire de m√™me pour les champs de distance. <br><br>  √âtant donn√© que la fonction <code>fmod</code> (en plus d'utiliser% pour diviser avec le reste) nous donne le reste, pas la d√©finition du reste, nous devrons utiliser une astuce.  Tout d'abord, nous prenons le reste de la division enti√®re par la fonction fmod.  Pour les nombres positifs, c'est exactement ce dont nous avons besoin, et pour les nombres n√©gatifs, c'est le r√©sultat dont nous avons besoin moins la p√©riode.  Vous pouvez r√©soudre ce probl√®me en ajoutant un point et en prenant √† nouveau le reste de la division.  L'ajout d'une p√©riode donnera le r√©sultat souhait√© pour les valeurs d'entr√©e n√©gatives et pour les valeurs d'entr√©e positives, la valeur est sup√©rieure d'une p√©riode.  Le deuxi√®me reste de la division ne fera rien avec les valeurs des valeurs d'entr√©e n√©gatives, car elles sont d√©j√† comprises entre 0 et la p√©riode, et pour les valeurs d'entr√©e positives, nous soustraireons essentiellement une p√©riode. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function cells(position, float2(3, 3));</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b9/3f0/b53/4b93f0b53e221b11780ed0c627ebe5c8.png"></div><br>  Le probl√®me avec les cellules est que nous perdons la continuit√© pour laquelle nous aimons les champs de distance.  Ce n'est pas mauvais si les formes ne sont qu'au milieu des cellules, mais dans l'exemple illustr√© ci-dessus, cela peut conduire √† des artefacts importants qui devraient √™tre √©vit√©s lorsque les champs de distance sont utilis√©s pour une vari√©t√© de t√¢ches dans lesquelles des champs de distance peuvent g√©n√©ralement √™tre appliqu√©s. <br><br>  Il y a une solution qui ne fonctionne pas dans tous les cas, mais quand cela fonctionne, c'est merveilleux: refl√©ter toutes les autres cellules.  Pour ce faire, nous avons besoin d'un index de cellule de pixel, mais nous n'avons toujours pas de valeur de retour dans la fonction, nous pouvons donc simplement l'utiliser pour renvoyer l'index de cellule. <br><br>  Pour calculer l'indice de cellule, nous divisons la position par la p√©riode.  Ainsi, 0-1 est la premi√®re cellule, 1-2 est la seconde, et ainsi de suite ... et nous pouvons facilement le discr√©tiser.  Pour obtenir l'index de la cellule, nous arrondissons simplement la valeur vers le bas et retournons le r√©sultat.  L'important est que l'on calcule l'indice de la cellule avant de diviser par le reste pour r√©p√©ter les cellules;  sinon, nous obtiendrions l'indice 0 partout, car la position ne peut pas d√©passer la p√©riode. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float2 cells(inout float2 position, float2 period){ position = fmod(position, period); //negative positions lead to negative modulo position += period; //negative positions now have correct cell coordinates, positive input positions too high position = fmod(position, period); //second mod doesn't change values between 0 and period, but brings down values that are above period. float2 cellIndex = position / period; cellIndex = floor(cellIndex); return cellIndex; }</span></span></code> </pre> <br>  Avec ces informations, nous pouvons retourner les cellules.  Pour comprendre s'il faut retourner ou non, on divise l'index de cellule modulo 2. Le r√©sultat de cette op√©ration est alternativement 0 et 1 ou -1 toutes les deux cellules.  Pour rendre le changement plus permanent, nous prenons la valeur absolue et obtenons une valeur qui bascule entre 0 et 1. <br><br>  Pour utiliser cette valeur pour basculer entre une position normale et invers√©e, nous avons besoin d'une fonction qui ne fait rien pour la valeur 0, et soustrait la position de la p√©riode pendant laquelle le retournement est 1. Autrement dit, nous effectuons une interpolation lin√©aire de la position normale √† la position invers√©e √† l'aide de la variable flip .  Comme la variable flip est un vecteur 2D, ses composants sont invers√©s individuellement. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 3; float2 cell = cells(position, period); float2 flip = abs(fmod(cell, 2)); position = lerp(position, period - position, flip);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/c36/5a1/45ac365a1cb18e89306a5ac1f0d01b57.png"></div><br><h2>  Cellules radiales </h2><br>  Une autre grande caract√©ristique est la r√©p√©tition de l'espace dans un motif radial. <br><br>  Pour obtenir cet effet, nous calculons d'abord la position radiale.  Pour ce faire, nous encodons l'angle par rapport au centre de l'axe x et la distance du centre le long de l'axe y. <br><br><pre> <code class="cpp hljs">float2 radialPosition = float2(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(position.x, position.y), length(position));</code> </pre> <br>  Ensuite, nous r√©p√©tons le coin.  √âtant donn√© que la transmission du nombre de r√©p√©titions est beaucoup plus facile que l'angle de chaque pi√®ce, nous calculons d'abord la taille de chaque pi√®ce.  Le cercle entier fait 2 * pi, donc pour obtenir la bonne partie, nous divisons 2 * pi par la taille des cellules. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PI = <span class="hljs-number"><span class="hljs-number">3.14159</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellSize = PI * <span class="hljs-number"><span class="hljs-number">2</span></span> / cells;</code> </pre> <br>  Avec ces informations, nous pouvons r√©p√©ter la composante x de la position radiale toutes les unit√©s cellSize.  Nous effectuons la r√©p√©tition par division avec le reste, donc, comme pr√©c√©demment, nous avons des probl√®mes avec les nombres n√©gatifs, qui peuvent √™tre √©limin√©s en utilisant les deux fonctions de division avec le reste. <br><br><pre> <code class="cpp hljs">radialPosition.x = <span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(radialPosition.x, cellSize) + cellSize, cellSize);</code> </pre> <br>  Ensuite, vous devez ramener la nouvelle position aux coordonn√©es xy habituelles.  Ici, nous utilisons la fonction sincos avec la composante x de la position radiale comme angle pour √©crire le sinus √† la coordonn√©e x de la position et le cosinus √† la coordonn√©e y.  Avec cette √©tape, nous obtenons une position normalis√©e.  Pour obtenir la bonne direction √† partir du centre, multipliez-la par la composante y de la position radiale, ce qui signifie la longueur. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void radial_cells(inout float2 position, float cells){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, false);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/a77/c42/1dba77c426e68d224172d2587b0a3a6f.png"></div><br>  Ensuite, nous pouvons √©galement ajouter l'index de cellule et la mise en miroir, comme nous l'avons fait avec les cellules normales. <br><br>  Il est n√©cessaire de calculer l'indice de cellule apr√®s avoir calcul√© la position radiale, mais avant de recevoir son reste de la division.  Nous l'obtenons en divisant la composante x de la position radiale et en arrondissant le r√©sultat vers le bas.  Dans ce cas, l'indice peut √©galement √™tre n√©gatif, ce qui pose probl√®me si le nombre de cellules est impair.  Par exemple, avec 3 cellules, on obtient 1 cellule avec un indice de 0, 1 cellule avec un indice de -1 et 2 demi-cellules avec les indices 1 et -2.  Pour contourner ce probl√®me, nous ajoutons le nombre de cellules √† la variable arrondie √† la variable, puis divisons par la taille de la cellule avec le reste. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); //at the end of the function: return cellIndex;</span></span></code> </pre> <br>  Pour refl√©ter cela, nous avons besoin que les coordonn√©es soient en radians, donc pour √©viter de recalculer les coordonn√©es radiales en dehors de la fonction, nous y ajoutons une option en utilisant l'argument bool.  Habituellement, dans les shaders, la ramification (si les constructions) n'est pas la bienvenue, mais dans ce cas, tous les pixels de l'√©cran suivront le m√™me chemin, c'est donc normal. <br><br>  La mise en miroir doit se produire apr√®s le bouclage de la coordonn√©e radiale, mais avant qu'elle ne soit reconvertie √† sa position normale.  Nous d√©couvrons si nous devons inverser la cellule actuelle en divisant l'index de cellule par 2 avec le reste. Habituellement, cela devrait nous donner des z√©ros et des uns, mais dans mon cas, plusieurs deux apparaissent, ce qui est √©trange, et pourtant nous pouvons le g√©rer.  Pour √©liminer les √©galit√©s, nous soustrayons simplement 1 de la variable flip, puis prenons la valeur absolue.  Ainsi, les z√©ros et les deux deviennent des unit√©s et les unit√©s ne deviennent des z√©ros, comme nous en avons besoin, que dans l'ordre inverse. <br><br>  Comme les z√©ros et les uns sont dans le mauvais ordre, nous effectuons une interpolation lin√©aire de la version invers√©e √† la version invers√©e, et non l'inverse, comme pr√©c√©demment.  Pour inverser les coordonn√©es, nous soustrayons simplement la position de la taille de la cellule. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function float2 period = 6; radial_cells(position, period, true);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/3ea/d5e/1b03ead5e0a63236e909d31a5025d8c7.png"></div><br><h2>  Espace de balancement </h2><br>  Mais changer l'espace n'est pas n√©cessaire de le r√©p√©ter.  Par exemple, dans le tutoriel sur les bases, nous l'avons tourn√©, d√©plac√© et mis √† l'√©chelle.  Vous pouvez √©galement effectuer les op√©rations suivantes: d√©placer chaque axe sur la base de l'autre avec une onde sinuso√Ødale.  Cela rendra les distances de la fonction de distance sign√©e moins pr√©cises, mais jusqu'√† ce qu'elles oscillent trop, tout ira bien. <br><br>  Tout d'abord, nous calculons l'amplitude du changement de position en inversant les composantes x et y, puis en les multipliant par la fr√©quence d'oscillation.  Ensuite, nous prenons le sinus de cette valeur et le multiplions par la quantit√© d'oscillation que nous voulons ajouter.  Apr√®s cela, nous ajoutons simplement ce facteur d'oscillation √† la position et appliquons √† nouveau le r√©sultat √† la position. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in 2D_SDF.cginc void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function wobble(position, 5, .05);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01c/67e/ec8/01c67eec8726bff917f97e90a5fa8431.png"></div><br>  Nous pouvons √©galement animer cette ondulation, changer sa position, appliquer une ondulation √† la position d√©cal√©e et renvoyer l'espace.  Pour que les nombres √† virgule flottante ne deviennent pas trop grands, je fais la division avec le reste pi * 2 par la fr√©quence d'oscillation, cela correspond √† l'oscillation (la sinuso√Øde se r√©p√®te chaque pi * 2 unit√©s), donc nous √©vitons les sauts et les d√©calages trop grands. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in shader function const float PI = 3.14159; float frequency = 5; float offset = _Time.y; offset = fmod(offset, PI * 2 / frequency); position = translate(position, offset); wobble(position, 5, .05); position = translate(position, -offset);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b13/a59/cc9/b13a59cc9538d7f55cc41cba474575d7.gif"></div><br><h2>  Code source </h2><br><h3>  Biblioth√®que SDF 2D </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/2D_SDF.cginc</a> </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SDF_2D #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDF_2D </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//transforms float2 rotate(float2 samplePosition, float rotation){ const float PI = 3.14159; float angle = rotation * PI * 2 * -1; float sine, cosine; sincos(angle, sine, cosine); return float2(cosine * samplePosition.x + sine * samplePosition.y, cosine * samplePosition.y - sine * samplePosition.x); } float2 translate(float2 samplePosition, float2 offset){ //move samplepoint in the opposite direction that we want to move shapes in return samplePosition - offset; } float2 scale(float2 samplePosition, float scale){ return samplePosition / scale; } //combinations ///basic float merge(float shape1, float shape2){ return min(shape1, shape2); } float intersect(float shape1, float shape2){ return max(shape1, shape2); } float subtract(float base, float subtraction){ return intersect(base, -subtraction); } float interpolate(float shape1, float shape2, float amount){ return lerp(shape1, shape2, amount); } /// round float round_merge(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 - radius, shape2 - radius); intersectionSpace = min(intersectionSpace, 0); float insideDistance = -length(intersectionSpace); float simpleUnion = merge(shape1, shape2); float outsideDistance = max(simpleUnion, radius); return insideDistance + outsideDistance; } float round_intersect(float shape1, float shape2, float radius){ float2 intersectionSpace = float2(shape1 + radius, shape2 + radius); intersectionSpace = max(intersectionSpace, 0); float outsideDistance = length(intersectionSpace); float simpleIntersection = intersect(shape1, shape2); float insideDistance = min(simpleIntersection, -radius); return outsideDistance + insideDistance; } float round_subtract(float base, float subtraction, float radius){ return round_intersect(base, -subtraction, radius); } ///champfer float champfer_merge(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleMerge = merge(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer - champferSize; return merge(simpleMerge, champfer); } float champfer_intersect(float shape1, float shape2, float champferSize){ const float SQRT_05 = 0.70710678118; float simpleIntersect = intersect(shape1, shape2); float champfer = (shape1 + shape2) * SQRT_05; champfer = champfer + champferSize; return intersect(simpleIntersect, champfer); } float champfer_subtract(float base, float subtraction, float champferSize){ return champfer_intersect(base, -subtraction, champferSize); } /// round border intersection float round_border(float shape1, float shape2, float radius){ float2 position = float2(shape1, shape2); float distanceFromBorderIntersection = length(position); return distanceFromBorderIntersection - radius; } float groove_border(float base, float groove, float width, float depth){ float circleBorder = abs(groove) - width; float grooveShape = subtract(circleBorder, base + depth); return subtract(base, grooveShape); } // space repetition void mirror(inout float2 position){ position.x = abs(position.x); } float2 cells(inout float2 position, float2 period){ //find cell index float2 cellIndex = position / period; cellIndex = floor(cellIndex); //negative positions lead to negative modulo position = fmod(position, period); //negative positions now have correct cell coordinates, positive input positions too high position += period; //second mod doesn't change values between 0 and period, but brings down values that are above period. position = fmod(position, period); return cellIndex; } float radial_cells(inout float2 position, float cells, bool mirrorEverySecondCell = false){ const float PI = 3.14159; float cellSize = PI * 2 / cells; float2 radialPosition = float2(atan2(position.x, position.y), length(position)); float cellIndex = fmod(floor(radialPosition.x / cellSize) + cells, cells); radialPosition.x = fmod(fmod(radialPosition.x, cellSize) + cellSize, cellSize); if(mirrorEverySecondCell){ float flip = fmod(cellIndex, 2); flip = abs(flip-1); radialPosition.x = lerp(cellSize - radialPosition.x, radialPosition.x, flip); } sincos(radialPosition.x, position.x, position.y); position = position * radialPosition.y; return cellIndex; } void wobble(inout float2 position, float2 frequency, float2 amount){ float2 wobble = sin(position.yx * frequency) * amount; position = position + wobble; } //shapes float circle(float2 samplePosition, float radius){ //get distance from center and grow it according to radius return length(samplePosition) - radius; } float rectangle(float2 samplePosition, float2 halfSize){ float2 componentWiseEdgeDistance = abs(samplePosition) - halfSize; float outsideDistance = length(max(componentWiseEdgeDistance, 0)); float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0); return outsideDistance + insideDistance; } #endif</span></span></span></span></code> </pre> <br><h3>  Shader de d√©monstration de base </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_mirror.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_cells.shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/036_SDF_space_manipulation/sdf_wobble.shader</a> </li></ul><br><pre> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/036_SDF_Space_Manpulation/Mirror"</span></span>{ Properties{ _InsideColor(<span class="hljs-string"><span class="hljs-string">"Inside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _OutsideColor(<span class="hljs-string"><span class="hljs-string">"Outside Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) _LineDistance(<span class="hljs-string"><span class="hljs-string">"Mayor Line Distance"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) = <span class="hljs-number"><span class="hljs-number">1</span></span> _LineThickness(<span class="hljs-string"><span class="hljs-string">"Mayor Line Thickness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.05</span></span> [IntRange]_SubLines(<span class="hljs-string"><span class="hljs-string">"Lines between major lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) = <span class="hljs-number"><span class="hljs-number">4</span></span> _SubLineThickness(<span class="hljs-string"><span class="hljs-string">"Thickness of inbetween lines"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.05</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.01</span></span> } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { // modify position here! float2 squarePosition = position; squarePosition = translate(squarePosition, float2(2, 2)); squarePosition = rotate(squarePosition, .125); float squareShape = rectangle(squarePosition, float2(1, 1)); float2 circlePosition = position; circlePosition = translate(circlePosition, float2(1, 1.5)); float circleShape = circle(circlePosition, 1); float combination = merge(circleShape, squareShape); return combination; } float4 _InsideColor; float4 _OutsideColor; float _LineDistance; float _LineThickness; float _SubLines; float _SubLineThickness; fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); fixed4 col = lerp(_InsideColor, _OutsideColor, step(0, dist)); float distanceChange = fwidth(dist) * 0.5; float majorLineDistance = abs(frac(dist / _LineDistance + 0.5) - 0.5) * _LineDistance; float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance); float distanceBetweenSubLines = _LineDistance / _SubLines; float subLineDistance = abs(frac(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines; float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance); return col * majorLines * subLines; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  Maintenant, vous connaissez toutes les bases des fonctions de distance de signe dont je me souviens.  Dans le prochain tutoriel, je vais essayer de faire quelque chose d'int√©ressant avec eux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/842/5fe/d84/8425fed84e484cd150a7eba8b4d8901c.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439000/">https://habr.com/ru/post/fr439000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438988/index.html">Tutoriel React Partie 15: Ateliers sur l'√©tat des composants</a></li>
<li><a href="../fr438992/index.html">Journal du d√©veloppeur ou mauvaises d√©cisions</a></li>
<li><a href="../fr438994/index.html">Intel Xeon W-3175X, un batteur √† chaud. Test</a></li>
<li><a href="../fr438996/index.html">R√©seau d'entreprise et MitM. Partie 1</a></li>
<li><a href="../fr438998/index.html">Meetup CGDevs Moscou # 2</a></li>
<li><a href="../fr439002/index.html">Comment arr√™ter d'√©crire des savoirs traditionnels et commencer √† travailler?</a></li>
<li><a href="../fr439006/index.html">Comment l'IA aide √† apprendre la langue des signes</a></li>
<li><a href="../fr439010/index.html">Fonctionnement de la consolidation d'archives dans DeviceLock DLP</a></li>
<li><a href="../fr439012/index.html">Annuaire t√©l√©phonique de l'organisation - version imprim√©e</a></li>
<li><a href="../fr439016/index.html">Tableaux g√©n√©riques statiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>