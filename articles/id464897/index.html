<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>➿ 🤲🏾 🤰🏽 Membangun XPath? XPath algoritmik? Tidak lain hanyalah XPath 🏇 🏇🏻 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo pembaca yang budiman. Posting ini akan fokus pada aplikasi yang sedikit tidak standar dari formalisme terkenal seperti XPath. Semua orang tahu ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membangun XPath? XPath algoritmik? Tidak lain hanyalah XPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464897/"> Halo pembaca yang budiman.  Posting ini akan fokus pada aplikasi yang sedikit tidak standar dari formalisme terkenal seperti XPath.  Semua orang tahu bahwa sangat mudah untuk mengekstraksi informasi dari XML- atau HTML- atau beberapa dokumen * ML lainnya (baik teks sederhana dan beberapa virtual, yang merupakan lapisan teratas untuk mewakili informasi kompleks), kemudian ada untuk mengajukan dokumen-dokumen ini pertanyaan  Namun, diketahui bahwa semakin baik pertanyaan dirumuskan, semakin banyak bagian dari jawaban yang sudah ada.  Oleh karena itu, pemikiran sederhana menyarankan dirinya: apakah mungkin menggunakan ekspresi yang ditulis dalam XPath sebagai pernyataan, yaitu, membangun dokumen sedemikian rupa sehingga ungkapan XPath ini benar?  Saya pikir itu mungkin, dan ini adalah hal pertama yang akan dibahas di sini.  Dan yang kedua - jika kita belajar bagaimana secara langsung membuat elemen baru dalam dokumen dengan menggunakan XPath secara langsung, apakah mungkin mengubah XPath menjadi bahasa pemrograman algoritmik yang sederhana?  Bahkan, dia tahu cara mengakses data, dia tahu cara membuat data.  Sangat mudah untuk membayangkan bagaimana menggambarkan urutan operator dan operator cabang di dalamnya, tetap memikirkan siklus di dalamnya dan tentang fungsi.  Ini menarik, setidaknya secara teoritis.  Dan ini juga akan dibahas. <br><a name="habracut"></a><br><h1>  Membangun XPath </h1><br>  Jadi, XPath biasa menjelaskan urutan langkah-langkah untuk bergerak melalui pohon dokumen, dan kondisi filter (predikat yang ditulis dalam tanda kurung siku) dapat dikenakan pada setiap langkah.  Sebagai hasilnya, kita mendapatkan beberapa set node hingga angka atau string atau nilai logis.  Kami terutama tertarik pada kasus beberapa node.  XPath biasa menghasilkan node yang sudah ada dalam dokumen.  Pertimbangkan membangun XPath hipotetis yang tidak hanya akan mengembalikan node yang ada, tetapi juga membangun node baru sehingga mereka sepenuhnya cocok dengan kueri. <br><br>  Idenya sangat sederhana - pada langkah berikutnya dari permintaan XPath, kami akan menganalisis predikat filter dan membuat varian data yang termasuk dalam filter ini.  Dan kemudian kita akan memeriksa mana dari opsi-opsi ini yang sudah ada dan selesai membangun yang tidak ada. <br><br>  Sebagai contoh, ini adalah kueri: <br><br><pre><code class="plaintext hljs">/OBJS/Var[@A=1 and @B=1 or @A=2 or @A=3]/X</code> </pre> <br>  Jika kami menganggapnya sebagai konstruksi, maka pertama-tama kami akan memeriksa apakah elemen root &lt;OBJS&gt; ada, dan jika tidak, buatlah.  Selanjutnya adalah langkah Var dengan filter.  Saya tidak akan menjelaskan aturan yang digunakan filter predikat agar tidak menyulitkan presentasi, saya hanya akan mengatakan bahwa filter ini dengan jelas menjelaskan tiga set data yang benar: <br><br><ol><li>  &lt;Var A = ”1” B = ”1” /&gt; </li><li>  &lt;Var A = ”2” /&gt; </li><li>  &lt;Var A = ”3” /&gt; </li></ol><br>  Jadi, kita perlu memastikan bahwa elemen &lt;OBJS&gt; memiliki elemen &lt;Var&gt; anak dengan data tersebut.  Dan, akhirnya, langkah selanjutnya adalah X tanpa syarat - ini berarti bahwa setiap elemen Var harus memiliki elemen turunan &lt;X&gt;. <br><br>  Jadi, semuanya sederhana.  Sebagai hasil menerapkan XPath seperti membangun, misalnya, ke dokumen <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”2”</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  kami mendapatkan dokumen keluaran: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”2”</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">X</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”1”</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">B</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”1”</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">X</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">”3”</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">X</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Var</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OBJS</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Dan pada saat yang sama, kami berhasil secara eksklusif dengan XPath, tanpa XSL atau semacamnya. <br><br><h1>  XPath algoritmik </h1><br>  Jadi kami mengajarkan XPath cara membuat data.  Sekarang ajari dia (sedikit) untuk memprosesnya secara algoritmik. <br><br>  Urutan operator dapat dijelaskan dengan ekspresi AND-logis yang biasa.  Ini dihitung ketat dari kiri ke kanan, ini yang Anda butuhkan.  Jika harus sepenuhnya diimplementasikan, maka Anda hanya perlu memastikan bahwa semua elemennya mengembalikan ekspresi yang benar. <br><br><pre> <code class="plaintext hljs">A and B and C … and Z</code> </pre><br>  Operator kondisional dari bentuk <strong>jika (A) maka B</strong> selain <strong>C</strong> , tentu saja (dan saya tidak akan mengatakan sesuatu yang baru di sini), dapat dijelaskan dengan ekspresi logis <br><pre> <code class="plaintext hljs">A and B or C</code> </pre><br>  Semuanya sedikit lebih rumit dengan loop.  Saya hanya tidak ingin memperkenalkannya begitu saja, jadi saya memutuskan untuk hanya memperkenalkan konsep fungsi XPath, yang bisa bersifat rekursif.  Dan kemudian siklus apa pun dapat direpresentasikan sebagai rantai panggilan rekursif dengan verifikasi kondisi terminasi. <br><br>  Pada prinsipnya, ini hampir semuanya (dalam versi minimal).  Bahkan variabel tidak diperlukan - mereka diganti oleh elemen dokumen saat ini.  Hanya argumen fungsi bernama yang diperlukan. <br><br>  Saya akan memberi contoh.  Misalkan kita memiliki dokumen yang berisi dua daftar angka yang dijelaskan oleh serangkaian elemen &lt;list&gt; bersarang: <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">c</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"4"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">c</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Biarkan perlu untuk menggabungkan daftar dari elemen &lt;b&gt; dan elemen &lt;c&gt; dan menempatkan hasilnya secara langsung di &lt;a&gt;.  Untuk melakukan ini, tiga fungsi XPath harus diperkenalkan: <br><br><pre> <code class="plaintext hljs">concat_list($#, $##): add_list(#/self::*) and add_list(##/self::*) add_list($#): count(list) = 0 and copy_list(#/self::*) or list[add_list(#/self::*)] or true() copy_list($#): count(#/list) = 0 or create(list[@data = #/list/@data]) and (list[copy_list(#/list)] or true())</code> </pre><br>  dan tambahkan XPath panggilan ke mereka: <br><br><pre> <code class="plaintext hljs">concat_list(/a/b,/a/c)</code> </pre><br>  Saya harap, para pembaca yang budiman, akan sedikit menarik bagi Anda untuk memahami "kode" seperti itu.  Satu-satunya hal yang saya pasti akan sebutkan adalah <strong>create (XPATH)</strong> adalah fungsi sistem yang mengeksekusi argumen XPATH dalam mode konstruksi. <br><br>  Dan sekarang semua ini menarik, tentu saja, tetapi pemrograman tanpa variabel masih cukup sulit.  Menyadari hal ini, saya memperkenalkan variabel penuh, yang, pada kenyataannya, di XPath sudah ada - mereka mulai dengan tanda "$", tetapi saya menambahkan kemampuan untuk memberikan nilai kepada mereka dengan fungsi set yang baru.  Tolong, di sini adalah contoh fungsi depth_list dengan dua argumen - referensi ke elemen awal yang berisi daftar elemen bersarang (seperti pada contoh di atas), dan variabel output yang berisi panjang daftar: <br><br><pre> <code class="plaintext hljs">depth_list($#, &amp;$OUT1): set($OUT1,0) and (#/list[set($OUT1,1) and depth_list(#/list,$OUT0) and set($OUT1,max($OUT0+1,$OUT1))]) or true()</code> </pre><br><h1>  Kesimpulan </h1><br>  Dalam bahasa mikro yang dihasilkan, yang saya sebut <strong>XPath Defender</strong> , saya menambahkan beberapa fungsi yang lebih penting dan menggunakannya di sistem saya untuk mengenali dan menghasilkan program PGEN ++ untuk melakukan tugas penting seperti penyelesaian otomatis model program yang disajikan sebagai dokumen XML.  Dengan kata lain, jika ada deskripsi tekstual dari suatu masalah (untuk kepastian, dalam bahasa Rusia), untuk solusi yang diperlukan untuk menghasilkan sebuah program, maka deskripsi ini dikenali dan berubah menjadi seperangkat elemen pernyataan tugas yang diurutkan (objek dengan parameter).  Ini adalah pernyataan awal, yang belum mengandung rencana untuk menyelesaikan masalah.  Elemen yang dikenali ditempatkan dalam dokumen XML dan aturan diterapkan padanya, ditulis baik dalam bentuk ikatan sederhana atau menghasilkan pernyataan XPath, dan dalam bentuk fragmen pada XPath Defender (ini adalah salah satu opsi untuk alur kerja).  Aturan-aturan ini memvalidasi dan melengkapi model dokumen XML dengan elemen-elemen rencana solusi.  Dan hanya kemudian, sesuai dengan model yang diperoleh, sistem membangun program yang menentukan.  Sirkuit ini telah berhasil diuji pada masalah-masalah sederhana dari pemrosesan matematika data vektor. <br><br>  Namun demikian, hasil yang paling penting, saya pikir, adalah kenyataan bahwa adalah mungkin untuk membuktikan bahwa adalah mungkin untuk membangun bahasa pemrograman algoritmik, menggunakan hampir secara eksklusif cara-cara yang biasa dan membangun XPath, perlu untuk memperkenalkan hanya fungsi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464897/">https://habr.com/ru/post/id464897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464883/index.html">Ke mana Jaringan menuju</a></li>
<li><a href="../id464887/index.html">Beberapa kesalahan umum di Vue.js (Vuex)</a></li>
<li><a href="../id464889/index.html">Kembali ke masa depan ponsel</a></li>
<li><a href="../id464893/index.html">Kami mencari bug dalam kode PHP tanpa penganalisa statis</a></li>
<li><a href="../id464895/index.html">Kenapa Israel adalah mesin untuk pengembangan teknologi otomotif</a></li>
<li><a href="../id464899/index.html">Runtuhnya sebuah kota Texas yang melewatkan uang dari pertanian bitcoin</a></li>
<li><a href="../id464901/index.html">Pengembangan Helpdesk</a></li>
<li><a href="../id464909/index.html">“Mereka mengawasi kita”: apa yang bisa terjadi pada minivan yang tidak mencolok tepat di bawah jendela Anda</a></li>
<li><a href="../id464913/index.html">"Know kaizen": filosofi apa ini untuk meningkatkan proses produksi</a></li>
<li><a href="../id464915/index.html">Optimisasi rekursi ekor JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>