<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚖️ 👰🏼 👨🏾‍🎨 Peta segi enam di Unity: menyimpan dan memuat, tekstur, jarak 🧖🏻 ♏️ 💏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1-3: jala, warna, dan tinggi sel 

 Bagian 4-7: gundukan, sungai, dan jalan 

 Bagian 8-11: air, bentang alam, dan benteng 

 Bagian 12-15: men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Peta segi enam di Unity: menyimpan dan memuat, tekstur, jarak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425919/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1-3: jala, warna, dan tinggi sel</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4-7: gundukan, sungai, dan jalan</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8-11: air, bentang alam, dan benteng</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 12-15: menyimpan dan memuat, tekstur, jarak</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 16-19: menemukan jalan, regu pemain, animasi</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 20-23: Kabut Perang, Penelitian Peta, Generasi Prosedural</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 24-27: siklus air, erosi, bioma, peta silindris</a> <br><br><h1>  Bagian 12: simpan dan muat </h1><br><ul><li>  Lacak jenis medan alih-alih warna. </li><li>  Buat file. </li><li>  Kami menulis data ke file, dan kemudian membacanya. </li><li>  Kami membuat serialisasi data sel. </li><li>  Kurangi ukuran file. </li></ul><br>  Kami sudah tahu cara membuat peta yang cukup menarik.  Sekarang Anda perlu belajar bagaimana cara menyimpannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/2ce/740/7bb2ce7409d37733e3b6f96c237ce1e9.jpg"></div><a name="habracut"></a><br>  <i>Dimuat dari file <a href="">test.map</a> .</i> <br><br><h2>  Jenis medan </h2><br>  Saat menyimpan peta, kita tidak perlu menyimpan semua data yang kita lacak selama eksekusi aplikasi.  Sebagai contoh, kita hanya perlu mengingat level tinggi sel.  Posisi vertikal itu sendiri diambil dari data ini, jadi Anda tidak perlu menyimpannya.  Sebenarnya, lebih baik jika kita tidak menyimpan metrik yang dihitung ini.  Dengan demikian, data peta akan tetap benar, bahkan jika nanti kami memutuskan untuk mengubah offset ketinggian.  Data terpisah dari presentasinya. <br><br>  Demikian pula, kita tidak perlu menyimpan warna sel yang tepat.  Anda dapat menulis bahwa selnya berwarna hijau.  Namun warna hijau yang tepat bisa berubah dengan perubahan gaya visual.  Untuk melakukan ini, kita dapat menyimpan indeks warna, bukan warna itu sendiri.  Bahkan, mungkin cukup bagi kita untuk menyimpan indeks ini daripada warna asli dalam sel saat runtime.  Ini akan memungkinkan nantinya untuk beralih ke visualisasi lega yang lebih kompleks. <br><br><h3>  Memindahkan sederetan warna </h3><br>  Jika sel tidak lagi memiliki data warna, maka itu harus disimpan di tempat lain.  Paling nyaman menyimpannya di <code>HexMetrics</code> .  Jadi mari kita tambahkan array warna ke dalamnya. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color[] colors;</code> </pre> <br>  Seperti semua data global lainnya, seperti noise, kita dapat menginisialisasi warna-warna ini dengan <code>HexGrid</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; } }</code> </pre> <br>  Dan karena sekarang kami tidak menetapkan warna langsung ke sel, kami akan menyingkirkan warna default. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color defaultColor = Color.white; … void CreateCell (int x, int z, int i) { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); // cell.Color = defaultColor; … }</span></span></code> </pre> <br>  Atur warna baru agar sesuai dengan susunan umum editor peta segi enam. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bf/3cb/002/4bf3cb002342f9ab3aa482cf3a526042.png"></div><br>  <i>Warna ditambahkan ke kisi.</i> <br><br><h3>  Refactoring sel </h3><br>  Hapus bidang warna dari <code>HexCell</code> .  Sebaliknya, kami akan menyimpan indeks.  Alih-alih indeks warna, kami menggunakan indeks jenis relief yang lebih umum. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Color color; int terrainTypeIndex;</span></span></code> </pre> <br>  Properti warna dapat menggunakan indeks ini hanya untuk mendapatkan warna yang sesuai.  Sekarang tidak diatur secara langsung, jadi hapus bagian ini.  Dalam hal ini, kami mendapatkan kesalahan kompilasi, yang akan segera kami perbaiki. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.colors[terrainTypeIndex]; } <span class="hljs-comment"><span class="hljs-comment">// set { // … // } }</span></span></code> </pre> <br>  Tambahkan properti baru untuk mendapatkan dan mengatur indeks tipe ketinggian baru. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TerrainTypeIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> terrainTypeIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (terrainTypeIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { terrainTypeIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } }</code> </pre> <br><h3>  Editor refactoring </h3><br>  Di dalam <code>HexMapEditor</code> menghapus semua kode terkait warna.  Ini akan memperbaiki kesalahan kompilasi. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … // Color activeColor; … // bool applyColor; … // public void SelectColor (int index) { // applyColor = index &gt;= 0; // if (applyColor) { // activeColor = colors[index]; // } // } … // void Awake () { // SelectColor(0); // } … void EditCell (HexCell cell) { if (cell) { // if (applyColor) { // cell.Color = activeColor; // } … } }</span></span></code> </pre> <br>  Sekarang tambahkan bidang dan metode untuk mengontrol indeks tipe elevasi aktif. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeTerrainTypeIndex; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTerrainTypeIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeTerrainTypeIndex = index; }</code> </pre> <br>  Kami menggunakan metode ini sebagai pengganti metode <code>SelectColor</code> sekarang hilang.  Hubungkan widget warna di UI dengan <code>SetTerrainTypeIndex</code> , biarkan semuanya tidak berubah.  Ini berarti bahwa indeks negatif masih digunakan dan berarti warnanya tidak boleh berubah. <br><br>  Ubah <code>EditCell</code> sehingga indeks tipe elevasi ditetapkan ke sel yang sedang diedit. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activeTerrainTypeIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.TerrainTypeIndex = activeTerrainTypeIndex; } … } }</code> </pre> <br>  Meskipun kami menghapus data warna dari sel, peta harus bekerja sama seperti sebelumnya.  Satu-satunya perbedaan adalah bahwa warna default sekarang adalah yang pertama dalam array.  Dalam kasus saya ini berwarna kuning. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/e7e/6ac/8cce7e6acb202e119a6e7d5cdae2db74.png"></div><br>  <i>Kuning adalah warna default baru.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Menyimpan data ke file </h2><br>  Untuk mengontrol penyimpanan dan pemuatan peta, kami menggunakan <code>HexMapEditor</code> .  Kami akan membuat dua metode yang akan melakukan ini, dan untuk saat ini biarkan semuanya kosong. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br>  Tambahkan dua tombol ke UI ( <em>GameObject / UI / Button</em> ).  Hubungkan mereka ke tombol dan berikan label yang sesuai.  Saya menempatkannya di bagian bawah panel kanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/eba/96b/6eceba96bb5ff18fd0b4ad9472a19695.png"></div><br>  <i>Simpan dan Muat tombol.</i> <br><br><h3>  Lokasi file </h3><br>  Untuk menyimpan kartu, Anda harus menyimpannya di suatu tempat.  Seperti yang dilakukan di sebagian besar game, kami akan menyimpan data dalam file.  Tetapi di mana harus meletakkan file ini dalam sistem file?  Jawabannya tergantung pada sistem operasi mana game berjalan.  Setiap OS memiliki standar sendiri untuk menyimpan file yang terkait dengan aplikasi. <br><br>  Kita tidak perlu tahu standar-standar ini.  Unity tahu jalan yang benar yang bisa kita dapatkan dengan <code>Application.persistentDataPath</code> .  Anda dapat memeriksa bagaimana hal itu akan terjadi dengan Anda, dalam metode <code>Save</code> , menampilkannya di konsol dan menekan tombol dalam mode Play. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(Application.persistentDataPath); }</code> </pre> <br>  Pada sistem desktop, jalur akan berisi nama perusahaan dan produk.  Jalur ini digunakan oleh editor dan majelis.  Nama dapat dikonfigurasi dalam <em>Edit / Pengaturan Proyek / Player</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/a60/056/656a60056f9d51c5a5f3d81762135b87.png"></div><br>  <i>Nama perusahaan dan produk.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa saya tidak dapat menemukan folder Library di Mac?</b> <div class="spoiler_text">  Folder <em>Perpustakaan</em> sering disembunyikan.  Cara menampilkannya tergantung pada versi OS X. Jika Anda tidak memiliki versi yang lebih lama, pilih folder beranda di Finder dan buka <em>Show Show Options</em> .  Ada kotak centang untuk folder <em>Perpustakaan</em> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana dengan WebGL?</b> <div class="spoiler_text">  Game WebGL tidak dapat mengakses sistem file pengguna.  Sebaliknya, semua operasi file diarahkan ke sistem file yang terletak di memori.  Dia transparan bagi kita.  Namun, untuk menyimpan data, Anda harus memesan halaman web secara manual untuk membuang data ke dalam penyimpanan browser. </div></div><br><h3>  Pembuatan file </h3><br>  Untuk membuat file, kita perlu menggunakan kelas dari namespace <code>System.IO</code> .  Oleh karena itu, kami menambahkan pernyataan <code>using</code> untuk itu di atas kelas <code>HexMapEditor</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … }</code> </pre> <br>  Pertama kita perlu membuat path lengkap ke file.  Kami menggunakan <em>test.map</em> sebagai <em>nama</em> file.  Itu harus ditambahkan ke jalur data yang disimpan.  Apakah Anda perlu memasukkan maju atau backslash (garis miring atau garis miring terbalik) tergantung pada platform.  Metode <code>Path.Combine</code> akan <code>Path.Combine</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); }</code> </pre> <br>  Selanjutnya, kita perlu mengakses file di lokasi ini.  Kami melakukan ini menggunakan metode <code>File.Open</code> .  Karena kita ingin menulis data ke file ini, kita perlu menggunakan mode buatnya.  Dalam hal ini, file baru akan dibuat pada jalur yang ditentukan, atau file yang sudah ada akan diganti. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); File.Open(path, FileMode.Create);</code> </pre> <br>  Hasil memanggil metode ini akan menjadi aliran data terbuka yang terkait dengan file ini.  Kita bisa menggunakannya untuk menulis data ke file.  Dan kita tidak boleh lupa untuk menutup arus ketika kita tidak lagi membutuhkannya. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); Stream fileStream = File.Open(path, FileMode.Create); fileStream.Close();</code> </pre> <br>  Pada tahap ini, ketika Anda mengklik tombol <em>Simpan</em> , file <em>test.map</em> akan dibuat di folder yang ditentukan sebagai jalur ke data yang disimpan.  Jika Anda mempelajari file ini, itu akan kosong dan memiliki ukuran 0 byte, karena sejauh ini kami belum menulis apa pun untuknya. <br><br><h3>  Menulis ke file </h3><br>  Untuk menulis data ke file, kita perlu cara untuk mengalirkan data ke file.  Cara termudah untuk melakukannya adalah dengan <code>BinaryWriter</code> .  Objek-objek ini memungkinkan Anda untuk menulis data primitif ke aliran apa pun. <br><br>  Buat objek <code>BinaryWriter</code> baru, dan aliran file kami akan menjadi argumennya.  Penulis penutup menutup aliran yang digunakannya.  Karenanya, kita tidak perlu lagi menyimpan tautan langsung ke aliran. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Close();</code> </pre> <br>  Untuk mentransfer data ke aliran, kita dapat menggunakan metode <code>BinaryWriter.Write</code> .  Ada varian dari metode <code>Write</code> untuk semua tipe primitif, seperti integer dan float.  Itu juga dapat merekam garis.  Mari kita coba menulis bilangan bulat 123. <br><br><pre> <code class="cs hljs"> BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)); writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); writer.Close();</code> </pre> <br>  Klik tombol <em>Simpan</em> dan periksa <em>test.map</em> lagi.  Sekarang ukurannya adalah 4 byte, karena ukuran integer adalah 4 byte. <br><br><div class="spoiler">  <b class="spoiler_title">Mengapa manajer file saya menunjukkan bahwa file tersebut membutuhkan lebih banyak ruang?</b> <div class="spoiler_text">  Karena sistem file membagi ruang menjadi blok byte.  Mereka tidak melacak byte individu.  Karena <em>test.map</em> hanya membutuhkan empat byte sejauh ini, ia membutuhkan satu blok ruang penyimpanan. </div></div><br>  Perhatikan bahwa kami menyimpan data biner, bukan teks yang dapat dibaca manusia.  Karena itu, jika kita membuka file dalam editor teks, kita akan melihat serangkaian karakter yang tidak jelas.  Anda mungkin akan melihat simbol <em>{</em> diikuti oleh tidak ada atau beberapa penampung. <br><br>  Anda dapat membuka file dalam hex editor.  Dalam hal ini, kita akan melihat <em>7b 00 00 00</em> .  Ini adalah empat byte integer kami, yang dipetakan dalam notasi heksadesimal.  Dalam angka desimal biasa, ini adalah <em>123 0 0 0</em> .  Dalam biner, byte pertama terlihat seperti <em>01111011</em> . <br><br>  Kode ASCII untuk <em>{</em> adalah 123, sehingga karakter ini dapat ditampilkan dalam editor teks.  ASCII 0 adalah karakter nol yang tidak cocok dengan karakter apa pun yang terlihat. <br><br>  Tiga byte sisanya sama dengan nol, karena kami menulis angka kurang dari 256. Jika kami menulis 256, kita akan melihat <em>00 01 00 00</em> di hex editor. <br><br><div class="spoiler">  <b class="spoiler_title">Bukankah seharusnya 123 disimpan sebagai 00 00 00 7b?</b> <div class="spoiler_text">  <code>BinaryWriter</code> menggunakan format little-endian untuk menyimpan angka.  Ini berarti bahwa byte paling signifikan ditulis terlebih dahulu.  Format ini digunakan oleh Microsoft dalam pengembangan kerangka .Net.  Itu mungkin dipilih karena CPU Intel menggunakan format little-endian. <br><br>  Alternatif untuk itu adalah big-endian, di mana byte paling signifikan disimpan terlebih dahulu.  Ini sesuai dengan urutan nomor yang biasa.  123 adalah seratus dua puluh tiga karena yang kami maksud adalah rekaman big-endian.  Jika itu adalah endian kecil, maka itu berarti tiga ratus dua puluh satu. </div></div><br><h3>  Kami membuat sumber daya gratis </h3><br>  Adalah penting bahwa kita menutup penulis.  Ketika terbuka, sistem file mengunci file, mencegah proses lain dari menulis ke sana.  Jika kita lupa untuk menutupnya, kita akan memblokir diri kita juga.  Jika kita menekan tombol simpan dua kali, kedua kalinya kita tidak akan dapat membuka aliran. <br><br>  Alih-alih menutup penulis secara manual, kita dapat membuat blok <code>using</code> untuk ini.  Ini mendefinisikan ruang lingkup di mana penulis valid.  Ketika kode yang dapat dieksekusi melampaui ruang lingkup ini, penulis dihapus dan utas ditutup. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">123</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// writer.Close();</span></span></code> </pre> <br>  Ini akan berfungsi karena kelas penulis dan aliran file mengimplementasikan antarmuka <code>IDisposable</code> .  Objek-objek ini memiliki metode <code>Dispose</code> , yang secara tidak langsung dipanggil ketika mereka melampaui ruang lingkup <code>using</code> . <br><br>  Keuntungan besar <code>using</code> adalah bahwa ia bekerja tidak peduli bagaimana program kehabisan ruang lingkup.  Pengembalian awal, pengecualian dan kesalahan tidak mengganggunya.  Selain itu, dia sangat ringkas. <br><br><h3>  Pengambilan data </h3><br>  Untuk membaca data yang ditulis sebelumnya, kita perlu memasukkan kode ke dalam metode <code>Load</code> .  Seperti dalam kasus penyimpanan, kita perlu membuat jalur dan membuka aliran file.  Perbedaannya adalah bahwa sekarang kita membuka file untuk membaca, bukan menulis.  Dan alih-alih penulis, kita membutuhkan <code>BinaryReader</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.Open(path, FileMode.Open)) ) { } }</code> </pre> <br>  Dalam hal ini, kita dapat menggunakan metode <code>File.OpenRead</code> untuk membuka file untuk dibaca. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Mengapa kita tidak bisa menggunakan File.OpenWrite saat menulis?</b> <div class="spoiler_text">  Metode ini menciptakan aliran yang menambahkan data ke file yang ada, daripada menggantikannya. </div></div><br>  Saat membaca, kita perlu secara eksplisit menunjukkan jenis data yang diterima.  Untuk membaca integer dari stream, kita perlu menggunakan <code>BinaryReader.ReadInt32</code> .  Metode ini membaca bilangan bulat 32-bit, yaitu empat byte. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { Debug.Log(reader.ReadInt32()); }</code> </pre> <br>  Perlu dicatat bahwa ketika menerima <em>123,</em> itu akan cukup bagi kita untuk membaca satu byte.  Tetapi pada saat yang sama, tiga byte milik integer ini akan tetap ada di aliran.  Selain itu, ini tidak akan berfungsi untuk angka di luar interval 0-255.  Karena itu, jangan lakukan itu. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">paket unity</a> <br><br><h2>  Menulis dan membaca data peta </h2><br>  Saat menyimpan data, pertanyaan penting adalah apakah akan menggunakan format yang dapat dibaca manusia.  Biasanya, format yang dapat dibaca manusia adalah JSON, XML, dan ASCII biasa dengan beberapa jenis struktur.  File-file tersebut dapat dibuka, ditafsirkan dan diedit dalam editor teks.  Selain itu, mereka menyederhanakan pertukaran data antara aplikasi yang berbeda. <br><br>  Namun, format tersebut memiliki persyaratan sendiri.  File akan memakan lebih banyak ruang (terkadang lebih banyak) daripada menggunakan data biner.  Mereka juga dapat sangat meningkatkan biaya pengodean dan penguraian data, baik dari segi runtime dan jejak memori. <br><br>  Sebaliknya, data biner kompak dan cepat.  Ini penting saat merekam data dalam jumlah besar.  Misalnya, saat menyimpan peta besar secara otomatis di setiap belokan game.  Oleh karena itu <br>  kita akan menggunakan format biner.  Jika Anda dapat menangani ini, Anda dapat bekerja dengan format yang lebih rinci. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana dengan serialisasi otomatis?</b> <div class="spoiler_text">  Segera selama proses serialisasi data Unity, kita dapat langsung menulis kelas serial ke stream.  Detail rekaman masing-masing bidang akan disembunyikan dari kami.  Namun, kami tidak dapat membuat serialisasi sel secara langsung.  Mereka adalah kelas <code>MonoBehaviour</code> yang berisi data yang tidak perlu kita simpan.  Oleh karena itu, kita perlu menggunakan hierarki objek yang terpisah, yang menghancurkan kesederhanaan serialisasi otomatis.  Selain itu, akan lebih sulit untuk mendukung perubahan kode di masa depan.  Oleh karena itu, kami akan mempertahankan kontrol penuh dengan serialisasi manual.  Selain itu, itu akan membuat kita benar-benar mengerti apa yang sedang terjadi. </div></div><br>  Untuk membuat serial peta, kita perlu menyimpan data setiap sel.  Untuk menyimpan dan memuat sel tunggal, tambahkan metode <code>Save</code> dan <code>Load</code> ke <code>HexCell</code> .  Karena mereka membutuhkan penulis atau pembaca untuk bekerja, kami akan menambahkannya sebagai parameter. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Tambahkan metode <code>Save</code> dan <code>Load</code> ke <code>HexGrid</code> .  Metode ini memintas semua sel dengan memanggil metode <code>Load</code> dan <code>Save</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } } }</code> </pre> <br>  Jika kita mengunduh peta, peta itu perlu diperbarui setelah data sel diubah.  Untuk melakukan ini, cukup perbarui semua fragmen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br>  Akhirnya, kami mengganti kode pengujian kami di <code>HexMapEditor</code> dengan panggilan ke metode <code>Save</code> dan <code>Load</code> kisi, yang meneruskan penulis atau pembaca dengannya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { hexGrid.Save(writer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { hexGrid.Load(reader); } }</code> </pre> <br><h3>  Menyimpan tipe bantuan </h3><br>  Pada tahap saat ini, menyimpan kembali membuat file kosong, dan mengunduh tidak menghasilkan apa-apa.  Mari kita mulai secara bertahap dengan merekam dan memuat hanya indeks tipe elevasi <code>HexCell</code> . <br><br>  Tetapkan nilai langsung ke bidang terrainTypeIndex.  Kami tidak akan menggunakan properti.  Karena kami secara eksplisit memperbarui semua fragmen, panggilan ke properti <code>Refresh</code> tidak diperlukan.  Selain itu, karena kami hanya menyimpan peta yang benar, kami akan menganggap bahwa semua peta yang diunduh juga benar.  Karena itu, misalnya, kami tidak akan memeriksa apakah sungai atau jalan itu diizinkan. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); }</code> </pre> <br>  Saat menyimpan ke file ini, satu demi satu indeks jenis bantuan semua sel akan ditulis.  Karena indeks adalah bilangan bulat, ukurannya empat byte.  Kartu saya berisi 300 sel, mis. Ukuran file adalah 1200 byte. <br><br>  Muatan membaca indeks dalam urutan yang sama di mana mereka ditulis.  Jika Anda mengubah warna sel setelah menyimpan, maka memuat peta akan mengembalikan warna ke status saat menyimpan.  Karena kami tidak lagi menyimpan apa pun, sisa data sel akan tetap sama.  Artinya, pemuatan akan mengubah jenis medan, tetapi tidak tinggi, ketinggian air, fitur medan, dll. <br><br><h3>  Menyimpan Semua Integer </h3><br>  Menyimpan indeks jenis bantuan tidak cukup bagi kami.  Anda perlu menyimpan semua data lainnya.  Mari kita mulai dengan semua bidang bilangan bulat.  Ini adalah indeks dari jenis bantuan, tinggi sel, tingkat air, tingkat kota, tingkat pertanian, tingkat vegetasi dan indeks benda-benda khusus.  Mereka harus dibaca dalam urutan yang sama ketika mereka direkam. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); }</code> </pre> <br>  Coba sekarang untuk menyimpan dan memuat peta, membuat perubahan di antara operasi ini.  Segala sesuatu yang kami sertakan dalam data yang disimpan dipulihkan sebaik mungkin, kecuali ketinggian sel.  Ini terjadi karena ketika Anda mengubah level ketinggian, Anda perlu memperbarui posisi vertikal sel.  Ini dapat dilakukan dengan menugaskannya ke properti, dan bukan bidang, nilai ketinggian yang dimuat.  Tetapi properti ini melakukan pekerjaan tambahan yang tidak kita butuhkan.  Oleh karena itu, mari kita ekstrak kode yang memperbarui posisi sel dari setter <code>Elevation</code> dan masukkan ke dalam metode <code>RefreshPosition</code> terpisah.  Satu-satunya perubahan yang perlu Anda lakukan di sini adalah mengganti <code>value</code> referensi ke bidang <code>elevation</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 position = transform.localPosition; position.y = elevation * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; }</code> </pre> <br>  Sekarang kita dapat memanggil metode saat mengatur properti, serta setelah memuat data ketinggian. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshPosition(); ValidateRivers(); … } } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); … }</code> </pre> <br>  Setelah perubahan ini, sel-sel akan dengan benar mengubah tinggi yang tampak saat memuat. <br><br><h3>  Menyimpan semua data </h3><br>  Keberadaan dinding dan sungai masuk / keluar dalam sel disimpan di bidang Boolean.  Kita dapat menulisnya hanya sebagai integer.  Selain itu, data jalan adalah larik enam nilai Boolean yang bisa kita tulis dengan satu lingkaran. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(terrainTypeIndex); writer.Write(elevation); writer.Write(waterLevel); writer.Write(urbanLevel); writer.Write(farmLevel); writer.Write(plantLevel); writer.Write(specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write(hasOutgoingRiver); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { writer.Write(roads[i]); } }</code> </pre> <br>  Arah sungai masuk dan keluar disimpan di bidang <code>HexDirection</code> .  Tipe <code>HexDirection</code> adalah enumerasi yang disimpan secara internal sebagai beberapa nilai integer.  Oleh karena itu, kami juga dapat membuat cerita bersambung sebagai integer menggunakan konversi eksplisit. <br><br><pre> <code class="cs hljs"> writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)outgoingRiver);</code> </pre> <br>  Nilai Boolean dibaca menggunakan metode <code>BinaryReader.ReadBoolean</code> .  Arah sungai adalah bilangan bulat, yang harus kita konversi kembali ke <code>HexDirection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { terrainTypeIndex = reader.ReadInt32(); elevation = reader.ReadInt32(); RefreshPosition(); waterLevel = reader.ReadInt32(); urbanLevel = reader.ReadInt32(); farmLevel = reader.ReadInt32(); plantLevel = reader.ReadInt32(); specialIndex = reader.ReadInt32(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadInt32(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = reader.ReadBoolean(); } }</code> </pre> <br>  Sekarang kami menyimpan semua data sel yang diperlukan untuk menyimpan dan memulihkan peta secara lengkap.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini membutuhkan sembilan bilangan bulat dan sembilan nilai Boolean per sel. </font><font style="vertical-align: inherit;">Setiap nilai Boolean membutuhkan satu byte, jadi kami menggunakan total 45 byte per sel. </font><font style="vertical-align: inherit;">Artinya, kartu dengan 300 sel membutuhkan total 13.500 byte. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurangi ukuran file </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun tampaknya 13.500 byte tidak terlalu banyak untuk 300 sel, mungkin kita dapat melakukannya dengan jumlah yang lebih kecil. </font><font style="vertical-align: inherit;">Pada akhirnya, kami memiliki kendali penuh atas bagaimana data diserialisasi. </font><font style="vertical-align: inherit;">Mari kita lihat apakah ada cara yang lebih ringkas untuk menyimpannya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengurangan interval numerik </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level dan indeks sel yang berbeda disimpan sebagai integer. </font><font style="vertical-align: inherit;">Namun, mereka hanya menggunakan rentang nilai yang kecil. </font><font style="vertical-align: inherit;">Masing-masing dari mereka pasti akan tetap di kisaran 0-255. </font><font style="vertical-align: inherit;">Ini berarti bahwa hanya byte pertama dari setiap integer yang akan digunakan. </font><font style="vertical-align: inherit;">Tiga sisanya akan selalu nol. </font><font style="vertical-align: inherit;">Tidak masuk akal untuk menyimpan byte kosong ini. </font><font style="vertical-align: inherit;">Kita dapat membuangnya dengan menulis integer ke byte sebelum menulis ke stream.</font></font><br><br><pre> <code class="cs hljs"> writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)terrainTypeIndex); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)elevation); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)waterLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)urbanLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)farmLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)plantLevel); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)specialIndex); writer.Write(walled); writer.Write(hasIncomingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)incomingRiver); writer.Write(hasOutgoingRiver); writer.Write((<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)outgoingRiver);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, untuk mengembalikan angka-angka ini, kita harus menggunakan </font></font><code>BinaryReader.ReadByte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Konversi dari byte ke integer dilakukan secara implisit, jadi kami tidak perlu menambahkan konversi eksplisit.</font></font><br><br><pre> <code class="cs hljs"> terrainTypeIndex = reader.ReadByte(); elevation = reader.ReadByte(); RefreshPosition(); waterLevel = reader.ReadByte(); urbanLevel = reader.ReadByte(); farmLevel = reader.ReadByte(); plantLevel = reader.ReadByte(); specialIndex = reader.ReadByte(); walled = reader.ReadBoolean(); hasIncomingRiver = reader.ReadBoolean(); incomingRiver = (HexDirection)reader.ReadByte(); hasOutgoingRiver = reader.ReadBoolean(); outgoingRiver = (HexDirection)reader.ReadByte();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kita menyingkirkan tiga byte per integer, yang menghemat 27 byte per sel. Sekarang kita menghabiskan 18 byte per sel, dan hanya 5.400 byte per 300 sel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu dicatat bahwa data kartu lama menjadi tidak berarti pada tahap ini. Saat memuat penyimpanan lama, data tercampur dan kami mendapatkan sel yang bingung. Ini karena kita sekarang membaca lebih sedikit data. Jika kita membaca lebih banyak data daripada sebelumnya, kita akan mendapatkan kesalahan ketika mencoba membaca di luar akhir file.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketidakmampuan untuk memproses data lama cocok untuk kita, karena kita sedang dalam proses menentukan format. </font><font style="vertical-align: inherit;">Tetapi ketika kita memutuskan format simpan, kita perlu memastikan bahwa kode yang akan datang dapat selalu membacanya. </font><font style="vertical-align: inherit;">Sekalipun kita mengubah formatnya, idealnya kita tetap bisa membaca format yang lama.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sungai Byte Union </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, kami menggunakan empat byte untuk menyimpan data sungai, dua per arah. </font><font style="vertical-align: inherit;">Untuk setiap arah, kami menyimpan keberadaan sungai dan arah alirannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampak jelas bahwa kami tidak perlu menyimpan arah sungai jika tidak. </font><font style="vertical-align: inherit;">Ini berarti bahwa sel-sel tanpa sungai membutuhkan dua byte lebih sedikit. </font><font style="vertical-align: inherit;">Bahkan, satu byte ke arah sungai akan cukup bagi kita, terlepas dari keberadaannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki enam kemungkinan arah, yang disimpan sebagai angka dalam interval 0–5. </font><font style="vertical-align: inherit;">Tiga bit sudah cukup untuk ini, karena dalam bentuk angka biner dari 0 hingga 5 terlihat seperti 000, 001, 010, 011, 100, 101 dan 110. Artinya, satu byte lagi tetap tidak digunakan lima bit lagi. </font><font style="vertical-align: inherit;">Kita dapat menggunakan salah satunya untuk menunjukkan apakah ada sungai. </font><font style="vertical-align: inherit;">Sebagai contoh, Anda dapat menggunakan bit kedelapan, sesuai dengan angka 128. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, kita akan menambahkan 128 untuknya sebelum mengubah arah menjadi byte. Artinya, jika kita memiliki sungai yang mengalir ke barat laut, kita akan menulis 133, yang dalam bentuk biner adalah 10000101. Dan jika tidak ada sungai, maka kita hanya menulis nol byte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada saat yang sama, empat bit lagi tetap tidak digunakan, tetapi ini normal. </font><font style="vertical-align: inherit;">Kita dapat menggabungkan kedua arah sungai menjadi satu byte, tetapi ini sudah terlalu membingungkan.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// writer.Write(hasIncomingRiver); // writer.Write((byte)incomingRiver); if (hasIncomingRiver) { writer.Write((byte)(incomingRiver + 128)); } else { writer.Write((byte)0); } // writer.Write(hasOutgoingRiver); // writer.Write((byte)outgoingRiver); if (hasOutgoingRiver) { writer.Write((byte)(outgoingRiver + 128)); } else { writer.Write((byte)0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendekode data sungai, pertama-tama kita perlu membaca byte kembali. </font><font style="vertical-align: inherit;">Jika nilainya tidak kurang dari 128, maka ini berarti ada sungai. </font><font style="vertical-align: inherit;">Untuk mendapatkan arahannya, kurangi 128, lalu konversikan ke </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// hasIncomingRiver = reader.ReadBoolean(); // incomingRiver = (HexDirection)reader.ReadByte(); byte riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasIncomingRiver = true; incomingRiver = (HexDirection)(riverData - 128); } else { hasIncomingRiver = false; } // hasOutgoingRiver = reader.ReadBoolean(); // outgoingRiver = (HexDirection)reader.ReadByte(); riverData = reader.ReadByte(); if (riverData &gt;= 128) { hasOutgoingRiver = true; outgoingRiver = (HexDirection)(riverData - 128); } else { hasOutgoingRiver = false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasilnya, kami mendapat 16 byte per sel. </font><font style="vertical-align: inherit;">Peningkatan tampaknya tidak besar, tetapi ini adalah salah satu trik yang digunakan untuk mengurangi ukuran data biner.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simpan jalan dalam satu byte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menggunakan trik serupa untuk mengompres data jalan. </font><font style="vertical-align: inherit;">Kami memiliki enam nilai boolean yang dapat disimpan dalam enam bit pertama byte. </font><font style="vertical-align: inherit;">Artinya, setiap arah jalan diwakili oleh angka yang merupakan kekuatan dua. </font><font style="vertical-align: inherit;">Ini adalah 1, 2, 4, 8, 16 dan 32, atau dalam bentuk biner 1, 10, 100, 1000, 10000 dan 100000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat byte jadi, kita perlu mengatur bit yang sesuai dengan arah jalan yang digunakan. </font><font style="vertical-align: inherit;">Untuk mendapatkan arah yang benar untuk arah itu, kita bisa menggunakan operator </font></font><code>&lt;&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian gabungkan mereka menggunakan operator bitwise OR. </font><font style="vertical-align: inherit;">Misalnya, jika jalan pertama, kedua, ketiga dan keenam digunakan, maka byte yang selesai adalah 100111.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">// writer.Write(roads[i]); if (roads[i]) { roadFlags |= 1 &lt;&lt; i; } } writer.Write((byte)roadFlags);</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara kerja &lt;&lt;?</font></font></b> <div class="spoiler_text">     .   integer      .  .     integer .    ,          .   <code>1 &lt;&lt; n</code>  2 <sup>n</sup> ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan nilai Boolean dari jalan kembali, Anda perlu memeriksa apakah bit sudah diatur. </font><font style="vertical-align: inherit;">Jika demikian, maka sembunyikan semua bit lainnya menggunakan operator bitwise AND dengan nomor yang sesuai. </font><font style="vertical-align: inherit;">Jika hasilnya tidak sama dengan nol, maka bit diatur dan jalan ada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> roadFlags = reader.ReadByte(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { roads[i] = (roadFlags &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i)) != <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah meremas enam byte menjadi satu, kami menerima 11 byte per sel. </font><font style="vertical-align: inherit;">Dengan 300 sel, ini hanya 3.300 byte. </font><font style="vertical-align: inherit;">Artinya, setelah bekerja sedikit dengan byte, kami mengurangi ukuran file sebesar 75%.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bersiap untuk masa depan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum menyatakan format penyimpanan kami selesai, kami menambahkan satu lagi detail. </font><font style="vertical-align: inherit;">Sebelum menyimpan data peta, kami akan dipaksa untuk </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menulis bilangan bulat nol.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">0</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan menambahkan empat byte kosong ke awal data kami. </font><font style="vertical-align: inherit;">Artinya, sebelum memuat kartu, kita harus membaca empat byte ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { reader.ReadInt32(); hexGrid.Load(reader); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun byte ini tidak berguna sejauh ini, mereka digunakan sebagai header yang akan memberikan kompatibilitas ke belakang di masa depan. </font><font style="vertical-align: inherit;">Jika kami belum menambahkan byte nol ini, maka konten beberapa byte pertama bergantung pada sel pertama peta. </font><font style="vertical-align: inherit;">Oleh karena itu, di masa mendatang akan lebih sulit bagi kita untuk mengetahui versi format penyimpanan mana yang sedang kita tangani. </font><font style="vertical-align: inherit;">Sekarang kita bisa memeriksa empat byte pertama. </font><font style="vertical-align: inherit;">Jika mereka kosong, maka kita berhadapan dengan versi format 0. Dalam versi yang akan datang, akan dimungkinkan untuk menambahkan sesuatu yang lain di sana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, jika judulnya bukan nol, kami berhadapan dengan beberapa versi yang tidak dikenal. </font><font style="vertical-align: inherit;">Karena kami tidak dapat menemukan data apa yang ada, kami harus menolak untuk mengunduh peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } }</code> </pre> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 13: manajemen kartu </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membuat kartu baru dalam mode Play. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan dukungan untuk berbagai ukuran kartu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan ukuran peta ke data yang disimpan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simpan dan muat peta yang berubah-ubah. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilkan daftar kartu. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian ini, kami akan menambahkan dukungan untuk berbagai ukuran kartu, serta menyimpan file yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai dari bagian ini, tutorial akan dibuat di Unity 5.5.0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/9e2/1e4/abd9e21e467d0b291c33f4ad31e96c51.jpg"></div><br> <i><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> perpustakaan peta.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat Peta Baru </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hingga saat ini, kami hanya membuat kisi segi enam sekali - saat memuat adegan. </font><font style="vertical-align: inherit;">Sekarang kita akan memungkinkan untuk memulai peta baru kapan saja. </font><font style="vertical-align: inherit;">Kartu baru hanya akan menggantikan yang sekarang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di Sedarlah </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, beberapa metrik diinisialisasi, dan kemudian jumlah sel ditentukan dan fragmen serta sel yang diperlukan dibuat. </font><font style="vertical-align: inherit;">Membuat kumpulan fragmen dan sel baru, kami membuat peta baru. </font><font style="vertical-align: inherit;">Mari kita bagi </font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi dua bagian - kode sumber inisialisasi dan metode umum </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan tombol di UI untuk membuat peta baru. </font><font style="vertical-align: inherit;">Saya membuatnya besar dan meletakkannya di bawah tombol simpan dan muat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c02/ff4/203c02ff4ca668836064c72ad770328c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tombol Peta Baru. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita hubungkan acara </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Click</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tombol ini dengan metode </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek kita </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Artinya, kita tidak akan melalui </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi langsung memanggil metode objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36a/d04/a3e/36ad04a3ebf94b00faf7aebe8c783b2f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat peta dengan mengklik.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghapus data lama </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, ketika Anda mengklik tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , satu set fragmen dan sel baru akan dibuat. </font><font style="vertical-align: inherit;">Namun, yang lama tidak dihapus secara otomatis. </font><font style="vertical-align: inherit;">Karenanya, sebagai hasilnya, kami mendapatkan beberapa jerat peta yang saling bertumpukan. </font><font style="vertical-align: inherit;">Untuk menghindari ini, pertama-tama kita harus menyingkirkan benda-benda tua. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menghancurkan semua fragmen saat ini di awal </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunks != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { Destroy(chunks[i].gameObject); } } … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah kita menggunakan kembali objek yang ada?</font></font></b> <div class="spoiler_text">  ,         .     ,       .  ,    —    ,      . </div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah mungkin untuk menghancurkan elemen anak seperti ini dalam satu lingkaran?</font></font></b> <div class="spoiler_text">  Tentu saja         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tentukan ukuran dalam sel, bukan fragmen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sementara kita mengatur ukuran peta melalui bidang </font></font><code>chunkCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>chunkCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tetapi akan jauh lebih nyaman untuk menunjukkan ukuran peta dalam sel. </font><font style="vertical-align: inherit;">Pada saat yang sama, kita bahkan dapat mengubah ukuran fragmen di masa depan tanpa mengubah ukuran kartu. </font><font style="vertical-align: inherit;">Karena itu, mari bertukar peran jumlah sel dan jumlah bidang fragmen.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int chunkCountX = 4, chunkCountZ = 3; public int cellCountX = 20, cellCountZ = 15; … // int cellCountX, cellCountZ; int chunkCountX, chunkCountZ; … public void CreateMap () { … // cellCountX = chunkCountX * HexMetrics.chunkSizeX; // cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini akan menyebabkan kesalahan kompilasi, karena </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan ukuran fragmen </font><font style="vertical-align: inherit;">untuk membatasi posisinya </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ubah </font></font><code>HexMapCamera.ClampPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga dia menggunakan langsung jumlah sel yang masih dia butuhkan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.cellCountX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.cellCountZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah fragmen berukuran 5 x 5 sel, dan peta secara default memiliki ukuran 4 x 3 fragmen. </font><font style="vertical-align: inherit;">Oleh karena itu, untuk menjaga kartu tetap sama, kita harus menggunakan ukuran 20 kali 15 sel. </font><font style="vertical-align: inherit;">Dan meskipun kami telah menetapkan nilai default dalam kode, objek grid masih tidak akan menggunakannya secara otomatis, karena bidang sudah ada dan default ke 0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/2e3/da6/3992e3da66fb278c396e15a3d339707a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara default, kartu memiliki ukuran 20 hingga 15.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ukuran kartu khusus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah selanjutnya adalah dukungan untuk membuat kartu dengan ukuran berapa pun, bukan hanya ukuran standar. </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X dan Z </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">parameter. Mereka akan mengganti jumlah sel yang ada. </font><font style="vertical-align: inherit;">Di dalam, </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami hanya akan memanggil mereka dengan jumlah sel saat ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { … cellCountX = x; cellCountZ = z; chunkCountX = cellCountX / HexMetrics.chunkSizeX; chunkCountZ = cellCountZ / HexMetrics.chunkSizeZ; CreateChunks(); CreateCells(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, ini hanya akan berfungsi dengan benar dengan jumlah sel yang merupakan kelipatan dari ukuran fragmen. </font><font style="vertical-align: inherit;">Jika tidak, divisi integer akan membuat fragmen terlalu sedikit. </font><font style="vertical-align: inherit;">Meskipun kami dapat menambahkan dukungan untuk fragmen yang sebagian terisi dengan sel, mari kita melarang penggunaan ukuran yang tidak sesuai dengan fragmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menggunakan operator </font></font><code>%</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menghitung sisa pembagian jumlah sel dengan jumlah fragmen. </font><font style="vertical-align: inherit;">Jika tidak sama dengan nol, maka ada perbedaan dan kami tidak akan membuat peta baru. </font><font style="vertical-align: inherit;">Dan sementara kita melakukan ini, mari kita tambahkan perlindungan terhadap ukuran nol dan negatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menu Kartu Baru </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap saat ini, tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak lagi berfungsi, karena metode </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang memiliki dua parameter. Kami tidak dapat langsung menghubungkan acara Unity ke metode tersebut. Selain itu, untuk mendukung ukuran kartu yang berbeda, kami memerlukan beberapa tombol. Alih-alih menambahkan semua tombol ini ke UI utama, mari kita buat menu popup terpisah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan kanvas baru ke adegan ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Canvas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Kami akan menggunakan pengaturan yang sama dengan kanvas yang ada, kecuali bahwa </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urutan Urutannya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus sama dengan 1. Berkat ini, itu akan berada di atas UI editor utama. Saya membuat kanvas dan sistem acara sebagai anak dari objek UI baru sehingga hirarki adegan tetap bersih.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c91/6c5/c2c/c916c5c2cee3f58576b12ac1a052bd64.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3be/a8b/79b/3bea8b79bae11a493aea43590394b0a3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu kanvas Peta Baru. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan </font><font style="vertical-align: inherit;">panel </font><font style="vertical-align: inherit;">ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang menutup seluruh layar. </font><font style="vertical-align: inherit;">Diperlukan untuk menggelapkan latar belakang dan tidak membiarkan kursor berinteraksi dengan yang lainnya ketika menu terbuka. </font><font style="vertical-align: inherit;">Saya memberinya warna yang seragam, membersihkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Image-nya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font><font style="vertical-align: inherit;">menetapkan (0, 0, 0, 200) </font><font style="vertical-align: inherit;">sebagai </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warna</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16c/1f0/a4f/16c1f0a4f31e0769099b845794a83b4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengaturan gambar latar belakang. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan bilah menu ke tengah kanvas, mirip dengan panel </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mari kita buat label dan tombol yang jelas untuk kartu kecil, sedang dan besar. </font><font style="vertical-align: inherit;">Kami juga akan menambahkan tombol batal padanya jika pemain berubah pikiran. </font><font style="vertical-align: inherit;">Setelah selesai membuat desain, nonaktifkan seluruh </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/0d9/584/c0a0d95847337d91b97a823312c98a43.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/3a1/7c3/9173a17c38f4c6e35f258c407b44d710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Peta Baru. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengelola menu, buat komponen </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tambahkan ke kanvas objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Map Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Untuk membuat peta baru, kita perlu akses ke objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambahkan bidang umum ke sana dan menghubungkannya.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NewMapMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/a25/c3e/f7da25c3ed3ebf12ba9f4785b19ec8e1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen Menu Peta Baru.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuka dan menutup </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat membuka dan menutup menu popup hanya dengan mengaktifkan dan menonaktifkan objek kanvas. </font><font style="vertical-align: inherit;">Mari kita tambahkan </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua metode umum untuk melakukan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang sambungkan tombol </font><font style="vertical-align: inherit;">UI </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> editor ke metode </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b84/100/590/b841005902c164f5eb1dcab4f39c4221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuka menu dengan menekan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga sambungkan tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke metode </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan memungkinkan kita untuk membuka dan menutup menu popup.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat Peta Baru </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat peta baru, kita perlu memanggil </font><font style="vertical-align: inherit;">metode </font><font style="vertical-align: inherit;">di objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Selain itu, setelah itu kita perlu menutup menu pop-up. </font><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode yang akan menangani ini, dengan mempertimbangkan ukuran sewenang-wenang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode ini seharusnya tidak bersifat umum, karena kita masih tidak dapat menghubungkannya langsung ke acara tombol. </font><font style="vertical-align: inherit;">Sebagai gantinya, buat satu metode per tombol yang akan memanggil </font></font><code>CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan ukuran yang ditentukan. </font><font style="vertical-align: inherit;">Untuk peta kecil, saya menggunakan ukuran 20 kali 15, sesuai dengan ukuran standar peta. </font><font style="vertical-align: inherit;">Untuk kartu tengah, saya memutuskan untuk menggandakan ukuran ini, mendapatkan 40 oleh 30, dan menggandakannya lagi untuk kartu besar. </font><font style="vertical-align: inherit;">Hubungkan tombol dengan metode yang sesuai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateSmallMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMediumMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateLargeMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kunci kamera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menggunakan menu pop-up untuk membuat peta baru dengan tiga ukuran berbeda! Semuanya bekerja dengan baik, tetapi kita perlu mengurus sedikit detail. Ketika </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aktif, kita tidak dapat lagi berinteraksi dengan UI editor dan mengedit sel. Namun, kami masih dapat mengontrol kamera. Idealnya, dengan menu terbuka, kamera harus mengunci. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita hanya memiliki satu kamera, solusi cepat dan pragmatis adalah dengan menambahkan properti statis padanya </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Untuk penggunaan luas, solusi ini tidak terlalu cocok, tetapi untuk antarmuka sederhana kami, ini sudah cukup. Ini mengharuskan kami melacak instance statis di dalam </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang diatur ketika kamera Sedarlah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexMapCamera instance; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Properti </font></font><code>Locked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat menjadi properti Boolean statis sederhana hanya dengan setter. </font><font style="vertical-align: inherit;">Yang dilakukannya hanyalah mematikan instance </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat dikunci, dan menyalakannya saat tidak terkunci.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Locked { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { instance.enabled = !<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang ia </font></font><code>NewMapMenu.Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat memblokir kamera, dan </font></font><code>NewMapMenu.Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- membuka kuncinya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mempertahankan posisi kamera yang benar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan ada masalah lain dengan kamera. </font><font style="vertical-align: inherit;">Saat membuat peta baru yang lebih kecil dari yang sekarang, kamera mungkin muncul di luar batas peta. </font><font style="vertical-align: inherit;">Dia akan tetap di sana sampai pemain mencoba untuk memindahkan kamera. </font><font style="vertical-align: inherit;">Dan hanya dengan demikian akan dibatasi oleh batas-batas peta baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, kita dapat menambahkan </font></font><code>HexMapCamera</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode statis </font></font><code>ValidatePosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Memanggil metode </font></font><code>AdjustPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instan dengan offset nol akan memaksa kamera untuk bergerak ke batas peta. </font><font style="vertical-align: inherit;">Jika kamera sudah berada di dalam batas peta baru, maka ia akan tetap di tempatnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidatePosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { instance.AdjustPosition(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggil metode di dalam </font></font><code>NewMapMenu.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah membuat peta baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { hexGrid.CreateMap(x, z); HexMapCamera.ValidatePosition(); Close(); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyimpan Ukuran Peta </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun kami dapat membuat kartu dengan ukuran berbeda, itu tidak diperhitungkan saat menyimpan dan memuat. </font><font style="vertical-align: inherit;">Ini berarti bahwa memuat peta akan menyebabkan kesalahan atau peta yang salah jika ukuran peta saat ini tidak cocok dengan ukuran yang dimuat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, sebelum memuat data sel, kita perlu membuat peta baru dengan ukuran yang sesuai. </font><font style="vertical-align: inherit;">Katakanlah kita memiliki peta kecil yang disimpan. </font><font style="vertical-align: inherit;">Dalam hal ini, semuanya akan baik-baik saja jika kita membuat </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peta 20 x 15 </font><font style="vertical-align: inherit;">di awal </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Load(reader); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].Refresh(); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penyimpanan ukuran kartu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, kita dapat menyimpan kartu dengan berbagai ukuran. </font><font style="vertical-align: inherit;">Oleh karena itu, solusi umum adalah menyimpan ukuran peta di depan sel-sel ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryWriter writer</span></span></span><span class="hljs-function">)</span></span> { writer.Write(cellCountX); writer.Write(cellCountZ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lalu kita bisa mendapatkan ukuran sebenarnya dan menggunakannya untuk membuat peta dengan ukuran yang benar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader</span></span></span><span class="hljs-function">)</span></span> { CreateMap(reader.ReadInt32(), reader.ReadInt32()); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sekarang kita dapat memuat peta dengan ukuran berbeda, kita kembali dihadapkan pada masalah posisi kamera. </font><font style="vertical-align: inherit;">Kami akan menyelesaikannya dengan memeriksa posisinya </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah memuat peta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Format file baru </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun pendekatan ini berfungsi dengan kartu yang akan kita simpan di masa depan, itu tidak akan bekerja dengan yang lama. </font><font style="vertical-align: inherit;">Dan sebaliknya - kode dari bagian sebelumnya dari tutorial tidak akan dapat memuat file peta baru dengan benar. </font><font style="vertical-align: inherit;">Untuk membedakan antara format lama dan baru, kami akan meningkatkan nilai integer dari header. </font><font style="vertical-align: inherit;">Format penyimpanan lama tanpa ukuran peta memiliki versi 0. Format baru dengan ukuran peta akan memiliki versi 1. Oleh karena itu, saat merekam, </font></font><code>HexMapEditor.Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menuliskan 1 bukan 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ( BinaryWriter writer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(<span class="hljs-number"><span class="hljs-number">1</span></span>); hexGrid.Save(writer); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai sekarang, kartu akan disimpan sebagai versi 1. Jika kami mencoba membukanya di tutorial dari tutorial sebelumnya, mereka akan menolak memuat dan melaporkan pada format kartu yang tidak dikenal. </font><font style="vertical-align: inherit;">Faktanya, ini akan terjadi jika kita sudah mencoba memuat kartu semacam itu. </font><font style="vertical-align: inherit;">Anda perlu mengubah metode </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menerima versi baru.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = Path.Combine(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"test.map"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (BinaryReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryReader(File.OpenRead(path))) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> header = reader.ReadInt32(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header == <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader); HexMapCamera.ValidatePosition(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"Unknown map format "</span></span> + header); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompatibilitas mundur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan, jika kita mau, kita masih bisa mengunduh peta versi 0, dengan asumsi mereka semua memiliki ukuran yang sama 20 kali 15. Artinya, judulnya tidak harus 1, juga bisa nol. </font><font style="vertical-align: inherit;">Karena setiap versi memerlukan pendekatannya sendiri, itu </font></font><code>HexMapEditor.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus meneruskan header ke metode </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">judul </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">parameter dan gunakan untuk membuat keputusan tentang tindakan selanjutnya. </font><font style="vertical-align: inherit;">Jika header tidak kurang dari 1, maka Anda perlu membaca data ukuran kartu. </font><font style="vertical-align: inherit;">Kalau tidak, kami menggunakan kartu ukuran tetap lama 20 dengan 15 dan lewati membaca data ukuran.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } CreateMap(x, z); … }</code> </pre> <br> <a href="" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file peta versi 0</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cek Ukuran Kartu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti halnya membuat peta baru, secara teori dimungkinkan bahwa kita harus memuat peta yang tidak kompatibel dengan ukuran fragmen. </font><font style="vertical-align: inherit;">Ketika ini terjadi, kita harus menghentikan unduhan kartu. </font></font><code>HexGrid.CreateMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah menolak untuk membuat peta dan menampilkan kesalahan di konsol. </font><font style="vertical-align: inherit;">Untuk memberitahukan hal ini kepada pemanggil metode, mari kita mengembalikan bool jitu jika peta dibuat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateMap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || x % HexMetrics.chunkSizeX != <span class="hljs-number"><span class="hljs-number">0</span></span> || z &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || z % HexMetrics.chunkSizeZ != <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"Unsupported map size."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, </font></font><code>HexGrid.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu juga dapat menghentikan eksekusi ketika pembuatan peta gagal.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">20</span></span>, z = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (header &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { x = reader.ReadInt32(); z = reader.ReadInt32(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena memuat menimpa semua data dalam sel yang ada, kita tidak perlu membuat peta baru jika peta dengan ukuran yang sama dimuat. </font><font style="vertical-align: inherit;">Karena itu, langkah ini bisa dilewati.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != cellCountX || z != cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateMap(x, z)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajemen file </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menyimpan dan memuat kartu dengan ukuran berbeda, tetapi selalu menulis dan membaca </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sekarang kami akan menambahkan dukungan untuk file yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih langsung menyimpan atau memuat peta, kami menggunakan menu pop-up lain yang menyediakan manajemen file tingkat lanjut. </font><font style="vertical-align: inherit;">Buat kanvas lain, seperti di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tapi kali ini kami akan menyebutnya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simpan Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Menu ini akan menyimpan dan memuat peta, tergantung pada tombol yang ditekan untuk membukanya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan membuat desain </font><em><font style="vertical-align: inherit;">Save Load Menu</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti itu adalah menu simpan. Nanti kita akan secara dinamis mengubahnya menjadi menu boot. Seperti menu lain, menu harus memiliki latar belakang dan bilah menu, label menu, dan tombol batal. Kemudian tambahkan tampilan gulir ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Scroll View</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ke menu untuk menampilkan daftar file. Di bawah ini kami memasukkan bidang input ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Input Field</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) untuk menunjukkan nama-nama kartu baru. Kami juga membutuhkan tombol aksi untuk menyimpan peta. Dan akhirnya. tambahkan tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hapus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menghapus kartu yang tidak perlu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c73/279/198/c732791989e1eb6fa53e73ec3435bc74.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/176/485/3da/1764853da66092443c0327638dc1803a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desain Simpan Menu Muat.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secara default, tampilan gulir memungkinkan pengguliran horizontal dan vertikal, tetapi kita hanya perlu daftar dengan pengguliran vertikal. Oleh karena itu, menonaktifkan bergulir </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mencabut horizontal scroll bar. Kami juga mengatur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis Gerakan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk dijepit dan menonaktifkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inersia</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk membuat daftar tampak lebih ketat.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/3a9/e36/43f3a9e36202f436772f54eedcd96c76.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi Daftar File. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menghapus anak </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horizontal Scrollbar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar File</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena kami tidak membutuhkannya. </font><font style="vertical-align: inherit;">Kemudian mengubah ukuran </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scrollbar Vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga </font><em><font style="vertical-align: inherit;">mencapai bagian</font></em><font style="vertical-align: inherit;"> bawah daftar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teks placeholder untuk objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input Nama</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat diubah di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placeholder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anaknya </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya menggunakan teks deskriptif, tetapi Anda bisa membiarkannya kosong dan menyingkirkan placeholder.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/7d5/d17/ed57d5d17dfb0695fc4b2f5f3f9dc8a5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desain menu berubah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami selesai dengan desain, dan sekarang menonaktifkan menu sehingga secara default tersembunyi.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manajemen menu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar menu berfungsi, kita perlu skrip lain, dalam hal ini - </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seperti </font></font><code>NewMapMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ini membutuhkan tautan ke kisi, serta metode </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan komponen ini ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveLoadMenu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan berikan tautan ke objek kisi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/974/86f/440/97486f440f44d4db9c744cfa9b6acec0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen SaveLoadMenu. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu akan terbuka untuk menyimpan atau memuat. </font><font style="vertical-align: inherit;">Untuk menyederhanakan pekerjaan, tambahkan </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter Boolean </font><font style="vertical-align: inherit;">ke metode </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini menentukan apakah menu harus dalam mode simpan. </font><font style="vertical-align: inherit;">Kami akan melacak mode ini di lapangan untuk mengetahui tindakan apa yang harus dilakukan nanti.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> saveMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang menggabungkan tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simpan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beban</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obyek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Peta Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan metode </font></font><code>Open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simpan Muat Menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Periksa parameter boolean hanya untuk tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simpan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38c/59c/44f/38c59c44fa001e97128532d7c7d92168.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuka menu dalam mode simpan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda belum melakukannya, hubungkan acara tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke metode </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sekarang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simpan Beban menu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat dibuka dan ditutup.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berubah penampilan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menciptakan menu sebagai menu simpan, tetapi modenya ditentukan oleh tombol yang ditekan untuk membuka. </font><font style="vertical-align: inherit;">Kita perlu mengubah tampilan menu tergantung pada mode. </font><font style="vertical-align: inherit;">Secara khusus, kita perlu mengubah label menu dan label tombol aksi. </font><font style="vertical-align: inherit;">Ini artinya kita perlu tautan ke tag-tag ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text menuLabel, actionButtonLabel; … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/4d3/b8d/e7c4d3b8d55ce8c333d38be996a3ebc1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koneksi dengan tag. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menu terbuka dalam mode simpan, kami menggunakan label yang ada, yaitu, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simpan Peta</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menu dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simpan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk tombol aksi. </font><font style="vertical-align: inherit;">Kalau tidak, kita berada dalam mode pemuatan, yaitu, kami menggunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muat Peta</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveMode = saveMode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Save Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Save"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { menuLabel.text = <span class="hljs-string"><span class="hljs-string">"Load Map"</span></span>; actionButtonLabel.text = <span class="hljs-string"><span class="hljs-string">"Load"</span></span>; } gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masukkan nama kartu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita tinggalkan daftar file untuk saat ini. </font><font style="vertical-align: inherit;">Pengguna dapat menentukan file yang disimpan atau diunduh dengan memasukkan nama kartu di kolom input. </font><font style="vertical-align: inherit;">Untuk mendapatkan data ini, kita perlu referensi ke komponen </font></font><code>InputField</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input Nama</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InputField nameInput;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e49/8e0/021/e498e002162a42103571cfac7cf91221.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koneksi ke kolom input. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengguna tidak perlu dipaksa untuk memasukkan path lengkap ke file peta. </font><font style="vertical-align: inherit;">Hanya cukup nama kartu tanpa ekstensi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mari kita tambahkan metode yang mengambil input pengguna dan menciptakan jalur yang tepat untuk itu. </font><font style="vertical-align: inherit;">Ini tidak mungkin ketika input kosong, jadi dalam hal ini kami akan kembali </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectedPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName = nameInput.text; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mapName.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Path.Combine(Application.persistentDataPath, mapName + <span class="hljs-string"><span class="hljs-string">".map"</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang terjadi jika pengguna memasukkan karakter yang tidak valid?</font></font></b> <div class="spoiler_text">        ,       .  ,      ,         . <br><br>         <em>Content Type</em>  . ,       - ,     .      ,    ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menyimpan dan memuat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang akan terlibat dalam menyimpan dan memuat </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Oleh karena itu, kita bergerak metode </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mereka tidak lagi harus dibagikan, dan akan bekerja dengan parameter path, bukan path tetap.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// string path = Path.Combine(Application.persistentDataPath, "test.map"); using ( BinaryWriter writer = new BinaryWriter(File.Open(path, FileMode.Create)) ) { writer.Write(1); hexGrid.Save(writer); } } void Load (string path) { // string path = Path.Combine(Application.persistentDataPath, "test.map"); using (BinaryReader reader = new BinaryReader(File.OpenRead(path))) { int header = reader.ReadInt32(); if (header &lt;= 1) { hexGrid.Load(reader, header); HexMapCamera.ValidatePosition(); } else { Debug.LogWarning("Unknown map format " + header); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita sekarang mengunggah file sewenang-wenang, alangkah baiknya untuk memverifikasi bahwa file itu benar-benar ada, dan baru kemudian mencoba membacanya. </font><font style="vertical-align: inherit;">Jika tidak, maka kami melakukan kesalahan dan menghentikan operasi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!File.Exists(path)) { Debug.LogError(<span class="hljs-string"><span class="hljs-string">"File does not exist "</span></span> + path); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tambahkan metode umum </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dimulai dengan mendapatkan jalur yang dipilih pengguna. </font><font style="vertical-align: inherit;">Jika ada jalan, simpan atau muat. </font><font style="vertical-align: inherit;">Kemudian tutup menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (saveMode) { Save(path); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Load(path); } Close(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan melampirkan acara </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tombol Aksi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke metode ini </font><font style="vertical-align: inherit;">, kita dapat menyimpan dan memuat menggunakan nama peta yang berubah-ubah. </font><font style="vertical-align: inherit;">Karena kami tidak menyetel ulang bidang input, nama yang dipilih akan tetap sampai berikutnya menyimpan atau memuat. </font><font style="vertical-align: inherit;">Ini nyaman untuk menyimpan atau memuat dari satu file beberapa kali berturut-turut, jadi kami tidak akan mengubah apa pun.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Peta Daftar Item </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita akan mengisi daftar file dengan semua kartu yang ada di jalur penyimpanan data. </font><font style="vertical-align: inherit;">Ketika Anda mengklik salah satu item dalam daftar, itu akan digunakan sebagai teks di </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input Nama</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tambahkan </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode umum untuk ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItem</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { nameInput.text = name; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membutuhkan sesuatu yang merupakan item daftar. </font><font style="vertical-align: inherit;">Tombol biasa akan berfungsi. </font><font style="vertical-align: inherit;">Buat dan kurangi ketinggian hingga 20 unit sehingga tidak memakan banyak ruang secara vertikal. </font><font style="vertical-align: inherit;">Seharusnya tidak terlihat seperti sebuah tombol, sehingga membersihkan Link </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber Gambar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> komponennya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam hal ini, itu akan menjadi sepenuhnya putih. </font><font style="vertical-align: inherit;">Selain itu, kami akan memastikan bahwa label disejajarkan ke kiri dan bahwa ada ruang antara teks dan sisi kiri tombol. </font><font style="vertical-align: inherit;">Setelah selesai dengan desain tombol, kami mengubahnya menjadi cetakan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/0f0/6e5/5010f06e5b380440bca024ffb8c0e307.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/60b/21f/67b60b21f34e4ae69846c35ed5583fae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tombol adalah item daftar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak dapat secara langsung menghubungkan acara tombol ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu Peta Baru</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena ini adalah cetakan dan belum ada di tempat kejadian. </font><font style="vertical-align: inherit;">Oleh karena itu, item menu memerlukan tautan ke menu sehingga dapat memanggil metode ketika diklik </font></font><code>SelectItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dia juga perlu melacak nama kartu yang diwakilinya, dan mengatur teksnya. </font><font style="vertical-align: inherit;">Mari kita buat komponen kecil untuk ini </font></font><code>SaveLoadItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadItem</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadMenu menu; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MapName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mapName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { mapName = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>).GetComponent&lt;Text&gt;().text = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mapName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { menu.SelectItem(mapName); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan komponen ke item menu dan buat panggilan tombol metodenya </font></font><code>Select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/249/172/7a0/2491727a0c07b0b92e89db0e3c02fe67.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen barang.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Isi Daftar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengisi daftar, Anda </font></font><code>SaveLoadMenu</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memerlukan tautan ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di dalam </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viewport</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar File</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dia juga membutuhkan tautan ke cetakan barang.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform listContent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SaveLoadItem itemPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b6/22a/0eb/4b622a0eb5cf47422ce591dcd5c120e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Campurkan isi daftar dan cetakan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan metode baru untuk mengisi daftar ini. </font><font style="vertical-align: inherit;">Langkah pertama adalah mengidentifikasi file peta yang ada. </font><font style="vertical-align: inherit;">Untuk mendapatkan larik semua jalur file di dalam direktori, kita dapat menggunakan metode ini </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode ini memiliki parameter kedua yang memungkinkan Anda memfilter file. </font><font style="vertical-align: inherit;">Dalam kasus kami, hanya file yang cocok dengan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* .map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mask yang diperlukan </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, pesanan file tidak dijamin. </font><font style="vertical-align: inherit;">Untuk menampilkannya dalam urutan abjad, kita perlu mengurutkan array </font></font><code>System.Array.Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SaveLoadMenu</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] paths = Directory.GetFiles(Application.persistentDataPath, <span class="hljs-string"><span class="hljs-string">"*.map"</span></span>); Array.Sort(paths); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita akan membuat instance cetakan untuk setiap elemen array. </font><font style="vertical-align: inherit;">Bind item ke menu, atur nama petanya dan jadikan sebagai anak isi daftar.</font></font><br><br><pre> <code class="cs hljs"> Array.Sort(paths); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; paths.Length; i++) { SaveLoadItem item = Instantiate(itemPrefab); item.menu = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; item.MapName = paths[i]; item.transform.SetParent(listContent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena </font></font><code>Directory.GetFiles</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan path lengkap ke file, kita perlu menghapusnya. </font><font style="vertical-align: inherit;">Untungnya, inilah yang membuat metode yang nyaman </font></font><code>Path.GetFileNameWithoutExtension</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> item.MapName = Path.GetFileNameWithoutExtension(paths[i]);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum menampilkan menu, kita perlu mengisi daftar. </font><font style="vertical-align: inherit;">Dan karena file cenderung berubah, kita perlu melakukan ini setiap kali kita membuka menu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Open</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> saveMode</span></span></span><span class="hljs-function">)</span></span> { … FillList(); gameObject.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); HexMapCamera.Locked = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat mengisi ulang daftar, kita perlu menghapus semua yang lama sebelum menambahkan item baru. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillList</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; listContent.childCount; i++) { Destroy(listContent.GetChild(i).gameObject); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c83/4ff/fc3/c834fffc34b03b0d39de0056796fa199.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Barang tanpa pengaturan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengaturan poin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang daftar akan menampilkan item, tetapi mereka akan tumpang tindih dan berada di posisi yang buruk. Untuk mengubahnya menjadi daftar vertikal, tambahkan </font><font style="vertical-align: inherit;">komponen </font><em><font style="vertical-align: inherit;">Grup Tata Letak Vertikal</font></em><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">Komponen / Tata Letak / Grup Tata Letak Vertikal</font></em><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">ke objek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daftar </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Agar pengaturan berfungsi dengan benar, aktifkan </font><em><font style="vertical-align: inherit;">Lebar</font></em><font style="vertical-align: inherit;"> dari </font><em><font style="vertical-align: inherit;">Child Control Size</font></em><font style="vertical-align: inherit;"> dan </font><em><font style="vertical-align: inherit;">Child Force Expand</font></em><font style="vertical-align: inherit;"> . Kedua opsi </font><em><font style="vertical-align: inherit;">Tinggi</font></em><font style="vertical-align: inherit;"> harus dinonaktifkan.</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/32e/aac/39232eaac1c1741718d8993aae992bb4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/aba/ce4/7ddabace4df7d61a274544889de9a3c2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan grup tata letak vertikal. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami punya daftar barang yang indah. </font><font style="vertical-align: inherit;">Namun, ukuran isi daftar tidak menyesuaikan dengan jumlah item yang sebenarnya. </font><font style="vertical-align: inherit;">Karena itu, bilah gulir tidak pernah mengubah ukuran. </font><font style="vertical-align: inherit;">Kami dapat memaksa </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konten untuk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengubah ukuran secara otomatis dengan menambahkan komponen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitter Ukuran Konten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Component / Layout / Content Size Fitter</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ke dalamnya. </font><font style="vertical-align: inherit;">Mode </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertical Fit-nya</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus diatur ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preferred Size</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/c56/fdb/34ec56fdb61e1d3a2bc71989333a7a8a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/a17/bf1/acba17bf1387ddb89b00ea48c9e31035.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan bugar ukuran konten. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang dengan sejumlah kecil poin, scrollbar akan hilang. </font><font style="vertical-align: inherit;">Dan ketika ada terlalu banyak item dalam daftar yang tidak sesuai dengan viewport, bilah gulir muncul dan memiliki ukuran yang sesuai.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/327/460/6d8/3274606d8e5831f783d282d5122e55cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilah gulir muncul.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penghapusan kartu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat dengan mudah bekerja dengan banyak file peta. </font><font style="vertical-align: inherit;">Namun, terkadang perlu untuk menyingkirkan beberapa kartu. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda dapat menggunakan tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hapus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mari kita membuat metode untuk ini dan membuat tombol menyebutnya. </font><font style="vertical-align: inherit;">Jika ada jalur yang dipilih, cukup hapus dengan </font></font><code>File.Delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = GetSelectedPath(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita juga harus memeriksa apakah kita bekerja dengan file yang benar-benar ada. </font><font style="vertical-align: inherit;">Jika ini bukan masalahnya, maka kita seharusnya tidak mencoba untuk menghapusnya, tetapi ini tidak mengarah pada kesalahan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mengeluarkan kartu, kita tidak perlu menutup menu. </font><font style="vertical-align: inherit;">Ini membuatnya lebih mudah untuk menghapus banyak file sekaligus. </font><font style="vertical-align: inherit;">Namun, setelah dihapus, kita perlu menghapus </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input Nama</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , serta memperbarui daftar file.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (File.Exists(path)) { File.Delete(path); } nameInput.text = <span class="hljs-string"><span class="hljs-string">""</span></span>; FillList();</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 14: tekstur relief </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gunakan warna titik untuk membuat peta percikan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat aset tekstur array. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menambahkan indeks ketinggian ke jerat. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transisi antara tekstur relief. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sampai saat ini, kami menggunakan warna solid untuk mewarnai kartu. </font><font style="vertical-align: inherit;">Sekarang kita akan menerapkan tekstur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4da/9e8/4fa/4da9e84faf824fdcf3933310de58ff9c.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggambar tekstur.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Campuran tiga jenis </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun warna seragam jelas dapat dibedakan dan cukup sesuai dengan tugas, mereka tidak terlihat sangat menarik. </font><font style="vertical-align: inherit;">Menggunakan tekstur akan secara signifikan meningkatkan daya tarik peta. </font><font style="vertical-align: inherit;">Tentu saja, untuk ini kita harus mencampur tekstur, bukan hanya warna. </font><font style="vertical-align: inherit;">Dalam tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3, Combining Textures,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya berbicara tentang cara mencampurkan banyak tekstur menggunakan peta splat. </font><font style="vertical-align: inherit;">Di peta segi enam kami, Anda dapat menggunakan pendekatan serupa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya empat tekstur yang dicampur, dan dengan satu peta percikan kami dapat mendukung hingga lima tekstur. </font><font style="vertical-align: inherit;">Saat ini, kami menggunakan lima warna berbeda, jadi ini sangat cocok untuk kami. </font><font style="vertical-align: inherit;">Namun, nanti kita bisa menambahkan tipe lain. </font><font style="vertical-align: inherit;">Oleh karena itu, dukungan untuk sejumlah jenis bantuan diperlukan. </font><font style="vertical-align: inherit;">Saat menggunakan properti tekstur yang ditetapkan secara eksplisit, ini tidak mungkin, jadi Anda harus menggunakan array tekstur. </font><font style="vertical-align: inherit;">Nanti kita akan membuatnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menggunakan array tekstur, kita perlu memberi tahu shader tekstur mana yang harus dicampur. </font><font style="vertical-align: inherit;">Pencampuran yang paling sulit diperlukan untuk segitiga siku-siku, yang bisa antara tiga sel dengan jenis medan mereka sendiri. </font><font style="vertical-align: inherit;">Oleh karena itu, kami membutuhkan dukungan pencampuran antara tiga jenis per segitiga.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan warna titik sebagai Splat Maps </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan asumsi kami dapat memberi tahu Anda tekstur mana yang akan dicampurkan, kami dapat menggunakan warna titik untuk membuat peta percikan untuk setiap segitiga. </font><font style="vertical-align: inherit;">Karena dalam setiap kasus maksimal tiga tekstur digunakan, kami hanya membutuhkan tiga saluran warna. </font><font style="vertical-align: inherit;">Merah akan mewakili tekstur pertama, hijau - yang kedua, dan biru - yang ketiga.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf1/3fb/603/cf13fb603f1d7ab8e83d9290b483b9ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta Triangle Splat.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah jumlah peta splat segitiga selalu sama dengan satu?</font></font></b> <div class="spoiler_text">  Ya         .     . ,        (1, 0, 0)  ,  (½, ½, 0)     (&amp;frac13;, &amp;frac13;, &amp;frac13;)  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika sebuah segitiga hanya membutuhkan satu tekstur, kami hanya menggunakan saluran pertama. </font><font style="vertical-align: inherit;">Artinya, warnanya akan sepenuhnya merah. </font><font style="vertical-align: inherit;">Dalam hal pencampuran antara dua jenis yang berbeda, kami menggunakan saluran pertama dan kedua. </font><font style="vertical-align: inherit;">Artinya, warna segitiga akan menjadi campuran merah dan hijau. </font><font style="vertical-align: inherit;">Dan ketika ketiga jenis ini ditemukan, maka itu akan menjadi campuran merah, hijau dan biru.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/364/890/aa33648906f62a94be8a45aba4bd80de.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga konfigurasi peta percikan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menggunakan konfigurasi peta percikan ini terlepas dari tekstur mana yang sebenarnya tercampur. </font><font style="vertical-align: inherit;">Artinya, peta percikan akan selalu sama. </font><font style="vertical-align: inherit;">Hanya tekstur yang akan berubah. </font><font style="vertical-align: inherit;">Cara melakukan ini, kita akan mencari tahu nanti. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita perlu mengubah </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga menciptakan peta percikan ini, daripada menggunakan warna sel. </font><font style="vertical-align: inherit;">Karena kita akan sering menggunakan tiga warna, kita akan membuat bidang statis untuknya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Color color3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pusat sel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan mengganti warna pusat sel secara default. </font><font style="vertical-align: inherit;">Tidak ada pencampuran yang dilakukan di sini, jadi kami hanya menggunakan warna pertama, yaitu merah.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, color1); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/44b/f10/3e944bf109bb387ab6a620ea680c2772.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pusat sel merah. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pusat sel sekarang menjadi merah. </font><font style="vertical-align: inherit;">Mereka semua menggunakan yang pertama dari tiga tekstur, tidak peduli apa teksturnya. </font><font style="vertical-align: inherit;">Peta percikannya sama, terlepas dari warna yang digunakan untuk mewarnai sel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lingkungan Sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengubah segmen hanya di dalam sel tanpa sungai mengalir di sepanjang mereka. </font><font style="vertical-align: inherit;">Kita perlu melakukan hal yang sama untuk segmen yang berdekatan dengan sungai. </font><font style="vertical-align: inherit;">Dalam kasus kami, ini adalah strip tulang rusuk dan penggemar segitiga rusuk. </font><font style="vertical-align: inherit;">Di sini juga, hanya merah yang cukup untuk kita.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/846/a8a/b7c846a8a2a4b5a2670b77359d55f9f6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmen merah berdekatan dengan sungai.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita perlu menjaga geometri sungai di dalam sel. </font><font style="vertical-align: inherit;">Semuanya juga harus berubah menjadi merah. </font><font style="vertical-align: inherit;">Untuk memulainya, mari kita lihat awal dan akhir sungai.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeFan(center, m, color1); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kemudian geometri yang membentuk tepi dan dasar sungai. </font><font style="vertical-align: inherit;">Saya telah mengelompokkan panggilan metode warna untuk membuat kode lebih mudah dibaca.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateEdgeStrip(m, color1, e, color1); terrain.AddTriangle(centerL, m.v1, m.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(cell.Color); terrain.AddQuad(centerL, center, m.v2, m.v3); // terrain.AddQuadColor(cell.Color); terrain.AddQuad(center, centerR, m.v3, m.v4); // terrain.AddQuadColor(cell.Color); terrain.AddTriangle(centerR, m.v4, m.v5); // terrain.AddTriangleColor(cell.Color); terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da8/46a/455/da846a455aa262ddff54429faa207267.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sungai merah di sepanjang sel.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iga </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua tepi berbeda karena berada di antara sel yang dapat memiliki jenis medan yang berbeda. </font><font style="vertical-align: inherit;">Kami menggunakan warna pertama untuk jenis sel saat ini, dan warna kedua untuk jenis tetangga. </font><font style="vertical-align: inherit;">Akibatnya, peta percikan akan menjadi gradien merah-hijau, bahkan jika kedua sel memiliki tipe yang sama. </font><font style="vertical-align: inherit;">Jika kedua sel menggunakan tekstur yang sama, maka itu hanya menjadi campuran dari tekstur yang sama di kedua sisi.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/42b/88c/36842b88cd626359ef4adfd4c3b99b13.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iga merah-hijau, tidak termasuk tepian.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukankah transisi yang tajam antara merah dan hijau menyebabkan masalah?</font></font></b> <div class="spoiler_text">   ,         ,      .        .     splat map,         .            . <br><br>  ,           . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tepi dengan tepian sedikit lebih rumit, karena mereka memiliki simpul tambahan. </font><font style="vertical-align: inherit;">Untungnya, kode interpolasi yang ada berfungsi dengan baik dengan warna peta percikan. </font><font style="vertical-align: inherit;">Cukup gunakan warna pertama dan kedua, bukan warna sel-sel awal dan akhir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, color1, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, color2, hasRoad); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/635/fe1/450635fe13e41a888046f2f7e0cce830.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulang rusuk merah-hijau.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sudut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudut sel adalah yang paling sulit karena mereka harus mencampur tiga tekstur yang berbeda. </font><font style="vertical-align: inherit;">Kami menggunakan merah untuk puncak bawah, hijau untuk kiri dan biru untuk kanan. </font><font style="vertical-align: inherit;">Mari kita mulai dengan sudut satu segitiga.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/d9c/218/10ad9c21858e48e059c92bbed08c779f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sudut merah-hijau-biru, kecuali untuk tepian. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita kembali dapat menggunakan kode interpolasi warna yang ada untuk sudut dengan tepian. </font><font style="vertical-align: inherit;">Hanya interpolasi dilakukan antara tiga, bukan dua warna. </font><font style="vertical-align: inherit;">Pertama, perhatikan tepian yang tidak dekat tebing.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/d1d/6b3/504d1d6b3997b321e0a6e7bf5aa253f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tepi sudut merah-hijau-biru, kecuali tepian di sepanjang tebing. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika datang ke tebing, kita perlu menggunakan metode </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode ini menerima sel awal dan kiri sebagai parameter. </font><font style="vertical-align: inherit;">Namun, sekarang kita membutuhkan warna percikan yang sesuai, yang dapat bervariasi tergantung pada topologi. </font><font style="vertical-align: inherit;">Karena itu, kami mengganti parameter ini dengan warna.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubahlah </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agar menggunakan warna yang benar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color3, b); TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan lakukan hal yang sama untuk </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … Color boundaryColor = Color.Lerp(color1, color2, b); TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f89/7e0/e40/f897e0e408335e1e7b198ced5e1dc8ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peta bantuan percikan penuh. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array Tekstur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang karena medan kami memiliki peta percikan, kami dapat meneruskan koleksi tekstur ke shader. </font><font style="vertical-align: inherit;">Kami tidak bisa hanya menetapkan shader ke array tekstur C #, karena array harus ada dalam memori GPU sebagai satu kesatuan. </font><font style="vertical-align: inherit;">Kita harus menggunakan objek khusus </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang telah didukung di Unity sejak versi 5.4.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah semua GPU mendukung susunan tekstur?</font></font></b> <div class="spoiler_text">  GPU  ,         .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Unity</a> . <br><ul><li> Direct3D 11/12 (Windows, Xbox One) </li><li> OpenGL Core (Mac OS X, Linux) </li><li> Metal (iOS, Mac OS X) </li><li> OpenGL ES 3.0 (Android, iOS, WebGL 2.0) </li><li> PlayStation 4 </li></ul></div></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tuan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, dukungan Unity untuk array tekstur di versi 5.5 sangat minim. </font><font style="vertical-align: inherit;">Kami tidak bisa hanya membuat aset array tekstur dan memberikan tekstur padanya. </font><font style="vertical-align: inherit;">Kita harus melakukannya secara manual. </font><font style="vertical-align: inherit;">Kami dapat membuat array tekstur dalam mode Putar, atau membuat aset di editor. </font><font style="vertical-align: inherit;">Mari kita membuat aset.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa membuat aset?</font></font></b> <div class="spoiler_text">     ,         Play    .        ,        . <br><br>     ,    . Unity            .            ,    . ,       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat array tekstur, kita akan merakit master kita sendiri. </font><font style="vertical-align: inherit;">Buat skrip </font></font><code>TextureArrayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan letakkan di dalam folder </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sebagai gantinya, </font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu harus memperluas jenis </font></font><code>ScriptableWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari namespace </font></font><code>UnityEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TextureArrayWizard</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableWizard</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat membuka wizard melalui metode statis umum </font></font><code>ScriptableWizard.DisplayWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Parameternya adalah nama-nama jendela penyihir dan tombol buatnya. </font><font style="vertical-align: inherit;">Kami akan memanggil metode ini dalam metode statis </font></font><code>CreateWizard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ScriptableWizard.DisplayWizard&lt;TextureArrayWizard&gt;( <span class="hljs-string"><span class="hljs-string">"Create Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Create"</span></span> ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengakses wizard melalui editor, kita perlu menambahkan metode ini ke menu Unity. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menambahkan atribut ke metode </font></font><code>MenuItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita tambahkan ke menu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aset</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan lebih khusus lagi ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array Aset / Buat / Tekstur</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">MenuItem(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Assets/Create/Texture Array"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateWizard</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/2b4/433/f7d2b44333870be6838dcd48ea3a697f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wizard kustom kami. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan item menu baru, Anda dapat membuka menu pop-up dari wizard khusus kami. </font><font style="vertical-align: inherit;">Itu tidak terlalu indah, tetapi cocok untuk memecahkan masalah. </font><font style="vertical-align: inherit;">Namun, masih kosong. </font><font style="vertical-align: inherit;">Untuk membuat larik tekstur, kita perlu larik tekstur. </font><font style="vertical-align: inherit;">Tambahkan bidang umum untuk master. </font><font style="vertical-align: inherit;">GUI standar dari wizard menampilkannya seperti yang dilakukan oleh inspektur standar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D[] textures;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/beb/aa7/d6d/bebaa7d6dd8e0d995ea485d670ea5a0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kuasai dengan tekstur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ayo buat sesuatu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika Anda mengklik tombol </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wizard, itu menghilang. </font><font style="vertical-align: inherit;">Selain itu, Unity mengeluh bahwa tidak ada metode </font></font><code>OnWizardCreate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah metode yang dipanggil saat tombol buat diklik, jadi kita perlu menambahkannya ke wizard.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita akan membuat susunan tekstur kita. </font><font style="vertical-align: inherit;">Setidaknya jika pengguna menambahkan tekstur ke master. </font><font style="vertical-align: inherit;">Jika tidak, tidak ada yang dibuat dan pekerjaan harus dihentikan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnWizardCreate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah selanjutnya adalah meminta lokasi untuk menyimpan aset array tekstur. </font><font style="vertical-align: inherit;">Panel penyimpanan file dapat dibuka menggunakan metode ini </font></font><code>EditorUtility.SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Parameternya menentukan nama panel, nama file default, ekstensi file dan deskripsi. </font><font style="vertical-align: inherit;">Array tekstur menggunakan ekstensi file </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aset</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umum </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (textures.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> );</code> </pre> <br> <code>SaveFilePanelInProject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan jalur file yang dipilih pengguna. </font><font style="vertical-align: inherit;">Jika pengguna mengklik batal pada panel ini, jalan akan menjadi string kosong. </font><font style="vertical-align: inherit;">Karena itu, dalam hal ini, kita harus mengganggu pekerjaan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = EditorUtility.SaveFilePanelInProject( <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"Texture Array"</span></span>, <span class="hljs-string"><span class="hljs-string">"asset"</span></span>, <span class="hljs-string"><span class="hljs-string">"Save Texture Array"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat array tekstur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita memiliki jalur yang benar, maka kita dapat melanjutkan dan membuat objek baru </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode konstruktornya memerlukan menentukan lebar dan tinggi tekstur, panjang array, format tekstur, dan kebutuhan untuk tekstur texting. </font><font style="vertical-align: inherit;">Parameter ini harus sama untuk semua tekstur dalam array. </font><font style="vertical-align: inherit;">Untuk mengkonfigurasi objek, kami menggunakan tekstur pertama. </font><font style="vertical-align: inherit;">Pengguna harus memverifikasi bahwa semua tekstur memiliki format yang sama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (path.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Texture2D t = textures[<span class="hljs-number"><span class="hljs-number">0</span></span>]; Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena array tekstur adalah sumber daya GPU tunggal, ia menggunakan mode penyaringan dan lipat yang sama untuk semua tekstur. </font><font style="vertical-align: inherit;">Di sini kita kembali menggunakan tekstur pertama untuk mengatur semuanya.</font></font><br><br><pre> <code class="cs hljs"> Texture2DArray textureArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Texture2DArray( t.width, t.height, textures.Length, t.format, t.mipmapCount &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ); textureArray.anisoLevel = t.anisoLevel; textureArray.filterMode = t.filterMode; textureArray.wrapMode = t.wrapMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita bisa menyalin tekstur ke dalam array menggunakan metode ini </font></font><code>Graphics.CopyTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode ini menyalin data tekstur mentah, satu tingkat mip pada satu waktu. </font><font style="vertical-align: inherit;">Karena itu, kita perlu memutar semua tekstur dan level mipnya. </font><font style="vertical-align: inherit;">Parameter metode adalah dua set yang terdiri dari sumber daya tekstur, indeks, dan tingkat mip. </font><font style="vertical-align: inherit;">Karena tekstur aslinya bukan array, indeksnya selalu nol.</font></font><br><br><pre> <code class="cs hljs"> textureArray.wrapMode = t.wrapMode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = <span class="hljs-number"><span class="hljs-number">0</span></span>; m &lt; t.mipmapCount; m++) { Graphics.CopyTexture(textures[i], <span class="hljs-number"><span class="hljs-number">0</span></span>, m, textureArray, i, m); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, kami memiliki memori dalam susunan tekstur yang benar, tetapi belum merupakan aset. </font><font style="vertical-align: inherit;">Langkah terakhir adalah memanggil </font></font><code>AssetDatabase.CreateAsset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan array dan path-nya. </font><font style="vertical-align: inherit;">Dalam hal ini, data akan ditulis ke file di proyek kami, dan itu akan muncul di jendela proyek.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.Length; i++) { … } AssetDatabase.CreateAsset(textureArray, path);</code> </pre> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tekstur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat array tekstur nyata, kita perlu tekstur asli. Berikut adalah lima tekstur yang cocok dengan warna yang kami gunakan sampai sekarang. Kuning menjadi pasir, hijau menjadi rumput, biru menjadi bumi, oranye menjadi batu, dan putih menjadi salju.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/195/104/a40/195104a4070bfa42e6c4e0eaff218d42.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d7/777/f86/0d7777f865b086c46a1c95a06380c66a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/30b/55f/0f830b55ffdbc729bc02d013805bb2c3.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/347/4eb/37b/3474eb37b3a5404866a6fd384e9c6352.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/0eb/fa3/6de0ebfa32b5b0b04c8c082e6cce0c01.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur pasir, rumput, tanah, batu, dan salju. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa tekstur ini bukan foto relief ini. </font><font style="vertical-align: inherit;">Ini adalah pola pseudo-acak mudah yang saya buat menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NumberFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya berusaha keras untuk membuat jenis dan detail bantuan yang dapat dikenali yang tidak bertentangan dengan bantuan abstrak poligonal. </font><font style="vertical-align: inherit;">Photorealism ternyata tidak cocok untuk ini. </font><font style="vertical-align: inherit;">Selain itu, meskipun pola menambah variabilitas, ada beberapa fitur berbeda di dalamnya yang akan membuat pengulangan segera terlihat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan tekstur ini ke array master, pastikan urutannya sesuai dengan warna. </font><font style="vertical-align: inherit;">Yaitu, pertama pasir, kemudian rumput, tanah, batu dan akhirnya salju.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ec/511/2a1/5ec5112a1bdaa4f170ec382b2549ad9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a54/4e8/1f0/a544e81f0c74fa36290553a6c6a328df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuat array tekstur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah membuat aset array tekstur, pilih dan memeriksanya di inspektur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e1/8f3/8d6/6e18f38d6682f71b3c8a999823642cd4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspektur array tekstur.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah tampilan paling sederhana dari sepotong data array tekstur. Perhatikan bahwa ada sakelar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is Readable</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang pada awalnya dihidupkan. Karena kita tidak perlu membaca data piksel dari array, matikan. Kami tidak dapat melakukan ini di wisaya karena tidak </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada metode atau properti untuk mengakses parameter ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Dalam Unity 5.6, ada bug yang merusak array tekstur dalam rakitan pada beberapa platform. Anda dapat mengatasinya tanpa menonaktifkan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapat Dibaca</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu juga dicatat bahwa ada bidang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruang Warna</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang diberi nilai 1. Ini berarti bahwa tekstur diasumsikan berada dalam ruang gamma, yang benar. </font><font style="vertical-align: inherit;">Jika mereka seharusnya berada dalam ruang linear, maka bidang tersebut harus diatur ke 0. Sebenarnya, perancang </font></font><code>Texture2DArray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki parameter tambahan untuk menentukan ruang warna, tetapi itu </font></font><code>Texture2D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak menunjukkan apakah itu dalam ruang linear atau tidak, oleh karena itu, dalam hal apa pun, Anda perlu mengatur nilai secara manual.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki serangkaian tekstur, kita perlu mengajari shader cara bekerja dengannya. </font><font style="vertical-align: inherit;">Untuk saat ini, kami menggunakan shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VertexColors</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk merender medan </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena sekarang kami akan menggunakan tekstur alih-alih warna, ubah nama menjadi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kemudian kita mengubah parameter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_MainTex</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menjadi array tekstur dan menetapkannya sebagai aset.</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Shader</span></span> <span class="hljs-string"><span class="hljs-string">"Custom/Terrain"</span></span> { <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/878/0b2/3de/8780b23ded3ced3ab980a039d0f5753d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan bantuan dengan berbagai tekstur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengaktifkan array tekstur pada semua platform yang mendukungnya, Anda perlu meningkatkan level target shader dari 3.0 menjadi 3.5.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.5</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena variabel </font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang merujuk ke array tekstur, kita perlu mengubah tipenya. </font><font style="vertical-align: inherit;">Jenisnya tergantung pada platform target dan makro akan membereskannya </font></font><code>UNITY_DECLARE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// sampler2D _MainTex; UNITY_DECLARE_TEX2DARRAY(_MainTex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti pada shader lainnya, untuk mencicipi tekstur relief, kita memerlukan koordinat dunia XZ. </font><font style="vertical-align: inherit;">Oleh karena itu, kami akan menambahkan posisi di dunia ke struktur input shader permukaan. </font><font style="vertical-align: inherit;">Kami juga menghapus koordinat UV default, karena kami tidak membutuhkannya.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// float2 uv_MainTex; float4 color : COLOR; float3 worldPos; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk sampel array tekstur, kita perlu menggunakan makro </font></font><code>UNITY_SAMPLE_TEX2DARRAY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk mengambil sampel array, dibutuhkan tiga koordinat. </font><font style="vertical-align: inherit;">Dua yang pertama adalah koordinat UV biasa. </font><font style="vertical-align: inherit;">Kami akan menggunakan koordinat dunia XZ yang diskalakan hingga 0,02. </font><font style="vertical-align: inherit;">Jadi kami mendapatkan resolusi tekstur yang baik pada pembesaran penuh. </font><font style="vertical-align: inherit;">Tekstur akan diulang kira-kira setiap empat sel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koordinat ketiga digunakan sebagai indeks array tekstur, seperti dalam array biasa. </font><font style="vertical-align: inherit;">Karena koordinatnya mengambang, sebelum pengindeksan array GPU mengitarinya. </font><font style="vertical-align: inherit;">Karena sampai kita tahu tekstur apa yang dibutuhkan, mari kita gunakan dulu. </font><font style="vertical-align: inherit;">Juga, warna titik tidak akan mempengaruhi hasil akhir, karena itu adalah peta percikan.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, float3(uv, <span class="hljs-number"><span class="hljs-number">0</span></span>)); Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/a19/df0/c08a19df0f6c0674406e4922b6595585.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semuanya menjadi pasir. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemilihan tekstur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membutuhkan peta percikan yang mencampur tiga jenis menjadi sebuah segitiga. </font><font style="vertical-align: inherit;">Kami memiliki serangkaian tekstur dengan tekstur untuk setiap jenis medan. </font><font style="vertical-align: inherit;">Kami memiliki shader yang sampel array tekstur. </font><font style="vertical-align: inherit;">Tetapi untuk saat ini, kami tidak memiliki cara untuk memberi tahu shader tekstur mana yang harus dipilih untuk setiap segitiga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena setiap segitiga bercampur hingga tiga jenis, kita perlu mengasosiasikan tiga indeks dengan masing-masing segitiga. </font><font style="vertical-align: inherit;">Kami tidak dapat menyimpan informasi untuk segitiga, jadi kami harus menyimpan indeks untuk simpul. </font><font style="vertical-align: inherit;">Ketiga simpul segitiga hanya akan menyimpan indeks yang sama dengan warna solid.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data Jerat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menggunakan salah satu set UV mesh untuk menyimpan indeks. </font><font style="vertical-align: inherit;">Karena tiga indeks disimpan pada setiap titik, set UV 2D yang ada tidak akan cukup. </font><font style="vertical-align: inherit;">Untungnya, set UV dapat berisi hingga empat koordinat. </font><font style="vertical-align: inherit;">Karena itu, kami menambah </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daftar kedua </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang akan kami sebut sebagai jenis bantuan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useTerrainTypes; [NonSerialized] List&lt;Vector3&gt; vertices, terrainTypes;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktifkan jenis medan untuk </font><font style="vertical-align: inherit;">anak </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pabrikan Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/728/0c5/4eb/7280c54ebcd1a6063fb3df9f0328cc5b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan jenis bantuan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika perlu, kami akan mengambil daftar lain </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk jenis bantuan selama pembersihan mesh.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { terrainTypes = ListPool&lt;Vector3&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam proses menerapkan data mesh, kami menyimpan jenis bantuan di set UV ketiga. </font><font style="vertical-align: inherit;">Karena itu, mereka tidak akan bertentangan dengan dua set lainnya, jika kita memutuskan untuk menggunakannya bersama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useTerrainTypes) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">2</span></span>, terrainTypes); ListPool&lt;Vector3&gt;.Add(terrainTypes); } hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatur jenis relief dari segitiga, kita akan gunakan </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena yang sama untuk seluruh segitiga, kami hanya menambahkan data yang sama tiga kali.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencampuran di quad berfungsi sama. </font><font style="vertical-align: inherit;">Keempat simpul adalah dari jenis yang sama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadTerrainTypes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 types</span></span></span><span class="hljs-function">)</span></span> { terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); terrainTypes.Add(types); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penggemar Segitiga Ribs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu menambahkan tipe ke data mesh di </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mari kita mulai </font></font><code>TriangulateEdgeFan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertama, demi keterbacaan yang lebih baik, kami akan memisahkan panggilan ke metode titik dan warna. </font><font style="vertical-align: inherit;">Ingatlah bahwa dengan setiap panggilan ke metode ini, kami meneruskannya kepadanya </font></font><code>color1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga kami dapat menggunakan warna ini secara langsung, dan tidak menerapkan parameter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { terrain.AddTriangle(center, edge.v1, edge.v2); <span class="hljs-comment"><span class="hljs-comment">// terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v2, edge.v3); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v3, edge.v4); // terrain.AddTriangleColor(color); terrain.AddTriangle(center, edge.v4, edge.v5); // terrain.AddTriangleColor(color); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); terrain.AddTriangleColor(color1); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah warna, kami menambahkan jenis bantuan. </font><font style="vertical-align: inherit;">Karena jenis dalam segitiga mungkin berbeda, ini harus menjadi parameter yang menggantikan warna. </font><font style="vertical-align: inherit;">Gunakan tipe sederhana ini untuk membuat </font></font><code>Vector3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Hanya empat saluran pertama yang penting bagi kami, karena dalam hal ini peta percikan selalu merah. </font><font style="vertical-align: inherit;">Karena ketiga komponen vektor perlu ditetapkan, mari tetapkan satu jenis.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type</span></span></span><span class="hljs-function">)</span></span> { … Vector3 types; types.x = types.y = types.z = type; terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu mengubah semua panggilan ke metode ini, mengganti argumen warna dengan indeks dari jenis medan sel. </font><font style="vertical-align: inherit;">Kami akan membuat perubahan ini di </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeFan(center, e, color1); TriangulateEdgeFan(center, e, cell.TerrainTypeIndex);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada titik ini, ketika Anda memulai mode Putar, kesalahan akan muncul memberi tahu Anda bahwa set ketiga jerat UV berada di luar batas. </font><font style="vertical-align: inherit;">Ini terjadi karena kami belum menambahkan tipe relief untuk setiap segitiga dan quad. </font><font style="vertical-align: inherit;">Jadi mari kita terus berubah </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rib stripes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang saat membuat strip tepi, kita perlu tahu jenis medan apa yang ada di kedua sisi. </font><font style="vertical-align: inherit;">Oleh karena itu, kami menambahkannya sebagai parameter, dan kemudian membuat vektor jenis yang dua salurannya ditugaskan untuk jenis ini. </font><font style="vertical-align: inherit;">Saluran ketiga tidak penting, jadi samakan saja dengan yang pertama. </font><font style="vertical-align: inherit;">Setelah menambahkan warna, tambahkan jenis ke quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); terrain.AddQuadColor(c1, c2); Vector3 types; types.x = types.z = type1; types.y = type2; terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita perlu mengubah tantangan </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertama </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menggunakan tipe sel untuk kedua sisi strip rib.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(m, color1, e, color1); TriangulateEdgeStrip( m, color1, cell.TerrainTypeIndex, e, color1, cell.TerrainTypeIndex );</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, case paling sederhana dari edge </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus menggunakan tipe sel untuk edge terdekat dan tipe tetangga untuk edge jauh. </font><font style="vertical-align: inherit;">Mereka bisa sama atau berbeda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// TriangulateEdgeStrip(e1, color1, e2, color2, hasRoad); TriangulateEdgeStrip( e1, color1, cell.TerrainTypeIndex, e2, color2, neighbor.TerrainTypeIndex, hasRoad ); } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal yang sama berlaku untuk </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa yang memicu tiga kali </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jenis untuk tepiannya sama.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = beginCell.TerrainTypeIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = endCell.TerrainTypeIndex; TriangulateEdgeStrip(begin, color1, t1, e2, c2, t2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(color1, color2, i); TriangulateEdgeStrip(e1, c1, t1, e2, c2, t2, hasRoad); } TriangulateEdgeStrip(e2, c2, t1, end, color2, t2, hasRoad); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sudut </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasus sudut yang paling sederhana adalah segitiga sederhana. </font><font style="vertical-align: inherit;">Sel bawah mentransfer tipe pertama, yang kiri yang kedua, dan yang kanan yang ketiga. </font><font style="vertical-align: inherit;">Dengan menggunakannya, buat vektor jenis dan tambahkan ke segitiga.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangle(bottom, left, right); terrain.AddTriangleColor(color1, color2, color3); Vector3 types; types.x = bottomCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); } features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menggunakan pendekatan yang sama </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, hanya di sini kami membuat grup quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(color1, color2, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(color1, color3, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; terrain.AddTriangle(begin, v3, v4); terrain.AddTriangleColor(color1, c3, c4); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(color1, color2, i); c4 = HexMetrics.TerraceLerp(color1, color3, i); terrain.AddQuad(v1, v2, v3, v4); terrain.AddQuadColor(c1, c2, c3, c4); terrain.AddQuadTerrainTypes(types); } terrain.AddQuad(v3, v4, left, right); terrain.AddQuadColor(c3, c4, color2, color3); terrain.AddQuadTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat mencampur tepian dan tebing, kita perlu menggunakannya </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Berikan saja parameter tipe vektor dan tambahkan ke semua segitiga.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, Color beginColor, Vector3 left, Color leftColor, Vector3 boundary, Color boundaryColor, Vector3 types </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginColor, leftColor, <span class="hljs-number"><span class="hljs-number">1</span></span>); terrain.AddTriangleUnperturbed(HexMetrics.Perturb(begin), v2, boundary); terrain.AddTriangleColor(beginColor, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginColor, leftColor, i); terrain.AddTriangleUnperturbed(v1, v2, boundary); terrain.AddTriangleColor(c1, c2, boundaryColor); terrain.AddTriangleTerrainTypes(types); } terrain.AddTriangleUnperturbed(v2, HexMetrics.Perturb(left), boundary); terrain.AddTriangleColor(c2, leftColor, boundaryColor); terrain.AddTriangleTerrainTypes(types); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat vektor jenis berdasarkan sel yang ditransfer. </font><font style="vertical-align: inherit;">Kemudian tambahkan ke satu segitiga dan lewati </font></font><code>TriangulateBoundaryTriangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(right), b ); Color boundaryColor = Color.Lerp(color1, color3, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( begin, color1, left, color2, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal yang sama berlaku untuk </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } Vector3 boundary = Vector3.Lerp( HexMetrics.Perturb(begin), HexMetrics.Perturb(left), b ); Color boundaryColor = Color.Lerp(color1, color2, b); Vector3 types; types.x = beginCell.TerrainTypeIndex; types.y = leftCell.TerrainTypeIndex; types.z = rightCell.TerrainTypeIndex; TriangulateBoundaryTriangle( right, color3, begin, color1, boundary, boundaryColor, types ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, color2, right, color3, boundary, boundaryColor, types ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrain.AddTriangleUnperturbed( HexMetrics.Perturb(left), HexMetrics.Perturb(right), boundary ); terrain.AddTriangleColor(color2, color3, boundaryColor); terrain.AddTriangleTerrainTypes(types); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sungai </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode terakhir yang diubah adalah ini </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena di sini kita berada di tengah sel, kita hanya berurusan dengan jenis sel saat ini. </font><font style="vertical-align: inherit;">Oleh karena itu, buat vektor untuk itu dan tambahkan ke segitiga dan quad-s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … terrain.AddTriangleColor(color1); terrain.AddQuadColor(color1); terrain.AddQuadColor(color1); terrain.AddTriangleColor(color1); Vector3 types; types.x = types.y = types.z = cell.TerrainTypeIndex; terrain.AddTriangleTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddQuadTerrainTypes(types); terrain.AddTriangleTerrainTypes(types); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jenis campuran </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap ini, jerat berisi indeks elevasi yang diperlukan. </font><font style="vertical-align: inherit;">Yang tersisa bagi kita adalah memaksa shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk </font><font style="vertical-align: inherit;">menggunakannya. </font><font style="vertical-align: inherit;">Agar indeks jatuh ke shader fragmen, pertama-tama kita harus melewati mereka melalui vertex shader. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini dalam fungsi vertex kita sendiri, seperti yang kita lakukan pada shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muara</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam hal ini, kami menambahkan bidang ke struktur input </font></font><code>float3 terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menyalinnya ke dalamnya </font></font><code>v.texcoord2.xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard fullforwardshadows vertex:vert #pragma target <span class="hljs-number"><span class="hljs-number">3.5</span></span> … struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; float3 worldPos; float3 terrain; }; <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> data) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, data); data.terrain = v.texcoord2.xyz; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita perlu sampel array tekstur tiga kali per fragmen. </font><font style="vertical-align: inherit;">Oleh karena itu, mari kita membuat fungsi yang nyaman untuk membuat koordinat tekstur, mengambil sampel array dan memodulasi sampel dengan peta percikan untuk satu indeks.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> GetTerrainColor (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { float3 uvw = float3(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.terrain[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]); <span class="hljs-type"><span class="hljs-type">float4</span></span> c = UNITY_SAMPLE_TEX2DARRAY(_MainTex, uvw); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>]; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisakah kita bekerja dengan vektor sebagai array?</font></font></b> <div class="spoiler_text">  Ya   - <code>color[0]</code>  <code>color.r</code> .  <code>color[1]</code>  <code>color.g</code> ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan menggunakan fungsi ini, kita cukup sampel array tekstur tiga kali dan menggabungkan hasilnya. </font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { // float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.02</span></span>; fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); o.Albedo = c.rgb * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da9/2fa/577/da92fa577510b38d4d0cdb99db83aea0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relief bertekstur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita bisa melukis relief dengan tekstur. </font><font style="vertical-align: inherit;">Mereka mencampur seperti warna solid. </font><font style="vertical-align: inherit;">Karena kita menggunakan koordinat dunia sebagai koordinat UV, mereka tidak berubah dengan ketinggian. </font><font style="vertical-align: inherit;">Akibatnya, di sepanjang tebing yang tajam, teksturnya membentang. </font><font style="vertical-align: inherit;">Jika teksturnya cukup netral dan sangat bervariasi, maka hasilnya akan dapat diterima. </font><font style="vertical-align: inherit;">Kalau tidak, kita mendapatkan stretch mark jelek besar. </font><font style="vertical-align: inherit;">Anda dapat mencoba menyembunyikannya dengan geometri tambahan atau tekstur tebing, tetapi dalam tutorial kami tidak akan melakukan ini.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sapu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, ketika kita menggunakan tekstur alih-alih warna, masuk akal untuk mengubah panel editor. </font><font style="vertical-align: inherit;">Kita dapat membuat antarmuka yang indah yang bahkan dapat menampilkan tekstur relief, tetapi saya akan fokus pada singkatan yang sesuai dengan gaya skema yang ada.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/c52/c81/263c52c812c97de2b8095b6ca80a8f5d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opsi bantuan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">properti warna tidak lagi diperlukan, jadi hapus saja.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color Color { // get { // return HexMetrics.colors[terrainTypeIndex]; // } // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga dapat menghapus serangkaian warna dan kode terkait dari dalamnya.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Color[] colors; … void Awake () { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; CreateMap(cellCountX, cellCountZ); } … … void OnEnable () { if (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); // HexMetrics.colors = colors; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, serangkaian warna juga tidak diperlukan di </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public static Color[] colors;</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bagian 15: jarak </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilkan garis kisi. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beralih antara mode pengeditan dan navigasi. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hitung jarak antar sel. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menemukan cara mengatasi kendala. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami memperhitungkan variabel biaya pemindahan. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah membuat peta berkualitas tinggi, kami akan memulai navigasi. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15b/b5d/65d/15bb5d65de19358da88e581cedad71cb.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalur terpendek tidak selalu lurus.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilan kotak </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigasi pada peta dilakukan dengan berpindah dari sel ke sel. </font><font style="vertical-align: inherit;">Untuk sampai ke suatu tempat, Anda harus melalui serangkaian sel. </font><font style="vertical-align: inherit;">Untuk mempermudah memperkirakan jarak, mari tambahkan opsi untuk menampilkan kisi segi enam yang menjadi dasar peta kita.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tekstur jala </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun penyimpangan dari map mesh, mesh di bawahnya benar-benar rata. </font><font style="vertical-align: inherit;">Kami dapat menunjukkan ini dengan memproyeksikan pola kisi ke peta. </font><font style="vertical-align: inherit;">Ini dapat dicapai dengan menggunakan tekstur jala berulang.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a7/74c/76e/3a774c76e29b57018450a8e21f5bf1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengulangi tekstur jala. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur yang ditunjukkan di atas berisi sebagian kecil dari kisi segi enam yang meliputi 2 sel 2 sel. </font><font style="vertical-align: inherit;">Area ini berbentuk persegi, bukan persegi. </font><font style="vertical-align: inherit;">Karena teksturnya sendiri berbentuk bujur sangkar, polanya terlihat melar. </font><font style="vertical-align: inherit;">Saat pengambilan sampel, kita perlu mengimbanginya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Proyeksi kisi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memproyeksikan pola mesh, kita perlu menambahkan </font><font style="vertical-align: inherit;">properti tekstur ke </font><font style="vertical-align: inherit;">shader </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs nginx"> <span class="hljs-section"><span class="hljs-section">Properties</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">_Color</span></span> (<span class="hljs-string"><span class="hljs-string">"Color"</span></span>, Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex (<span class="hljs-string"><span class="hljs-string">"Terrain Texture Array"</span></span>, 2DArray) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_GridTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Grid Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-attribute"><span class="hljs-attribute">_Glossiness</span></span> (<span class="hljs-string"><span class="hljs-string">"Smoothness"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> _Metallic (<span class="hljs-string"><span class="hljs-string">"Metallic"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/708/6de/2837086dedff939d3380396c9146ddfc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahan bantuan dengan tekstur jala. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cicipi tekstur menggunakan koordinat XZ dunia, lalu kalikan dengan albedo. </font><font style="vertical-align: inherit;">Karena garis grid pada tekstur berwarna abu-abu, ini akan menjalin pola ke dalam relief.</font></font><br><br><pre> <code class="hljs pgsql"> sampler2D _GridTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + GetTerrainColor(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); fixed4 grid = tex2D(_GridTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz); o.Albedo = c.rgb * grid * _Color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/a3e/432/972a3e4323541d1195904c9777a29e07.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Albedo dikalikan dengan jaring halus. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita perlu skala pola sehingga cocok dengan sel-sel di peta. </font><font style="vertical-align: inherit;">Jarak antara pusat sel tetangga adalah 15, perlu digandakan untuk naik dua sel. </font><font style="vertical-align: inherit;">Yaitu, kita perlu membagi koordinat grid V dengan 30. Radius internal sel adalah 5√3, dan untuk memindahkan dua sel ke kanan, kita perlu empat kali lipat. </font><font style="vertical-align: inherit;">Oleh karena itu, perlu untuk membagi koordinat grid U dengan 20√3.</font></font><br><br><pre> <code class="hljs markdown"> float2 gridUV = IN.worldPos.xz; gridUV.x <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (4 *</span></span> 8.66025404); gridUV.y <span class="hljs-emphasis"><span class="hljs-emphasis">*= 1 / (2 *</span></span> 15.0); fixed4 grid = tex2D(_GridTex, gridUV);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/1ba/191/4541ba19123145c27422e2b90b52aa6f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran jala yang benar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang garis kisi berhubungan dengan sel-sel peta. </font><font style="vertical-align: inherit;">Seperti tekstur relief, mereka mengabaikan ketinggian, sehingga garis akan direntangkan di sepanjang tebing.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98a/708/906/98a7089069b6d04bc708851045c9fe7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyeksi pada sel dengan tinggi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deformasi mesh biasanya tidak terlalu buruk, terutama ketika melihat peta dari jarak jauh.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/287/5ac/690/2875ac690eb796bf00a86b48d193aec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jaring di kejauhan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inklusi Kisi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun menampilkan kisi itu mudah, itu tidak selalu diperlukan. </font><font style="vertical-align: inherit;">Misalnya, Anda harus mematikannya saat mengambil tangkapan layar. </font><font style="vertical-align: inherit;">Selain itu, tidak semua orang lebih suka melihat grid secara konstan. </font><font style="vertical-align: inherit;">Jadi mari kita membuatnya opsional. </font><font style="vertical-align: inherit;">Kami akan menambahkan arahan multi_compile ke shader untuk membuat opsi dengan dan tanpa kisi. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kami akan menggunakan kata kunci </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kompilasi shader bersyarat dijelaskan dalam tutorial </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering 5, Multiple Lights</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs css"> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">surf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Standard</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fullforwardshadows</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vertex</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:vert</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">target</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#pragma</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">multi_compile</span></span> _ <span class="hljs-selector-tag"><span class="hljs-selector-tag">GRID_ON</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat mendeklarasikan variabel, </font></font><code>grid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pertama-tama </font><font style="vertical-align: inherit;">kita </font><font style="vertical-align: inherit;">menetapkan nilai 1. Sebagai hasilnya, kisi akan dinonaktifkan. </font><font style="vertical-align: inherit;">Kemudian kami akan mencicipi tekstur grid hanya untuk varian dengan kata kunci tertentu </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs mel"> fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(GRID_ON) float2 gridUV = IN.worldPos.xz; gridUV.x *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">8.66025404</span></span>); gridUV.y *= <span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">15.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> = tex2D(_GridTex, gridUV); #endif o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">grid</span></span> * _Color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kata kunci </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak termasuk dalam shader medan, kisi akan hilang. </font><font style="vertical-align: inherit;">Untuk mengaktifkannya lagi, kami akan menambahkan sakelar ke UI editor peta. </font><font style="vertical-align: inherit;">Untuk memungkinkan ini, saya </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus mendapatkan tautan ke materi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan metode untuk mengaktifkan atau menonaktifkan kata kunci </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material terrainMaterial; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (visible) { terrainMaterial.EnableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d0/d53/873/7d0d53873a0aace69be804dcbf22d7ce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor March segi enam dengan mengacu pada materi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan sakelar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotak</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke UI </font><font style="vertical-align: inherit;">dan sambungkan ke metode </font></font><code>ShowGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56b/38a/6b6/56b38a6b6792eb8b89fb3936a55e9194.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Switch jaringan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simpan status </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang dalam mode Play, kita dapat mengganti tampilan grid. </font><font style="vertical-align: inherit;">Pada pengujian pertama, kisi pada awalnya dimatikan dan menjadi terlihat ketika kita menghidupkan sakelar. </font><font style="vertical-align: inherit;">Saat Anda mematikannya, kisi akan hilang lagi. </font><font style="vertical-align: inherit;">Namun, jika kita keluar dari mode Putar ketika kisi terlihat, maka saat berikutnya Anda memulai mode Putar, itu akan dihidupkan lagi, meskipun sakelar dimatikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini karena kami mengubah kata kunci untuk materi </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> umum </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami mengedit aset material, sehingga perubahan disimpan di editor Unity. </font><font style="vertical-align: inherit;">Itu tidak akan disimpan di majelis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk selalu memulai permainan tanpa kotak, kami akan menonaktifkan kata kunci </font></font><code>GRID_ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di Sedarlah </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrainMaterial.DisableKeyword(<span class="hljs-string"><span class="hljs-string">"GRID_ON"</span></span>); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mode edit </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita ingin mengontrol pergerakan di peta, maka kita perlu berinteraksi dengannya. </font><font style="vertical-align: inherit;">Paling tidak, kita perlu memilih sel sebagai titik awal jalan. </font><font style="vertical-align: inherit;">Tetapi ketika Anda mengklik sel, itu akan diedit. </font><font style="vertical-align: inherit;">Kami dapat menonaktifkan semua opsi pengeditan secara manual, tetapi ini tidak nyaman. </font><font style="vertical-align: inherit;">Selain itu, kami tidak ingin perhitungan perpindahan dilakukan selama pengeditan peta. </font><font style="vertical-align: inherit;">Jadi mari kita tambahkan sakelar yang menentukan apakah kita dalam mode edit.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edit sakelar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang Boolean </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, serta metode yang mendefinisikannya. </font><font style="vertical-align: inherit;">Kemudian tambahkan sakelar lain ke UI untuk mengontrolnya. </font><font style="vertical-align: inherit;">Mari kita mulai dengan mode navigasi, yaitu mode pengeditan akan dinonaktifkan secara default.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> editMode; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bf/19b/ace/1bf19baceed0ecfa766dbe0386ed38d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sakelar mode pengeditan. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk benar-benar menonaktifkan pengeditan, buat panggilan </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bergantung </font></font><code>editMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Label Debugging </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini kami tidak memiliki unit untuk bergerak di sekitar peta. </font><font style="vertical-align: inherit;">Sebaliknya, kami memvisualisasikan jarak pergerakan. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda dapat menggunakan label sel yang ada. </font><font style="vertical-align: inherit;">Karenanya, kami akan membuatnya terlihat saat mode pengeditan dinonaktifkan.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { editMode = toggle; hexGrid.ShowUI(!toggle); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejak kita mulai dengan mode navigasi, label default harus diaktifkan. </font><font style="vertical-align: inherit;">Saat ini </font></font><code>HexGridChunk.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menonaktifkannya, tetapi ia tidak lagi harus melakukan ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; <span class="hljs-comment"><span class="hljs-comment">// ShowUI(false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/730/666/90c/73066690c998f0715fb22356a0374fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Label yang terkoordinasi. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koordinat sel sekarang menjadi terlihat segera setelah meluncurkan mode Putar. </font><font style="vertical-align: inherit;">Tapi kami tidak perlu koordinat, kami menggunakan label untuk menampilkan jarak. </font><font style="vertical-align: inherit;">Karena ini hanya membutuhkan satu nomor per sel, Anda dapat menambah ukuran font sehingga dapat dibaca lebih baik. </font><font style="vertical-align: inherit;">Ubah cetakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Label Hex Cell</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga menggunakan huruf tebal dengan ukuran 8.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/008/aa0/8ea008aa075686891f8815148c70ba06.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag dengan ukuran font tebal 8.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang setelah meluncurkan mode Play, kita akan melihat tag besar. </font><font style="vertical-align: inherit;">Hanya koordinat pertama sel yang terlihat, sisanya tidak ditempatkan pada label.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/baf/016/745baf0160c2f9cf8aaae974ff285d16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tag besar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kami tidak lagi membutuhkan koordinat, kami akan menghapus </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai </font><font style="vertical-align: inherit;">dalam </font><font style="vertical-align: inherit;">penugasan </font></font><code>label.text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); <span class="hljs-comment"><span class="hljs-comment">// label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga dapat menghapus sakelar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Label</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan metode yang terkait </font><font style="vertical-align: inherit;">dari UI </font></font><code>HexMapEditor.ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public void ShowUI (bool visible) { // hexGrid.ShowUI(visible); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e0/4d4/652/6e04d46522e65937a9324e0f3498d480.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peralihan metode tidak lebih. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menemukan jarak </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki mode navigasi yang ditandai, kita dapat mulai menampilkan jarak. </font><font style="vertical-align: inherit;">Kami akan memilih sel dan kemudian menampilkan jarak dari sel ini ke semua sel di peta.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tampilan jarak </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melacak jarak ke sel, tambahkan ke </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bidang bilangan bulat </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini akan menunjukkan jarak antara sel ini dan yang dipilih. </font><font style="vertical-align: inherit;">Oleh karena itu, untuk sel yang dipilih itu sendiri, itu akan menjadi nol, untuk tetangga terdekatnya adalah 1, dan seterusnya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika jarak diatur, kita harus memperbarui label sel untuk menampilkan nilainya. </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki referensi ke </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek UI. </font><font style="vertical-align: inherit;">Kita harus memanggilnya </font></font><code>GetComponent&lt;Text&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk sampai ke sel. </font><font style="vertical-align: inherit;">Pertimbangkan apa yang </font></font><code>Text</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada di namespace </font></font><code>UnityEngine.UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jadi gunakan di awal skrip.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance.ToString(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukankah kita seharusnya menyimpan tautan langsung ke komponen Teks?</font></font></b> <div class="spoiler_text"> ,   .     ,       ,  ,    .   ,      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mari atur properti umum untuk menerima dan mengatur jarak ke sel, serta memperbarui labelnya. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Distance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { distance = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; UpdateDistanceLabel(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan ke </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode umum </font></font><code>FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan parameter sel. </font><font style="vertical-align: inherit;">Untuk saat ini, kami hanya akan mengatur jarak nol ke setiap sel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika mode pengeditan tidak diaktifkan, maka kami </font></font><code>HexMapEditor.HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memanggil metode baru dengan sel saat ini.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (editMode) { EditCells(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hexGrid.FindDistancesTo(currentCell); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jarak antar koordinat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang dalam mode navigasi, setelah menyentuh salah satunya, semua sel menampilkan nol. </font><font style="vertical-align: inherit;">Tetapi, tentu saja, mereka harus menampilkan jarak sebenarnya ke sel. </font><font style="vertical-align: inherit;">Untuk menghitung jarak ke mereka, kita bisa menggunakan koordinat sel. </font><font style="vertical-align: inherit;">Oleh karena itu, anggaplah ia </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki metode </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan gunakan dalam </font></font><code>HexGrid.FindDistancesTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tambahkan ke </font></font><code>HexCoordinates</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">metode </font></font><code>DistanceTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dia harus membandingkan koordinatnya sendiri dengan koordinat set lainnya. </font><font style="vertical-align: inherit;">Mari kita mulai hanya dengan mengukur X, dan kita akan mengurangi koordinat X dari satu sama lain.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - other.x; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akibatnya, kami mendapatkan offset sepanjang X relatif terhadap sel yang dipilih. </font><font style="vertical-align: inherit;">Tetapi jarak tidak boleh negatif, jadi Anda harus mengembalikan modulo perbedaan X.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; other.x ? other.x - x : x - other.x;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fdb/c62/16c/fdbc6216c12ae4a38ff7edaba203116e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak sepanjang X.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jadi kita mendapatkan jarak yang benar hanya jika kita memperhitungkan hanya satu dimensi. </font><font style="vertical-align: inherit;">Tetapi ada tiga dimensi dalam kisi segi enam. </font><font style="vertical-align: inherit;">Jadi mari kita tambahkan jarak untuk ketiga dimensi dan lihat apa yang memberi kita.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/170/ac0/ffd170ac0b133a9b589e3dea9d6fd2b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah jarak XYZ. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata jaraknya dua kali lipat. </font><font style="vertical-align: inherit;">Artinya, untuk mendapatkan jarak yang benar, jumlah ini harus dibagi dua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x &lt; other.x ? other.x - x : x - other.x) + (Y &lt; other.Y ? other.Y - Y : Y - other.Y) + (z &lt; other.z ? other.z - z : z - other.z)) / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bd/37d/353/9bd37d3535471f748d31be64ce897c17.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak nyata.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa jumlah sama dengan dua kali jarak?</font></font></b> <div class="spoiler_text">  ,       .      ,  (1, −3, 2).       .      ,       .      .   ,            .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/533/197/09e533197dfc487db1c5b91f92fd6ba8.png"></div><br> <i> .</i> </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bekerja dengan rintangan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak yang kami hitung sesuai dengan jalur terpendek dari sel yang dipilih ke setiap sel lainnya. </font><font style="vertical-align: inherit;">Kami tidak dapat menemukan cara yang lebih pendek. </font><font style="vertical-align: inherit;">Tetapi jalur ini dijamin benar jika rute tidak memblokir apa pun. </font><font style="vertical-align: inherit;">Tebing, air, dan rintangan lain bisa membuat kita berkeliling. </font><font style="vertical-align: inherit;">Mungkin beberapa sel tidak bisa dijangkau sama sekali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menemukan cara mengatasi rintangan, kita perlu menggunakan pendekatan yang berbeda daripada hanya menghitung jarak antara koordinat. </font><font style="vertical-align: inherit;">Kami tidak lagi dapat memeriksa setiap sel secara individual. </font><font style="vertical-align: inherit;">Kami harus mencari peta sampai kami menemukan setiap sel yang bisa dijangkau.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisasi pencarian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian peta adalah proses berulang. </font><font style="vertical-align: inherit;">Untuk memahami apa yang kami lakukan, akan sangat membantu untuk melihat setiap tahap pencarian. </font><font style="vertical-align: inherit;">Kita dapat melakukan ini dengan mengubah algoritma pencarian menjadi coroutine, yang membutuhkan ruang pencarian </font></font><code>System.Collections</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kecepatan refresh 60 iterasi per detik cukup kecil bagi kita untuk melihat apa yang terjadi, dan mencari di peta kecil tidak memakan terlalu banyak waktu.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StartCoroutine(Search(cell)); } <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; cells[i].Distance = cell.coordinates.DistanceTo(cells[i].coordinates); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami perlu memastikan bahwa hanya satu pencarian yang aktif pada waktu tertentu. </font><font style="vertical-align: inherit;">Karena itu, sebelum memulai pencarian baru, kami menghentikan semua coroutine.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindDistancesTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); StartCoroutine(Search(cell)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain itu, kami harus menyelesaikan pencarian saat memuat peta baru. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Load</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BinaryReader reader, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> header</span></span></span><span class="hljs-function">)</span></span> { StopAllCoroutines(); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pencarian Luas Pertama </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan sebelum kita memulai pencarian, kita tahu bahwa jarak ke sel yang dipilih adalah nol. Dan, tentu saja, jarak ke semua tetangganya adalah 1, jika mereka dapat dijangkau. Lalu kita bisa melihat salah satu tetangga ini. Sel ini kemungkinan besar memiliki tetangganya sendiri yang dapat dijangkau, dan yang jaraknya belum dihitung. Jika demikian, maka jarak ke tetangga ini harus 2. Kita bisa mengulangi proses ini untuk semua tetangga pada jarak 1. Setelah itu, kita ulangi untuk semua tetangga pada jarak 2. Dan seterusnya, sampai kita mencapai semua sel.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artinya, pertama-tama kita menemukan semua sel pada jarak 1, lalu kita menemukan semuanya pada jarak 2, lalu pada jarak 3, dan seterusnya, sampai kita selesai. </font><font style="vertical-align: inherit;">Ini memastikan bahwa kami menemukan jarak terkecil ke setiap sel yang dapat dijangkau. </font><font style="vertical-align: inherit;">Algoritma ini disebut pencarian luas pertama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar bisa bekerja, kita perlu tahu apakah kita sudah menentukan jarak ke sel. </font><font style="vertical-align: inherit;">Seringkali untuk ini, sel ditempatkan dalam koleksi yang disebut set siap pakai atau tertutup. </font><font style="vertical-align: inherit;">Tetapi kita dapat mengatur jarak ke sel </font></font><code>int.MaxValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menunjukkan bahwa kita belum mengunjunginya. </font><font style="vertical-align: inherit;">Kita perlu melakukan ini untuk semua sel sebelum melakukan pencarian.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga dapat menggunakan ini untuk menyembunyikan semua sel yang belum dikunjungi dengan mengubah </font></font><code>HexCell.UpdateDistanceLabel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setelah itu, kami akan memulai setiap pencarian di peta kosong.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateDistanceLabel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Text label = uiRect.GetComponent&lt;Text&gt;(); label.text = distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue ? <span class="hljs-string"><span class="hljs-string">""</span></span> : distance.ToString(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, kita perlu melacak sel yang perlu dikunjungi, dan urutan kunjungannya. </font><font style="vertical-align: inherit;">Koleksi seperti itu sering disebut perbatasan atau set terbuka. </font><font style="vertical-align: inherit;">Kita hanya perlu memproses sel-sel dalam urutan yang sama di mana kita bertemu mereka. </font><font style="vertical-align: inherit;">Untuk melakukan ini, Anda dapat menggunakan antrian </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang merupakan bagian dari namespace </font></font><code>System.Collections.Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sel yang dipilih akan menjadi yang pertama ditempatkan dalam antrian ini dan akan memiliki jarak 0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Search</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { cells[i].Distance = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } WaitForSeconds delay = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">60f</span></span>); Queue&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Enqueue(cell); <span class="hljs-comment"><span class="hljs-comment">// for (int i = 0; i &lt; cells.Length; i++) { // yield return delay; // cells[i].Distance = // cell.coordinates.DistanceTo(cells[i].coordinates); // } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai saat ini, algoritma mengeksekusi loop sementara ada sesuatu dalam antrian. </font><font style="vertical-align: inherit;">Pada setiap iterasi, sel paling depan diambil dari antrian.</font></font><br><br><pre> <code class="cs hljs"> frontier.Enqueue(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita memiliki sel saat ini, yang bisa berada pada jarak berapa pun. </font><font style="vertical-align: inherit;">Selanjutnya, kita perlu menambahkan semua tetangganya ke antrian satu langkah lebih jauh dari sel yang dipilih.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier.Dequeue(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetapi kita harus menambahkan hanya sel-sel yang belum diberi jarak. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian luas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari air </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah memastikan bahwa pencarian pertama kali menemukan jarak yang benar pada peta monoton, kita dapat mulai menambahkan rintangan. </font><font style="vertical-align: inherit;">Ini dapat dilakukan dengan menolak menambahkan sel ke antrian jika kondisi tertentu terpenuhi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya, kami telah melewati beberapa sel: sel yang tidak ada, dan sel yang telah kami tandai jaraknya. </font><font style="vertical-align: inherit;">Mari kita menulis ulang kode sehingga dalam hal ini kita melewatkan tetangga secara eksplisit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } neighbor.Distance = current.Distance + <span class="hljs-number"><span class="hljs-number">1</span></span>; frontier.Enqueue(neighbor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lewati semua sel yang ada di bawah air. </font><font style="vertical-align: inherit;">Ini berarti bahwa ketika mencari jarak terdekat, kami hanya mempertimbangkan pergerakan di darat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || neighbor.Distance != <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak tanpa bergerak melalui air. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma masih menemukan jarak terpendek, tetapi sekarang menghindari semua air. </font><font style="vertical-align: inherit;">Oleh karena itu, sel-sel bawah laut tidak pernah mendapatkan jarak, seperti area tanah yang terisolasi. </font><font style="vertical-align: inherit;">Sel bawah air hanya menerima jarak jika dipilih.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hindari tebing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, untuk menentukan kemungkinan mengunjungi tetangga, kita bisa menggunakan jenis iga. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat membuat tebing menghalangi jalan. </font><font style="vertical-align: inherit;">Jika Anda membiarkan gerakan di lereng, maka sel-sel di sisi lain tebing masih dapat dicapai, hanya di jalur lain. </font><font style="vertical-align: inherit;">Oleh karena itu, mereka dapat berada pada jarak yang sangat berbeda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak tanpa melintasi tebing. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Biaya perjalanan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat menghindari sel dan ujung, tetapi opsi ini adalah biner. </font><font style="vertical-align: inherit;">Orang dapat membayangkan bahwa lebih mudah untuk menavigasi ke beberapa arah daripada di tempat lain. </font><font style="vertical-align: inherit;">Dalam hal ini, jarak diukur dalam persalinan atau waktu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jalan cepat </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akan logis bahwa lebih mudah dan lebih cepat untuk bepergian di jalan, jadi mari kita membuat persimpangan tepi dengan jalan lebih murah. </font><font style="vertical-align: inherit;">Karena kita menggunakan nilai integer untuk mengatur jarak, kita akan meninggalkan biaya bergerak di sepanjang jalan sama dengan 1, dan biaya melintasi tepi lain kita akan meningkat menjadi 10. Ini adalah perbedaan besar yang memungkinkan kita untuk segera melihat apakah kita mendapatkan hasil yang tepat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } neighbor.Distance = distance;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/225/6e3/8992256e34fef206c7282bc31a72a573.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan dengan jarak yang salah.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sortir Perbatasan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, ternyata pencarian pertama kali tidak dapat bekerja dengan biaya pemindahan variabel. </font><font style="vertical-align: inherit;">Dia mengasumsikan bahwa sel ditambahkan ke perbatasan dalam urutan peningkatan jarak, dan bagi kita ini tidak lagi relevan. </font><font style="vertical-align: inherit;">Kita perlu antrian prioritas, yaitu antrian yang menyortir dirinya sendiri. </font><font style="vertical-align: inherit;">Tidak ada antrian prioritas standar, karena Anda tidak dapat memprogramnya sedemikian rupa sehingga sesuai dengan semua situasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat membuat antrian prioritas kita sendiri, tetapi mari kita optimalkan untuk tutorial selanjutnya. </font><font style="vertical-align: inherit;">Untuk saat ini, kami cukup mengganti antrian dengan daftar yang akan memiliki metode </font></font><code>Sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> List&lt;HexCell&gt; frontier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;HexCell&gt;(); cell.Distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; frontier.Add(cell); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (frontier.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay; HexCell current = frontier[<span class="hljs-number"><span class="hljs-number">0</span></span>]; frontier.RemoveAt(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { … neighbor.Distance = distance; frontier.Add(neighbor); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak bisakah saya menggunakan ListPool &lt;HexCell&gt;?</font></font></b> <div class="spoiler_text"> , ,  .       ,  ,        . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar perbatasan benar, kita perlu mengurutkannya setelah menambahkan sel ke dalamnya. </font><font style="vertical-align: inherit;">Bahkan, kami dapat menunda penyortiran sampai semua tetangga sel ditambahkan, tetapi, saya ulangi, sampai optimasi tidak menarik bagi kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami ingin menyortir sel berdasarkan jarak. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu memanggil metode pengurutan daftar dengan tautan ke metode yang melakukan perbandingan ini.</font></font><br><br><pre> <code class="cs hljs"> frontier.Add(neighbor); frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara kerja metode Sortir ini?</font></font></b> <div class="spoiler_text">     .     ,       .        . <br><br><pre> <code class="cs hljs"> frontier.Sort(CompareDistances); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareDistances</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell x, HexCell y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x.Distance.CompareTo(y.Distance); }</code> </pre> </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ca/f5d/f85/2caf5df85335f7997694522b7885d882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batas yang diurutkan masih salah.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pembaruan perbatasan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah kami mulai menyortir perbatasan, kami mulai mendapatkan hasil yang lebih baik, tetapi masih ada kesalahan. Ini karena ketika sel ditambahkan ke perbatasan, kita tidak perlu menemukan jarak terpendek ke sel ini. Ini berarti bahwa sekarang kita tidak bisa lagi melewati tetangga yang telah diberi jarak. Sebaliknya, kita perlu memeriksa apakah kita telah menemukan jalan yang lebih pendek. Jika demikian, maka kita perlu mengubah jarak ke tetangga, alih-alih menambahkannya ke perbatasan.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = current.GetNeighbor(d); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.GetEdgeType(neighbor) == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Distance == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { neighbor.Distance = distance; frontier.Add(neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; neighbor.Distance) { neighbor.Distance = distance; } frontier.Sort((x, y) =&gt; x.Distance.CompareTo(y.Distance));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jarak yang benar. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang setelah kami memiliki jarak yang benar, kami akan mulai mempertimbangkan biaya pemindahan. </font><font style="vertical-align: inherit;">Anda mungkin memperhatikan bahwa jarak ke beberapa sel pada awalnya terlalu besar, tetapi dikoreksi ketika mereka dihapus dari perbatasan. </font><font style="vertical-align: inherit;">Pendekatan ini disebut algoritma Dijkstra, dinamai setelah yang pertama kali ditemukan oleh Edsger Dijkstra.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lereng </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak ingin terbatas pada perbedaan biaya hanya untuk jalan. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat mengurangi biaya melintasi tepi rata tanpa jalan ke 5, meninggalkan lereng tanpa jalan bernilai 10.</font></font><br><br><pre> <code class="cs hljs"> HexEdgeType edgeType = current.GetEdgeType(neighbor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (edgeType == HexEdgeType.Cliff) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> distance = current.Distance; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fd/8e1/1b5/8fd8e11b5a95d0e35ce03d1eb8bc32a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatasi lereng Anda perlu membuat lebih banyak pekerjaan, dan jalan selalu cepat.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Benda bantuan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami dapat menambah biaya dengan adanya benda bantuan. </font><font style="vertical-align: inherit;">Misalnya, dalam banyak permainan lebih sulit untuk menavigasi hutan. </font><font style="vertical-align: inherit;">Dalam hal ini, kita cukup menambahkan semua level objek ke jarak. </font><font style="vertical-align: inherit;">Dan di sini lagi jalan mempercepat segalanya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6e/ef4/b2b/f6eef4b2bba378bd83daf9377f9a1603.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objek melambat jika tidak ada jalan.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dindingnya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, mari kita perhatikan temboknya. </font><font style="vertical-align: inherit;">Dinding harus menghalangi gerakan jika jalan tidak melewatinya.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.HasRoadThroughEdge(d)) { distance += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.Walled != neighbor.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { distance += edgeType == HexEdgeType.Flat ? <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-number"><span class="hljs-number">10</span></span>; distance += neighbor.UrbanLevel + neighbor.FarmLevel + neighbor.PlantLevel; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b3/9cd/7a9/1b39cd7a97483749c25474622ed8326b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dinding tidak membiarkan kami lewat, Anda perlu mencari gerbang. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paket unity</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425919/">https://habr.com/ru/post/id425919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425905/index.html">Cara menulis kode assembler dengan instruksi yang tumpang tindih (teknik lain untuk mengaburkan bytecode)</a></li>
<li><a href="../id425907/index.html">Kami sedang melakukan proyek pembelajaran mesin dengan Python. Bagian 2</a></li>
<li><a href="../id425911/index.html">Transfer cloud CRM ke versi kotak</a></li>
<li><a href="../id425915/index.html">Bagaimana komunikasi lintas batas dapat menggantikan lampu lalu lintas dan mempersingkat cara bekerja</a></li>
<li><a href="../id425917/index.html">Justice fighter mencegah Waymo mematenkan teknologi kunci Lidar</a></li>
<li><a href="../id425921/index.html">Pertemuan komunitas .NET di CLRium # 4 + online</a></li>
<li><a href="../id425923/index.html">Malapetaka 25 tahun</a></li>
<li><a href="../id425925/index.html">Pencetakan 3D dalam penciptaan tata letak pada contoh STUDIO 911</a></li>
<li><a href="../id425927/index.html">Stasiun cuaca di Arduino dari A hingga Z. Bagian 2</a></li>
<li><a href="../id425929/index.html">Google telah meninggalkan pertarungan untuk kontrak Pentagon yang ke-miliar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>