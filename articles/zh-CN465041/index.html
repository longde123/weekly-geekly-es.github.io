<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏻 🤷🏼 👂🏻 如何在不存入小额硬币的情况下进行BTC交易 🌭 🏯 🔫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="许多比特币钱包在选择要发送的硬币时更喜欢使用较大的硬币，其余额大于所发送的金额。 在每次这样的交易之后，形成找零硬币。 一段时间后，整个钱包里满是0.001（约合10美元）的硬币，现在已经没有钱可花了。 当我再次需要进行交易时，我想到是否有可能组装交易，以便不进行任何更改。 钱包顽固地提议“削减”另...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在不存入小额硬币的情况下进行BTC交易</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465041/"><p><img src="https://habrastorage.org/webt/fn/ez/kn/fnezknn373mov5izqcr1u0nppfk.png" alt="目标：在背包容量有限的情况下，将尽可能多的贵重物品装在背包中"></p><br><p>许多比特币钱包在选择要发送的硬币时更喜欢使用较大的硬币，其余额大于所发送的金额。 在每次这样的交易之后，形成找零硬币。 一段时间后，整个钱包里满是0.001（约合10美元）的硬币，现在已经没有钱可花了。 当我再次需要进行交易时，我想到是否有可能组装交易，以便不进行任何更改。 钱包顽固地提议“削减”另一枚较大的硬币，因此我决定用手摘硬币以收集必要的金额。 但是，事实并非如此简单：总和要么小于期望值，要么超过期望值。 结果，我决定应该有一种算法，您可以用该算法从硬币中收集所需的数量或更多。 事实证明，这不仅可行，而且效果很好，使我撰写了这篇文章。 但是首先是第一件事。 </p><a name="habracut"></a><br><h2 id="zadacha-o-ryukzake"> 背包问题 </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">背包问题是</a>众所周知的：在背包的容量有限的情况下，将尽可能多的贵重物品装进背包。 在这种情况下，我们遇到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了0-1背包问题</a> ，因为每个物品（硬币）只能在背包中包装一次。 另外，每个“项目”的权重与其值一致，因此我们正在处理一个更特殊的情况， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">即子集总和</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">问题</a> 。 维基百科建议使用遗传算法，但我决定使用动态编程来寻找精确的解决方案，因为这在资源方面是可以实现的，而且看起来很简单。 </p><br><p> 为了减少为背包任务选择硬币的问题，您需要对输入数据进行少量转换。 事实是，解决背包问题（更确切地说是子集的总和）将为我们提供原始集合的一个子集，其最大数量不超过参数（背包携带能力）。 但是我们对硬币的组合不满意，因为硬币的数量少于我们要发送的数量。 但是，我们对稍微优越的组合感到满意。 例如，如果我们需要发送0.005比特币，并且发现一个组合可以提供0.00499，那么这对我们来说是无用的，因为它小于卖方想要的数量。 但是，如果我们找到0.005001，那是对的。 额外的satoshiki可以用作佣金（我们将在下面详细讨论），或者如果卖方允许发送更大的金额，则可以将其交给卖方。 因此，借助背包问题，我们不需要选择需要<strong>发送</strong>的硬币，而是选择需要<strong>留下</strong>的硬币。 那么就原始问题而言，最大程度的“短缺”将变成“破产”。 </p><br><p><img src="https://habrastorage.org/webt/ew/3q/su/ew3qsuzkpbzdy68chuyleel8vrm.png" alt="自动和手动选择要发送的硬币"></p><br><p> 一个例子。 假设我们有这样的硬币：0.1 BTC，0.002 BTC，0.00832423 BTC。 我们需要发送0.01 BTC。 我们将找到这样的硬币，其总和将是最大的，但小于或等于我们的硬币的总数量减去发送的数量，即该数字：0.1 + 0.002 + 0.00832423-0.01 = 0.10032423。 在这种情况下，简单的搜索就会发现它是0.1个硬币。 我们将其保留，这意味着我们将发送其余的：0.002 BTC和0.00832423 BTC，它们总共给出0.01032423 BTC，这大于0.01 BTC并且适合我们。  （的确，佣金约为3美元，但我们说网络很忙，我们希望尽快进行发送。） </p><br><h2 id="komissii"> 佣金 </h2><br><p> 为了考虑交易费用，我修改了每个输入硬币，将其余额减少为将其包含在交易中作为输入必须支付的金额。 这可以通过知道输入的大小和佣金（例如，每个字节2个聪）来完成。 此外，我修改了要发送的金额，并在其中增加了不依赖于所选代币的交易部分的价格：标题和退出。 用户可以使用标志指定所有这些参数。 通常，您还可以通过指定每个字节0个Satoshi的佣金来禁用佣金的调整。 </p><br><p> 我从以下地址获取了有关不同版本地址（经典，包装的隔离见证和本机隔离见证）中输入和输出大小的信息： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ://bitcoin.stackexchange.com/a/84006 </p><br><h2 id="algoritmy-i-realizaciya"> 算法与实现 </h2><br><p> 我立即放弃了遗传算法，也许是徒劳的。 专注于准确的算法。 我的第一个尝试是通过详尽搜索所有组合来实现，但即使使用40个硬币，它也要工作数小时，并且不得不放弃。 然后，我尝试了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Wikipedia上建议</a>的动态编程。 在其中，您不能将整个矩阵保留在内存中，而只能保留当前和前一行。 另外，我们不需要存储该值，因为它与权重一致并且是列号。 但是我们需要记住这种组合-我决定以位集的形式存储它。 此外，您只能存储一行，并从该行开始构建下一行。 每个非零行记录都保留在其位置，并被复制（加上相应的位）到另一个单元格中，该单元格位于右侧一定数量的单元格中（如果该位置之前为空）。 如果以相反的顺序进行排序，则对“跳转”所在的单元格进行排序，则可以正确填写所有内容： </p><br><p><img src="https://habrastorage.org/webt/fa/qb/ts/faqbtspntkfkjgzwy6koiubabvi.png" alt="过渡到下一行的说明，即在动态编程中添加另一枚硬币"><br>  <em>当前行中的每个非零单元格本身都会在下一行中生成，并在右侧为特定数量的单元格（等于所添加硬币的值）生成另一个单元格。</em>  <em>如果该单元格中已经有一个值，那么在其他条件相同的情况下，由于我们希望发送尽可能少的硬币，因此选择（即不包括在交易中）硬币数量最多的选项“获胜”。</em> </p><br><p> 在一个单元格上，我花了8个字节用于位集，单元格的数量等于从0到硬币数量减去发送数量的可能余额数。 例如，如果钱包中只有1个比特币，并且发送了0.1个比特币，那么将有100'000'000-10'000'000 = 90'000'000个单元，每个单元为8个字节，即720兆字节-对于现代计算机来说是很少的。 如果硬币的数量少于32个，则每个硬币可以使用4个字节，但是我没有对其进行优化。 另外，如果有64个以上的硬币，则该程序将不起作用-这也必须通过制作任意长度的位集来解决。 最后，您可以舍弃天平中的最后一个符号，从而失去一些准确性，但可以赢得10次内存。 但是到目前为止，它会做到的。 </p><br><p>我将<strong>程序不变地</strong>调用，并将其放在gitlab上： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gitlab.com/starius/changeless</a> 。 它是用Go编写的，照常使用<code>go get</code>组装。  CI中提供了适用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">于Linux，Windows，Mac的二​​进制文件</a> 。 </p><br><p> 当我用真实的硬币启动该程序时，我为她选择所需组合的准确性感到惊讶。 当硬币数量很大时，几乎可以选择与硬币余额相称的任何数量，精确度可低至satoshi！ 您更改了1个satoshi的所需金额，程序就为该金额提供了完全不同的硬币组合。 以下是使用50个随机硬币（余额为0到1个比特币）的示例。 </p><br><pre> <code class="plaintext hljs">$ cat coins50.txt 0.01331611 0.03906237 0.04847086 0.08453118 0.09748168 0.10395389 0.10619825 0.12156721 0.12923149 0.13587973 0.14798976 0.16053788 0.19011834 0.21570038 0.21946913 0.31861430 0.33435508 0.33718842 0.33789473 0.35976748 0.37360122 0.44944553 0.47572926 0.49927495 0.50992142 0.53062326 0.53079433 0.53542072 0.54715225 0.55019714 0.55313907 0.56656642 0.56673333 0.65879650 0.66228482 0.68424322 0.70436496 0.75638055 0.79095597 0.82438005 0.83684407 0.85151564 0.86862948 0.90054250 0.90239402 0.91636213 0.93087757 0.93579251 0.97207439 0.98248384 $ changeless -amount 10.00000000 -coins coins50.txt Processing item 50/50. 0.09748168 + 0.33435508 + 0.47572926 + 0.53542072 + 0.66228482 + 0.70436496 + 0.75638055 + 0.82438005 + 0.9005425 + 0.90239402 + 0.91636213 + 0.93579251 + 0.97207439 + 0.98248384 = 10.00004651 Tx size: 2118 vBytes. Total fees: 0.00004651 BTC (2.2 sats/vByte). $ changeless -amount 10.00000001 -coins coins50.txt Processing item 50/50. 0.01331611 + 0.09748168 + 0.53079433 + 0.56656642 + 0.70436496 + 0.75638055 + 0.82438005 + 0.86862948 + 0.9005425 + 0.91636213 + 0.93087757 + 0.93579251 + 0.97207439 + 0.98248384 = 10.00004652 Tx size: 2118 vBytes. Total fees: 0.00004651 BTC (2.2 sats/vByte).</code> </pre> <br><p> 该程序设法提取硬币组合，以发送正好10个比特币和正好10.00000001个比特币（10个比特币和1个satoshi）。 要看到这一点，您必须从硬币金额中减去佣金：10.00004651-0.00004651 = 10，10.00004652-0.00004651 = 10.00000001。 </p><br><h2 id="kak-poluchit-spisok-balansov-monet"> 如何获得硬币余额清单 </h2><br><p> 对于Electrum程序，我发现是这样的（控制台命令）： </p><br><pre> <code class="plaintext hljs">' '.join((x["value"]) for x in listunspent())</code> </pre> <br><p> 如果您想排除某些硬币，例如在某个地址，则可以这样进行： </p><br><pre> <code class="plaintext hljs">' '.join((x["value"]) for x in listunspent() if x["address"] != "bad address")</code> </pre> <br><p> 对于其他钱包，我没有找到这么简单的方法，只能用手重新输入。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465041/">https://habr.com/ru/post/zh-CN465041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465027/index.html">关于CRM的10个幼稚但重要的问题</a></li>
<li><a href="../zh-CN465029/index.html">[可能] SORM解密到Mail.ru和ICQ的HTTPS通信</a></li>
<li><a href="../zh-CN465031/index.html">内部视图：现代世界中的RFID。 第2部分：中文RFID</a></li>
<li><a href="../zh-CN465033/index.html">提出Powercheck技术</a></li>
<li><a href="../zh-CN465039/index.html">安全周35：有关通过Google云端硬盘泄露的密码和攻击的统计信息</a></li>
<li><a href="../zh-CN465045/index.html">Android上的Kali Linux NetHunter：为什么以及如何安装</a></li>
<li><a href="../zh-CN465047/index.html">DBMS中的单元测试-我们如何在Sportmaster中进行测试，第二部分</a></li>
<li><a href="../zh-CN465049/index.html">2020年值得与您一同学习的10本关于敏捷项目管理的书</a></li>
<li><a href="../zh-CN465055/index.html">使您的数据科学事业更上一层楼的六种技能。</a></li>
<li><a href="../zh-CN465057/index.html">容器和Windows。 从Hello World到Kubernetes。 第一部分，简介</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>