<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò≥ üçµ üë©üèª Programaci√≥n Orientada a Protocolo, Parte 3 üö∞ üë©üèæ‚Äçüé§ üö¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Art√≠culo final sobre programaci√≥n orientada al protocolo. 


 En esta parte, veremos c√≥mo se almacenan y copian las variables de tipo gen√©rico y c√≥mo ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n Orientada a Protocolo, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474830/"><p>  Art√≠culo final sobre programaci√≥n orientada al protocolo. </p><br><p>  En esta parte, veremos c√≥mo se almacenan y copian las variables de tipo gen√©rico y c√≥mo funciona el m√©todo de env√≠o con ellas. </p><a name="habracut"></a><br><h2 id="neobobschennaya-versiya">  Versi√≥n no compartida </h2><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line = <span class="hljs-type"><span class="hljs-type">Line</span></span>() drawACopy(line) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>() drawACopy(point)</code> </pre> <br><p>  C√≥digo muy simple  <code>drawACopy</code> toma un par√°metro de tipo Drawable y llama a su m√©todo de dibujo, eso es todo. </p><br><h2 id="obobschennaya-versiya">  Versi√≥n generalizada </h2><br><p>  Veamos la versi√≥n generalizada del c√≥digo anterior: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } ...</code> </pre> <br><p>  Nada parece haber cambiado.  Todav√≠a podemos llamar a la funci√≥n <code>drawACopy</code> , como su versi√≥n <code>drawACopy</code> , y nada m√°s, pero la m√°s interesante como de costumbre. <br>  El c√≥digo generalizado tiene dos caracter√≠sticas importantes: </p><br><ol><li>  polimorfismo est√°tico (tambi√©n conocido como param√©trico) </li><li>  un tipo espec√≠fico y √∫nico en el contexto de la llamada (un tipo gen√©rico T se define en tiempo de compilaci√≥n) </li></ol><br><p>  Considere esto con un ejemplo: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { bar(local) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo(point)</code> </pre> <br><p>  La parte m√°s interesante comienza cuando llamamos a la funci√≥n <code>foo</code> .  El compilador conoce exactamente el tipo de <code>point</code> variable, es solo Point.  Adem√°s, el compilador puede inferir libremente el tipo T: Drawable en la funci√≥n <code>foo</code> desde el momento en que pasamos una variable del tipo Point conocido a esta funci√≥n: T = Point.  Todos los tipos son conocidos en el momento de la compilaci√≥n y el compilador puede realizar todas sus maravillosas optimizaciones; lo m√°s importante es alinear la llamada <code>foo</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">This</span></span>: ```swift <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point) <span class="hljs-type"><span class="hljs-type">Becomes</span></span> this: ```swift bar&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point)</code> </pre> <br><p>  El compilador simplemente incorpora la llamada <code>foo</code> con su implementaci√≥n y tambi√©n muestra el tipo gen√©rico de T: barra dibujable.  En otras palabras, el compilador primero incrusta una llamada al m√©todo foo con tipo T = Point, luego incrusta el resultado de la incrustaci√≥n anterior: el m√©todo de barra con tipo T = Point. </p><br><h2 id="realizaciya-obobschennyh-metodov">  Implementaci√≥n de m√©todos gen√©ricos. </h2><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  Internamente, <code>drawACopy</code> Swift utiliza una tabla de m√©todo de protocolo (que contiene todas las implementaciones del m√©todo T) y una tabla de ciclo de vida (que contiene todos los m√©todos de ciclo de vida para la instancia T).  En pseudoc√≥digo, se ve as√≠: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T, pwt: T.PWT, vwt: T.VWT)</span></span></span></span> {...} drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>.pwt, <span class="hljs-type"><span class="hljs-type">Point</span></span>.vwt)</code> </pre> <br><p>  VWT y PWT son tipos asociados (tipo asociado) en T - como alias de tipo (typealias), solo que mejor.  Point.pwt y Point.vwt son propiedades est√°ticas. </p><br><p>  Como en nuestro ejemplo T es Punto, T est√° bien definido, por lo tanto, no se requiere la creaci√≥n de un contenedor.  En la versi√≥n anterior <code>drawACopy</code> de <code>drawACopy</code> (local: Drawable), la creaci√≥n de un contenedor existencial se llev√≥ a cabo seg√∫n fue necesario; lo examinamos en la segunda parte del art√≠culo. </p><br><p>  Se requiere una tabla de ciclo de vida en las funciones debido a la creaci√≥n de un argumento.  Como sabemos, los argumentos en Swift se pasan a trav√©s de valores, no a trav√©s de enlaces, por lo tanto, deben copiarse, y el m√©todo de copia para este argumento pertenece a la tabla del ciclo de vida como este argumento.  Tambi√©n hay otros m√©todos de ciclo de vida all√≠: asignar, destruir y desasignar. </p><br><p>  Se requiere una tabla de ciclo de vida en funciones gen√©ricas debido al uso de m√©todos para par√°metros de c√≥digo gen√©rico. </p><br><h2 id="obobschennyy-ili-neobobschennyy">  ¬øGeneralizado o no generalizado? </h2><br><p>  ¬øEs cierto que el uso de tipos gen√©ricos hace que la ejecuci√≥n del c√≥digo sea m√°s r√°pida que el uso de tipos de protocolo solamente?  ¬øLa funci√≥n generalizada <code>func foo&lt;T: Drawable&gt;(arg: T)</code> m√°s r√°pida que su hom√≥logo <code>fun foo(arg: Drawable)</code> ? </p><br><p>  Notamos que el c√≥digo gen√©rico da una forma m√°s est√°tica de polimorfismo.  Tambi√©n incluye optimizaciones del compilador llamadas "Especializaci√≥n en c√≥digo gen√©rico".  A ver: </p><br><p>  Nuevamente tenemos el mismo c√≥digo: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  La especializaci√≥n de una funci√≥n gen√©rica crea una copia con tipos gen√©ricos especializados de esta funci√≥n.  Por ejemplo, si llamamos a <code>drawACopy</code> con una variable de tipo Point, el compilador crear√° una versi√≥n especializada de esta funci√≥n: <code>drawACopyOfPoint</code> (local: Point), y obtenemos: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Point)</span></span></span></span> { local.draw() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Line)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Lo que se puede reducir mediante la optimizaci√≥n del compilador crudo antes de esto: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Point</span></span>(...).draw() <span class="hljs-type"><span class="hljs-type">Line</span></span>(...).draw()</code> </pre> <br><p>  Todos estos trucos est√°n disponibles porque las funciones gen√©ricas solo se pueden <code>drawACopy</code> si todos los tipos gen√©ricos est√°n definidos: en el m√©todo <code>drawACopy</code> tipo gen√©rico (T) est√° bien definido. </p><br><h2 id="obobschennye-hranimye-svoystva">  Propiedades almacenadas gen√©ricas </h2><br><p>  Considere un par de estructura simple: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(fst: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...), snd: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Cuando usamos esto de esta manera, obtenemos 2 asignaciones en el mont√≥n (las condiciones de memoria exactas en este escenario se describieron en la segunda parte), pero podemos evitar esto con la ayuda de un c√≥digo generalizado. </p><br><p>  La versi√≥n gen√©rica de Pair se ve as√≠: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre> <br><p>  Desde el momento en que el tipo T se define en la versi√≥n generalizada, los tipos de propiedad <code>fst</code> y <code>snd</code> mismos y tambi√©n se definen.  Como el tipo est√° definido, el compilador puede asignar una cantidad especializada de memoria para estas dos propiedades: <code>fst</code> y <code>snd</code> . </p><br><p>  En m√°s detalle sobre la cantidad especializada de memoria: </p><br><p>  Cuando trabajamos con una versi√≥n <code>fst</code> de <code>Pair</code> , los tipos de propiedad <code>fst</code> y <code>snd</code> son Drawable.  Cualquier tipo puede corresponder a Drawable, incluso si se necesitan 10 KB de memoria.  Es decir, Swift no podr√° sacar una conclusi√≥n sobre el tama√±o de este tipo y utilizar√° una ubicaci√≥n de memoria universal, por ejemplo, un contenedor existencial.  Cualquier tipo se puede almacenar en este contenedor.  En el caso del c√≥digo gen√©rico, el tipo es bien reconocido, el tama√±o real de las propiedades tambi√©n es reconocible y Swift puede crear una ubicaci√≥n de memoria especializada.  Por ejemplo (versi√≥n generalizada): </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  El tipo T ahora es punto.  Point toma N bytes de memoria y en Pair obtenemos dos de ellos.  Swift asignar√° 2 * N cantidad de memoria y pondr√° <code>pair</code> all√≠. </p><br><p>  Entonces, con la versi√≥n gen√©rica de Pair, eliminamos las asignaciones innecesarias en el mont√≥n, porque los tipos son f√°cilmente reconocibles y pueden ubicarse espec√≠ficamente, sin la necesidad de crear plantillas de memoria universal, ya que todo es conocido. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><h3 id="1-specializirovannyy-obobschennyy-kod---tipy-znacheniy">  1. C√≥digo gen√©rico especializado - Tipos de valor </h3><br><p>  tiene la mejor velocidad de ejecuci√≥n, ya que: </p><br><ul><li>  sin asignaci√≥n de mont√≥n al copiar </li><li>  c√≥digo gen√©rico: escribe una funci√≥n para un tipo especializado </li><li>  sin recuento de referencias </li><li>  env√≠o de m√©todo est√°tico </li></ul><br><h3 id="2-specializirovannyy-obobschennyy-kod---ssylochnye-tipy">  2. C√≥digo generalizado especializado - tipos de referencia </h3><br><p>  Tiene una velocidad de ejecuci√≥n promedio, ya que: </p><br><ul><li>  asignaciones por mont√≥n al crear instancias </li><li>  hay un recuento de referencia </li><li>  env√≠o de m√©todos din√°micos a trav√©s de una tabla virtual </li></ul><br><h3 id="3-nespecializirovannyy-obobschennyy-kod---malenkie-znacheniya">  3. C√≥digo generalizado no especializado - valores peque√±os </h3><br><ul><li>  sin asignaci√≥n de mont√≥n: el valor se coloca en el b√∫fer de valor del contenedor existencial </li><li>  sin recuento de referencias (ya que no se coloca nada en el mont√≥n) </li><li>  env√≠o de m√©todo din√°mico a trav√©s de la tabla de m√©todo de protocolo </li></ul><br><h3 id="4-nespecializirovannyy-obobschennyy-kod---bolshie-znacheniya">  4. C√≥digo generalizado no especializado - valores grandes </h3><br><ul><li>  colocaci√≥n en el mont√≥n: el valor se coloca en el b√∫fer de valores </li><li>  hay un recuento de referencia </li><li>  despacho din√°mico a trav√©s de la tabla de protocolo-m√©todo </li></ul><br><p>  Este material no significa que las clases sean malas, que las estructuras sean buenas y que las estructuras en combinaci√≥n con el c√≥digo generalizado sean las mejores.  Queremos decir que como programador, usted tiene la responsabilidad de elegir una herramienta para sus tareas.  Las clases son realmente buenas cuando necesitas mantener valores grandes y hay una sem√°ntica de enlaces.  Las estructuras son mejores para valores peque√±os y cuando necesita su sem√°ntica.  Los protocolos se adaptan mejor a estructuras y c√≥digos gen√©ricos, etc.  Todas las herramientas son espec√≠ficas de la tarea que est√° resolviendo y tienen lados positivos y negativos. </p><br><p>  Y <strong>tampoco pague el dinamismo cuando no lo necesite</strong> .  Encuentre la abstracci√≥n correcta con los requisitos m√≠nimos de tiempo de ejecuci√≥n. </p><br><ul><li>  tipos estructurales - sem√°ntica de significados </li><li>  tipos de clase - identidad </li><li>  c√≥digo generalizado - polimorfismo est√°tico </li><li>  tipos de protocolo - polimorfismo din√°mico </li></ul><br><p>  Utilice el almacenamiento indirecto para trabajar con valores grandes. </p><br><p>  Y no lo olvide, es su responsabilidad elegir la herramienta adecuada. <br>  Gracias por su atenci√≥n a este tema.  Esperamos que estos art√≠culos te hayan ayudado y hayan sido interesantes. </p><br><p>  <strong>Buena suerte</strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474830/">https://habr.com/ru/post/474830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474814/index.html">Antig√ºedades: el mensajero de la decadencia o la obsolescencia no planificada</a></li>
<li><a href="../474816/index.html">Proyectos de mascotas - vida peque√±a</a></li>
<li><a href="../474818/index.html">¬øHay n√∫meros aleatorios en CSS?</a></li>
<li><a href="../474822/index.html">WISE-PaaS: una plataforma en la nube para la Internet industrial de las cosas</a></li>
<li><a href="../474826/index.html">Tablas normales en Markdown</a></li>
<li><a href="../474832/index.html">C√≥mo funciona la criptograf√≠a de curva el√≠ptica en TLS 1.3</a></li>
<li><a href="../474838/index.html">SIBUR Challenge 2019 - Competencia de an√°lisis de datos industriales</a></li>
<li><a href="../474840/index.html">¬øQu√© estudian en la especialidad de Data Science en universidades extranjeras?</a></li>
<li><a href="../474842/index.html">Caso: servicio de coche. Desarrollo de campa√±as publicitarias e implementaci√≥n de Bitrix24</a></li>
<li><a href="../474844/index.html">Dell XPS 13 7390: una computadora port√°til muy compacta para quienes a menudo trabajan fuera de la oficina</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>