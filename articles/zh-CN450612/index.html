<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔈 💪🏾 ⛸️ 牛顿入门协议：可以容纳4 KB 📴 🤸🏽 😶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我最近在PC 4k简介类别中参加了Revision 2019演示场景，我的简介赢得了第一名。 我进行编码和图形处理，然后由狄克森作曲。 竞赛的基本规则是创建一个大小仅为4096字节的可执行文件或网站。 这意味着必须使用数学和算法来生成所有内容。 我无法将图像，视频和音频压缩到如此少量的内存中。 在本...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>牛顿入门协议：可以容纳4 KB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450612/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png" alt="图片"></div><br> 我最近在PC 4k简介类别中参加了Revision 2019演示场景，我的简介赢得了第一名。 我进行编码和图形处理，然后由狄克森作曲。 竞赛的基本规则是创建一个大小仅为4096字节的可执行文件或网站。 这意味着必须使用数学和算法来生成所有内容。 我无法将图像，视频和音频压缩到如此少量的内存中。 在本文中，我将讨论Newton简介影片的渲染流程。 在下面，您可以查看完成的结果，或<a href="">单击此处</a>查看在Revision上的实时效果，或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转到pouet</a>进行评论并下载参加比赛的简介。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处阅读</a>有关竞争对手的工作和更正的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> 。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iIIu7kPCN-8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br> 光线行进距离场技术在4k入门学科中非常流行，因为它允许您仅用几行代码指定复杂的形式。 但是，这种方法的缺点是执行速度快。 要渲染场景，您需要找到光线与场景的交点，首先确定所看到的东西，例如，来自相机的光线，然后确定从对象到光源的后续光线，以计算照明。 使用光线行进时，无法一步找到这些交点，您需要沿着光束采取许多小步骤，并评估每个点上的所有对象。 另一方面，使用射线追踪时，可以通过仅检查每个对象一次来找到确切的相交，但是可以使用的形状集非常有限：每种类型都需要有一个公式才能计算与射线的相交。 <br><br> 在本简介中，我想模拟非常精确的照明。 由于必须反射场景中的数百万条光线，因此光线追踪似乎是实现此效果的合理选择。 我将自己限制在一个单一的图形-球体上，因为光线和球体的交点非常简单。 甚至介绍中的墙实际上都是很大的球体。 此外，它简化了物理模拟。 仅考虑领域之间的冲突就足够了。 <br><br> 为了说明适合4096字节的代码量，下面提供了完整的介绍的完整源代码。 除HTML末尾以外的所有部分均编码为PNG图像，以将其压缩为较小的尺寸。 如果不进行这种压缩，则该代码将占用几乎8900个字节。 名为Synth的部分是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SoundBox</a>的精简版本。 为了以这种最小化格式打包代码，我使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google Closure Compiler</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Shader Minifier</a> 。 最后，几乎所有内容都使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JsExe</a>压缩为PNG。 在我之前的4k简介<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Core Critical</a>的源代码中可以看到完整的编译管道，因为它完全与此处介绍的匹配。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/274/690/e5b27469046c9c34bfb14fc2fbe33fa5.png"></div><br>  <i>音乐和合成器完全用Javascript实现。</i>  <i>WebGL上的这一部分分为两部分（代码中以绿色突出显示）；另一部分则为WebGL。</i>  <i>她设置了渲染管道。</i>  <i>物理和光线跟踪器元素是GLSL着色器。</i>  <i>其余代码被编码为PNG图像，HTML不变地添加到结果图像的末尾。</i>  <i>浏览器将忽略图像数据，仅执行HTML代码，然后将PNG解码回javascript并执行。</i> <br><br><h3> 渲染管线 </h3><br> 下图显示了渲染管道。 它由两部分组成。 管道的第一部分是物理模拟器。 简介场景包含50个球体，它们在房间内相互碰撞。 房间本身由六个球体组成，其中一些比其他球体小一些，以创建更多弯曲的墙。 拐角处的两个垂直照明光源也是球体，即场景中共有58个球体。 流水线的第二部分是光线跟踪器，用于渲染场景。 下图显示了在时间t处一帧的渲染。 物理模拟采用前一帧（t-1）并模拟当前状态。 光线跟踪器获取当前位置和前一帧的位置（对于速度通道），并渲染场景。 然后，后处理将先前的5帧和当前的帧进行组合以减少失真和噪点，然后创建最终结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6a/848/ac0/f6a848ac09343ca15abfd03393a7ceeb.png"></div><br>  <i>在时间t渲染一帧。</i> <br><br> 物理部分非常简单，在Internet上可以找到许多有关创建球体原始模拟的教程。 位置，半径，速度和质量存储在分辨率为1 x 58的两个纹理中。我使用了Webgl 2功能，该功能允许渲染到多个渲染目标，因此可以同时记录两个纹理的数据。 光线跟踪器使用相同的功能来创建三个纹理。  Webgl不提供对NVidia RTX或DirectX光线跟踪（DXR）光线跟踪API的任何访问权限，因此一切都从头开始。 <br><br><h3> 光线追踪器 </h3><br> 光线跟踪本身是一种相当原始的技术。 我们将光线释放到场景中，被反射4次，如果光线进入光源，则反射的颜色会累积。 否则，我们会变黑。 在4096字节（包括音乐，合成器，物理和渲染）中，没有空间创建复杂的加速射线跟踪结构。 因此，我们使用粗略搜索方法，即，针对每条射线检查所有57个球体（不包括前壁），而没有进行任何优化以排除部分球体。 这意味着要以每秒1080p的分辨率提供60帧，您只能发射2-6射线或每个像素样本。 这足够接近以创建平滑的照明。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/2ce/72d/b232ce72d49f57a69b96d402ec0bb148.png"></div><br>  <i>每个像素1个样本。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e52/77d/19e/e5277d19e5a7b897b8dd9046eaae6f26.png"></div><br>  <i>每个像素6个样本。</i> <br><br> 如何应对呢？ 最初，我研究了光线跟踪算法，但是已经简化到了这一点。 通过消除射线在球体内部开始的情况，我设法稍微提高了性能，因为这种情况仅在存在透明效果的情况下适用，并且场景中仅存在不透明的对象。 之后，我将每个if条件组合到一个单独的语句中，以避免不必要的分支：尽管进行了“冗余”计算，但这种方法仍然比一堆条件语句要快。 您还可以改善采样模式：我们可以随机地将光线分布在整个场景中，而不是随机发出光线。 不幸的是，这无济于事，并且在我尝试的每种算法中都产生了波浪状的假象。 但是，这种方法为静止图像创造了良好的效果。 结果，我返回使用完全随机分布。 <br><br> 相邻像素应该具有非常相似的照明，那么为什么在计算单个像素的照明时不使用它们呢？ 我们不想仅使照明模糊，而是需要在单独的通道中渲染它们。 我们也不想模糊对象，因此我们需要考虑对象的标识符，以便知道哪些像素可以轻松地模糊。 因为我们有反光物体，并且需要清晰的反射，所以仅找出光束与之碰撞的第一个物体的ID是不够的。 对于纯反射材料，我使用了一种特殊情况，即在对象标识符通道的反射中也包含第一和第二个对象的ID。 在这种情况下，模糊可以使反射中物体的照明变得平滑，同时保持物体的边界。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f69/a24/a6b/f69a24a6b9094903309af27b5606e923.png"></div><br>  <i>纹理通道，我们不需要对其进行模糊处理。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/c4a/7f6/a4fc4a7f6ec4fa0552542edf7204cb58.png"></div><br>  <i>红色通道中包含第一个对象的ID，绿色（第二个）和蓝色（第三个）。</i>  <i>实际上，它们全部被编码为浮点格式的单个值，其中整数部分存储对象的标识符，而小数部分表示粗糙度：332211.RR。</i> <br><br> 由于场景中的物体具有不同的粗糙度（某些区域是粗糙的，光线会散射在其他区域，在第三区域中会产生镜面反射），因此我存储该粗糙度以控制模糊半径。 场景中没有很小的细节，因此我使用了一个较大的50 x 50核心，其权重采用反平方的形式来模糊。 它没有考虑世界空间（可以实现以获得更精确的结果），因为在某些方向上以一定角度倾斜的表面会侵蚀较大的区域。 这种模糊会产生相当平滑的图像，但是伪影清晰可见，尤其是在运动中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/553/f9d/ca6553f9d61bc8f7dda51ba41c2cbf28.png"></div><br>  <i>照明通道具有模糊和明显的伪影。</i>  <i>在此图像中，可以看到后壁上的模糊点，这是由带有第二个反射物体的标识符的小错误（光线离开场景）引起的。</i>  <i>在完成的图像上，这不是很明显，因为从纹理通道获得了清晰的反射。</i>  <i>光源也变得模糊，但是我喜欢这种效果，所以我离开了。</i>  <i>如果需要，可以通过根据材料更改对象的标识符来防止这种情况。</i> <br><br> 当物体在场景中并且拍摄场景的相机移动缓慢时，每帧中的照明应保持恒定。 因此，我们不仅可以在屏幕的XY坐标上执行模糊；还可以在屏幕上执行模糊。 我们可以及时模糊。 如果我们假设光照在100毫秒内变化不大，则可以将其平均6帧。 但是在此时间范围内，物体和相机之间仍会相隔一段距离，因此简单计算6帧的平均值将创建非常模糊的图像。 但是，我们知道所有对象和摄影机在上一张地图中的位置，因此我们可以计算屏幕空间中的速度矢量。 这称为临时重投影。 如果我在时间t处有一个像素，那么我可以以该像素的速度计算在时间t-1处的像素，然后计算在时间t-1处的像素在时间t-2处，依此类推。后5帧。 与屏幕空间模糊不同，我对每一帧使用相同的权重，即 只是对所有帧之间的颜色进行平均以得到临时的“模糊”。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/a4c/e42/1fca4ce4250f372223862a34472add21.png"></div><br>  <i>像素速度通道根据对象和摄像机的运动报告像素在最后一帧中的位置。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/011/bb5/1f6/011bb51f60e3b3066c87ee4a1d46d403.png"></div><br>  <i>为了避免对象的联合模糊，我们将再次使用对象标识符的通道。</i>  <i>在这种情况下，我们仅考虑光束碰撞的第一个对象。</i>  <i>这提供了对象内的抗锯齿，即</i>  <i>在思考。</i> <br><br> 当然，在前一帧中可能看不到该像素。 它可能被其他物体隐藏或不在相机的视野范围内。 在这种情况下，我们无法使用以前的信息。 此检查是针对每个帧分别执行的，因此我们每个像素获得1到6个样本或帧，并使用可能的样本或帧。 下图显示了对于慢速物体这不是一个非常严重的问题。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5b/c89/8fc/c5bc898fc8ac6ff9b5a0c8685312604f.png"></div><br>  <i>当对象移动并打开场景的新部分时，我们没有6帧信息可以对这些部分取平均。</i>  <i>此图像显示具有6帧的区域（白色），以及缺少6帧的区域（逐渐变暗的阴影）。</i>  <i>轮廓的出现是由于每一帧中像素的采样位置的随机化以及我们从第一个样本中获取对象的标识符这一事实造成的。</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/570/c4c/b4a/570c4cb4a84f008a497678b0b735930e.png"></div><br>  <i>模糊照明平均超过六帧。</i>  <i>伪影几乎是不可见的，并且随着时间的推移，结果是稳定的，因为在每帧中，只有六帧中考虑照明的变化中的一帧。</i> <br><br> 结合所有这些，我们得到一个完整的图像。 照明模糊到相邻像素，而纹理和反射保持清晰。 然后，将所有这些数据平均在六个帧之间，以随时间推移创建更平滑，更稳定的图像。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfa/bba/a35/bfabbaa350d27446b3b058ce41e73228.png"></div><br>  <i>完成的图像。</i> <br><br> 阻尼伪影仍然很明显，因为我平均每个像素有几个样本，尽管我选择了第一个交叉点的对象标识和速度通道。 您可以尝试解决此问题，并通过丢弃样本（如果样本与第一个样本不重合）或至少在第一次碰撞的顺序不重合上获得平滑化。 在实践中，痕迹几乎是看不见的，因此我没有费心去消除它们。 对象的边界也会失真，因为无法平滑速度和对象标识符的通道。 我曾考虑过以2160p渲染整个图像的可能性，并进一步缩小到1080p，但是我的NVidia GTX 980ti无法以60fps的分辨率处理这样的分辨率，因此我决定放弃这个想法。 <br><br> 总的来说，我对介绍的结果感到非常满意。 我设法将所有想法牢记在心，尽管有一些小错误，但最终结果还是很高的质量。 将来，您可以尝试修复错误并改进抗锯齿功能。 还值得尝试使用诸如透明度，运动模糊，各种形状和对象变换之类的功能。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba9/f56/e02/ba9f56e02c13d046f73e888540a0d75e.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN450612/">https://habr.com/ru/post/zh-CN450612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN450602/index.html">“我们如何构建IaaS”：1cloud材料</a></li>
<li><a href="../zh-CN450604/index.html">比Wikipedia更快筛选出数十亿个简单数字</a></li>
<li><a href="../zh-CN450606/index.html">餐厅模特人生中的一天</a></li>
<li><a href="../zh-CN450608/index.html">在我们中间他妈的</a></li>
<li><a href="../zh-CN450610/index.html">热声学。 使用扬声器从声音中产生电能</a></li>
<li><a href="../zh-CN450614/index.html">2019年4月Joomla摘要</a></li>
<li><a href="../zh-CN450618/index.html">根据Yandex和StackOverfow C＃的统计，为什么程序员最便宜？</a></li>
<li><a href="../zh-CN450620/index.html">超新星1987A中微子之谜</a></li>
<li><a href="../zh-CN450624/index.html">从Hayabusa-2向致敬</a></li>
<li><a href="../zh-CN450626/index.html">修复设计模式-PHP中的Singleton</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>