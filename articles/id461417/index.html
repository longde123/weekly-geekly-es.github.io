<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸˆ¯ï¸ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ˜œ Bagaimana saya menolak db4o dalam sistem industri ğŸ’ª ğŸ¤²ğŸ¿ ğŸ•º</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami adalah departemen perusahaan besar yang mengembangkan sistem Java SE / MS SQL / db4o yang penting. Selama beberapa tahun, proyek beralih dari pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya menolak db4o dalam sistem industri</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461417/"><p><img src="https://habrastorage.org/webt/ql/p2/ye/qlp2yevkdo5rbywpveackt_fm7s.jpeg" alt="gambar"></p><br><p>  Kami adalah departemen perusahaan besar yang mengembangkan sistem Java SE / MS SQL / db4o yang penting.  Selama beberapa tahun, proyek beralih dari prototipe ke operasi industri dan db4o berubah menjadi rem perhitungan, saya ingin beralih dari db4o ke teknologi noSQL modern.  Trial and error mengarah jauh dari rencana semula - adalah mungkin untuk menolak db4o, tetapi dengan mengorbankan kompromi.  Di bawah refleksi kucing dan detail implementasi. </p><a name="habracut"></a><br><h2 id="tehnologiya-db4o-umerla">  Apakah teknologi db4o mati? </h2><br><p>  Di HabrÃ© dimungkinkan untuk menemukan tidak begitu banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi</a> tentang db4o.  Di Stackoverflow, ada beberapa aktivitas residual seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar baru pada pertanyaan lama</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertanyaan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baru yang belum terjawab</a> .  Wiki umumnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">percaya</a> bahwa versi stabil saat ini tertanggal 2011. </p><br><p>  Ini membentuk kesan umum: teknologinya tidak relevan.  Bahkan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konfirmasi resmi</a> : Actian memutuskan untuk tidak secara aktif mengejar dan mempromosikan penawaran produk db4o komersial untuk pelanggan baru lagi. </p><br><h2 id="kak-db4o-popala-v-raschet">  Bagaimana db4o bisa dihitung </h2><br><p>  Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Database Berorientasi Objek</a> berbicara tentang fitur utama db4o - tidak adanya skema data.  Anda dapat membuat objek apa pun </p><br><pre><code class="plaintext hljs">User user1 = new User("Vasya", "123456", 25);</code> </pre> <br><p>  dan kemudian hanya menulisnya ke file database </p><br><pre> <code class="plaintext hljs">db.Store(user1)</code> </pre> <br><p>  Objek yang direkam kemudian dapat diambil menggunakan metode Query.execute () dalam bentuk di mana ia disimpan. </p><br><p>  Pada awal proyek, ini memungkinkan untuk dengan cepat memastikan tampilan jejak audit dengan semua data yang disampaikan, tanpa mengganggu struktur tabel relasional.  Ini membantu proyek bertahan.  Lalu ada beberapa sumber daya di kotak pasir, dan segera setelah akhir perhitungan hari ini, data untuk besok mulai memuat di MS SQL.  Semuanya terus berubah - cari tahu apa yang sebenarnya disajikan secara otomatis di malam hari.  Dan file db4o dapat diakses <br>  dalam debugging, ekstrak snapshot dari hari yang diinginkan dan jawab pertanyaan "kami mengirimkan semua data, tetapi Anda tidak memesan apa pun." </p><br><p>  Seiring waktu, masalah kelangsungan hidup menghilang, proyek lepas landas, pekerjaan dengan permintaan pengguna telah berubah.  Buka file db4o dalam debugging dan parse pertanyaan yang sulit bisa pengembang yang selalu sibuk.  Sebagai gantinya, ada kerumunan analis, yang dipersenjatai dengan deskripsi logika pesanan dan hanya dapat menggunakan bagian data yang dapat dilihat pengguna.  Segera db4o menjadi digunakan hanya untuk menampilkan sejarah perhitungan.  Sama seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pareto</a> - sebagian kecil dari kemampuan menyediakan beban utama. </p><br><p>  Dalam operasi tempur, file histori memakan waktu ~ 35 GB / hari, pembongkaran membutuhkan waktu sekitar satu jam.  File itu sendiri kompres dengan baik (1:10), tetapi untuk beberapa alasan perpustakaan com.db4o.ObjectContainer tidak melakukan kompresi.  Di utara CentOS, perpustakaan com.db4o.query.Query menulis / membaca file secara eksklusif untuk satu aliran.  Kecepatan adalah hambatan. </p><br><h1 id="principialnaya-shema-ustroystva">  Diagram skematis perangkat </h1><br><p>  Model informasi sistem adalah hierarki objek A, B, C, dan D. Hirarki bukan pohon, tautan C1 -&gt; B1 diperlukan untuk operasi. </p><br><pre> <code class="plaintext hljs">ROOT || | ==&gt;A1 | || | | ==&gt; B1 &lt;------ | | || | | | | ======&gt; C1 | | | | | | | ===&gt; C1.$D | | =======&gt; C2 | | | | ==&gt; B2 ==&gt; C2.$D | | ===&gt;A2 =======&gt; C3 | | ==&gt; B3 ===&gt; C3.$D | ======&gt; C4 | ===&gt; C4.$D</code> </pre> <br><p>  Pengguna berinteraksi dengan server melalui antarmuka pengguna (GUI), yang disediakan oleh com.sun.net.httpserver.HttpsServer, klien dan server bertukar dokumen XML.  Pada tampilan pertama, server menetapkan pengidentifikasi ke tingkat pengguna, yang tidak berubah lebih lanjut.  Jika pengguna memerlukan riwayat beberapa tingkat, GUI mengirimkan server pengenal yang dibungkus XML.  Server menentukan nilai kunci untuk mencari basis data, memindai file db4o untuk hari yang diinginkan dan mengambil objek yang diminta dalam memori ditambah semua objek yang dirujuk.  Membangun presentasi XML dari tingkat yang diekstraksi dan mengembalikannya ke klien. </p><br><p>  Saat memindai file, db40 secara default membaca semua objek anak hingga kedalaman tertentu, mengekstraksi hierarki yang agak besar bersama-sama dengan objek yang diinginkan.  Waktu membaca dapat dikurangi dengan menetapkan kedalaman aktivasi minimum untuk kelas Foo yang tidak perlu dengan conf.common (). ObjectClass (Foo.class) .maximumActivationDepth (1). </p><br><p>  Menggunakan kelas anonim mengarah ke pembuatan referensi implisit ke kelas terlampir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">$ 0 ini</a> .  Db4o memproses dan mengembalikan tautan seperti itu dengan benar (tetapi lambat). </p><br><h1 id="0-ideya">  0. Ide </h1><br><p>  Jadi, admin memiliki ekspresi aneh di wajah mereka ketika datang untuk mendukung atau mengelola db4o.  Ekstraksi data lambat, teknologinya tidak terlalu hidup.  Tugas: alih-alih db4o, terapkan teknologi NoSQL saat ini.  Sepasang Spring Data + MongoDB menarik perhatian saya. </p><br><h1 id="1-lobovoy-podhod">  1. Pendekatan frontal </h1><br><p>  Pikiran pertama saya adalah menggunakan org.springframework.data.mongodb.core.MongoOperations dan metode save (), karena terlihat seperti com.db4o.ObjectContainer.db.Store (user1).  Dokumentasi MongoDB mengatakan bahwa dokumen disimpan dalam koleksi, adalah logis untuk menyajikan objek sistem yang diperlukan sebagai dokumen dari koleksi yang sesuai.  Ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjelasan @ DBRef</a> yang memungkinkan Anda untuk menerapkan hubungan antar dokumen secara umum dalam semangat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3NF</a> .  Ayo pergi. </p><br><h2 id="11-vygruzka-ssylochnyy-tip-klyucha">  1.1.  Bongkar  Jenis Referensi Kunci </h2><br><p>  Sistem ini terdiri dari kelas POJO yang dirancang sejak lama dan tanpa memperhitungkan semua teknologi baru ini.  Bidang tipe Peta &lt;POJO, POJO&gt; digunakan, ada logika bercabang untuk bekerja dengannya.  Saya menyimpan bidang ini, saya mendapatkan kesalahan </p><br><pre> <code class="plaintext hljs">org.springframework.data.mapping.MappingException: Cannot use a complex object as a key value.</code> </pre> <br><p>  Pada kesempatan ini, hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">korespondensi tahun 2011 yang ditemukan</a> , di mana ia diusulkan untuk mengembangkan MappingMongoConverter non-standar.  Tercatat sejauh ini di bidang masalah @ Transient, saya akan melanjutkan.  Ternyata untuk menyelamatkan, mempelajari hasilnya. </p><br><p>  Penghematan terjadi dalam koleksi, nama yang bertepatan dengan nama kelas yang disimpan.  Saya belum menggunakan anotasi @DBRef, jadi hanya ada satu koleksi, dokumen JSON cukup besar dan bercabang.  Saya perhatikan bahwa ketika Anda menyimpan objek, MongoOperations menelusuri semua tautan non-kosong (termasuk yang diwarisi) dan menulisnya sebagai dokumen terlampir. </p><br><h2 id="12-vygruzka-imenovannoe-pole-ili-massiv">  1.2.  Bongkar  Kolom atau array bernama? </h2><br><p>  Model sistem sedemikian rupa sehingga kelas C dapat berisi referensi ke kelas D yang sama beberapa kali.  Dalam bidang defaultMode yang terpisah dan di antara tautan lainnya di ArrayList, sesuatu seperti ini <br></p><pre> <code class="plaintext hljs">public class C { private D defaultMode; private List&lt;D&gt; listOfD = new ArrayList&lt;D&gt;(); public class D { .. } public C(){ this.defaultMode = new D(); listOfD.add(defaultMode); } }</code> </pre> <br><p>  Setelah membongkar, dokumen JSON akan memiliki dua salinannya: dokumen terlampir bernama defaultMode dan elemen yang tidak disebutkan namanya dari array dokumen.  Dalam kasus pertama, dokumen dapat diakses dengan nama, dalam yang kedua - dengan nama array dengan indeks.  Anda dapat mencari koleksi MongoDB dalam kedua kasus.  Bekerja hanya dengan Spring Data dan MongoDB, saya sampai pada kesimpulan bahwa Anda dapat menggunakan ArrayList, jika hati-hati;  Saya tidak melihat adanya pembatasan penggunaan array.  Fitur muncul kemudian, di tingkat Konektor MongoDB untuk BI. </p><br><h2 id="13-zagruzka-argumenty-konstruktora">  1.3.  Unduh  Argumen konstruktor </h2><br><p>  Saya mencoba membaca dokumen yang disimpan menggunakan metode MongoOperations.findOne ().  Memuat objek A dari database melempar pengecualian </p><br><pre> <code class="plaintext hljs">"No property name found on entity class A to bind constructor parameter to!"</code> </pre> <br><p>  Ternyata kelas memiliki bidang corpName, dan konstruktor memiliki parameter nama String, dan this.corpName = nama ditugaskan di badan konstruktor.  MongoOperations mensyaratkan bahwa nama bidang di kelas cocok dengan nama argumen konstruktor.  Jika ada beberapa konstruktor, Anda perlu memilih satu dengan anotasi @PersistenceConstructor.  Saya membawa nama bidang dan parameter ke dalam korespondensi. </p><br><h2 id="14-zagruzka-sd-i-this0">  1.4.  Unduh  Dengan $ D dan $ 0 ini </h2><br><p>  Kelas D bersarang bagian dalam merangkum perilaku default kelas C dan tidak masuk akal secara terpisah dari kelas C.  Sebuah instance dari D dibuat untuk setiap instance dari C dan sebaliknya - untuk setiap instance dari D ada instance dari C yang menghasilkannya. Kelas D masih memiliki turunan yang menerapkan perilaku alternatif dan dapat disimpan dalam listOfD.  Konstruktor kelas turunan D membutuhkan objek yang ada C. </p><br><p>  Selain kelas dalam bersarang, sistem menggunakan kelas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">anonim</a> .  Seperti yang Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketahui</a> , keduanya berisi referensi implisit ke instance kelas terlampir.  Yaitu, sebagai bagian dari setiap instance objek CD, kompiler membuat tautan $ 0 ini, yang menunjuk ke objek induk C. </p><br><p>  Sekali lagi saya mencoba membaca dokumen yang disimpan dari koleksi dan mendapatkan pengecualian </p><br><pre> <code class="plaintext hljs">"No property this$0 found on entity class $D to bind constructor parameter to!"</code> </pre> <br><p>  Saya ingat bahwa metode kelas D menggunakan kekuatan penuh dari referensi C.this.fieldOfClassC ini, dan turunan dari kelas D membutuhkan konstruktor untuk membuat instance C sebagai argumen.  Yaitu, saya perlu memberikan urutan tertentu untuk membuat objek di MongoOperations sehingga objek induk C dapat ditentukan dalam konstruktor D. Sekali lagi, MappingMongoConverter non-standar? </p><br><p>  Mungkin tidak menggunakan kelas anonim dan membuat kelas dalam menjadi normal?  Memperbaiki, atau lebih tepatnya memperbaiki arsitektur sistem yang sudah diterapkan adalah tugas ... </p><br><h1 id="2-podhod-so-storony-3nfdbref">  2. Pendekatan dari 3NF / @ DBRef </h1><br><p>  Saya mencoba untuk pergi di sisi lain, menyelamatkan setiap kelas dalam koleksi saya dan membuat koneksi di antara mereka dalam semangat 3NF. </p><br><h2 id="21-vygruzka-dbref---eto-krasivo">  2.1.  Bongkar  @DBRef itu indah </h2><br><p>  Kelas C berisi beberapa referensi ke D. Jika tautan defaultMode dan ArrayList ditandai sebagai @DBRef, maka ukuran dokumen akan berkurang, alih-alih dokumen terlampir yang besar akan ada tautan rapi.  Di bidang json, dokumen kumpulan C bidang muncul <br></p><pre> <code class="plaintext hljs">"defaultMode" : DBRef("D", ObjectId("5c496eed2c9c212614bb8176"))</code> </pre> <br><p>  Dalam database MongoDB, kumpulan D secara otomatis dibuat dan dokumen dengan bidang di dalamnya </p><br><pre> <code class="plaintext hljs">"_id" : ObjectId("5c496eed2c9c212614bb8176")</code> </pre> <br><p>  Semuanya sederhana dan indah. </p><br><h2 id="22-zagruzka-konstuktor-klassa-d">  2.2.  Unduh  Konstruktor kelas D </h2><br><p>  Saat bekerja dengan tautan, objek C tahu bahwa objek D default dibuat tepat satu kali.  Jika Anda perlu mem-bypass semua objek D kecuali yang default, cukup bandingkan tautannya: </p><br><pre> <code class="plaintext hljs">private D defaultMode; private ArrayList&lt;D&gt; listOfD; for (D currentD: listOfD){ if (currentD == defaultMode) continue; doSomething(currentD); }</code> </pre> <br><p>  Saya memanggil findOne (), saya mempelajari kelas C. Ternyata MongoOperations membaca dokumen json dan memanggil konstruktor D untuk setiap penjelasan @DBRef yang dijumpainya, setiap kali membuat objek baru.  Saya mendapatkan konstruksi aneh - dua referensi berbeda ke D di bidang defaultMode dan dalam array listOfD, di mana tautannya harus sama. </p><br><p>  Belajar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas</a> : "Dbref menurut saya harus dihindari ketika bekerja dengan mongodb."  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pertimbangan</a> lain dalam nada yang sama dari dokumentasi resmi: model data denormalized di mana data terkait disimpan dalam satu dokumen akan optimal untuk menyelesaikan DBRefs, aplikasi Anda harus melakukan pertanyaan tambahan untuk mengembalikan dokumen yang direferensikan. </p><br><p>  Halaman dokumentasi yang disebutkan mengatakan di bagian paling awal: "Untuk banyak kasus penggunaan di MongoDB, model data denormalized di mana data terkait disimpan dalam satu dokumen akan menjadi optimal."  Apakah ini ditulis untuk saya? </p><br><p>  Fokus dengan perancang menyarankan bahwa Anda tidak perlu berpikir seperti dalam DBMS relasional.  Pilihannya adalah: </p><br><ul><li>  jika Anda menentukan @DBRef: <br><ul><li>  konstruktor untuk setiap anotasi akan dipanggil dan beberapa objek identik akan dibuat; </li><li>  MongoOperations akan menemukan dan membaca semua dokumen dari semua koleksi terkait.  Akan ada permintaan untuk indeks oleh ObjectId dan kemudian membaca dari banyak koleksi database (besar); </li></ul></li><li>  jika Anda tidak menentukan, maka json "abnormal" akan disimpan dengan pengulangan data yang sama. </li></ul><br><p>  Saya perhatikan sendiri: Anda tidak bisa mengandalkan @DBRef, tetapi gunakan bidang tipe ObjectId, mengisinya secara manual.  Dalam hal ini, alih-alih </p><br><pre> <code class="plaintext hljs">"defaultMode" : DBRef("D", ObjectId("5c496eed2c9c212614bb8176"))</code> </pre> <br><p>  dokumen json akan berisi </p><br><pre> <code class="plaintext hljs">"defaultMode" : ObjectId("5c496eed2c9c212614bb8176")</code> </pre> <br><p>  Tidak akan ada pemuatan otomatis - MongoOperations tidak tahu dalam koleksi mana untuk mencari dokumen.  Dokumen harus dimuat dalam permintaan (malas) terpisah yang menunjukkan koleksi dan ObjectId.  Permintaan tunggal harus mengembalikan hasil dengan cepat, di samping itu, indeks otomatis dibuat untuk setiap koleksi oleh ObjectId. </p><br><h2 id="23-nu-i-chto-teper">  2.3.  Jadi bagaimana sekarang? </h2><br><p>  Subtotal.  Itu tidak mungkin untuk dengan cepat dan mudah mengimplementasikan fungsi db4o di MongoDB: </p><br><ul><li>  Tidak jelas cara menggunakan POJO kustom sebagai Kunci - Nilai daftar kunci; </li><li>  Tidak jelas cara mengatur urutan objek yang dibuat di MappingMongoConverter; </li><li>  tidak jelas apakah akan mengunggah dokumen "non-normalisasi" tanpa DBRef dan apakah perlu untuk membuat mekanisme sendiri untuk inisialisasi malas. </li></ul><br><p>  Anda dapat menambahkan pemuatan malas.  Anda dapat mencoba melakukan MappingMongoConverter.  Anda dapat memodifikasi konstruktor / bidang / daftar yang ada.  Tetapi ada bertahun-tahun pelapisan logika bisnis - bukan perubahan yang lemah dan risiko tidak pernah diuji. </p><br><p>  Solusi kompromi: untuk membuat mekanisme baru untuk menyimpan data untuk masalah yang sedang dipecahkan, sambil mempertahankan mekanisme untuk berinteraksi dengan GUI. </p><br><h1 id="3-popytka-tretya-opyt-pervyh-dvuh">  3. Upaya ketiga, pengalaman dua yang pertama </h1><br><p>  Pareto menyarankan bahwa menyelesaikan masalah dengan kecepatan pengguna akan berarti keberhasilan seluruh tugas.  Tugasnya adalah ini: Anda perlu mempelajari cara menyimpan dan mengembalikan data presentasi pengguna dengan cepat tanpa db4o. </p><br><p>  Ini akan kehilangan kemampuan untuk memeriksa objek yang disimpan dalam debugging.  Di satu sisi, ini buruk.  Di sisi lain, tugas seperti itu jarang terjadi, dan di git semua pengiriman pertempuran ditandai.  Untuk toleransi kesalahan, setiap kali sebelum membongkar, sistem membuat serial perhitungan untuk file.  Jika Anda perlu memeriksa objek dalam debugging, Anda dapat mengambil serialisasi, mengkloning unit sistem yang sesuai dan mengembalikan perhitungan. </p><br><h2 id="31-dannye-polzovatelskih-prezentaciy">  3.1.  Data Presentasi Kustom </h2><br><p>  Untuk membangun presentasi tingkat pengguna, sistem memiliki kelas Penampil khusus.  Metode Viewer.getXML () menerima level sebagai input, mengekstraksi nilai numerik dan string yang diperlukan dari itu, dan menghasilkan XML. </p><br><p>  Jika pengguna diminta untuk menunjukkan level perhitungan hari ini, maka level tersebut akan ditemukan dalam RAM.  Untuk menampilkan perhitungan dari masa lalu, metode com.db4o.query.Query.execute () akan menemukan level dalam file.  Level dari file hampir tidak berbeda dari level yang baru saja dibuat dan Penampil akan membangun presentasi tanpa memperhatikan substitusi. </p><br><p>  Untuk mengatasi masalah saya, saya membutuhkan perantara antara tingkat perhitungan dan presentasinya - kerangka presentasi (Bingkai), yang akan menyimpan data dan membangun data XML yang tersedia.  Rantai tindakan untuk membangun presentasi akan menjadi lebih lama, setiap kali bingkai akan dihasilkan dan bingkai akan menghasilkan XML: </p><br><pre> <code class="plaintext hljs"> : &lt; &gt; -&gt; Viewer.getXML() : &lt; &gt; -&gt; Viewer.getFrame() -&gt; Frame.getXML()</code> </pre> <br><p>  Saat menyimpan cerita, Anda perlu membuat bingkai dari semua level dan menulis ke basis data. </p><br><h2 id="32-vygruzka">  3.2.  Bongkar </h2><br><p>  Tugasnya relatif sederhana dan tidak ada masalah dengan itu.  Mengulangi struktur presentasi XML, frame menerima perangkat rekursif dalam bentuk hierarki elemen dengan bidang String, Integer dan Double.  Frame meminta getXML () dari semua elemennya, mengumpulkannya menjadi satu dokumen, dan kembali.  MongoOperations melakukan pekerjaan besar dengan sifat rekursif dari frame dan tidak mengajukan pertanyaan baru saat itu berkembang. </p><br><p>  Akhirnya, semuanya lepas landas!  Mesin WiredTiger secara default <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memampatkan</a> koleksi dokumen MongoDB, pada sistem file, pembongkaran membutuhkan ~ 3,5 GB per hari.  Penurunan sepuluh kali lipat dari db4o tidak buruk. </p><br><p>  Pada awalnya, pembongkaran diatur hanya - traversal rekursif dari pohon level, MongoOperations.save () untuk masing-masing.  Pembongkaran seperti itu memakan waktu 5,5 jam, dan ini terlepas dari kenyataan bahwa membangun presentasi hanya melibatkan objek membaca.  Saya menambahkan multithreading: melintasi pohon level secara rekursif, membagi semua level yang tersedia menjadi paket dengan ukuran tertentu, membuat implementasi Callable.call () sesuai dengan jumlah paket, mentransfer setiap paket ke paket kami sendiri dan melakukannya melalui ExecutorService.invokeAll (). </p><br><p>  MongoOperations kembali tidak mengajukan pertanyaan dan melakukan pekerjaan hebat dengan mode multi-utas.  Memilih ukuran paket secara empiris, memberikan kecepatan bongkar terbaik.  Ternyata 15 menit untuk paket 1000 level. </p><br><h2 id="33-mongo-bi-connector-ili-kak-lyudyam-s-etim-rabotat">  3.3.  Konektor Mongo BI, atau bagaimana orang bekerja dengannya </h2><br><p>  Bahasa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan</a> MongoDB besar dan kuat, saya pasti mendapatkan pengalaman bekerja dengannya, mencapai tempat ini.  Konsol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendukung</a> JavaScript, Anda dapat menulis desain yang indah dan kuat.  Ini satu sisi.  Di sisi lain, saya dapat mematahkan otak setengah dari sesama analis dengan permintaan </p><br><pre> <code class="plaintext hljs">db.users.find( { numbers: { $in: [ 390, 754, 454 ] } } );</code> </pre> <br><p>  bukannya yang biasa </p><br><pre> <code class="plaintext hljs">SELECT * FROM users WHERE numbers IN (390, 754, 454)</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MongoDB Connector untuk BI</a> datang untuk menyelamatkan, di mana Anda dapat menyajikan dokumen koleksi dalam bentuk tabel.  Basis data MongoDB disebut basis data berbasis dokumen, tidak tahu bagaimana menyajikan hierarki bidang / dokumen dalam bentuk tabel.  Agar konektor berfungsi, perlu untuk menggambarkan struktur tabel di masa mendatang dalam file .drdl yang terpisah, format yang sangat mirip dengan yaml.  Dalam file, Anda harus menentukan korespondensi antara bidang tabel relasional di output dan jalur ke bidang dokumen JSON di input. </p><br><h2 id="34--osobennosti-ispolzovanie-massivov">  3.4.  Fitur menggunakan array </h2><br><p>  Dikatakan di atas bahwa untuk MongoDB itu sendiri tidak ada perbedaan khusus antara array dan bidang.  Dari perspektif konektor, array sangat berbeda dari bidang bernama;  Aku bahkan harus memperbaiki kelas Frame yang sudah jadi.  Sejumlah dokumen harus digunakan hanya jika perlu untuk memasukkan bagian informasi ke dalam tabel tertaut. </p><br><p>  Jika dokumen JSON adalah hierarki bidang bernama, maka bidang apa pun dapat diakses dengan menentukan lintasan dari akar dokumen melalui periode, misalnya xy. Jika korespondensi xy =&gt; fieldXY ditentukan dalam file DRDL, maka tabel output akan memiliki banyak baris seperti ada dokumen dalam koleksi di pintu masuk.  Jika dalam beberapa dokumen tidak ada bidang xy, NULL akan berada di baris tabel yang sesuai. </p><br><p>  Misalkan kita memiliki database MongoDB yang disebut Frames, ada koleksi A dalam database, dan MongoOperations telah menulis dua contoh kelas A ke koleksi ini. Berikut dokumen-dokumennya: pertama </p><br><pre> <code class="plaintext hljs">{ "_id": ObjectId("5cdd51e2394faf88a01bd456"), "x": { "y": "xy string value 1"}, "days": [{ "k": "0", "v": 0.0 }, { "k": "1", "v": 0.1 }], "_class": "A" }</code> </pre> <br><p>  dan kedua (ObjectId berbeda dengan digit terakhir): </p><br><pre> <code class="plaintext hljs">{ "_id": ObjectId("5cdd51e2394faf88a01bd457"), "x": { "y": "xy string value 2"}, "days": [{ "k": "0", "v": 0.3 }, { "k": "1", "v": 0.4 }], "_class": "A" }</code> </pre> <br><p>  Konektor BI tidak dapat mengakses elemen-elemen array dengan indeks, dan itu tidak mungkin untuk mengekstrak, misalnya, hari-hari [1] .v bidang dari array ke dalam tabel.  Sebagai gantinya, konektor dapat mewakili setiap elemen array hari sebagai baris dalam tabel terpisah menggunakan operator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">$ relax</a> .  Tabel terpisah ini akan dikaitkan dengan hubungan satu-ke-banyak yang asli melalui pengidentifikasi baris.  Dalam contoh kami, table tableA didefinisikan untuk kumpulan dokumen dan tableA_days untuk dokumen array hari.  File .drdl terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">schema: - db: Frames tables: - table: tableA collection: A pipeline: [] columns: - Name: _id MongoType: bson.ObjectId SqlName: _id SqlType: objectid - Name: xy MongoType: string SqlName: fieldXY SqlType: varchar - table: tableA_days collection: A pipeline: - $unwind: path: $days columns: - Name: _id #   MongoType: bson.ObjectId SqlName: tableA_id SqlType: objectid - Name: days.k MongoType: string SqlName: tableA_dayNo SqlType: varchar - Name: days.v MongoType: string SqlName: tableA_dayVal SqlType: varchar</code> </pre> <br><p>  Isi tabel akan menjadi: table tableA </p><br><div class="scrollable-table"><table><thead><tr><th>  _id </th><th>  fieldXY </th></tr></thead><tbody><tr><td>  5cdd51e2394faf88a01bd456 </td><td>  nilai string xy 1 </td></tr><tr><td>  5cdd51e2394faf88a01bd457 </td><td>  nilai string xy 2 </td></tr></tbody></table></div><br><p>  dan tabel tableA_days </p><br><div class="scrollable-table"><table><thead><tr><th>  tableA_id </th><th>  tableA_dayTidak </th><th>  tableA_dayVal </th></tr></thead><tbody><tr><td>  5cdd51e2394faf88a01bd456 </td><td>  0 </td><td>  0,0 </td></tr><tr><td>  5cdd51e2394faf88a01bd456 </td><td>  1 </td><td>  0,1 </td></tr><tr><td>  5cdd51e2394faf88a01bd457 </td><td>  0 </td><td>  0,3 </td></tr><tr><td>  5cdd51e2394faf88a01bd457 </td><td>  1 </td><td>  0,4 </td></tr></tbody></table></div><br><h1 id="itogo">  Total </h1><br><p>  Itu tidak mungkin untuk mengimplementasikan tugas dalam formulasi asli, Anda tidak bisa hanya mengambil dan mengganti db4o dengan MongoDB.  MongoOperations tidak dapat secara otomatis mengembalikan objek apa pun seperti db4o.  Anda mungkin dapat melakukan ini, tetapi biaya tenaga kerja tidak akan sebanding dengan memanggil metode store / query perpustakaan db4o. </p><br><p>  Jejak audit.  Db4o adalah alat yang sangat berguna pada awal proyek.  Anda cukup menulis objek, lalu mengembalikannya dan pada saat yang sama tidak ada kekhawatiran dan tabel.  Semua ini dengan peringatan penting: jika Anda perlu mengubah hierarki kelas (tambahkan kelas E antara A dan B), maka semua informasi yang disimpan sebelumnya menjadi tidak dapat dibaca.  Tetapi untuk memulai sebuah proyek, ini tidak terlalu penting, selama tidak ada array besar dari file-file lama. </p><br><p>  Ketika ada cukup pengalaman dengan MongoOperations, menulis unggahan tidak menyebabkan masalah.  Menulis kode baru untuk kerangka kerja jauh lebih mudah daripada mengulangi kode lama, yang juga diproduksi. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461417/">https://habr.com/ru/post/id461417/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461401/index.html">Apa yang kamu, Event Loop? Atau cara kerja loop acara di browser Chrome</a></li>
<li><a href="../id461403/index.html">Cara menulis musik menggunakan OOP</a></li>
<li><a href="../id461405/index.html">Bagaimana saya mengambil CFA Level 1</a></li>
<li><a href="../id461407/index.html">Dari sejarah liburan - AdminFest 2011 di Rostov-on-Don</a></li>
<li><a href="../id461413/index.html">Tidak hanya Wi-Fi 6: bagaimana Huawei akan mengembangkan teknologi jaringan</a></li>
<li><a href="../id461421/index.html">Cara mengasuransikan diri Anda dari kemungkinan kerugian saat berinvestasi di bursa: produk struktural</a></li>
<li><a href="../id461423/index.html">11 tips: cara mempresentasikan UI / UX berfungsi untuk "non-desainer"</a></li>
<li><a href="../id461425/index.html">Bagaimana menjadi manajer produk dan berkembang lebih jauh</a></li>
<li><a href="../id461431/index.html">"Suka dan tidak suka": DNS over HTTPS</a></li>
<li><a href="../id461433/index.html">Menggunakan Identity Server 4 di Net Core 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>