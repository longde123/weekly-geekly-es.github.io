<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏼 🖖🏼 🤳🏽 Tempat licin di C ++ 17 🥘 👨🏾 🔒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam beberapa tahun terakhir, C ++ telah melangkah maju dengan cepat, dan mengikuti semua seluk-beluk dan seluk-beluk bahasa bisa sangat, sangat suli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tempat licin di C ++ 17</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/465181/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/fp/nd/-g/fpnd-ggxjx4-xafw3sb7rx2keca.png" alt="gambar"></a> <br><br>  Dalam beberapa tahun terakhir, C ++ telah melangkah maju dengan cepat, dan mengikuti semua seluk-beluk dan seluk-beluk bahasa bisa sangat, sangat sulit.  Sebuah standar baru tidak jauh, namun, pengenalan tren baru bukanlah proses tercepat dan termudah, oleh karena itu, sementara ada sedikit waktu sebelum C ++ 20, saya sarankan menyegarkan atau menemukan beberapa tempat "licin" standar standar saat ini. bahasa <br><br>  Hari ini saya akan memberi tahu Anda mengapa jika constexpr bukan pengganti makro, apa "internal" dari penjilidan terstruktur dan "jebakan" nya dan apakah benar salin salinan selalu berfungsi sekarang dan Anda dapat menulis pengembalian tanpa ragu. <br><br>  Jika Anda tidak takut kotor sedikit pun, gali "bagian dalam" lidah Anda, selamat datang di Cat. <br><a name="habracut"></a><br><hr><br><h1>  jika constexpr </h1><br>  Mari kita mulai dengan yang paling sederhana - <code>if constexpr</code> memungkinkan Anda untuk membuang cabang ekspresi bersyarat yang kondisi yang diinginkan tidak terpenuhi bahkan pada tahap kompilasi. <br><br>  Tampaknya ini adalah pengganti makro <code>#if</code> mematikan logika "ekstra"?  Tidak.  Tidak semuanya. <br><br>  Pertama, <code>if</code> memiliki properti yang tidak tersedia untuk makro - di dalam Anda dapat menghitung ekspresi <code>constexpr</code> yang dapat <code>constexpr</code> menjadi <code>bool</code> .  Nah, dan kedua, isi dari cabang yang dibuang harus benar secara sintaksis dan semantik. <br><br>  Karena persyaratan kedua, <code>if constexpr</code> tidak dapat digunakan, misalnya, fungsi yang tidak ada (kode platform-dependen tidak dapat dipisahkan secara eksplisit dengan cara ini) atau buruk dari sudut pandang bahasa konstruksi (misalnya, " <code>void T = 0;</code> "). <br><br>  Apa gunanya menggunakan <code>if constexpr</code> ?  Poin utama ada di template.  Ada aturan khusus untuk mereka: cabang yang dibuang tidak dipakai saat template dibuat dipakai.  Ini membuatnya lebih mudah untuk menulis kode yang entah bagaimana tergantung pada properti dari tipe templat. <br><br>  Namun, dalam templat, orang tidak boleh lupa bahwa kode di dalam cabang harus benar setidaknya untuk beberapa contoh instantiation (bahkan murni potensial), oleh karena itu, tidak <code>static_assert(false)</code> untuk menulis, misalnya, <code>static_assert(false)</code> di dalam salah satu cabang (perlu bahwa ini <code>static_assert</code> tergantung pada beberapa parameter yang bergantung pada template). <br><br>  Contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//    ,       if constexpr ( os == OS::win ) {        win_api_call(); //         }    else {        some_other_os_call(); //  win      } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-comment"><span class="hljs-comment">//    ,    T      if constexpr ( os == OS::win ) {        T::win_api_call(); //  T   ,    win    }    else {        T::some_other_os_call(); //  T   ,         } }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(condition1)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-comment"><span class="hljs-comment">// ...    }    else if constexpr (condition2) {        // ...    }    else {        // static_assert(false); //          static_assert(trait&lt;T&gt;::value); // ,   ,  trait&lt;T&gt;::value   false    } }</span></span></code> </pre><br><h2>  Hal-hal yang Harus Diingat </h2><br><ol><li>  Kode di semua cabang harus benar. <br></li><li>  Di dalam templat, konten cabang yang dibuang tidak dipakai. <br></li><li>  Kode di dalam cabang apa pun harus benar untuk setidaknya satu varian instantiasi templat yang murni potensial. <br></li></ol><br><h1>  Ikatan terstruktur </h1><br><img src="https://habrastorage.org/webt/0v/jl/x4/0vjlx42it96fu5j20yz-m-pvhpq.png"><br><br>  Di C ++ 17, mekanisme yang cukup nyaman untuk mendekomposisi berbagai objek mirip tuple muncul, memungkinkan Anda untuk dengan mudah dan ringkas mengikat elemen-elemen internal mereka ke variabel bernama: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     —    : for (const auto&amp; [key, value] : map) {    std::cout &lt;&lt; key &lt;&lt; ": " &lt;&lt; value &lt;&lt; std::endl; }</span></span></code> </pre><br>  Dengan objek seperti tuple, maksud saya adalah objek yang jumlah elemen internalnya tersedia pada saat kompilasi diketahui (dari "tuple" - daftar terurut dengan jumlah elemen tetap (vektor)). <br><br>  Definisi tersebut termasuk dalam definisi ini sebagai: <code>std::pair</code> , <code>std::tuple</code> , <code>std::array</code> , array dari form “ <code>T a[N]</code> ”, serta berbagai struktur dan kelas yang ditulis sendiri. <br><br>  Stop ... Bisakah Anda menggunakan struktur Anda sendiri dalam pengikatan struktural?  Spoiler: Anda bisa (walaupun terkadang Anda harus bekerja keras (tetapi lebih dari itu di bawah)). <br><br><h2>  Bagaimana cara kerjanya </h2><br>  Pekerjaan menghubungkan struktural layak mendapatkan artikel terpisah, tetapi karena kita berbicara secara khusus tentang tempat-tempat "licin", saya akan mencoba menjelaskan secara singkat bagaimana semuanya bekerja. <br><br>  Standar ini menyediakan sintaks berikut untuk mendefinisikan pengikatan: <br><br>  <i>attr</i> (opsional) <i>cv-auto</i> <i>ref-operator</i> (opsional) <i>ekspresi</i> [ <i>daftar pengidentifikasi</i> ]; <br><br><ul><li>  <code>attr</code> - daftar atribut opsional; <br></li><li>  <code>cv-auto</code> - otomatis dengan kemungkinan pengubah const / volatile; <br></li><li>  <code>ref-operator</code> - specifier referensi opsional (&amp; atau &amp;&amp;); <br></li><li>  <code>identifier-list</code> - daftar nama variabel baru; <br></li><li>  <code>expression</code> adalah ekspresi yang menghasilkan objek seperti tuple yang digunakan untuk mengikat (ekspresi bisa dalam bentuk " <code>= expr</code> ", " <code>{expr}</code> " atau " <code>(expr)</code> "). <br></li></ul><br>  Penting untuk dicatat bahwa jumlah nama dalam daftar <code>identifier-list</code> harus sesuai dengan jumlah elemen dalam objek yang dihasilkan dari <code>expression</code> . <br><br>  Ini semua memungkinkan Anda untuk menulis konstruksi formulir: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp; [a,b,c] = Foo{};</code> </pre><br>  Dan di sini kita sampai ke tempat "licin" pertama: bertemu ekspresi dari bentuk " <code>auto a = expr;</code>  ", Anda biasanya berarti bahwa tipe" <code>a</code> "akan dihitung oleh ekspresi" <code>expr</code> ", dan Anda berharap bahwa dalam ekspresi" <code>const auto&amp; [a,b,c] = expr;</code>  "Hal yang sama akan dilakukan, hanya tipe untuk" <code>a,b,c</code> "yang akan menjadi tipe <code>const&amp;</code> elemen" <code>expr</code> "yang sesuai ... <br><br>  Kebenarannya berbeda: specifier <code>cv-auto ref-operator</code> digunakan untuk menghitung jenis variabel tak terlihat, di mana hasil perhitungan expr ditugaskan (yaitu, kompiler menggantikan " <code>const auto&amp; [a,b,c] = expr</code> " dengan " <code>const auto&amp; e = expr</code> "). <br><br>  Dengan demikian, entitas tak kasat mata baru muncul (selanjutnya saya akan menyebutnya {e}), namun entitas tersebut sangat berguna: misalnya, ia dapat mematerialisasi objek sementara (karena itu, Anda dapat dengan aman menghubungkannya “ <code>const auto&amp; [a,b,c] = Foo {};</code> "). <br><br>  Tempat licin kedua mengikuti segera dari penggantian yang dibuat oleh kompiler: jika jenis yang dideduksi untuk {e} bukan referensi, maka hasil <code>expr</code> akan disalin ke {e}. <br><br>  Jenis apa yang akan dimiliki variabel dalam <code>identifier-list</code> ?  Untuk memulainya, ini tidak akan menjadi variabel.  Ya, mereka berperilaku seperti variabel nyata dan biasa, tetapi hanya dengan perbedaan yang di dalamnya mereka merujuk ke entitas yang terkait dengannya, dan tipe pernyataan dari variabel "referensi" akan menghasilkan tipe entitas yang dirujuk oleh variabel ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; t(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [a, b] = t; <span class="hljs-comment"><span class="hljs-comment">// decltype(a) — int, decltype(b) — float ++a; // ,  « »,   t std::cout &lt;&lt; std::get&lt;0&gt;(t); //  2</span></span></code> </pre><br>  Jenisnya sendiri didefinisikan sebagai berikut: <br><br><ol><li>  Jika <b>{e}</b> adalah sebuah array ( <code>T a[N]</code> ), maka jenisnya akan menjadi satu - T, cv-modifiers akan bertepatan dengan array. <br></li><li>  Jika <b>{e}</b> bertipe E dan mendukung antarmuka tuple, strukturnya didefinisikan: <br><br><pre> <code class="plaintext hljs">std::tuple_size&lt;E&gt;</code> </pre> <br><pre> <code class="plaintext hljs">std::tuple_element&lt;i, E&gt;</code> </pre> <br>  dan fungsi: <br><br><pre> <code class="plaintext hljs">get&lt;i&gt;({e}); //  {e}.get&lt;i&gt;()</code> </pre> <br>  maka tipe setiap variabel akan menjadi tipe <code>std::tuple_element_t&lt;i, E&gt;</code> <br></li><li>  Dalam kasus lain, jenis variabel akan sesuai dengan jenis elemen struktur yang mengikat dilakukan. <br></li></ol><br>  Jadi, jika sangat singkat, langkah-langkah berikut diambil dengan penautan struktural: <br><br><ol><li>  Perhitungan jenis dan inisialisasi entitas tak terlihat {e} berdasarkan jenis pengubah <code>expr</code> dan <code>cv-ref</code> . <br></li><li>  Buat pseudo-variabel dan ikat ke elemen {e}. <br></li></ol><br><h2>  Secara struktural menghubungkan kelas / struktur Anda </h2><br>  Kendala utama untuk menghubungkan struktur mereka adalah kurangnya refleksi dalam C ++.  Bahkan penyusun, yang, kelihatannya, harus tahu pasti bagaimana struktur ini atau itu diatur di dalam, mengalami kesulitan: pengubah akses (publik / swasta / terlindungi) dan pewarisan sangat mempersulit masalah. <br><br>  Karena kesulitan seperti itu, pembatasan penggunaan kelas mereka sangat ketat (setidaknya untuk saat ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1061</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1096</a> ): <br><br><ol><li>  Semua bidang non-statis internal kelas harus dari kelas dasar yang sama, dan harus tersedia pada saat digunakan. <br></li><li>  Atau kelas harus menerapkan "refleksi" (mendukung antarmuka tuple). <br></li></ol><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  «»  struct A { int a; }; struct B : A {}; struct C : A { int c; }; class D { int d; }; auto [a] = A{}; //  (a -&gt; A::a) auto [a] = B{}; //  (a -&gt; B::A::a) auto [a, c] = C{}; // : a  c    auto [d] = D{}; // : d — private void D::foo() {    auto [d] = *this; //  (d   ) }</span></span></code> </pre><br>  Implementasi antarmuka tuple memungkinkan Anda untuk menggunakan salah satu kelas Anda untuk mengikat, tetapi terlihat sedikit rumit dan membawa jebakan lain.  Mari segera gunakan contoh: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,      int   class Foo; template&lt;&gt; struct std::tuple_size&lt;Foo&gt; : std::integral_constant&lt;std::size_t, 1&gt; {}; template&lt;&gt; struct std::tuple_element&lt;0, Foo&gt; { using type = int&amp;; }; class Foo { public: template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; const&amp; get() const; template&lt;std::size_t i&gt; std::tuple_element_t&lt;i, Foo&gt; &amp; get(); private: int _foo = 0; int&amp; _bar = _foo; }; template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; const&amp; Foo::get&lt;0&gt;() const { return _bar; } template&lt;&gt; std::tuple_element_t&lt;0, Foo&gt; &amp; Foo::get&lt;0&gt;() { return _bar; }</span></span></code> </pre><br>  Sekarang kita ikat: <br><br><pre> <code class="cpp hljs">Foo foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f1] = foo; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f2] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; [f3] = foo; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [f4] = foo;</code> </pre><br>  Dan ini saatnya memikirkan jenis apa yang kita dapat?  (Siapa pun yang bisa menjawab langsung berhak mendapatkan sweetie yang lezat.) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f2); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f3); <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f4);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Jawaban yang benar</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// int&amp; decltype(f2); // int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //     foo._foo,  {e}    const</span></span></code> </pre><br></div></div><br>  Mengapa ini terjadi?  Jawabannya terletak pada spesialisasi standar untuk <code>std::tuple_element</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;i, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">add_const_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">tuple_element_t</span></span>&lt;i, T&gt;&gt;; };</code> </pre><br>  <code>std::add_const</code> tidak menambahkan <code>const</code> ke tipe referensi, jadi tipe untuk <code>Foo</code> akan selalu <code>int&amp;</code> . <br><br>  Bagaimana cara memenangkan ini?  Cukup tambahkan spesialisasi untuk <code>const Foo</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:tuple_element&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Foo&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;; };</code> </pre><br>  Maka semua jenis akan diharapkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(f1); <span class="hljs-comment"><span class="hljs-comment">// const int&amp; decltype(f2); // const int&amp; decltype(f3); // int&amp; decltype(f4); // int&amp; ++f1; //    </span></span></code> </pre><br>  Ngomong-ngomong, perilaku yang sama berlaku untuk, misalnya, <code>std::tuple&lt;T&amp;&gt;</code> <br>  - Anda bisa mendapatkan referensi non-konstan ke elemen internal, meskipun objek itu sendiri akan konstan. <br><br><h2>  Hal yang perlu diingat </h2><br><ol><li>  “ <code>cv-auto ref</code> ” dalam “ <code>cv-auto ref [a1..an] = expr</code> ” mengacu pada variabel tak terlihat {e}. <br></li><li>  Jika jenis yang disimpulkan {e} tidak direferensikan, {e} akan diinisialisasi dengan menyalin (hati-hati dengan kelas "kelas berat"). <br></li><li>  Variabel terikat adalah tautan “implisit” (mereka berperilaku seperti tautan, meskipun jenis <code>decltype</code> mengembalikan tipe non-referensi untuk mereka (kecuali variabel tersebut merujuk ke tautan)). <br></li><li>  Harus diperhatikan saat menggunakan tipe referensi untuk mengikat. <br></li></ol><br><h1>  Return Value Optimization (rvo, salin elision) </h1><br><img src="https://habrastorage.org/webt/gt/0i/ln/gt0iln8n664yvitfqfpkjk9vuds.png"><br><br>  Mungkin ini adalah salah satu fitur yang paling banyak dibahas dari standar C ++ 17 (setidaknya di lingkaran teman saya).  Dan memang: C ++ 11 membawa semantik gerakan, yang sangat menyederhanakan transfer "internal" objek dan pembuatan berbagai pabrik, dan C ++ 17 secara umum, tampaknya, memungkinkan untuk tidak memikirkan cara mengembalikan objek dari metode pabrik apa pun , - sekarang semuanya harus tanpa menyalin dan secara umum, "segera semuanya akan mekar di Mars" ... <br><br>  Tetapi mari kita menjadi sedikit realistis: mengoptimalkan nilai kembali bukanlah hal yang paling mudah untuk diterapkan.  Saya sangat merekomendasikan menonton presentasi ini dari cppcon2018: Arthur O'Dwyer “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Return Value Optimization: Harder Than It Looks</a> ”, di mana penulis menjelaskan mengapa ini sulit. <br><br>  Spoiler pendek: <br><br>  Ada yang namanya "slot untuk nilai pengembalian."  Slot ini pada dasarnya hanyalah tempat di tumpukan yang dialokasikan oleh orang yang memanggil dan meneruskan ke yang dipanggil.  Jika kode yang dipanggil tahu persis objek tunggal mana yang akan dikembalikan, ia dapat langsung dibuat di slot ini secara langsung (asalkan ukuran dan jenis objek dan slotnya sama). <br><br>  Apa yang mengikuti dari ini?  Mari kita bedakan dengan contoh-contoh. <br><br>  Semuanya akan baik-baik saja di sini - NRVO akan berfungsi, objek akan dibangun segera di "slot": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Base a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br>  Di sini tidak lagi mungkin untuk menentukan objek mana yang seharusnya menjadi hasil, sehingga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">move constructor</a> (c ++ 11) akan secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implisit disebut</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Ini sedikit lebih rumit ... Karena jenis nilai balik berbeda dari tipe yang dideklarasikan, Anda tidak dapat secara implisit memanggil <code>move</code> , sehingga pembuat salinan dipanggil secara default.  Untuk mencegah hal ini terjadi, Anda perlu secara eksplisit memanggil <code>move</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a,b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(a); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b); }</code> </pre><br>  Tampaknya ini sama dengan <code>foo2</code> , tetapi operator ternary adalah hal yang sangat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aneh</a> ... <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Base a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Mirip dengan <code>foo4</code> , tetapi juga tipe yang berbeda, jadi <code>move</code> diperlukan persis: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Base </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ Derived a, b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(c ? a : b); }</code> </pre><br>  Seperti yang dapat Anda lihat dari contoh-contoh di atas, kita masih harus berpikir tentang bagaimana mengembalikan makna bahkan dalam kasus-kasus yang tampaknya sepele ... Apakah ada cara untuk menyederhanakan hidup Anda sedikit?  Ya: dentang untuk beberapa waktu mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagnosis</a> kebutuhan untuk secara eksplisit memanggil <code>move</code> , dan ada beberapa proposal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1155</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P0527</a> ) dalam standar baru yang akan membuat <code>move</code> eksplisit kurang diperlukan. <br><br><h2>  Hal yang perlu diingat </h2><br><ol><li>  RVO / NRVO hanya akan berfungsi jika: <br><ul><li>  secara jelas diketahui objek tunggal mana yang harus dibuat dalam "slot nilai balik"; </li><li>  mengembalikan objek dan tipe fungsi adalah sama. </li></ul></li><li>  Jika ada ambiguitas dalam nilai kembali, maka: <br><ul><li>  jika jenis objek dan fungsi yang dikembalikan cocok, bergerak akan disebut secara implisit; </li><li>  jika tidak, Anda harus secara eksplisit memanggil langkah. </li></ul></li><li>  Perhatian dengan operator ternary: itu ringkas, tetapi mungkin memerlukan langkah eksplisit. <br></li><li>  Lebih baik menggunakan kompiler dengan diagnostik yang berguna (atau setidaknya analisa statis). <br></li></ol><br><h1>  Kesimpulan </h1><br>  Namun saya suka C ++;) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465181/">https://habr.com/ru/post/id465181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465167/index.html">Perencanaan Sumberdaya. Mengapa itu tidak berhasil? Bagian 1</a></li>
<li><a href="../id465169/index.html">DIY dari PVS-Studio: Gamification of Achievements</a></li>
<li><a href="../id465173/index.html">Bagaimana cara mengubah biaya berlangganan yang dibuat di aplikasi Anda. App Store Connect dan Google Play Console</a></li>
<li><a href="../id465177/index.html">Bukan Peninggalan Baru: Pandangan pada Datadog dan Atatus</a></li>
<li><a href="../id465179/index.html">Apakah otomasi akan menggantikan pengujian manual?</a></li>
<li><a href="../id465185/index.html">Standar pengawasan video baru: warna pada malam hari, anti noise, ePoE</a></li>
<li><a href="../id465187/index.html">6 frase bahasa Inggris yang dapat digunakan dalam negosiasi gaji dengan perusahaan asing</a></li>
<li><a href="../id465189/index.html">Workflow Satu Tim Pengembangan Sprint</a></li>
<li><a href="../id465191/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 25. Studi mendalam tentang IPv6</a></li>
<li><a href="../id465193/index.html">Membangun proyek Android dalam wadah buruh pelabuhan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>