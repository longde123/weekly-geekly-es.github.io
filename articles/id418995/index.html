<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚬 🕺🏻 ⌚️ Mengapa saya menyalin satu CD 300 kali 📨 🤞🏻 ❕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya mengumpulkan musik: Saya membeli CD, mendigitalkannya dengan Salinan Audio yang Tepat , dan memindai sampul dan sisipan. Terkadang tidak mudah ji...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa saya menyalin satu CD 300 kali</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418995/"> Saya mengumpulkan musik: Saya membeli CD, mendigitalkannya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Salinan Audio yang Tepat</a> , dan memindai sampul dan sisipan.  Terkadang tidak mudah jika CD dirilis dalam edisi terbatas di luar negeri 10 tahun yang lalu.  Hal yang paling sulit adalah jika CD memiliki cacat produksi - dan beberapa trek tidak dapat dibaca. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f5/e32/a86/6f5e32a86569ad14e42c0ea28a8de301.jpg" align="left">  Album aransemen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Altneuland</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">帰 る べ き 城</a> dirilis pada tahun 2005.  Saya menemukannya tiga tahun kemudian (mungkin di YouTube), mengunduh salinan terbaik - dan memasukkannya ke dalam daftar pembelian di masa mendatang.  Kemajuan terbaru dalam teknologi email internasional telah memungkinkan untuk membeli disk yang digunakan tahun lalu.  Sayangnya, tidak ada drive CD saya yang bisa membaca trek nomor 3. Ini sering terjadi ketika membeli disk lama, terutama ketika mereka pergi melalui pusat pengiriman internasional USPS.  Saya mengesampingkannya dan mulai mencari salinan lain yang saya temukan bulan lalu.  Dia tiba pada hari Jumat - dan saya segera mencoba merobeknya.  Tetapi dengan mendorong dengan <i>kesalahan yang sama persis</i> .  Tampaknya ini bukan masalah keausan atau kerusakan - disk mungkin keluar langsung dari pabrik. <br><br>  TAMBAHAN: Setelah penyelidikan, saya tidak lagi percaya bahwa ini adalah cacat pabrik.  Ketika saya menulis awal atau akhir trek yang buruk ke CD-R kosong dan menyalinnya, ripper menghasilkan kesalahan yang sama!  Coba sendiri dengan file <a href="">minimal.flac</a> . <br><a name="habracut"></a><br>  Ada dua opsi yang tersisa: coba suatu hari nanti untuk menemukan salinan lain yang akan berhasil disalin (tidak mungkin), atau entah bagaimana mengembalikan data suara asli dari disk yang rusak.  Anda sudah tahu opsi mana yang telah saya pilih. <br><br><h1>  Bagaimana ripper bekerja </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/9b0/ff6/69e9b0ff62e391da0701a6a4cd02b57d.png"><br>  <i><font color="gray">EAC tidak dapat membaca trek No. 3 dari disk [帰 る べ き 城]</font></i> <br><br>  CD menyimpan data digital, tetapi ada antarmuka yang sepenuhnya analog antara cakram, laser, dan dioda optik.  Kesalahan membaca terjadi karena berbagai alasan: media kotor, goresan pada lapisan pelindung polycarbonate, getaran drive itu sendiri.  Kode koreksi kesalahan primitif dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar CDDA</a> membantu meminimalkan distorsi suara pada disk yang jarang digunakan, tetapi tidak dapat sepenuhnya memulihkan aliran bit pada CD dengan sejumlah besar kesalahan.  Ripper modern memecahkan masalah dengan dua metode pendeteksian kesalahan yang penting: pembacaan berlebihan dan AccurateRip. <br><br>  Halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EAC: Extraction Technology</a> menjelaskan bagaimana EAC menghasilkan pembacaan berlebihan: <br><br><blockquote>  Dalam mode aman, program membaca setiap sektor setidaknya dua kali [...] Jika terjadi kesalahan (baca atau sinkronkan), program akan terus membaca sektor ini hingga 8 dari 16 upaya identik.  Prosedur semacam itu dilakukan paling banyak sekali, tiga atau lima kali (sesuai dengan kualitas pemulihan kesalahan yang dipilih).  Jadi dalam kasus terburuk, bad sector dibaca 82 kali! </blockquote><br>  Semuanya sederhana.  Jika permintaan baca terkadang mengembalikan data yang salah, baca lagi, dan kemudian berhati-hatilah jika dua yang pertama dibaca memberikan hasil yang berbeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AccurateRip</a> menggunakan prinsip yang sama, tetapi secara terdistribusi: ripper mengirim checksum dari file audio yang disalin ke layanan ini.  Idenya adalah bahwa jika seribu orang menyalin trek dengan bit yang sama, ini mungkin rip yang tepat. <br><br>  Artikel ini adalah tentang apa yang harus dilakukan jika kedua metode tidak dapat membantu.  EAC tidak memberikan hasil jika setiap pembacaan mengembalikan data yang berbeda, dan dalam database AccurateRip hanya ada satu catatan tentang disk langka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[1]</a> <a name="1_1"></a>  . <br><br><h1>  "Aku melewati sepuluh ribu bagian, sepuluh ribu bagian untuk melihatmu" </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/44a/1ab/850/44a1ab850b96409640f45e9425f73652.jpg"><br>  <i><font color="gray">Drive optik Asus, LG, Lite-On, Pioneer dan OEM yang tidak dikenal</font></i> <br><br>  Jika CD tidak disalin, logis untuk menggunakan drive yang berbeda.  Terkadang model tertentu lebih merendahkan spesifikasi CDDA, atau apakah ada firmware yang lebih baik untuk memperbaiki kesalahan, atau yang lainnya.  Forum DBpoweramp memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peringkat akurasi drive CD / DVD</a> untuk memilih drive rip yang paling cocok. <br><br>  Pada Sabtu pagi, saya membeli lima drive CD baru dari berbagai produsen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[2]</a> <a name="2_2"></a>  , Saya mencoba semuanya - dan menemukan satu yang dapat menjaga sinkronisasi pada beat beat.  Sayangnya, konfirmasi rip tidak dapat diperoleh - di antara semua robekan ada sekitar 20.000 byte yang berbeda. <br><br>  Tapi sekarang saya punya file .wav di disk, dan Anda bisa mendapat manfaat dari ini.  Saya beralasan bahwa membaca kesalahan di jalur yang buruk berada di dekat yang "benar".  Oleh karena itu, masuk akal untuk membuat beberapa robekan dan menemukan nilai "konsensus" untuk byte yang tidak stabil.  Pendekatan ini pada akhirnya berhasil, tetapi membutuhkan lebih banyak pekerjaan daripada yang saya harapkan. <br><br><h1>  “Kuantitas masuk ke kualitas” </h1><br>  Saya mulai dengan menyalin disk beberapa kali pada salah satu drive, menulis semua nilai untuk setiap byte dan menyatakan kesalahan "dapat diperbaiki" jika lebih dari setengah robekan menghasilkan nilai byte spesifik untuk posisi ini.  Permulaannya bagus: jumlah kesalahan yang tidak dapat diperbaiki menurun dari hampir ~ 6900 byte pada N = 4 hingga ~ 5000 byte pada N = 10.  Manfaat dari setiap rip tambahan menurun dari waktu ke waktu, sampai sekitar N = 80 jumlah kesalahan yang tidak dapat diperbaiki menjadi stabil pada ~ 3700.  Saya berhenti merobek N = 100. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/aaa/809/b87aaa809a043eaeaa2d049258fe0cb9.png"><br>  <i><font color="gray">Memperbaiki dan kesalahan fatal pada jumlah rip</font></i> <br><br>  Kemudian saya mencoba menyalin disk 100 kali pada drive kedua dan menggunakan dua kartu koreksi untuk "mengisi" posisi kesalahan yang tidak dapat diperbaiki dari drive pertama.  Tapi itu tidak berhasil: pada setiap drive ada ribuan koreksi yang tidak sesuai dengan koreksi di yang lain!  Ternyata noise tidak bisa dihilangkan dengan menggabungkannya dengan sumber noise lain yang terkait. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/911/6d5/c33/9116d5c339461cb286edc4537c712a71.png"><br>  <i><font color="gray">Hal yang sama, tetapi untuk dua disc lintas-validasi</font></i> <br><br><h1>  Seni rakyat </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/829/554/ec78295544b0a161b472598114e2be2d.jpg"><br><br>  Ada sumber daya lain yang baik di situs web EAC: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes kualitas DAE</a> , yang menentukan kualitas firmware drive dengan tingkat kesalahan yang diperbaiki.  Ini adalah penanganan kesalahan level yang lebih rendah ketika drive <i>mengoreksi</i> kesalahan baca daripada hanya melaporkannya.  Tangkapannya adalah bahwa "safe mode" dari EAC hanya tersedia ketika Anda menonaktifkan kode koreksi kesalahan bawaan ini, menunjukkan bahwa itu tidak bekerja dengan benar. <br><br>  Saya menyiapkan tes dengan membakar file .wav ke CD-R, menyoroti sektor yang tepat di permukaan data dan dengan hati-hati mengecatnya dengan spidol hitam.  Ini dijamin kesalahan fatal pada pola deterministik. <br><br>  Saya menguji semua drive dan mendapat dua hasil menarik: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11f/4c6/f55/11f4c6f554062ec91d1f5d4160b40a43.png"><br><br>  Saya menggunakan drive Lite-On untuk mengatasi kesalahan sinkronisasi.  Dia mengunyah penanda ajaib dengan senang, tetapi dia sangat bingung dengan garis lurus di permukaan data.  Anda dapat melihat bagaimana alih-alih tiga puncak terpisah di sebelah kanan ada satu gumpalan gagal besar. <br><br> <code>Errors total Num : 206645159 <br> Errors (Loudness) Num : 965075 - Avg : -21.7 dB(A) - Max : -5.5 dB(A) <br> Error Muting Num : 154153 - Avg : 99.1 Samples - Max : 3584 Samples <br> Skips Num : 103 - Avg : 417.3 Samples - Max : 2939 Samples <br> <br> Total Test Result : 45.3 points (of 100.0 maximum)</code> <br> <br><img src="https://habrastorage.org/getpro/habr/post_images/07b/beb/2d7/07bbeb2d7534a3eb062e176c8b059182.png"><br><br>  Drive Pioneer menerima skor DAE tertinggi.  Menurut pendapat saya, bagan tidak terlihat istimewa, tetapi alat analisis mengatakan bahwa ini adalah firmware terbaik untuk memperbaiki kesalahan dalam set kecil saya. <br><br> <code>Errors total Num : 2331952 <br> Errors (Loudness) Num : 147286 - Avg : -77.2 dB(A) - Max : -13.2 dB(A) <br> Error Muting Num : 8468 - Avg : 1.5 Samples - Max : 273 Samples <br> Skips Num : 50 - Avg : 6.5 Samples - Max : 30 Samples <br> <br> Total Test Result : 62.7 points (of 100.0 maximum)</code> <br> <br><h1>  "Dari saat tertentu, angka penting" </h1><br>  Bagaimana cara menggunakan firmware Pioneer dengan koreksi kesalahan yang baik jika "safe mode" EAC mengabaikannya?  Sangat sederhana: alihkan EAC ke "burst mode" dan tulis ke disk bit stream dalam bentuk di mana firmware melaporkannya.  Lalu bagaimana mengubah sekelompok file .wav yang tidak diverifikasi ini menjadi file berkualitas baik, seperti dalam "safe mode"?  Ya, alat analisis kesalahan yang sama yang kami gunakan dalam robekan dengan Lite-On! <br><br>  Setelah beberapa pengaturan konfigurasi EAC dan setelah seratus robekan, kami mendapatkan diagram yang begitu indah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/323/e9f/405323e9fad21af9069c1983e25a7025.png"><br>  <i><font color="gray">Memperbaiki dan memperbaiki kesalahan pada jumlah robekan (Pioneer)</font></i> <br><br>  Apa yang bisa dicatat: <br><br><ul><li>  Kesalahan bit fatal cepat cenderung ke nol, tetapi tidak pernah mencapainya. </li><li>  Lompatan besar dalam bug yang diperbaiki dalam 53-54 robekan. </li><li>  Jumlah kesalahan sebelum dan sesudah lompatan besar ini praktis tidak berubah, yang menunjukkan bidang stabilitas dalam data yang disalin. </li></ul><br><h1>  0xA595BC09 </h1><br>  Menggunakan koreksi kesalahan yang hampir sempurna dari Pioneer, saya menghasilkan file "tebakan terbaik" dan mulai membandingkannya dengan robekan Pioneer.  Seperti yang diharapkan, beberapa bagian berkualitas rendah ditemukan, yang saya koreksi dengan membuat 10 robekan lagi: <br><br> <code>$ for RIP_ID in $(seq -w 1 100); do echo -n "rip$RIP_ID: "; cmp -l analysis-out.wav rips-cd1-pioneer/rip${RIP_ID}/*.wav | wc -l ; done | sort -rgk2 | head -n 10 <br> rip054: 2865 <br> rip099: 974 <br> rip007: 533 <br> rip037: 452 <br> rip042: 438 <br> rip035: 404 <br> rip006: 392 <br> rip059: 381 <br> rip043: 327 <br> rip014: 323</code> <br> <br>  Saya juga menemukan sesuatu yang sangat menarik: beberapa robekan menghasilkan konten yang <i>persis</i> sama!  Ingat, ini justru kriteria untuk sukses dalam "safe mode" EAC.  <code>shncat -q -e | rhash --print="%C"</code>  <code>shncat -q -e | rhash --print="%C"</code> digunakan untuk menghitung checksum CRC32 dari data audio mentah: inilah yang digunakan EAC. <br><br> <code>$ for wav in rips-cd1-pioneer/*/*.wav; do shncat "$wav" -q -e | rhash --printf="%C $wav\n" - ; done | sort -k1 <br> [...] <br> 9DD05FFF rips-cd1-pioneer/rip059/rip.wav <br> 9F8D1B53 rips-cd1-pioneer/rip072/rip.wav <br> A2EA0283 rips-cd1-pioneer/rip082/rip.wav <br> A595BC09 rips-cd1-pioneer/rip021/rip.wav <br> A595BC09 rips-cd1-pioneer/rip022/rip.wav <br> A595BC09 rips-cd1-pioneer/rip023/rip.wav <br> A595BC09 rips-cd1-pioneer/rip024/rip.wav <br> A595BC09 rips-cd1-pioneer/rip025/rip.wav <br> A595BC09 rips-cd1-pioneer/rip026/rip.wav <br> A595BC09 rips-cd1-pioneer/rip027/rip.wav <br> A595BC09 rips-cd1-pioneer/rip028/rip.wav <br> A595BC09 rips-cd1-pioneer/rip030/rip.wav <br> A595BC09 rips-cd1-pioneer/rip031/rip.wav <br> A595BC09 rips-cd1-pioneer/rip040/rip.wav <br> A595BC09 rips-cd1-pioneer/rip055/rip.wav <br> A595BC09 rips-cd1-pioneer/rip058/rip.wav <br> AA3B5929 rips-cd1-pioneer/rip043/rip.wav <br> ABAAE784 rips-cd1-pioneer/rip033/rip.wav <br> [...]</code> <br> <br>  Sementara itu, robekan berulang dari bagian berkualitas rendah memungkinkan kami untuk menyelesaikan analisis dengan nol kesalahan fatal.  Dan ketika saya memeriksa file ini, ada konten audio yang persis sama seperti pada rip "biasa"!  Ini cukup untuk menyatakan kemenangan. <br><br>  Saya 99% yakin bahwa saya berhasil menyalin CD bermasalah ini, dan 0xA595BC09 adalah jumlah CRC yang tepat untuk track nomor 3. <br><br><h1>  Lampiran A: compare.rs </h1><br>  Saya menggunakan alat ini untuk menghitung kemungkinan byte error.  Ini tidak dimaksudkan untuk penggunaan jangka panjang, jadi ini sedikit jelek, tetapi mungkin menarik bagi mereka yang menemukan halaman ini, menyelesaikan masalah yang sama. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> memmap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::collections::HashMap; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::env; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::mpsc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> memmap::Mmap; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHUNK_SIZE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">suspect_positions</span></span></span></span>( mmaps: &amp;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt;, start_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, end_idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, ) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> positions = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ii <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> start_idx..end_idx { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (_file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { byte = file_content[ii]; first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> byte != file_content[ii] { positions.push(ii); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } positions } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> args: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt; = env::args().collect(); args.remove(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> files: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;fs::File&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmaps: HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, Mmap&gt; = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> file = fs::File::open(&amp;filename).unwrap(); files.push(file); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { Mmap::map(files.last().unwrap()).unwrap() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first { first = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; size = mmap.len(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(size == mmap.len()); } mmaps.insert(filename, mmap); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (suspects_tx, suspects_rx) = mpsc::channel(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> start_idx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = sync::Arc::new(mmaps); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_start_idx = start_idx; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> t_end_idx = cmp::min(start_idx + CHUNK_SIZE, size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start_idx == t_end_idx { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmaps_ref = mmaps_ref.clone(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects_tx = suspects_tx.clone(); thread::spawn(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> suspects = suspect_positions(mmaps_ref.as_ref(), t_start_idx, t_end_idx); suspects_tx.send(suspects).unwrap(); }); start_idx = t_end_idx; } <span class="hljs-built_in"><span class="hljs-built_in">drop</span></span>(suspects_tx); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::with_capacity(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects_rx { suspects.append(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> suspects_chunk); } suspects.sort(); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{{\"files\": ["</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> first_file = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (file_name, file_content) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mmaps_ref.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> file_comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_file { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; first_file = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}{{\"name\": \"{}\", \"suspect_bytes\": ["</span></span>, file_comma, file_name); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (ii, position) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> suspects.iter().enumerate() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> comma = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ii == suspects.len() - <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-string"><span class="hljs-string">","</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"[{}, {}]{}"</span></span>, position, file_content[*position], comma); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"]}}"</span></span>); }</code> </pre> <br>  1. <a name="1"></a>  Dalam catatan AccurateRip tunggal ini, CRC untuk semua trek kecuali nomor trek 3 cocok dengan disk saya: jumlahnya adalah 0x84B9DD1A, dan saya punya 0xA595BC09.  Saya menduga bahwa ripper tidak mengerti bahwa ia memiliki drive yang buruk.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[kembali]</a> <br><br>  2. <a name="2"></a>  Pertanyaan yang jelas ketika membeli drive CD atau DVD pada tahun 2018 adalah: "Sial, di mana saya bisa membelinya?"  Dan saya tidak membutuhkan satu, tetapi <i>beberapa</i> dari <i>merek yang berbeda</i> .  Saya tahu hanya satu toko di dekatnya yang memiliki drive DVD 5,25 ". Hanya satu toko yang cukup besar untuk tidak menyesali ruang rak untuk drive seperti itu, dan cukup aneh untuk tidak terlihat aneh di sana. Tentu saja, saya berbicara tentang Frys Electronics. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[kembali]</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418995/">https://habr.com/ru/post/id418995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418979/index.html">Ketika saya terbang di seluruh negeri, mengimplementasikan proyek untuk beberapa ribu pekerjaan</a></li>
<li><a href="../id418981/index.html">Metode numerik untuk menyelesaikan persamaan elips</a></li>
<li><a href="../id418985/index.html">Analisis dan desain secara keseluruhan</a></li>
<li><a href="../id418987/index.html">Firefox dengan mudah melewati perlindungan di antarmuka Gmail baru</a></li>
<li><a href="../id418991/index.html">Mikrofilm akan ada selama setengah milenium</a></li>
<li><a href="../id418997/index.html">Kontribusi Nyata ke Sumber Terbuka Nyata</a></li>
<li><a href="../id418999/index.html">[Pengumuman, Peter] JUG.ru bertemu dengan Andrei Belyaev dan Alexei Stukalov - Troll menekan CUBA: FAQ</a></li>
<li><a href="../id419001/index.html">5 "keterampilan super" diperlukan untuk pekerjaan di masa depan</a></li>
<li><a href="../id419003/index.html">Intisari Blockchain</a></li>
<li><a href="../id419005/index.html">Wisata ke gardu 220/110/20</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>