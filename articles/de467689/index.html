<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïí üåä ü¶å Ein kleiner √úberblick √ºber SIMD in .NET / C # ü§üüèª üï∫ üòî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hier ein kurzer √úberblick √ºber die Vektorisierungsfunktionen von Algorithmen in .NET Framework und .NET Core. Dieser Artikel richtet sich an diejenige...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein kleiner √úberblick √ºber SIMD in .NET / C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467689/"><p>  Hier ein kurzer √úberblick √ºber die Vektorisierungsfunktionen von Algorithmen in .NET Framework und .NET Core.  Dieser Artikel richtet sich an diejenigen, die nichts √ºber diese Techniken wissen.  Ich werde auch zeigen, dass .NET f√ºr die native Entwicklung nicht hinter "echt kompilierten" Sprachen zur√ºckbleibt. </p><a name="habracut"></a><br><p> Ich fange gerade an, Vektorisierungstechniken zu lernen.  Ich w√ºrde mich freuen, wenn Community-Mitglieder eindeutige Fehler finden oder Verbesserungen der beschriebenen Algorithmen vorschlagen. </p><br><h2 id="some-history">  Etwas Geschichte </h2><br><p>  SIMD wurde 2015 in .NET Framework 4.6 ver√∂ffentlicht. Dann wurden die Typen Matrix3x2, Matrix4x4, Plane, Quaternion, Vector2, Vector3 und Vector4 hinzugef√ºgt.  Sie erlaubten vektorisierte Berechnungen.  Als n√§chstes kam der Typ Vector &lt;T&gt;, der mehr M√∂glichkeiten zur Vektorisierung von Algorithmen bot.  Viele Programmierer waren jedoch immer noch unzufrieden, da diese Typen die Ideenstr√∂me der Codierer einschr√§nkten und nicht die volle Kapazit√§t von SIMD-Anweisungen in modernen Prozessoren nutzen lie√üen.  In der Vorschau von .NET Core 3.0 haben wir jetzt den System.Runtime.Intrinsics-Namespace, der viel Freiheit bei der Auswahl von Anweisungen bietet.  Um die h√∂chste Geschwindigkeit zu erzielen, m√ºssen Sie RyuJit verwenden und entweder auf die x64-Assembly zur√ºckgreifen oder ausschalten. Bevorzugen Sie 32-Bit und w√§hlen Sie AnyCPU-Assembly.  Ich habe alle Benchmarks auf einem Intel Core i7-6700 3,40 GHz (Skylake) CPU-Computer ausgef√ºhrt. </p><br><h2 id="summing-array-elements">  Array-Elemente summieren </h2><br><p>  Ich habe mich entschlossen, mit einer klassischen Aufgabe zu beginnen, die normalerweise an erster Stelle steht, wenn es um Vektorisierung geht.  Es geht darum, die Summe der Array-Elemente zu finden.  Schreiben wir vier Implementierungen dieser Aufgabe, um die Elemente von Array zu summieren. </p><br><p>  Die naheliegendste Implementierung: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { result += i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  LINQ-basierte Implementierung: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Aggregate&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, (current, i) =&gt; current + i);</code> </pre> <br><p>  Die Implementierung basiert auf Vektoren von System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Die Implementierung basiert auf Code aus dem System.Runtime.Intrinsics-Namespace: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Ich habe diese 4 Methoden auf meinem Computer verglichen und die folgenden Ergebnisse erzielt: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10 </td><td>  3,531 ns </td><td>  0,0336 ns </td><td>  0,0314 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  76,925 ns </td><td>  0,4166 ns </td><td>  0,3897 ns </td><td>  21.79 </td></tr><tr><td>  Vektoren </td><td>  10 </td><td>  2,750 ns </td><td>  0,0210 ns </td><td>  0,0196 ns </td><td>  0,78 </td></tr><tr><td>  Intrinsics </td><td>  10 </td><td>  6,513 ns </td><td>  0,0623 ns </td><td>  0,0582 ns </td><td>  1,84 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100 </td><td>  47,982 ns </td><td>  0,3975 ns </td><td>  0,3524 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  590,414 ns </td><td>  3,8808 ns </td><td>  3,4402 ns </td><td>  12.31 </td></tr><tr><td>  Vektoren </td><td>  100 </td><td>  10,122 ns </td><td>  0,0747 ns </td><td>  0,0699 ns </td><td>  0,21 </td></tr><tr><td>  Intrinsics </td><td>  100 </td><td>  14.277 ns </td><td>  0,0566 ns </td><td>  0,0529 ns </td><td>  0,30 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1000 </td><td>  569.910 ns </td><td>  2,8297 ns </td><td>  2,6469 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  5.658,570 ns </td><td>  31,7465 ns </td><td>  29.6957 ns </td><td>  9.93 </td></tr><tr><td>  Vektoren </td><td>  1000 </td><td>  79,598 ns </td><td>  0,3498 ns </td><td>  0,3272 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  66,970 ns </td><td>  0,3937 ns </td><td>  0,3682 ns </td><td>  0,12 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  10.000 </td><td>  5.637,571 ns </td><td>  37,5050 ns </td><td>  29,2814 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  56.498.987 ns </td><td>  294.8776 ns </td><td>  275,8287 ns </td><td>  10.02 </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  772.900 ns </td><td>  2,6802 ns </td><td>  2,5070 ns </td><td>  0,14 </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  579,152 ns </td><td>  2,8371 ns </td><td>  2,6538 ns </td><td>  0,10 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  56.352,865 ns </td><td>  230,7916 ns </td><td>  215,8826 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  562,610,571 ns </td><td>  3,775.7631 ns </td><td>  3,152.9332 ns </td><td>  9.98 </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  8,389.647 ns </td><td>  165,9590 ns </td><td>  227,1666 ns </td><td>  0,15 </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  7,261.334 ns </td><td>  89,6468 ns </td><td>  69.9903 ns </td><td>  0,13 </td></tr></tbody></table></div><br><p>  Es ist klar, dass L√∂sungen mit Vektoren und Intrinsics viel schneller sind als die offensichtlichen und LINQ-basierten L√∂sungen.  Jetzt m√ºssen wir herausfinden, was in diesen beiden Methoden vor sich geht. </p><br><p>  Betrachten wir die Vektorenmethode genauer: </p><br><div class="spoiler">  <b class="spoiler_title">Vektoren</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); accVector = Vector.Add(accVector, v); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = Vector.Dot(accVector, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  int vectorSize = Vector &lt;int&gt; .Count;  - Die Anzahl der 4-Byte-Zahlen, die wir in einen Vektor einf√ºgen k√∂nnen.  Wenn die Hardwarebeschleunigung verwendet wird, zeigt dieser Wert an, wie viele 4-Byte-Nummern in ein SIMD-Register eingef√ºgt werden k√∂nnen.  Tats√§chlich wird angezeigt, wie viele Elemente dieses Typs gleichzeitig verarbeitet werden k√∂nnen. </li><li>  accVector ist ein Vektor, der das Ergebnis der Funktion akkumuliert. </li><li>  var v = neuer Vektor &lt;int&gt; (Array, i);  - Die Daten aus dem Array werden beginnend mit dem i-Index in einen neuen v-Vektor geladen.  Die Vektorgr√∂√üe der Daten wird genau geladen. </li><li>  accVector = Vector.Add (accVector, v);  - Zwei Vektoren werden summiert. <br>  Zum Beispiel enth√§lt Array 8 Zahlen: {0, 1, 2, 3, 4, 5, 6, 7} und vectorSize == 4. <br>  W√§hrend des ersten Zyklus iteriert accVector = {0, 0, 0, 0}, v = {0, 1, 2, 3} und nach der Addition h√§lt accVector: {0, 0, 0, 0} + {0, 1 , 2, 3} = {0, 1, 2, 3}. <br>  W√§hrend der zweiten Iteration ist v = {4, 5, 6, 7} und nach Addition accVector = {0, 1, 2, 3} + {4, 5, 6, 7} = {4, 6, 8, 10}. </li><li>  Jetzt m√ºssen wir nur noch die Summe aller Vektorelemente erhalten.  Dazu k√∂nnen wir die Skalarmultiplikation mit einem mit Einsen gef√ºllten Vektor verwenden: int result = Vector.Dot (accVector, Vector &lt;int&gt; .One); <br>  Dann erhalten wir: {4, 6, 8, 10} * {1, 1, 1, 1} = 4 * 1 + 6 * 1 + 8 * 1 + 10 * 1 = 28. </li><li>  Falls erforderlich, werden die Zahlen, die nicht zum letzten Vektor passen, am Ende summiert. </li></ul><br><p>  Schauen wir uns den Intrinsics-Code an: </p><br><div class="spoiler">  <b class="spoiler_title">Intrinsics</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); accVector = Avx2.Add(accVector, v); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { result += array[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Wir k√∂nnen sehen, dass es mit einer Ausnahme wie Vektoren ist: </p><br><ul><li>  vectorSize wird durch eine Konstante angegeben.  Dies liegt daran, dass diese Methode explizit Avx2-Anweisungen verwendet, die mit 256-Bit-Registern arbeiten.  Eine echte Anwendung sollte eine √úberpr√ºfung enthalten, ob ein aktueller Prozessor Avx2 unterst√ºtzt.  Wenn nicht, sollte ein anderer Code aufgerufen werden.  Es sieht so aus: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.IsSupported) { DoThingsForAvx2(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx.IsSupported) { DoThingsForAvx(); } ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Sse2.IsSupported) { DoThingsForSse2(); } ...</code> </pre> </li><li>  var accVector = Vector256 &lt;int&gt; .Zero;  accVector wird als 256-Bit-Vektor deklariert, der mit Nullen gef√ºllt ist. </li><li>  fest (int * ptr = Array) - Der Zeiger auf das Array wird in ptr platziert. </li><li>  Als n√§chstes folgen die gleichen Operationen wie in Vektoren: Laden von Daten in einen Vektor und Hinzuf√ºgen von zwei Vektoren. </li><li>  Die Summierung von Vektorelementen erfolgt nach folgender Methode: <br><ul><li>  Erstellen Sie ein Array auf dem Stapel: var temp = stackalloc int [vectorSize]; </li><li>  Laden Sie einen Vektor in dieses Array: Avx2.Store (temp, accVector); </li><li>  Summenarray-Elemente w√§hrend des Zyklus. </li></ul></li><li>  Als n√§chstes werden die Elemente zusammengefasst, die nicht zum letzten Vektor passen. </li></ul><br><h2 id="comparing-two-arrays">  Zwei Arrays vergleichen </h2><br><p>  Wir m√ºssen zwei Arrays von Bytes vergleichen.  Genau diese Aufgabe hat mich dazu gebracht, SIMD in .NET zu studieren.  Lassen Sie uns noch einmal verschiedene Methoden f√ºr das Benchmarking schreiben und zwei Arrays vergleichen: ArrayA und ArrayB. </p><br><p>  Die naheliegendste L√∂sung: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  LINQ-basierte L√∂sung: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; ArrayA.SequenceEqual(ArrayB);</code> </pre> <br><p>  Die L√∂sung basierend auf der MemCmp-Funktion: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"msvcrt.dll"</span></span></span><span class="hljs-meta">, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memcmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemCmp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; memcmp(ArrayA, ArrayB, ArrayA.Length) == <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  Die L√∂sung basiert auf Vektoren von System.Numerics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt;= ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayA, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(ArrayB, i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Vector.EqualsAll(va, vb)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  Intrinsics-basierte L√∂sung: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> equalsMask = <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (<span class="hljs-number"><span class="hljs-number">0b1111</span></span>_1111_1111_1111_1111_1111_1111_1111)); <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrA = ArrayA) <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptrB = ArrayB) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt;= ArrayA.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> va = Avx2.LoadVector256(ptrA + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vb = Avx2.LoadVector256(ptrB + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; ArrayA.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ArrayA[i] != ArrayB[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Die Ergebnisse der Ausf√ºhrung des Benchmarks auf meinem Computer: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10.000 </td><td>  7.033,8 ns </td><td>  50,636 ns </td><td>  47,365 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  64.841,4 ns </td><td>  289,157 ns </td><td>  270,478 ns </td><td>  9.22 </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  504,0 ns </td><td>  2,406 ns </td><td>  2,251 ns </td><td>  0,07 </td></tr><tr><td>  Memcmp </td><td>  10.000 </td><td>  368,1 ns </td><td>  2,637 ns </td><td>  2,466 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  283,6 ns </td><td>  1,135 ns </td><td>  1,061 ns </td><td>  0,04 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  85.214,4 ns </td><td>  903,868 ns </td><td>  845,478 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  702.279,4 ns </td><td>  2,846.609 ns </td><td>  2,662.720 ns </td><td>  8.24 </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  5,179,2 ns </td><td>  45,337 ns </td><td>  42,409 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  100.000 </td><td>  4,510,5 ns </td><td>  24,292 ns </td><td>  22.723 ns </td><td>  0,05 </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  2.957,0 ns </td><td>  11.452 ns </td><td>  10,712 ns </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1.000.000 </td><td>  844.006,1 ns </td><td>  3,552.478 ns </td><td>  3,322.990 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6.483.079,3 ns </td><td>  42.641,040 ns </td><td>  39.886,455 ns </td><td>  7.68 </td></tr><tr><td>  Vektoren </td><td>  1.000.000 </td><td>  54.180,1 ns </td><td>  357,258 ns </td><td>  334.180 ns </td><td>  0,06 </td></tr><tr><td>  Memcmp </td><td>  1.000.000 </td><td>  49.480,1 ns </td><td>  515,675 ns </td><td>  457,133 ns </td><td>  0,06 </td></tr><tr><td>  Intrinsics </td><td>  1.000.000 </td><td>  36.633,9 ns </td><td>  680,525 ns </td><td>  636,564 ns </td><td>  0,04 </td></tr></tbody></table></div><br><p>  Ich denke, der Code dieser Methoden ist klar, mit Ausnahme von zwei Zeilen in Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(va, vb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Avx2.MoveMask(areEqual) != equalsMask) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  In der ersten Zeile werden zwei Vektoren auf Gleichheit verglichen und das Ergebnis in einem gleichen Vektor gespeichert, in dem alle Bits im Element an einer bestimmten Position auf 1 gesetzt werden, wenn die entsprechenden Elemente in va und vb gleich sind.  Es stellt sich also heraus, dass, wenn die Bytevektoren va und vb gleich sind, alle Elemente in areEquals gleich 255 (11111111b) sein sollten.  Da Avx2.CompareEqual ein Wrapper √ºber _mm256_cmpeq_epi8 ist, k√∂nnen wir auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intel-Website</a> den Pseudocode dieser Operation anzeigen: <br>  Die MoveMask-Methode erstellt aus einem Vektor eine 32-Bit-Zahl.  Die oberen Bits von jeweils 32 Ein-Byte-Elementen in einem Vektor sind die Werte der Bits im MoveMask-Ergebnis.  Der Pseudocode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar. </p><br><p>  Wenn also einige Bytes in va und vb nicht √ºbereinstimmen, sind die entsprechenden Bytes in areEqual 0. Daher sind auch die oberen Bits dieser Bytes 0.  Dies bedeutet, dass die entsprechenden Bits in der Avx2.MoveMask-Antwort ebenfalls 0 sind und areEqual nicht gleich equalsMask ist. </p><br><p>  Schauen wir uns ein Beispiel an, bei dem angenommen wird, dass die Vektorl√§nge 8 Bytes betr√§gt (um weniger zu schreiben): </p><br><ul><li>  Sei va = {100, 10, 20, 30, 100, 40, 50, 100} und vb = {100, 20, 10, 30, 100, 40, 80, 90}. </li><li>  Dann sind areEquals {255, 0, 0, 255, 255, 255, 0, 0}. </li><li>  Die MoveMask-Methode gibt 10011100b zur√ºck, die mit der 11111111b-Maske verglichen werden soll.  Da diese Masken nicht gleich sind, sind auch die Vektoren va und vb nicht gleich. </li></ul><br><h2 id="counting-the-times-an-element-occurs-in-a-collection">  Z√§hlen der H√§ufigkeit, mit der ein Element in einer Sammlung vorkommt. </h2><br><p>  Manchmal m√ºssen Sie die Vorkommen eines bestimmten Elements, z. B. Ganzzahlen, in einer Sammlung z√§hlen.  Wir k√∂nnen diesen Algorithmus auch beschleunigen.  Zum Vergleich schreiben wir verschiedene Methoden, um das Element Item in Array zu durchsuchen. </p><br><p>  Das offensichtlichste: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Naive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Array) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Verwenden von LINQ: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LINQ</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Array.Count(i =&gt; i == Item);</code> </pre> <br><p>  Verwenden von Vektoren aus System.Numerics.Vectors: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Vectors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(Item); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Count; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(array, i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Vector.Equals(v, mask); accResult = Vector.Subtract(accResult, areEqual); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } result += Vector.Dot(accResult, Vector&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.One); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Verwenden von Intrinsics: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsafe</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intrinsics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vectorSize = <span class="hljs-number"><span class="hljs-number">256</span></span> / <span class="hljs-number"><span class="hljs-number">8</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[vectorSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { temp[j] = Item; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mask = Avx2.LoadVector256(temp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accVector = Vector256&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Zero; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = Array; <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = array) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= array.Length - vectorSize; i += vectorSize) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = Avx2.LoadVector256(ptr + i); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = Avx2.CompareEqual(v, mask); accVector = Avx2.Subtract(accVector, areEqual); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; Avx2.Store(temp, accVector); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; vectorSize; j++) { result += temp[j]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; i &lt; array.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array[i] == Item) { result++; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Die Ergebnisse der Ausf√ºhrung des Benchmarks auf meinem Computer: </p><br><div class="scrollable-table"><table><thead><tr><th>  Methode </th><th>  ItemsCount </th><th>  Mittelwert </th><th>  Fehler </th><th>  Stddev </th><th>  Verh√§ltnis </th></tr></thead><tbody><tr><td>  Naiv </td><td>  10 </td><td>  8,844 ns </td><td>  0,0772 ns </td><td>  0,0603 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10 </td><td>  87,456 ns </td><td>  0,9496 ns </td><td>  0,8883 ns </td><td>  9,89 </td></tr><tr><td>  Vektoren </td><td>  10 </td><td>  3,140 ns </td><td>  0,0406 ns </td><td>  0,0380 ns </td><td>  0,36 </td></tr><tr><td>  Intrinsics </td><td>  10 </td><td>  13.813 ns </td><td>  0,0825 ns </td><td>  0,0772 ns </td><td>  1,56 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100 </td><td>  107,310 ns </td><td>  0,6975 ns </td><td>  0,6183 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100 </td><td>  626,285 ns </td><td>  5,7677 ns </td><td>  5,3951 ns </td><td>  5.83 </td></tr><tr><td>  Vektoren </td><td>  100 </td><td>  11.844 ns </td><td>  0,2113 ns </td><td>  0,1873 ns </td><td>  0,11 </td></tr><tr><td>  Intrinsics </td><td>  100 </td><td>  19.616 ns </td><td>  0,1018 ns </td><td>  0,0903 ns </td><td>  0,18 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1000 </td><td>  1.032,466 ns </td><td>  6,3799 ns </td><td>  5,6556 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1000 </td><td>  6,266.605 ns </td><td>  42,6585 ns </td><td>  39,9028 ns </td><td>  6.07 </td></tr><tr><td>  Vektoren </td><td>  1000 </td><td>  83,417 ns </td><td>  0,5393 ns </td><td>  0,4780 ns </td><td>  0,08 </td></tr><tr><td>  Intrinsics </td><td>  1000 </td><td>  88,358 ns </td><td>  0,4921 ns </td><td>  0,4603 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  10.000 </td><td>  9.942,503 ns </td><td>  47,9732 ns </td><td>  40.0598 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  10.000 </td><td>  62.305.598 ns </td><td>  643,8775 ns </td><td>  502,6972 ns </td><td>  6.27 </td></tr><tr><td>  Vektoren </td><td>  10.000 </td><td>  914,967 ns </td><td>  7,2959 ns </td><td>  6,8246 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsics </td><td>  10.000 </td><td>  931.698 ns </td><td>  6,3444 ns </td><td>  5,9346 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  100.000 </td><td>  94.834,804 ns </td><td>  793,8585 ns </td><td>  703,7349 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  100.000 </td><td>  626.620.968 ns </td><td>  4,696.9221 ns </td><td>  4.393,5038 ns </td><td>  6.61 </td></tr><tr><td>  Vektoren </td><td>  100.000 </td><td>  9.000,827 ns </td><td>  179,5351 ns </td><td>  192.1005 ns </td><td>  0,09 </td></tr><tr><td>  Intrinsics </td><td>  100.000 </td><td>  8,690,771 ns </td><td>  101,7078 ns </td><td>  95,1376 ns </td><td>  0,09 </td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  Naiv </td><td>  1.000.000 </td><td>  959,302,249 ns </td><td>  4,268.2488 ns </td><td>  3,783.6914 ns </td><td>  1,00 </td></tr><tr><td>  LINQ </td><td>  1.000.000 </td><td>  6,218,681.888 ns </td><td>  31.321,9277 ns </td><td>  29.298.5506 ns </td><td>  6.48 </td></tr><tr><td>  Vektoren </td><td>  1.000.000 </td><td>  99.778,488 ns </td><td>  1,975.6001 ns </td><td>  4,252.6877 ns </td><td>  0,10 </td></tr><tr><td>  Intrinsics </td><td>  1.000.000 </td><td>  96.449,350 ns </td><td>  1,171.8067 ns </td><td>  978,5116 ns </td><td>  0,10 </td></tr></tbody></table></div><br><p>  Vektoren und Intrinsics-Methoden stimmen in der Logik vollst√§ndig √ºberein, unterscheiden sich jedoch in der Implementierung bestimmter Operationen.  Die Idee ist die folgende: </p><br><ul><li>  Erstellen Sie einen Maskenvektor, in dem in jedem Element eine erforderliche Anzahl gespeichert ist. </li><li>  Laden Sie den Teil eines Arrays in den Vektor v und vergleichen Sie diesen Teil mit einer Maske.  Infolgedessen werden alle Bits in gleiche Elemente von areEqual gesetzt.  Da areEqual ein Array von ganzen Zahlen ist, erhalten wir, wenn wir alle Bits eines Elements setzen, -1 in diesem Element ((int) (1111_1111_1111_1111_1111_1111_1111_1111b) == -1); </li><li>  subtrahieren areEqual Vektor von accVector.  Dann speichert accVector, wie oft das Elementelement in allen Vektoren f√ºr jede Position aufgetreten ist (Minus mal Minus ist ein Plus). </li></ul><br><p>  Der gesamte Code aus dem Artikel ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . </p><br><h2 id="conclusion">  Fazit </h2><br><p>  Ich habe nur einen kleinen Teil der .NET-Funktionen f√ºr die Berechnungsvektorisierung beschrieben.  Um die vollst√§ndige aktualisierte Liste aller in .NET Core unter x86 verf√ºgbaren Intrinsics anzuzeigen, wenden Sie sich an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> .  Es ist praktisch, dass die Zusammenfassung aller in C # -Dateien enthaltenen Elemente ihren Namen in der C-Welt enth√§lt.  Dies hilft entweder, den Zweck dieser Eigenschaft zu verstehen oder vorhandene C ++ / C-Algorithmen auf .NET zu √ºbertragen.  Die Dokumentation zu System.Numerics.Vector ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">msdn</a> verf√ºgbar. </p><br><p>  Ich denke, .NET hat einen gro√üen Vorteil gegen√ºber C ++.  Da die JIT-Kompilierung bereits auf einem Clientcomputer erfolgt, kann ein Compiler den Code f√ºr einen bestimmten Clientprozessor optimieren und so maximale Leistung erzielen.  Gleichzeitig kann ein Programmierer in einer Sprache und denselben Technologien bleiben, um schnellen Code zu schreiben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467689/">https://habr.com/ru/post/de467689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467675/index.html">Modellieren des Anwendungsstatus mithilfe von Store-Objekten in SwiftUI</a></li>
<li><a href="../de467677/index.html">Tests oder Typen</a></li>
<li><a href="../de467679/index.html">PyCrunch - Intelligente Testausf√ºhrung und visuelle Codeabdeckung in der IDE</a></li>
<li><a href="../de467681/index.html">Sicherheitsl√ºcke bei SOAP-Routing-Umwegen</a></li>
<li><a href="../de467683/index.html">Der Versuch, das nicht zusammensetzbare Docking-Schema zusammenzustellen</a></li>
<li><a href="../de467691/index.html">Intel Nervana NNP-T und NNP-I - Spezialchips f√ºr KI</a></li>
<li><a href="../de467693/index.html">September IT Events Digest (Teil 2)</a></li>
<li><a href="../de467697/index.html">Stimmt es, dass GOPATH und GOROOT nicht mehr ben√∂tigt werden?</a></li>
<li><a href="../de467699/index.html">Wie man nicht die schnellste Kraft macht und einen Fehler in der Visual Studio 2019 Community findet</a></li>
<li><a href="../de467701/index.html">Kategorien statt Verzeichnisse. Ein Tool zur bequemen Speicherung von Dateien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>