<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¦ğŸ¼ ğŸ¦’ ğŸ‘¨ğŸ½â€ğŸš€ Utreexo: mengompresi banyak UTXO Bitcoin ğŸš„ ğŸ’² ğŸŒ–</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 


 Dalam jaringan Bitcoin, semua simpul setuju dengan konsensus tentang banyak UTXO: berapa banyak koin yang tersedia untuk dibelanjakan,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utreexo: mengompresi banyak UTXO Bitcoin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456424/"><p><img src="https://habrastorage.org/webt/5_/dt/be/5_dtbegl1errsyauglpuftz1xus.png"></p><br><p>  Halo, Habr! </p><br><p>  Dalam jaringan Bitcoin, semua simpul setuju dengan konsensus tentang banyak UTXO: berapa banyak koin yang tersedia untuk dibelanjakan, kepada siapa, dan dalam kondisi apa.  Himpunan UTXO adalah kumpulan data minimum yang diperlukan untuk simpul validator, yang tanpanya node tidak dapat memverifikasi validitas transaksi yang masuk dan blok yang mengandungnya. </p><br><p>  Dalam hal ini, upaya dilakukan dengan segala cara untuk mengurangi representasi simpanan dari set ini, untuk mengompresnya tanpa kehilangan jaminan keamanan.  Semakin kecil volume data yang disimpan, semakin rendah persyaratan untuk ruang disk dari simpul validator, yang membuat peluncuran simpul validator murah, memungkinkan Anda untuk memperluas jaringan dan dengan demikian meningkatkan stabilitas jaringan. </p><br><p>  Dalam catatan ini, kami akan membahas prototipe Rust dari proposal baru-baru ini dari penulis bersama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lightning Network Paper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utreexo: akumulator berbasis hash dinamis yang dioptimalkan untuk set Bitcoin UTXO</a> , yang mengurangi kebutuhan ruang disk untuk node validator. </p><a name="habracut"></a><br><h2 id="v-chyom-problema">  Apa masalahnya? </h2><br><p>  Salah satu masalah abadi Bitcoin adalah skalabilitasnya.  Gagasan "memiliki bank" mengharuskan peserta jaringan untuk melacak semua dana yang tersedia untuk digunakan.  Dalam Bitcoin, dana yang tersedia dinyatakan sebagai satu set keluaran yang tidak digunakan - set UTXO.  Meskipun ini bukan presentasi yang sangat intuitif, ini menguntungkan dalam hal kinerja implementasi, dibandingkan dengan presentasi di mana setiap dompet memiliki "keseimbangan" sebagai entri terpisah, dan juga menambah privasi (misalnya, menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoinJoin</a> ). </p><br><p>  Penting untuk membedakan antara riwayat transaksi (apa yang disebut blockchain) dan kondisi sistem saat ini.  Sejarah transaksi Bitcoin saat ini menempati sekitar 200 GB ruang disk, dan terus bertambah.  Namun, keadaan sistem jauh lebih kecil, sekitar 4 GB, dan hanya memperhitungkan fakta bahwa seseorang saat ini memiliki koin.  Volume data ini juga meningkat seiring waktu, tetapi pada tingkat yang jauh lebih rendah dan kadang-kadang bahkan cenderung menurun (lihat KDPV). </p><br><p>  Klien keamanan pertukaran cahaya (SPVs) menukar kemampuan untuk tidak menyimpan status minimum (set-UTXO), kecuali untuk kunci pribadi. </p><br><h2 id="utxo-i-utxo-set">  UTXO dan UTXO-set </h2><br><p>  UTXO (Output Transaksi yang Tidak Terpakai) - output transaksi yang tidak terpakai, titik akhir dari perjalanan setiap satoshi yang ditransmisikan dalam transaksi.  Output yang tidak digunakan menjadi input dari transaksi baru dan pada saat yang bersamaan menghabiskan dan dihapus dari UTXO-set. </p><br><p>  UTXO baru selalu dibuat oleh transaksi: </p><br><ul><li>  transaksi coinbase tanpa input: buat UTXO baru selama penerbitan koin oleh penambang </li><li>  transaksi konvensional: buat UTXO baru, sambil menghabiskan sejumlah UTXO yang ada </li></ul><br><p>  Proses bekerja dengan UTXO: <br><img src="https://habrastorage.org/webt/rw/ey/fh/rweyfhzcoy-cgcigbrlfv0qbypi.gif"></p><br><p>  Dompet mempertimbangkan jumlah koin yang tersedia untuk pengeluaran (saldo) berdasarkan jumlah UTXO yang tersedia untuk dompet ini untuk dibelanjakan. </p><br><p>  Setiap simpul validator, untuk mencegah upaya pengeluaran ganda, harus melacak pengumpulan <strong>semua</strong> UTXO selama verifikasi <strong>setiap</strong> transaksi dari <strong>setiap</strong> blok. </p><br><p>  Node harus memiliki logika: </p><br><ul><li>  Tambahan untuk UTXO-set </li><li>  Set penghapusan UTXO </li><li>  Memeriksa keberadaan UTXO tunggal di set </li></ul><br><p>  Ada cara untuk mengurangi persyaratan untuk informasi yang tersimpan tentang perangkat, sementara tetap mempertahankan kemampuan untuk menambah dan menghapus elemen, memeriksa dan membuktikan keberadaan elemen dalam perangkat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baterai kriptografi</a> . </p><br><h2 id="akkumulyatory-dlya-utxo">  Baterai untuk UTXO </h2><br><p>  Gagasan menggunakan baterai untuk menyimpan banyak UTXO telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibahas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> . </p><br><p>  UTXO-set dibangun dengan cepat, selama pemuatan awal rantai blok (IBD, pengunduhan blok awal), disimpan secara penuh dan terus-menerus, sementara isinya berubah setelah memproses transaksi dari setiap blok jaringan yang baru dan benar.  Proses ini memerlukan mengunduh sekitar 200 GB blok data dan memverifikasi ratusan juta tanda tangan digital.  Setelah proses IBD selesai, residu kering yang diatur UTXO akan menempati sekitar 4 GB. </p><br><p>  Namun, ketika menggunakan baterai, aturan konsensus mengenai dana turun untuk memeriksa dan menghasilkan bukti kriptografi, dan beban melacak dana yang tersedia ditempatkan di pundak pemilik dana ini, yang memberikan bukti keberadaan dan kepemilikannya. </p><br><p>  Baterai dapat disebut representasi ringkas dari perangkat.  Ukuran tampilan yang disimpan, dalam hal ini, harus konstan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.66ex" viewBox="0 -832 2043 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-31" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-29" x="1653" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (1) </script>  , atau menambah secara sublinear relatif terhadap kekuatan himpunan dan ukuran elemen itu sendiri, misalnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.724ex" height="2.66ex" viewBox="0 -832 4186.5 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-6C" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-6F" x="1451" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-67" x="1937" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-28" x="2417" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-6E" x="2807" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-29" x="3407" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-29" x="3797" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-2"> O (log (n)) </script>  di mana n adalah kekuatan set yang disimpan. </p><br><p>  Dalam hal ini, akumulator harus memungkinkan menghasilkan bukti dari dimasukkannya elemen dalam set (bukti inklusi) dan memungkinkannya untuk memverifikasi bukti ini secara efektif. </p><br><p>  Baterai disebut <strong>dinamis</strong> jika memungkinkan Anda untuk menambah item dan menghapus item dari set. </p><br><p>  Contoh dari baterai tersebut adalah baterai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RSA yang diusulkan oleh Boneh, Bunz, Fisch pada bulan Desember 2018</a> .  Baterai seperti itu memiliki ukuran konstan dari tampilan yang disimpan, tetapi membutuhkan <em>rahasia bersama</em> (pengaturan tepercaya).  Persyaratan ini meniadakan penerapan akumulator tersebut untuk jaringan yang tidak dapat dipercaya seperti Bitcoin, karena kebocoran data selama pembuatan rahasia dapat memungkinkan penyerang untuk membuat bukti palsu tentang keberadaan UTXO dengan menipu node dengan set UTXO yang didasarkan pada akumulator tersebut. </p><br><h3 id="utreexo">  Utreexo </h3><br><p>  Desain Thaddeus Dryja yang diusulkan oleh Utreexo memungkinkan Anda untuk membuat baterai yang <strong>dinamis</strong> <strong>tanpa</strong> pengaturan yang tepercaya. </p><br><p>  Utreexo adalah hutan biner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Merkle Trees yang</a> ideal dan merupakan pengembangan dari ide-ide yang disajikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akumulator Asinkron efisien untuk pki terdistribusi</a> , menambahkan kemampuan untuk menghapus elemen dari set. </p><br><h4 id="logicheskaya-struktura-akkumulyatora">  Struktur logis baterai </h4><br><p>  Sel baterai diatur dalam hutan pohon biner yang sempurna.  Pohon dipesan berdasarkan tinggi.  Presentasi ini dipilih sebagai yang paling visual dan memungkinkan Anda untuk memvisualisasikan penggabungan pohon selama operasi pada baterai. </p><br><p>  Penulis mencatat bahwa karena semua pohon di hutan sempurna, ketinggiannya dinyatakan oleh kekuatan dua, sama seperti nomor alami dapat direpresentasikan sebagai jumlah dari kekuatan dua.  Dengan demikian, setiap set sheet dapat dikelompokkan dalam bentuk pohon biner, dan dalam semua kasus, menambahkan elemen baru <em>hanya</em> membutuhkan pengetahuan <em>tentang simpul akar dari pohon yang disimpan</em> . </p><br><p>  Dengan demikian, tampilan tersimpan baterai Utreexo adalah daftar simpul akar (akar Merkle), <em>dan bukan seluruh hutan pohon</em> . </p><br><p> Bayangkan daftar elemen root sebagai <code>Vec&lt;Option&lt;Hash&gt;&gt;</code> .  Jenis <code>Option&lt;Hash&gt;</code> opsional <code>Option&lt;Hash&gt;</code> menunjukkan bahwa elemen root mungkin hilang, yang berarti bahwa pohon tidak memiliki pohon dengan ketinggian yang sesuai. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// SHA-256  #[derive(Copy, Clone, Hash, Eq, PartialEq)] pub struct Hash(pub [u8; 32]); #[derive(Debug, Clone)] pub struct Utreexo { pub roots: Vec&lt;Option&lt;Hash&gt;&gt;, } impl Utreexo { pub fn new(capacity: usize) -&gt; Self { Utreexo { roots: vec![None; capacity], } } }</span></span></code> </pre> <br><h4 id="dobavlenie-elementov">  Menambahkan Item </h4><br><p>  Pertama, kami menggambarkan fungsi <code>parent()</code> , yang mengenali node induk untuk dua elemen yang diberikan. </p><br><div class="spoiler">  <b class="spoiler_title">Fungsi induk ()</b> <div class="spoiler_text"><p>  Karena kita menggunakan pohon Merkle, induk dari masing-masing dua node adalah satu node yang menyimpan hash gabungan dari hash dari node turunan: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span></span>(bytes: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> sha = Sha256::new(); sha.input(bytes); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = sha.result(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> res_bytes = [<span class="hljs-number"><span class="hljs-number">0u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]; res_bytes.copy_from_slice(res.as_slice()); Hash(res_bytes) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parent</span></span></span></span>(left: &amp;Hash, right: &amp;Hash) -&gt; Hash { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> concat = left .<span class="hljs-number"><span class="hljs-number">0</span></span> .into_iter() .chain(right.<span class="hljs-number"><span class="hljs-number">0</span></span>.into_iter()) .map(|b| *b) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt;&gt;(); hash(&amp;concat[..]) }</code> </pre> <br><p>  Penulis mencatat bahwa untuk mencegah serangan yang dijelaskan oleh Charles Bouillaguet, Pierre-Alain Fouque, Adi Shamir, dan Sebastien Zimmer dalam <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Serangan preimage kedua pada fungsi hash yang terkutuk</a> , selain dua hash, Anda harus menambahkan tinggi di dalam pohon ke dalam rangkaian. </p></div></div><br><p>  Saat menambahkan item ke baterai, Anda harus melacak item root mana yang sedang diubah.  Mengikuti jalur untuk mengubah elemen root untuk setiap elemen yang ditambahkan, Anda kemudian dapat membuat bukti keberadaan elemen-elemen ini. </p><br><div class="spoiler">  <b class="spoiler_title">Lacak perubahan saat mengunggah</b> <div class="spoiler_text"><p>  Untuk melacak perubahan yang dilakukan, kami akan mendeklarasikan struktur <code>Update</code> , yang akan menyimpan data tentang perubahan pada node. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> utreexo: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Utreexo, <span class="hljs-comment"><span class="hljs-comment">// ProofStep  ""     pub updated: HashMap&lt;Hash, ProofStep&gt;, }</span></span></code> </pre> </div></div><br><p>  Untuk menambahkan elemen ke baterai, Anda perlu: </p><br><ul><li>  Buat array keranjang elemen root <code>new_roots</code> dan tempatkan elemen root yang ada di sana, satu untuk setiap keranjang: </li></ul><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> new_roots = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.iter() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::&lt;Hash&gt;::new(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(hash) = root { vec.push(*hash); } new_roots.push(vec); }</code> </pre> </div></div><br><ul><li>  Tambahkan elemen yang ditambahkan (array <code>insertions</code> ) ke keranjang pertama <code>new_roots[0]</code> : </li></ul><br><p><img src="https://habrastorage.org/webt/8f/ne/jg/8fnejgnqbngrgygwreduomorpni.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="rust hljs">new_roots[<span class="hljs-number"><span class="hljs-number">0</span></span>].extend_from_slice(insertions);</code> </pre> </div></div><br><ul><li>  Lakukan "penggabungan" item yang ditambahkan ke keranjang pertama dengan yang lain: <br><ul><li>  Untuk semua keranjang dengan lebih dari satu item: <br><ol><li>  Kami mengambil dua elemen dari akhir keranjang, menghitung induknya, menghapus kedua elemen </li><li>  Tambahkan induk terhitung ke keranjang berikutnya. </li></ol></li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/df/dl/fm/dfdlfm0iw0tvwxtlomxmrml1ijc.gif"></p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> new_roots[i].len() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-comment"><span class="hljs-comment">//         let a = new_roots[i][new_roots[i].len() - 2]; let b = new_roots[i][new_roots[i].len() - 1]; new_roots[i].pop(); new_roots[i].pop(); let hash = self.parent(&amp;a, &amp;b); //      if new_roots.len() &lt;= i + 1 { new_roots.push(vec![]); } //      new_roots[i + 1].push(hash); //    ; //        updated.insert(a, ProofStep { hash: b, is_left: false }); updated.insert(b, ProofStep {hash: a, is_left: true }); } }</span></span></code> </pre> </div></div><br><ul><li>  Pindahkan elemen root dari keranjang ke array baterai yang dihasilkan </li></ul><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, bucket) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_roots.into_iter().enumerate() { <span class="hljs-comment"><span class="hljs-comment">//     if self.roots.len() &lt;= i { self.roots.push(None); } if bucket.is_empty() { self.roots[i] = None; } else { self.roots[i] = Some(bucket[0]); } }</span></span></code> </pre> </div></div><br><h4 id="sozdanie-dokazatelstva-dlya-dobavlennyh-elementov">  Membuat bukti untuk item yang ditambahkan </h4><br><p>  Bukti dimasukkannya elemen dalam baterai ( <code>Proof</code> ) akan menjadi Merkle Path, yang terdiri dari rantai <code>ProofStep</code> .  Jika jalan itu tidak menuju ke mana-mana, maka buktinya salah. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///         . #[derive(Debug, Copy, Clone)] pub struct ProofStep { pub hash: Hash, pub is_left: bool, } ///   .       . #[derive(Debug, Clone)] pub struct Proof { pub steps: Vec&lt;ProofStep&gt;, pub leaf: Hash, }</span></span></code> </pre> <br><p>  Menggunakan informasi yang diperoleh sebelumnya selama penambahan elemen (Struktur <code>Update</code> ), Anda dapat membuat bukti bahwa elemen telah ditambahkan ke baterai.  Untuk melakukan ini, kita berkeliling tabel perubahan yang dibuat dan menambahkan setiap langkah ke jalur Merkle, yang selanjutnya akan berfungsi sebagai bukti: </p><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Update&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prove</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, leaf: &amp;Hash) -&gt; Proof { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> proof = Proof { steps: <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[], leaf: *leaf, }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> item = *leaf; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(s) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updated.get(&amp;item) { proof.steps.push(*s); item = parent(&amp;item, &amp;s); } proof } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Proses bukti</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/8i/2h/gy/8i2hgyqkn8syqa0wdsybg3o9asm.gif"></p></div></div><br><h4 id="proverka-dokazatelstva-dlya-elementa">  Bukti bukti untuk suatu barang </h4><br><p>  Memeriksa bukti dimasukkannya elemen (bukti inklusi) dikurangi untuk mengikuti jalur Merkle, sampai mengarah ke elemen root yang ada: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verify</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = proof.steps.len(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> expected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots[n]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(expected) = expected { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> current_parent = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> proof.steps.iter() { current_parent = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.is_left { parent(&amp;s.hash, &amp;current_parent) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { parent(&amp;current_parent, &amp;s.hash) }; } current_parent == expected } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><p>  Jelas: </p><br><div class="spoiler">  <b class="spoiler_title">Proses Verifikasi Bukti untuk A</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sx/49/dz/sx49dzfpgnzqv-x6-hl1fxgey1a.gif"></p></div></div><br><h4 id="udalenie-elementov">  Hapus item </h4><br><p>  Untuk menghapus elemen dari baterai, Anda harus memberikan bukti yang valid bahwa elemen itu ada di sana.  Dengan menggunakan data dari buktinya, kita dapat menghitung elemen-elemen root baru dari baterai yang buktinya tidak lagi benar. </p><br><p>  Algoritma adalah sebagai berikut: </p><br><ol><li>  Seperti halnya penambahan, kami mengatur satu set keranjang kosong yang sesuai dengan pohon Merkle dengan ketinggian sama dengan dua indeks keranjang </li><li>  Masukkan item dari langkah-langkah lintasan Merkle ke dalam keranjang  indeks keranjang sama dengan nomor langkah saat ini </li><li>  Kami menghapus elemen root yang path dari bukti mengarah. </li><li>  Seperti halnya penambahan, kami menghitung elemen root baru, menggabungkan elemen dari keranjang berpasangan dan memindahkan hasil gabungan ke keranjang berikutnya </li></ol><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, proof: &amp;Proof, new_roots: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Hash&gt;&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;(), ()&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.len() &lt; proof.steps.len() || <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.roots.get(proof.steps.len()).is_none() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">Err</span></span>(()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> height = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> hash = proof.leaf; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> height &lt; new_roots.len() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (index, ok) = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.find_root(&amp;hash, &amp;new_roots[height]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ok { <span class="hljs-comment"><span class="hljs-comment">// Remove hash from new_roots new_roots[height].remove(index); loop { if height &gt;= proof.steps.len() { if !self.roots[height] .and_then(|h| Some(h == hash)) .unwrap_or(false) { return Err(()); } return Ok(()); } s = proof.steps[height]; hash = self.parent(&amp;hash, &amp;s); height += 1; } } } if height &gt;= proof.steps.len() { return Err(()); } while height &gt; new_roots.len() { new_roots.push(vec![]); } s = proof.steps[height]; new_roots[height].push(s.hash); hash = self.parent(&amp;hash, &amp;s); height += 1; } }</span></span></code> </pre> </div></div><br><p>  Proses menghapus item "A": <br><img src="https://habrastorage.org/webt/pi/uf/rb/piufrb9ivxabdm_45vbmohgm5os.gif"></p><br><h2 id="integraciya-v-suschestvuyuschuyu-set">  Integrasi ke dalam jaringan yang ada </h2><br><p>  Menggunakan baterai yang diusulkan, node dapat menolak untuk menggunakan database untuk menyimpan semua UTXO, sambil mempertahankan kemampuan untuk mengubah set UTXO.  Namun, ada masalah dalam bekerja dengan bukti. </p><br><p>  Kami akan memanggil simpul validator yang menggunakan baterai <em>kompak</em> UTXO (compact-state node), dan validator tanpa baterai - <em>penuh</em> (simpul penuh).  Keberadaan dua kelas node menciptakan masalah mengintegrasikan mereka ke dalam satu jaringan, karena node kompak memerlukan bukti keberadaan UTXO, yang dihabiskan dalam transaksi, tetapi node penuh tidak.  Jika semua node jaringan pada saat yang sama dan secara terkoordinasi tidak beralih ke Utreexo, maka node kompak akan tertinggal dan tidak akan dapat bekerja di jaringan Bitcoin. </p><br><p>  Untuk memecahkan masalah mengintegrasikan node kompak ke dalam jaringan, diusulkan untuk memperkenalkan kelas tambahan node - <em>jembatan</em> .  Bridge node adalah node lengkap yang, antara lain, menyimpan baterai Utreexo dan bukti inklusi untuk <strong>semua</strong> UTXO dari set UTXO.  Bridges menghitung hash baru dan memperbarui baterai dan bukti ketika blok baru tiba dengan transaksi.  Mendukung dan memperbarui baterai dan bukti tidak membebankan beban komputasi tambahan pada node tersebut.  Bridges mengorbankan ruang disk: menjaga ketertiban <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.557ex" height="1.937ex" viewBox="0 -728.2 1101 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-6E" x="500" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> 2n </script>  hash dibandingkan dengan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.141ex" height="2.66ex" viewBox="0 -832 2644 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-6C" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-6F" x="298" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-67" x="784" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-28" x="1264" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMATHI-6E" x="1654" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456424/&amp;usg=ALkJrhgWatyMuZlV4W4dSj8OND0LfMrpiQ#MJMAIN-29" x="2254" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-4"> log (n) </script>  hash untuk node kompak, di mana n adalah kekuatan dari set UTXO. </p><br><h3 id="arhitektura-seti">  Arsitektur jaringan </h3><br><p><img src="https://habrastorage.org/webt/fj/at/9t/fjat9tzhyxy_ncflmmzgt8ere_4.gif"></p><br><p>  Jembatan memungkinkan untuk secara bertahap menambahkan node kompak ke jaringan tanpa mengubah perangkat lunak dari node yang ada.  Node penuh berfungsi seperti sebelumnya, mendistribusikan transaksi dan blok di antara mereka sendiri.  Bridge node adalah node lengkap yang juga menyimpan data baterai Utreexo dan satu set bukti inklusi untuk <strong>semua</strong> UTXO saat ini.  Node jembatan tidak mengiklankan dirinya sendiri seperti itu, berpura-pura menjadi simpul penuh untuk semua simpul lengkap dan simpul kompak untuk semua simpul padat.  Meskipun jembatan menghubungkan kedua jaringan bersama-sama, pada kenyataannya, mereka harus terhubung hanya dalam satu arah: dari node lengkap yang ada ke node kompak.  Ini dimungkinkan karena format transaksi tidak perlu diubah, dan bukti untuk UTXO untuk simpul padat dapat dibuang, sehingga simpul padat apa pun dapat mengirim transaksi ke semua peserta jaringan dengan cara yang sama tanpa partisipasi simpul jembatan. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Kami meninjau baterai Utreexo dan mengimplementasikan prototipe di Rust.  Kami memeriksa arsitektur jaringan, yang akan mengintegrasikan node berdasarkan pada baterai.  Keuntungan dari compact catch adalah ukuran data yang disimpan, yang tergantung secara logaritmik pada kekuatan banyak UTXO, yang sangat mengurangi kebutuhan ruang disk dan kinerja penyimpanan untuk node tersebut.  Kerugiannya adalah trafik node tambahan untuk transfer bukti, tetapi teknik agregasi bukti (ketika satu bukti membuktikan keberadaan beberapa elemen) dan caching dapat membantu menjaga lalu lintas dalam batas yang dapat diterima. </p><br><p>  <strong>Referensi</strong> : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utreexo Rust Prototype GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Thaddeus Dryja</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Utreexo: akumulator berbasis hash dinamis yang dioptimalkan untuk set Bitcoin UTXO</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Karya Seni Animasi dari Artikel</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456424/">https://habr.com/ru/post/id456424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456412/index.html">Inovasi kontroversial dari Yandex - masuk ke akun Anda melalui surat</a></li>
<li><a href="../id456414/index.html">Perlindungan terhadap kebakaran di pusat data, atau bagaimana data disimpan</a></li>
<li><a href="../id456416/index.html">Agile for All Book</a></li>
<li><a href="../id456418/index.html">Sejarah Singkat Kecurangan Permainan Video</a></li>
<li><a href="../id456422/index.html">Pengumuman versi baru dari Styled Components v5: Animal Grin</a></li>
<li><a href="../id456426/index.html">BASS - kerangka kerja untuk sintesis otomatis tanda tangan anti-virus</a></li>
<li><a href="../id456428/index.html">Bagaimana menerapkan pendekatan BI untuk analisis data: rekomendasi praktis</a></li>
<li><a href="../id456430/index.html">Masalah abadi utang teknis</a></li>
<li><a href="../id456432/index.html">Minggu Keamanan 25: Evernote kerentanan dan ratusan toko online yang diretas</a></li>
<li><a href="../id456434/index.html">Profesi Masa Depan: "Siapa yang Akan Anda Kerjakan di Mars?"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>