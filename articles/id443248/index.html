<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€âš•ï¸ ğŸ•ºğŸ¿ ğŸ¤¤ Protokol reservasi mulus PRP dan HSR ğŸš ğŸ‘§ğŸ¾ ğŸ™ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam industri, persyaratan LAN menjadi semakin serius ICS mengambil lebih banyak fungsionalitas, dan kehilangan data dapat menyebabkan biaya serius. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protokol reservasi mulus PRP dan HSR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/phoenix_contact/blog/443248/">  Dalam industri, persyaratan LAN menjadi semakin serius  ICS mengambil lebih banyak fungsionalitas, dan kehilangan data dapat menyebabkan biaya serius. <br><br>  Misalnya, di sektor energi, jika data dari transduser pengukur tidak mencapai terminal relai tepat waktu, ini dapat dipenuhi dengan penyebaran hubung singkat ke bagian-bagian yang berdekatan dari jaringan catu daya, yang akan menghasilkan kerugian yang jauh lebih serius daripada dalam kasus pemutusan tepat waktu dari bagian dari hubung singkat.  Oleh karena itu, seringkali dalam proyek energi Anda dapat memenuhi persyaratan "Waktu pemulihan kurang dari 1 ms." <br><a name="habracut"></a><br>  Redundansi jaringan berdasarkan protokol industri seperti RSTP, MRP, DLR, dan sejenisnya, didasarkan pada perubahan topologi jika terjadi kerusakan dalam transfer data.  Mengubah topologi membutuhkan waktu tertentu (dari milidetik ke detik, tergantung pada protokol), yang disebut "waktu pemulihan".  Selama waktu ini, tidak ada komunikasi dengan bagian dari jaringan dan, dengan demikian, data hilang.  Yaitu  teknologi redundansi cincin konvensional tidak memungkinkan waktu pemulihan kurang dari 1 ms. <br><br>  Mengingat hal ini, apa yang disebut teknologi redundansi â€œmulusâ€ - PRP dan HSR - semakin populer.  Redundansi berdasarkan PRP dan HSR dilakukan, berbeda dengan protokol di atas, bukan dengan membangun kembali topologi, tetapi dengan menduplikasi bingkai.  Setiap frame digandakan oleh pengirim, dan kedua frame ditransmisikan dengan cara yang berbeda, dan node penerima memproses frame yang masuk pertama dan membuang yang kedua.  Prinsip operasi ini tidak memerlukan restrukturisasi topologi dan, karenanya, protokol ini beroperasi hampir "mulus".  Di bawah potongan Anda akan menemukan detail implementasi protokol ini. <br><br><h4>  Struktur jaringan </h4><br>  Redundansi mulus diimplementasikan pada node akhir, bukan komponen jaringan.  Ini adalah salah satu perbedaan utama antara PRP dan HSR dari protokol cadangan lain seperti RSTP atau MRP.  Pertimbangkan fitur struktur jaringan untuk PRP dan HSR. <br><br><h4>  PRP - struktur jaringan </h4><br>  Node akhir memiliki dua antarmuka Ethernet yang terhubung ke dua jaringan yang diisolasi satu sama lain, yang beroperasi secara paralel dan memiliki topologi independen (mis., Topologi dari dua jaringan ini dapat sama atau berbeda).  Jaringan harus diisolasi agar kerusakan dan penghentian transmisi data dalam satu jaringan tidak memengaruhi yang kedua, mis.  bahkan kekuatan jaringan disuplai dari sumber yang berbeda.  Seharusnya tidak ada koneksi langsung antara jaringan-jaringan ini. <br><br><img src="https://habrastorage.org/webt/rc/19/go/rc19go3yzzhhcc8ej24_7pbxhb4.png"><br><br>  <i>Struktur jaringan PRP</i> <br><br>  Kedua jaringan ini biasanya disebut LAN A dan LAN B. Seperti telah ditunjukkan, mereka dapat memiliki topologi yang berbeda serta kinerja yang berbeda.  Keterlambatan dalam pengiriman data juga dapat bervariasi. <br><br>  Jaringan mungkin mengandung elemen-elemen berikut: <br><br><ul><li>  DAN (Dual Attached Node) - node yang terhubung ke kedua jaringan dan mengirim / menerima frame duplikat. </li><li>  SAN (Single Attached Node) - node yang terhubung hanya ke satu jaringan (LAN A atau LAN B) dan mengirim / menerima frame normal. </li><li>  Dalam hal ketika perlu untuk menghubungkan secara berlebihan perangkat yang memiliki satu antarmuka Ethernet dan tidak mendukung protokol PRP ke jaringan RPR, yang disebut Kotak Redundansi (biasanya RedBox) digunakan.  Pada RedBox, paket dari perangkat digandakan dan dikirim ke jaringan PRP, seolah-olah data ditransmisikan dari DAN.  Selain itu, perangkat di belakang RedBox dipandang sebagai DAN untuk perangkat lain.  Node seperti itu disebut DAN DAN VDAN virtual (Virtual DAN). </li></ul><br><br><img src="https://habrastorage.org/webt/ko/1f/ye/ko1fyehyesxd7zlz5qs-_q2zs_e.png"><br><br>  <i>Prinsip kerja RedBox</i> <br><br><h4>  HSR - struktur jaringan </h4><br><img src="https://habrastorage.org/webt/sd/mi/hd/sdmihdk3aqfpandamwmu3artwf0.png"><br><br>  <i>Struktur jaringan HSR</i> <br><br>  Prinsip operasi HSR adalah bahwa semua perangkat digabungkan menjadi dering dan semua pesan, serta dalam PRP, digandakan.  Perangkat mengirim kedua frame melalui ring: satu salinan searah jarum jam, yang lainnya berlawanan arah jarum jam.  Penerima menerima kedua salinan, tetapi hanya memproses yang pertama, dan menghapus yang kedua.  Jika sesuatu terjadi pada salah satu tautan, dan salah satu frame yang digandakan tidak datang, maka yang lain hanya diterima.  Semua perangkat HSR memiliki dua antarmuka Ethernet - port A dan port B. <br><br>  Menurut protokol HSR, elemen-elemen berikut mungkin ada di jaringan: <br><br><ul><li>  SAN adalah simpul yang hanya memiliki satu antarmuka Ethernet.  Node tersebut dapat dihubungkan ke jaringan HSR secara eksklusif melalui RedBox. </li><li>  DAN - simpul yang dapat bertukar data di dalam cincin HSR (dapat mengirim / menerima bingkai duplikat). </li><li>  RedBox - seperti di PRP, RedBox memungkinkan Anda untuk menghubungkan perangkat yang memiliki satu antarmuka Ethernet ke jaringan HSR.  Perangkat di belakang RedBox dipandang sebagai DAN untuk perangkat lain.  Node seperti itu disebut DAN DAN VDAN virtual (Virtual DAN). </li><li>  QuadBox - HSR juga memperkenalkan satu elemen baru - QuadBox.  Perangkat ini memiliki empat port HSR.  Ini memungkinkan Anda untuk menggabungkan dua cincin HSR.  Di setiap dering, QuadBox bertindak sebagai DAN dan dapat mentransfer data dari satu cincin ke cincin lainnya. </li></ul><br><img src="https://habrastorage.org/webt/we/7n/dc/we7ndcshvu_8oefjqm9ykvrc8a8.png"><br><br>  <i>Contoh QuadBox</i> <br><br><h4>  DAN struktur </h4><br>  Untuk PRP dan HSR, struktur DAN serupa.  Setiap DAN memiliki dua antarmuka yang beroperasi secara paralel dan terhubung ke tingkat atas dari satu tumpukan komunikasi melalui apa yang disebut lapisan LRE - tautan entitas redundansi.  Pada level ini, semua fungsi cadangan dilakukan. <br><br>  Kedua antarmuka DAN memiliki alamat MAC yang sama dan satu alamat IP.  Ini memungkinkan Anda untuk membuat reservasi transparan ke tingkat atas.  Terutama penting adalah kenyataan bahwa ini memungkinkan penggunaan ARP untuk DAN serta untuk simpul yang tidak redundan. <br><br>  Namun, tentu saja, ada nuansa dalam struktur DAN untuk PRP dan untuk HSR. <br><br><h4>  Struktur PRP - DAN </h4><br>  Ketika sebuah frame dikirim dari level atas, LRE menduplikasinya dan mengirimkan kedua paket melalui port-port secara bersamaan.  Kedua frame ditransmisikan secara paralel melalui dua jaringan dengan penundaan yang berbeda.  Dalam situasi yang ideal, mereka dikirim ke node tujuan dengan perbedaan waktu minimum.  Setelah menerima LRE, penerima mengirimkan bingkai yang diterima pertama ke lapisan atas, dan membuang yang kedua. <br><br>  LRE membuat duplikat frame saat mengirim dan memprosesnya setelah diterima.  Tingkat ini, terkait dengan tingkat atas, mewakili antarmuka biasa dari adaptor jaringan yang tidak redundan.  LRE melakukan dua tugas: menangani frame duplikat dan mengelola redundansi.  Untuk menerapkan kontrol, LRE menambahkan trailer kontrol redundansi 32-bit (RCT) ke setiap frame dan menghapusnya ketika frame diterima. <br><br><img src="https://habrastorage.org/webt/7v/tf/p7/7vtfp7drkalyuxwvs7c1fnbdewy.png"><br><br>  <i>Mentransfer data antara dua DANs dalam PRP</i> <br><br><h4>  Struktur HSR - DAN </h4><br>  Bingkai yang dikirim dari lapisan atas diduplikasi oleh layer LRE, dan paket dikirim melalui port A dan port B hampir secara bersamaan.  (1 dan 2 dalam diagram). <br><br>  Setelah menerima bingkai, penerima mentransfernya ke tingkat LRE, dan juga mengarahkannya ke port lain dan meneruskannya lebih jauh di atas ring.  (3, 4). <br><br>  Jika bingkai tiba di pengirim, maka bingkai ini tidak ditransmisikan lebih lanjut, tetapi dihancurkan (5, 6). <br><br>  Kedua frame tiba di level LRE, tetapi yang dikirim lebih cepat ditransfer ke level atas, dan frame yang diduplikasi dibuang. <br><br>  LRE menambahkan tag HSR 48-bit ke setiap frame (mirip dengan menambahkan tag VLAN) dan menghapus tag ini setelah diterima. <br><br><img src="https://habrastorage.org/webt/k9/xl/pj/k9xlpj2jf76juzewex9ocyuze_k.png"><br><br>  <i>Mentransfer Data antara Dua DANs dalam HSR</i> <br><br><h4>  Interoperabilitas antara SAN dan DAN </h4><br>  Dalam PRP, SAN dapat dihubungkan ke jaringan apa pun - LAN A atau LAN B, tetapi simpul semacam itu tidak mendukung fungsi cadangan.  Oleh karena itu, SAN yang terhubung ke satu jaringan tidak dapat berkomunikasi dengan simpul serupa lainnya yang terhubung ke jaringan kedua.  Untuk berinteraksi dengan SAN, DAN menghasilkan bingkai khusus.  Kebutuhan ini disebabkan oleh fakta bahwa SAN dalam bingkai normal dari perangkat redundan harus mengabaikan RCT, yang tidak mungkin, karena SAN tidak dapat membedakan RCT dari blok data IEEE 802.3 reguler.  Pada gilirannya, DAN memahami bahwa ia mengirim frame ke SAN dan tidak menambahkan RCT ke frame.  Ini hanya meneruskan satu frame dari tingkat atas ke antarmuka yang terhubung dengan SAN.  Dengan kata lain, jika DAN tidak dapat menentukan apa yang bertukar data dengan DAN lain, maka itu tidak menambahkan RCT ke bingkai. <br><br>  Dalam HSR, SAN tidak dapat terhubung langsung ke jaringan.  Itu dapat dihubungkan secara eksklusif melalui RedBox. <br><br><h4>  DAN Mode </h4><br>  Ketika bekerja dengan frame duplikat yang diterima pada kedua antarmuka (jika mereka bisa diperbaiki), DAN harus menerima salah satu frame dan membuang yang kedua.  Ada dua metode pemrosesan dalam PRP: <br><br><ul><li>  Duplikat terima adalah metode di mana kedua frame yang masuk diterima dan diarahkan ke tingkat atas. </li><li>  Duplicate discard - metode di mana node penerima membaca informasi dari RCT dari frame yang masuk untuk menentukan frame mana yang akan dibuang. </li></ul><br>  Untuk HSR, pertimbangkan mode U dan X paling populer. <br><br><h4>  Gandakan terima </h4><br>  DAN yang beroperasi dalam mode ini tidak menjatuhkan frame mana pun saat memproses pada lapisan data link. <br><br>  Frame dikirim ke LAN A dan LAN B tanpa RCT.  LRE penerima hanya mengalihkan kedua frame ke tingkat atas, dengan asumsi bahwa transmisi lebih lanjut akan menghancurkan duplikat (IEEE 802.1D dengan jelas menyatakan bahwa protokol tingkat atas harus dapat menangani duplikat frame). <br><br>  Misalnya, TCP dan UDP memiliki tingkat ketahanan yang tinggi untuk menduplikasi bingkai. <br><br>  Metode ini sangat sederhana untuk diterapkan, tetapi memiliki kelemahan serius - tidak memberikan kemampuan kontrol jaringan apa pun, seperti  penerimaan kedua frame tidak dipantau dengan cara apa pun. <br><br><h4>  Buang duplikat di tingkat saluran </h4><br>  Saat menggunakan metode kedua, bidang yang terdiri dari empat oktet ditambahkan ke bingkai - RCT (trailer kontrol redundansi).  Cuplikan ditambahkan pada level LRE ketika frame diterima dari level atas.  RCT terdiri dari parameter berikut: <br><br><ul><li>  Nomor urut 16-bit; </li><li>  Pengenal jaringan 4-bit, 1010 (0xA) untuk LAN A dan 1011 (0xB) untuk LAN B; </li><li>  Ukuran bingkai 12-bit. </li></ul><br>  Karena penambahan trailer RCT ke bingkai, ukurannya lebih besar dari ukuran bingkai maksimum yang ditentukan dalam standar IEEE 802.3-2005.  Untuk mengirimkan data dalam jaringan dengan PRP, peralatan harus dikonfigurasikan untuk mengirimkan data dalam ukuran 1496 oktet.  Karena itu, tidak setiap sakelar cocok untuk digunakan pada LAN A atau LAN B. <br><br><img src="https://habrastorage.org/webt/-c/sa/9z/-csa9zpwutrbhyuemwfexrw6xki.png"><br><br>  <i>Bingkai dengan menambahkan RCT</i> <br><br>  Setiap kali lapisan tautan mengirim bingkai ke alamat tertentu, pengirim meningkatkan nomor urut untuk simpul yang sesuai dan mengirimkan bingkai yang identik melalui kedua antarmuka. <br><br>  Node penerima harus menentukan duplikat berdasarkan informasi dari RCT. <br><br><h4>  Algoritma Metode Buang Duplikat </h4><br>  Penerima mengasumsikan bahwa frame yang dikirim dari sumber apa pun menggunakan protokol PRP dikirim secara berurutan dengan jumlah yang terus meningkat.  Nomor urut yang diharapkan untuk frame berikutnya disimpan dalam variabel ExpectedSeqA dan, karenanya, ExpectedSeqB. <br><br>  Setelah menerima, kebenaran urutan dapat diperiksa dengan membandingkan nilai ExpectedSeqA (ExpectedSeqB) dengan nomor urut frame yang diterima, disimpan dalam variabel currentSeq di RCT.  Jika hasilnya positif, variabel ExpectedSeq diatur ke satu lebih dari currentSeq sehingga dimungkinkan untuk melakukan pemeriksaan yang benar pada baris ini. <br><br><img src="https://habrastorage.org/webt/6q/ty/-p/6qty-pwnzatajmck0f9ciyzu4so.png"><br><br>  <i>Frame Drop Interval (drop window)</i> <br><br>  Untuk kedua antarmuka, ada interval penurunan bingkai dinamis untuk nomor urut berpasangan.  Batas atas interval ini adalah ExpectedSeq (nomor urut yang diharapkan berikutnya pada antarmuka ini), tidak termasuk nilai yang diberikan itu sendiri, dan batas bawah interval ini adalah startSeq (nomor urut terkecil di mana frame duplikat dengan nomor urut ini dibuang). <br><br>  Setelah memeriksa nomor urut, penerima memutuskan untuk membuang bingkai atau tidak.  Asumsikan bahwa LAN A memiliki ukuran interval drop frame yang tidak nol (Gbr. 5).  Frame dari LAN B yang nomornya terletak pada interval ini akan dibuang.  Semua frame lain dari LAN B akan diterima dan dikirim ke tingkat atas. <br><br>  Menjatuhkan bingkai dari LAN B mengurangi ukuran LAN A, karena  setelah menerima bingkai ini, diharapkan tidak ada bingkai dengan angka yang lebih rendah pada antarmuka ini.  Dengan demikian, startSeqA diatur ke satu lebih dari currentSeqB.  Dalam hal ini, ukuran interval drop dari frame LAN B diatur ulang ke 0 (startSeqB = diharapkanSeqB), karena  Jelas, frame LAN B berada "di belakang" LAN LAN dan tidak ada frame dari LAN A yang harus dibuang. <br><br><img src="https://habrastorage.org/webt/px/8a/l5/px8al5_iebz0d8qr-atw4zepiy0.png"><br><br>  <i>Kurangi LAN Interval setelah menjatuhkan bingkai dari LAN B</i> <br><br>  Dalam situasi pada Gambar. 7, ketika beberapa frame dari LAN A datang berturut-turut, tetapi tidak ada yang datang dari LAN B, mereka diterima, karena  currentSeq mereka berada di luar interval membuang frame LAN B dan interval LAN A meningkat satu posisi.  Jika frame dari LAN A terus berdatangan, tetapi tidak ada yang datang dari LAN B, ketika ukuran interval maksimum tercapai, startSeqA juga mulai bertambah satu. <br><br>  Ketika frame yang diterima berada di luar interval discard dari frame LAN lain, maka frame ini disimpan, dan ukuran interval dari interface ini diatur ke 1, yang berarti bahwa hanya frame dari LAN lain dengan nomor urut yang sama yang akan dibuang, sedangkan drop window dari antarmuka lain diatur ke 0, yang berarti tidak ada bingkai yang akan dijatuhkan (Gbr. 7). <br><br><img src="https://habrastorage.org/webt/_r/gy/b2/_rgyb2_tufbtbbi3wfr18yqby6a.png"><br><br>  Bingkai dari LAN B tidak terjatuh <br><br>  Situasi yang paling umum adalah ketika kedua antarmuka disinkronkan dan ukuran kedua interval adalah 0 (Gbr. 8), yang berarti bahwa bingkai antarmuka yang didahulukan akan diterima dan interval antarmuka ini akan ditingkatkan menjadi 1, yang akan memungkinkan frame untuk dijatuhkan dari antarmuka lain dengan nomor urut yang sama. <br><br><img src="https://habrastorage.org/webt/x5/sj/n9/x5sjn9q0lxkcg6xbc6jwgzopvpa.png"><br><br>  <i>LAN yang disinkronkan</i> <br><br>  Karena adanya pengenal LAN di RCT, duplikat frame berbeda satu bit (dan memiliki checksum berbeda).  Penerima memeriksa bahwa frame milik antarmuka (mis., Memeriksa apakah frame dengan pengidentifikasi LAN A telah tiba di antarmuka A).  Penerima tidak akan menjatuhkan bingkai ini, karena  mungkin berisi informasi yang berguna di blok data, tetapi dalam kasus ini counter cntWrongLanA atau cntWrongLanB akan bertambah satu.  Karena kesalahan tersebut bukan hanya satu kali (dicampur oleh LAN A dan LAN B), penghitung akan terus meningkat. <br><br><h4>  Tautkan lalu lintas HSR </h4><br>  Saat mentransfer data dalam jaringan HSR, tag HSR ditambahkan ke setiap bingkai. <br>  Tag HSR terdiri dari parameter berikut: <br><br><ul><li>  16-bit HSR Ethertype </li><li>  Indikator jalur 4-bit </li><li>  Ukuran bingkai 12-bit </li><li>  Nomor urut 16 bit </li></ul><br>  Pengirim memasukkan nomor urut yang sama ke frame duplikat yang dikirim, dan kemudian menambah nomor urut untuk setiap pesan yang dikirim dari simpul ini. <br><br>  Penerima memantau nomor urut semua frame dari setiap sumber dari mana ia menerima data (itu membedakan sumber dengan alamat MAC).  Jika bingkai berasal dari garis yang berbeda dan memiliki sumber dan nomor urut yang sama, maka salah satunya diterima, dan yang kedua dibuang. <br><br>  Untuk mengontrol jaringan, setiap perangkat memelihara tabel semua node dalam jaringan yang darinya ia menerima data.  Ini memungkinkan Anda untuk mendeteksi hilangnya node dan kesalahan di bus. <br><br>  Node mendefinisikan bingkai yang dikirim oleh sumber dan dengan nomor urut. <br><br><img src="https://habrastorage.org/webt/0w/al/xj/0walxjqivh2nvo3ae-dr20d7b7e.png"><br><br>  <i>Bingkai dengan menambahkan tag HSR</i> <br><br>  Node HSR tidak pernah membuang bingkai yang sebelumnya tidak diterima.  Node mendefinisikan hampir semua frame duplikat, tetapi jika ada beberapa dari mereka, itu tidak menghapusnya, yaitu.  bingkai hanya melewati seluruh cincin dan dihancurkan pada pengirim. <br><br>  Dalam standar, algoritma untuk menentukan frame duplikat tidak ditentukan.  Sebagai metode yang mungkin, tabel hash, antrian, dan pelacakan nomor urut dapat digunakan. <br><br><h4>  Mode U </h4><br>  Dalam mode ini, simpul yang menerima bingkai menghancurkan duplikat dan tidak memperbolehkannya untuk menyebar lebih jauh.  Jika frame itu bagaimanapun ditransfer lebih lanjut, maka itu dihancurkan pada node berikut.  Mode ini memungkinkan Anda untuk melepas cincin dari lalu lintas Unicast. <br><br>  Dalam diagram, panah merah menunjukkan paket dengan tag HSR yang dikirim dari port "A" (selanjutnya - frame "A"). <br><br>  Panah hijau menunjukkan paket dengan tag HSR yang dikirim dari port "B" (selanjutnya - frame "B"). <br><br>  Panah kosong menunjukkan lalu lintas yang turun, mis.  bingkai yang akan ditransmisikan selama operasi normal, tetapi dalam mode ini dibuang. <br>  Tanda silang menunjukkan penghapusan lalu lintas dari cincin (dalam hal apa pun). <br><br><img src="https://habrastorage.org/webt/sk/yk/14/skyk14uoacfn9l4y1hcdnvvytwe.png"><br><br><h4>  Mode X </h4><br>  Dalam mode ini, node tidak meneruskan frame lebih lanjut dan membuangnya jika frame tersebut diterima dari arah lain. <br><br>  Misalnya, DAN 1 pada gambar tidak akan meneruskan bingkai "B" lebih lanjut, karena  dia telah menerima frame "A", dan DAN 2 tidak akan mengirimkan frame "A" lebih lanjut, karena  sudah menerima bingkai "B". <br><br>  Jika terjadi kesalahan di suatu tempat dalam algoritma dan frame ditransmisikan lebih lanjut, mereka akan dibuang pada node berikut atau pada node di mana mereka dibuat. <br><br>  Mode X tidak berlaku untuk pesan PTP dan untuk transmisi frame pengawasan. <br><br><img src="https://habrastorage.org/webt/tn/jk/ih/tnjkihj4soziqhacnpxdfh7soeo.png"><br><br><h3>  Kontrol jaringan </h3><br><h4>  PRP </h4><br>  Penerima memeriksa bahwa semua frame tiba secara berurutan dan diterima dengan benar di kedua saluran.  Ini mendukung penghitung kesalahan yang dapat dibaca, misalnya, melalui SNMP. <br><br>  Semua perangkat mendukung tabel simpul yang dengannya mereka bertukar data.  Tabel ini berisi informasi tentang waktu ketika frame terakhir dikirim atau diterima dari node tertentu dan informasi lain mengenai protokol PRP. <br><br>  Pada saat yang sama, tabel ini memungkinkan untuk mendeteksi senyawa yang perlu disinkronkan nomor urut, serta untuk mendeteksi urutan yang rusak dan node yang hilang. <br><br>  Diagnostik didasarkan pada fakta bahwa setiap DAN secara berkala mengirimkan kerangka diagnostik (kerangka pengawasan), yang memungkinkan Anda untuk memeriksa integritas jaringan dan keberadaan node.  Pada saat yang sama, frame ini memungkinkan Anda untuk memeriksa perangkat mana yang bertindak sebagai DAN, menentukan alamat MAC mereka dan dalam mode apa mereka bekerja - menerima duplikat atau membuang duplikat. <br><br><h4>  Hsr </h4><br>  Setiap node secara konstan memeriksa semua tautan. <br><br>  Setiap node secara berkala mengirimkan kerangka diagnostik (ke kedua port) yang berisi informasi tentang keadaan node.  Frame ini diterima oleh semua node, termasuk pengirim.  Ketika pengirim menerima pesan diagnostiknya sendiri, pemeriksaan integritas saluran fisik dilakukan. <br><br>  Interval untuk mengirim kerangka diagnostik relatif besar (beberapa detik), karena  tidak diperlukan untuk menyediakan redundansi, tetapi diperlukan hanya untuk tujuan diagnostik. <br><br>  Semua node dimasukkan ke dalam tabel semua mitra yang ditemukan, dan waktu dicatat ketika node terakhir aktif, serta semua frame dan frame yang hilang yang tidak dikirim secara berurutan. <br><br>  Semua perubahan topologi yang telah terjadi juga dicatat dan semua informasi dapat diperoleh melalui SNMP. <br><br>  HSR dan PRP: Pro dan Kontra <br><br><img src="https://habrastorage.org/webt/90/zj/xf/90zjxfixfn8ixq80tbqdf8s4lem.png"><br><br><h4>  Kesimpulan </h4><br>  Ini bukan untuk mengatakan bahwa satu protokol lebih baik dari yang lain - mereka dirancang sedikit untuk aplikasi yang berbeda.  HSR dan PRP memungkinkan redundansi jaringan yang mulus, tetapi HSR memungkinkan Anda untuk membuat solusi yang lebih hemat biaya.  Tetapi keuntungan seperti itu memerlukan kesulitan, karena  jaringan berbasis HSR sulit untuk diukur dan aplikasi tidak terlalu fleksibel.  Fleksibilitas yang rendah disebabkan oleh topologi yang terbatas (cincin, pasangan cincin), serta kompatibilitas protokol yang buruk dengan teknologi lain.  Oleh karena itu, HSR lebih cocok untuk redundansi sistem kecil dan integrasi ke dalam jaringan besar.  Pencadangan seluruh jaringan berbasis HSR bermasalah.  PRP, pada gilirannya, adalah solusi yang lebih mahal, tetapi memungkinkan Anda untuk mengatur jaringan skala yang cukup besar, yang di masa depan dapat diperluas tanpa masalah, karena<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokol ini memungkinkan untuk mengintegrasikan hampir semua teknologi dengan mudah dan menerapkan topologi yang sangat berbeda. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temukan solusinya</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443248/">https://habr.com/ru/post/id443248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443238/index.html">Bagaimana tidak berubah menjadi capung jika Anda memiliki banyak basis data yang berbeda</a></li>
<li><a href="../id443240/index.html">Memahami Q-learning, masalah "Berjalan di atas batu"</a></li>
<li><a href="../id443242/index.html">Quarkus adalah Jawa subatom supersonik. Tinjauan singkat kerangka kerja</a></li>
<li><a href="../id443244/index.html">Tugas pembekalan. Beanpoisk_1</a></li>
<li><a href="../id443246/index.html">Bagaimana kami menciptakan kembali Askozia IP PBX setelah proyek dijual dan ditutup oleh pengembang</a></li>
<li><a href="../id443250/index.html">Pengumpul Sampah Homemade untuk OpenJDK</a></li>
<li><a href="../id443252/index.html">Bot Ant Modular dengan Memori</a></li>
<li><a href="../id443254/index.html">Triton adalah virus paling mematikan</a></li>
<li><a href="../id443256/index.html">PowerShell, dump dari pengalaman saya</a></li>
<li><a href="../id443258/index.html">Gotify - proyek sumber terbuka untuk mengirimkan pemberitahuan dan mengirim pesan ke server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>