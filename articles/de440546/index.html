<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ΩüèΩ üíª üíò Verteilter Chat auf Node.JS und Redis üéûÔ∏è üë∂üèΩ üë®‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine kleine Frage / Antwort: 


 F√ºr wen ist es? Menschen, die wenig oder keine Erfahrung mit verteilten Systemen haben und daran interessiert sind, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verteilter Chat auf Node.JS und Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="Das Ergebnis ist ein Scherzbild zum Waschen von &quot;Taubenpost&quot;"></p><br><p>  Eine kleine Frage / Antwort: </p><br><p> <em>F√ºr wen ist es?</em>  Menschen, die wenig oder keine Erfahrung mit verteilten Systemen haben und daran interessiert sind, wie sie aufgebaut werden k√∂nnen, welche Muster und L√∂sungen existieren. </p><br><p>  <em>Warum ist das so?</em>  Er selbst interessierte sich f√ºr was und wie.  Ich habe Informationen aus verschiedenen Quellen gesammelt und mich entschlossen, sie in konzentrierter Form zu ver√∂ffentlichen, weil ich selbst einmal gerne eine √§hnliche Arbeit sehen w√ºrde.  Tats√§chlich ist dies eine Textaussage meines pers√∂nlichen Werfens und Denkens.  Es wird sicherlich auch viele Korrekturen in den Kommentaren von sachkundigen Personen geben, und dies ist teilweise der Zweck, all dies in Form eines Artikels zu schreiben. </p><br><h2 id="postanovka-zadachi">  Erkl√§rung des Problems </h2><br><p>  Wie mache ich einen Chat?  Dies sollte eine triviale Aufgabe sein, wahrscheinlich hat jeder zweite Beckender seine eigene ges√§gt, genau wie Spieleentwickler ihre Tetris / Schlangen usw. herstellen. Ich habe diese Aufgabe aufgegriffen, aber um sie interessanter zu machen, sollte sie bereit sein, die Welt zu √ºbernehmen, damit sie Hunderten von Milliarden standhalten kann aktive Benutzer und im Allgemeinen war unglaublich cool.  Die eindeutige Notwendigkeit einer verteilten Architektur ergibt sich daraus, da es unrealistisch ist, √ºber die derzeitige Kapazit√§t zu verf√ºgen, um die gesamte imagin√§re Anzahl von Kunden auf einer Maschine unterzubringen.  Anstatt nur zu sitzen und auf das Erscheinen von Quantencomputern zu warten, begann ich entschlossen, das Thema verteilte Systeme zu studieren. </p><br><p>  Es ist erw√§hnenswert, dass eine schnelle Antwort sehr wichtig ist, die ber√ºchtigte Echtzeit, es ist ein <strong>Chat</strong> !  keine Taubenpostzustellung. </p><br><p>  % <em>zuf√§lliger Witz √ºber russische Post</em> % </p><br><p>  Wir werden Node.JS verwenden, es ist ideal f√ºr das Prototyping.  Nehmen Sie f√ºr Steckdosen Socket.IO.  Schreiben Sie auf TypeScript. </p><br><p>  Und was wollen wir: </p><br><ol><li>  Damit Benutzer sich gegenseitig Nachrichten senden k√∂nnen </li><li>  Wissen, wer online / offline ist </li></ol><br><p>  Wie wollen wir es: </p><a name="habracut"></a><br><h2 id="singl-server">  Einzelner Server </h2><br><p>  Es gibt nichts Besonderes zu sagen, direkt zum Code.  Deklarieren Sie die Nachrichtenschnittstelle: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Auf dem Server: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  Auf dem Client so etwas wie: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Sie k√∂nnen mit dem Online-Status wie folgt arbeiten: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  Und auf dem Kunden: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Hinweis: Der Code wurde nicht ausgef√ºhrt, ich schreibe nur zum Beispiel aus dem Speicher </blockquote><p>  Genau wie bei Brennholz spinnen wir syudy echte Autorisierung, Raumverwaltung (Nachrichtenverlauf, Hinzuf√ºgen / Entfernen von Teilnehmern) und Gewinn. </p><br><p>  ABER!  Aber wir werden den Weltfrieden √ºbernehmen, was bedeutet, dass es nicht an der Zeit ist aufzuh√∂ren, wir bewegen uns schnell weiter: </p><br><h2 id="nodejs-klaster">  Node.JS-Cluster </h2><br><p>  Beispiele f√ºr die Verwendung von Socket.IO auf vielen Knoten finden Sie direkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der offiziellen Website</a> .  Dazu geh√∂rt auch ein nativer Node.JS-Cluster, der mir f√ºr meine Aufgabe nicht zutreffend erschien: Er erm√∂glicht es uns, unsere Anwendung auf der gesamten Maschine zu erweitern, ABER nicht √ºber den Rahmen hinaus, sodass wir ihn definitiv vermissen.  Wir m√ºssen endlich die Grenzen eines St√ºcks Eisen √ºberschreiten! </p><br><h2 id="raspredelyay-i-velosiped">  Verteilen und Fahrrad fahren </h2><br><p>  Wie kann man das machen?  Nat√ºrlich m√ºssen Sie unsere Instanzen irgendwie verbinden, die nicht nur zu Hause im Keller, sondern auch im benachbarten Keller gestartet werden.  Was zuerst in den Sinn kommt: Wir stellen eine Art Zwischenverbindung her, die als Bus zwischen all unseren Knoten dient: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Wenn ein Knoten eine Nachricht an einen anderen senden m√∂chte, sendet er eine Anfrage an Bus und leitet sie bereits an den Ort weiter, an dem sie ben√∂tigt wird. Alles ist einfach.  Unser Netzwerk ist fertig! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... aber es ist nicht so einfach?) </p><br><p>  Mit diesem Ansatz sto√üen wir auf die Leistung dieser Zwischenverbindung, und tats√§chlich m√∂chten wir die erforderlichen Knoten direkt kontaktieren, denn was kann schneller sein als direkte Kommunikation?  Bewegen wir uns also in diese Richtung! </p><br><p>  Was wird zuerst ben√∂tigt?  Legitimieren Sie tats√§chlich eine Instanz zu einer anderen.  Aber wie erf√§hrt der erste von der Existenz des zweiten?  Aber wir wollen eine unendliche Anzahl von ihnen haben, willk√ºrlich erh√∂hen / entfernen!  Wir brauchen einen Master-Server, dessen Adresse bekannterma√üen bekannt ist, jeder stellt eine Verbindung zu ihm her, aufgrund dessen er alle vorhandenen Knoten im Netzwerk kennt und diese Informationen freundlicherweise an alle weitergibt. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  Der Knoten steigt an, teilt dem Master sein Erwachen mit, gibt eine Liste anderer aktiver Knoten an, wir stellen eine Verbindung zu ihnen her und das Netzwerk ist bereit.  Der Meister mag Konsul oder so etwas sein, aber da wir Fahrrad fahren, muss der Meister selbst gemacht sein. </p><br><p>  Gro√üartig, jetzt haben wir unser eigenes Skynet!  Die aktuelle Implementierung des darin enthaltenen Chats ist jedoch nicht mehr geeignet.  Lassen Sie uns tats√§chlich die Anforderungen ausarbeiten: </p><br><ol><li>  Wenn ein Benutzer eine Nachricht sendet, m√ºssen wir wissen, an wen er sie sendet, dh Zugriff auf die Teilnehmer im Raum haben. </li><li>  Wenn wir die Teilnehmer erhalten haben, m√ºssen wir ihnen Nachrichten √ºbermitteln. </li><li>  Wir m√ºssen wissen, welcher Benutzer jetzt online ist. </li><li>  Zur Vereinfachung: Geben Sie den Benutzern die M√∂glichkeit, den Online-Status anderer Benutzer zu abonnieren, damit sie in Echtzeit √ºber deren √Ñnderungen informiert werden </li></ol><br><p>  Besch√§ftigen wir uns mit Benutzern.  Sie k√∂nnen dem Master beispielsweise mitteilen, welcher Knoten mit welchem ‚Äã‚ÄãKnoten verbunden ist.  Die Situation ist wie folgt: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Zwei Benutzer sind mit verschiedenen Knoten verbunden.  Der Master wei√ü das, die Knoten wissen, was der Master wei√ü.  Wenn sich UserB anmeldet, benachrichtigt Node2 den Master, der sich "erinnert", dass UserB mit Node2 verbunden ist.  Wenn UserA eine UserB-Nachricht senden m√∂chte, erhalten Sie das folgende Bild: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  Im Prinzip funktioniert alles, aber ich m√∂chte eine zus√§tzliche Runde in Form einer Befragung des Masters vermeiden. Es w√§re wirtschaftlicher, sofort direkt zum gew√ºnschten Knoten zu gehen, denn darum ging es.  Dies kann geschehen, wenn sie allen mitteilen, mit welchen Benutzern sie verbunden sind, jeder von ihnen zu einem autarken Analogon des Assistenten wird und der Assistent selbst unn√∂tig wird, da die Liste des Verh√§ltnisses "Benutzer =&gt; Knoten" f√ºr alle dupliziert wird.  Zu Beginn eines Knotens reicht es aus, eine Verbindung zu einem bereits laufenden Knoten herzustellen, seine Liste an sich selbst und voila zu ziehen. Au√üerdem ist er kampfbereit. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Als Kompromiss erhalten wir jedoch eine Verdoppelung der Liste, die zwar ein Verh√§ltnis von "Benutzer-ID -&gt; [Host-Verbindungen]" darstellt, sich jedoch bei einer ausreichenden Anzahl von Benutzern als ziemlich gro√ü im Speicher herausstellt.  Und im Allgemeinen, wenn Sie es selbst schneiden - es riecht eindeutig nach Fahrradindustrie.  Je mehr Code, desto mehr potenzielle Fehler.  Vielleicht frieren wir diese Option ein und schauen uns an, was bereits fertig ist: </p><br><h2 id="brokery-soobscheniy">  Nachrichtenbroker </h2><br><p>  Die Entit√§t, die denselben "Bus" implementiert, die oben erw√§hnte "Zwischenverbindung".  Ihre Aufgabe ist es, Nachrichten zu empfangen und zuzustellen.  Wir als Benutzer k√∂nnen sie abonnieren und unsere eigenen senden.  Alles ist einfach. </p><br><p>  Es gibt bew√§hrte RabbitMQ und Kafka: Sie tun genau das, was sie √ºbermitteln - dies ist ihr Zweck, vollgepackt mit allen notwendigen Funktionen f√ºr den Hals.  In ihrer Welt muss eine Nachricht √ºbermittelt werden, egal was passiert. </p><br><p>  Zur gleichen Zeit gibt es Redis und sein Pub / Sub - genau wie die oben genannten Leute, aber mehr Eiche: Es empf√§ngt die Nachricht nur dumm und liefert sie an den Abonnenten, ohne Warteschlangen und andere Gemeinkosten.  Er k√ºmmert sich absolut nicht um die Nachrichten selbst, sie werden verschwinden, wenn der Abonnent h√§ngt - er wird sie wegwerfen und eine neue aufnehmen, als w√ºrden sie einen gl√ºhenden Poker in seine H√§nde werfen, den Sie schneller loswerden m√∂chten.  Auch wenn er pl√∂tzlich f√§llt - alle Nachrichten werden auch mit ihm sinken.  Von einer Liefergarantie ist also keine Rede. </p><br><p>  ... und das brauchen Sie! </p><br><p>  Nun, wirklich, wir unterhalten uns nur.  Keine Art von kritischem Geldservice oder Raumfahrt-Kontrollzentrum, sondern ... nur ein Gespr√§ch.  Das Risiko, dass der bedingte Pete einmal im Jahr nicht eine von tausend Nachrichten erh√§lt - es kann vernachl√§ssigt werden, wenn wir im Gegenzug ein Produktivit√§tswachstum erzielen und damit die Anzahl der Benutzer f√ºr die gleichen Tage in seiner ganzen Pracht abw√§gen.  Dar√ºber hinaus k√∂nnen Sie gleichzeitig einen Nachrichtenverlauf in einem dauerhaften Repository aufbewahren. Dies bedeutet, dass Petya diese verpasste Nachricht weiterhin sieht, indem Sie die Seite / Anwendung neu laden.  Aus diesem Grund konzentrieren wir uns auf Redis Pub / Sub oder besser gesagt: Sehen Sie sich den vorhandenen Adapter f√ºr SocketIO an, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Artikel im B√ºro erw√§hnt wird.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> . </p><br><p>  Was ist das? </p><br><h2 id="redis-adapter">  Redis Adapter </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Mit seiner Hilfe verwandelt sich eine gew√∂hnliche Anwendung mit wenigen Zeilen und einer minimalen Anzahl von Gesten in einen echten verteilten Chat!  Aber wie?  <a href="">Wenn Sie nach innen schauen</a> , stellt sich heraus, dass es nur eine Datei pro halbe hundert Zeilen gibt. </p><br><p>  In dem Fall, wenn wir eine Nachricht ausgeben </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  Es wird in Radieschen geschoben und an alle anderen Instanzen unseres Chats √ºbertragen, die es wiederum bereits lokal an Sockets ausgeben </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  Die Nachricht wird auf alle Knoten verteilt, auch wenn sie an einen bestimmten Benutzer gesendet wird.  Das hei√üt, jeder Knoten akzeptiert alle Nachrichten und versteht bereits, ob er sie ben√∂tigt. </p><br><p>  Au√üerdem ist ein einfacher RPC (Aufruf von Remoteprozeduren) implementiert, mit dem nicht nur Antworten gesendet, sondern auch empfangen werden k√∂nnen.  Sie k√∂nnen beispielsweise Steckdosen fernsteuern, z. B. "Wer befindet sich in dem angegebenen Raum?", "Die Steckdose soll dem Raum beitreten" usw. </p><br><p>  Was kann man damit machen?  Verwenden Sie beispielsweise die Benutzer-ID als Raumnamen (Benutzer-ID == Raum-ID).  Wenn Sie autorisieren, den Socket daran anzuschlie√üen und wenn wir eine Nachricht an den Benutzer senden m√∂chten - nur einen Helm hinein.  Au√üerdem k√∂nnen wir herausfinden, ob der Benutzer online ist, indem wir einfach pr√ºfen, ob sich im angegebenen Raum Steckdosen befinden. </p><br><p>  Im Prinzip k√∂nnen wir hier aufh√∂ren, aber wie immer reicht es uns nicht: </p><br><ol><li>  Flaschenhals in einem einzigen Rettich </li><li>  Redundanz, ich m√∂chte, dass die Knoten nur die Nachrichten empfangen, die sie ben√∂tigen </li></ol><br><p>  Betrachten Sie auf Kosten von Absatz 1 Folgendes: </p><br><h2 id="redis-cluster">  Redis-Cluster </h2><br><p>  Es verbindet mehrere Rettichinstanzen, nach denen sie als Ganzes arbeiten.  Aber wie macht er das?  Ja, so: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... und wir sehen, dass die Nachricht an alle Clustermitglieder dupliziert wird.  Das hei√üt, es ist nicht beabsichtigt, die Produktivit√§t zu steigern, sondern die Zuverl√§ssigkeit zu erh√∂hen, was sicherlich gut und notwendig ist, aber f√ºr unseren Fall hat es keinen Wert und rettet die Situation in keiner Weise mit einem Engpass, und in der Summe ist es noch mehr Verschwendung von Ressourcen. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Ich bin ein Anf√§nger, ich wei√ü nicht viel, manchmal muss ich zum Pitchforking zur√ºckkehren, was wir tun werden.  Nein, lassen wir den Rettich so, dass er √ºberhaupt nicht verrutscht, aber Sie m√ºssen an etwas mit Architektur denken, weil der aktuelle nicht gut ist. </p><br><h2 id="povorot-ne-tuda">  Biegen Sie in die falsche Richtung ab </h2><br><p>  Was brauchen wir  Erh√∂hen Sie den Gesamtdurchsatz.  Versuchen wir zum Beispiel, dumm eine andere Instanz zu erzeugen.  Stellen Sie sich vor, socket.io-redis kann eine Verbindung zu mehreren herstellen. Wenn Sie eine Nachricht senden, wird eine zuf√§llige Nachricht ausgew√§hlt und alles abonniert.  Es stellt sich so heraus: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  Im Allgemeinen ist das Problem gel√∂st, Radieschen sind kein Engpass mehr, Sie k√∂nnen beliebig viele Kopien erzeugen!  Aber sie wurden zu Knoten.  Ja, ja, unsere Chat-Instanzen verarbeiten immer noch ALLE Nachrichten, f√ºr die sie nicht bestimmt waren. </p><br><p>  Sie k√∂nnen umgekehrt: Abonnieren Sie eine zuf√§llige, wodurch die Belastung der Knoten verringert wird, und dr√ºcken Sie alles: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Wir sehen, dass es umgekehrt geworden ist: Die Knoten f√ºhlen sich ruhiger an, aber die Belastung der Rettichinstanz hat zugenommen.  Das ist auch nicht gut.  Sie m√ºssen ein bisschen Fahrrad fahren. </p><br><p>  Um unser System zu pumpen, lassen wir das Paket socket.io-redis in Ruhe, obwohl es cool ist, brauchen wir mehr Freiheit.  Und so verbinden wir den Rettich: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Richten Sie unser Messaging-System ein: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  Im Moment stellt sich heraus, wie in socket.io-redis: Wir h√∂ren alle Nachrichten ab.  Jetzt werden wir es beheben. </p><br><p>  Wir organisieren Abonnements wie folgt: Denken Sie an das Konzept mit "Benutzer-ID == Raum-ID", und wenn der Benutzer angezeigt wird, abonnieren wir den gleichnamigen Kanal im Rettich.  Daher empfangen unsere Knoten nur Nachrichten, die f√ºr sie bestimmt sind, und h√∂ren nicht die "gesamte Sendung" ab. </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Genial, jetzt sind wir sicher, dass Knoten nur Nachrichten empfangen, die f√ºr sie bestimmt sind, mehr nicht!  Es sollte jedoch beachtet werden, dass die Abonnements selbst jetzt viel, viel gr√∂√üer sind, was bedeutet, dass sie den Speicher des Yoy Yoy + mehr Abonnement- / Abmeldevorg√§nge verschlingen, die relativ teuer sind.  Auf jeden Fall gibt uns dies eine gewisse Flexibilit√§t. Sie k√∂nnen sogar in diesem Moment anhalten und alle vorherigen Optionen erneut pr√ºfen, wobei Sie bereits unsere neue Eigenschaft von Knoten in Form selektiverer, keusch empfangender Nachrichten ber√ºcksichtigen.  Beispielsweise k√∂nnen Knoten eine von mehreren Rettichinstanzen abonnieren und beim Dr√ºcken eine Nachricht an alle Instanzen senden: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... aber was auch immer man sagen mag, sie bieten immer noch keine unendliche Erweiterbarkeit mit angemessenem Overhead, Sie m√ºssen andere Optionen hervorbringen.  An einem Punkt kam mir das folgende Schema in den Sinn: Was ist, wenn Rettichinstanzen in Gruppen unterteilt werden, z. B. A und B, jeweils zwei Instanzen.  Beim Abonnieren werden Knoten von einer Instanz aus jeder Gruppe signiert, und beim Push senden sie eine Nachricht an alle Instanzen einer einzelnen zuf√§lligen Gruppe. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  So erhalten wir in Echtzeit eine Betriebsstruktur mit unendlichem Erweiterungspotential. Die Belastung eines einzelnen Knotens h√§ngt zu keinem Zeitpunkt von der Gr√∂√üe des Systems ab, weil: </p><br><ol><li>  Die Gesamtbandbreite wird zwischen Gruppen aufgeteilt, d. H. Mit einer Zunahme der Benutzer / Aktivit√§t vergleichen wir einfach zus√§tzliche Gruppen. </li><li>  Die Benutzerverwaltung (Abonnements) ist innerhalb der Gruppen selbst aufgeteilt, d. H. Wenn Benutzer / Abonnements erh√∂ht werden, erh√∂hen wir einfach die Anzahl der Instanzen innerhalb der Gruppen. </li></ol><br><p>  ... und wie immer gibt es ein "ABER": Je mehr es alles bekommt, desto mehr Ressourcen werden f√ºr den n√§chsten Gewinn ben√∂tigt, es scheint mir ein exorbitanter Kompromiss. </p><br><p>  Wenn Sie dar√ºber nachdenken, sind die oben genannten Stecker im Allgemeinen darauf zur√ºckzuf√ºhren, dass Sie nicht wissen, welcher Benutzer sich auf welchem ‚Äã‚ÄãKnoten befindet.  Wenn wir diese Informationen h√§tten, k√∂nnten wir Nachrichten genau dort pushen, wo sie ben√∂tigt werden, ohne unn√∂tige Doppelarbeit.  Was haben wir die ganze Zeit versucht?  Sie versuchten, das System unendlich skalierbar zu machen, ohne √ºber einen eindeutigen Adressierungsmechanismus zu verf√ºgen, der unweigerlich entweder in eine Sackgasse oder in eine ungerechtfertigte Redundanz geriet.  Sie k√∂nnen beispielsweise den Assistenten aufrufen, der als ‚ÄûAdressbuch‚Äú fungiert: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  √Ñhnliches sagt diesem Kerl: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Um den Standort des Benutzers zu ermitteln, f√ºhren wir eine zus√§tzliche Rundreise durch, die im Prinzip in Ordnung ist, in unserem Fall jedoch nicht.  Es scheint, wir graben in die falsche Richtung, wir brauchen etwas anderes ... </p><br><h2 id="sila-hesha">  Hash St√§rke </h2><br><p>  Es gibt so etwas wie einen Hash.  Es hat einen endlichen Wertebereich.  Sie k√∂nnen es aus beliebigen Daten erhalten.  Aber was ist, wenn Sie diesen Bereich auf Rettichinstanzen aufteilen?  Nun, wir nehmen die Benutzer-ID, erstellen einen Hash und abh√§ngig von dem Bereich, in dem sich herausstellte, dass sie eine bestimmte Instanz abonniert / pusht.  Das hei√üt, wir wissen nicht im Voraus, wo welcher Benutzer existiert, aber nachdem wir ihn erhalten haben, k√∂nnen wir sicher sagen, dass es sich um die n-Instanz inf 100 handelt. Nun das Gleiche, aber mit dem Code: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Jetzt sind wir nicht mehr auf die Anzahl der Instanzen des Wortes im Allgemeinen angewiesen, sondern k√∂nnen ohne Overhead so viel skalieren, wie wir m√∂chten!  Im Ernst, dies ist eine brillante Option, deren einziges Minus die Notwendigkeit ist, das System vollst√§ndig neu zu starten, wenn die Anzahl der Rettichinstanzen aktualisiert wird.  Es gibt so etwas wie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardring und einen Partitionsring</a> , mit denen Sie dies √ºberwinden k√∂nnen, die jedoch in einem Nachrichtensystem nicht anwendbar sind.  Sie k√∂nnen die Logik der Migration von Abonnements zwischen Instanzen erstellen, dies kostet jedoch immer noch einen zus√§tzlichen Code von unverst√§ndlicher Gr√∂√üe. Wie wir wissen, ben√∂tigen wir diesen Code nicht, je mehr Code, desto mehr Fehler.  In unserem Fall sind Ausfallzeiten ein akzeptabler Kompromiss. </p><br><p>  Sie k√∂nnen sich auch RabbitMQ mit seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin</a> ansehen, mit dem wir das Gleiche tun k√∂nnen wie wir und + die Migration von Abonnements erm√∂glicht (wie oben erw√§hnt - es ist an die Funktionalit√§t von Kopf bis Fu√ü gebunden).  Im Prinzip k√∂nnen Sie es nehmen und ruhig schlafen, aber wenn jemand an seiner Abstimmung herumfummelt, um den Modus in Echtzeit zu bringen, bleibt nur eine Funktion mit einem Hash-Ring √ºbrig. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberflutete das Repository auf Github.</a> </p><br><p>  Es implementiert die endg√ºltige Version, zu der wir gekommen sind.  Zus√§tzlich gibt es eine zus√§tzliche Logik f√ºr die Arbeit mit R√§umen (Dialoge). </p><br><p>  Generell bin ich zufrieden und kann abgerundet werden. </p><br><h2 id="itogo">  Insgesamt </h2><br><p>  Sie k√∂nnen alles tun, aber es gibt so etwas wie Ressourcen, und sie sind endlich, also m√ºssen Sie sich winden. </p><br><p>  Wir haben mit v√∂lliger Unkenntnis dar√ºber begonnen, wie verteilte Systeme zu mehr oder weniger greifbaren konkreten Mustern funktionieren k√∂nnen, und das ist gut so. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440546/">https://habr.com/ru/post/de440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440534/index.html">√úbersetzung des politisch korrekten Wortschatzes vom Englischen ins Russische</a></li>
<li><a href="../de440536/index.html">Wie Facebook Project Infer hilft, Fehler in mobilen Anwendungen vor der Bereitstellung zu finden</a></li>
<li><a href="../de440540/index.html">Die Reddit-Kapitalisierung erreichte 3 Milliarden US-Dollar, nachdem 300 Millionen US-Dollar investiert worden waren</a></li>
<li><a href="../de440542/index.html">Vuex - √ºberm√§√üiger Einsatz von Gettern in der Anwendung. Fehler beim Parsen</a></li>
<li><a href="../de440544/index.html">Blazor 0.8.0 experimentelle Version jetzt verf√ºgbar</a></li>
<li><a href="../de440548/index.html">"Sie k√∂nnen Spannungsquellen nicht einfach nehmen und parallelisieren."</a></li>
<li><a href="../de440550/index.html">Das Farbdreieck hat nicht zwei, sondern eine Ecke</a></li>
<li><a href="../de440552/index.html">Schlie√üen Sie Schlie√üungen und injizieren Sie Dependency Injection in JavaScript</a></li>
<li><a href="../de440554/index.html">Bequeme BEM</a></li>
<li><a href="../de440556/index.html">Lernen des Entwurfs von Entit√§tsbeziehungsdiagrammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>