<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤽🏽 💻 💘 Verteilter Chat auf Node.JS und Redis 🎞️ 👶🏽 👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine kleine Frage / Antwort: 


 Für wen ist es? Menschen, die wenig oder keine Erfahrung mit verteilten Systemen haben und daran interessiert sind, w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verteilter Chat auf Node.JS und Redis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440546/"><p><img src="https://cs4.pikabu.ru/post_img/2015/10/04/5/1443945163_2102700146.jpg" alt="Das Ergebnis ist ein Scherzbild zum Waschen von &quot;Taubenpost&quot;"></p><br><p>  Eine kleine Frage / Antwort: </p><br><p> <em>Für wen ist es?</em>  Menschen, die wenig oder keine Erfahrung mit verteilten Systemen haben und daran interessiert sind, wie sie aufgebaut werden können, welche Muster und Lösungen existieren. </p><br><p>  <em>Warum ist das so?</em>  Er selbst interessierte sich für was und wie.  Ich habe Informationen aus verschiedenen Quellen gesammelt und mich entschlossen, sie in konzentrierter Form zu veröffentlichen, weil ich selbst einmal gerne eine ähnliche Arbeit sehen würde.  Tatsächlich ist dies eine Textaussage meines persönlichen Werfens und Denkens.  Es wird sicherlich auch viele Korrekturen in den Kommentaren von sachkundigen Personen geben, und dies ist teilweise der Zweck, all dies in Form eines Artikels zu schreiben. </p><br><h2 id="postanovka-zadachi">  Erklärung des Problems </h2><br><p>  Wie mache ich einen Chat?  Dies sollte eine triviale Aufgabe sein, wahrscheinlich hat jeder zweite Beckender seine eigene gesägt, genau wie Spieleentwickler ihre Tetris / Schlangen usw. herstellen. Ich habe diese Aufgabe aufgegriffen, aber um sie interessanter zu machen, sollte sie bereit sein, die Welt zu übernehmen, damit sie Hunderten von Milliarden standhalten kann aktive Benutzer und im Allgemeinen war unglaublich cool.  Die eindeutige Notwendigkeit einer verteilten Architektur ergibt sich daraus, da es unrealistisch ist, über die derzeitige Kapazität zu verfügen, um die gesamte imaginäre Anzahl von Kunden auf einer Maschine unterzubringen.  Anstatt nur zu sitzen und auf das Erscheinen von Quantencomputern zu warten, begann ich entschlossen, das Thema verteilte Systeme zu studieren. </p><br><p>  Es ist erwähnenswert, dass eine schnelle Antwort sehr wichtig ist, die berüchtigte Echtzeit, es ist ein <strong>Chat</strong> !  keine Taubenpostzustellung. </p><br><p>  % <em>zufälliger Witz über russische Post</em> % </p><br><p>  Wir werden Node.JS verwenden, es ist ideal für das Prototyping.  Nehmen Sie für Steckdosen Socket.IO.  Schreiben Sie auf TypeScript. </p><br><p>  Und was wollen wir: </p><br><ol><li>  Damit Benutzer sich gegenseitig Nachrichten senden können </li><li>  Wissen, wer online / offline ist </li></ol><br><p>  Wie wollen wir es: </p><a name="habracut"></a><br><h2 id="singl-server">  Einzelner Server </h2><br><p>  Es gibt nichts Besonderes zu sagen, direkt zum Code.  Deklarieren Sie die Nachrichtenschnittstelle: </p><br><pre><code class="plaintext hljs">interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Auf dem Server: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //    //         sock.on('message', (data:Message)=&gt; io.to(data.roomId).emit('message', data)) })</code> </pre> <br><p>  Auf dem Client so etwas wie: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const roomId = 'some room' //      sock.on('message', (data:Message)=&gt; console.log(`Message ${data.message} from ${data.roomId}`)) //   sock.emit('join', roomId) //    sock.emit('message', &lt;Message&gt;{roomId: roomId, message: 'Halo!'}) })</code> </pre> <br><p>  Sie können mit dem Online-Status wie folgt arbeiten: </p><br><pre> <code class="plaintext hljs">io.on('connection', sock=&gt;{ //         // ,        - //      sock.on('auth', (uid:string)=&gt; sock.join(uid)) //,     , //          //   sock.on('isOnline', (uid:string, resp)=&gt; resp(io.sockets.clients(uid).length &gt; 0)) })</code> </pre> <br><p>  Und auf dem Kunden: </p><br><pre> <code class="plaintext hljs">sock.on('connect', ()=&gt; { const uid = 'im uid, rly' //  sock.emit('auth', uid) //     sock.emit('isOnline', uid, (isOnline:boolean)=&gt; console.log(`User online status is ${isOnline}`)) })</code> </pre> <br><blockquote>  Hinweis: Der Code wurde nicht ausgeführt, ich schreibe nur zum Beispiel aus dem Speicher </blockquote><p>  Genau wie bei Brennholz spinnen wir syudy echte Autorisierung, Raumverwaltung (Nachrichtenverlauf, Hinzufügen / Entfernen von Teilnehmern) und Gewinn. </p><br><p>  ABER!  Aber wir werden den Weltfrieden übernehmen, was bedeutet, dass es nicht an der Zeit ist aufzuhören, wir bewegen uns schnell weiter: </p><br><h2 id="nodejs-klaster">  Node.JS-Cluster </h2><br><p>  Beispiele für die Verwendung von Socket.IO auf vielen Knoten finden Sie direkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der offiziellen Website</a> .  Dazu gehört auch ein nativer Node.JS-Cluster, der mir für meine Aufgabe nicht zutreffend erschien: Er ermöglicht es uns, unsere Anwendung auf der gesamten Maschine zu erweitern, ABER nicht über den Rahmen hinaus, sodass wir ihn definitiv vermissen.  Wir müssen endlich die Grenzen eines Stücks Eisen überschreiten! </p><br><h2 id="raspredelyay-i-velosiped">  Verteilen und Fahrrad fahren </h2><br><p>  Wie kann man das machen?  Natürlich müssen Sie unsere Instanzen irgendwie verbinden, die nicht nur zu Hause im Keller, sondern auch im benachbarten Keller gestartet werden.  Was zuerst in den Sinn kommt: Wir stellen eine Art Zwischenverbindung her, die als Bus zwischen all unseren Knoten dient: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140775997.png" alt="1549140775997"></p><br><p>  Wenn ein Knoten eine Nachricht an einen anderen senden möchte, sendet er eine Anfrage an Bus und leitet sie bereits an den Ort weiter, an dem sie benötigt wird. Alles ist einfach.  Unser Netzwerk ist fertig! </p><br><p>  <strong>FIN.</strong> </p><br><p>  ... aber es ist nicht so einfach?) </p><br><p>  Mit diesem Ansatz stoßen wir auf die Leistung dieser Zwischenverbindung, und tatsächlich möchten wir die erforderlichen Knoten direkt kontaktieren, denn was kann schneller sein als direkte Kommunikation?  Bewegen wir uns also in diese Richtung! </p><br><p>  Was wird zuerst benötigt?  Legitimieren Sie tatsächlich eine Instanz zu einer anderen.  Aber wie erfährt der erste von der Existenz des zweiten?  Aber wir wollen eine unendliche Anzahl von ihnen haben, willkürlich erhöhen / entfernen!  Wir brauchen einen Master-Server, dessen Adresse bekanntermaßen bekannt ist, jeder stellt eine Verbindung zu ihm her, aufgrund dessen er alle vorhandenen Knoten im Netzwerk kennt und diese Informationen freundlicherweise an alle weitergibt. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549048945334.png" alt="1549048945334"></p><br><p>  Der Knoten steigt an, teilt dem Master sein Erwachen mit, gibt eine Liste anderer aktiver Knoten an, wir stellen eine Verbindung zu ihnen her und das Netzwerk ist bereit.  Der Meister mag Konsul oder so etwas sein, aber da wir Fahrrad fahren, muss der Meister selbst gemacht sein. </p><br><p>  Großartig, jetzt haben wir unser eigenes Skynet!  Die aktuelle Implementierung des darin enthaltenen Chats ist jedoch nicht mehr geeignet.  Lassen Sie uns tatsächlich die Anforderungen ausarbeiten: </p><br><ol><li>  Wenn ein Benutzer eine Nachricht sendet, müssen wir wissen, an wen er sie sendet, dh Zugriff auf die Teilnehmer im Raum haben. </li><li>  Wenn wir die Teilnehmer erhalten haben, müssen wir ihnen Nachrichten übermitteln. </li><li>  Wir müssen wissen, welcher Benutzer jetzt online ist. </li><li>  Zur Vereinfachung: Geben Sie den Benutzern die Möglichkeit, den Online-Status anderer Benutzer zu abonnieren, damit sie in Echtzeit über deren Änderungen informiert werden </li></ol><br><p>  Beschäftigen wir uns mit Benutzern.  Sie können dem Master beispielsweise mitteilen, welcher Knoten mit welchem ​​Knoten verbunden ist.  Die Situation ist wie folgt: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549237952673.png" alt="1549237952673"></p><br><p>  Zwei Benutzer sind mit verschiedenen Knoten verbunden.  Der Master weiß das, die Knoten wissen, was der Master weiß.  Wenn sich UserB anmeldet, benachrichtigt Node2 den Master, der sich "erinnert", dass UserB mit Node2 verbunden ist.  Wenn UserA eine UserB-Nachricht senden möchte, erhalten Sie das folgende Bild: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549140491881.png" alt="1549140491881"></p><br><p>  Im Prinzip funktioniert alles, aber ich möchte eine zusätzliche Runde in Form einer Befragung des Masters vermeiden. Es wäre wirtschaftlicher, sofort direkt zum gewünschten Knoten zu gehen, denn darum ging es.  Dies kann geschehen, wenn sie allen mitteilen, mit welchen Benutzern sie verbunden sind, jeder von ihnen zu einem autarken Analogon des Assistenten wird und der Assistent selbst unnötig wird, da die Liste des Verhältnisses "Benutzer =&gt; Knoten" für alle dupliziert wird.  Zu Beginn eines Knotens reicht es aus, eine Verbindung zu einem bereits laufenden Knoten herzustellen, seine Liste an sich selbst und voila zu ziehen. Außerdem ist er kampfbereit. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139768940.png" alt="1549139768940"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549139882747.png" alt="1549139882747"></p><br><p>  Als Kompromiss erhalten wir jedoch eine Verdoppelung der Liste, die zwar ein Verhältnis von "Benutzer-ID -&gt; [Host-Verbindungen]" darstellt, sich jedoch bei einer ausreichenden Anzahl von Benutzern als ziemlich groß im Speicher herausstellt.  Und im Allgemeinen, wenn Sie es selbst schneiden - es riecht eindeutig nach Fahrradindustrie.  Je mehr Code, desto mehr potenzielle Fehler.  Vielleicht frieren wir diese Option ein und schauen uns an, was bereits fertig ist: </p><br><h2 id="brokery-soobscheniy">  Nachrichtenbroker </h2><br><p>  Die Entität, die denselben "Bus" implementiert, die oben erwähnte "Zwischenverbindung".  Ihre Aufgabe ist es, Nachrichten zu empfangen und zuzustellen.  Wir als Benutzer können sie abonnieren und unsere eigenen senden.  Alles ist einfach. </p><br><p>  Es gibt bewährte RabbitMQ und Kafka: Sie tun genau das, was sie übermitteln - dies ist ihr Zweck, vollgepackt mit allen notwendigen Funktionen für den Hals.  In ihrer Welt muss eine Nachricht übermittelt werden, egal was passiert. </p><br><p>  Zur gleichen Zeit gibt es Redis und sein Pub / Sub - genau wie die oben genannten Leute, aber mehr Eiche: Es empfängt die Nachricht nur dumm und liefert sie an den Abonnenten, ohne Warteschlangen und andere Gemeinkosten.  Er kümmert sich absolut nicht um die Nachrichten selbst, sie werden verschwinden, wenn der Abonnent hängt - er wird sie wegwerfen und eine neue aufnehmen, als würden sie einen glühenden Poker in seine Hände werfen, den Sie schneller loswerden möchten.  Auch wenn er plötzlich fällt - alle Nachrichten werden auch mit ihm sinken.  Von einer Liefergarantie ist also keine Rede. </p><br><p>  ... und das brauchen Sie! </p><br><p>  Nun, wirklich, wir unterhalten uns nur.  Keine Art von kritischem Geldservice oder Raumfahrt-Kontrollzentrum, sondern ... nur ein Gespräch.  Das Risiko, dass der bedingte Pete einmal im Jahr nicht eine von tausend Nachrichten erhält - es kann vernachlässigt werden, wenn wir im Gegenzug ein Produktivitätswachstum erzielen und damit die Anzahl der Benutzer für die gleichen Tage in seiner ganzen Pracht abwägen.  Darüber hinaus können Sie gleichzeitig einen Nachrichtenverlauf in einem dauerhaften Repository aufbewahren. Dies bedeutet, dass Petya diese verpasste Nachricht weiterhin sieht, indem Sie die Seite / Anwendung neu laden.  Aus diesem Grund konzentrieren wir uns auf Redis Pub / Sub oder besser gesagt: Sehen Sie sich den vorhandenen Adapter für SocketIO an, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Artikel im Büro erwähnt wird.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> . </p><br><p>  Was ist das? </p><br><h2 id="redis-adapter">  Redis Adapter </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/socketio/socket.io-redis</a> </p><br><p>  Mit seiner Hilfe verwandelt sich eine gewöhnliche Anwendung mit wenigen Zeilen und einer minimalen Anzahl von Gesten in einen echten verteilten Chat!  Aber wie?  <a href="">Wenn Sie nach innen schauen</a> , stellt sich heraus, dass es nur eine Datei pro halbe hundert Zeilen gibt. </p><br><p>  In dem Fall, wenn wir eine Nachricht ausgeben </p><br><pre> <code class="plaintext hljs">io.emit("everyone", "hello")</code> </pre> <br><p>  Es wird in Radieschen geschoben und an alle anderen Instanzen unseres Chats übertragen, die es wiederum bereits lokal an Sockets ausgeben </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549232309776.png" alt="1549232309776"></p><br><p>  Die Nachricht wird auf alle Knoten verteilt, auch wenn sie an einen bestimmten Benutzer gesendet wird.  Das heißt, jeder Knoten akzeptiert alle Nachrichten und versteht bereits, ob er sie benötigt. </p><br><p>  Außerdem ist ein einfacher RPC (Aufruf von Remoteprozeduren) implementiert, mit dem nicht nur Antworten gesendet, sondern auch empfangen werden können.  Sie können beispielsweise Steckdosen fernsteuern, z. B. "Wer befindet sich in dem angegebenen Raum?", "Die Steckdose soll dem Raum beitreten" usw. </p><br><p>  Was kann man damit machen?  Verwenden Sie beispielsweise die Benutzer-ID als Raumnamen (Benutzer-ID == Raum-ID).  Wenn Sie autorisieren, den Socket daran anzuschließen und wenn wir eine Nachricht an den Benutzer senden möchten - nur einen Helm hinein.  Außerdem können wir herausfinden, ob der Benutzer online ist, indem wir einfach prüfen, ob sich im angegebenen Raum Steckdosen befinden. </p><br><p>  Im Prinzip können wir hier aufhören, aber wie immer reicht es uns nicht: </p><br><ol><li>  Flaschenhals in einem einzigen Rettich </li><li>  Redundanz, ich möchte, dass die Knoten nur die Nachrichten empfangen, die sie benötigen </li></ol><br><p>  Betrachten Sie auf Kosten von Absatz 1 Folgendes: </p><br><h2 id="redis-cluster">  Redis-Cluster </h2><br><p>  Es verbindet mehrere Rettichinstanzen, nach denen sie als Ganzes arbeiten.  Aber wie macht er das?  Ja, so: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549233023980.png" alt="1549233023980"></p><br><p>  ... und wir sehen, dass die Nachricht an alle Clustermitglieder dupliziert wird.  Das heißt, es ist nicht beabsichtigt, die Produktivität zu steigern, sondern die Zuverlässigkeit zu erhöhen, was sicherlich gut und notwendig ist, aber für unseren Fall hat es keinen Wert und rettet die Situation in keiner Weise mit einem Engpass, und in der Summe ist es noch mehr Verschwendung von Ressourcen. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549231953897.png" alt="1549231953897"></p><br><p>  Ich bin ein Anfänger, ich weiß nicht viel, manchmal muss ich zum Pitchforking zurückkehren, was wir tun werden.  Nein, lassen wir den Rettich so, dass er überhaupt nicht verrutscht, aber Sie müssen an etwas mit Architektur denken, weil der aktuelle nicht gut ist. </p><br><h2 id="povorot-ne-tuda">  Biegen Sie in die falsche Richtung ab </h2><br><p>  Was brauchen wir  Erhöhen Sie den Gesamtdurchsatz.  Versuchen wir zum Beispiel, dumm eine andere Instanz zu erzeugen.  Stellen Sie sich vor, socket.io-redis kann eine Verbindung zu mehreren herstellen. Wenn Sie eine Nachricht senden, wird eine zufällige Nachricht ausgewählt und alles abonniert.  Es stellt sich so heraus: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239818663.png" alt="1549239818663"></p><br><p>  Voila!  Im Allgemeinen ist das Problem gelöst, Radieschen sind kein Engpass mehr, Sie können beliebig viele Kopien erzeugen!  Aber sie wurden zu Knoten.  Ja, ja, unsere Chat-Instanzen verarbeiten immer noch ALLE Nachrichten, für die sie nicht bestimmt waren. </p><br><p>  Sie können umgekehrt: Abonnieren Sie eine zufällige, wodurch die Belastung der Knoten verringert wird, und drücken Sie alles: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1549239361416.png" alt="1549239361416"></p><br><p>  Wir sehen, dass es umgekehrt geworden ist: Die Knoten fühlen sich ruhiger an, aber die Belastung der Rettichinstanz hat zugenommen.  Das ist auch nicht gut.  Sie müssen ein bisschen Fahrrad fahren. </p><br><p>  Um unser System zu pumpen, lassen wir das Paket socket.io-redis in Ruhe, obwohl es cool ist, brauchen wir mehr Freiheit.  Und so verbinden wir den Rettich: </p><br><pre> <code class="plaintext hljs">//  : const pub = new RedisClient({host: 'localhost', port: 6379})//  const sub = new RedisClient({host: 'localhost', port: 6379})//   //    interface Message{ roomId: string,//    message: string,//    }</code> </pre> <br><p>  Richten Sie unser Messaging-System ein: </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, dataRaw:string)=&gt; { const data = &lt;Message&gt;JSON.parse(dataRaw) io.to(data.roomId).emit('message', data)) }) //   sub.subscribe("messagesChannel") //    sock.on('join', (roomId:number)=&gt; sock.join(roomId)) //   sock.on('message', (data:Message)=&gt; { //   pub.publish("messagesChannel", JSON.stringify(data)) })</code> </pre> <br><p>  Im Moment stellt sich heraus, wie in socket.io-redis: Wir hören alle Nachrichten ab.  Jetzt werden wir es beheben. </p><br><p>  Wir organisieren Abonnements wie folgt: Denken Sie an das Konzept mit "Benutzer-ID == Raum-ID", und wenn der Benutzer angezeigt wird, abonnieren wir den gleichnamigen Kanal im Rettich.  Daher empfangen unsere Knoten nur Nachrichten, die für sie bestimmt sind, und hören nicht die "gesamte Sendung" ab. </p><br><pre> <code class="plaintext hljs">//     sub.on('message', (channel:string, message:string)=&gt; { io.to(channel).emit('message', message)) }) let UID:string|null = null; sock.on('auth', (uid:string)=&gt; { UID = uid //   -   //  UID  sub.subscribe(UID) //   sock.join(UID) }) sock.on('writeYourself', (message:string)=&gt; { //  ,        UID if (UID) pub.publish(UID, message) })</code> </pre> <br><p>  Genial, jetzt sind wir sicher, dass Knoten nur Nachrichten empfangen, die für sie bestimmt sind, mehr nicht!  Es sollte jedoch beachtet werden, dass die Abonnements selbst jetzt viel, viel größer sind, was bedeutet, dass sie den Speicher des Yoy Yoy + mehr Abonnement- / Abmeldevorgänge verschlingen, die relativ teuer sind.  Auf jeden Fall gibt uns dies eine gewisse Flexibilität. Sie können sogar in diesem Moment anhalten und alle vorherigen Optionen erneut prüfen, wobei Sie bereits unsere neue Eigenschaft von Knoten in Form selektiverer, keusch empfangender Nachrichten berücksichtigen.  Beispielsweise können Knoten eine von mehreren Rettichinstanzen abonnieren und beim Drücken eine Nachricht an alle Instanzen senden: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174595491.png" alt="1550174595491"></p><br><p>  ... aber was auch immer man sagen mag, sie bieten immer noch keine unendliche Erweiterbarkeit mit angemessenem Overhead, Sie müssen andere Optionen hervorbringen.  An einem Punkt kam mir das folgende Schema in den Sinn: Was ist, wenn Rettichinstanzen in Gruppen unterteilt werden, z. B. A und B, jeweils zwei Instanzen.  Beim Abonnieren werden Knoten von einer Instanz aus jeder Gruppe signiert, und beim Push senden sie eine Nachricht an alle Instanzen einer einzelnen zufälligen Gruppe. </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174092066.png" alt="1550174092066"></p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550174943313.png" alt="1550174943313"></p><br><p>  So erhalten wir in Echtzeit eine Betriebsstruktur mit unendlichem Erweiterungspotential. Die Belastung eines einzelnen Knotens hängt zu keinem Zeitpunkt von der Größe des Systems ab, weil: </p><br><ol><li>  Die Gesamtbandbreite wird zwischen Gruppen aufgeteilt, d. H. Mit einer Zunahme der Benutzer / Aktivität vergleichen wir einfach zusätzliche Gruppen. </li><li>  Die Benutzerverwaltung (Abonnements) ist innerhalb der Gruppen selbst aufgeteilt, d. H. Wenn Benutzer / Abonnements erhöht werden, erhöhen wir einfach die Anzahl der Instanzen innerhalb der Gruppen. </li></ol><br><p>  ... und wie immer gibt es ein "ABER": Je mehr es alles bekommt, desto mehr Ressourcen werden für den nächsten Gewinn benötigt, es scheint mir ein exorbitanter Kompromiss. </p><br><p>  Wenn Sie darüber nachdenken, sind die oben genannten Stecker im Allgemeinen darauf zurückzuführen, dass Sie nicht wissen, welcher Benutzer sich auf welchem ​​Knoten befindet.  Wenn wir diese Informationen hätten, könnten wir Nachrichten genau dort pushen, wo sie benötigt werden, ohne unnötige Doppelarbeit.  Was haben wir die ganze Zeit versucht?  Sie versuchten, das System unendlich skalierbar zu machen, ohne über einen eindeutigen Adressierungsmechanismus zu verfügen, der unweigerlich entweder in eine Sackgasse oder in eine ungerechtfertigte Redundanz geriet.  Sie können beispielsweise den Assistenten aufrufen, der als „Adressbuch“ fungiert: </p><br><p><img src="https://raw.githubusercontent.com/Alster/distributed-nodejs-chat-with-redis/master/article/images/1550233610561.png" alt="1550233610561"></p><br><blockquote>  Ähnliches sagt diesem Kerl: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6G22a5Iooqk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></blockquote><p>  Um den Standort des Benutzers zu ermitteln, führen wir eine zusätzliche Rundreise durch, die im Prinzip in Ordnung ist, in unserem Fall jedoch nicht.  Es scheint, wir graben in die falsche Richtung, wir brauchen etwas anderes ... </p><br><h2 id="sila-hesha">  Hash Stärke </h2><br><p>  Es gibt so etwas wie einen Hash.  Es hat einen endlichen Wertebereich.  Sie können es aus beliebigen Daten erhalten.  Aber was ist, wenn Sie diesen Bereich auf Rettichinstanzen aufteilen?  Nun, wir nehmen die Benutzer-ID, erstellen einen Hash und abhängig von dem Bereich, in dem sich herausstellte, dass sie eine bestimmte Instanz abonniert / pusht.  Das heißt, wir wissen nicht im Voraus, wo welcher Benutzer existiert, aber nachdem wir ihn erhalten haben, können wir sicher sagen, dass es sich um die n-Instanz inf 100 handelt. Nun das Gleiche, aber mit dem Code: </p><br><pre> <code class="plaintext hljs">function hash(val:string):number{/**/}// -,   const clients:RedisClient[] = []//   const uid = "some uid"//  //,            //      const selectedClient = clients[hash(uid) % clients.length]</code> </pre> <br><p>  Voila!  Jetzt sind wir nicht mehr auf die Anzahl der Instanzen des Wortes im Allgemeinen angewiesen, sondern können ohne Overhead so viel skalieren, wie wir möchten!  Im Ernst, dies ist eine brillante Option, deren einziges Minus die Notwendigkeit ist, das System vollständig neu zu starten, wenn die Anzahl der Rettichinstanzen aktualisiert wird.  Es gibt so etwas wie einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardring und einen Partitionsring</a> , mit denen Sie dies überwinden können, die jedoch in einem Nachrichtensystem nicht anwendbar sind.  Sie können die Logik der Migration von Abonnements zwischen Instanzen erstellen, dies kostet jedoch immer noch einen zusätzlichen Code von unverständlicher Größe. Wie wir wissen, benötigen wir diesen Code nicht, je mehr Code, desto mehr Fehler.  In unserem Fall sind Ausfallzeiten ein akzeptabler Kompromiss. </p><br><p>  Sie können sich auch RabbitMQ mit seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin</a> ansehen, mit dem wir das Gleiche tun können wie wir und + die Migration von Abonnements ermöglicht (wie oben erwähnt - es ist an die Funktionalität von Kopf bis Fuß gebunden).  Im Prinzip können Sie es nehmen und ruhig schlafen, aber wenn jemand an seiner Abstimmung herumfummelt, um den Modus in Echtzeit zu bringen, bleibt nur eine Funktion mit einem Hash-Ring übrig. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überflutete das Repository auf Github.</a> </p><br><p>  Es implementiert die endgültige Version, zu der wir gekommen sind.  Zusätzlich gibt es eine zusätzliche Logik für die Arbeit mit Räumen (Dialoge). </p><br><p>  Generell bin ich zufrieden und kann abgerundet werden. </p><br><h2 id="itogo">  Insgesamt </h2><br><p>  Sie können alles tun, aber es gibt so etwas wie Ressourcen, und sie sind endlich, also müssen Sie sich winden. </p><br><p>  Wir haben mit völliger Unkenntnis darüber begonnen, wie verteilte Systeme zu mehr oder weniger greifbaren konkreten Mustern funktionieren können, und das ist gut so. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440546/">https://habr.com/ru/post/de440546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440534/index.html">Übersetzung des politisch korrekten Wortschatzes vom Englischen ins Russische</a></li>
<li><a href="../de440536/index.html">Wie Facebook Project Infer hilft, Fehler in mobilen Anwendungen vor der Bereitstellung zu finden</a></li>
<li><a href="../de440540/index.html">Die Reddit-Kapitalisierung erreichte 3 Milliarden US-Dollar, nachdem 300 Millionen US-Dollar investiert worden waren</a></li>
<li><a href="../de440542/index.html">Vuex - übermäßiger Einsatz von Gettern in der Anwendung. Fehler beim Parsen</a></li>
<li><a href="../de440544/index.html">Blazor 0.8.0 experimentelle Version jetzt verfügbar</a></li>
<li><a href="../de440548/index.html">"Sie können Spannungsquellen nicht einfach nehmen und parallelisieren."</a></li>
<li><a href="../de440550/index.html">Das Farbdreieck hat nicht zwei, sondern eine Ecke</a></li>
<li><a href="../de440552/index.html">Schließen Sie Schließungen und injizieren Sie Dependency Injection in JavaScript</a></li>
<li><a href="../de440554/index.html">Bequeme BEM</a></li>
<li><a href="../de440556/index.html">Lernen des Entwurfs von Entitätsbeziehungsdiagrammen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>