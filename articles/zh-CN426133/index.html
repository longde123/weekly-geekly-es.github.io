<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🎤 👨🏽‍🍳 🚴🏼 在Kubernetes中引入卷快照的Alpha版本 🥦 🤩 👨🏽‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意事项 佩雷夫 ：最初的文章最近发表在Kubernetes博客上，由Google和华为（徐静，杨星，Saad Ali）的员工撰写，如果您对K8的功能和与之相关的问题感兴趣，您肯定会在该项目的GitHub上看到他们的活动。与数据存储。 工程师讨论了卷快照的用途，其当前功能以及使用它们的基础知识。 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Kubernetes中引入卷快照的Alpha版本</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/426133/"><img src="https://habrastorage.org/webt/ok/pe/iy/okpeiy2vp8v36hzrr-ddpboknyi.png"><br><br>  <i><b>注意事项</b></i>  <i><b>佩雷夫</b></i>  <i>：最初的文章最近发表在Kubernetes博客上，由Google和华为（徐静，杨星，Saad Ali）的员工撰写，如果您对K8的功能和与之相关的问题感兴趣，您肯定会在该项目的GitHub上看到他们的活动。与数据存储。</i>  <i>工程师讨论了卷快照的用途，其当前功能以及使用它们的基础知识。</i> <a name="habracut"></a><br><br>  Kubernetes v1.12引入了对卷快照的支持的Alpha版本。 此功能使您可以创建和删除卷的快照，以及通过Kubernetes API使用系统的“本机”方式从快照中创建新卷。 <br><br><h2> 什么是快照？ </h2><br> 许多存储系统（例如Google Cloud永久磁盘，Amazon Elastic Block Storage和许多本地存储系统）都提供了为永久卷创建快照（“快照”）的功能。 快照是在特定时间点的卷的副本。 它可用于提供一个新卷（已经用快照中的数据填充）或将现有卷还原到以前的状态（在快照中显示）。 <br><br><h2> 为什么要将快照添加到Kubernetes？ </h2><br>  Kubernetes卷插件系统中已经提供了强大的抽象功能，可以自动配置，连接和安装块和文件存储。 <br><br> 提供所有这些功能是Kubernetes的工作负载容忍目标的一部分：Kubernetes旨在在充当分布式系统的应用程序和基础集群之间创建抽象级别，以便应用程序独立于运行它们的特定集群，并且不需要应用程序部署任何特定于群集的知识。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes Storage SIG已将</a>快照操作确定为各种有状态工作负载的关键功能。 例如，数据库管理员可能想在对其数据库执行任何操作之前先对其数据库进行快照。 <br><br> 通过使Kubernetes API成为调用快照操作的标准方式，Kubernetes用户可以使用它们，而无需解决方法（以及手动调用特定于存储系统的操作）。 取而代之的是，让用户有机会将快照操作嵌入他们的工具和策略中，这是一种冷静的理解，即无论底层存储如何，一切都将适用于任何Kubernetes集群。 <br><br> 此外，这些Kubernetes原语用作基本构建块，为开发用于存储管理（例如保护，复制和数据迁移）的更高级企业级功能开辟了道路。 <br><br><h2> 哪些卷插件支持Kubernetes中的快照？ </h2><br>  Kubernetes支持三种类型的批量插件：in-tree，Flex和CSI。 有关详细信息，请参见<a href="">Kubernetes Volume Plugin FAQ</a> 。 <br><br> 仅CSI驱动程序支持快照（树内或Flex均不支持快照）。 要利用此功能，请确保在Kubernetes群集中部署了实现快照支持的CSI驱动程序。 <br><br> 在<i><b>撰写</b></i>本博文时<i>（2018年10月9日- <b>大约翻译</b> ）</i> ，以下CSI驱动程序支持快照： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GCE永久磁盘</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenSDS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">塞夫·罗伯特</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">波特沃克斯</a> </li></ul><br> 对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他驱动程序</a>快照的支持正在开发中，应尽快提供。 有关CSI以及如何部署CSI驱动程序的更多详细信息，在出版物“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes Goes Beta的容器存储接口（CSI）”中进行了描述</a> <i>（另请参见注释“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">理解容器存储接口（在Kubernetes等）中</a> ”的翻译） - <b>大约翻译</b> ）</i> 。 <br><br><h2>  Kubernetes快照API </h2><br> 为了管理快照，Kubernetes Volume Snapshots以与Kubernetes Persistent Volumes API中相同的方式引入了三个新的API对象： <br><br><ul><li> <code>VolumeSnapshot</code> <br> <ul><li> 由Kubernetes用户创建，以请求指定卷的快照。 包含有关快照操作的信息，例如删除快照的时间戳以及快照是否准备就绪。 </li><li> 与<code>PersistentVolumeClaim</code>对象类似，创建和删除该对象表示用户希望创建或删除群集资源（快照）。 </li></ul></li><li> <code>VolumeSnapshotContent</code> <br> <ul><li> 成功创建快照后，由CSI驱动程序创建。 包含有关快照的信息，包括其ID。 </li><li> 像<code>PersistentVolume</code>对象一样，它表示群集已经提供的资源（快照）。 </li><li> 与<code>PersistentVolumeClaim</code>和<code>PersistentVolume</code>对象类似，创建快照时， <code>VolumeSnapshotContent</code>对象<code>VolumeSnapshotContent</code>附加到<code>VolumeSnapshot</code>创建快照的<code>VolumeSnapshotContent</code> （使用一对一映射）。 </li></ul></li><li> <code>VolumeSnapshotClass</code> <br> <ul><li> 由集群管理员定义，以描述可以创建哪些快照。 包括驱动程序信息，用于访问快照的机密等。 </li></ul></li></ul><br> 需要注意的是，与Kubernetes中的主要Persistent Volume对象不同，这些快照对象被定义为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CustomResourceDefinitions（CRD）</a> 。  Kubernetes项目正在逐步摆脱API服务器中预定义的资源类型，而采用一种模型，其中API服务器独立于API对象。 这种方法允许您在其他项目中（除了Kubernetes之外）重用API服务器，并且使用者（例如Kubernetes）可以将其所需的资源类型设置为CRD。 <br><br> 支持快照的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSI驱动程序</a>将自动安装必要的CRD。  Kubernetes最终用户只需要验证群集中是否部署了支持快照的CSI驱动程序。 <br><br> 除了这些新对象之外，现有的<code>PersistentVolumeClaim</code>一个新的<code>DataSource</code>字段： <br><br><pre> <code class="plaintext hljs">type PersistentVolumeClaimSpec struct { AccessModes []PersistentVolumeAccessMode Selector *metav1.LabelSelector Resources ResourceRequirements VolumeName string StorageClassName *string VolumeMode *PersistentVolumeMode DataSource *TypedLocalObjectReference }</code> </pre> <br> 创建新卷时，此字段（处于Alpha版本状态）允许您自动使用现有快照中的数据填充它。 <br><br><h2>  Kubernetes快照要求 </h2><br> 在Kubernetes中使用卷快照之前，您必须： <br><br><ul><li> 确保实现快照的CSI驱动程序已在群集上部署并运行； </li><li> 通过新功能门启用Kubernetes Volume Snapshotting功能（默认情况下对于Alpha版本禁用）： <br><ul><li> 为API Server <code>--feature-gates=VolumeSnapshotDataSource=true</code>设置以下标志：-- <code>--feature-gates=VolumeSnapshotDataSource=true</code> </li></ul></li></ul><br> 在创建快照之前，还必须确定要使用的CSI驱动程序，这是通过创建<code>VolumeSnapshotClass</code>对象并在<code>VolumeSnapshotClass</code>字段中指定CSI驱动程序来完成的。 在下面的<code>VolumeSnapshotClass</code>示例中，此驱动程序是<code>com.example.csi-driver</code> 。 每个快照提供程序至少需要一个<code>VolumeSnapshotClass</code>对象。 也可以为每个CSI驱动程序定义一个默认的<code>VolumeSnapshotClass</code>这可以通过在类定义中设置<code>snapshot.storage.kubernetes.io/is-default-class: "true"</code>注释来完成： <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: default-snapclass annotations: snapshot.storage.kubernetes.io/is-default-class: "true" snapshotter: com.example.csi-driver apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotClass metadata: name: csi-snapclass snapshotter: com.example.csi-driver parameters: fakeSnapshotOption: foo csiSnapshotterSecretName: csi-secret csiSnapshotterSecretNamespace: csi-namespace</code> </pre> <br> 必须根据CSI驱动程序文档设置所有必需的参数。 在上面的示例中，在创建和删除快照期间， <code>fakeSnapshotOption: foo</code>参数和所有提及的机密将传递给CSI驱动程序。 默认情况下， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSI external-snapshotter</a>保存<code>csiSnapshotterSecretName</code>和<code>csiSnapshotterSecretNamespace</code>参数密钥。 <br><br> 最后，在创建快照之前，必须通过CSI驱动程序创建卷，并在其中填充要在其中查看的数据（有关如何使用CSI卷的详细信息，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此出版物</a> ）。 <br><br><h2> 在Kubernetes中创建新快照 </h2><br> 一旦定义了<code>VolumeSnapshotClass</code>对象并且该对象<code>VolumeSnapshotClass</code>要从中删除快照的卷，就可以通过创建<code>VolumeSnapshot</code>对象来执行此操作。 <br><br> 快照的来源由两个参数确定： <br><br><ul><li>  <code>kind</code> -这里显示了<code>PersistentVolumeClaim</code> ； </li><li>  <code>name</code> -PVC对象的实际名称。 </li></ul><br> 可以理解，为其创建快照的卷的名称空间由<code>VolumeSnapshot</code>对象的名称空间确定。 <br><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: new-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass source: name: mypvc kind: PersistentVolumeClaim</code> </pre> <br>  <code>VolumeSnapshot</code>规范可以<code>VolumeSnapshot</code>一个<code>VolumeSnapshotClass</code> ，其中包含有关将使用哪个CSI驱动程序来创建快照的信息。 如先前所报道，在创建<code>VolumeSnapshot</code>对象之后<code>VolumeSnapshot</code> <code>fakeSnapshotOption: foo</code>参数和所有提到的<code>VolumeSnapshotClass</code>机密将在<code>CreateSnapshot</code>调用中传递给CSI插件<code>com.example.csi-driver</code> 。 <br><br> 响应于这样的请求，CSI驱动程序获取卷的快照，然后自动创建一个代表新快照的<code>VolumeSnapshotContent</code>对象，并将该对象附加到<code>VolumeSnapshot</code> ，以备使用。 如果CSI驱动程序无法创建快照并返回错误，则快照控制器将在<code>VolumeSnapshot</code>对象的状态中报告此错误，并且<b>不会</b>进行新的尝试（此行为与Kubernetes中的其他控制器不同-实现该行为是为了避免在不可预测的时间创建快照） 。 <br><br> 如果未指定快照类，则外部快照者将尝试查找默认类并将其用于创建的快照。 在这种情况下， <code>snapshotter</code>在默认类中指向的CSI驱动程序应与PVC存储类中的<code>provisioner</code>程序所指向的CSI驱动程序相对应。 <br><br> 请注意，Kubernetes快照的Alpha版本不保证一致性。 为了确保快照中的完整数据，有必要在删除应用程序之前对其进行适当的准备（停止应用程序，冻结文件系统等）。 <br><br> 要<code>VolumeSnapshot</code>创建<code>VolumeSnapshot</code>对象并将其与<code>VolumeSnapshotContent</code>关联，可以使用<code>kubectl describe volumesnapshot</code> ： <br><br><ul><li>  <code>Ready</code>应为<code>true</code> ，这将指示已准备好使用卷快照。 </li><li>  <code>Creation Time</code>字段显示实际拍摄快照的<code>Creation Time</code> 。 </li><li>  <code>Restore Size</code>字段是还原快照的最小卷大小。 </li><li> 规范中的“ <code>Snapshot Content Name</code>字段指向为此快照创建的<code>VolumeSnapshotContent</code>对象。 </li></ul><br><h2> 将现有快照导入Kubernetes </h2><br> 可以通过手动创建一个代表该快照的<code>VolumeSnapshotContent</code>对象，将现有快照导入Kubernetes。 由于<code>VolumeSnapshotContent</code>是不与命名空间绑定的API对象，因此只有系统管理员才有权创建它。 <br><br> 创建<code>VolumeSnapshotContent</code>对象时，用户可以创建另一个指向该对象的对象<code>VolumeSnapshot</code> 。 在检查<code>VolumeSnapshot</code>和<code>VolumeSnapshotContent</code>之间是否存在连接和正确性之后，外部快照<code>VolumeSnapshot</code>器控制器会将快照标记为就绪。 建立此连接后，快照即可在Kubernetes中使用。 <br><br> 必须使用以下表示<i>预配置</i>快照的字段创建<code>VolumeSnapshotContent</code>对象： <br><br><ul><li>  <code>csiVolumeSnapshotSource</code>标识快照的信息： <br><ul><li>  <code>snapshotHandle</code>名称/标识符。 必填项 </li><li>  driver-用于此卷的CSI驱动程序。 必填字段。 必须与控制器（快照控制器）中<code>snapshotter</code>的名称匹配； </li><li>  <code>creationTime</code>和<code>restoreSize</code>对于预配置的卷，这些字段是可选的。 创建快照后，外部快照程序控制器将自动更新它们。 </li></ul></li><li>  <code>volumeSnapshotRef</code>指向应将此对象（即<code>VolumeSnapshotContent</code> ）附加到的<code>VolumeSnapshot</code>对象的指针： <br><ul><li>  <code>name</code>和<code>namespace</code> -绑定了内容的<code>VolumeSnapshot</code>对象的名称和名称空间； </li><li>  <code>UID</code>可选（用于预先准备的卷）字段。 绑定后，外部快照程序控制器将自动更新此字段。 如果用户定义了该字段，则需要确保它与发生绑定的快照的UID相匹配。 如果没有这样的对应关系，则认为内容无关紧要（孤立对象），因此控制器将删除该内容和关联的快照。 </li></ul></li><li>  <code>snapshotClassName</code>是一个可选字段。 绑定后，外部快照器控制器将自动对其进行更新。 </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshotContent metadata: name: static-snapshot-content spec: csiVolumeSnapshotSource: driver: com.example.csi-driver snapshotHandle: snapshotcontent-example-id volumeSnapshotRef: kind: VolumeSnapshot name: static-snapshot-demo namespace: demo-namespace</code> </pre> <br> 必须创建<code>VolumeSnapshot</code>对象，以便用户可以使用快照。 在其中： <br><br><ul><li>  <code>snapshotClassName</code>卷的快照类的名称。 可选字段。 如果已设置，则<code>snapshotter</code>类中的<code>snapshotter</code>字段应与快照控制器的名称匹配。 如果未设置，则控制器将查找默认快照类；否则，控制器将查找默认快照类。 </li><li>  <code>snapshotContentName</code>快照卷内容的名称。 预先准备的卷的必填字段。 </li></ul><br><pre> <code class="plaintext hljs">apiVersion: snapshot.storage.k8s.io/v1alpha1 kind: VolumeSnapshot metadata: name: static-snapshot-demo namespace: demo-namespace spec: snapshotClassName: csi-snapclass snapshotContentName: static-snapshot-content</code> </pre> <br> 创建这些对象后，快照控制器将绑定它们，将“ <code>Ready</code>字段（在“ <code>Status</code> ）设置为<code>True</code> ，表示快照已准备就绪。 <br><br><h2> 从Kubernetes中的快照准备新卷 </h2><br> 要创建一个预填充了快照对象中数据的新卷，请使用<code>PersistentVolumeClaim</code>的new <code>dataSource</code>字段。 它具有三个参数： <br><br><ul><li>  <code>VolumeSnapshot</code>代表快照源的<code>VolumeSnapshot</code>对象的名称； </li><li>  <code>VolumeSnapshot</code>应该设置为<code>VolumeSnapshot</code> ; </li><li>  <code>apiGroup</code>应该是<code>snapshot.storage.k8s.io</code> 。 </li></ul><br> 假定源的名称空间（ <code>VolumeSnapshot</code> ）与<code>PersistentVolumeClaim</code>的名称空间匹配。 <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: PersistentVolumeClaim metadata: name: pvc-restore Namespace: demo-namespace spec: storageClassName: csi-storageclass dataSource: name: new-snapshot-demo kind: VolumeSnapshot apiGroup: snapshot.storage.k8s.io accessModes: - ReadWriteOnce resources: requests: storage: 1Gi</code> </pre> <br> 创建<code>PersistentVolumeClaim</code>对象时，它将调用新卷的配置，该新卷已预填充了来自指定快照的数据。 <br><br><h2> 如果我是存储开发人员，如何为我的CSI驱动程序添加快照支持？ </h2><br> 为了提供对快照的支持，应将其他控制器功能添加到CSI驱动程序： <code>CREATE_DELETE_SNAPSHOT</code>和<code>LIST_SNAPSHOTS</code> ，以及其他RPC控制器： <code>CreateSnapshot</code> ， <code>DeleteSnapshot</code> ， <code>ListSnapshots</code> 。 有关详细信息，请参见<a href="">CSI规范</a> 。 <br><br> 尽管Kubernetes提供了打包和部署CSI Volume Driver的<a href="">最基本准则</a> ，但是还是<a href="">建议使用一种机制</a>在Kubernetes中部署任意容器化的CSI驱动程序，以简化此过程。 <br><br> 作为建议的部署过程的一部分，Kubernetes团队建议使用各种附带（即辅助）容器，包括带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">外部快照</a>器的附带容器。 <br><br> 提到的外部快照程序监视API服务器中的<code>VolumeSnapshot</code>和<code>VolumeSnapshotContent</code>对象，并为CSI端点调用<code>CreateSnapshot</code>和<code>DeleteSnapshot</code> 。 带有CSI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">external-provisioner</a>的sidecar容器也已更新，以支持使用新的PVC <code>dataSource</code>字段从快照进行卷恢复。 <br><br> 为了支持快照功能，建议存储制造商在外部置备器之外，还通过外部快照程序部署sidecar容器，并将CSI驱动程序放在<code>StatefulSet</code> ，如下图所示： <br><br><img src="https://habrastorage.org/webt/9e/og/xm/9eogxmximi8i_y-6tlhber-xjts.png"><br><br> 在<a href="">此部署示例中，有</a>两个sidecar容器，一个外部供应器和一个外部快照器，并且CSI驱动程序与StatefulSet容器内的CSI主机路径插件一起部署。  CSI主机路径是一个示例插件，不适用于生产环境。 <br><br><h2>  alpha版本的局限性是什么？ </h2><br>  Kubernetes中快照实现的Alpha版本具有以下限制： <br><br><ul><li> 不支持将现有卷回滚到快照代表的先前状态（仅支持从快照配置新卷）。 </li><li> 快照中的现有<code>PersistentVolumeClaim</code>不支持就地还原： 通过快照配置新卷是可行的，但不会更新现有的<code>PersistentVolumeClaim</code> ，使其指向新卷，并且PVC回滚到较早的状态（仅支持通过新PV / PVC使用从快照创建的新卷）。 </li><li> 快照一致性的保证不会超出存储系统提供的保证（例如，删除时的完整性）。 </li></ul><br><h2> 接下来是什么？ </h2><br>  Kubernetes团队计划根据收到的反馈和技术的适应性，将CSI快照的实现引入1.13或1.14版的beta版本。 <br><br><h2> 如何找出更多细节？ </h2><br> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">k8s.io/docs/concepts/storage/volume-snapshots</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubernetes-csi.github.io/docs上的</a>其他快照文档。 <br><br><h2> 译者的PS </h2><br> 另请参阅我们的博客： <br><br><ul><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes 1.12：关键创新概述</a> ”； </li><li>  “我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了解容器存储接口（不仅限于Kubernetes）</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rook是Kubernetes的“自助式”数据仓库</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们在小型项目中使用Kubernetes的经验</a> ” <i>（审查和视频报告）</i> ； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">监控和Kubernetes</a> ” <i>（审查和视频报告）</i> 。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN426133/">https://habr.com/ru/post/zh-CN426133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN426119/index.html">上古：Cryptonomicon铁</a></li>
<li><a href="../zh-CN426121/index.html">MC.exe（消息编译器），rc.exe，link.exe为EventMessageFile生成.dll</a></li>
<li><a href="../zh-CN426123/index.html">学习OpenGL。 第6.1课。 PBR或物理正确的渲染。 理论</a></li>
<li><a href="../zh-CN426125/index.html">职业类固醇。 电梯</a></li>
<li><a href="../zh-CN426131/index.html">通过USB将配置下载到FPGA或拆卸FTDI MPSSE</a></li>
<li><a href="../zh-CN426135/index.html">物联网专用云</a></li>
<li><a href="../zh-CN426137/index.html">诚信时代</a></li>
<li><a href="../zh-CN426141/index.html">红帽用Podman取代Docker</a></li>
<li><a href="../zh-CN426143/index.html">3D动画-视频还是互动的？</a></li>
<li><a href="../zh-CN426145/index.html">独立接受研讨会，莫斯科，10月23日</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>