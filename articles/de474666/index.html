<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª üéüÔ∏è üí™üèΩ Wie man ein Projekt in Rust nicht umschreibt üëÄ ü§¥üèø ‚úâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sobald Sie die Schmerzschwelle des Borrow-Checker √ºberschreiten und feststellen, dass Rust es Ihnen erm√∂glicht, Dinge zu tun, die in anderen Sprachen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man ein Projekt in Rust nicht umschreibt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474666/"><p><img align="right" width="320" src="https://habrastorage.org/webt/dr/uk/dk/drukdkvyoebpgesff5zb_o1zplm.png">  Sobald Sie die Schmerzschwelle des <em>Borrow-Checker</em> √ºberschreiten und feststellen, dass Rust es Ihnen erm√∂glicht, Dinge zu tun, die in anderen Sprachen unvorstellbar (und manchmal gef√§hrlich) sind, haben Sie m√∂glicherweise auch den gleichen unwiderstehlichen Wunsch, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alles in Rust umzuschreiben</a> .  Obwohl dies im besten Fall banal unproduktiv ist (bedeutungsloser Aufwand f√ºr mehrere Projekte), f√ºhrt dies im schlimmsten Fall zu einer Verschlechterung der Codequalit√§t (warum sind Sie im Umgang mit der Bibliothek erfahrener als der urspr√ºngliche Autor?) </p><br><p>  Es w√§re viel n√ºtzlicher, eine sichere Schnittstelle f√ºr die urspr√ºngliche Bibliothek bereitzustellen, indem der Code wiederverwendet wird. </p><a name="habracut"></a><br><p>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erste Schritte</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir sammeln chmlib-sys</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schreiben eines sicheren Wrappers in Rust</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Suchen Sie nach Elementen nach Namen</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Elemente nach Filter umgehen</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen von Dateiinhalten</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºgen Sie Beispiele hinzu</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhaltsverzeichnis der CHM-Datei</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entpacken Sie die CHM-Datei auf die Festplatte</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie geht es weiter?</a> </p><br><blockquote>  Dieser Artikel beschreibt ein reales Projekt.  Ich musste Informationen aus vorhandenen CHM-Dateien extrahieren, aber es war keine Zeit, das Format zu verstehen.  Faulheit ist der Motor des Fortschritts. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die <strong>chmlib-Kiste wird</strong> auf crates.io</a> ver√∂ffentlicht und ihr Quellcode ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf GitHub</a> verf√ºgbar.  Wenn Sie es n√ºtzlich finden oder Probleme darin finden, lassen Sie es mich <a href="">√ºber den Bugtracker</a> wissen. </blockquote><br><h2 id="pervye-shagi">  Erste Schritte </h2><br><p>  Zun√§chst lohnt es sich zu verstehen, wie die Arbeit mit der Bibliothek urspr√ºnglich konzipiert wurde. </p><br><blockquote>  Auf diese Weise lernen Sie nicht nur, wie man es benutzt, sondern stellen auch sicher, dass alles l√§uft.  Wenn Sie Gl√ºck haben, finden Sie sogar vorgefertigte Tests und Beispiele. <br><br>  <strong>√úberspringen Sie diesen Schritt nicht!</strong> </blockquote><p> Wir werden mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CHMLib arbeiten</a> , einer C-Bibliothek zum Lesen von <em>Microsoft Compiled HTML Help</em> ( <code>.chm</code> ) -Dateien. </p><br><p>  Beginnen wir damit, ein neues Projekt zu erstellen und CHMLib als Git-Submodul zu verbinden: </p><br><pre> <code class="plaintext hljs">$ git init chmlib &amp;&amp; cd chmlib Initialized empty Git repository in /home/michael/Documents/chmlib/.git/ $ touch README.md Cargo.toml $ cargo new --lib chmlib Created library `chmlib` package $ cargo new --lib chmlib-sys Created library `chmlib-sys` package $ cat Cargo.toml [workspace] members = ["chmlib", "chmlib-sys"] $ git submodule add git@github.com:jedwing/CHMLib.git vendor/CHMLib Cloning into '/home/michael/Documents/chmlib/vendor/CHMLib'... remote: Enumerating objects: 99, done. remote: Total 99 (delta 0), reused 0 (delta 0), pack-reused 99 Receiving objects: 100% (99/99), 375.51 KiB | 430.00 KiB/s, done. Resolving deltas: 100% (45/45), done.</code> </pre> <br><p>  Schauen Sie sich danach mit <code>tree</code> an, was sich darin befindet: </p><br><pre> <code class="plaintext hljs">$ tree vendor/CHMLib vendor/CHMLib ‚îú‚îÄ‚îÄ acinclude.m4 ‚îú‚îÄ‚îÄ AUTHORS ‚îú‚îÄ‚îÄ ChangeLog ‚îú‚îÄ‚îÄ ChmLib-ce.zip ‚îú‚îÄ‚îÄ ChmLib-ds6.zip ‚îú‚îÄ‚îÄ configure.in ‚îú‚îÄ‚îÄ contrib ‚îÇ ‚îî‚îÄ‚îÄ mozilla_helper.sh ‚îú‚îÄ‚îÄ COPYING ‚îú‚îÄ‚îÄ Makefile.am ‚îú‚îÄ‚îÄ NEWS ‚îú‚îÄ‚îÄ NOTES ‚îú‚îÄ‚îÄ README ‚îî‚îÄ‚îÄ src ‚îú‚îÄ‚îÄ chm_http.c ‚îú‚îÄ‚îÄ chm_lib.c ‚îú‚îÄ‚îÄ chm_lib.h ‚îú‚îÄ‚îÄ enum_chmLib.c ‚îú‚îÄ‚îÄ enumdir_chmLib.c ‚îú‚îÄ‚îÄ extract_chmLib.c ‚îú‚îÄ‚îÄ lzx.c ‚îú‚îÄ‚îÄ lzx.h ‚îú‚îÄ‚îÄ Makefile.am ‚îú‚îÄ‚îÄ Makefile.simple ‚îî‚îÄ‚îÄ test_chmLib.c 2 directories, 23 files</code> </pre> <br><p>  Es sieht so aus, als w√ºrde die Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU Autotools</a> zum Erstellen verwenden.  Dies ist nicht gut, da alle Benutzer der chmlib-Kiste (und ihre Benutzer) Autotools installieren m√ºssen. </p><br><blockquote>  Wir werden versuchen, diese "ansteckende" Abh√§ngigkeit durch manuelles Sammeln des C-Codes zu beseitigen, aber dazu sp√§ter mehr. </blockquote><p>  Die Dateien lzx.h und lzx.c enthalten eine Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LZX-</a> Komprimierungsalgorithmus.  Im Allgemeinen w√§re es besser, eine Art Liblzx-Bibliothek zu verwenden, um kostenlose Updates und all das zu erhalten, aber vielleicht w√§re es einfacher, diese Dateien dumm zu kompilieren. </p><br><p>  enum_chmLib.c, enumdir_chmLib.c, extract_chmLib.c scheinen Beispiele f√ºr die Verwendung der Funktionen chm_enumerate (), chm_enumerate_dir (), chm_retrieve_object () zu sein.  Es wird sich als n√ºtzlich erweisen ... </p><br><p>  Die Datei test_chmLib.c enth√§lt ein weiteres Beispiel, diesmal wird eine Seite aus der CHM-Datei auf die Festplatte extrahiert. </p><br><p>  chm_http.c implementiert einen einfachen HTTP-Server, der eine CHM-Datei in einem Browser anzeigt.  Dies wird wahrscheinlich nicht l√§nger n√ºtzlich sein. </p><br><p>  Also haben wir alles aussortiert, was in vendor / CHMLib / src enthalten ist.  Werden wir die Bibliothek abholen? </p><br><p>  Ehrlich gesagt ist es klein genug, um die wissenschaftliche Poke-Methode anzuwenden. </p><br><pre> <code class="plaintext hljs">$ clang chm_lib.c enum_chmLib.c -o enum_chmLib /usr/bin/ld: /tmp/chm_lib-537dfe.o: in function `chm_close': chm_lib.c:(.text+0x8fa): undefined reference to `LZXteardown' /usr/bin/ld: /tmp/chm_lib-537dfe.o: in function `_chm_decompress_region': chm_lib.c:(.text+0x18ca): undefined reference to `LZXinit' /usr/bin/ld: /tmp/chm_lib-537dfe.o: in function `_chm_decompress_block': chm_lib.c:(.text+0x2900): undefined reference to `LZXreset' /usr/bin/ld: chm_lib.c:(.text+0x2a4b): undefined reference to `LZXdecompress' /usr/bin/ld: chm_lib.c:(.text+0x2abe): undefined reference to `LZXreset' /usr/bin/ld: chm_lib.c:(.text+0x2bf4): undefined reference to `LZXdecompress' clang: error: linker command failed with exit code 1 (use -v to see invocation)</code> </pre> <br><p>  Okay, vielleicht wird dieser LZX noch ben√∂tigt ... </p><br><pre> <code class="plaintext hljs">$ clang chm_lib.c enum_chmLib.c lzx.c -o enum_chmLib</code> </pre> <br><p>  √Ñh ... alles? </p><br><p>  Um sicherzustellen, dass der Code funktioniert, habe ich ein Beispiel aus dem Internet heruntergeladen: </p><br><pre> <code class="plaintext hljs">$ curl http://www.innovasys.com/static/hs/samples/topics.classic.chm.zip \ -o topics.classic.chm.zip $ unzip topics.classic.chm.zip Archive: topics.classic.chm.zip inflating: output/compiled/topics.classic.chm $ file output/compiled/topics.classic.chm output/compiled/topics.classic.chm: MS Windows HtmlHelp Data</code> </pre> <br><p>  Mal sehen, wie enum_chmLib damit umgeht: </p><br><pre> <code class="plaintext hljs">$ ./enum_chmLib output/compiled/topics.classic.chm output/compiled/topics.classic.chm: spc start length type name === ===== ====== ==== ==== 0 0 0 normal dir / 1 5125797 4096 special file /#IDXHDR ... 1 4944434 11234 normal file /BrowserView.html ... 0 0 0 normal dir /flash/ 1 532689 727 normal file /flash/expressinstall.swf 0 0 0 normal dir /Images/Commands/RealWorld/ 1 24363 1254 normal file /Images/Commands/RealWorld/BrowserBack.bmp ... 1 35672 1021 normal file /Images/Employees24.gif ... 1 3630715 200143 normal file /template/packages/jquery-mobile/script/ jquery.mobile-1.4.5.min.js ... 0 134 1296 meta file ::DataSpace/Storage/MSCompressed/Transform/ {7FC28940-9D31-11D0-9B27-00A0C91E9C7C}/ InstanceData/ResetTable</code> </pre> <br><p>  Herr, <em>auch hier</em> jQuery ¬Ø \ _ („ÉÑ) _ / ¬Ø </p><br><h2 id="sobiraem-chmlib-sys">  Erstellen Sie chmlib-sys </h2><br><p>  Jetzt wissen wir genug, um CHMLib in der chmlib <strong>-sys-Kiste zu verwenden</strong> , die f√ºr die Erstellung der nativen Bibliothek, die Verkn√ºpfung mit dem Rast-Compiler und eine Schnittstelle zu C-Funktionen verantwortlich ist. </p><br><p>  Um die Bibliothek zu erstellen, m√ºssen Sie die Datei <code>build.rs</code> schreiben.  Mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>cc-</strong> Kiste</a> ruft er den C-Compiler auf und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schlie√üt</a> weitere Freundschaften, damit alles so funktioniert, wie es sollte. </p><br><blockquote>  Wir haben das Gl√ºck, dass wir den gr√∂√üten Teil der Arbeit auf CC verlagern k√∂nnen, aber manchmal ist es viel schwieriger.  Weitere Informationen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation zu Assemblerskripten</a> . </blockquote><p>  F√ºgen Sie zuerst <strong>cc</strong> als Abh√§ngigkeit f√ºr chmlib-sys hinzu: </p><br><pre> <code class="plaintext hljs">$ cd chmlib-sys $ cargo add --build cc Updating 'https://github.com/rust-lang/crates.io-index' index Adding cc v1.0.46 to build-dependencies</code> </pre> <br><p>  Dann schreiben wir <code>build.rs</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib-sys/build.rs use cc::Build; use std::{env, path::PathBuf}; fn main() { let project_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()) .canonicalize() .unwrap(); let root_dir = project_dir.parent().unwrap(); let src = root_dir.join("vendor").join("CHMLib").join("src"); Build::new() .file(src.join("chm_lib.c")) .file(src.join("lzx.c")) .include(&amp;src) .warnings(false) .compile("chmlib"); }</span></span></code> </pre> <br><p>  Sie m√ºssen Cargo auch mitteilen, dass chmlib-sys Links zur chmlib-Bibliothek enth√§lt.  Dann kann Cargo garantieren, dass es im gesamten Abh√§ngigkeitsdiagramm nur ein Rack gibt, abh√§ngig von der spezifischen nativen Bibliothek.  Dies vermeidet undurchsichtige Fehlermeldungen √ºber wiederholte Zeichen oder die versehentliche Verwendung inkompatibler Bibliotheken. </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/chmlib-sys/Cargo.toml +++ b/chmlib-sys/Cargo.toml @@ -3,7 +3,13 @@ name = "chmlib-sys" version = "0.1.0" authors = ["Michael Bryan &lt;michaelfbryan@gmail.com&gt;"] edition = "2018" description = "Raw bindings to the CHMLib C library" license = "LGPL" repository = "https://github.com/Michael-F-Bryan/chmlib" +links = "chmlib" +build = "build.rs" [dependencies] [build-dependencies] cc = { version = "1.0" }</span></span></code> </pre> <br><p>  Als n√§chstes m√ºssen wir alle von der chmlib-Bibliothek exportierten Funktionen deklarieren, damit sie aus Rast verwendet werden k√∂nnen. </p><br><p>  Daf√ºr gibt es das wunderbare Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bindgen</a> .  Die C-Header-Datei wird an die Eingabe √ºbergeben, und die Datei mit den FFI-Bindungen f√ºr Rast wird ausgegeben. </p><br><pre> <code class="plaintext hljs">$ cargo install bindgen $ bindgen ../vendor/CHMLib/src/chm_lib.h \ -o src/lib.rs \ --raw-line '#![allow(non_snake_case, non_camel_case_types)]' $ head src/lib.rs /* automatically generated by rust-bindgen */ #![allow(non_snake_case, non_camel_case_types)] pub const CHM_UNCOMPRESSED: u32 = 0; pub const CHM_COMPRESSED: u32 = 1; pub const CHM_MAX_PATHLEN: u32 = 512; pub const CHM_PARAM_MAX_BLOCKS_CACHED: u32 = 0; pub const CHM_RESOLVE_SUCCESS: u32 = 0; pub const CHM_RESOLVE_FAILURE: u32 = 1; $ tail src/lib.rs extern "C" { pub fn chm_enumerate_dir( h: *mut chmFile, prefix: *const ::std::os::raw::c_char, what: ::std::os::raw::c_int, e: CHM_ENUMERATOR, context: *mut ::std::os::raw::c_void, ) -&gt; ::std::os::raw::c_int; }</code> </pre> <br><blockquote>  Ich empfehle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dringend, die Bedienungsanleitung von Bindgen zu</a> lesen, wenn Sie etwas im Auspuff reparieren m√ºssen. </blockquote><p>  In diesem Stadium ist es n√ºtzlich, einen Rauchtest zu schreiben, der √ºberpr√ºft, ob alles wie erwartet funktioniert und ob wir tats√§chlich die Funktionen der urspr√ºnglichen C-Bibliothek aufrufen k√∂nnen. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib-sys/tests/smoke_test.rs //    Path  char*     . //  , OsStr ( Path)  Windows  [u16]  , //        char*. #![cfg(unix)] use std::{ffi::CString, os::unix::ffi::OsStrExt, path::Path}; #[test] fn open_example_file() { let project_dir = Path::new(env!("CARGO_MANIFEST_DIR")); let sample_chm = project_dir.parent().unwrap().join("topics.classic.chm"); let c_str = CString::new(sample_chm.as_os_str().as_bytes()).unwrap(); unsafe { let handle = chmlib_sys::chm_open(c_str.as_ptr()); assert!(!handle.is_null()); chmlib_sys::chm_close(handle); } }</span></span></code> </pre> <br><p>  <code>cargo test</code> sagt, dass alles in Ordnung zu sein scheint: </p><br><pre> <code class="plaintext hljs">$ cargo test Finished test [unoptimized + debuginfo] target(s) in 0.03s Running ~/chmlib/target/debug/deps/chmlib_sys-2ffd7b11a9fd8437 running 1 test test bindgen_test_layout_chmUnitInfo ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Running ~/chmlib/target/debug/deps/smoke_test-f7be9810412559dc running 1 test test open_example_file ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Doc-tests chmlib-sys running 0 tests test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out</code> </pre> <br><h2 id="pishem-bezopasnuyu-obyortku-na-rust">  Schreiben eines sicheren Wrappers in Rust </h2><br><p>  <em>Technisch und technisch k√∂nnen</em> wir jetzt CHMLib von Rasta aus aufrufen, dies erfordert jedoch einen <strong>unsicheren</strong> Heap.  Es mag f√ºr ein abgedroschenes Handwerk funktionieren, aber f√ºr das Ver√∂ffentlichen auf crates.io lohnt es sich, einen sicheren Wrapper f√ºr allen unsicheren Code zu schreiben. </p><br><p>  Wenn Sie sich die chmlib-sys-API mit dem Frachtdokument --open <code>cargo doc --open</code> , sehen Sie viele Funktionen, die <strong><code>*mut ChmFile</code></strong> als erstes Argument verwenden.  Dies √§hnelt Objekten und Methoden. </p><br><div class="spoiler">  <b class="spoiler_title">CHMLib-Header-Datei</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* $Id: chm_lib.h,v 1.10 2002/10/09 01:16:33 jedwin Exp $ */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * chm_lib.h - CHM archive manipulation routines * * ------------------- * * * * author: Jed Wing &lt;jedwin@ugcs.caltech.edu&gt; * * version: 0.3 * * notes: These routines are meant for the manipulation of microsoft * * .chm (compiled html help) files, but may likely be used * * for the manipulation of any ITSS archive, if ever ITSS * * archives are used for any other purpose. * * * * Note also that the section names are statically handled. * * To be entirely correct, the section names should be read * * from the section names meta-file, and then the various * * content sections and the "transforms" to apply to the data * * they contain should be inferred from the section name and * * the meta-files referenced using that name; however, all of * * the files I've been able to get my hands on appear to have * * only two sections: Uncompressed and MSCompressed. * * Additionally, the ITSS.DLL file included with Windows does * * not appear to handle any different transforms than the * * simple LZX-transform. Furthermore, the list of transforms * * to apply is broken, in that only half the required space * * is allocated for the list. (It appears as though the * * space is allocated for ASCII strings, but the strings are * * written as unicode. As a result, only the first half of * * the string appears.) So this is probably not too big of * * a deal, at least until CHM v4 (MS .lit files), which also * * incorporate encryption, of some description. * ***************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU Lesser General Public License as * * published by the Free Software Foundation; either version 2.1 of the * * License, or (at your option) any later version. * * * ***************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> INCLUDED_CHMLIB_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INCLUDED_CHMLIB_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __cplusplus extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* RWE 6/12/1002 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> PPC_BSTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;wtypes.h&gt; #endif #ifdef WIN32 #ifdef __MINGW32__ #define __int64 long long #endif typedef unsigned __int64 LONGUINT64; typedef __int64 LONGINT64; #else typedef unsigned long long LONGUINT64; typedef long long LONGINT64; #endif /* the two available spaces in a CHM file */ /* NB: The format supports arbitrarily many spaces, but only */ /* two appear to be used at present. */ #define CHM_UNCOMPRESSED (0) #define CHM_COMPRESSED (1) /* structure representing an ITS (CHM) file stream */ struct chmFile; /* structure representing an element from an ITS file stream */ #define CHM_MAX_PATHLEN (512) struct chmUnitInfo { LONGUINT64 start; LONGUINT64 length; int space; int flags; char path[CHM_MAX_PATHLEN+1]; }; /* open an ITS archive */ #ifdef PPC_BSTR /* RWE 6/12/2003 */ struct chmFile* chm_open(BSTR filename); #else struct chmFile* chm_open(const char *filename); #endif /* close an ITS archive */ void chm_close(struct chmFile *h); /* methods for ssetting tuning parameters for particular file */ #define CHM_PARAM_MAX_BLOCKS_CACHED 0 void chm_set_param(struct chmFile *h, int paramType, int paramVal); /* resolve a particular object from the archive */ #define CHM_RESOLVE_SUCCESS (0) #define CHM_RESOLVE_FAILURE (1) int chm_resolve_object(struct chmFile *h, const char *objPath, struct chmUnitInfo *ui); /* retrieve part of an object from the archive */ LONGINT64 chm_retrieve_object(struct chmFile *h, struct chmUnitInfo *ui, unsigned char *buf, LONGUINT64 addr, LONGINT64 len); /* enumerate the objects in the .chm archive */ typedef int (*CHM_ENUMERATOR)(struct chmFile *h, struct chmUnitInfo *ui, void *context); #define CHM_ENUMERATE_NORMAL (1) #define CHM_ENUMERATE_META (2) #define CHM_ENUMERATE_SPECIAL (4) #define CHM_ENUMERATE_FILES (8) #define CHM_ENUMERATE_DIRS (16) #define CHM_ENUMERATE_ALL (31) #define CHM_ENUMERATOR_FAILURE (0) #define CHM_ENUMERATOR_CONTINUE (1) #define CHM_ENUMERATOR_SUCCESS (2) int chm_enumerate(struct chmFile *h, int what, CHM_ENUMERATOR e, void *context); int chm_enumerate_dir(struct chmFile *h, const char *prefix, int what, CHM_ENUMERATOR e, void *context); #ifdef __cplusplus } #endif #endif /* INCLUDED_CHMLIB_H */</span></span></span></span></code> </pre> </div></div><br><p>  Beginnen wir mit dem Datentyp, der im Konstruktor chm_open () und im Destruktor chm_close () aufruft. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chm_open</span></span></span></span>(filename: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c_char) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmFile; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chm_close</span></span></span></span>(h: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmFile);</code> </pre> <br><p>  Um die Fehlerbehandlung zu vereinfachen, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>thiserror-Kiste</strong></a> , die <code>std::error::Error</code> automatisch implementiert. </p><br><pre> <code class="plaintext hljs">$ cd chmlib $ cargo add thiserror</code> </pre> <br><p>  Nun m√ºssen Sie herausfinden, wie <code>std::path::Path</code> in <code>*const c_char</code> .  Leider ist dies aufgrund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschiedener</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Witze</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mit Kompatibilit√§t</a> nicht so einfach zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bewerkstelligen</a> . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs use thiserror::Error; use std::{ffi::CString, path::Path}; #[cfg(unix)] fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString, InvalidPath&gt; { use std::os::unix::ffi::OsStrExt; let bytes = path.as_os_str().as_bytes(); CString::new(bytes).map_err(|_| InvalidPath) } #[cfg(not(unix))] fn path_to_cstring(path: &amp;Path) -&gt; Result&lt;CString, InvalidPath&gt; { //  ,  Windows CHMLib  CreateFileA(),   //       ASCII.   ...   // ,          ? let rust_str = path.as_os_str().as_str().ok_or(InvalidPath)?; CString::new(rust_str).map_err(|_| InvalidPath) } #[derive(Error, Debug, Copy, Clone, PartialEq)] #[error("Invalid Path")] pub struct InvalidPath;</span></span></code> </pre> <br><p>  Definieren Sie nun die Struktur der <strong>ChmFile</strong> .  Es speichert einen Zeiger ungleich Null auf chmlib_sys :: chmFile.  Wenn chm_open () einen Nullzeiger zur√ºckgibt, bedeutet dies, dass sie die Datei aufgrund eines Fehlers nicht √∂ffnen konnte. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs use std::{ffi::CString, path::Path, ptr::NonNull}; #[derive(Debug)] pub struct ChmFile { raw: NonNull&lt;chmlib_sys::chmFile&gt;, } impl ChmFile { pub fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;ChmFile, OpenError&gt; { let c_path = path_to_cstring(path.as_ref())?; // ,   c_path  unsafe { let raw = chmlib_sys::chm_open(c_path.as_ptr()); match NonNull::new(raw) { Some(raw) =&gt; Ok(ChmFile { raw }), None =&gt; Err(OpenError::Other), } } } } impl Drop for ChmFile { fn drop(&amp;mut self) { unsafe { chmlib_sys::chm_close(self.raw.as_ptr()); } } } /// The error returned when we are unable to open a [`ChmFile`]. #[derive(Error, Debug, Copy, Clone, PartialEq)] pub enum OpenError { #[error("Invalid path")] InvalidPath(#[from] InvalidPath), #[error("Unable to open the ChmFile")] Other, }</span></span></code> </pre> <br><p>  F√ºhren Sie unter <strong>Valgrind</strong> einen einfachen Test durch, um sicherzustellen, dass keine Speicherlecks auftreten.  Er erstellt eine ChmFile und gibt sie sofort frei. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs #[test] fn open_valid_chm_file() { let sample = sample_path(); //   let chm_file = ChmFile::open(&amp;sample).unwrap(); //      drop(chm_file); } fn sample_path() -&gt; PathBuf { let project_dir = Path::new(env!("CARGO_MANIFEST_DIR")); let sample = project_dir.parent().unwrap().join("topics.classic.chm"); assert!(sample.exists()); sample }</span></span></code> </pre> <br><p>  Valgrind sagt, es ist kein unkontrollierter Speicher mehr vorhanden: </p><br><pre> <code class="plaintext hljs">$ valgrind ../target/debug/deps/chmlib-8d8c740d578324 open_valid_chm_file ==8953== Memcheck, a memory error detector ==8953== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==8953== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info ==8953== Command: ~/chmlib/target/debug/deps/chmlib-8d8c740d578324 open_valid_chm_file ==8953== running 1 test test tests::open_valid_chm_file ... ok test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out ==8953== ==8953== HEAP SUMMARY: ==8953== in use at exit: 0 bytes in 0 blocks ==8953== total heap usage: 249 allocs, 249 frees, 43,273 bytes allocated ==8953== ==8953== All heap blocks were freed -- no leaks are possible ==8953== ==8953== For counts of detected and suppressed errors, rerun with: -v ==8953== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code> </pre> <br><h3 id="poisk-elementov-po-imeni">  Suchen Sie nach Artikeln nach Namen </h3><br><p>  Als n√§chstes folgt die Funktion chm_resolve_object (): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHM_RESOLVE_SUCCESS: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CHM_RESOLVE_FAILURE: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* resolve a particular object from the archive */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chm_resolve_object</span></span></span></span>( h: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmFile, objPath: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c_char, ui: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chmUnitInfo ) -&gt; c_int;</code> </pre> <br><p>  Die Suche kann fehlschlagen, daher gibt chm_resolve_object () einen Fehlercode zur√ºck, der Erfolg oder Misserfolg meldet, und Informationen √ºber das gefundene Objekt werden vom √ºbergebenen Zeiger auf <strong>chmUnitInfo aufgezeichnet</strong> . </p><br><p>  Der Typ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>std::mem::MaybeUninit</code></a> nur f√ºr unseren Fall mit dem out-Parameter <strong>ui erstellt</strong> . </p><br><p>  Lassen wir zun√§chst die UnitInfo-Struktur leer - dies ist das Rust-√Ñquivalent der chmUnitInfo C-Struktur.  Wir werden die Felder hinzuf√ºgen, wenn wir mit dem Lesen von ChmFile beginnen. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs impl ChmFile { ... /// Find a particular object in the archive. pub fn find&lt;P: AsRef&lt;Path&gt;&gt;(&amp;mut self, path: P) -&gt; Option&lt;UnitInfo&gt; { let path = path_to_cstring(path.as_ref()).ok()?; unsafe { //   chmUnitInfo   let mut resolved = MaybeUninit::&lt;chmlib_sys::chmUnitInfo&gt;::uninit(); //  -  let ret = chmlib_sys::chm_resolve_object( self.raw.as_ptr(), path.as_ptr(), resolved.as_mut_ptr(), ); if ret == chmlib_sys::CHM_RESOLVE_SUCCESS { //    "resolved"   Some(UnitInfo::from_raw(resolved.assume_init())) } else { None } } } } #[derive(Debug)] pub struct UnitInfo; impl UnitInfo { fn from_raw(ui: chmlib_sys::chmUnitInfo) -&gt; UnitInfo { UnitInfo } }</span></span></code> </pre> <br><blockquote>  Beachten Sie, dass ChmFile :: find () <strong><code>&amp;mut self</code></strong> akzeptiert, obwohl der Code auf dem Rast keine explizite Status√§nderung enth√§lt.  Tatsache ist, dass die C-Implementierung alle Arten von fseek () verwendet, um sich in der Datei zu bewegen, sodass sich der interne Status w√§hrend der Suche immer noch √§ndert. </blockquote><p>  Lassen Sie uns ChmFile :: find () in der zuvor heruntergeladenen experimentellen Datei √ºberpr√ºfen: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs #[test] fn find_an_item_in_the_sample() { let sample = sample_path(); let chm = ChmFile::open(&amp;sample).unwrap(); assert!(chm.find("/BrowserView.html").is_some()); assert!(chm.find("doesn't exist.txt").is_none()); }</span></span></code> </pre> <br><h3 id="obhod-elementov-po-filtru">  Bypass-Elemente filtern </h3><br><p>  CHMLib bietet eine API zum Anzeigen des Inhalts einer CHM-Datei √ºber einen Bitmaskenfilter. </p><br><p>  Nehmen Sie die praktische Bitflags-Kiste zum Arbeiten mit Masken und Flaggen: </p><br><pre> <code class="plaintext hljs">$ cargo add bitflags Updating 'https://github.com/rust-lang/crates.io-index' index Adding bitflags v1.2.1 to dependencies</code> </pre> <br><p>  Und definieren Sie die <strong>Filter-</strong> Kontrollk√§stchen basierend auf den Konstanten aus chm_lib.h: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs bitflags::bitflags! { pub struct Filter: c_int { /// A normal file. const NORMAL = chmlib_sys::CHM_ENUMERATE_NORMAL as c_int; /// A meta file (typically used by the CHM system). const META = chmlib_sys::CHM_ENUMERATE_META as c_int; /// A special file (starts with `#` or `$`). const SPECIAL = chmlib_sys::CHM_ENUMERATE_SPECIAL as c_int; /// It's a file. const FILES = chmlib_sys::CHM_ENUMERATE_FILES as c_int; /// It's a directory. const DIRS = chmlib_sys::CHM_ENUMERATE_DIRS as c_int; } }</span></span></code> </pre> <br><p>  Wir ben√∂tigen auch einen <code>extern "C"</code> -Adapter f√ºr Rastovyh-Verschl√ºsse, der in Form eines Zeigers auf eine Funktion an C √ºbergeben werden kann: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs unsafe extern "C" fn function_wrapper&lt;F&gt;( file: *mut chmlib_sys::chmFile, unit: *mut chmlib_sys::chmUnitInfo, state: *mut c_void, ) -&gt; c_int where F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; Continuation, { //      FFI- let result = panic::catch_unwind(|| { //   ManuallyDrop    `&amp;mut ChmFile` //        ( double-free). let mut file = ManuallyDrop::new(ChmFile { raw: NonNull::new_unchecked(file), }); let unit = UnitInfo::from_raw(unit.read()); //  state      let closure = &amp;mut *(state as *mut F); closure(&amp;mut file, unit) }); match result { Ok(Continuation::Continue) =&gt; { chmlib_sys::CHM_ENUMERATOR_CONTINUE as c_int }, Ok(Continuation::Stop) =&gt; chmlib_sys::CHM_ENUMERATOR_SUCCESS as c_int, Err(_) =&gt; chmlib_sys::CHM_ENUMERATOR_FAILURE as c_int, } }</span></span></code> </pre> <br><blockquote>  <code>function_wrapper</code> enth√§lt einen kniffligen unsicheren Code, den Sie verwenden m√ºssen: <br><br><ul><li>  Der <code>state</code> <strong>muss</strong> auf die Instanz von Closure F zeigen. </li><li>  Durch einen Abschluss ausgef√ºhrter Rasta-Code kann Panik ausl√∂sen.  Es sollte die Grenze zwischen Rast und C nicht √ºberschreiten, da Stack-Promotion in verschiedenen Sprachen undefiniertes Verhalten ist.  Eine m√∂gliche Panik sollte mit <code>std::panic::catch_unwind()</code> abgefangen werden. </li><li>  Ein Zeiger auf chmlib_sys :: chmFile, der an function_wrapper √ºbergeben wird, wird auch in der aufrufenden ChmFile gespeichert.  W√§hrend der Dauer des Aufrufs m√ºssen Sie sicherstellen, dass nur der Abschluss chmlib_sys :: chmFile manipulieren kann. Andernfalls kann eine Race-Bedingung auftreten. </li><li>  Der Abschluss muss <code>&amp;mut ChmFile</code> , und daf√ºr m√ºssen Sie ein tempor√§res Objekt auf dem Stapel unter Verwendung des vorhandenen Zeigers erstellen.  Wenn in diesem Fall der ChmFile-Destruktor ausgef√ºhrt wird, wird chmlib_sys :: chmFile zu fr√ºh freigegeben.  Um dieses Problem zu l√∂sen, gibt es <code>std::mem::ManuallyDrop</code> . </li></ul><br></blockquote><p>  So wird function_wrapper verwendet, um <code>ChmFile::for_each()</code> zu implementieren: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs impl ChmFile { ... /// Inspect each item within the [`ChmFile`]. pub fn for_each&lt;F&gt;(&amp;mut self, filter: Filter, mut cb: F) where F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; Continuation, { unsafe { chmlib_sys::chm_enumerate( self.raw.as_ptr(), filter.bits(), Some(function_wrapper::&lt;F&gt;), &amp;mut cb as *mut _ as *mut c_void, ); } } /// Inspect each item within the [`ChmFile`] inside a specified directory. pub fn for_each_item_in_dir&lt;F, P&gt;( &amp;mut self, filter: Filter, prefix: P, mut cb: F, ) where P: AsRef&lt;Path&gt;, F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; Continuation, { let path = match path_to_cstring(prefix.as_ref()) { Ok(p) =&gt; p, Err(_) =&gt; return, }; unsafe { chmlib_sys::chm_enumerate_dir( self.raw.as_ptr(), path.as_ptr(), filter.bits(), Some(function_wrapper::&lt;F&gt;), &amp;mut cb as *mut _ as *mut c_void, ); } } }</span></span></code> </pre> <br><blockquote>  Beachten Sie, wie der Parameter F mit der generischen Funktion function_wrapper interagiert.  Diese Technik wird h√§ufig verwendet, wenn Sie den Rust-Verschluss √ºber FFI an Code in einer anderen Sprache √ºbergeben m√ºssen. </blockquote><br><h3 id="chtenie-soderzhimogo-faylov">  Dateiinhalt lesen </h3><br><p>  Die letzte Funktion, die wir ben√∂tigen, ist f√ºr das Lesen der Datei mit chm_retrieve_object () verantwortlich. </p><br><p>  Die Implementierung ist ziemlich trivial.  Dies √§hnelt einem typischen std :: io :: Read-Merkmal mit Ausnahme eines expliziten Datei-Offsets. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs impl ChmFile { ... pub fn read( &amp;mut self, unit: &amp;UnitInfo, offset: u64, buffer: &amp;mut [u8], ) -&gt; Result&lt;usize, ReadError&gt; { let mut unit = unit.0.clone(); let bytes_written = unsafe { chmlib_sys::chm_retrieve_object( self.raw.as_ptr(), &amp;mut unit, buffer.as_mut_ptr(), offset, buffer.len() as _, ) }; if bytes_written &gt;= 0 { Ok(bytes_written as usize) } else { Err(ReadError) } } } #[derive(Error, Debug, Copy, Clone, PartialEq)] #[error("The read failed")] pub struct ReadError;</span></span></code> </pre> <br><p>  Nat√ºrlich w√§re es sch√∂n, eine detailliertere Fehlermeldung zu haben als "Fehler beim Lesen", aber nach dem Quellcode zu urteilen, unterscheidet chm_retrieve_object () nicht besonders zwischen Fehlern: </p><br><ul><li>  gibt 0 zur√ºck, wenn die Datei bis zum Ende gelesen wird; </li><li>  Gibt 0 f√ºr ung√ºltige Argumente zur√ºck: Nullzeiger oder Grenz√ºberschreitungen; </li><li>  Gibt ‚àí1 zur√ºck, wenn Fehler beim Lesen von Dateien vom System auftreten (und f√ºllt errno aus). </li><li>  Gibt ‚àí1 f√ºr Dekomprimierungsfehler zur√ºck, ohne die Datenbesch√§digung zu unterscheiden und beispielsweise die Unf√§higkeit, √ºber malloc () Speicher f√ºr einen tempor√§ren Puffer zuzuweisen. </li></ul><br><p>  Sie k√∂nnen ChmFile :: read () mit Dateien mit bekanntem Inhalt testen: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/src/lib.rs #[test] fn read_an_item() { let sample = sample_path(); let mut chm = ChmFile::open(&amp;sample).unwrap(); let filename = "/template/packages/core-web/css/index.responsive.css"; //        let item = chm.find(filename).unwrap(); //      let mut buffer = vec![0; item.length() as usize]; let bytes_written = chm.read(&amp;item, 0, &amp;mut buffer).unwrap(); //      assert_eq!(bytes_written, item.length() as usize); // ...  ,    let got = String::from_utf8(buffer).unwrap(); assert!(got.starts_with( "html, body, div#i-index-container, div#i-index-body" )); }</span></span></code> </pre> <br><h2 id="dobavlyaem-primery">  Beispiele hinzuf√ºgen </h2><br><p>  Wir haben die meisten APIs der CHMLib-Bibliothek behandelt, und viele w√§ren damit fertig geworden, wenn die Portierung erfolgreich abgeschlossen worden w√§re.  Es w√§re jedoch sch√∂n, unser Rack noch benutzerfreundlicher zu gestalten.        ‚Äî  ,    Rust  Go       ( ,  <em>rustdoc</em>  <em>godoc</em>     ). </p><br><p>  ,  CHMLib    ,        . </p><br><p>       , ,         . </p><br><h3 id="oglavlenie-chm-fayla">  CHM- </h3><br><p>    CHM-         . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* $Id: enum_chmLib.c,v 1.7 2002/10/09 12:38:12 jedwin Exp $ */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * enum_chmLib.c - CHM archive test driver * * ------------------- * * * * author: Jed Wing &lt;jedwin@ugcs.caltech.edu&gt; * * notes: This is a quick-and-dirty test driver for the chm lib * * routines. The program takes as its input the paths to one * * or more .chm files. It attempts to open each .chm file in * * turn, and display a listing of all of the files in the * * archive. * * * * It is not included as a particularly useful program, but * * rather as a sort of "simplest possible" example of how to * * use the enumerate portion of the API. * ***************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU Lesser General Public License as * * published by the Free Software Foundation; either version 2.1 of the * * License, or (at your option) any later version. * * * ***************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"chm_lib.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; /* * callback function for enumerate API */ int _print_ui(struct chmFile *h, struct chmUnitInfo *ui, void *context) { static char szBuf[128]; memset(szBuf, 0, 128); if(ui-&gt;flags &amp; CHM_ENUMERATE_NORMAL) strcpy(szBuf, "normal "); else if(ui-&gt;flags &amp; CHM_ENUMERATE_SPECIAL) strcpy(szBuf, "special "); else if(ui-&gt;flags &amp; CHM_ENUMERATE_META) strcpy(szBuf, "meta "); if(ui-&gt;flags &amp; CHM_ENUMERATE_DIRS) strcat(szBuf, "dir"); else if(ui-&gt;flags &amp; CHM_ENUMERATE_FILES) strcat(szBuf, "file"); printf(" %1d %8d %8d %s\t\t%s\n", (int)ui-&gt;space, (int)ui-&gt;start, (int)ui-&gt;length, szBuf, ui-&gt;path); return CHM_ENUMERATOR_CONTINUE; } int main(int c, char **v) { struct chmFile *h; int i; for (i=1; i&lt;c; i++) { h = chm_open(v[i]); if (h == NULL) { fprintf(stderr, "failed to open %s\n", v[i]); exit(1); } printf("%s:\n", v[i]); printf(" spc start length type\t\t\tname\n"); printf(" === ===== ====== ====\t\t\t====\n"); if (! chm_enumerate(h, CHM_ENUMERATE_ALL, _print_ui, NULL)) printf(" *** ERROR ***\n"); chm_close(h); } return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  _print_ui()    Rust.         UnitInfo  ,      ,     . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/enumerate-items.rs fn describe_item(item: UnitInfo) { let mut description = String::new(); if item.is_normal() { description.push_str("normal "); } else if item.is_special() { description.push_str("special "); } else if item.is_meta() { description.push_str("meta "); } if item.is_dir() { description.push_str("dir"); } else if item.is_file() { description.push_str("file"); } println!( " {} {:8} {:8} {}\t\t{}", item.space(), item.start(), item.length(), description, item.path().unwrap_or(Path::new("")).display() ); }</span></span></code> </pre> <br><p>  main()       ,  ,   describe_item()  ChmFile::for_each(). </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/enumerate-items.rs fn main() { let filename = env::args() .nth(1) .unwrap_or_else(|| panic!("Usage: enumerate-items &lt;filename&gt;")); let mut file = ChmFile::open(&amp;filename).expect("Unable to open the file"); println!("{}:", filename); println!(" spc start length type\t\t\tname"); println!(" === ===== ====== ====\t\t\t===="); file.for_each(Filter::all(), |_file, item| { describe_item(item); Continuation::Continue }); }</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="plaintext hljs">$ cargo run --example enumerate-items topics.classic.chm &gt; rust-example.txt $ cd vendor/CHMLib/src $ clang chm_lib.c enum_chmLib.c lzx.c -o enum_chmLib $ cd ../../.. $ ./vendor/CHMLib/src/enum_chmLib topics.classic.chm &gt; c-example.txt $ diff -u rust-example.txt c-example.txt $ echo $? 0</code> </pre> <br><p> diff ,   ,   ,     ,    .    -   ,     diff. </p><br><pre> <code class="diff hljs">diff --git a/chmlib/examples/enumerate-items.rs b/chmlib/examples/enumerate-items.rs index e68fa58..ef855ac 100644 --- a/chmlib/examples/enumerate-items.rs +++ b/chmlib/examples/enumerate-items.rs @@ -36,6 +36,10 @@ fn describe_item(item: UnitInfo) { description.push_str("file"); } + if item.length() % 7 == 0 { + description.push_str(" :)"); + } + println!( " {} {:8} {:8} {}\t\t{}", item.space(),</code> </pre> <br><p>     : </p><br><pre> <code class="diff hljs">$ cargo run --example enumerate-items topics.classic.chm &gt; rust-example.txt $ diff -u rust-example.txt c-example.txt --- rust-example.txt 2019-10-20 16:51:53.933560892 +0800 +++ c-example.txt 2019-10-20 16:40:42.007053966 +0800 @@ -1,9 +1,9 @@ topics.classic.chm: spc start length type name <span class="hljs-comment"><span class="hljs-comment">=== ===== ====== ==== ==== - 0 0 0 normal dir :) / + 0 0 0 normal dir / 1 5125797 4096 special file /#IDXHDR - 0 0 0 special file :) /#ITBITS + 0 0 0 special file /#ITBITS 1 5104520 148 special file /#IVB 1 5132009 1227 special file /#STRINGS 0 1430 4283 special file /#SYSTEM @@ -13,9 +13,9 @@ ...</span></span></code> </pre> <br><p> ! </p><br><h3 id="raspakovka-chm-fayla-na-disk">  CHM-   </h3><br><p>  ,     CHMLib,   ¬´¬ª   . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* $Id: extract_chmLib.c,v 1.4 2002/10/10 03:24:51 jedwin Exp $ */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * extract_chmLib.c - CHM archive extractor * * ------------------- * * * * author: Jed Wing &lt;jedwin@ugcs.caltech.edu&gt; * * notes: This is a quick-and-dirty chm archive extractor. * ***************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*************************************************************************** * * * This program is free software; you can redistribute it and/or modify * * it under the terms of the GNU Lesser General Public License as * * published by the Free Software Foundation; either version 2.1 of the * * License, or (at your option) any later version. * * * ***************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"chm_lib.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #ifdef WIN32 #include &lt;windows.h&gt; #include &lt;direct.h&gt; #define mkdir(X, Y) _mkdir(X) #define snprintf _snprintf #else #include &lt;unistd.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; #endif struct extract_context { const char *base_path; }; static int dir_exists(const char *path) { #ifdef WIN32 /* why doesn't this work?!? */ HANDLE hFile; hFile = CreateFileA(path, FILE_LIST_DIRECTORY, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile != INVALID_HANDLE_VALUE) { CloseHandle(hFile); return 1; } else return 0; #else struct stat statbuf; if (stat(path, &amp;statbuf) != -1) return 1; else return 0; #endif } static int rmkdir(char *path) { /* * strip off trailing components unless we can stat the directory, or we * have run out of components */ char *i = strrchr(path, '/'); if(path[0] == '\0' || dir_exists(path)) return 0; if (i != NULL) { *i = '\0'; rmkdir(path); *i = '/'; mkdir(path, 0777); } #ifdef WIN32 return 0; #else if (dir_exists(path)) return 0; else return -1; #endif } /* * callback function for enumerate API */ int _extract_callback(struct chmFile *h, struct chmUnitInfo *ui, void *context) { LONGUINT64 ui_path_len; char buffer[32768]; struct extract_context *ctx = (struct extract_context *)context; char *i; if (ui-&gt;path[0] != '/') return CHM_ENUMERATOR_CONTINUE; /* quick hack for security hole mentioned by Sven Tantau */ if (strstr(ui-&gt;path, "/../") != NULL) { /* fprintf(stderr, "Not extracting %s (dangerous path)\n", ui-&gt;path); */ return CHM_ENUMERATOR_CONTINUE; } if (snprintf(buffer, sizeof(buffer), "%s%s", ctx-&gt;base_path, ui-&gt;path) &gt; 1024) return CHM_ENUMERATOR_FAILURE; /* Get the length of the path */ ui_path_len = strlen(ui-&gt;path)-1; /* Distinguish between files and dirs */ if (ui-&gt;path[ui_path_len] != '/' ) { FILE *fout; LONGINT64 len, remain=ui-&gt;length; LONGUINT64 offset = 0; printf("--&gt; %s\n", ui-&gt;path); if ((fout = fopen(buffer, "wb")) == NULL) { /* make sure that it isn't just a missing directory before we abort */ char newbuf[32768]; strcpy(newbuf, buffer); i = strrchr(newbuf, '/'); *i = '\0'; rmkdir(newbuf); if ((fout = fopen(buffer, "wb")) == NULL) return CHM_ENUMERATOR_FAILURE; } while (remain != 0) { len = chm_retrieve_object(h, ui, (unsigned char *)buffer, offset, 32768); if (len &gt; 0) { fwrite(buffer, 1, (size_t)len, fout); offset += len; remain -= len; } else { fprintf(stderr, "incomplete file: %s\n", ui-&gt;path); break; } } fclose(fout); } else { if (rmkdir(buffer) == -1) return CHM_ENUMERATOR_FAILURE; } return CHM_ENUMERATOR_CONTINUE; } int main(int c, char **v) { struct chmFile *h; struct extract_context ec; if (c &lt; 3) { fprintf(stderr, "usage: %s &lt;chmfile&gt; &lt;outdir&gt;\n", v[0]); exit(1); } h = chm_open(v[1]); if (h == NULL) { fprintf(stderr, "failed to open %s\n", v[1]); exit(1); } printf("%s:\n", v[1]); ec.base_path = v[2]; if (! chm_enumerate(h, CHM_ENUMERATE_ALL, _extract_callback, (void *)&amp;ec)) printf(" *** ERROR ***\n"); chm_close(h); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>               . ,     . </p><br><p>     extract().    ,              . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/extract.rs fn extract( root_dir: &amp;Path, file: &amp;mut ChmFile, item: &amp;UnitInfo, ) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; { if !item.is_file() || !item.is_normal() { //      return Ok(()); } let path = match item.path() { Some(p) =&gt; p, //     ,   None =&gt; return Ok(()), }; let mut dest = root_dir.to_path_buf(); // :  CHM       (  "/"), //     root_dir     "/". dest.extend(path.components().skip(1)); //     if let Some(parent) = dest.parent() { fs::create_dir_all(parent)?; } let mut f = File::create(dest)?; let mut start_offset = 0; // CHMLib      &amp;[u8]    (, //      ),       //      let mut buffer = vec![0; 1 &lt;&lt; 16]; loop { let bytes_read = file.read(item, start_offset, &amp;mut buffer)?; if bytes_read == 0 { //     break; } else { //      start_offset += bytes_read as u64; f.write_all(&amp;buffer)?; } } Ok(()) }</span></span></code> </pre> <br><p>  main()  ,  extract(),         . </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// chmlib/examples/extract.rs fn main() { let args: Vec&lt;_&gt; = env::args().skip(1).collect(); if args.len() != 2 || args.iter().any(|arg| arg.contains("-h")) { println!("Usage: extract &lt;chm-file&gt; &lt;out-dir&gt;"); return; } let mut file = ChmFile::open(&amp;args[0]).expect("Unable to open the file"); let out_dir = PathBuf::from(&amp;args[1]); file.for_each(Filter::all(), |file, item| { match extract(&amp;out_dir, file, &amp;item) { Ok(_) =&gt; Continuation::Continue, Err(e) =&gt; { eprintln!("Error: {}", e); Continuation::Stop }, } }); }</span></span></code> </pre> <br><p>      CHM-    HTML-,      -. </p><br><pre> <code class="plaintext hljs">$ cargo run --example extract -- ./topics.classic.chm ./extracted $ tree ./extracted ./extracted ‚îú‚îÄ‚îÄ default.html ‚îú‚îÄ‚îÄ BrowserForward.html ... ‚îú‚îÄ‚îÄ Images ‚îÇ ‚îú‚îÄ‚îÄ Commands ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ RealWorld ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ BrowserBack.bmp ... ‚îú‚îÄ‚îÄ script ‚îÇ ‚îú‚îÄ‚îÄ _community ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ disqus.js ‚îÇ ‚îú‚îÄ‚îÄ hs-common.js ... ‚îî‚îÄ‚îÄ userinterface.html $ firefox topics.classic/default.html ( default.html  Firefox)</code> </pre> <br><p>  JavaScript   ( -    Microsoft Help),   ,     . </p><br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>  chmlib    ,    ,     crates.io. </p><br><p>        : </p><br><ul><li>    ChmFile::for_each()  ChmFile::for_each_item_in_dir() ,          ,     . </li><li>   ,          ChmFile       <code>Continuation::Continue</code>   . ,     <code>F: FnMut(&amp;mut ChmFile, UnitInfo) -&gt; C</code>  <code>C: Into&lt;Continuation&gt;</code> ,    <code>impl From&lt;()&gt; for Continuation</code> . </li><li>      (,     extract())      ChmFile::for_each()   .         <code>impl&lt;E&gt; From&lt;Result&lt;(), E&gt;&gt; for Continuation where E: Error + 'static</code> . </li><li> -               <code>std::fs::File</code> .      ,     ChmFile::read()     - <code>std::io::Writer</code> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474666/">https://habr.com/ru/post/de474666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474654/index.html">SSH Handshake in einfachen Worten.</a></li>
<li><a href="../de474656/index.html">Reversim MIPS und Golang - die Grundlagen des Reverse. L√∂sen von Problemen beim Umkehren mit r0ot-mi. Teil 2</a></li>
<li><a href="../de474658/index.html">Schmerzen am Handgelenk und Computerm√§use</a></li>
<li><a href="../de474662/index.html">Beta-Test: Devdiction for Developers - eine Plattform zum Englischlernen</a></li>
<li><a href="../de474664/index.html">Um die Aufmerksamkeit zu erh√∂hen, erh√∂ht unser Gehirn nicht die Konzentration, sondern verwendet Informationsfilter</a></li>
<li><a href="../de474668/index.html">GitHub-Aktionen als CI / CD f√ºr eine Site auf einem statischen Generator und GitHub-Seiten</a></li>
<li><a href="../de474672/index.html">Reagieren, JSX, Importieren von ES-Modulen (auch dynamisch) in einen Browser ohne Webpack</a></li>
<li><a href="../de474674/index.html">Bildverarbeitung und Medizin</a></li>
<li><a href="../de474676/index.html">Der Interaktionsalgorithmus von Hunderttausenden eindeutigen Partikeln auf der GPU in GLES3 und WebGL2</a></li>
<li><a href="../de474678/index.html">Die Khronos Group hat ein einheitliches Repository mit Vulkan-Beispielen erstellt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>