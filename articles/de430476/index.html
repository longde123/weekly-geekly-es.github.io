<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊ 👊🏾 🧓🏼 NCBI Genome Workbench: Gefährdete Forschung 👨🏿‍🤝‍👨🏾 🛌🏾 🥜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Moderne Computertechnologien, technische und Softwarelösungen - all dies erleichtert und beschleunigt die Umsetzung verschiedener wissenschaftlicher F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NCBI Genome Workbench: Gefährdete Forschung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430476/"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/9dc/792/9ce9dc792e9661eba72b3692521754be.png" align="left">  Moderne Computertechnologien, technische und Softwarelösungen - all dies erleichtert und beschleunigt die Umsetzung verschiedener wissenschaftlicher Forschungen erheblich.  Oft ist die Computersimulation die einzige Möglichkeit, viele Theorien zu testen.  Wissenschaftliche Software hat ihre eigenen Eigenschaften.  Beispielsweise wird eine solche Software häufig sehr gründlichen Tests unterzogen, ist jedoch schlecht dokumentiert.  Software wird jedoch von Menschen geschrieben, und Menschen machen Fehler.  Fehler in wissenschaftlichen Programmen können die gesamte Forschung in Frage stellen.  In diesem Artikel werden Dutzende von Problemen aufgelistet, die im Code des NCBI Genome Workbench-Softwarepakets enthalten sind. <br><a name="habracut"></a><br><h2>  Einführung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die NCBI Genome Workbench</a> bietet Forschern eine breite Palette von Werkzeugen zum Studieren und Analysieren genetischer Daten.  Benutzer können Daten aus verschiedenen Quellen recherchieren und vergleichen, einschließlich der NCBI-Datenbanken (National Center for Biotechnology Information) oder ihrer eigenen persönlichen Daten. <br><br>  Wie bereits erwähnt, wird wissenschaftliche Software in der Regel durch Unit-Tests gut abgedeckt.  Bei der Überprüfung dieses Projekts wurden 85 Verzeichnisse mit Testdateien von der Analyse ausgeschlossen.  Das sind ungefähr tausend Dateien.  Möglicherweise liegt dies an den Anforderungen zum Testen verschiedener komplexer Algorithmen, die für verschiedene Studien erfunden wurden.  Aber die Qualität des restlichen Codes (nicht des Tests) ist nicht so hoch, wie wir es gerne hätten.  Wie in jedem Projekt, in dem sie sich noch nicht um die Einführung statischer Code-Analyse-Tools gekümmert haben :). <br><br>  Daten zur Überprüfung (oder sogar Recherche) des Codes wurden vom statischen Code-Analysator für C / C ++ / C # / Java - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> bereitgestellt. <br><br><h2>  Nur zwei Zahlen, die Ihr Projekt ruinieren </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dad/9f3/20b/dad9f320b84473428205cc1227a20fe6.png"></div><br><br>  Basierend auf unserer Fehlerdatenbank, die derzeit mehr als 12.000 ausgewählte Beispiele umfasst, bemerken und beschreiben wir spezifische Muster zum Schreiben von Code, die zu zahlreichen Fehlern führen.  Zum Beispiel haben wir folgende Studien durchgeführt: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Wirkung der letzten Zeile</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die gefährlichste Funktion in der Welt von C / C ++</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Logische Ausdrücke in C / C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie falsch sind die Profis</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Böse lebt in Vergleichsfunktionen</a> . </li></ol><br>  Dieses Projekt war der Beginn der Beschreibung des neuen Musters.  Wir sprechen über die Nummern <b>1</b> und <b>2</b> in den Namen von Variablen, zum Beispiel <i>Datei1</i> und <i>Datei2</i> usw.  Es ist sehr leicht, zwei solche Variablen zu verwechseln.  Dies ist ein Sonderfall von Tippfehlern im Code, aber ein solcher Fehler führt zu dem Wunsch, mit gleichnamigen Variablen zu arbeiten, die sich nur in den Nummern 1 und 2 am Ende des Namens unterscheiden. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass alle oben aufgeführten Studien im Code dieses Projekts bestätigt wurden: D. <br><br>  Betrachten Sie das erste Beispiel aus dem Genome Workbench-Projekt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdrücke '(! Loc1.IsInt () &amp;&amp;! Loc1.IsWhole ())'.  Betreiber.  nw_aligner.cpp 480 <br><br><pre><code class="cpp hljs">CRef&lt;CSeq_align&gt; CNWAligner::Run(CScope &amp;scope, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc2, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trim_end_gaps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!loc1.IsInt() &amp;&amp; !loc1.IsWhole()) || (!loc1.IsInt() &amp;&amp; !loc1.IsWhole())) { NCBI_THROW(CException, eUnknown, <span class="hljs-string"><span class="hljs-string">"Only whole and interval locations supported"</span></span>); } .... }</code> </pre> <br>  Wir sehen zwei Variablen mit den Namen <i>loc1</i> und <i>loc2</i> .  Und auch ein Fehler im Code: Die Variable <i>loc2 wird</i> nicht verwendet, da stattdessen wieder <i>loc1</i> verwendet wird. <br><br>  Ein weiteres Beispiel: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> Ein Teil des bedingten Ausdrucks ist immer falsch: s1.IsSet ().  valid_biosource.cpp 3073 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_PCRPrimerSetLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; s1.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &lt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &gt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ..... }</code> </pre> <br>  In der ersten Codezeile wurden die Variablen <i>s1</i> und <i>s2 verwechselt</i> .  Basierend auf dem Namen ist dies eine Vergleichsfunktion.  Ein solcher Fehler kann jedoch überall auftreten, da der Programmierer durch die Benennung der Variablen <i>Nummer 1</i> und <i>Nummer 2</i> mit ziemlicher Sicherheit in Zukunft einen Fehler machen wird.  Und je häufiger solche Namen in einer Funktion verwendet werden, desto höher ist die Wahrscheinlichkeit eines Fehlers. <br><br><h2>  Andere Tippfehler und Copy-Paste </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/d9f/f6b/6d5d9ff6bf8083922701b25273fa50b2.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom Operator '! =' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gibt</a> es identische Unterausdrücke: bd.bit_.bits [i]! = Bd.bit_.bits [i] bm.h 296 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator_base&amp; ib)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;block_type_ == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.ptr != ib_db.bit_.ptr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.idx != ib_db.bit_.idx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.cnt != ib_db.bit_.cnt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.pos != ib_db.bit_.pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bd.bit_.cnt; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.bits[i] != bd.bit_.bits[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } .... }</code> </pre> <br>  Ich glaube, dass nach all den Überprüfungen die Größen der <i>Bit-</i> Arrays der <i>Objekte</i> <i>bd.bit_</i> und <i>ib_db.bit_</i> gleich sind.  Daher schrieb der Autor des Codes einen Zyklus für den elementweisen Vergleich des <i>Bit-</i> Arrays, machte jedoch einen Tippfehler im Namen eines der verglichenen Objekte.  Infolgedessen können verglichene Objekte in einigen Situationen fälschlicherweise als gleich angesehen werden. <br><br>  Dieses Beispiel verdient den Artikel "Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Böse lebt in Vergleichsfunktionen</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdrücke 'CFieldHandler :: QualifierNamesAreEquivalent (Feld, kFieldTypeSeqId)'.  Betreiber.  field_handler.cpp 152 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CFieldHandlerFactory::s_IsSequenceIDField(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; field) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId) || CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Höchstwahrscheinlich ist eine der Prüfungen überflüssig.  Ich habe in den <i>Codevariablen</i> , die <i>kFieldTypeSeqId</i> ähneln, <i>keine gefunden</i> .  Trotzdem ist aufgrund des Operators "||" ein zusätzlicher Funktionsaufruf möglich, der die Leistung beeinträchtigt. <br><br>  Ein paar weitere Orte derselben Art mit einer Analysatorwarnung, die überprüft werden muss: <br><br><ul><li>  V501 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke 'uf-&gt; GetData (). IsBool ()'.  Variation_utils.cpp 1711 </li><li>  V501 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke 'uf-&gt; GetData (). IsBool ()'.  Variation_utils.cpp 1735 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V766</a> Ein Element mit demselben Schlüssel 'kArgRemote' wurde bereits hinzugefügt.  blast_args.cpp 3262 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastAppArgs::x_IssueWarningsForIgnoredOptions(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CArgs&amp; args) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; can_override; .... can_override.insert(kArgOutputFormat); can_override.insert(kArgNumDescriptions); can_override.insert(kArgNumAlignments); can_override.insert(kArgMaxTargetSequences); can_override.insert(kArgRemote); <span class="hljs-comment"><span class="hljs-comment">// &lt;= can_override.insert(kArgNumThreads); can_override.insert(kArgInputSearchStrategy); can_override.insert(kArgRemote); // &lt;= can_override.insert("remote_verbose"); can_override.insert("verbose"); .... }</span></span></code> </pre> <br>  Der Analysator hat festgestellt, dass dem <i>eingestellten</i> Behälter 2 identische Werte hinzugefügt wurden.  Denken Sie daran, dass dieser Container nur eindeutige Werte speichert, sodass ihm keine Duplikate hinzugefügt werden. <br><br>  Code wie der obige wird häufig mit der Copy-Paste-Methode geschrieben.  Möglicherweise gibt es einfach einen zusätzlichen Wert, oder der Autor hat beim Kopieren vergessen, eine der Variablen umzubenennen.  Wenn Sie einen zusätzlichen Aufruf zum <i>Einfügen</i> entfernen <i>, wird der</i> Code leicht optimiert, was jedoch nicht von Bedeutung ist.  Noch wichtiger ist, dass hier möglicherweise ein schwerwiegender Fehler aufgrund eines fehlenden Elements in der Gruppe ausgeblendet wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V523</a> Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  vcf_reader.cpp 1105 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CVcfReader::xAssignFeatureLocationSet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_SetType == CVcfData::ST_ALL_DEL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_strRef.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); //-1 for 0-based, //another -1 for inclusive end-point ( ie [], not [) ) pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; } //default: For MNV's we will use the single starting point //NB: For references of size &gt;=2, this location will not //match the reference allele. Future Variation-ref //normalization code will address these issues, //and obviate the need for this code altogether. if (data.m_strRef.size() == 1) { //deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; }</span></span></code> </pre> <br>  Die Funktion enthält große und vollständig identische Codefragmente.  Sie enthalten jedoch verschiedene begleitende Kommentare.  Der Code ist nicht optimal, verwirrend geschrieben und enthält möglicherweise einen Fehler. <br><br>  Die gesamte Liste der verdächtigen Orte mit der if-else-Anweisung sieht folgendermaßen aus: <br><br><ul><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  blk.c 2142 </li><li>  V523 Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  odbc.c 379 </li><li>  V523 Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  odbc.c 1414 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  seqdbvol.cpp 1922 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  seqdb_demo.cpp 466 </li><li>  V523 Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  blast_engine.c 1917 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  blast_filter.c 420 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  blast_parameters.c 636 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  unordered_spliter.cpp 684 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  bme.cpp 333 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  gme.cpp 484 </li></ul><br><h2>  / * mit Sicherheit ist am besten pedantisch * / </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/df5/670/914df5670813e7eb410e446f60a0ed5e.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'passwd_buf' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PW_SZ 14 .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ntlm_v == 1) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* with security is best be pedantic */</span></span></span><span class="hljs-meta"> memset(hash, 0, sizeof(hash)); memset(passwd_buf, 0, sizeof(passwd_buf)); memset(ntlm2_challenge, 0, sizeof(ntlm2_challenge)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { .... } }</span></span></code> </pre> <br>  Wie Sie wahrscheinlich bereits vermutet haben, wurde im Abschnittstitel ein lustiger Kommentar zur Sicherheit durch Code verwendet. <br><br>  Kurz gesagt, die <i>Memset-</i> Funktion wird vom Compiler entfernt, da geleerte Puffer nicht mehr verwendet werden.  Und Daten wie <i>Hash</i> oder <i>passwd_buf</i> sind eigentlich keine Nullen.  Weitere Informationen zu diesem nicht offensichtlichen Compiler-Mechanismus finden Sie im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sicheres Löschen privater Daten</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'answer' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 561 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TDSRET </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds7_send_auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* for security reason clear structure */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;answer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TDSANSWER)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tds_flush_packet(tds); }</code> </pre> <br>  Dies war nicht das einzige Beispiel mit Kommentaren zu „Sicherheit“.  Den Kommentaren nach zu urteilen, kann davon ausgegangen werden, dass Sicherheit für das Projekt wirklich wichtig ist.  Daher füge ich die gesamte nicht kleine Liste der identifizierten Probleme bei: <br><br><ul><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das 'heap'-Objekt geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  ncbi_heapmgr.c 1300 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das 'context'-Objekt geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 167 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ks' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 339 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'md5_ctx' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 353 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'Hash'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Challenge.c 365 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ks' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 406 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ntlm_v2_response' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  login.c 795 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'answer' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  login.c 801 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'Paket'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  numeric.c 256 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'Paket'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  numeric.c 110 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'pwd'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  getpassarg.c 50 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das 'context'-Objekt geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 188 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'buf'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 243 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'ntlm_v2_hash' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 309 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'md5_ctx' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 354 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'passwd_buf' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 380 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ks' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 393 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'Hash'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 394 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'ntlm2_challenge' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 395 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ks' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 419 </li><li>  V597 Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem das Objekt 'ntlm_v2_response' gelöscht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 556 </li></ul><br><h2>  Verdächtige Zyklen </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/c77/124/8acc77124e5a13a1d25926c95d9eb2cf.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V534</a> Es ist wahrscheinlich, dass eine falsche Variable innerhalb des ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">for'</a> -Operators verglichen wird.  Betrachten Sie die Überprüfung von 'i'.  taxFormat.cpp 569 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTaxFormat::x_LoadTaxTree(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; alignTaxids.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tax_id = alignTaxids[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; taxInfo.seqInfoList.size(); j++) { SSeqInfo* seqInfo = taxInfo.seqInfoList[j]; seqInfo-&gt;taxid = newTaxid; } .... } .... }</code> </pre> <br>  Ich denke, im Zustand der inneren Schleife habe ich die Variable zufällig erhalten.  Stattdessen sollte die Variable <i>j</i> verwendet werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V535</a> Die Variable 'i' wird für diese Schleife und für die äußere Schleife verwendet.  Überprüfen Sie die Zeilen: 302, 309. sls_alp.cpp 309 <br><br><pre> <code class="cpp hljs">alp::~alp() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d_alp_states) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=d_nalp;i++) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if(i&lt;=d_alp_states-&gt;d_dim) { if(d_alp_states-&gt;d_elem[i]) { for(i=0;i&lt;=d_nalp;i++) // &lt;= { .... .... }</span></span></code> </pre> <br>  Zwei verschachtelte identische Zyklen, in denen auch der globale Zähler zurückgesetzt wird, sehen sehr verdächtig aus.  Entwickler sollten überprüfen, was hier passiert. <br><br><h2>  Array-Indizierung abnormal </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/136/5b2/4a81365b2534c606f6d12df389841299.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V520</a> Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommaoperator</a> ',' im Array- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexausdruck</a> '[- i2, - k]'.  nw_spliced_aligner16.cpp 564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CSplicedAligner16::x_DoBackTrace ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Uint2* backtrace_matrix, CNWAligner::SAlignInOut* data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_global_max, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j_global_max) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(intron_length &lt; m_IntronMinSize || (Key &amp; donor) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Key = backtrace_matrix[--i2, --k]; ++intron_length; data-&gt;m_transcript.push_back(eTS_Intron); } .... }</code> </pre> <br>  Ich muss sofort sagen, dass es keinen Fehler zu geben scheint (vorerst lol).  Betrachten Sie die folgende Zeile: <br><br><pre> <code class="cpp hljs">Key = backtrace_matrix[--i2, --k];</code> </pre> <br>  Das Wort "Matrix" und die doppelte Indizierung können darauf hinweisen, dass das Array zweidimensional ist, dies ist jedoch nicht der Fall.  Dies ist ein regulärer Zeiger auf ein Array von Ganzzahlen.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V520-</a> Diagnose wurde jedoch nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> .  Programmierer sind wirklich verwirrt darüber, wie zweidimensionale Arrays indiziert werden sollen. <br><br>  In diesem Fall hat der Autor einfach beschlossen, in einer Codezeile zu speichern, obwohl er folgendermaßen schreiben könnte: <br><br><pre> <code class="cpp hljs">--i2; Key = backtrace_matrix[--k];</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V661</a> Ein verdächtiger Ausdruck 'A [B == C]'.  Bedeutete wahrscheinlich 'A [B] == C'.  ncbi_service_connector.c 180 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EHTTP_HeaderParse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_ParseHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* header, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header, <span class="hljs-string"><span class="hljs-string">"%u.%u.%u.%u%n"</span></span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;n) &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header + n, <span class="hljs-string"><span class="hljs-string">"%hu%x%n"</span></span>, &amp;uuu-&gt;port, &amp;tkt, &amp;m) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || (header[m += n] &amp;&amp; !(header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((header + m) [header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>])))) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span><span class="hljs-comment"><span class="hljs-comment">/*failed - unreadable connection info*/</span></span>; } .... }</code> </pre> <br>  Ein weiteres Beispiel für Code, in dem ich lange versucht habe zu verstehen, was vor sich geht: D.  Die Funktion <i>isspace ()</i> überprüft das Zeichen mit dem Index <i>m</i> . Wenn dieses Zeichen jedoch '$' ist, wird das Zeichen mit dem Index <i>m + 1</i> an die Funktion übergeben.  Darüber hinaus war der Vergleich mit '$' bereits im Voraus.  Vielleicht liegt hier kein Fehler vor, aber der Code kann definitiv klarer umgeschrieben werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V557</a> Array-Überlauf ist möglich.  Der 'Zeilen'-Index zeigt über die Array-Grenze hinaus.  aln_reader.cpp 412 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CAlnReader::x_IsGap(TNumrow row, TSeqPos pos, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; residue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_MiddleSections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x_CalculateMiddleSections(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt; m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; m_MiddleSections[row].first) { .... } .... }</code> </pre> <br>  Hier liegt ein schwerwiegender Fehler vor.  Die korrekte Überprüfung des Zeilenindex sollte folgendermaßen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt;= m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Andernfalls ist es möglich, auf Daten außerhalb des <i>MiddleSections-</i> Vektors <i>zuzugreifen</i> . <br><br>  Viele weitere solcher Orte: <br><br><ul><li>  V557 Array-Überlauf ist möglich.  Der 'i'-Index zeigt über die Array-Grenze hinaus.  resource_pool.hpp 388 </li><li>  V557 Array-Überlauf ist möglich.  Der 'Zeilen'-Index zeigt über die Array-Grenze hinaus.  aln_reader.cpp 418 </li><li>  V557 Array-Überlauf ist möglich.  Der Index 'fmt_idx' zeigt über die Array-Grenze hinaus.  seq_writer.cpp 384 </li><li>  V557 Array-Überlauf ist möglich.  Der Index 'fmt_idx' zeigt über die Array-Grenze hinaus.  blastdb_formatter.cpp 183 </li><li>  V557 Array-Überlauf ist möglich.  Der 'num'-Index zeigt über die Array-Grenze hinaus.  newcleanupp.cpp 13035 </li></ul><br><h2>  Wie man Misstrauen gegenüber Funktionen verdient </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/029/c18/147029c18e4ccacc04f11f688084034f.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V570</a> Die Variable 'm_onClickFunction' wird sich selbst zugewiesen.  alngraphic.hpp 103 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOnClickFunctionName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> onClickFunction)</span></span></span><span class="hljs-function"> </span></span>{ m_onClickFunction = m_onClickFunction; }</code> </pre> <br>  Es gibt nichts zu kommentieren.  Sie können nur mit der Person sympathisieren, die auf etwas geklickt, geklickt, aber nichts geändert hat. <br><br>  Zwei weitere Fälle, in denen mir Variablen zugewiesen werden, führen zu einer Liste: <br><br><ul><li>  V570 Die Variable 'iter-&gt; level' wird sich selbst zugewiesen.  align_format_util.cpp 189 </li><li>  V570 Die Variable 'd_elements_values ​​[ind]' wird sich selbst zugewiesen.  sls_alp_data.cpp 1416 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V763 Der</a> Parameter 'w1' wird vor seiner Verwendung immer in den Funktionskörper umgeschrieben.  bmfunc.h 5363 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Bit COUNT functor template&lt;typename W&gt; struct bit_COUNT { W operator()(W w1, W w2) { w1 = 0; BM_INCWORD_BITCOUNT(w1, w2); return w1; } };</span></span></code> </pre> <br>  Eine Funktion, bei der das Argument unmittelbar nach Eingabe der Funktion ausgefranst ist, kann für die Entwickler, die sie verwenden, irreführend sein.  Der Code sollte doppelt überprüft werden. <br><br><h2>  Klassendesignfehler </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/033/e75/06c/033e7506c36604696731f73024f57c78.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V688</a> Das Funktionsargument 'm_qsrc' hat denselben Namen wie eines der Klassenmitglieder, was zu Verwirrung führen kann.  compart_matching.cpp 873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CElementaryMatching</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CObject { .... ISequenceSource * m_qsrc; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateIndex</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode index_more, ....)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateRemapData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode mode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_LoadRemapData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; sdb)</span></span></span></span>; .... };</code> </pre> <br>  Sofort enthalten 3 Klassenfunktionen Argumente, deren Namen mit dem Klassenfeld übereinstimmen.  Dies kann zu Fehlern in Funktionskörpern führen: Der Programmierer glaubt möglicherweise, mit einem Mitglied der Klasse zu arbeiten, und ändert tatsächlich den Wert der lokalen Variablen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V614</a> Nicht initialisierte Variable 'm_BitSet' verwendet.  SnpBitAttributes.hpp 187 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// SNP bit attribute container. class CSnpBitAttributes { public: .... private: /// Internal storage for bits. Uint8 m_BitSet; }; inline CSnpBitAttributes::CSnpBitAttributes(Uint8 bits) : m_BitSet(bits) { } inline CSnpBitAttributes::CSnpBitAttributes(const vector&lt;char&gt;&amp; octet_string) { auto count = sizeof(m_BitSet); auto byte = octet_string.end(); do m_BitSet = (m_BitSet &lt;&lt; 8) | *--byte; while (--count &gt; 0); }</span></span></code> </pre> <br>  Einer der Konstruktoren arbeitet <i>schlampig</i> mit der Variablen <i>m_BitSet</i> .  Tatsache ist, dass die Variable nicht initialisiert ist.  Sein "Garbage" -Wert wird bei der ersten Iteration der Schleife verwendet, wonach die Initialisierung erfolgt.  Dies ist ein sehr schwerwiegender Fehler, der zu undefiniertem Programmverhalten führt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V603</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; SIntervalComparisonResult :: SIntervalComparisonResult (....)' verwendet werden.  compare_feats.hpp 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//This struct keeps the result of comparison of two exons struct SIntervalComparisonResult : CObject { public: SIntervalComparisonResult(unsigned pos1, unsigned pos2, FCompareLocs result, int pos_comparison = 0) : m_exon_ordinal1(pos1), m_exon_ordinal2(pos2), m_result(result), m_position_comparison(pos_comparison) {} SIntervalComparisonResult() { SIntervalComparisonResult(0, 0, fCmp_Unknown, 0); } .... };</span></span></code> </pre> <br>  Vor sehr langer Zeit bin ich bei der Überprüfung von Projekten nicht auf solche Fehler gestoßen.  Das Problem ist aber immer noch relevant.  Der Fehler besteht darin, dass beim Aufrufen des parametrisierten Konstruktors auf diese Weise ein temporäres Objekt erstellt und entfernt wird.  Und die Klassenfelder bleiben nicht initialisiert.  Ein anderer Konstruktor sollte über die Initialisierungsliste aufgerufen werden (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Delegieren des Konstruktors</a> ). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V591</a> Non-void-Funktion sollte einen Wert zurückgeben.  bio_tree.hpp 266 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Recursive assignment CBioNode&amp; operator=(const CBioNode&amp; tree) { TParent::operator=(tree); TBioTree* pt = (TBioTree*)tree.GetParentTree(); SetParentTree(pt); }</span></span></code> </pre> <br>  Der Analysator geht davon aus, dass die Zeile in der überladenen Anweisung fehlt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V670</a> Das nicht initialisierte Klassenmitglied 'm_OutBlobIdOrData' wird zum Initialisieren des 'm_StdOut'-Mitglieds verwendet.  Denken Sie daran, dass Mitglieder in der Reihenfolge ihrer Deklarationen innerhalb einer Klasse initialisiert werden.  remote_app.hpp 215 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCBI_XCONNECT_EXPORT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CRemoteAppResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CRemoteAppResult(CNetCacheAPI::TInstance netcache_api, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_inline_size = kMaxBlobInlineSize) : m_NetCacheAPI(netcache_api), m_RetCode(<span class="hljs-number"><span class="hljs-number">-1</span></span>), m_StdOut(netcache_api, m_OutBlobIdOrData, m_OutBlobSize), m_OutBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StdErr(netcache_api, m_ErrBlobIdOrData, m_ErrBlobSize), m_ErrBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StorageType(eBlobStorage), m_MaxInlineSize(max_inline_size) { } .... };</code> </pre> <br>  3 Analysatorwarnungen werden sofort an dieses Codefragment ausgegeben.  Klassenfelder werden nicht in der Reihenfolge initialisiert, in der sie in der Initialisierungsliste aufgeführt sind, sondern so, wie sie in der Klasse deklariert sind.  Die klassische Fehlerursache ist, dass sich nicht alle Programmierer an diese Regel erinnern oder sie kennen.  Hier und in der Initialisierungsliste ist nur die falsche Reihenfolge.  Man hat das Gefühl, dass die Liste der Felder in zufälliger Reihenfolge eingegeben wurde. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V746</a> Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 247 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CMultiAligner::SetQueries(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; CRef&lt;objects::CBioseq&gt; &gt;&amp; queries) { .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { seq_loc-&gt;SetId(*it-&gt;GetSeqId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (objects::CObjMgrException e) { NCBI_THROW(CMultiAlignerException, eInvalidInput, (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)<span class="hljs-string"><span class="hljs-string">"Missing seq-id in bioseq. "</span></span> + e.GetMsg()); } m_tQueries.push_back(seq_loc); .... }</code> </pre> <br>  Das Abfangen von Ausnahmen nach Wert kann zum Verlust einiger Informationen über die Ausnahme führen, da ein neues Objekt erstellt wird.  Es ist viel besser und sicherer, eine Ausnahme als Referenz zu erfassen. <br><br>  Ähnliche Orte: <br><br><ul><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  agp_validate_reader.cpp 562 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  aln_build_app.cpp 320 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  aln_test_app.cpp 458 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 691 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 719 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 728 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 732 </li></ul><br><h2>  Informationen zu nicht erreichbarem Code und anderen Problemen bei der Codeausführung </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/8f5/263/1d18f52633776adc7ca32f92446c4b9f.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V779</a> Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  merge_tree_core.cpp 627 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CMergeTree::x_FindBefores_Up_Iter(....) { .... FirstFrame-&gt;Curr = StartCurr; FirstFrame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FirstFrame-&gt;VisitCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; FrameStack.push_back(FirstFrame); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!FrameStack.empty()) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eAfter) { Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FrameStack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eBefore) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Frame-&gt;VisitCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= FrameStack.pop_back(); continue; } // end stack loop FirstFrame-&gt;ChildFrames.clear(); return FirstFrame-&gt;Returned; }</span></span></code> </pre> <br>  Der Code der bedingten Anweisung ist so geschrieben, dass absolut alle Zweige des Codes mit der <i>continue-</i> Anweisung enden.  Dies führte dazu, dass sich in der <i>while-Schleife</i> mehrere Zeilen nicht erreichbaren Codes bildeten.  Diese Zeilen sehen sehr verdächtig aus.  Dieses Problem trat höchstwahrscheinlich nach der Überarbeitung des Codes auf und erfordert nun eine sorgfältige Codeüberprüfung. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V519</a> Der Variablen 'interval_width' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  Überprüfen Sie die Zeilen: 454, 456. aln_writer.cpp 456 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CAlnWriter::AddGaps(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(exon_chunk-&gt;Which()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Match: interval_width = exon_chunk-&gt;GetMatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Mismatch: interval_width = exon_chunk-&gt;GetMismatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Diag: interval_width = exon_chunk-&gt;GetDiag(); genomic_string.append(....); product_string.append(....); genomic_pos += interval_width; product_pos += interval_width/res_width; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... }</code> </pre> <br>  Die Variable <i>interval_width wird</i> mehrmals überschrieben, weil  In Fallzweigen gibt es keine <i>break-</i> Anweisungen.  Obwohl ein Klassiker, aber ein sehr schlimmer Fehler. <br><br>  Noch ein paar verdächtige Orte: <br><br><ul><li>  V779 Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  dbapi_driver_utils.cpp 351 </li><li>  V779 Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  net.c 780 </li><li>  V779 Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  bcp.c 1495 </li><li>  V779 Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  remote_blast.cpp 1470 </li><li>  V779 Nicht erreichbarer Code erkannt.  Möglicherweise liegt ein Fehler vor.  remote_blast.cpp 1522 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V571</a> Wiederkehrende Prüfung.  Die Bedingung 'if (m_QueryOpts-&gt; filter_options)' wurde bereits in Zeile 703 überprüft. Blast_options_local_priv.hpp 713 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastOptionsLocal::SetFilterString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* f) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_QueryOpts-&gt;filtering_options) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { SBlastFilterOptions* old_opts = m_QueryOpts-&gt;filtering_options; m_QueryOpts-&gt;filtering_options = NULL; SBlastFilterOptionsMerge(&amp;(m_QueryOpts-&gt;filtering_options), old_opts, new_opts); old_opts = SBlastFilterOptionsFree(old_opts); new_opts = SBlastFilterOptionsFree(new_opts); } else { if (m_QueryOpts-&gt;filtering_options) // &lt;= m_QueryOpts-&gt;filtering_options = SBlastFilterOptionsFree(m_QueryOpts-&gt;filtering_options); m_QueryOpts-&gt;filtering_options = new_opts; new_opts = NULL; } .... }</span></span></code> </pre> <br>  Offensichtlich muss der Zweig <i>else neu geschrieben</i> werden.  Ich habe einige Ideen, die ich mit dem Zeiger <i>m_QueryOpts-&gt; filtering_options machen wollte</i> , aber der Code ist immer noch irgendwie verwirrend.  Ich appelliere an die Autoren des Kodex. <br><br>  Nun, das Problem kommt nicht alleine: <br><br><ul><li>  V571 Wiederkehrende Prüfung.  Die Bedingung 'if (Schlafzeit)' wurde bereits in Zeile 205 überprüft. Request_control.cpp 208 </li><li>  V571 Wiederkehrende Prüfung.  Die Bedingung 'if (assignValue.empty ())' wurde bereits in Zeile 712 überprüft. Classstr.cpp 718 </li></ul><br><h2>  Datenlesefehler </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/761/548/f6b/761548f6b44470fe7b64db8ce0b0eb11.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V739</a> EOF sollte nicht mit einem Wert vom Typ 'char' verglichen werden.  Der 'linestring [0]' sollte vom Typ 'int' sein.  alnread.c 3509 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EBool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_AfrpInitLineData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* linestring = readfunc (pfile); .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (linestring != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; linestring [</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] != EOF) { s_TrimSpace (&amp;linestring); .... } .... }</span></span></span></span></code> </pre> <br>  Zeichen, die Sie mit EOF vergleichen möchten, sollten nicht in <i>Zeichenvariablen</i> gespeichert werden.  Andernfalls besteht die Gefahr, dass aus einem Zeichen mit dem Wert 0xFF (255) -1 wird und wie am Ende einer Datei (EOF) interpretiert wird.  Auch (nur für den Fall) lohnt es sich, die Implementierung der <i>Readfunc-</i> Funktion zu überprüfen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V663</a> Endlosschleife ist möglich.  Die Bedingung 'cin.eof ()' reicht nicht aus, um die Schleife zu verlassen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie dem bedingten Ausdruck möglicherweise den Funktionsaufruf 'cin.fail ()' hinzu. </font><font style="vertical-align: inherit;">ncbicgi.cpp 1564</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream CNcbiIstream; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CCgiRequest::Serialize(CNcbiOstream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... CNcbiIstream* istrm = GetInputStream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrm) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!istrm-&gt;eof()) { istrm-&gt;read(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); os.write(buf, istrm-&gt;gcount()); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator hat einen möglichen Fehler festgestellt, aufgrund dessen eine Endlosschleife auftreten kann. </font><font style="vertical-align: inherit;">Wenn beim Lesen von Daten ein Fehler auftritt, gibt der Aufruf der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eof ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false zurück</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Um die Schleife in diesem Fall abzuschließen, ist eine zusätzliche Überprüfung des von der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fail () zurückgegebenen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werts erforderlich </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Fehler </font></font></h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/132/51d/701/13251d701a22cae67c852d1bed7d33a5.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V502</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vielleicht arbeitet der Operator '?:' Anders als erwartet. </font><font style="vertical-align: inherit;">Der Operator '?:' Hat eine niedrigere Priorität als der Operator '&amp;&amp;'. </font><font style="vertical-align: inherit;">ncbi_connutil.c 1135</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_ClientAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* client_host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*bool*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local_host)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((client_host == c &amp;&amp; x_IsSufficientAddress(client_host)) || !(ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)) || SOCK_ntoa(ip, addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)) != <span class="hljs-number"><span class="hljs-number">0</span></span> || !(s = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(client_host) + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(addr) + <span class="hljs-number"><span class="hljs-number">3</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client_host<span class="hljs-comment"><span class="hljs-comment">/*least we can do :-/*/</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achten Sie auf den Ausdruck: </font></font><br><br><pre> <code class="cpp hljs">!local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es wird nicht wie vom Programmierer erwartet berechnet, da der gesamte Ausdruck folgendermaßen aussieht: </font></font><br><br><pre> <code class="cpp hljs">ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(...)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operatorpriorität ist </font><font style="vertical-align: inherit;">höher als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aus diesem Grund wird der Code nicht wie beabsichtigt ausgeführt. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist wahrscheinlich besser, der Variablen 'seq' einen Wert zuzuweisen, als ihn erneut zu deklarieren. </font><font style="vertical-align: inherit;">Vorherige Deklaration: validator.cpp, Zeile 490. validator.cpp 492</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CValidator::IsSeqLocCorrectlyOrdered(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc&amp; loc, CScope&amp; scope) { CBioseq_Handle seq; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CBioseq_Handle seq = scope.GetBioseqHandle(loc); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CObjMgrException&amp; ) { <span class="hljs-comment"><span class="hljs-comment">// no way to tell return true; } catch (const exception&amp; ) { // no way to tell return true; } if (seq &amp;&amp; seq.GetInst_Topology() == CSeq_inst::eTopology_circular) { // no way to check if topology is circular return true; } return CheckConsecutiveIntervals(loc, scope, x_IsCorrectlyOrdered); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Programmierer eine neue </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">im try / catch-Abschnitt </font><font style="vertical-align: inherit;">deklariert </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">bleibt </font><font style="vertical-align: inherit;">die andere </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">nicht initialisiert und wird unten im Code verwendet. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist seltsam, einen Wert vom Typ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Bool</font></a><font style="vertical-align: inherit;"> mit einem Wert von 0 zu vergleichen: (((Status) &amp; 0x7f) == 0)! = 0. ncbi_process.cpp 111</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CProcess::CExitInfo::IsExited(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { EXIT_INFO_CHECK; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != eExitInfo_Terminated) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(NCBI_OS_UNIX) return WIFEXITED(status) != 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(NCBI_OS_MSWIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The process always terminates with exit code return true; #endif }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nichts war schlecht, aber WIFEXITED stellte sich auf diese Weise als Makroöffnung heraus: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((status) &amp; <span class="hljs-number"><span class="hljs-number">0x7f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass die Funktion den entgegengesetzten Wert zurückgibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Code gab es eine andere solche Funktion, die eine Warnung ausgab:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V562 Es ist seltsam, einen Wert vom Typ Bool mit einem Wert von 0 zu vergleichen. Ncbi_process.cpp 126 </font></font></li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Zeiger 'dst_len' wurde verwendet, bevor er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">Überprüfen Sie die Zeilen: 309, 315. zlib.cpp 309</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CZipCompression::CompressBuffer( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* src_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> src_len, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* dst_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> dst_size, <span class="hljs-comment"><span class="hljs-comment">/* out */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* dst_len) { *dst_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Check parameters if (!src_len &amp;&amp; !F_ISSET(fAllowEmptyData)) { src_buf = NULL; } if (!src_buf || !dst_buf || !dst_len) { SetError(Z_STREAM_ERROR, "bad argument"); ERR_COMPRESS(48, FormatErrorMessage("CZipCompression::CompressBuffer")); return false; } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zeiger </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ganz am Anfang der Funktion dereferenziert, während der Code weiter auf Gleichheit mit Null überprüft wird. </font><font style="vertical-align: inherit;">Im Code ist ein Fehler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgetreten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der zu undefiniertem Verhalten führt, wenn der Zeiger </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">nullptr</font></i><font style="vertical-align: inherit;"> ist </font><font style="vertical-align: inherit;">. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V590</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Überprüfen Sie den Ausdruck 'ch! =' \ 0 '&amp;&amp; ch ==' ''. </font><font style="vertical-align: inherit;">Der Ausdruck ist übertrieben oder enthält einen Druckfehler. </font><font style="vertical-align: inherit;">cleanup_utils.cpp 580</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Asn2gnbkCompressSpaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { ptr++; ch = *ptr; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedingung zum Stoppen der Schleife hängt nur davon ab, ob das Zeichen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ch ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leerzeichen ist oder nicht. </font><font style="vertical-align: inherit;">Der Ausdruck kann wie folgt vereinfacht werden:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { .... }</code> </pre> <br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung von Computerprogrammen in der wissenschaftlichen Forschung hilft und wird helfen, Entdeckungen zu machen. </font><font style="vertical-align: inherit;">Hoffen wir, dass besonders wichtige nicht durch Tippfehler übersehen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich lade die Entwickler des NCBI Genome Workbench-Projekts ein, sich mit uns in Verbindung zu setzen, und wir werden einen vollständigen Bericht des PVS-Studio-Analysators bereitstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, diese kleine Code-Recherche hilft, viele Fehler zu beheben und die Zuverlässigkeit des Projekts im Allgemeinen zu verbessern. </font><font style="vertical-align: inherit;">Versuchen Sie, PVS-Studio mit dem Code Ihrer Projekte auszuführen, falls Sie dies noch nicht getan haben. </font><font style="vertical-align: inherit;">Es könnte dir gefallen :).</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Svyatoslav Razmyslov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NCBI Genome Workbench: Wissenschaftliche Forschung unter Bedrohung</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430476/">https://habr.com/ru/post/de430476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430466/index.html">Mini AI Cup # 3: Einen Top Bot schreiben</a></li>
<li><a href="../de430468/index.html">Sensibilisierung der Bürger</a></li>
<li><a href="../de430470/index.html">Warum den Kontext auf dem Kundenkonto pflegen - ehrlich und profitabel</a></li>
<li><a href="../de430472/index.html">DIY nahtloses DECT-Netzwerk</a></li>
<li><a href="../de430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../de430478/index.html">Trading Bots für den Kryptowährungsmarkt. Wo soll ich anfangen?</a></li>
<li><a href="../de430480/index.html">Wie wir die Anwendung beim NASA Space Apps Challenge Hackathon geschrieben haben</a></li>
<li><a href="../de430482/index.html">Das Thema der Panzerplatten in der Kultur von Ost und West</a></li>
<li><a href="../de430484/index.html">Typische NGFW-Implementierungsszenarien</a></li>
<li><a href="../de430486/index.html">Wie Freiberufler leben: vom Entwickler zum technischen Texter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>