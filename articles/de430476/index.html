<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úä üëäüèæ üßìüèº NCBI Genome Workbench: Gef√§hrdete Forschung üë®üèø‚Äçü§ù‚Äçüë®üèæ üõåüèæ ü•ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Moderne Computertechnologien, technische und Softwarel√∂sungen - all dies erleichtert und beschleunigt die Umsetzung verschiedener wissenschaftlicher F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NCBI Genome Workbench: Gef√§hrdete Forschung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430476/"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/9dc/792/9ce9dc792e9661eba72b3692521754be.png" align="left">  Moderne Computertechnologien, technische und Softwarel√∂sungen - all dies erleichtert und beschleunigt die Umsetzung verschiedener wissenschaftlicher Forschungen erheblich.  Oft ist die Computersimulation die einzige M√∂glichkeit, viele Theorien zu testen.  Wissenschaftliche Software hat ihre eigenen Eigenschaften.  Beispielsweise wird eine solche Software h√§ufig sehr gr√ºndlichen Tests unterzogen, ist jedoch schlecht dokumentiert.  Software wird jedoch von Menschen geschrieben, und Menschen machen Fehler.  Fehler in wissenschaftlichen Programmen k√∂nnen die gesamte Forschung in Frage stellen.  In diesem Artikel werden Dutzende von Problemen aufgelistet, die im Code des NCBI Genome Workbench-Softwarepakets enthalten sind. <br><a name="habracut"></a><br><h2>  Einf√ºhrung </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die NCBI Genome Workbench</a> bietet Forschern eine breite Palette von Werkzeugen zum Studieren und Analysieren genetischer Daten.  Benutzer k√∂nnen Daten aus verschiedenen Quellen recherchieren und vergleichen, einschlie√ülich der NCBI-Datenbanken (National Center for Biotechnology Information) oder ihrer eigenen pers√∂nlichen Daten. <br><br>  Wie bereits erw√§hnt, wird wissenschaftliche Software in der Regel durch Unit-Tests gut abgedeckt.  Bei der √úberpr√ºfung dieses Projekts wurden 85 Verzeichnisse mit Testdateien von der Analyse ausgeschlossen.  Das sind ungef√§hr tausend Dateien.  M√∂glicherweise liegt dies an den Anforderungen zum Testen verschiedener komplexer Algorithmen, die f√ºr verschiedene Studien erfunden wurden.  Aber die Qualit√§t des restlichen Codes (nicht des Tests) ist nicht so hoch, wie wir es gerne h√§tten.  Wie in jedem Projekt, in dem sie sich noch nicht um die Einf√ºhrung statischer Code-Analyse-Tools gek√ºmmert haben :). <br><br>  Daten zur √úberpr√ºfung (oder sogar Recherche) des Codes wurden vom statischen Code-Analysator f√ºr C / C ++ / C # / Java - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> bereitgestellt. <br><br><h2>  Nur zwei Zahlen, die Ihr Projekt ruinieren </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dad/9f3/20b/dad9f320b84473428205cc1227a20fe6.png"></div><br><br>  Basierend auf unserer Fehlerdatenbank, die derzeit mehr als 12.000 ausgew√§hlte Beispiele umfasst, bemerken und beschreiben wir spezifische Muster zum Schreiben von Code, die zu zahlreichen Fehlern f√ºhren.  Zum Beispiel haben wir folgende Studien durchgef√ºhrt: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Wirkung der letzten Zeile</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die gef√§hrlichste Funktion in der Welt von C / C ++</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Logische Ausdr√ºcke in C / C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie falsch sind die Profis</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das B√∂se lebt in Vergleichsfunktionen</a> . </li></ol><br>  Dieses Projekt war der Beginn der Beschreibung des neuen Musters.  Wir sprechen √ºber die Nummern <b>1</b> und <b>2</b> in den Namen von Variablen, zum Beispiel <i>Datei1</i> und <i>Datei2</i> usw.  Es ist sehr leicht, zwei solche Variablen zu verwechseln.  Dies ist ein Sonderfall von Tippfehlern im Code, aber ein solcher Fehler f√ºhrt zu dem Wunsch, mit gleichnamigen Variablen zu arbeiten, die sich nur in den Nummern 1 und 2 am Ende des Namens unterscheiden. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass alle oben aufgef√ºhrten Studien im Code dieses Projekts best√§tigt wurden: D. <br><br>  Betrachten Sie das erste Beispiel aus dem Genome Workbench-Projekt: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdr√ºcke '(! Loc1.IsInt () &amp;&amp;! Loc1.IsWhole ())'.  Betreiber.  nw_aligner.cpp 480 <br><br><pre><code class="cpp hljs">CRef&lt;CSeq_align&gt; CNWAligner::Run(CScope &amp;scope, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc2, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trim_end_gaps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!loc1.IsInt() &amp;&amp; !loc1.IsWhole()) || (!loc1.IsInt() &amp;&amp; !loc1.IsWhole())) { NCBI_THROW(CException, eUnknown, <span class="hljs-string"><span class="hljs-string">"Only whole and interval locations supported"</span></span>); } .... }</code> </pre> <br>  Wir sehen zwei Variablen mit den Namen <i>loc1</i> und <i>loc2</i> .  Und auch ein Fehler im Code: Die Variable <i>loc2 wird</i> nicht verwendet, da stattdessen wieder <i>loc1</i> verwendet wird. <br><br>  Ein weiteres Beispiel: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> Ein Teil des bedingten Ausdrucks ist immer falsch: s1.IsSet ().  valid_biosource.cpp 3073 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_PCRPrimerSetLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; s1.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &lt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &gt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ..... }</code> </pre> <br>  In der ersten Codezeile wurden die Variablen <i>s1</i> und <i>s2 verwechselt</i> .  Basierend auf dem Namen ist dies eine Vergleichsfunktion.  Ein solcher Fehler kann jedoch √ºberall auftreten, da der Programmierer durch die Benennung der Variablen <i>Nummer 1</i> und <i>Nummer 2</i> mit ziemlicher Sicherheit in Zukunft einen Fehler machen wird.  Und je h√§ufiger solche Namen in einer Funktion verwendet werden, desto h√∂her ist die Wahrscheinlichkeit eines Fehlers. <br><br><h2>  Andere Tippfehler und Copy-Paste </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/d9f/f6b/6d5d9ff6bf8083922701b25273fa50b2.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom Operator '! =' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gibt</a> es identische Unterausdr√ºcke: bd.bit_.bits [i]! = Bd.bit_.bits [i] bm.h 296 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator_base&amp; ib)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;block_type_ == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.ptr != ib_db.bit_.ptr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.idx != ib_db.bit_.idx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.cnt != ib_db.bit_.cnt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.pos != ib_db.bit_.pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bd.bit_.cnt; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.bits[i] != bd.bit_.bits[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } .... }</code> </pre> <br>  Ich glaube, dass nach all den √úberpr√ºfungen die Gr√∂√üen der <i>Bit-</i> Arrays der <i>Objekte</i> <i>bd.bit_</i> und <i>ib_db.bit_</i> gleich sind.  Daher schrieb der Autor des Codes einen Zyklus f√ºr den elementweisen Vergleich des <i>Bit-</i> Arrays, machte jedoch einen Tippfehler im Namen eines der verglichenen Objekte.  Infolgedessen k√∂nnen verglichene Objekte in einigen Situationen f√§lschlicherweise als gleich angesehen werden. <br><br>  Dieses Beispiel verdient den Artikel "Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B√∂se lebt in Vergleichsfunktionen</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdr√ºcke 'CFieldHandler :: QualifierNamesAreEquivalent (Feld, kFieldTypeSeqId)'.  Betreiber.  field_handler.cpp 152 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CFieldHandlerFactory::s_IsSequenceIDField(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; field) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId) || CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  H√∂chstwahrscheinlich ist eine der Pr√ºfungen √ºberfl√ºssig.  Ich habe in den <i>Codevariablen</i> , die <i>kFieldTypeSeqId</i> √§hneln, <i>keine gefunden</i> .  Trotzdem ist aufgrund des Operators "||" ein zus√§tzlicher Funktionsaufruf m√∂glich, der die Leistung beeintr√§chtigt. <br><br>  Ein paar weitere Orte derselben Art mit einer Analysatorwarnung, die √ºberpr√ºft werden muss: <br><br><ul><li>  V501 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke 'uf-&gt; GetData (). IsBool ()'.  Variation_utils.cpp 1711 </li><li>  V501 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke 'uf-&gt; GetData (). IsBool ()'.  Variation_utils.cpp 1735 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V766</a> Ein Element mit demselben Schl√ºssel 'kArgRemote' wurde bereits hinzugef√ºgt.  blast_args.cpp 3262 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastAppArgs::x_IssueWarningsForIgnoredOptions(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CArgs&amp; args) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; can_override; .... can_override.insert(kArgOutputFormat); can_override.insert(kArgNumDescriptions); can_override.insert(kArgNumAlignments); can_override.insert(kArgMaxTargetSequences); can_override.insert(kArgRemote); <span class="hljs-comment"><span class="hljs-comment">// &lt;= can_override.insert(kArgNumThreads); can_override.insert(kArgInputSearchStrategy); can_override.insert(kArgRemote); // &lt;= can_override.insert("remote_verbose"); can_override.insert("verbose"); .... }</span></span></code> </pre> <br>  Der Analysator hat festgestellt, dass dem <i>eingestellten</i> Beh√§lter 2 identische Werte hinzugef√ºgt wurden.  Denken Sie daran, dass dieser Container nur eindeutige Werte speichert, sodass ihm keine Duplikate hinzugef√ºgt werden. <br><br>  Code wie der obige wird h√§ufig mit der Copy-Paste-Methode geschrieben.  M√∂glicherweise gibt es einfach einen zus√§tzlichen Wert, oder der Autor hat beim Kopieren vergessen, eine der Variablen umzubenennen.  Wenn Sie einen zus√§tzlichen Aufruf zum <i>Einf√ºgen</i> entfernen <i>, wird der</i> Code leicht optimiert, was jedoch nicht von Bedeutung ist.  Noch wichtiger ist, dass hier m√∂glicherweise ein schwerwiegender Fehler aufgrund eines fehlenden Elements in der Gruppe ausgeblendet wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V523</a> Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  vcf_reader.cpp 1105 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CVcfReader::xAssignFeatureLocationSet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_SetType == CVcfData::ST_ALL_DEL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_strRef.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); //-1 for 0-based, //another -1 for inclusive end-point ( ie [], not [) ) pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; } //default: For MNV's we will use the single starting point //NB: For references of size &gt;=2, this location will not //match the reference allele. Future Variation-ref //normalization code will address these issues, //and obviate the need for this code altogether. if (data.m_strRef.size() == 1) { //deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; }</span></span></code> </pre> <br>  Die Funktion enth√§lt gro√üe und vollst√§ndig identische Codefragmente.  Sie enthalten jedoch verschiedene begleitende Kommentare.  Der Code ist nicht optimal, verwirrend geschrieben und enth√§lt m√∂glicherweise einen Fehler. <br><br>  Die gesamte Liste der verd√§chtigen Orte mit der if-else-Anweisung sieht folgenderma√üen aus: <br><br><ul><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  blk.c 2142 </li><li>  V523 Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  odbc.c 379 </li><li>  V523 Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  odbc.c 1414 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  seqdbvol.cpp 1922 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  seqdb_demo.cpp 466 </li><li>  V523 Die Anweisung 'then' entspricht dem nachfolgenden Codefragment.  blast_engine.c 1917 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  blast_filter.c 420 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  blast_parameters.c 636 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  unordered_spliter.cpp 684 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  bme.cpp 333 </li><li>  V523 Die Anweisung 'then' entspricht der Anweisung 'else'.  gme.cpp 484 </li></ul><br><h2>  / * mit Sicherheit ist am besten pedantisch * / </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/df5/670/914df5670813e7eb410e446f60a0ed5e.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der Puffer 'passwd_buf' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PW_SZ 14 .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ntlm_v == 1) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* with security is best be pedantic */</span></span></span><span class="hljs-meta"> memset(hash, 0, sizeof(hash)); memset(passwd_buf, 0, sizeof(passwd_buf)); memset(ntlm2_challenge, 0, sizeof(ntlm2_challenge)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { .... } }</span></span></code> </pre> <br>  Wie Sie wahrscheinlich bereits vermutet haben, wurde im Abschnittstitel ein lustiger Kommentar zur Sicherheit durch Code verwendet. <br><br>  Kurz gesagt, die <i>Memset-</i> Funktion wird vom Compiler entfernt, da geleerte Puffer nicht mehr verwendet werden.  Und Daten wie <i>Hash</i> oder <i>passwd_buf</i> sind eigentlich keine Nullen.  Weitere Informationen zu diesem nicht offensichtlichen Compiler-Mechanismus finden Sie im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sicheres L√∂schen privater Daten</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'answer' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 561 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TDSRET </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds7_send_auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* for security reason clear structure */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;answer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TDSANSWER)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tds_flush_packet(tds); }</code> </pre> <br>  Dies war nicht das einzige Beispiel mit Kommentaren zu ‚ÄûSicherheit‚Äú.  Den Kommentaren nach zu urteilen, kann davon ausgegangen werden, dass Sicherheit f√ºr das Projekt wirklich wichtig ist.  Daher f√ºge ich die gesamte nicht kleine Liste der identifizierten Probleme bei: <br><br><ul><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das 'heap'-Objekt geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  ncbi_heapmgr.c 1300 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das 'context'-Objekt geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 167 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'ks' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 339 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'md5_ctx' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 353 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'Hash'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Challenge.c 365 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'ks' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 406 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'ntlm_v2_response' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  login.c 795 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'answer' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  login.c 801 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'Paket'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  numeric.c 256 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'Paket'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  numeric.c 110 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'pwd'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  getpassarg.c 50 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das 'context'-Objekt geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 188 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'buf'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 243 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der Puffer 'ntlm_v2_hash' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 309 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'md5_ctx' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 354 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der Puffer 'passwd_buf' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 380 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'ks' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 393 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der 'Hash'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 394 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem der Puffer 'ntlm2_challenge' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 395 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'ks' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 419 </li><li>  V597 Der Compiler k√∂nnte den Funktionsaufruf 'memset' l√∂schen, mit dem das Objekt 'ntlm_v2_response' gel√∂scht wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu l√∂schen.  Herausforderung.c 556 </li></ul><br><h2>  Verd√§chtige Zyklen </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/c77/124/8acc77124e5a13a1d25926c95d9eb2cf.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V534</a> Es ist wahrscheinlich, dass eine falsche Variable innerhalb des ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">for'</a> -Operators verglichen wird.  Betrachten Sie die √úberpr√ºfung von 'i'.  taxFormat.cpp 569 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTaxFormat::x_LoadTaxTree(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; alignTaxids.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tax_id = alignTaxids[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; taxInfo.seqInfoList.size(); j++) { SSeqInfo* seqInfo = taxInfo.seqInfoList[j]; seqInfo-&gt;taxid = newTaxid; } .... } .... }</code> </pre> <br>  Ich denke, im Zustand der inneren Schleife habe ich die Variable zuf√§llig erhalten.  Stattdessen sollte die Variable <i>j</i> verwendet werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V535</a> Die Variable 'i' wird f√ºr diese Schleife und f√ºr die √§u√üere Schleife verwendet.  √úberpr√ºfen Sie die Zeilen: 302, 309. sls_alp.cpp 309 <br><br><pre> <code class="cpp hljs">alp::~alp() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d_alp_states) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=d_nalp;i++) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if(i&lt;=d_alp_states-&gt;d_dim) { if(d_alp_states-&gt;d_elem[i]) { for(i=0;i&lt;=d_nalp;i++) // &lt;= { .... .... }</span></span></code> </pre> <br>  Zwei verschachtelte identische Zyklen, in denen auch der globale Z√§hler zur√ºckgesetzt wird, sehen sehr verd√§chtig aus.  Entwickler sollten √ºberpr√ºfen, was hier passiert. <br><br><h2>  Array-Indizierung abnormal </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/136/5b2/4a81365b2534c606f6d12df389841299.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V520</a> Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommaoperator</a> ',' im Array- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexausdruck</a> '[- i2, - k]'.  nw_spliced_aligner16.cpp 564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CSplicedAligner16::x_DoBackTrace ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Uint2* backtrace_matrix, CNWAligner::SAlignInOut* data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_global_max, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j_global_max) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(intron_length &lt; m_IntronMinSize || (Key &amp; donor) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Key = backtrace_matrix[--i2, --k]; ++intron_length; data-&gt;m_transcript.push_back(eTS_Intron); } .... }</code> </pre> <br>  Ich muss sofort sagen, dass es keinen Fehler zu geben scheint (vorerst lol).  Betrachten Sie die folgende Zeile: <br><br><pre> <code class="cpp hljs">Key = backtrace_matrix[--i2, --k];</code> </pre> <br>  Das Wort "Matrix" und die doppelte Indizierung k√∂nnen darauf hinweisen, dass das Array zweidimensional ist, dies ist jedoch nicht der Fall.  Dies ist ein regul√§rer Zeiger auf ein Array von Ganzzahlen.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V520-</a> Diagnose wurde jedoch nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> .  Programmierer sind wirklich verwirrt dar√ºber, wie zweidimensionale Arrays indiziert werden sollen. <br><br>  In diesem Fall hat der Autor einfach beschlossen, in einer Codezeile zu speichern, obwohl er folgenderma√üen schreiben k√∂nnte: <br><br><pre> <code class="cpp hljs">--i2; Key = backtrace_matrix[--k];</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V661</a> Ein verd√§chtiger Ausdruck 'A [B == C]'.  Bedeutete wahrscheinlich 'A [B] == C'.  ncbi_service_connector.c 180 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EHTTP_HeaderParse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_ParseHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* header, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header, <span class="hljs-string"><span class="hljs-string">"%u.%u.%u.%u%n"</span></span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;n) &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header + n, <span class="hljs-string"><span class="hljs-string">"%hu%x%n"</span></span>, &amp;uuu-&gt;port, &amp;tkt, &amp;m) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || (header[m += n] &amp;&amp; !(header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((header + m) [header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>])))) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span><span class="hljs-comment"><span class="hljs-comment">/*failed - unreadable connection info*/</span></span>; } .... }</code> </pre> <br>  Ein weiteres Beispiel f√ºr Code, in dem ich lange versucht habe zu verstehen, was vor sich geht: D.  Die Funktion <i>isspace ()</i> √ºberpr√ºft das Zeichen mit dem Index <i>m</i> . Wenn dieses Zeichen jedoch '$' ist, wird das Zeichen mit dem Index <i>m + 1</i> an die Funktion √ºbergeben.  Dar√ºber hinaus war der Vergleich mit '$' bereits im Voraus.  Vielleicht liegt hier kein Fehler vor, aber der Code kann definitiv klarer umgeschrieben werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V557</a> Array-√úberlauf ist m√∂glich.  Der 'Zeilen'-Index zeigt √ºber die Array-Grenze hinaus.  aln_reader.cpp 412 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CAlnReader::x_IsGap(TNumrow row, TSeqPos pos, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; residue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_MiddleSections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x_CalculateMiddleSections(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt; m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; m_MiddleSections[row].first) { .... } .... }</code> </pre> <br>  Hier liegt ein schwerwiegender Fehler vor.  Die korrekte √úberpr√ºfung des Zeilenindex sollte folgenderma√üen aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt;= m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Andernfalls ist es m√∂glich, auf Daten au√üerhalb des <i>MiddleSections-</i> Vektors <i>zuzugreifen</i> . <br><br>  Viele weitere solcher Orte: <br><br><ul><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'i'-Index zeigt √ºber die Array-Grenze hinaus.  resource_pool.hpp 388 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'Zeilen'-Index zeigt √ºber die Array-Grenze hinaus.  aln_reader.cpp 418 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der Index 'fmt_idx' zeigt √ºber die Array-Grenze hinaus.  seq_writer.cpp 384 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der Index 'fmt_idx' zeigt √ºber die Array-Grenze hinaus.  blastdb_formatter.cpp 183 </li><li>  V557 Array-√úberlauf ist m√∂glich.  Der 'num'-Index zeigt √ºber die Array-Grenze hinaus.  newcleanupp.cpp 13035 </li></ul><br><h2>  Wie man Misstrauen gegen√ºber Funktionen verdient </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/029/c18/147029c18e4ccacc04f11f688084034f.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V570</a> Die Variable 'm_onClickFunction' wird sich selbst zugewiesen.  alngraphic.hpp 103 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOnClickFunctionName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> onClickFunction)</span></span></span><span class="hljs-function"> </span></span>{ m_onClickFunction = m_onClickFunction; }</code> </pre> <br>  Es gibt nichts zu kommentieren.  Sie k√∂nnen nur mit der Person sympathisieren, die auf etwas geklickt, geklickt, aber nichts ge√§ndert hat. <br><br>  Zwei weitere F√§lle, in denen mir Variablen zugewiesen werden, f√ºhren zu einer Liste: <br><br><ul><li>  V570 Die Variable 'iter-&gt; level' wird sich selbst zugewiesen.  align_format_util.cpp 189 </li><li>  V570 Die Variable 'd_elements_values ‚Äã‚Äã[ind]' wird sich selbst zugewiesen.  sls_alp_data.cpp 1416 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V763 Der</a> Parameter 'w1' wird vor seiner Verwendung immer in den Funktionsk√∂rper umgeschrieben.  bmfunc.h 5363 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Bit COUNT functor template&lt;typename W&gt; struct bit_COUNT { W operator()(W w1, W w2) { w1 = 0; BM_INCWORD_BITCOUNT(w1, w2); return w1; } };</span></span></code> </pre> <br>  Eine Funktion, bei der das Argument unmittelbar nach Eingabe der Funktion ausgefranst ist, kann f√ºr die Entwickler, die sie verwenden, irref√ºhrend sein.  Der Code sollte doppelt √ºberpr√ºft werden. <br><br><h2>  Klassendesignfehler </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/033/e75/06c/033e7506c36604696731f73024f57c78.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V688</a> Das Funktionsargument 'm_qsrc' hat denselben Namen wie eines der Klassenmitglieder, was zu Verwirrung f√ºhren kann.  compart_matching.cpp 873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CElementaryMatching</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CObject { .... ISequenceSource * m_qsrc; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateIndex</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode index_more, ....)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateRemapData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode mode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_LoadRemapData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; sdb)</span></span></span></span>; .... };</code> </pre> <br>  Sofort enthalten 3 Klassenfunktionen Argumente, deren Namen mit dem Klassenfeld √ºbereinstimmen.  Dies kann zu Fehlern in Funktionsk√∂rpern f√ºhren: Der Programmierer glaubt m√∂glicherweise, mit einem Mitglied der Klasse zu arbeiten, und √§ndert tats√§chlich den Wert der lokalen Variablen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V614</a> Nicht initialisierte Variable 'm_BitSet' verwendet.  SnpBitAttributes.hpp 187 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// SNP bit attribute container. class CSnpBitAttributes { public: .... private: /// Internal storage for bits. Uint8 m_BitSet; }; inline CSnpBitAttributes::CSnpBitAttributes(Uint8 bits) : m_BitSet(bits) { } inline CSnpBitAttributes::CSnpBitAttributes(const vector&lt;char&gt;&amp; octet_string) { auto count = sizeof(m_BitSet); auto byte = octet_string.end(); do m_BitSet = (m_BitSet &lt;&lt; 8) | *--byte; while (--count &gt; 0); }</span></span></code> </pre> <br>  Einer der Konstruktoren arbeitet <i>schlampig</i> mit der Variablen <i>m_BitSet</i> .  Tatsache ist, dass die Variable nicht initialisiert ist.  Sein "Garbage" -Wert wird bei der ersten Iteration der Schleife verwendet, wonach die Initialisierung erfolgt.  Dies ist ein sehr schwerwiegender Fehler, der zu undefiniertem Programmverhalten f√ºhrt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V603</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen m√∂chten, sollte 'this-&gt; SIntervalComparisonResult :: SIntervalComparisonResult (....)' verwendet werden.  compare_feats.hpp 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//This struct keeps the result of comparison of two exons struct SIntervalComparisonResult : CObject { public: SIntervalComparisonResult(unsigned pos1, unsigned pos2, FCompareLocs result, int pos_comparison = 0) : m_exon_ordinal1(pos1), m_exon_ordinal2(pos2), m_result(result), m_position_comparison(pos_comparison) {} SIntervalComparisonResult() { SIntervalComparisonResult(0, 0, fCmp_Unknown, 0); } .... };</span></span></code> </pre> <br>  Vor sehr langer Zeit bin ich bei der √úberpr√ºfung von Projekten nicht auf solche Fehler gesto√üen.  Das Problem ist aber immer noch relevant.  Der Fehler besteht darin, dass beim Aufrufen des parametrisierten Konstruktors auf diese Weise ein tempor√§res Objekt erstellt und entfernt wird.  Und die Klassenfelder bleiben nicht initialisiert.  Ein anderer Konstruktor sollte √ºber die Initialisierungsliste aufgerufen werden (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Delegieren des Konstruktors</a> ). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V591</a> Non-void-Funktion sollte einen Wert zur√ºckgeben.  bio_tree.hpp 266 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Recursive assignment CBioNode&amp; operator=(const CBioNode&amp; tree) { TParent::operator=(tree); TBioTree* pt = (TBioTree*)tree.GetParentTree(); SetParentTree(pt); }</span></span></code> </pre> <br>  Der Analysator geht davon aus, dass die Zeile in der √ºberladenen Anweisung fehlt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V670</a> Das nicht initialisierte Klassenmitglied 'm_OutBlobIdOrData' wird zum Initialisieren des 'm_StdOut'-Mitglieds verwendet.  Denken Sie daran, dass Mitglieder in der Reihenfolge ihrer Deklarationen innerhalb einer Klasse initialisiert werden.  remote_app.hpp 215 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCBI_XCONNECT_EXPORT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CRemoteAppResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CRemoteAppResult(CNetCacheAPI::TInstance netcache_api, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_inline_size = kMaxBlobInlineSize) : m_NetCacheAPI(netcache_api), m_RetCode(<span class="hljs-number"><span class="hljs-number">-1</span></span>), m_StdOut(netcache_api, m_OutBlobIdOrData, m_OutBlobSize), m_OutBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StdErr(netcache_api, m_ErrBlobIdOrData, m_ErrBlobSize), m_ErrBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StorageType(eBlobStorage), m_MaxInlineSize(max_inline_size) { } .... };</code> </pre> <br>  3 Analysatorwarnungen werden sofort an dieses Codefragment ausgegeben.  Klassenfelder werden nicht in der Reihenfolge initialisiert, in der sie in der Initialisierungsliste aufgef√ºhrt sind, sondern so, wie sie in der Klasse deklariert sind.  Die klassische Fehlerursache ist, dass sich nicht alle Programmierer an diese Regel erinnern oder sie kennen.  Hier und in der Initialisierungsliste ist nur die falsche Reihenfolge.  Man hat das Gef√ºhl, dass die Liste der Felder in zuf√§lliger Reihenfolge eingegeben wurde. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V746</a> Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 247 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CMultiAligner::SetQueries(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; CRef&lt;objects::CBioseq&gt; &gt;&amp; queries) { .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { seq_loc-&gt;SetId(*it-&gt;GetSeqId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (objects::CObjMgrException e) { NCBI_THROW(CMultiAlignerException, eInvalidInput, (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)<span class="hljs-string"><span class="hljs-string">"Missing seq-id in bioseq. "</span></span> + e.GetMsg()); } m_tQueries.push_back(seq_loc); .... }</code> </pre> <br>  Das Abfangen von Ausnahmen nach Wert kann zum Verlust einiger Informationen √ºber die Ausnahme f√ºhren, da ein neues Objekt erstellt wird.  Es ist viel besser und sicherer, eine Ausnahme als Referenz zu erfassen. <br><br>  √Ñhnliche Orte: <br><br><ul><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  agp_validate_reader.cpp 562 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  aln_build_app.cpp 320 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  aln_test_app.cpp 458 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 691 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 719 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 728 </li><li>  V746 Objektschneiden.  Eine Ausnahme sollte eher durch Referenz als durch Wert abgefangen werden.  cobalt.cpp 732 </li></ul><br><h2>  Informationen zu nicht erreichbarem Code und anderen Problemen bei der Codeausf√ºhrung </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/8f5/263/1d18f52633776adc7ca32f92446c4b9f.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V779</a> Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  merge_tree_core.cpp 627 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CMergeTree::x_FindBefores_Up_Iter(....) { .... FirstFrame-&gt;Curr = StartCurr; FirstFrame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FirstFrame-&gt;VisitCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; FrameStack.push_back(FirstFrame); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!FrameStack.empty()) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eAfter) { Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FrameStack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eBefore) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Frame-&gt;VisitCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= FrameStack.pop_back(); continue; } // end stack loop FirstFrame-&gt;ChildFrames.clear(); return FirstFrame-&gt;Returned; }</span></span></code> </pre> <br>  Der Code der bedingten Anweisung ist so geschrieben, dass absolut alle Zweige des Codes mit der <i>continue-</i> Anweisung enden.  Dies f√ºhrte dazu, dass sich in der <i>while-Schleife</i> mehrere Zeilen nicht erreichbaren Codes bildeten.  Diese Zeilen sehen sehr verd√§chtig aus.  Dieses Problem trat h√∂chstwahrscheinlich nach der √úberarbeitung des Codes auf und erfordert nun eine sorgf√§ltige Code√ºberpr√ºfung. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V519</a> Der Variablen 'interval_width' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  √úberpr√ºfen Sie die Zeilen: 454, 456. aln_writer.cpp 456 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CAlnWriter::AddGaps(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(exon_chunk-&gt;Which()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Match: interval_width = exon_chunk-&gt;GetMatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Mismatch: interval_width = exon_chunk-&gt;GetMismatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Diag: interval_width = exon_chunk-&gt;GetDiag(); genomic_string.append(....); product_string.append(....); genomic_pos += interval_width; product_pos += interval_width/res_width; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... }</code> </pre> <br>  Die Variable <i>interval_width wird</i> mehrmals √ºberschrieben, weil  In Fallzweigen gibt es keine <i>break-</i> Anweisungen.  Obwohl ein Klassiker, aber ein sehr schlimmer Fehler. <br><br>  Noch ein paar verd√§chtige Orte: <br><br><ul><li>  V779 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  dbapi_driver_utils.cpp 351 </li><li>  V779 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  net.c 780 </li><li>  V779 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  bcp.c 1495 </li><li>  V779 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  remote_blast.cpp 1470 </li><li>  V779 Nicht erreichbarer Code erkannt.  M√∂glicherweise liegt ein Fehler vor.  remote_blast.cpp 1522 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V571</a> Wiederkehrende Pr√ºfung.  Die Bedingung 'if (m_QueryOpts-&gt; filter_options)' wurde bereits in Zeile 703 √ºberpr√ºft. Blast_options_local_priv.hpp 713 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastOptionsLocal::SetFilterString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* f) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_QueryOpts-&gt;filtering_options) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { SBlastFilterOptions* old_opts = m_QueryOpts-&gt;filtering_options; m_QueryOpts-&gt;filtering_options = NULL; SBlastFilterOptionsMerge(&amp;(m_QueryOpts-&gt;filtering_options), old_opts, new_opts); old_opts = SBlastFilterOptionsFree(old_opts); new_opts = SBlastFilterOptionsFree(new_opts); } else { if (m_QueryOpts-&gt;filtering_options) // &lt;= m_QueryOpts-&gt;filtering_options = SBlastFilterOptionsFree(m_QueryOpts-&gt;filtering_options); m_QueryOpts-&gt;filtering_options = new_opts; new_opts = NULL; } .... }</span></span></code> </pre> <br>  Offensichtlich muss der Zweig <i>else neu geschrieben</i> werden.  Ich habe einige Ideen, die ich mit dem Zeiger <i>m_QueryOpts-&gt; filtering_options machen wollte</i> , aber der Code ist immer noch irgendwie verwirrend.  Ich appelliere an die Autoren des Kodex. <br><br>  Nun, das Problem kommt nicht alleine: <br><br><ul><li>  V571 Wiederkehrende Pr√ºfung.  Die Bedingung 'if (Schlafzeit)' wurde bereits in Zeile 205 √ºberpr√ºft. Request_control.cpp 208 </li><li>  V571 Wiederkehrende Pr√ºfung.  Die Bedingung 'if (assignValue.empty ())' wurde bereits in Zeile 712 √ºberpr√ºft. Classstr.cpp 718 </li></ul><br><h2>  Datenlesefehler </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/761/548/f6b/761548f6b44470fe7b64db8ce0b0eb11.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V739</a> EOF sollte nicht mit einem Wert vom Typ 'char' verglichen werden.  Der 'linestring [0]' sollte vom Typ 'int' sein.  alnread.c 3509 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EBool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_AfrpInitLineData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* linestring = readfunc (pfile); .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (linestring != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; linestring [</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] != EOF) { s_TrimSpace (&amp;linestring); .... } .... }</span></span></span></span></code> </pre> <br>  Zeichen, die Sie mit EOF vergleichen m√∂chten, sollten nicht in <i>Zeichenvariablen</i> gespeichert werden.  Andernfalls besteht die Gefahr, dass aus einem Zeichen mit dem Wert 0xFF (255) -1 wird und wie am Ende einer Datei (EOF) interpretiert wird.  Auch (nur f√ºr den Fall) lohnt es sich, die Implementierung der <i>Readfunc-</i> Funktion zu √ºberpr√ºfen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V663</a> Endlosschleife ist m√∂glich.  Die Bedingung 'cin.eof ()' reicht nicht aus, um die Schleife zu verlassen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie dem bedingten Ausdruck m√∂glicherweise den Funktionsaufruf 'cin.fail ()' hinzu. </font><font style="vertical-align: inherit;">ncbicgi.cpp 1564</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream CNcbiIstream; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CCgiRequest::Serialize(CNcbiOstream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... CNcbiIstream* istrm = GetInputStream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrm) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!istrm-&gt;eof()) { istrm-&gt;read(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); os.write(buf, istrm-&gt;gcount()); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Analysator hat einen m√∂glichen Fehler festgestellt, aufgrund dessen eine Endlosschleife auftreten kann. </font><font style="vertical-align: inherit;">Wenn beim Lesen von Daten ein Fehler auftritt, gibt der Aufruf der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eof ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false zur√ºck</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Um die Schleife in diesem Fall abzuschlie√üen, ist eine zus√§tzliche √úberpr√ºfung des von der Funktion </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fail () zur√ºckgegebenen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Werts erforderlich </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Fehler </font></font></h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/132/51d/701/13251d701a22cae67c852d1bed7d33a5.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V502</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vielleicht arbeitet der Operator '?:' Anders als erwartet. </font><font style="vertical-align: inherit;">Der Operator '?:' Hat eine niedrigere Priorit√§t als der Operator '&amp;&amp;'. </font><font style="vertical-align: inherit;">ncbi_connutil.c 1135</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_ClientAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* client_host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*bool*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local_host)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((client_host == c &amp;&amp; x_IsSufficientAddress(client_host)) || !(ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)) || SOCK_ntoa(ip, addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)) != <span class="hljs-number"><span class="hljs-number">0</span></span> || !(s = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(client_host) + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(addr) + <span class="hljs-number"><span class="hljs-number">3</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client_host<span class="hljs-comment"><span class="hljs-comment">/*least we can do :-/*/</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achten Sie auf den Ausdruck: </font></font><br><br><pre> <code class="cpp hljs">!local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es wird nicht wie vom Programmierer erwartet berechnet, da der gesamte Ausdruck folgenderma√üen aussieht: </font></font><br><br><pre> <code class="cpp hljs">ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(...)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Operatorpriorit√§t ist </font><font style="vertical-align: inherit;">h√∂her als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aus diesem Grund wird der Code nicht wie beabsichtigt ausgef√ºhrt. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist wahrscheinlich besser, der Variablen 'seq' einen Wert zuzuweisen, als ihn erneut zu deklarieren. </font><font style="vertical-align: inherit;">Vorherige Deklaration: validator.cpp, Zeile 490. validator.cpp 492</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CValidator::IsSeqLocCorrectlyOrdered(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc&amp; loc, CScope&amp; scope) { CBioseq_Handle seq; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CBioseq_Handle seq = scope.GetBioseqHandle(loc); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CObjMgrException&amp; ) { <span class="hljs-comment"><span class="hljs-comment">// no way to tell return true; } catch (const exception&amp; ) { // no way to tell return true; } if (seq &amp;&amp; seq.GetInst_Topology() == CSeq_inst::eTopology_circular) { // no way to check if topology is circular return true; } return CheckConsecutiveIntervals(loc, scope, x_IsCorrectlyOrdered); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Programmierer eine neue </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">im try / catch-Abschnitt </font><font style="vertical-align: inherit;">deklariert </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">bleibt </font><font style="vertical-align: inherit;">die andere </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">nicht initialisiert und wird unten im Code verwendet. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist seltsam, einen Wert vom Typ </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Bool</font></a><font style="vertical-align: inherit;"> mit einem Wert von 0 zu vergleichen: (((Status) &amp; 0x7f) == 0)! = 0. ncbi_process.cpp 111</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CProcess::CExitInfo::IsExited(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { EXIT_INFO_CHECK; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != eExitInfo_Terminated) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(NCBI_OS_UNIX) return WIFEXITED(status) != 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(NCBI_OS_MSWIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The process always terminates with exit code return true; #endif }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nichts war schlecht, aber WIFEXITED stellte sich auf diese Weise als Makro√∂ffnung heraus: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((status) &amp; <span class="hljs-number"><span class="hljs-number">0x7f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellt sich heraus, dass die Funktion den entgegengesetzten Wert zur√ºckgibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Code gab es eine andere solche Funktion, die eine Warnung ausgab:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V562 Es ist seltsam, einen Wert vom Typ Bool mit einem Wert von 0 zu vergleichen. Ncbi_process.cpp 126 </font></font></li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Zeiger 'dst_len' wurde verwendet, bevor er gegen nullptr verifiziert wurde. </font><font style="vertical-align: inherit;">√úberpr√ºfen Sie die Zeilen: 309, 315. zlib.cpp 309</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CZipCompression::CompressBuffer( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* src_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> src_len, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* dst_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> dst_size, <span class="hljs-comment"><span class="hljs-comment">/* out */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* dst_len) { *dst_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Check parameters if (!src_len &amp;&amp; !F_ISSET(fAllowEmptyData)) { src_buf = NULL; } if (!src_buf || !dst_buf || !dst_len) { SetError(Z_STREAM_ERROR, "bad argument"); ERR_COMPRESS(48, FormatErrorMessage("CZipCompression::CompressBuffer")); return false; } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zeiger </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ganz am Anfang der Funktion dereferenziert, w√§hrend der Code weiter auf Gleichheit mit Null √ºberpr√ºft wird. </font><font style="vertical-align: inherit;">Im Code ist ein Fehler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgetreten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der zu undefiniertem Verhalten f√ºhrt, wenn der Zeiger </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len </font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">nullptr</font></i><font style="vertical-align: inherit;"> ist </font><font style="vertical-align: inherit;">. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V590</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberpr√ºfen Sie den Ausdruck 'ch! =' \ 0 '&amp;&amp; ch ==' ''. </font><font style="vertical-align: inherit;">Der Ausdruck ist √ºbertrieben oder enth√§lt einen Druckfehler. </font><font style="vertical-align: inherit;">cleanup_utils.cpp 580</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Asn2gnbkCompressSpaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { ptr++; ch = *ptr; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Bedingung zum Stoppen der Schleife h√§ngt nur davon ab, ob das Zeichen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ch ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leerzeichen ist oder nicht. </font><font style="vertical-align: inherit;">Der Ausdruck kann wie folgt vereinfacht werden:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { .... }</code> </pre> <br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung von Computerprogrammen in der wissenschaftlichen Forschung hilft und wird helfen, Entdeckungen zu machen. </font><font style="vertical-align: inherit;">Hoffen wir, dass besonders wichtige nicht durch Tippfehler √ºbersehen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich lade die Entwickler des NCBI Genome Workbench-Projekts ein, sich mit uns in Verbindung zu setzen, und wir werden einen vollst√§ndigen Bericht des PVS-Studio-Analysators bereitstellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, diese kleine Code-Recherche hilft, viele Fehler zu beheben und die Zuverl√§ssigkeit des Projekts im Allgemeinen zu verbessern. </font><font style="vertical-align: inherit;">Versuchen Sie, PVS-Studio mit dem Code Ihrer Projekte auszuf√ºhren, falls Sie dies noch nicht getan haben. </font><font style="vertical-align: inherit;">Es k√∂nnte dir gefallen :).</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Artikel einem englischsprachigen Publikum zug√§nglich machen m√∂chten, verwenden Sie bitte den Link zur √úbersetzung: Svyatoslav Razmyslov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NCBI Genome Workbench: Wissenschaftliche Forschung unter Bedrohung</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430476/">https://habr.com/ru/post/de430476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430466/index.html">Mini AI Cup # 3: Einen Top Bot schreiben</a></li>
<li><a href="../de430468/index.html">Sensibilisierung der B√ºrger</a></li>
<li><a href="../de430470/index.html">Warum den Kontext auf dem Kundenkonto pflegen - ehrlich und profitabel</a></li>
<li><a href="../de430472/index.html">DIY nahtloses DECT-Netzwerk</a></li>
<li><a href="../de430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../de430478/index.html">Trading Bots f√ºr den Kryptow√§hrungsmarkt. Wo soll ich anfangen?</a></li>
<li><a href="../de430480/index.html">Wie wir die Anwendung beim NASA Space Apps Challenge Hackathon geschrieben haben</a></li>
<li><a href="../de430482/index.html">Das Thema der Panzerplatten in der Kultur von Ost und West</a></li>
<li><a href="../de430484/index.html">Typische NGFW-Implementierungsszenarien</a></li>
<li><a href="../de430486/index.html">Wie Freiberufler leben: vom Entwickler zum technischen Texter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>