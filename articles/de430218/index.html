<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèø üëÉüèø üö¶ Energieoptimierung STM32: Ein praktischer Leitfaden ü§¥ üéóÔ∏è üë©‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Es gibt viele Artikel im Netzwerk √ºber den Betrieb von STM32-Mikrocontrollern in energieeffizienten Ger√§ten - normalerweise batteriebet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Energieoptimierung STM32: Ein praktischer Leitfaden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430218/"> Hallo Habr! <br><br>  Es gibt viele Artikel im Netzwerk √ºber den Betrieb von STM32-Mikrocontrollern in energieeffizienten Ger√§ten - normalerweise batteriebetriebenen Ger√§ten -, darunter ist es bedauerlich, dass sie dieses Thema au√üerhalb der Liste der Energiesparmodi und der SPL / HAL-Befehle, die sie enthalten, nicht verstehen (es gilt jedoch der gleiche Anspruch zu der √ºberwiegenden Mehrheit der Artikel √ºber die Arbeit mit STM32). <br><br>  In der Zwischenzeit gewinnt das Thema aufgrund der rasanten Entwicklung von Smart Homes und allen Arten von IoT zunehmend an Bedeutung. In solchen Systemen sind viele Komponenten batteriebetrieben, und von ihnen wird ein jahrelanger Dauerbetrieb erwartet. <br><br>  Wir werden diese L√ºcke am Beispiel des STM32L1 schlie√üen - eines sehr beliebten Controllers, der recht sparsam ist und gleichzeitig einige spezifische Probleme f√ºr diese Serie aufweist.  Fast alle der oben genannten Punkte gelten auch f√ºr STM32L0 und STM32L4 sowie in Bezug auf allgemeine Probleme und Ans√§tze f√ºr andere Steuerungen, die auf Cortex-M-Kernen basieren. <br><br><img src="https://habrastorage.org/webt/-r/az/lt/-razltjud_qdbwtc74aaopi69la.jpeg"><br><br>  Das praktische Ergebnis sollte ungef√§hr so ‚Äã‚Äãaussehen wie auf dem Foto oben (und ja, wir werden auch √ºber die Anwendbarkeit von Multimetern und anderen Messinstrumenten auf √§hnliche Aufgaben sprechen). <br><a name="habracut"></a><br><h3>  Energiesparmodi in STM32L1 </h3><br>  Die Grundlagen des Batteriesparens sind die wichtigsten Energiesparmodi des Prozessors.  Jeder Hersteller und jede Serie von Controllern hat ihre eigenen (ein spezifischer Satz ist eine Herstellererweiterung der Standard-Cortex-M-Kernmodi mit verschiedenen Nuancen in Bezug auf Peripherie, Versorgungsspannungen usw.). <br><br>  Insbesondere der STM32L1, der zur wirtschaftlichen Reihe von Steuerungen geh√∂rt und in dieser Hinsicht unter anderem einen erweiterten Satz von Leistungseinstellungen erhalten hat, hat Folgendes: <br><br><ul><li>  <b>Ausf√ºhren</b> - normaler Modus.  All inclusive, alle Peripherieger√§te verf√ºgbar, Frequenz bis 32 MHz. </li><li>  <b>Low Power Run (LP Run)</b> - ein spezieller Modus mit einer Betriebsfrequenz innerhalb von 131 kHz und einem maximalen Verbrauch unter <i>Ber√ºcksichtigung der gesamten Peripherie von</i> 200 ŒºA.  Im LP-Run-Modus wechselt der Prozessorleistungsregler in einen besonders wirtschaftlichen Modus, der bis zu f√ºnfzig Mikroampere spart, w√§hrend im Run-Modus mit derselben Frequenz gearbeitet wird. </li><li>  <b>Schlaf</b> - Suspendierung des Kernels, jedoch unter Beibehaltung aller Taktfrequenzen.  Die Prozessorperipherieger√§te k√∂nnen weiterarbeiten, wenn der Kernel sie nicht ben√∂tigt, sie k√∂nnen jedoch automatisch ausgeschaltet werden. </li><li>  <b>Low Power Sleep (LP Sleep)</b> - eine Kombination aus Sleep mit dem √úbergang des Stabilisators in den Economy-Modus.  Die Taktfrequenz ist nicht h√∂her als 131 kHz, der Gesamtverbrauch ist nicht h√∂her als 200 ŒºA. </li><li>  <b>Stopp</b> - ein vollst√§ndiger Stopp aller Taktfrequenzen mit Ausnahme des externen oder internen Taktgenerators 32768 Hz.  Im Fall von STM32L1 arbeitet in diesem Modus nur die Echtzeituhr weiter, alles andere stoppt vollst√§ndig.  In neueren Prozessoren k√∂nnen einige Peripherieger√§te mit niedrigen Frequenzen getaktet werden.  <i>Fast</i> alle Prozessorbeine behalten ihren Zustand.  Der Inhalt des RAM wird gespeichert, externe Interrupts funktionieren weiterhin. </li><li>  <b>Standby</b> - ein vollst√§ndiges Herunterfahren des Prozessorkerns, des Arbeitsspeichers und aller Peripherieger√§te mit Ausnahme von Echtzeituhren.  RAM wird nicht gespeichert (d. H. Aus Sicht der Software ist das Verlassen im Standby fast das Gleiche wie Leistungsverzerrung - von vorne beginnen), die RTC tickt weiter.  Externe Interrupts funktionieren nicht, mit Ausnahme von drei speziellen WKUPx-Beinen, deren Umschaltung von 0 auf 1 den Prozessor weckt. </li></ul><br>  Das Aufrufen der einzelnen Modi ist recht einfach: Sie m√ºssen die Flags in drei bis f√ºnf Registern setzen. Danach rufen Sie (f√ºr den Schlafmodus) den WFI- oder WFE-Befehl auf. Dies ist der Standard-Cortex-M-Befehl und bedeutet ‚ÄûAuf Unterbrechung warten‚Äú und ‚ÄûAuf Ereignis warten‚Äú. .  Abh√§ngig von den Flags (sie sind im Referenzhandbuch des Prozessors beschrieben, f√ºr STM32L1 ist es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RM0038</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√§llt</a> der Prozessor selbst mit diesem Befehl in diesen Modus. <br><br>  Au√üerdem w√§re es sch√∂n, Interrupts zu verbieten (dies hat keinen Einfluss auf die F√§higkeit externer und interner Ereignisse, den Prozessor aus dem Ruhezustand zu erwecken) und darauf zu warten, dass die Daten aus den Registern im Speicher gespeichert werden, wenn dies pl√∂tzlich mit dem DSB-Befehl geschieht. <br><br>  So sieht es beispielsweise aus, wenn Sie in den Stoppmodus wechseln: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  PDDS    Stop  Standby,    */</span></span> PWR-&gt;CR &amp;= ~(PWR_CR_PDDS); <span class="hljs-comment"><span class="hljs-comment">/*  Wakeup   ,      */</span></span> PWR-&gt;CR |= PWR_CR_CWUF; <span class="hljs-comment"><span class="hljs-comment">/*    low-power ,    Stop -    */</span></span> PWR-&gt;CR |= PWR_CR_LPSDSR; <span class="hljs-comment"><span class="hljs-comment">/*    Vref   */</span></span> PWR-&gt;CR |= PWR_CR_ULP; <span class="hljs-comment"><span class="hljs-comment">/*     Cortex-M,  Stop,  Standby -   Deep Sleep */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      Deep Sleep */</span></span> SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk); <span class="hljs-comment"><span class="hljs-comment">/*  ;       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> state = irq_disable(); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> __DSB(); <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> __WFI(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> init_clk(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> irq_restore(state);</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WFI</a> ist eine Blockierungsanweisung. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daraufhin</a> geht der Prozessor in den Tiefschlaf und verl√§sst ihn erst, wenn eine Unterbrechung auftritt.  Ja, ich wiederhole, obwohl wir Interrupts explizit deaktiviert haben, reagiert der Prozessor auf sie und wacht auf - aber die Verarbeitung beginnt erst, nachdem wir sie wieder eingeschaltet haben.  Und das hat eine tiefe Bedeutung. <br><br>  Im obigen Code geht nach WFI eine Art Neuinitialisierung der Betriebsfrequenzen nicht einfach so vor - Tatsache ist, dass L1 den Tiefschlaf immer bei einer Frequenz von 4,2 MHz und mit dem internen MSI-Generator als Quelle dieser Frequenz verl√§sst.  In vielen Situationen m√∂chten Sie nat√ºrlich nicht, dass der Interrupt-Handler, der den Prozessor aufweckt, mit dieser Frequenz startet - zum Beispiel, weil die Frequenzen aller Timer, UARTs und anderer Busse abfliegen.  Daher stellen wir zuerst die Betriebsfrequenzen wieder her (oder berechnen die erforderlichen Busse unter 4,2 MHz neu, wenn wir auf MSI bleiben m√∂chten) und tauchen dann in Interrupts ein. <br><br>  In der Praxis sind die beiden am h√§ufigsten verwendeten Modi Ausf√ºhren und Stoppen.  Tatsache ist, dass LP Run schmerzhaft langsam ist und keinen Sinn ergibt, wenn der Prozessor einige Berechnungen durchf√ºhren und nicht nur auf externe Ereignisse warten muss, und Sleep und LP Sleep nicht zu wirtschaftlich sind (Verbrauch bis zu 2 mA) und bei Bedarf ben√∂tigt werden Sparen Sie mindestens ein wenig, lassen Sie aber gleichzeitig die funktionierenden Peripherieger√§te und / oder sorgen Sie f√ºr die schnellstm√∂gliche Reaktion des Prozessors auf Ereignisse.  Solche Anforderungen existieren zwar, aber insgesamt nicht sehr oft. <br><br>  Der Standby-Modus wird normalerweise nicht verwendet, da es nach dem Nullsetzen des Arbeitsspeichers nicht m√∂glich ist, an der Stelle fortzufahren, an der Sie aufgeh√∂rt haben. Au√üerdem treten einige Probleme mit externen Ger√§ten auf, die im Folgenden erl√§utert werden und Hardwarel√∂sungen erfordern.  Wenn das Ger√§t jedoch unter diesem Gesichtspunkt entwickelt wurde, kann der Standby-Modus beispielsweise w√§hrend der Langzeitspeicherung dieses Ger√§ts als "Aus" -Modus verwendet werden. <br><br>  Tats√§chlich brechen die meisten Handb√ºcher bei der Pr√§sentation normalerweise triumphierend ab. <br><br>  Das Problem ist, dass Sie, wenn Sie ihnen folgen, traurige 100-200 ŒºA tats√§chlichen Verbrauchs anstelle der versprochenen 1,4 ŒºA in Stop mit den Arbeitsstunden erhalten - selbst beim Nucleo-Referenz-Debugging, das keine externen Chips, Sensoren usw. enth√§lt. dem es zugeschrieben werden k√∂nnte. <br><br>  Und nein, Ihr Prozessor funktioniert, es gibt nichts in Errata und Sie haben alles richtig gemacht. <br><br>  Nur nicht bis zum Ende. <br><br><h3>  Restless-Legs-Syndrom </h3><br>  Das erste Problem STM32L1, √ºber das <i>einige</i> Artikel sprechen, das sich aber oft nur in Foren erinnern, wenn am dritten Diskussionstag, woher die 100-200 ŒºA kamen, sich jemand an die Existenz von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AN3430 erinnert</a> und Seite 19 darin erreicht - dies Beine Zustand standardm√§√üig. <br><br>  Ich stelle fest, dass sich sogar STMicro selbst auf das Problem durch die H√ºllen bezieht und in den meisten Dokumenten, in denen die Optimierung des Energieverbrauchs in Betracht gezogen wird, auf ein oder zwei S√§tze beschr√§nkt ist, mit dem Rat, nicht verwendete Beine zu Boden zu ziehen oder in den analogen Eingabemodus zu versetzen, ohne die Gr√ºnde zu erl√§utern. <br><br>  Das Traurige ist, dass standardm√§√üig alle Beine als digitale Eing√§nge konfiguriert sind (0x00 im GPIOx_MODER-Register).  Ein Schmitt-Trigger befindet sich immer am digitalen Eingang, wodurch die St√∂rfestigkeit dieses Eingangs verbessert wird, w√§hrend er v√∂llig unabh√§ngig ist - es ist ein einfaches Logikelement, ein Puffer mit Hysterese, der keine externe Taktung erfordert. <br><br>  In unserem Fall bedeutet dies, dass wir die Uhr im Stoppmodus ausgeschaltet haben und die Schmitt-Trigger weiter funktionierten, als w√§re nichts passiert - je nach Pegel des Eingangssignals schalten sie ihre Ausg√§nge auf 0 und 1. <br><br>  Gleichzeitig h√§ngt ein Teil der Prozessorschenkel in einem typischen Schaltkreis in der Luft - das hei√üt, es ist kein verst√§ndliches Signal auf ihnen.  Es w√§re falsch zu glauben, dass das Fehlen eines klaren Signals bedeutet, dass auf diesen Beinen 0 aufgrund ihrer hohen Eingangsimpedanz kein zuf√§lliges Rauschen eines unbestimmten Werts von Tonabnehmern und Strom von benachbarten Spuren zum ersten Fernsehkanal flie√üt. Wenn der Fu√ü lang genug ist, um als Antenne zu dienen (analoge Fernsehger√§te in Russland werden jedoch bald ausgeschaltet, was zu einer gewissen Reduzierung des Stromverbrauchs falsch konfigurierter Mikrocontroller f√ºhren sollte). <br><br>  In √úbereinstimmung mit diesen Schwankungen schaltet der Zweig auf zuf√§llige Weise zwischen 0 und 1 um. Die CMOS-Logik verbraucht beim Schalten Strom.  Das hei√üt, ein <i>in der Luft h√§ngender Prozessorabschnitt, der im digitalen Eingabemodus konfiguriert ist, verbraucht an sich einen sp√ºrbaren Strom</i> . <br><br>  Der Ausweg ist einfach: Wenn Sie das Programm starten, m√ºssen Sie alle Beine auf den Status des Analogeingangs konfigurieren.  STM32 hat es formal f√ºr alle Beine ohne Ausnahme, unabh√§ngig davon, ob sie an den ADC angeschlossen sind oder nicht, und unterscheidet sich vom digitalen Eingang nur, wenn kein Schmitt-Trigger am Eingang vorhanden ist. <br><br><img src="https://habrastorage.org/webt/nm/k2/py/nmk2py-r1zqa2rgltekzx69bmy8.png"><br><br>  Dazu reicht es aus, den Wert 0xFF ... FF in alle GPIOx_MODER-Register zu schreiben. Dies ist, wie oben erw√§hnt, am einfachsten gleich zu Beginn, und dann werden Sie im Verlauf des Spiels die einzelnen Beine nach Bedarf in diesem Ger√§t neu konfigurieren. <br><br>  Hier tritt jedoch ein Problem zweiter Ordnung auf - es ist gut, wenn Ihre Firmware auf einem bestimmten Controller funktioniert und Sie daher immer wissen, was <i>x</i> in GPIOx ist.  Schlimmer noch, wenn die Firmware universell ist - der STM32 kann <i>bis zu</i> 8 Ports haben, aber kleiner sein;  Wenn Sie versuchen, auf einen Port zu schreiben, der in diesem Modell des Controllers nicht vorhanden ist, wird ein Hard Fault angezeigt, d. h.  Kernel-Absturz. <br><br>  Selbst dieser Fall kann umgangen werden. Mit Cortex-M k√∂nnen Sie die Adressen auf ihre G√ºltigkeit √ºberpr√ºfen. Im Fall von M3 und M4 ist die √úberpr√ºfung im Allgemeinen recht trivial, erfordert jedoch bei M0 etwas Magie, ist aber realisierbar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Details k√∂nnen hier gelesen werden</a> , wir werden diesen Artikel nicht f√§chern ) <br><br>  Das hei√üt, im Allgemeinen hat der Prozessor gestartet, die Frequenzen eingestellt - und sofort alle verf√ºgbaren GPIO-Ports durchlaufen und in MODER-Ports geschrieben (der folgende Code ist f√ºr RIOT OS geschrieben, aber im Allgemeinen ist er kommentarlos klar und kann auf drei Minuten √ºbertragen werden jede andere Plattform). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CPU_FAM_STM32L1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* switch all GPIOs to AIN mode to minimize power consumption */</span></span></span><span class="hljs-meta"> GPIO_TypeDef *port; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable GPIO clock */</span></span></span><span class="hljs-meta"> uint32_t ahb_gpio_clocks = RCC-&gt;AHBENR &amp; 0xFF; periph_clk_en(AHB, 0xFF); for (uint8_t i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 8; i++) { port = (GPIO_TypeDef *)(GPIOA_BASE + i*(GPIOB_BASE - GPIOA_BASE)); if (cpu_check_address((char *)port)) { port-&gt;MODER = 0xffffffff; } else { break; } } /* restore GPIO clock */ uint32_t tmpreg = RCC-&gt;AHBENR; tmpreg &amp;= ~((uint32_t)0xFF); tmpreg |= ahb_gpio_clocks; periph_clk_en(AHB, tmpreg); #endif</span></span></span></span></code> </pre><br>  Ich stelle fest, dass dies nur f√ºr die L1-Serie gilt. In L0 und L4 wurde die Erfahrung ber√ºcksichtigt, und sie konfigurieren standardm√§√üig alle Ports beim Start als analoge Eing√§nge. <br><br>  Nachdem Sie alle diese Verfahren sorgf√§ltig durchgef√ºhrt haben, f√ºllen Sie die Firmware in das fertige Ger√§t ... und erhalten 150 uA im Stoppmodus des Prozessors und aller externen Chips, die ausgeschaltet sind, obwohl Ihre Sch√§tzungen die pessimistischsten sind, die aus den Datenbl√§ttern f√ºr alles stammen, was Sie auf die Platine gel√∂tet haben Geben Sie nicht mehr als 10 ŒºA. <br><br>  Au√üerdem versuchen Sie dann, den Prozessor anstelle von Stop in den Standby-Modus zu versetzen, d. H.  Schalten Sie es einfach fast vollst√§ndig aus - und anstatt zu fallen, verdreifacht sich der Stromverbrauch und n√§hert sich fast einem halben Milliampere! <br><br>  Kein Grund zur Panik.  Wie Sie vielleicht erraten haben, haben Sie alles richtig gemacht.  Aber nicht bis zum Ende. <br><br><h3>  Restless Leg Syndrom - 2 </h3><br>  Das n√§chste Problem besteht aus zwei Teilen. <br><br>  Das erste liegt auf der Hand: Wenn Ihr Ger√§t nicht aus einem Mikrocontroller besteht, ist es wichtig, nicht zu vergessen, dass externe Chips auch Eingangssignale haben, an denen Schmitt-Trigger h√§ngen und die dar√ºber hinaus die interne Logik des Chips wecken k√∂nnen.  Beispielsweise versucht ein Chip, der vom UART-Team aus dem Ruhezustand gezogen und aus dem Ruhezustand entfernt wird, bei jeder Bewegung auf diesem Bus Daten daraus zu lesen. <br><br>  Wenn all diese Beine in der Luft h√§ngen, bekommen wir dementsprechend nichts Gutes. <br><br>  Unter welchen Bedingungen landen sie in der Luft? <br><br>  Erstens, wenn der Controller in den Standby-Modus wechselt, werden alle GPIOs mit hohem Widerstand in den High-Z-Zustand versetzt - das hei√üt, die an sie angeschlossenen externen Chips befinden sich in der Luft.  Es ist unm√∂glich, dies programmgesteuert in STM32L1 zu beheben (bei anderen Serien und anderen Controllern geschieht dies auf unterschiedliche Weise). Der einzige Ausweg besteht daher in einem System, das den Standby-Modus verwendet. Die Eing√§nge externer Chips m√ºssen gegen Masse gezogen oder von externen Widerst√§nden gespeist werden. <br><br>  Eine bestimmte Ebene wird so gew√§hlt, dass die Linie aus Sicht des Chips inaktiv ist: <br><br><ul><li>  1 f√ºr UART TX </li><li>  0 f√ºr SPI MOSI </li><li>  0 f√ºr SPI CLK im SPI-Modus 0 oder 1 </li><li>  1 f√ºr SPI CLK mit SPI-Modus 2 oder 3 </li><li>  1 f√ºr SPI CS </li></ul><br>  Zweitens kann auf STM32 <i>bei Verwendung des Stoppmodus</i> (sic!) <i>Der</i> Status der GPIOs, die mit den internen Hardwarebl√∂cken der Schnittstellen verbunden sind, unterschiedlich sein.  Das hei√üt, dieselbe SPI-Schnittstelle, wenn sie in Stop konfiguriert ist, stellt sich pl√∂tzlich entweder als digitaler Eingang oder im Allgemeinen als High-Z heraus - mit den entsprechenden Konsequenzen f√ºr externe Chips, die daran h√§ngen.  W√§hrend die Dokumentation besagt, dass die Beine in gutem Zustand sind, k√∂nnen Sie sich a priori nur darauf verlassen, wenn Sie Ihre Beine als regul√§re GPIOs verwenden. <br><br>  Sie k√∂nnen es nicht verstehen und verzeihen, aber Sie k√∂nnen es sich merken und beheben: F√ºr Schnittstellen, die sich auf diese Weise verhalten, m√ºssen Sie in der Schlafpflegefunktion ein erzwungenes Umschalten auf normales GPIO mit Pegeln hinzuf√ºgen, die inaktiven Ebenen dieser Schnittstelle entsprechen.  Nach dem Aufstehen k√∂nnen die Schnittstellen wiederhergestellt werden. <br><br>  Zum Beispiel das gleiche SPI vor dem Einschlafen (der Einfachheit halber nehme ich den Code aus dem RIOT-Betriebssystem, es ist klar, dass das gleiche einfach in Registern zu implementieren ist): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* specifically set GPIOs used for external SPI devices */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 0, MISO = AIN for SPI Mode 0 &amp; 1 (CPOL = 0) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 1, MISO = AIN for SPI Mode 2 &amp; 3 (CPOL = 1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SPI_NUMOF; i++) { <span class="hljs-comment"><span class="hljs-comment">/* check if SPI is in use */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_periph_clk(spi_config[i].apbbus, spi_config[i].rccmask) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* SPI CLK polarity */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spi_config[i].dev-&gt;CR1 &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>)) { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PU); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PD); } gpio_init(spi_config[i].mosi_pin, GPIO_IN_PD); gpio_init(spi_config[i].miso_pin, GPIO_AIN); } }</code> </pre><br>  Bitte beachten Sie, dass die Ausg√§nge hier nicht als GPIO_OUT mit Stufe 0 oder 1 konfiguriert sind, sondern als Eing√§nge mit einem Pull-up bis 0 oder 1 - dies ist kein grundlegender Punkt, bietet jedoch zus√§tzliche Sicherheit, wenn Sie einen Fehler machen und versuchen, Pull-Push mit einer Art von zu spielen Ein externer Chip zieht dieses Bein in die andere Richtung.  Mit GPIO_OUT k√∂nnen Sie einen Kurzschluss arrangieren, mit GPIO_IN mit einem Pull-up - niemals. <br><br>  Dar√ºber hinaus ist das SPI-CS-Signal nicht betroffen - in diesem Fall wird es programmgesteuert generiert, dh von einem normalen GPIO, und es beh√§lt seinen Zustand sicher in einem Traum. <br><br>  Um den Zustand des Beins beim Verlassen des Schlafes wiederherzustellen, reicht es aus, die Werte der Register, die ge√§ndert werden sollen (MODER, PUPDR, OTYPER, OSPEEDR - siehe die Situation in einem bestimmten Fall), am Eingang in Variablen zu schreiben und sie beim Verlassen des Schlafes in Register zur√ºckzusetzen . <br><br>  Und jetzt ... ta daaam!  Titelbild.  Eineinhalb Mikroampere. <br><br>  Aber es ist zu fr√ºh zum Feiern.  Damit haben wir die <i>statische</i> Optimierung des Energieverbrauchs abgeschlossen und liegen vor uns <i>dynamisch</i> . <br><br><h3>  Achilles gegen Schildkr√∂te </h3><br>  Was ist besser - mehr essen und schneller laufen oder weniger essen, aber langsamer laufen?  Bei Mikrocontrollern ist die Antwort auf diese Frage zweimal nicht trivial. <br><br>  Erstens k√∂nnen die Betriebsfrequenzen in einem sehr weiten Bereich ge√§ndert werden - von 65 kHz (LP Run) bis 32 MHz im Normalmodus.  Wie jeder CMOS-Chip hat STM32 zwei Komponenten im Stromverbrauch - statisch und dynamisch;  die zweite h√§ngt von der Frequenz ab, die erste ist konstant.  Infolgedessen sinkt der Energieverbrauch nicht so schnell wie die Betriebsfrequenz und Produktivit√§t, und je nach Aufgabe kann sich die aus Sicht der Energieeffizienz optimale Frequenz als unterschiedlich herausstellen - wenn Sie auf ein Ereignis warten m√ºssen, aber aus irgendeinem Grund nicht einschlafen k√∂nnen, wird dies der Fall sein Niedrige Frequenzen sind effektiv, wenn Sie nur Zahlen dreschen m√ºssen - hoch.  Bei typischen "Krankenhausdurchschnitt" -Aufgaben ist es normalerweise nicht sinnvoll, unter 2-4 MHz zu fallen. <br><br>  Zweitens, und dies ist ein weniger trivialer Moment, h√§ngt die Geschwindigkeit, mit der Sie aus dem Schlaf kommen, von der Arbeitsfrequenz und der Art und Weise ab, wie sie empfangen wird. <br><br>  Der schlimmste Fall ist, mit einer Frequenz von 32 MHz von einem externen Quarz aus dem Schlaf zu kommen (ich m√∂chte Sie daran erinnern, dass STM32L1 mit einem internen 4-MHz-Oszillator aufwacht), da er aus drei Stufen besteht: <br><br><ul><li>  Eigentlich wacht der Prozessor aus dem Schlaf auf </li><li>  Stabilisierung der Quarzerzeugung (1-24 MHz) </li><li>  Stabilisierung der PLL-Erzeugung (32 MHz) </li></ul><br>  Tats√§chlich ist es das kleinste Problem, den Prozessor hier aus dem Ruhezustand zu bringen. Bei einer Frequenz von 4,2 MHz dauert es ungef√§hr 10 Œºs.  Die Stabilisierung von Quarz kann jedoch bis zu 1 ms dauern (obwohl sie bei Hochgeschwindigkeitsresonatoren normalerweise noch schneller ist, in der Gr√∂√üenordnung von mehreren hundert Mikrosekunden), betr√§gt der Zugriff auf den PLL-Modus weitere 160 Œºs. <br><br>  Diese Verz√∂gerungen sind unter dem Gesichtspunkt des Energieverbrauchs f√ºr ein System, das selten aufwacht (nicht mehr als einmal pro Sekunde), m√∂glicherweise nicht signifikant. Wenn jedoch die Zeitspanne zwischen den Aufweckvorg√§ngen mehrere zehn Millisekunden und weniger betr√§gt und die Aufweckvorg√§nge selbst kurz sind, beginnt der Overhead sogar eine bereits messbare Addition unter Ber√ºcksichtigung, dass der Prozessor beim Aufwachen einen relativ kleinen Strom verbraucht. <br><br>  Was kann man damit machen?  Im Allgemeinen liegt die Antwort auf der Hand: Vermeiden Sie die Verwendung von externem Quarz.  Beispielsweise kann ein Programm, in dem es seltene schwere Unteraufgaben gibt, die eine genaue Taktung erfordern (z. B. die trivialen - UART-Datenaustausch), und h√§ufige einfache Unteraufgaben bei jedem Erwachen selbst entscheiden, ob es notwendig ist, zu gehen externer Quarz, oder es ist einfacher (und schneller!), die aktuelle Aufgabe auf dem MSI-Generator auszuf√ºhren, auf dem der Prozessor bereits aufgewacht ist, ohne viel Zeit f√ºr die Initialisierung der Frequenzen aufzuwenden. <br><br>  In diesem Fall kann es jedoch erforderlich sein, die Taktfrequenzen der Peripherie sowie die Zugriffsmodi auf den Flash-Speicher (die Anzahl der Verz√∂gerungszyklen), die Spannung des Prozessorkerns (in STM32L1 wird aus drei m√∂glichen Werten ausgew√§hlt) usw. anzupassen.  In Bezug auf die Kernel- und Speicherbetriebsarten ist es jedoch h√§ufig m√∂glich, diese durch Auswahl der f√ºr die maximal verwendete Frequenz empfohlenen zu optimieren, da ein nicht optimaler Betrieb des Kerns bei niedrigeren Frequenzen aufgrund des geringen Aufgabenvolumens bei diesen Frequenzen keine signifikante √Ñnderung der praktischen Leistung und des Stromverbrauchs bewirkt durchgef√ºhrt. <br><br>  Obwohl alle diese Ma√ünahmen bereits f√ºr die Feinabstimmung von Modi gelten (und zum Beispiel die meisten Betriebssysteme und Bibliotheken nicht einmal etwas in der N√§he der Box wissen), k√∂nnen sie in einigen F√§llen den Durchschnittsverbrauch auf einer Skala von Prozenteinheiten und manchmal sogar noch mehr senken.  Stellen Sie sich zum Beispiel einen Wasserz√§hler vor, der alle 50 ms die Kontakte eines Reed-Schalters abfragt, w√§hrend die eigentliche Vermessung mehrere zehn Mikrosekunden dauert. M√∂chten Sie bis zu diesem Zeitpunkt ~ 500 Œºs hinzuf√ºgen, um den Controller aufzuwecken? <br><br><h3>  Unertr√§glich lange Sekunde </h3><br>  Ein weiteres Problem, das nicht direkt mit der Energieeinsparung zusammenh√§ngt, sondern unvermeidlich damit zusammenh√§ngt - wie werden Zeitintervalle von weniger als 1 Sekunde gez√§hlt? <br><br>  Tatsache ist, dass es auf dem STM32L1 nur einen Timer gibt, der im Stoppmodus arbeitet - dies ist RTC, die Standardeinheit f√ºr 1 Sekunde.  Gleichzeitig gibt es in den Programmen st√§ndig Zeitintervalle von Einheiten, zehn und hundert Millisekunden, um mindestens denselben Wasserz√§hler zu nehmen. <br><br>  Wie man ist  Auf Prozessoren mit LPTIM-Timern laufen, die mit 32768 Hz getaktet sind?  Eine gute Option, aber nicht immer notwendig.  Es ist ohne es m√∂glich. <br><br>  Nicht bei allen STM32L1, aber beginnend mit Cat.  In 2 (dies sind die Prozessoren STM32L151CB-A, STM32L151CC und neuer) wurde der RTC-Block durch ein neues Register erg√§nzt - SSR, SubSeconds Register.  Genauer gesagt wurde es nicht so sehr erg√§nzt, als dass es f√ºr den Benutzer sichtbar gemacht wurde, und die Subsekundenalarme ALRMASSR und ALRMBSSR wurden hinzugef√ºgt. <br><br>  Dieses Register enth√§lt keine verst√§ndlichen Zeiteinheiten, es wurde von einem technischen internen Z√§hler erstellt.  In STM32L1 durchl√§uft ein Takt, der mit 32768 Hz tickt, zwei Teilerz√§hler, asynchron und synchron, die ihn normalerweise durch 32768 teilen, um einen Tick von 1 Sekunde f√ºr den Takt zu erhalten.  SSR ist also nur der aktuelle Wert des zweiten Z√§hlers. <br><br>  Obwohl die SSR nicht in Millisekunden, sondern in ihren Einheiten z√§hlt, kann die Dimension dieser Einheiten ge√§ndert werden, indem das Verh√§ltnis der Teiler des synchronen und asynchronen Z√§hlers ge√§ndert wird, w√§hrend ihr Gesamtkoeffizient gleich 32768 gehalten wird, um die Standard-1-Sekunde am RTC-Eingang zu erhalten.  Wenn wir diese Koeffizienten kennen, k√∂nnen wir den Preis einer SSR-Division in Millisekunden berechnen und von hier aus mit der Programmierung von Alarmen im Sekundentakt fortfahren. <br><br>  Es ist anzumerken, dass ein asynchroner Vorz√§hler wirtschaftlicher ist als ein synchroner SSR, und daher ist es energetisch nachteilig, ihn auf 1 zu setzen und die Eingangsfrequenz bereits durch 32768 in SSR zu teilen, nachdem er nur 30 Œºs gez√§hlt hat.  F√ºr uns haben wir den optimalen Wert f√ºr den vorl√§ufigen Teiler 7 f√ºr synchron - 4095 ((7 + 1) * (4095 + 1) = 32768) bestimmt.  Mit einer weiteren Abnahme des vorl√§ufigen Teilers beginnt der Energieverbrauch von RTC messbar zu wachsen - um einen Bruchteil einer Mikroampere, aber da wir dies mit der ‚ÄûReferenz‚Äú 1,4 ŒºA im Stoppmodus vergleichen, sind sogar die Fraktionen von Bedeutung.  Standardm√§√üig sind diese Werte f√ºr STM32L1 127 und 255, d. H.  Der Referenzpreis betr√§gt ca. 4 ms, was etwas rau ist. <br><br>  Wenn Sie tiefer in den Code eintauchen m√∂chten, haben wir zu gegebener Zeit <a href="">den Standard-RTC-Treiber</a> von RIOT OS fertiggestellt, um RTC_SSR- und Millisekundenintervalle zu unterst√ºtzen.  Seitdem verwenden wir es buchst√§blich bei jedem Schritt (und da wir im Betriebssystem arbeiten, h√§ngt auch ein Dienst dar√ºber, mit dem Sie fast eine beliebige Anzahl von Aufgaben mit beliebigen Zeitr√§umen mit einem Handgriff an einen Hardware-Timer h√§ngen k√∂nnen). <br><br>  Der gleiche Ansatz wird auf die Steuerungen STM32L0 und STM32L4 √ºbertragen, deren Modelle alle das Register RTC_SSR haben.  Dadurch werden keine LPTIM-Timer mehr ben√∂tigt und der Code f√ºr verschiedene Plattformen wird vereinheitlicht. <br><br><h3>  Wie man versteht, dass ein Multimeter l√ºgt </h3><br>  Nach all den Optimierungen stellt sich nat√ºrlich die berechtigte Frage: Was haben wir tats√§chlich erreicht?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne die Antwort darauf zu kennen, k√∂nnte man sich vollst√§ndig auf ein WFE mit korrekt konfigurierten Flags beschr√§nken, schlafen gehen und 200-500 ŒºA erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die traditionellste Methode zur Strommessung ist nat√ºrlich ein Multimeter. Zu verstehen, dass es mit seinem dynamischen Verbrauch wie ein Mikrocontroller auf einer Last liegt, ist sehr einfach - wenn es eingeschaltet ist, liegt es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet jedoch nicht, dass das Multimeter in dieser Angelegenheit unbrauchbar ist. Sie m√ºssen es nur anwenden k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens ist ein Multimeter eine sehr langsame Sache, eine typische Zeit f√ºr eine Z√§hlung ist eine zweite Skala, eine typische Zeit f√ºr die √Ñnderung des Zustands eines Mikrocontrollers ist eine Mikrosekunden-Skala. In einem System, das seinen Verbrauch in diesem Tempo √§ndert, zeigt das Multimeter einfach zuf√§llige Werte an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der f√ºr uns nicht zuf√§lligen Variablen ist jedoch der Verbrauch des Mikrocontrollers im Schlafmodus. Wenn es den auf Datenbl√§ttern gesch√§tzten Wert deutlich √ºberschreitet, stimmt eindeutig etwas nicht. Dies ist der Verbrauch eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statischen Systems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh er kann mit einem Multimeter gemessen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die trivialste Methode, die auf dem Titelfoto gezeigt wird, ist ein Multimeter im Mikroammetermodus, das jetzt in den meisten Modellen mit mittlerer Reichweite verwendet wird und eine gute Genauigkeit und hervorragende Aufl√∂sung aufweist. UT120C hat eine Aufl√∂sung von 0,1 ŒºA mit einer zertifizierten Genauigkeit von ¬± 1% ¬± 3 Entladungen, was f√ºr uns ausreicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Modus gibt es nur ein Problem: Die darin enthaltenen Multimeter haben einen gro√üen Serienwiderstand mit einer Skalierung von Hunderten von Ohm. Im normalen Modus startet der Mikrocontroller mit einem solchen Multimeter im Stromkreis einfach nicht. Gl√ºcklicherweise befinden sich die Positionen von "mA" und "uA" in fast allen Instrumenten auf der Waage in der N√§he. Die Buchsen f√ºr die Messung in beiden Bereichen sind gleich, sodass Sie den Controller sicher an der Grenze von "mA" starten k√∂nnen. Wenn er in den Ruhezustand wechselt, klicken Sie auf "uA" "- Dies geschieht schnell genug, damit der Controller keine Zeit hat, die Stromversorgung zu verlieren und neu zu starten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass diese Methode nicht anwendbar ist, wenn der Controller Aktivit√§tsspitzen aufweist. Beispielsweise wird der Watchdog-Timer in der Firmware des Ger√§ts alle 15 Sekunden zur√ºckgesetzt. In diesen Momenten zeigt das Multimeter etwas im Bereich von 27 ŒºA an, was nat√ºrlich nichts mit dem Wetter auf dem Mars zu tun hat. Wenn auf Ihrem System √∂fter als einmal alle 5-10 Sekunden etwas willk√ºrlich Kurzes auftritt, liegt das Multimeter einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere M√∂glichkeit, </font><b><font style="vertical-align: inherit;">statische</font></b><font style="vertical-align: inherit;"> Aufladung zu messen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ich hebe dieses Wort direkt hervor) Der Verbrauch durch ein Multimeter ist ein Ma√ü f√ºr den Sturz auf einen externen Shunt. Wenn Sie ultrakleine Str√∂me im Ma√üstab von einigen zehn Mikroampere messen m√∂chten, m√ºssen Sie einen gro√üen Shunt (z. B. 1 kOhm) parallel dazu schalten - eine Schottky-Diode in direkter Verbindung. Wenn der Shunt mehr als 0,3 V abf√§llt, √∂ffnet die Diode und begrenzt den Spannungsabfall. Bis zu 0,3 V k√∂nnen Sie den Abfall sicher mit einem Multimeter im Millivoltbereich von 1 mV = 1 ŒºA messen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider wird es nicht funktionieren, einen Abfall an einem Shunt mit niedriger Impedanz mit einem typischen Multimeter zu messen - Ger√§te der Mittelklasse sind in diesem Bereich ungl√ºcklich, selbst wenn sie etwas unter 100 ŒºV anzeigen. Wenn Sie ein gutes Desktop-Ger√§t haben, das 1 UV anzeigen kann, brauchen Sie meinen Rat nicht mehr.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Statik ist zwar gut, aber was ist mit der Dynamik? </font><font style="vertical-align: inherit;">Wie kann der gleiche Effekt verschiedener Frequenzen auf den durchschnittlichen Stromverbrauch bewertet werden? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist alles kompliziert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben wir die Grundvoraussetzungen auf:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Strombereich von mindestens 1 ŒºA - 100 mA (10 ^ 5) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Messdauer nicht mehr als 10 Œºs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spannungsabfall nicht h√∂her als 100 mV </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Messdauer - unbegrenzt </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir dies einfach direkt in Zahlen √ºbersetzen, erhalten wir einen relativ schnellen und nicht weniger als 18-Bit-ADC mit einer Eingangsvorspannung von weniger als 30 ŒºV, ein analoges Front-End, das Spannungen von 1 ŒºV messen kann, und eine schnelle Schnittstelle zum Computer, √ºber die wir all dies √ºbertragen k√∂nnen und speichern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das alles f√ºr einen einzigen Gebrauch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sehen, ja, warum liegen solche Dinge nicht an jeder Ecke von zehn Dollar? Keysight N6705C erf√ºllt in erster N√§herung unsere Anforderungen, kostet jedoch nur 7960 US-Dollar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Budgetl√∂sungen beispielsweise integriert SiLabs die aktuelle Messung in seine Debugs. Die Eigenschaften des Advanced Energy Monitoring (AEM) -Systems h√§ngen vom jeweiligen Debugging-Modell ab und sie haben das gr√∂√üte Problem mit der Messgeschwindigkeit. In den alten ‚ÄûStarter-Kits‚Äú betr√§gt der STK3300 / 3400 nur 100 Hz, in den neueren Debugs der STK3700 / 3800 (leicht erkennbar an schwarzem Textolith) - 6,25 kHz, und in √§lteren Debug-Modellen der DK-Serie kann er bis zu 10 kHz erreichen, kostet aber auch Sie sind bereits $ 300 +. F√ºr ernsthafte Aufgaben empfiehlt SiLabs offiziell die oben genannte Keysight.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Prinzip kann ein solches Ger√§t von Ihnen selbst entworfen werden - zun√§chst ben√∂tigen Sie sehr gute Operationsverst√§rker mit minimaler Eingangsvorspannung wie OPA2335. Solche Operationsverst√§rker werden auf den gleichen Shunt von 2-3 Teilen mit unterschiedlichen Verst√§rkungsfaktoren gelegt, alle werden auf unterschiedliche ADC-Eing√§nge gewickelt (bei diesem Ansatz ist es durchaus m√∂glich, den eingebauten Mikrocontroller zu verwenden), und dann wird bei jeder Datenerfassung programmgesteuert bestimmt, welcher der Operationsverst√§rker in einem bestimmten Bereich vorhanden ist Wenn der Moment nicht √ºberlastet ist, werden die Messwerte gez√§hlt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem der Geschwindigkeit der Daten√ºbertragung auf einen Computer ist ganz einfach zu l√∂sen - da wir aus praktischen Gr√ºnden in erster Linie am durchschnittlichen Verbrauch des Systems im realen Leben interessiert sind, k√∂nnen Mikrosekundenwerte im integrierten Mikrocontroller des Messger√§ts erfasst und der arithmetische Durchschnitt f√ºr einen angemessenen Millisekundenma√üstab gesendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus ist es, wie die Praxis zeigt, sehr n√ºtzlich, einen Z√§hlerlogger zu haben, der zwar einfach und nicht zu genau ist, aber immer zur Hand ist, um keine √úberraschungen mit einer durch Energiesparen unterbrochenen Firmware-√Ñnderung zu erhalten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel haben wir einen in unseren Standard-USB-Adapter UMDK-RF eingebaut, der beim Debuggen der Firmware st√§ndig verwendet wird. Er verf√ºgt bereits √ºber einen SWD-Programmierer mit Unterst√ºtzung f√ºr das DAPLink-Protokoll, eine USB-UART-Br√ºcke und eine Energieverwaltungslogik. Er verf√ºgt √ºber eine Verbrauchsanzeige fast kostenlos. Das Messger√§t selbst ist ein 1-Ohm-Shunt und ein INA213-Verst√§rker (50-fache Verst√§rkung, typischer Nullpunktversatz 5 ŒºV): Der </font></font><br><br><img src="https://habrastorage.org/webt/me/l_/dr/mel_drvu6rqzwr1bebtbtayfiiw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verst√§rker wird direkt an den Eingang des ADC des Mikrocontrollers (STM32F042F6P6) angeschlossen, der ADC verarbeitet √ºber einen Hardware-Timer mit einer Dauer von 10 Œºs und √ºber USB gemittelte Daten werden f√ºr ein Intervall von 100 ms ausgegeben. Wenn Sie also etwas an der Firmware-Logik √§ndern, k√∂nnen Sie einfach rauchen oder Kaffee trinken, das Ger√§t auf dem Tisch lassen und zur√ºckkehren. Sehen Sie sich einen Zeitplan wie diesen an:</font></font><br><br><img src="https://habrastorage.org/webt/qp/e2/h1/qpe2h1zrmci58iozay_rmag-lsm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Genauigkeit eines solchen ‚Äûfreien‚Äú Ger√§ts ist nat√ºrlich nicht hoch - mit einem 12-Bit-ADC und einem Verst√§rker betr√§gt das Mindestquantum 16 ŒºA, aber es ist √§u√üerst n√ºtzlich f√ºr eine schnelle und regelm√§√üige Bewertung des Verhaltens von debuggten Ger√§ten unter dem Gesichtspunkt des Energieverbrauchs. Wenn Sie am Ende etwas an der Firmware oder dem Ger√§t falsch machen, k√∂nnen Sie mit einer sehr hohen Garantie mindestens Hunderte von Mikroampere-Einheiten verlassen, was deutlich sichtbar ist. </font></font><br><br><img src="https://habrastorage.org/webt/np/kb/ko/npkbkoxcwb3xsmoyshtkjtc3-jq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer netter Bonus ist, dass Sie, da die Daten in Textform (Werte in Mikroampere) an den virtuellen COM-Port gesendet werden, das Terminalfenster neben dem Fenster mit der Ger√§tekonsole positionieren und gleichzeitig mit den Debug-Meldungen den Stromverbrauch anzeigen k√∂nnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich prahle aus einem bestimmten Grund damit, aber um jedem anzubieten, der diesen minimalen (und sehr billigen!) Debugger-Programmierer in seinen eigenen Projekten verwenden m√∂chte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Diagramm </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier</font></a><font style="vertical-align: inherit;"> zeichnen </font><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle in DipTrace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die Firmware </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herausziehen (umdk-rf-Brunch, wenn das Ziel UMDK-RF ist, basierend auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dap42-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt </font><font style="vertical-align: inherit;">). Das Diagramm ist chaotisch gezeichnet, aber ich hoffe, die Hauptpunkte sind klar, die Firmware wird mit libopencm3 in C geschrieben und mit dem √ºblichen arm-none-eabi-gcc zusammengesetzt. Als zus√§tzliche Funktionen verf√ºgt die Firmware √ºber eine Energieverwaltung, die Signale √ºber √úberlastung von Steuertasten abf√§ngt und den mit ihr verbundenen Controller per langem Dr√ºcken eines Knopfdrucks in ihren nativen Bootloader eingibt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NB: Wenn Sie m√∂chten, dass die Boot-Schaltfl√§che den eigenen Controller des Programmierers regelm√§√üig in den Bootloader bringt, muss die Polarit√§t der Verbindung ge√§ndert, die Optionsbytes-Bearbeitung des Controllers beim ersten Start und die Programmeingabe f√ºr den Bootloader entfernt und die Interrupt-Polarit√§t f√ºr den regul√§ren Bootloader entfernt werden Funktionen dieser Taste. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Hier</font></a><font style="vertical-align: inherit;"> (Seite 9) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen Sie sehen, wie der Strom an einem Operationsverst√§rkerpaar mit unterschiedlichen Verst√§rkungsfaktoren gemessen wird (z. B. um den oben f√ºr Ihre Aufgaben beschriebenen Debugger zu verbessern). Dies </font><font style="vertical-align: inherit;">ist eine traditionellere alternative Option - mit einem Operationsverst√§rker und einem teuren 24-Bit-ADC - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">TI hat es</font></a><font style="vertical-align: inherit;"> (EnergyTrace auf Seite 5).</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Bitte beachten Sie, dass beim Debuggen mit einem angeschlossenen UART oder JTAG / SWD auch ein kleiner Strom durch die Beine flie√üen kann, der w√§hrend des tats√§chlichen Betriebs des Ger√§ts nicht auftritt. </font><font style="vertical-align: inherit;">Bei UMDK-RF treten also etwa 15 ŒºA in die SWD aus (und daher werden auf dem Header-Foto Messungen mit einem Multimeter an der alten Version der Platine ohne SWD durchgef√ºhrt), und bei der STM32 Nucleo gab es F√§lle mit einem St√∂rstrom durch die SWD von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etwa 200 ŒºA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die f√ºr die Messung verwendeten Debug-Karten m√ºssen auf solche Funktionen √ºberpr√ºft werden - entweder durch Trennen ihrer Schnittstellenleitungen, wenn dies m√∂glich ist, oder durch Vergleichen der Ergebnisse mit dem gemessenen Verbrauch des Ger√§ts, ohne es zum Debuggen zu installieren, z. B. mit einem Multimeter im statischen Modus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstelle einer Schlussfolgerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich hoffe, Sie haben bereits verstanden, welchen Fehler Sie gemacht haben, als Sie die Mikrocontroller-Programmierung als Ihre Hauptspezialit√§t gew√§hlt haben. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430218/">https://habr.com/ru/post/de430218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430206/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: Privates Surfen im Internet, Teil 2</a></li>
<li><a href="../de430208/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: ‚ÄûPrivates Surfen im Internet‚Äú, Teil 3</a></li>
<li><a href="../de430210/index.html">Testen Sie meine Geduld mit der Check Point Security Academy</a></li>
<li><a href="../de430212/index.html">OpenSceneGraph: Grundlagen der Szenengeometrie</a></li>
<li><a href="../de430216/index.html">So wie ich es verstehe, esse ich viele S√º√üigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</a></li>
<li><a href="../de430220/index.html">Wie man einen "hundertj√§hrigen" USB-Hub in einen intelligent verwalteten verwandelt und 300 US-Dollar spart</a></li>
<li><a href="../de430222/index.html">Senior Engineer auf der Suche nach Arbeit. Wie ich 20 Interviews mit HR durchlaufen habe und was ich dar√ºber denke</a></li>
<li><a href="../de430224/index.html">Schizotypische St√∂rung: Ein Einblick</a></li>
<li><a href="../de430226/index.html">Von var b bis zum Interview</a></li>
<li><a href="../de430228/index.html">X-f√∂rmige Markierungen als Methode zur Radaridentifizierung mittels Open-Data-Analyse von zwei wissenschaftlichen Satelliten SENTINEL-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>