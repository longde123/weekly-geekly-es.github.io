<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏿 👃🏿 🚦 Energieoptimierung STM32: Ein praktischer Leitfaden 🤴 🎗️ 👩‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Es gibt viele Artikel im Netzwerk über den Betrieb von STM32-Mikrocontrollern in energieeffizienten Geräten - normalerweise batteriebet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Energieoptimierung STM32: Ein praktischer Leitfaden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430218/"> Hallo Habr! <br><br>  Es gibt viele Artikel im Netzwerk über den Betrieb von STM32-Mikrocontrollern in energieeffizienten Geräten - normalerweise batteriebetriebenen Geräten -, darunter ist es bedauerlich, dass sie dieses Thema außerhalb der Liste der Energiesparmodi und der SPL / HAL-Befehle, die sie enthalten, nicht verstehen (es gilt jedoch der gleiche Anspruch zu der überwiegenden Mehrheit der Artikel über die Arbeit mit STM32). <br><br>  In der Zwischenzeit gewinnt das Thema aufgrund der rasanten Entwicklung von Smart Homes und allen Arten von IoT zunehmend an Bedeutung. In solchen Systemen sind viele Komponenten batteriebetrieben, und von ihnen wird ein jahrelanger Dauerbetrieb erwartet. <br><br>  Wir werden diese Lücke am Beispiel des STM32L1 schließen - eines sehr beliebten Controllers, der recht sparsam ist und gleichzeitig einige spezifische Probleme für diese Serie aufweist.  Fast alle der oben genannten Punkte gelten auch für STM32L0 und STM32L4 sowie in Bezug auf allgemeine Probleme und Ansätze für andere Steuerungen, die auf Cortex-M-Kernen basieren. <br><br><img src="https://habrastorage.org/webt/-r/az/lt/-razltjud_qdbwtc74aaopi69la.jpeg"><br><br>  Das praktische Ergebnis sollte ungefähr so ​​aussehen wie auf dem Foto oben (und ja, wir werden auch über die Anwendbarkeit von Multimetern und anderen Messinstrumenten auf ähnliche Aufgaben sprechen). <br><a name="habracut"></a><br><h3>  Energiesparmodi in STM32L1 </h3><br>  Die Grundlagen des Batteriesparens sind die wichtigsten Energiesparmodi des Prozessors.  Jeder Hersteller und jede Serie von Controllern hat ihre eigenen (ein spezifischer Satz ist eine Herstellererweiterung der Standard-Cortex-M-Kernmodi mit verschiedenen Nuancen in Bezug auf Peripherie, Versorgungsspannungen usw.). <br><br>  Insbesondere der STM32L1, der zur wirtschaftlichen Reihe von Steuerungen gehört und in dieser Hinsicht unter anderem einen erweiterten Satz von Leistungseinstellungen erhalten hat, hat Folgendes: <br><br><ul><li>  <b>Ausführen</b> - normaler Modus.  All inclusive, alle Peripheriegeräte verfügbar, Frequenz bis 32 MHz. </li><li>  <b>Low Power Run (LP Run)</b> - ein spezieller Modus mit einer Betriebsfrequenz innerhalb von 131 kHz und einem maximalen Verbrauch unter <i>Berücksichtigung der gesamten Peripherie von</i> 200 μA.  Im LP-Run-Modus wechselt der Prozessorleistungsregler in einen besonders wirtschaftlichen Modus, der bis zu fünfzig Mikroampere spart, während im Run-Modus mit derselben Frequenz gearbeitet wird. </li><li>  <b>Schlaf</b> - Suspendierung des Kernels, jedoch unter Beibehaltung aller Taktfrequenzen.  Die Prozessorperipheriegeräte können weiterarbeiten, wenn der Kernel sie nicht benötigt, sie können jedoch automatisch ausgeschaltet werden. </li><li>  <b>Low Power Sleep (LP Sleep)</b> - eine Kombination aus Sleep mit dem Übergang des Stabilisators in den Economy-Modus.  Die Taktfrequenz ist nicht höher als 131 kHz, der Gesamtverbrauch ist nicht höher als 200 μA. </li><li>  <b>Stopp</b> - ein vollständiger Stopp aller Taktfrequenzen mit Ausnahme des externen oder internen Taktgenerators 32768 Hz.  Im Fall von STM32L1 arbeitet in diesem Modus nur die Echtzeituhr weiter, alles andere stoppt vollständig.  In neueren Prozessoren können einige Peripheriegeräte mit niedrigen Frequenzen getaktet werden.  <i>Fast</i> alle Prozessorbeine behalten ihren Zustand.  Der Inhalt des RAM wird gespeichert, externe Interrupts funktionieren weiterhin. </li><li>  <b>Standby</b> - ein vollständiges Herunterfahren des Prozessorkerns, des Arbeitsspeichers und aller Peripheriegeräte mit Ausnahme von Echtzeituhren.  RAM wird nicht gespeichert (d. H. Aus Sicht der Software ist das Verlassen im Standby fast das Gleiche wie Leistungsverzerrung - von vorne beginnen), die RTC tickt weiter.  Externe Interrupts funktionieren nicht, mit Ausnahme von drei speziellen WKUPx-Beinen, deren Umschaltung von 0 auf 1 den Prozessor weckt. </li></ul><br>  Das Aufrufen der einzelnen Modi ist recht einfach: Sie müssen die Flags in drei bis fünf Registern setzen. Danach rufen Sie (für den Schlafmodus) den WFI- oder WFE-Befehl auf. Dies ist der Standard-Cortex-M-Befehl und bedeutet „Auf Unterbrechung warten“ und „Auf Ereignis warten“. .  Abhängig von den Flags (sie sind im Referenzhandbuch des Prozessors beschrieben, für STM32L1 ist es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RM0038</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fällt</a> der Prozessor selbst mit diesem Befehl in diesen Modus. <br><br>  Außerdem wäre es schön, Interrupts zu verbieten (dies hat keinen Einfluss auf die Fähigkeit externer und interner Ereignisse, den Prozessor aus dem Ruhezustand zu erwecken) und darauf zu warten, dass die Daten aus den Registern im Speicher gespeichert werden, wenn dies plötzlich mit dem DSB-Befehl geschieht. <br><br>  So sieht es beispielsweise aus, wenn Sie in den Stoppmodus wechseln: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  PDDS    Stop  Standby,    */</span></span> PWR-&gt;CR &amp;= ~(PWR_CR_PDDS); <span class="hljs-comment"><span class="hljs-comment">/*  Wakeup   ,      */</span></span> PWR-&gt;CR |= PWR_CR_CWUF; <span class="hljs-comment"><span class="hljs-comment">/*    low-power ,    Stop -    */</span></span> PWR-&gt;CR |= PWR_CR_LPSDSR; <span class="hljs-comment"><span class="hljs-comment">/*    Vref   */</span></span> PWR-&gt;CR |= PWR_CR_ULP; <span class="hljs-comment"><span class="hljs-comment">/*     Cortex-M,  Stop,  Standby -   Deep Sleep */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      Deep Sleep */</span></span> SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk); <span class="hljs-comment"><span class="hljs-comment">/*  ;       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> state = irq_disable(); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> __DSB(); <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> __WFI(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> init_clk(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> irq_restore(state);</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WFI</a> ist eine Blockierungsanweisung. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daraufhin</a> geht der Prozessor in den Tiefschlaf und verlässt ihn erst, wenn eine Unterbrechung auftritt.  Ja, ich wiederhole, obwohl wir Interrupts explizit deaktiviert haben, reagiert der Prozessor auf sie und wacht auf - aber die Verarbeitung beginnt erst, nachdem wir sie wieder eingeschaltet haben.  Und das hat eine tiefe Bedeutung. <br><br>  Im obigen Code geht nach WFI eine Art Neuinitialisierung der Betriebsfrequenzen nicht einfach so vor - Tatsache ist, dass L1 den Tiefschlaf immer bei einer Frequenz von 4,2 MHz und mit dem internen MSI-Generator als Quelle dieser Frequenz verlässt.  In vielen Situationen möchten Sie natürlich nicht, dass der Interrupt-Handler, der den Prozessor aufweckt, mit dieser Frequenz startet - zum Beispiel, weil die Frequenzen aller Timer, UARTs und anderer Busse abfliegen.  Daher stellen wir zuerst die Betriebsfrequenzen wieder her (oder berechnen die erforderlichen Busse unter 4,2 MHz neu, wenn wir auf MSI bleiben möchten) und tauchen dann in Interrupts ein. <br><br>  In der Praxis sind die beiden am häufigsten verwendeten Modi Ausführen und Stoppen.  Tatsache ist, dass LP Run schmerzhaft langsam ist und keinen Sinn ergibt, wenn der Prozessor einige Berechnungen durchführen und nicht nur auf externe Ereignisse warten muss, und Sleep und LP Sleep nicht zu wirtschaftlich sind (Verbrauch bis zu 2 mA) und bei Bedarf benötigt werden Sparen Sie mindestens ein wenig, lassen Sie aber gleichzeitig die funktionierenden Peripheriegeräte und / oder sorgen Sie für die schnellstmögliche Reaktion des Prozessors auf Ereignisse.  Solche Anforderungen existieren zwar, aber insgesamt nicht sehr oft. <br><br>  Der Standby-Modus wird normalerweise nicht verwendet, da es nach dem Nullsetzen des Arbeitsspeichers nicht möglich ist, an der Stelle fortzufahren, an der Sie aufgehört haben. Außerdem treten einige Probleme mit externen Geräten auf, die im Folgenden erläutert werden und Hardwarelösungen erfordern.  Wenn das Gerät jedoch unter diesem Gesichtspunkt entwickelt wurde, kann der Standby-Modus beispielsweise während der Langzeitspeicherung dieses Geräts als "Aus" -Modus verwendet werden. <br><br>  Tatsächlich brechen die meisten Handbücher bei der Präsentation normalerweise triumphierend ab. <br><br>  Das Problem ist, dass Sie, wenn Sie ihnen folgen, traurige 100-200 μA tatsächlichen Verbrauchs anstelle der versprochenen 1,4 μA in Stop mit den Arbeitsstunden erhalten - selbst beim Nucleo-Referenz-Debugging, das keine externen Chips, Sensoren usw. enthält. dem es zugeschrieben werden könnte. <br><br>  Und nein, Ihr Prozessor funktioniert, es gibt nichts in Errata und Sie haben alles richtig gemacht. <br><br>  Nur nicht bis zum Ende. <br><br><h3>  Restless-Legs-Syndrom </h3><br>  Das erste Problem STM32L1, über das <i>einige</i> Artikel sprechen, das sich aber oft nur in Foren erinnern, wenn am dritten Diskussionstag, woher die 100-200 μA kamen, sich jemand an die Existenz von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AN3430 erinnert</a> und Seite 19 darin erreicht - dies Beine Zustand standardmäßig. <br><br>  Ich stelle fest, dass sich sogar STMicro selbst auf das Problem durch die Hüllen bezieht und in den meisten Dokumenten, in denen die Optimierung des Energieverbrauchs in Betracht gezogen wird, auf ein oder zwei Sätze beschränkt ist, mit dem Rat, nicht verwendete Beine zu Boden zu ziehen oder in den analogen Eingabemodus zu versetzen, ohne die Gründe zu erläutern. <br><br>  Das Traurige ist, dass standardmäßig alle Beine als digitale Eingänge konfiguriert sind (0x00 im GPIOx_MODER-Register).  Ein Schmitt-Trigger befindet sich immer am digitalen Eingang, wodurch die Störfestigkeit dieses Eingangs verbessert wird, während er völlig unabhängig ist - es ist ein einfaches Logikelement, ein Puffer mit Hysterese, der keine externe Taktung erfordert. <br><br>  In unserem Fall bedeutet dies, dass wir die Uhr im Stoppmodus ausgeschaltet haben und die Schmitt-Trigger weiter funktionierten, als wäre nichts passiert - je nach Pegel des Eingangssignals schalten sie ihre Ausgänge auf 0 und 1. <br><br>  Gleichzeitig hängt ein Teil der Prozessorschenkel in einem typischen Schaltkreis in der Luft - das heißt, es ist kein verständliches Signal auf ihnen.  Es wäre falsch zu glauben, dass das Fehlen eines klaren Signals bedeutet, dass auf diesen Beinen 0 aufgrund ihrer hohen Eingangsimpedanz kein zufälliges Rauschen eines unbestimmten Werts von Tonabnehmern und Strom von benachbarten Spuren zum ersten Fernsehkanal fließt. Wenn der Fuß lang genug ist, um als Antenne zu dienen (analoge Fernsehgeräte in Russland werden jedoch bald ausgeschaltet, was zu einer gewissen Reduzierung des Stromverbrauchs falsch konfigurierter Mikrocontroller führen sollte). <br><br>  In Übereinstimmung mit diesen Schwankungen schaltet der Zweig auf zufällige Weise zwischen 0 und 1 um. Die CMOS-Logik verbraucht beim Schalten Strom.  Das heißt, ein <i>in der Luft hängender Prozessorabschnitt, der im digitalen Eingabemodus konfiguriert ist, verbraucht an sich einen spürbaren Strom</i> . <br><br>  Der Ausweg ist einfach: Wenn Sie das Programm starten, müssen Sie alle Beine auf den Status des Analogeingangs konfigurieren.  STM32 hat es formal für alle Beine ohne Ausnahme, unabhängig davon, ob sie an den ADC angeschlossen sind oder nicht, und unterscheidet sich vom digitalen Eingang nur, wenn kein Schmitt-Trigger am Eingang vorhanden ist. <br><br><img src="https://habrastorage.org/webt/nm/k2/py/nmk2py-r1zqa2rgltekzx69bmy8.png"><br><br>  Dazu reicht es aus, den Wert 0xFF ... FF in alle GPIOx_MODER-Register zu schreiben. Dies ist, wie oben erwähnt, am einfachsten gleich zu Beginn, und dann werden Sie im Verlauf des Spiels die einzelnen Beine nach Bedarf in diesem Gerät neu konfigurieren. <br><br>  Hier tritt jedoch ein Problem zweiter Ordnung auf - es ist gut, wenn Ihre Firmware auf einem bestimmten Controller funktioniert und Sie daher immer wissen, was <i>x</i> in GPIOx ist.  Schlimmer noch, wenn die Firmware universell ist - der STM32 kann <i>bis zu</i> 8 Ports haben, aber kleiner sein;  Wenn Sie versuchen, auf einen Port zu schreiben, der in diesem Modell des Controllers nicht vorhanden ist, wird ein Hard Fault angezeigt, d. h.  Kernel-Absturz. <br><br>  Selbst dieser Fall kann umgangen werden. Mit Cortex-M können Sie die Adressen auf ihre Gültigkeit überprüfen. Im Fall von M3 und M4 ist die Überprüfung im Allgemeinen recht trivial, erfordert jedoch bei M0 etwas Magie, ist aber realisierbar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Details können hier gelesen werden</a> , wir werden diesen Artikel nicht fächern ) <br><br>  Das heißt, im Allgemeinen hat der Prozessor gestartet, die Frequenzen eingestellt - und sofort alle verfügbaren GPIO-Ports durchlaufen und in MODER-Ports geschrieben (der folgende Code ist für RIOT OS geschrieben, aber im Allgemeinen ist er kommentarlos klar und kann auf drei Minuten übertragen werden jede andere Plattform). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CPU_FAM_STM32L1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* switch all GPIOs to AIN mode to minimize power consumption */</span></span></span><span class="hljs-meta"> GPIO_TypeDef *port; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable GPIO clock */</span></span></span><span class="hljs-meta"> uint32_t ahb_gpio_clocks = RCC-&gt;AHBENR &amp; 0xFF; periph_clk_en(AHB, 0xFF); for (uint8_t i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 8; i++) { port = (GPIO_TypeDef *)(GPIOA_BASE + i*(GPIOB_BASE - GPIOA_BASE)); if (cpu_check_address((char *)port)) { port-&gt;MODER = 0xffffffff; } else { break; } } /* restore GPIO clock */ uint32_t tmpreg = RCC-&gt;AHBENR; tmpreg &amp;= ~((uint32_t)0xFF); tmpreg |= ahb_gpio_clocks; periph_clk_en(AHB, tmpreg); #endif</span></span></span></span></code> </pre><br>  Ich stelle fest, dass dies nur für die L1-Serie gilt. In L0 und L4 wurde die Erfahrung berücksichtigt, und sie konfigurieren standardmäßig alle Ports beim Start als analoge Eingänge. <br><br>  Nachdem Sie alle diese Verfahren sorgfältig durchgeführt haben, füllen Sie die Firmware in das fertige Gerät ... und erhalten 150 uA im Stoppmodus des Prozessors und aller externen Chips, die ausgeschaltet sind, obwohl Ihre Schätzungen die pessimistischsten sind, die aus den Datenblättern für alles stammen, was Sie auf die Platine gelötet haben Geben Sie nicht mehr als 10 μA. <br><br>  Außerdem versuchen Sie dann, den Prozessor anstelle von Stop in den Standby-Modus zu versetzen, d. H.  Schalten Sie es einfach fast vollständig aus - und anstatt zu fallen, verdreifacht sich der Stromverbrauch und nähert sich fast einem halben Milliampere! <br><br>  Kein Grund zur Panik.  Wie Sie vielleicht erraten haben, haben Sie alles richtig gemacht.  Aber nicht bis zum Ende. <br><br><h3>  Restless Leg Syndrom - 2 </h3><br>  Das nächste Problem besteht aus zwei Teilen. <br><br>  Das erste liegt auf der Hand: Wenn Ihr Gerät nicht aus einem Mikrocontroller besteht, ist es wichtig, nicht zu vergessen, dass externe Chips auch Eingangssignale haben, an denen Schmitt-Trigger hängen und die darüber hinaus die interne Logik des Chips wecken können.  Beispielsweise versucht ein Chip, der vom UART-Team aus dem Ruhezustand gezogen und aus dem Ruhezustand entfernt wird, bei jeder Bewegung auf diesem Bus Daten daraus zu lesen. <br><br>  Wenn all diese Beine in der Luft hängen, bekommen wir dementsprechend nichts Gutes. <br><br>  Unter welchen Bedingungen landen sie in der Luft? <br><br>  Erstens, wenn der Controller in den Standby-Modus wechselt, werden alle GPIOs mit hohem Widerstand in den High-Z-Zustand versetzt - das heißt, die an sie angeschlossenen externen Chips befinden sich in der Luft.  Es ist unmöglich, dies programmgesteuert in STM32L1 zu beheben (bei anderen Serien und anderen Controllern geschieht dies auf unterschiedliche Weise). Der einzige Ausweg besteht daher in einem System, das den Standby-Modus verwendet. Die Eingänge externer Chips müssen gegen Masse gezogen oder von externen Widerständen gespeist werden. <br><br>  Eine bestimmte Ebene wird so gewählt, dass die Linie aus Sicht des Chips inaktiv ist: <br><br><ul><li>  1 für UART TX </li><li>  0 für SPI MOSI </li><li>  0 für SPI CLK im SPI-Modus 0 oder 1 </li><li>  1 für SPI CLK mit SPI-Modus 2 oder 3 </li><li>  1 für SPI CS </li></ul><br>  Zweitens kann auf STM32 <i>bei Verwendung des Stoppmodus</i> (sic!) <i>Der</i> Status der GPIOs, die mit den internen Hardwareblöcken der Schnittstellen verbunden sind, unterschiedlich sein.  Das heißt, dieselbe SPI-Schnittstelle, wenn sie in Stop konfiguriert ist, stellt sich plötzlich entweder als digitaler Eingang oder im Allgemeinen als High-Z heraus - mit den entsprechenden Konsequenzen für externe Chips, die daran hängen.  Während die Dokumentation besagt, dass die Beine in gutem Zustand sind, können Sie sich a priori nur darauf verlassen, wenn Sie Ihre Beine als reguläre GPIOs verwenden. <br><br>  Sie können es nicht verstehen und verzeihen, aber Sie können es sich merken und beheben: Für Schnittstellen, die sich auf diese Weise verhalten, müssen Sie in der Schlafpflegefunktion ein erzwungenes Umschalten auf normales GPIO mit Pegeln hinzufügen, die inaktiven Ebenen dieser Schnittstelle entsprechen.  Nach dem Aufstehen können die Schnittstellen wiederhergestellt werden. <br><br>  Zum Beispiel das gleiche SPI vor dem Einschlafen (der Einfachheit halber nehme ich den Code aus dem RIOT-Betriebssystem, es ist klar, dass das gleiche einfach in Registern zu implementieren ist): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* specifically set GPIOs used for external SPI devices */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 0, MISO = AIN for SPI Mode 0 &amp; 1 (CPOL = 0) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 1, MISO = AIN for SPI Mode 2 &amp; 3 (CPOL = 1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SPI_NUMOF; i++) { <span class="hljs-comment"><span class="hljs-comment">/* check if SPI is in use */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_periph_clk(spi_config[i].apbbus, spi_config[i].rccmask) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* SPI CLK polarity */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spi_config[i].dev-&gt;CR1 &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>)) { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PU); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PD); } gpio_init(spi_config[i].mosi_pin, GPIO_IN_PD); gpio_init(spi_config[i].miso_pin, GPIO_AIN); } }</code> </pre><br>  Bitte beachten Sie, dass die Ausgänge hier nicht als GPIO_OUT mit Stufe 0 oder 1 konfiguriert sind, sondern als Eingänge mit einem Pull-up bis 0 oder 1 - dies ist kein grundlegender Punkt, bietet jedoch zusätzliche Sicherheit, wenn Sie einen Fehler machen und versuchen, Pull-Push mit einer Art von zu spielen Ein externer Chip zieht dieses Bein in die andere Richtung.  Mit GPIO_OUT können Sie einen Kurzschluss arrangieren, mit GPIO_IN mit einem Pull-up - niemals. <br><br>  Darüber hinaus ist das SPI-CS-Signal nicht betroffen - in diesem Fall wird es programmgesteuert generiert, dh von einem normalen GPIO, und es behält seinen Zustand sicher in einem Traum. <br><br>  Um den Zustand des Beins beim Verlassen des Schlafes wiederherzustellen, reicht es aus, die Werte der Register, die geändert werden sollen (MODER, PUPDR, OTYPER, OSPEEDR - siehe die Situation in einem bestimmten Fall), am Eingang in Variablen zu schreiben und sie beim Verlassen des Schlafes in Register zurückzusetzen . <br><br>  Und jetzt ... ta daaam!  Titelbild.  Eineinhalb Mikroampere. <br><br>  Aber es ist zu früh zum Feiern.  Damit haben wir die <i>statische</i> Optimierung des Energieverbrauchs abgeschlossen und liegen vor uns <i>dynamisch</i> . <br><br><h3>  Achilles gegen Schildkröte </h3><br>  Was ist besser - mehr essen und schneller laufen oder weniger essen, aber langsamer laufen?  Bei Mikrocontrollern ist die Antwort auf diese Frage zweimal nicht trivial. <br><br>  Erstens können die Betriebsfrequenzen in einem sehr weiten Bereich geändert werden - von 65 kHz (LP Run) bis 32 MHz im Normalmodus.  Wie jeder CMOS-Chip hat STM32 zwei Komponenten im Stromverbrauch - statisch und dynamisch;  die zweite hängt von der Frequenz ab, die erste ist konstant.  Infolgedessen sinkt der Energieverbrauch nicht so schnell wie die Betriebsfrequenz und Produktivität, und je nach Aufgabe kann sich die aus Sicht der Energieeffizienz optimale Frequenz als unterschiedlich herausstellen - wenn Sie auf ein Ereignis warten müssen, aber aus irgendeinem Grund nicht einschlafen können, wird dies der Fall sein Niedrige Frequenzen sind effektiv, wenn Sie nur Zahlen dreschen müssen - hoch.  Bei typischen "Krankenhausdurchschnitt" -Aufgaben ist es normalerweise nicht sinnvoll, unter 2-4 MHz zu fallen. <br><br>  Zweitens, und dies ist ein weniger trivialer Moment, hängt die Geschwindigkeit, mit der Sie aus dem Schlaf kommen, von der Arbeitsfrequenz und der Art und Weise ab, wie sie empfangen wird. <br><br>  Der schlimmste Fall ist, mit einer Frequenz von 32 MHz von einem externen Quarz aus dem Schlaf zu kommen (ich möchte Sie daran erinnern, dass STM32L1 mit einem internen 4-MHz-Oszillator aufwacht), da er aus drei Stufen besteht: <br><br><ul><li>  Eigentlich wacht der Prozessor aus dem Schlaf auf </li><li>  Stabilisierung der Quarzerzeugung (1-24 MHz) </li><li>  Stabilisierung der PLL-Erzeugung (32 MHz) </li></ul><br>  Tatsächlich ist es das kleinste Problem, den Prozessor hier aus dem Ruhezustand zu bringen. Bei einer Frequenz von 4,2 MHz dauert es ungefähr 10 μs.  Die Stabilisierung von Quarz kann jedoch bis zu 1 ms dauern (obwohl sie bei Hochgeschwindigkeitsresonatoren normalerweise noch schneller ist, in der Größenordnung von mehreren hundert Mikrosekunden), beträgt der Zugriff auf den PLL-Modus weitere 160 μs. <br><br>  Diese Verzögerungen sind unter dem Gesichtspunkt des Energieverbrauchs für ein System, das selten aufwacht (nicht mehr als einmal pro Sekunde), möglicherweise nicht signifikant. Wenn jedoch die Zeitspanne zwischen den Aufweckvorgängen mehrere zehn Millisekunden und weniger beträgt und die Aufweckvorgänge selbst kurz sind, beginnt der Overhead sogar eine bereits messbare Addition unter Berücksichtigung, dass der Prozessor beim Aufwachen einen relativ kleinen Strom verbraucht. <br><br>  Was kann man damit machen?  Im Allgemeinen liegt die Antwort auf der Hand: Vermeiden Sie die Verwendung von externem Quarz.  Beispielsweise kann ein Programm, in dem es seltene schwere Unteraufgaben gibt, die eine genaue Taktung erfordern (z. B. die trivialen - UART-Datenaustausch), und häufige einfache Unteraufgaben bei jedem Erwachen selbst entscheiden, ob es notwendig ist, zu gehen externer Quarz, oder es ist einfacher (und schneller!), die aktuelle Aufgabe auf dem MSI-Generator auszuführen, auf dem der Prozessor bereits aufgewacht ist, ohne viel Zeit für die Initialisierung der Frequenzen aufzuwenden. <br><br>  In diesem Fall kann es jedoch erforderlich sein, die Taktfrequenzen der Peripherie sowie die Zugriffsmodi auf den Flash-Speicher (die Anzahl der Verzögerungszyklen), die Spannung des Prozessorkerns (in STM32L1 wird aus drei möglichen Werten ausgewählt) usw. anzupassen.  In Bezug auf die Kernel- und Speicherbetriebsarten ist es jedoch häufig möglich, diese durch Auswahl der für die maximal verwendete Frequenz empfohlenen zu optimieren, da ein nicht optimaler Betrieb des Kerns bei niedrigeren Frequenzen aufgrund des geringen Aufgabenvolumens bei diesen Frequenzen keine signifikante Änderung der praktischen Leistung und des Stromverbrauchs bewirkt durchgeführt. <br><br>  Obwohl alle diese Maßnahmen bereits für die Feinabstimmung von Modi gelten (und zum Beispiel die meisten Betriebssysteme und Bibliotheken nicht einmal etwas in der Nähe der Box wissen), können sie in einigen Fällen den Durchschnittsverbrauch auf einer Skala von Prozenteinheiten und manchmal sogar noch mehr senken.  Stellen Sie sich zum Beispiel einen Wasserzähler vor, der alle 50 ms die Kontakte eines Reed-Schalters abfragt, während die eigentliche Vermessung mehrere zehn Mikrosekunden dauert. Möchten Sie bis zu diesem Zeitpunkt ~ 500 μs hinzufügen, um den Controller aufzuwecken? <br><br><h3>  Unerträglich lange Sekunde </h3><br>  Ein weiteres Problem, das nicht direkt mit der Energieeinsparung zusammenhängt, sondern unvermeidlich damit zusammenhängt - wie werden Zeitintervalle von weniger als 1 Sekunde gezählt? <br><br>  Tatsache ist, dass es auf dem STM32L1 nur einen Timer gibt, der im Stoppmodus arbeitet - dies ist RTC, die Standardeinheit für 1 Sekunde.  Gleichzeitig gibt es in den Programmen ständig Zeitintervalle von Einheiten, zehn und hundert Millisekunden, um mindestens denselben Wasserzähler zu nehmen. <br><br>  Wie man ist  Auf Prozessoren mit LPTIM-Timern laufen, die mit 32768 Hz getaktet sind?  Eine gute Option, aber nicht immer notwendig.  Es ist ohne es möglich. <br><br>  Nicht bei allen STM32L1, aber beginnend mit Cat.  In 2 (dies sind die Prozessoren STM32L151CB-A, STM32L151CC und neuer) wurde der RTC-Block durch ein neues Register ergänzt - SSR, SubSeconds Register.  Genauer gesagt wurde es nicht so sehr ergänzt, als dass es für den Benutzer sichtbar gemacht wurde, und die Subsekundenalarme ALRMASSR und ALRMBSSR wurden hinzugefügt. <br><br>  Dieses Register enthält keine verständlichen Zeiteinheiten, es wurde von einem technischen internen Zähler erstellt.  In STM32L1 durchläuft ein Takt, der mit 32768 Hz tickt, zwei Teilerzähler, asynchron und synchron, die ihn normalerweise durch 32768 teilen, um einen Tick von 1 Sekunde für den Takt zu erhalten.  SSR ist also nur der aktuelle Wert des zweiten Zählers. <br><br>  Obwohl die SSR nicht in Millisekunden, sondern in ihren Einheiten zählt, kann die Dimension dieser Einheiten geändert werden, indem das Verhältnis der Teiler des synchronen und asynchronen Zählers geändert wird, während ihr Gesamtkoeffizient gleich 32768 gehalten wird, um die Standard-1-Sekunde am RTC-Eingang zu erhalten.  Wenn wir diese Koeffizienten kennen, können wir den Preis einer SSR-Division in Millisekunden berechnen und von hier aus mit der Programmierung von Alarmen im Sekundentakt fortfahren. <br><br>  Es ist anzumerken, dass ein asynchroner Vorzähler wirtschaftlicher ist als ein synchroner SSR, und daher ist es energetisch nachteilig, ihn auf 1 zu setzen und die Eingangsfrequenz bereits durch 32768 in SSR zu teilen, nachdem er nur 30 μs gezählt hat.  Für uns haben wir den optimalen Wert für den vorläufigen Teiler 7 für synchron - 4095 ((7 + 1) * (4095 + 1) = 32768) bestimmt.  Mit einer weiteren Abnahme des vorläufigen Teilers beginnt der Energieverbrauch von RTC messbar zu wachsen - um einen Bruchteil einer Mikroampere, aber da wir dies mit der „Referenz“ 1,4 μA im Stoppmodus vergleichen, sind sogar die Fraktionen von Bedeutung.  Standardmäßig sind diese Werte für STM32L1 127 und 255, d. H.  Der Referenzpreis beträgt ca. 4 ms, was etwas rau ist. <br><br>  Wenn Sie tiefer in den Code eintauchen möchten, haben wir zu gegebener Zeit <a href="">den Standard-RTC-Treiber</a> von RIOT OS fertiggestellt, um RTC_SSR- und Millisekundenintervalle zu unterstützen.  Seitdem verwenden wir es buchstäblich bei jedem Schritt (und da wir im Betriebssystem arbeiten, hängt auch ein Dienst darüber, mit dem Sie fast eine beliebige Anzahl von Aufgaben mit beliebigen Zeiträumen mit einem Handgriff an einen Hardware-Timer hängen können). <br><br>  Der gleiche Ansatz wird auf die Steuerungen STM32L0 und STM32L4 übertragen, deren Modelle alle das Register RTC_SSR haben.  Dadurch werden keine LPTIM-Timer mehr benötigt und der Code für verschiedene Plattformen wird vereinheitlicht. <br><br><h3>  Wie man versteht, dass ein Multimeter lügt </h3><br>  Nach all den Optimierungen stellt sich natürlich die berechtigte Frage: Was haben wir tatsächlich erreicht?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne die Antwort darauf zu kennen, könnte man sich vollständig auf ein WFE mit korrekt konfigurierten Flags beschränken, schlafen gehen und 200-500 μA erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die traditionellste Methode zur Strommessung ist natürlich ein Multimeter. Zu verstehen, dass es mit seinem dynamischen Verbrauch wie ein Mikrocontroller auf einer Last liegt, ist sehr einfach - wenn es eingeschaltet ist, liegt es. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet jedoch nicht, dass das Multimeter in dieser Angelegenheit unbrauchbar ist. Sie müssen es nur anwenden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens ist ein Multimeter eine sehr langsame Sache, eine typische Zeit für eine Zählung ist eine zweite Skala, eine typische Zeit für die Änderung des Zustands eines Mikrocontrollers ist eine Mikrosekunden-Skala. In einem System, das seinen Verbrauch in diesem Tempo ändert, zeigt das Multimeter einfach zufällige Werte an.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der für uns nicht zufälligen Variablen ist jedoch der Verbrauch des Mikrocontrollers im Schlafmodus. Wenn es den auf Datenblättern geschätzten Wert deutlich überschreitet, stimmt eindeutig etwas nicht. Dies ist der Verbrauch eines </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statischen Systems</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh er kann mit einem Multimeter gemessen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die trivialste Methode, die auf dem Titelfoto gezeigt wird, ist ein Multimeter im Mikroammetermodus, das jetzt in den meisten Modellen mit mittlerer Reichweite verwendet wird und eine gute Genauigkeit und hervorragende Auflösung aufweist. UT120C hat eine Auflösung von 0,1 μA mit einer zertifizierten Genauigkeit von ± 1% ± 3 Entladungen, was für uns ausreicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei diesem Modus gibt es nur ein Problem: Die darin enthaltenen Multimeter haben einen großen Serienwiderstand mit einer Skalierung von Hunderten von Ohm. Im normalen Modus startet der Mikrocontroller mit einem solchen Multimeter im Stromkreis einfach nicht. Glücklicherweise befinden sich die Positionen von "mA" und "uA" in fast allen Instrumenten auf der Waage in der Nähe. Die Buchsen für die Messung in beiden Bereichen sind gleich, sodass Sie den Controller sicher an der Grenze von "mA" starten können. Wenn er in den Ruhezustand wechselt, klicken Sie auf "uA" "- Dies geschieht schnell genug, damit der Controller keine Zeit hat, die Stromversorgung zu verlieren und neu zu starten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitte beachten Sie, dass diese Methode nicht anwendbar ist, wenn der Controller Aktivitätsspitzen aufweist. Beispielsweise wird der Watchdog-Timer in der Firmware des Geräts alle 15 Sekunden zurückgesetzt. In diesen Momenten zeigt das Multimeter etwas im Bereich von 27 μA an, was natürlich nichts mit dem Wetter auf dem Mars zu tun hat. Wenn auf Ihrem System öfter als einmal alle 5-10 Sekunden etwas willkürlich Kurzes auftritt, liegt das Multimeter einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere Möglichkeit, </font><b><font style="vertical-align: inherit;">statische</font></b><font style="vertical-align: inherit;"> Aufladung zu messen</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ich hebe dieses Wort direkt hervor) Der Verbrauch durch ein Multimeter ist ein Maß für den Sturz auf einen externen Shunt. Wenn Sie ultrakleine Ströme im Maßstab von einigen zehn Mikroampere messen möchten, müssen Sie einen großen Shunt (z. B. 1 kOhm) parallel dazu schalten - eine Schottky-Diode in direkter Verbindung. Wenn der Shunt mehr als 0,3 V abfällt, öffnet die Diode und begrenzt den Spannungsabfall. Bis zu 0,3 V können Sie den Abfall sicher mit einem Multimeter im Millivoltbereich von 1 mV = 1 μA messen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider wird es nicht funktionieren, einen Abfall an einem Shunt mit niedriger Impedanz mit einem typischen Multimeter zu messen - Geräte der Mittelklasse sind in diesem Bereich unglücklich, selbst wenn sie etwas unter 100 μV anzeigen. Wenn Sie ein gutes Desktop-Gerät haben, das 1 UV anzeigen kann, brauchen Sie meinen Rat nicht mehr.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Statik ist zwar gut, aber was ist mit der Dynamik? </font><font style="vertical-align: inherit;">Wie kann der gleiche Effekt verschiedener Frequenzen auf den durchschnittlichen Stromverbrauch bewertet werden? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist alles kompliziert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben wir die Grundvoraussetzungen auf:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Strombereich von mindestens 1 μA - 100 mA (10 ^ 5) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Messdauer nicht mehr als 10 μs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spannungsabfall nicht höher als 100 mV </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Messdauer - unbegrenzt </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir dies einfach direkt in Zahlen übersetzen, erhalten wir einen relativ schnellen und nicht weniger als 18-Bit-ADC mit einer Eingangsvorspannung von weniger als 30 μV, ein analoges Front-End, das Spannungen von 1 μV messen kann, und eine schnelle Schnittstelle zum Computer, über die wir all dies übertragen können und speichern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und das alles für einen einzigen Gebrauch. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sehen, ja, warum liegen solche Dinge nicht an jeder Ecke von zehn Dollar? Keysight N6705C erfüllt in erster Näherung unsere Anforderungen, kostet jedoch nur 7960 US-Dollar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Budgetlösungen beispielsweise integriert SiLabs die aktuelle Messung in seine Debugs. Die Eigenschaften des Advanced Energy Monitoring (AEM) -Systems hängen vom jeweiligen Debugging-Modell ab und sie haben das größte Problem mit der Messgeschwindigkeit. In den alten „Starter-Kits“ beträgt der STK3300 / 3400 nur 100 Hz, in den neueren Debugs der STK3700 / 3800 (leicht erkennbar an schwarzem Textolith) - 6,25 kHz, und in älteren Debug-Modellen der DK-Serie kann er bis zu 10 kHz erreichen, kostet aber auch Sie sind bereits $ 300 +. Für ernsthafte Aufgaben empfiehlt SiLabs offiziell die oben genannte Keysight.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Prinzip kann ein solches Gerät von Ihnen selbst entworfen werden - zunächst benötigen Sie sehr gute Operationsverstärker mit minimaler Eingangsvorspannung wie OPA2335. Solche Operationsverstärker werden auf den gleichen Shunt von 2-3 Teilen mit unterschiedlichen Verstärkungsfaktoren gelegt, alle werden auf unterschiedliche ADC-Eingänge gewickelt (bei diesem Ansatz ist es durchaus möglich, den eingebauten Mikrocontroller zu verwenden), und dann wird bei jeder Datenerfassung programmgesteuert bestimmt, welcher der Operationsverstärker in einem bestimmten Bereich vorhanden ist Wenn der Moment nicht überlastet ist, werden die Messwerte gezählt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem der Geschwindigkeit der Datenübertragung auf einen Computer ist ganz einfach zu lösen - da wir aus praktischen Gründen in erster Linie am durchschnittlichen Verbrauch des Systems im realen Leben interessiert sind, können Mikrosekundenwerte im integrierten Mikrocontroller des Messgeräts erfasst und der arithmetische Durchschnitt für einen angemessenen Millisekundenmaßstab gesendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus ist es, wie die Praxis zeigt, sehr nützlich, einen Zählerlogger zu haben, der zwar einfach und nicht zu genau ist, aber immer zur Hand ist, um keine Überraschungen mit einer durch Energiesparen unterbrochenen Firmware-Änderung zu erhalten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel haben wir einen in unseren Standard-USB-Adapter UMDK-RF eingebaut, der beim Debuggen der Firmware ständig verwendet wird. Er verfügt bereits über einen SWD-Programmierer mit Unterstützung für das DAPLink-Protokoll, eine USB-UART-Brücke und eine Energieverwaltungslogik. Er verfügt über eine Verbrauchsanzeige fast kostenlos. Das Messgerät selbst ist ein 1-Ohm-Shunt und ein INA213-Verstärker (50-fache Verstärkung, typischer Nullpunktversatz 5 μV): Der </font></font><br><br><img src="https://habrastorage.org/webt/me/l_/dr/mel_drvu6rqzwr1bebtbtayfiiw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verstärker wird direkt an den Eingang des ADC des Mikrocontrollers (STM32F042F6P6) angeschlossen, der ADC verarbeitet über einen Hardware-Timer mit einer Dauer von 10 μs und über USB gemittelte Daten werden für ein Intervall von 100 ms ausgegeben. Wenn Sie also etwas an der Firmware-Logik ändern, können Sie einfach rauchen oder Kaffee trinken, das Gerät auf dem Tisch lassen und zurückkehren. Sehen Sie sich einen Zeitplan wie diesen an:</font></font><br><br><img src="https://habrastorage.org/webt/qp/e2/h1/qpe2h1zrmci58iozay_rmag-lsm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Genauigkeit eines solchen „freien“ Geräts ist natürlich nicht hoch - mit einem 12-Bit-ADC und einem Verstärker beträgt das Mindestquantum 16 μA, aber es ist äußerst nützlich für eine schnelle und regelmäßige Bewertung des Verhaltens von debuggten Geräten unter dem Gesichtspunkt des Energieverbrauchs. Wenn Sie am Ende etwas an der Firmware oder dem Gerät falsch machen, können Sie mit einer sehr hohen Garantie mindestens Hunderte von Mikroampere-Einheiten verlassen, was deutlich sichtbar ist. </font></font><br><br><img src="https://habrastorage.org/webt/np/kb/ko/npkbkoxcwb3xsmoyshtkjtc3-jq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer netter Bonus ist, dass Sie, da die Daten in Textform (Werte in Mikroampere) an den virtuellen COM-Port gesendet werden, das Terminalfenster neben dem Fenster mit der Gerätekonsole positionieren und gleichzeitig mit den Debug-Meldungen den Stromverbrauch anzeigen können.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich prahle aus einem bestimmten Grund damit, aber um jedem anzubieten, der diesen minimalen (und sehr billigen!) Debugger-Programmierer in seinen eigenen Projekten verwenden möchte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Diagramm </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">hier</font></a><font style="vertical-align: inherit;"> zeichnen </font><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle in DipTrace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die Firmware </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herausziehen (umdk-rf-Brunch, wenn das Ziel UMDK-RF ist, basierend auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dap42-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekt </font><font style="vertical-align: inherit;">). Das Diagramm ist chaotisch gezeichnet, aber ich hoffe, die Hauptpunkte sind klar, die Firmware wird mit libopencm3 in C geschrieben und mit dem üblichen arm-none-eabi-gcc zusammengesetzt. Als zusätzliche Funktionen verfügt die Firmware über eine Energieverwaltung, die Signale über Überlastung von Steuertasten abfängt und den mit ihr verbundenen Controller per langem Drücken eines Knopfdrucks in ihren nativen Bootloader eingibt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NB: Wenn Sie möchten, dass die Boot-Schaltfläche den eigenen Controller des Programmierers regelmäßig in den Bootloader bringt, muss die Polarität der Verbindung geändert, die Optionsbytes-Bearbeitung des Controllers beim ersten Start und die Programmeingabe für den Bootloader entfernt und die Interrupt-Polarität für den regulären Bootloader entfernt werden Funktionen dieser Taste. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Hier</font></a><font style="vertical-align: inherit;"> (Seite 9) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können Sie sehen, wie der Strom an einem Operationsverstärkerpaar mit unterschiedlichen Verstärkungsfaktoren gemessen wird (z. B. um den oben für Ihre Aufgaben beschriebenen Debugger zu verbessern). Dies </font><font style="vertical-align: inherit;">ist eine traditionellere alternative Option - mit einem Operationsverstärker und einem teuren 24-Bit-ADC - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">TI hat es</font></a><font style="vertical-align: inherit;"> (EnergyTrace auf Seite 5).</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Bitte beachten Sie, dass beim Debuggen mit einem angeschlossenen UART oder JTAG / SWD auch ein kleiner Strom durch die Beine fließen kann, der während des tatsächlichen Betriebs des Geräts nicht auftritt. </font><font style="vertical-align: inherit;">Bei UMDK-RF treten also etwa 15 μA in die SWD aus (und daher werden auf dem Header-Foto Messungen mit einem Multimeter an der alten Version der Platine ohne SWD durchgeführt), und bei der STM32 Nucleo gab es Fälle mit einem Störstrom durch die SWD von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etwa 200 μA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die für die Messung verwendeten Debug-Karten müssen auf solche Funktionen überprüft werden - entweder durch Trennen ihrer Schnittstellenleitungen, wenn dies möglich ist, oder durch Vergleichen der Ergebnisse mit dem gemessenen Verbrauch des Geräts, ohne es zum Debuggen zu installieren, z. B. mit einem Multimeter im statischen Modus.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anstelle einer Schlussfolgerung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich hoffe, Sie haben bereits verstanden, welchen Fehler Sie gemacht haben, als Sie die Mikrocontroller-Programmierung als Ihre Hauptspezialität gewählt haben. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430218/">https://habr.com/ru/post/de430218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430206/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: Privates Surfen im Internet, Teil 2</a></li>
<li><a href="../de430208/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: „Privates Surfen im Internet“, Teil 3</a></li>
<li><a href="../de430210/index.html">Testen Sie meine Geduld mit der Check Point Security Academy</a></li>
<li><a href="../de430212/index.html">OpenSceneGraph: Grundlagen der Szenengeometrie</a></li>
<li><a href="../de430216/index.html">So wie ich es verstehe, esse ich viele Süßigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</a></li>
<li><a href="../de430220/index.html">Wie man einen "hundertjährigen" USB-Hub in einen intelligent verwalteten verwandelt und 300 US-Dollar spart</a></li>
<li><a href="../de430222/index.html">Senior Engineer auf der Suche nach Arbeit. Wie ich 20 Interviews mit HR durchlaufen habe und was ich darüber denke</a></li>
<li><a href="../de430224/index.html">Schizotypische Störung: Ein Einblick</a></li>
<li><a href="../de430226/index.html">Von var b bis zum Interview</a></li>
<li><a href="../de430228/index.html">X-förmige Markierungen als Methode zur Radaridentifizierung mittels Open-Data-Analyse von zwei wissenschaftlichen Satelliten SENTINEL-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>