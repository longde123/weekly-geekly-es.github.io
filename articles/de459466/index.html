<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÇÔ∏è üßùüèΩ üë©üèø‚Äçü§ù‚Äçüë©üèΩ Lua in Moskau 2019: Interview mit Roberto Ierusalimschy üò® üö£üèæ üè¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einiger Zeit besuchte der Sch√∂pfer der Programmiersprache Lua, Roberto Ierusalimschy, unser Moskauer B√ºro. Wir haben ihm einige Fragen gestellt, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lua in Moskau 2019: Interview mit Roberto Ierusalimschy</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/459466/"><img src="https://habrastorage.org/webt/ng/7_/qz/ng7_qz-_skqhbze6n-v272bpohu.jpeg"><br><br>  Vor einiger Zeit besuchte der Sch√∂pfer der Programmiersprache Lua, Roberto Ierusalimschy, unser Moskauer B√ºro.  Wir haben ihm einige Fragen gestellt, die wir unter Beteiligung von Habr.com-Nutzern vorbereitet haben.  Und schlie√ülich m√∂chten wir die Volltextversion dieses Interviews teilen. <br><a name="habracut"></a><br>  <b>- Beginnen wir mit einigen philosophischen Fragen.</b>  <b>Stellen Sie sich vor, wenn Sie Lua von Grund auf neu erstellen w√ºrden, welche drei Dinge w√ºrden Sie in Lua √§ndern?</b> <br><br>  - Wow!  Das ist eine schwierige Frage.  In die Schaffung und Entwicklung der Sprache ist so viel Geschichte eingebettet.  Es war keine gro√üe Entscheidung auf einmal.  Es gibt einige Bedauern, von denen ich einige im Laufe der Jahre korrigieren konnte.  Die Leute beschweren sich st√§ndig dar√ºber wegen der Kompatibilit√§t.  Wir haben es mehrmals gemacht.  Ich denke nur an kleine Dinge. <br><br>  <b>- Standardm√§√üig global?</b>  <b>Glaubst du, das ist der Weg?</b> <br><br>  - Vielleicht.  F√ºr dynamische Sprachen ist es jedoch sehr schwierig.  Vielleicht besteht die L√∂sung darin, √ºberhaupt keine Standardeinstellungen zu haben, aber dann w√§re es schwierig, Variablen zu verwenden. <br><br>  Zum Beispiel m√ºssten Sie irgendwie alle Standardbibliotheken deklarieren.  Sie m√∂chten einen Einzeiler, <code>print(sin(x))</code> , und dann m√ºssen Sie 'print' und auch 'sin' deklarieren.  Es ist also seltsam, Erkl√§rungen f√ºr diese Art von sehr kurzen Skripten zu haben. <br><br>  Alles, was gr√∂√üer ist, sollte keine Standardeinstellungen haben, denke ich.  Standardm√§√üig ist Local nicht die L√∂sung, es existiert nicht.  Es ist nur f√ºr Aufgaben, nicht f√ºr die Verwendung.  Etwas, das wir zuweisen und dann verwenden und dann zuweisen, und es gibt einen Fehler - v√∂llig mystifizierend. <br><br>  M√∂glicherweise ist global standardm√§√üig nicht perfekt, aber lokal standardm√§√üig ist dies keine L√∂sung.  Ich denke, eine Art Erkl√§rung, vielleicht eine optionale Erkl√§rung ... Wir hatten diesen Vorschlag oft - eine Art globale Erkl√§rung.  Aber am Ende denke ich, dass das Problem darin besteht, dass die Leute immer mehr nachfragen und wir aufgeben. <br><br>  (sarkastisch) Ja, wir werden eine globale Erkl√§rung abgeben - f√ºgen Sie das und das und das hinzu, setzen Sie das aus, und am Ende verstehen wir, dass die endg√ºltige Schlussfolgerung die meisten Menschen nicht zufriedenstellen wird und wir nicht alle Optionen aufstellen werden, die jeder will. Also setzen wir nichts.  Am Ende ist der strikte Modus ein vern√ºnftiger Kompromiss. <br><br>  Es gibt dieses Problem: Meistens verwenden wir beispielsweise Felder innerhalb der Module, dann haben Sie wieder dieselben Probleme.  Es ist nur ein sehr spezifischer Fall von Fehlern, den die allgemeine L√∂sung wahrscheinlich beinhalten sollte.  Ich denke, wenn Sie das wirklich wollen, sollten Sie eine statisch typisierte Sprache verwenden. <br><br>  <b>- Standardm√§√üig ist Global auch f√ºr kleine Konfigurationsdateien geeignet.</b> <br><br>  - Ja genau f√ºr kleine Skripte und so weiter. <br><br>  <b>- Keine Kompromisse hier?</b> <br><br>  - Nein, es gibt immer Kompromisse.  Es gibt einen Kompromiss zwischen kleinen Skripten und echten Programmen oder so etwas. <br><br>  <b>- Wir kommen also auf die erste gro√üe Frage zur√ºck: Drei Dinge, die Sie √§ndern w√ºrden, wenn Sie die Chance h√§tten.</b>  <b>Aus meiner Sicht sind Sie ziemlich zufrieden mit dem, was wir jetzt haben, stimmt das?</b> <br><br>  - Nun, es ist keine gro√üe Ver√§nderung, aber dennoch ... Unsere Forderungsausf√§lle, die zu einer gro√üen Ver√§nderung wurden, sind Nullen in Tabellen.  Das bereue ich wirklich.  Ich habe diese Art von Implementierung gemacht, eine Art Hack ... Hast du gesehen, was ich getan habe?  Ich habe vor ungef√§hr sechs Monaten oder einem Jahr eine Version von Lua geschickt, die keine Tabellen enth√§lt. <br><br>  <b>- Nullwerte?</b> <br><br>  - Genau.  Ich denke, es wurde in Tabellen nils genannt - was null hei√üt.  Wir haben die Grammatik etwas gehackt, um sie einigerma√üen kompatibel zu machen. <br><br>  <b>- Warum wird es ben√∂tigt?</b> <br><br>  - Ich bin wirklich davon √ºberzeugt, dass dies ein ganzes Problem von L√∂chern ist ... Ich denke, dass die meisten Probleme von Nullen in Arrays verschwinden w√ºrden, wenn wir [Nullen in Tabellen] haben k√∂nnten ... Weil das genaue Problem nicht Nullen in Arrays ist.  Die Leute sagen, wir k√∂nnen keine Nullen in Arrays haben, also sollten wir Arrays von Tabellen getrennt haben.  Aber das eigentliche Problem ist, dass wir keine Nullen in Tabellen haben k√∂nnen!  Das Problem liegt also bei den Tabellen und nicht bei der Darstellung von Arrays.  Wenn wir Nullen in Tabellen haben k√∂nnten, dann h√§tten wir Nullen in Arrays ohne irgendetwas anderes.  Das ist etwas, was ich wirklich bedauere, und viele Leute verstehen nicht, wie sich die Dinge √§ndern w√ºrden, wenn Lua Nullen in Tischen zul√§sst. <br><br>  <b>- Darf ich Ihnen eine Geschichte √ºber Tarantool erz√§hlen?</b>  <b>Wir haben tats√§chlich unsere eigene Implementierung von null, die eine CDATA f√ºr einen Nullzeiger ist.</b>  <b>Wir verwenden es dort, wo Speicherl√ºcken erforderlich sind.</b>  <b>Um Positionsargumente zu f√ºllen, wenn wir Fernaufrufe t√§tigen und so weiter.</b>  <b>Aber wir leiden normalerweise darunter, weil CDATA immer in "wahr" konvertiert wird.</b>  <b>Nullen in Arrays w√ºrden also viele unserer Probleme l√∂sen.</b> <br><br>  - Ja, ich wei√ü.  Das ist genau mein Punkt - dies w√ºrde viele Probleme f√ºr viele Menschen l√∂sen, aber es gibt ein gro√ües Problem der Kompatibilit√§t.  Wir haben nicht die Energie, eine Version zu ver√∂ffentlichen, die so inkompatibel ist, und dann die Community zu brechen und unterschiedliche Dokumentationen f√ºr Lua 5 und Lua 6 usw. zu haben.  Aber vielleicht werden wir es eines Tages ver√∂ffentlichen.  Aber es ist eine wirklich gro√üe Ver√§nderung.  Ich denke, es h√§tte von Anfang an so sein sollen - wenn es so w√§re, w√§re es eine triviale √Ñnderung in der Sprache, abgesehen von der Kompatibilit√§t.  Es bricht viele Programme auf sehr subtile Weise. <br><br>  <b>- Was sind die Nachteile au√üer der Kompatibilit√§t?</b> <br><br>  - Neben der Kompatibilit√§t besteht der Nachteil darin, dass wir zwei neue Operationen und zwei neue Funktionen ben√∂tigen w√ºrden.  Wie 'Schl√ºssel l√∂schen', da das Zuweisen von nil den Schl√ºssel nicht l√∂schen w√ºrde, so dass wir eine Art primitive Operation h√§tten, um den Schl√ºssel zu l√∂schen und ihn wirklich aus der Tabelle zu entfernen.  Und 'Test', um zu √ºberpr√ºfen, wo genau zwischen Null und Abwesenheit zu unterscheiden ist.  Wir brauchen also zwei primitive Funktionen. <br><br>  <b>- Haben Sie die Auswirkungen auf reale Implementierungen analysiert?</b> <br><br>  - Ja, damit haben wir eine Version von Lua ver√∂ffentlicht.  Und wie gesagt, es bricht Code auf viele subtile Arten.  Es gibt Leute, die table.insert (f (x)) ausf√ºhren - einen Aufruf einer Funktion.  Und es ist absichtlich so, dass eine Funktion, wenn sie nichts einf√ºgen m√∂chte, null zur√ºckgibt.  Anstelle eines separaten H√§kchens "M√∂chte ich einf√ºgen?" Rufe ich dann eine table.insert auf und wei√ü, dass sie nicht eingef√ºgt wird, wenn sie gleich Null ist.  Wie alles in jeder Sprache wird ein Fehler zu einer Funktion, und die Benutzer verwenden die Funktion. Wenn Sie sie jedoch √§ndern, wird der Code besch√§digt. <br><br>  <b>- Was ist mit einem neuen Leertyp?</b>  <b>Wie Null, aber nichtig?</b> <br><br>  - Oh nein, das ist ein Albtraum.  Sie verschieben das Problem einfach, wenn Sie ein anderes setzen, dann brauchen Sie ein anderes und ein anderes und ein anderes.  Das ist nicht die L√∂sung.  Das Hauptproblem - nun ja, nicht das Hauptproblem, aber eines der Probleme - ist, dass Null bereits an vielen Stellen in der Sprache verwurzelt ist.  Zum Beispiel ein sehr typisches Beispiel.  Wir sagen: Sie sollten Nullen in Arrays und L√∂chern vermeiden.  Aber dann haben wir Funktionen, die nil und etwas nach nil zur√ºckgeben, sodass wir einen Fehlercode erhalten.  Diese Konstruktion selbst nimmt also an, was Null darstellt ... Wenn ich beispielsweise eine Liste der R√ºckgaben dieser Funktion erstellen m√∂chte, nur um alle diese R√ºckgaben zu erfassen. <br><br>  <b>- Deshalb hast du einen Hack daf√ºr.</b>  <b>:) :)</b> <br><br>  - Genau, aber Sie m√ºssen keine Hacks f√ºr so primitive und offensichtliche [Probleme] verwenden.  Aber die Art und Weise, wie die Bibliotheken aufgebaut sind ... Ich habe einmal dar√ºber nachgedacht - vielleicht sollten die Bibliotheken false statt null zur√ºckgeben -, aber es ist eine halbherzige L√∂sung, die nur einen kleinen Teil des Problems l√∂st.  Das eigentliche Problem ist, wie gesagt, dass wir Nullen in Tabellen haben sollten.  Wenn nicht, sollten wir vielleicht nicht so h√§ufig Nils verwenden wie jetzt.  Es ist alles irgendwie chaotisch.  Wenn Sie also eine Leere erstellen, geben diese Funktionen immer noch eine Null zur√ºck, und wir haben immer noch dieses Problem, es sei denn, wir erstellen einen neuen Typ und die Funktionen geben eine Leere anstelle von Null zur√ºck. <br><br>  <b>- Void kann verwendet werden, um explizit anzugeben, dass der Schl√ºssel in einem Tabellenschl√ºssel mit einem void-Wert aufbewahrt werden soll.</b>  <b>Und nichts kann so handeln wie zuvor.</b> <br><br>  - Ja, das meine ich.  Alle Funktionen in den Bibliotheken sollten void oder nil zur√ºckgeben. <br><br>  <b>- Sie k√∂nnen immer noch null zur√ºckgeben, warum nicht?</b> <br><br>  - Weil wir immer noch das Problem haben w√ºrden, dass Sie einige Funktionen nicht erfassen k√∂nnen. <br><br>  <b>- Aber es wird keinen ersten Schl√ºssel geben, nur einen zweiten Schl√ºssel.</b> <br><br>  - Nein, es wird keinen zweiten Schl√ºssel geben, da die Z√§hlung falsch ist und Sie ein Loch im Array haben. <br><br>  <b>- Ja, sagen Sie also, dass Sie eine falsche Metamethode ben√∂tigen?</b> <br><br>  - Ja.  Mein Traum ist so etwas: <br><br> <code>{f(x)}</code> <br> <br>  Sie sollten alle R√ºckgaben der Funktion <code>f(x)</code> erfassen.  Und dann kann ich <code>%x</code> oder <code>#x</code> , und das gibt mir die Anzahl der R√ºckgaben der Funktion.  Das sollte eine vern√ºnftige Sprache tun.  Das Erstellen einer Leere wird das also nicht l√∂sen, es sei denn, wir hatten eine sehr starke Regel, dass Funktionen niemals Null zur√ºckgeben sollten, aber warum brauchen wir dann Null?  Vielleicht sollten wir es vermeiden. <br><br>  <b>- Roberto, wird es eine viel st√§rkere Unterst√ºtzung f√ºr statische Analysen f√ºr Lua geben?</b>  <b>Wie "Lua Check auf Steroide."</b>  <b>Ich wei√ü, dass es nat√ºrlich nicht alle Probleme l√∂sen wird.</b>  <b>Sie sagen, dies ist eine Funktion f√ºr 6.0, wenn √ºberhaupt, oder?</b>  <b>Wenn es also in einem 5.x ein starkes statisches Analysetool geben w√ºrde - wenn Mannstunden und Mannjahre investiert w√ºrden - w√ºrde es wirklich helfen?</b> <br><br>  - Nein, ich denke, ein wirklich starkes statisches Analysewerkzeug hei√üt ... Typsystem!  Wenn Sie ein wirklich starkes Werkzeug w√ºnschen, sollten Sie eine statisch typisierte Sprache verwenden, etwa Haskell oder sogar etwas mit abh√§ngigen Typen.  Dann haben Sie wirklich starke Analysewerkzeuge. <br><br>  <b>- Aber dann hast du Lua nicht.</b> <br><br>  - Genau, Lua ist f√ºr ... <br><br>  <b>- Ungenau?</b>  <b>Ich habe Ihr Giraffenbild auf statischen und dynamischen Typen wirklich genossen.</b> <br><br>  - Ja, meine letzte Folie. <br><br><img src="https://habrastorage.org/webt/ch/po/as/chpoaszqoikzai3b3hcmymonqv0.jpeg"><br>  <i>Die letzte Folie aus Roberto Ierusalimschys Vortrag "Warum (und warum nicht) Lua?"</i> <i><br></i>  <i>auf der Konferenz Lua in Moskau 2019</i> <br><br>  <b>- Kehren wir f√ºr unsere n√§chste vorbereitete Frage zu diesem Bild zur√ºck.</b>  <b>Wenn ich es richtig verstanden habe, ist Ihre Position, dass Lua ein kleines, n√ºtzliches Werkzeug ist, um nicht sehr gro√üe Aufgaben zu l√∂sen.</b> <br><br>  - Nein, ich denke, Sie k√∂nnen einige gro√üe Aufgaben erledigen, aber nicht mit statischer Analyse.  Ich glaube fest an Tests.  √úbrigens, ich bin mit Ihnen in Bezug auf die Berichterstattung nicht einverstanden. Ihre Meinung ist, wir sollten die Berichterstattung nicht verfolgen ... Ich meine, ich stimme voll und ganz zu, dass die Berichterstattung keinen vollst√§ndigen Test impliziert, aber die Nicht-Berichterstattung einen Null-Prozent-Test impliziert.  Also hielt ich einen Vortrag √ºber einen Testraum - Sie waren dort in Stockholm.  Also habe ich meinen Test mit [ein paar] Fehlern begonnen - das ist das Seltsamste - einer von ihnen war ber√ºhmt, der andere war v√∂llig nicht ber√ºhmt.  In einer Header-Datei von Microsoft, C und C ++ ist etwas v√∂llig kaputt.  Also suche ich im Internet und niemand k√ºmmert sich darum oder hat es √ºberhaupt bemerkt. <br><br>  Zum Beispiel gibt es eine mathematische Funktion, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">modf ()</a> , bei der Sie einen Zeiger auf ein Double √ºbergeben m√ºssen, da zwei Doubles zur√ºckgegeben werden.  Wir √ºbersetzen den ganzzahligen Teil der Zahl oder den Bruchteil.  Das ist also schon lange Teil einer Standardbibliothek.  Dann kam C 99, und Sie ben√∂tigen diese Funktion f√ºr Floats.  Und die Header-Datei von Microsoft hat diese Funktion einfach beibehalten und eine andere als Makro deklariert.  Also hat es diesen in Typabg√ºsse gebracht.  Also hat es das Double in Float umgewandelt, ok, und dann hat es den Zeiger in Double umgewandelt, damit der Zeiger schwebt! <br><br>  <b>- Auf diesem Bild stimmt etwas nicht.</b> <br><br>  - Dies ist eine Header-Datei aus Visual C ++ und Visual C 2007. Ich meine, wenn Sie diese Funktion einmal mit beliebigen Parametern aufgerufen und die Ergebnisse √ºberpr√ºft haben, w√§re dies falsch, es sei denn, es ist Null.  Andernfalls ist jeder andere Wert falsch.  Sie w√ºrden diese Funktion niemals verwenden.  Keine Abdeckung.  Und dann gibt es viele Diskussionen √ºber das Testen ... Ich meine, rufen Sie einfach einmal eine Funktion auf und √ºberpr√ºfen Sie die Ergebnisse!  Also ist es da, es ist schon lange da, seit vielen Jahren k√ºmmert es niemanden.  Eine sehr ber√ºhmte war in Apple.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So etwas wie</a> " <code>if‚Ä¶ what‚Ä¶ goto‚Ä¶ ok</code> " war es so etwas.  Jemand hat hier eine andere Aussage gemacht.  Und dann w√ºrde alles gut werden.  Und es gab viele Diskussionen dar√ºber, dass Sie die Regeln haben sollten, die Klammern in Ihrem Stil obligatorisch sein sollten usw. usw.  Niemand hat erw√§hnt, dass es hier viele andere Wenns gibt.  Das wurde noch nie ausgef√ºhrt ... <br><br>  <b>- Soweit ich mich erinnere, gibt es auch ein Sicherheitsproblem.</b> <br><br>  - Ja genau.  Weil sie nur genehmigte F√§lle testeten.  Sie testeten nichts, weil alles genehmigt werden w√ºrde.  Dies bedeutet, dass es in der Sicherheitsanwendung keinen einzigen Testfall gibt, der pr√ºft, ob eine Verbindung abgelehnt wird oder was auch immer abgelehnt werden soll.  Also diskutieren alle und sagen, sie sollten Klammern haben ... Sie sollten Tests haben, minimale Tests!  Weil das noch niemand getestet hat, meine ich das mit Berichterstattung.  Es ist unglaublich, wie Leute keine grundlegenden Tests machen.  Denn wenn sie alle grundlegenden Tests durchf√ºhren w√ºrden, w√§re es nat√ºrlich ein Albtraum, die gesamte Abdeckung durchzuf√ºhren und alle Zeilen usw. auszuf√ºhren.  Die Leute vernachl√§ssigen selbst grundlegende Tests, so dass die Abdeckung mindestens das Minimum ist.  Auf diese Weise k√∂nnen Sie auf einige Teile des Programms aufmerksam machen, die Sie vergessen haben.  Es ist eine Art Leitfaden, wie Sie Ihre Tests ein wenig verbessern k√∂nnen. <br><br>  <b>- Was ist Testabdeckung in Tarantool?</b>  <b>83%!</b>  <b>Roberto, was ist Lua Testabdeckung?</b> <br><br>  - √úber 99,6.  Wie viele Codezeilen haben Sie?  Eine Million, Hunderttausende?  Das sind riesige Zahlen.  Ein Prozent von hunderttausend sind tausend Codezeilen, die nie getestet wurden.  Sie haben es √ºberhaupt nicht ausgef√ºhrt.  Ihre Benutzer testen nichts. <br><br>  <b>- Es gibt also etwa 17 Prozent der Tarantool-Funktionen, die derzeit nicht verwendet werden?</b> <br><br>  - Ich bin mir nicht sicher, ob Sie alles wieder dorthin bringen m√∂chten, wo wir waren ... Ich denke, eines der Probleme mit dynamischen Sprachen (und statischen Sprachen) ist, dass die Leute keine Sachen testen.  Selbst wenn Sie eine statische Sprache haben, √§ndern Sie das f√ºr das oder das, es sei denn, Sie haben etwas - nicht einmal wie Haskell, sondern Coq - ein Beweissystem.  Kein statisches Analysetool kann diese Fehler erkennen, daher ben√∂tigen Sie Tests.  Und wenn Sie die Tests haben, erkennen Sie globale Probleme, benennen Rechtschreibfehler um usw.  All diese Arten von Fehlern.  Sie sollten diese Tests sowieso haben, vielleicht ist es manchmal etwas schwieriger zu debuggen, manchmal nicht - h√§ngt von der Sprache und der Art des Fehlers ab.  Das Problem ist jedoch, dass Sie mit keinem statischen Analysetool Tests vermeiden k√∂nnen.  Die Tests andererseits ... nun, sie beweisen nie die Abwesenheit von Fehlern, aber ich f√ºhle mich nach all den Tests viel sicherer. <br><br>  <b>- Wir haben eine Frage zum Testen von Lua-Modulen.</b>  <b>Als Entwickler m√∂chte ich einige lokale Funktionen testen, die sp√§ter verwendet werden k√∂nnen.</b>  <b>Die Frage ist: Wir m√∂chten eine Abdeckung von ungef√§hr 99 Prozent haben, aber f√ºr die API, die dieses Modul erzeugt, ist die Anzahl der Funktionsf√§lle, die es erzeugen sollte, viel geringer als die Funktionalit√§t, die es intern unterst√ºtzt.</b> <br><br>  - Warum ist das so, sorry? <br><br>  <b>- Es gibt einige Funktionen, die √ºber die √∂ffentliche Schnittstelle nicht erreichbar sind.</b> <br><br>  - Wenn es Funktionen gibt, die √ºber die √∂ffentliche Schnittstelle nicht erreichbar sind, sollten sie nicht vorhanden sein. L√∂schen Sie sie einfach.  L√∂schen Sie diesen Code. <br><br>  <b>- T√∂te es einfach?</b> <br><br>  - Ja, manchmal mache ich das in Lua.  Es gab eine gewisse Codeabdeckung, ich konnte nicht dorthin oder dorthin oder dorthin gelangen, also hielt ich es f√ºr unm√∂glich und entfernte einfach den Code.  Es ist nicht so √ºblich, aber es ist mehr als einmal passiert.  Diese F√§lle waren unm√∂glich zu passieren, Sie haben nur eine Aussage gemacht, um zu kommentieren, warum es nicht passieren kann.  Wenn Sie nicht √ºber die √∂ffentliche API in Ihre Funktionen gelangen k√∂nnen, sollte diese nicht vorhanden sein.  Wir sollten die √∂ffentliche API mit falschen Eingaben codieren, was f√ºr die Tests wesentlich ist. <br><br>  <b>- Code entfernen, Entfernen ist gut, es reduziert die Komplexit√§t.</b>  <b>Eine reduzierte Komplexit√§t erh√∂ht die Wartbarkeit und Stabilit√§t.</b>  <b>Halte es einfach.</b> <br><br>  - Ja, extreme Programmierung hatte diese Regel.  Wenn es sich nicht um einen Test handelt, existiert es nicht. <br><br>  <b>- Welche Sprachen haben dich inspiriert, als du Lua erschaffen hast?</b>  <b>Welche Paradigmen oder funktionalen Besonderheiten oder Teile dieser Sprachen haben Ihnen gefallen?</b> <br><br>  - Ich habe Lua f√ºr einen ganz bestimmten Zweck entworfen, es war kein akademisches Projekt.  Deshalb sage ich, wenn Sie mich fragen, ob ich es noch einmal erstellen w√ºrde, dass die Sprache viele historische Dinge enth√§lt.  Ich habe nicht mit "Lassen Sie mich die Sprache erstellen, die ich m√∂chte oder verwenden m√∂chte oder die jeder braucht usw." erstellt.  Mein Problem war: 'Dieses Programm hier ben√∂tigt eine Konfigurationssprache f√ºr Geologen und Ingenieure, und ich muss eine kleine Sprache erstellen, die sie mit einer einfachen Oberfl√§che verwenden k√∂nnen.  Deshalb war die API immer ein wesentlicher Bestandteil der Sprache, da sie einfacher zu integrieren ist.  Das war das Ziel.  Was ich in meinem Hintergrund hatte, es waren zu dieser Zeit viele verschiedene Sprachen ... ungef√§hr zehn.  Wenn Sie den gesamten Hintergrund wollen ... <br><br>  <b>- Ich interessierte mich f√ºr Sprachen, die Sie in Lua aufnehmen wollten.</b> <br><br>  - Ich bekam Dinge aus vielen verschiedenen Sprachen, was auch immer zu meinem Problem passte.  Die gr√∂√üte Inspiration war die Modula-Sprache f√ºr die Syntax, aber ansonsten ist es schwierig zu sagen, weil es so viele Sprachen gibt.  Einige Sachen kamen von AWK, es war eine weitere kleine Inspiration.  Nat√ºrlich, Scheme und Lisp ... Ich war immer fasziniert von Lisp, seit ich mit dem Programmieren angefangen habe. <br><br>  <b>- Und immer noch keine Makros in Lua!</b> <br><br>  - Ja, es gibt gro√üe Unterschiede in der Syntax.  Ich glaube, Fortran war die erste Sprache ... nein, die erste Sprache, die ich lernte, war Versammlung, dann kam Fortran.  Ich habe studiert, aber nie CLU verwendet.  Ich habe viel mit Smalltalk, SNOBOL programmiert.  Ich habe auch studiert, aber nie Icon verwendet, es ist auch sehr interessant.  Vieles kam von Pascal und C. Als ich Lua erstellte, war C ++ f√ºr mich bereits zu komplex - und das war vor den Vorlagen usw.  Es war 1991 und 1993 wurde Lua gegr√ºndet. <br><br>  <b>- Die Sowjetunion ist gefallen und du hast angefangen, Lua zu erschaffen.</b>  <b>:) Warst du gelangweilt von Semikolons und Objekten, als du angefangen hast an Lua zu arbeiten?</b>  <b>Ich w√ºrde erwarten, dass Lua eine √§hnliche Syntax wie C hat, da sie in C integriert ist. Aber ...</b> <br><br>  - Ja, ich denke, es ist ein guter Grund, keine √§hnliche Syntax zu haben - also mischen Sie sie nicht, das sind zwei verschiedene Sprachen. <br><br>  Es ist etwas wirklich Lustiges und h√§ngt mit der Antwort zusammen, die Sie mir [auf der Konferenz] nicht erlaubt haben, Arrays ab 1 zu geben. Meine Antwort war zu lang. <br><br>  Als wir Lua starteten, war die Welt anders, nicht alles war C-√§hnlich.  Java und JavaScript gab es nicht, Python steckte noch in den Kinderschuhen und hatte eine Version unter 1.0.  Es gab also nicht dieses Ding, wenn alle Sprachen C-√§hnlich sein sollen.  C war nur eine von vielen Syntaxen. <br><br>  Und die Arrays waren genau die gleichen.  Es ist sehr lustig, dass die meisten Leute das nicht merken.  Es gibt gute Dinge √ºber nullbasierte Arrays sowie √ºber einsbasierte Arrays. <br><br>  Tatsache ist, dass die meisten popul√§ren Sprachen heutzutage aufgrund von C auf Null basieren. Sie wurden irgendwie von C inspiriert. Und das Lustige ist, dass C keine Indizierung hat.  Sie k√∂nnen also nicht sagen, dass C Arrays von Null indiziert, da es keine Indizierungsoperation gibt.  C hat eine Zeigerarithmetik, daher ist Null in C kein Index, sondern ein Offset.  Und als Offset muss es eine Null sein - nicht weil es bessere mathematische Eigenschaften hat oder weil es nat√ºrlicher ist, was auch immer. <br><br>  Und all diese Sprachen, die C kopiert haben, haben Indizes und keine Zeigerarithmetik.  Java, JavaScript usw. usw.  - Keiner von ihnen hat Zeigerarithmetik.  Sie haben also nur die Null kopiert, aber es ist eine ganz andere Operation.  Sie setzen ohne Grund Null - es ist wie ein Frachtkult. <br><br>  <b>- Sie sagen, es ist logisch, wenn Sie eine Sprache in C eingebettet haben, um sie mit C-√§hnlicher Syntax zu erstellen.</b>  <b>Wenn Sie jedoch eine in C eingebettete Sprache haben, haben Sie vermutlich C-Programmierer, die m√∂chten, dass der Code in C und nicht in einer anderen Sprache vorliegt, die wie C aussieht, aber nicht C ist. Daher sollten Lua-Benutzer niemals C verwenden t√§glich?</b>  <b>Warum?</b> <br><br>  - Wer benutzt C jeden Tag? <br><br>  <b>- Systemprogrammierer.</b> <br><br>  - Genau.  Das ist das Problem, zu viele Leute benutzen C, sollten es aber nicht benutzen d√ºrfen.  Programmierer sollten f√ºr die Verwendung von C zertifiziert sein. Warum ist Software so kaputt?  All diese Hacks, die in die Welt eindringen, all diese Sicherheitsprobleme.  Mindestens die H√§lfte von ihnen ist wegen C. Es ist wirklich schwer, in C zu programmieren. <br><br>  <b>- Aber Lua ist in C.</b> <br><br>  - Ja, und so haben wir gelernt, wie schwierig es ist, in C zu programmieren. Sie haben Puffer√ºberl√§ufe, Sie haben ganzzahlige √úberl√§ufe, die Puffer√ºberl√§ufe verursachen ... Holen Sie sich einfach ein einzelnes C-Programm, bei dem Sie sicher sein k√∂nnen, dass keine Arithmetik schief geht, wenn Leute es setzen Beliebige Nummer √ºberall und alles wird √ºberpr√ºft.  Andererseits echte Portabilit√§tsprobleme - vielleicht funktioniert es manchmal in einer CPU, aber dann gelangt es zur anderen CPU ... Es ist verr√ºckt. <br><br>  Zum Beispiel hatten wir k√ºrzlich ein Problem.  Woher wissen Sie, dass Ihr C-Programm keinen Stapel√ºberlauf ausf√ºhrt?  Ich meine Stapeltiefe, nicht Stapel√ºberlauf, weil Sie eingedrungen sind ... Wie viele Aufrufe haben Sie in einem C-Programm? <br><br>  <b>- Abh√§ngig von der Stapelgr√∂√üe.</b> <br><br>  - Genau.  Was sagt der Standard dazu?  Wenn Sie in C codieren und dann diese Funktion ausf√ºhren, die diese Funktion aufruft, die diese Funktion aufruft ... wie viele Aufrufe k√∂nnen Sie ausf√ºhren? <br><br>  <b>- 16 Tausend?</b> <br><br>  - Ich kann mich irren, aber ich denke, der Standard sagt nichts dar√ºber aus. <br><br>  <b>- Ich denke, der Standard enth√§lt nichts, weil er zu stark von der Gr√∂√üe abh√§ngt.</b> <br><br>  - Nat√ºrlich h√§ngt es von der Gr√∂√üe jeder Funktion ab.  Es k√∂nnen riesige, automatische Arrays im Funktionsrahmen sein ... Der Standard sagt also nichts und es gibt keine M√∂glichkeit zu √ºberpr√ºfen, ob ein Aufruf g√ºltig ist.  Wenn Sie also drei Schrittaufrufe haben, kann dies zu einem einzigen Problem f√ºhren. Es kann abst√ºrzen und dennoch ein g√ºltiges C-Programm sein.  Korrigieren Sie gem√§√ü dem Standard - obwohl es nicht korrekt ist, weil es abst√ºrzt.  Es ist also sehr schwer, in C zu programmieren, weil es so viele gibt ... Ein weiteres gutes Beispiel: Was ist das Ergebnis, wenn Sie zwei Zeiger subtrahieren?  Niemand hier arbeitet mit C? <br><br>  <b>- Nein, also grillen Sie sie nicht.</b>  <b>C ++ unterst√ºtzt jedoch verschiedene Typen.</b> <br><br>  - Nein, C ++ hat das gleiche Problem. <br><br>  <b>- Was ist die Art der Erkl√§rung?</b>  <b><code>ptrdiff_t</code> ?</b> <br><br>  - Genau, <code>ptrdiff_t</code> ist ein signierter Typ.  Wenn Sie also einen Standardspeicher mit der Gr√∂√üe Ihres Wortes haben und zwei Zeiger in diesem Bereich subtrahieren, k√∂nnen Sie normalerweise nicht alle Gr√∂√üen im signierten Typ darstellen.  Was sagt der Standard dazu? <br><br>  Wenn Sie zwei Zeiger subtrahieren und die Antwort in einen Zeigerdifferenz passt, ist dies die Antwort.  Ansonsten haben Sie undefiniertes Verhalten.  Und woher wei√üt du, ob es passt?  Das tust du nicht.  Wenn Sie also zwei Zeiger subtrahieren, wissen Sie normalerweise, dass dies nicht dem Standard entspricht. Wenn Sie auf etwas zeigen, das gr√∂√üer als mindestens 2 Byte ist, ist die gr√∂√üere Gr√∂√üe halb so gro√ü wie der Speicher, sodass alles in Ordnung ist. <br><br>  Sie haben also nur dann ein Problem, wenn Sie auf Bytes oder Zeichen zeigen.  Aber wenn Sie das tun, haben Sie ein echtes Problem. Sie k√∂nnen keine Zeigerarithmetik durchf√ºhren, ohne sich Sorgen machen zu m√ºssen, dass Sie eine Zeichenfolge haben, die gr√∂√üer als die H√§lfte des Speichers ist.  Und dann kann ich nicht einfach die Gr√∂√üe berechnen und in einem Zeigerdiff-Typ speichern, weil es falsch ist. <br><br>  Das meine ich mit einem sicheren C- oder C ++ - Programm, das wirklich sicher ist. <br><br>  <b>- Haben Sie dar√ºber nachgedacht, Lua in einer anderen Sprache zu implementieren?</b>  <b>√Ñndern Sie es von C zu etwas anderem?</b> <br><br>  - Als wir angefangen haben, habe ich √ºber C ++ nachgedacht, aber wie gesagt, ich habe es wegen der Komplexit√§t aufgegeben - ich kann nicht die ganze Sprache lernen.  Es sollte n√ºtzlich sein, ein paar Sachen aus C ++ zu haben, aber ... bis heute sehe ich keine Sprache, die das tun w√ºrde. <br><br>  <b>- Kannst du erkl√§ren warum?</b> <br><br>  - Weil ich keine Alternativen habe.  Ich kann nur erkl√§ren, warum gegen andere Sprachen.  Ich sage nicht, dass C perfekt oder sogar gut ist, aber es ist das Beste.  Um zu erkl√§ren warum, muss ich es mit anderen Sprachen vergleichen. <br><br>  <b>- Was ist mit JVM?</b> <br><br>  - Oh, JVM.  Komm schon, es passt nicht in die H√§lfte der Hardware ... Portabilit√§t ist der Hauptgrund, aber auch Leistung.  In JVM ist es ein bisschen besser als .NET, aber es ist nicht so anders.  Viele Dinge, die Lua tut, k√∂nnen wir mit JVM nicht tun.  Sie k√∂nnen beispielsweise den Garbage Collector nicht steuern.  Sie m√ºssen den JVM-Garbage Collector verwenden, da auf JVM kein anderer Garbage Collector implementiert werden kann.  JVM ist auch ein gro√üer Speicherkonsument.  Wenn ein Java-Programm anf√§ngt, Hallo zu sagen, sind es ungef√§hr 10 MB.  Portabilit√§t ist ein Problem, nicht weil es nicht portiert wurde, sondern weil es nicht portiert werden kann. <br><br>  <b>- Was ist mit JVM-Modifikationen wie Mobile JVM?</b> <br><br>  - Das ist keine JVM, das ist ein Witz.  Es ist wie eine Micro Edition von Java, nicht Java. <br><br>  <b>- Wie w√§re es mit anderen statischen Sprachen wie Go oder Oberon?</b>  <b>K√∂nnten sie die Basis f√ºr Lua sein, wenn Sie es heute schaffen w√ºrden?</b> <br><br>  - Oberon ... k√∂nnte sein, es kommt darauf an ... Go hat wieder einen M√ºllsammler und eine zu gro√üe Laufzeit f√ºr Lua.  Oberon w√§re eine Option, aber Oberon hat einige sehr seltsame Dinge, wie Sie fast keine Konstanten haben, wenn ich mich richtig erinnere.  Ja, ich denke, sie haben const von Pascal nach Oberon entfernt.  Ich hatte ein Buch √ºber Oberon und liebte Oberon.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">System</a> war unglaublich, es ist wirklich etwas. <br><br>  Ich erinnere mich, dass ich 1994 eine Demonstration von Oberon und Self gesehen habe.  Kennst du dich selbst?  Es ist eine sehr interessante dynamische Sprache mit Jit-Compilern usw. Ich habe diese Demos im Abstand von einer Woche gesehen, und Self war sehr schlau. Sie verwendeten einige Techniken aus Cartoons, um die Langsamkeit der Operationen zu verschleiern.  Denn als du etwas ge√∂ffnet hast, war es wie 'woop!'  - zuerst reduziert es sich ein wenig, dann dehnt es sich mit einigen Effekten aus.  Es wurde sehr gut implementiert, diese Techniken verwendeten sie, um Bewegung zu simulieren ... <br><br>  Dann, eine Woche sp√§ter, sahen wir eine Demo von Oberon, die auf 1/10 der Hardware f√ºr Self lief - da war diese sehr alte kleine Maschine.  In Oberon klickt man und boomt dann einfach, alles funktioniert sofort, das ganze System war so leicht. <br><br>  Aber f√ºr mich ist es zu minimalistisch, sie haben Konstanten und Variantentypen entfernt. <br><br>  <b>- Haskell?</b> <br><br>  - Ich wei√ü nicht, wie Haskell Lua in Haskell implementiert. <br><br>  <b>- Und wie stehen Sie zu Sprachen wie Python oder R oder Julia als Grundlage f√ºr zuk√ºnftige Implementierungen von Lua?</b> <br><br>  - Ich denke, jeder von diesen hat seinen Nutzen. <br><br>  R scheint gut f√ºr Statistiken zu sein.  Es ist sehr dom√§nenspezifisch und wird von Menschen in der Region durchgef√ºhrt. Dies ist also eine St√§rke. <br><br>  Python ist nett, aber ich hatte pers√∂nliche Probleme damit.  Ich dachte, ich h√§tte es in meinem Vortrag oder im Interview erw√§hnt.  Das Ding, die ganze Sprache nicht zu kennen oder sie nicht zu benutzen, der Irrtum der Teilmenge. <br><br>  Wir verwenden Python in unseren Kursen und unterrichten grundlegende Programmierung - nur einen kleinen Teil, Schleifen und ganze Zahlen.  Alle waren gl√ºcklich und sagten dann, es w√§re sch√∂n, einige grafische Anwendungen zu haben, also brauchten wir eine grafische Bibliothek.  Und bei fast allen grafischen Bibliotheken erhalten Sie die API ... Aber ich kenne Python nicht genug, das ist viel fortgeschrittenes Zeug.  Es hat die Illusion, dass es einfach ist und ich habe all diese Bibliotheken f√ºr alles, aber es ist entweder einfach oder Sie haben alles. <br><br>  Wenn Sie also anfangen, die Sprache zu verwenden, dann fangen Sie an: Oh, ich muss OOP lernen, Vererbung, was auch immer.  Jede einzelne Bibliothek.  Es sieht so aus, als ob Autoren stolz darauf sind, erweiterte Sprachfunktionen in ihrer API zu verwenden, um zu zeigen, dass ich nicht wei√ü, was.  Funktionsaufrufe, Standardtypen usw.  Sie haben dieses Objekt und wenn Sie etwas anderes wollen, m√ºssen Sie ein anderes Objekt erstellen ... <br><br>  Selbst beim Mustervergleich k√∂nnen Sie einige einfache Dinge tun, aber normalerweise ist der Standardmustervergleich nicht etwas, was Sie tun.  Sie f√ºhren einen Abgleich durch, ein Objekt gibt ein Ergebnis zur√ºck und rufen dann Methoden f√ºr dieses Objektergebnis auf, um das tats√§chliche Ergebnis des Abgleichs zu erhalten.  Manchmal gibt es einen einfacheren Weg, aber es ist nicht offensichtlich, es ist nicht der Weg, den die meisten Leute benutzen. <br><br>  Ein weiteres Beispiel: Ich unterrichtete einen Kurs zum Pattern Matching und wollte Perl-√§hnliche Syntax verwenden. Aufgrund einer v√∂llig anderen Syntax konnte ich Lua nicht verwenden.  Also dachte ich, Python w√§re das perfekte Beispiel.  Aber in Python gibt es einige direkte Funktionen f√ºr einige grundlegende Dinge, aber f√ºr alles Komplexere m√ºsste man Objekte und Methoden usw. kennen.  Ich wollte nur etwas tun und das Ergebnis haben. <br><br>  <b>- Was hast du letztendlich benutzt?</b> <br><br>  - Ich habe Python benutzt und es ihnen erkl√§rt.  Aber selbst Perl ist viel einfacher, Sie machen das Match und die Ergebnisse sind $ 1, $ 2, $ 3, es ist viel einfacher, aber ich habe nicht den Mut, Perl zu verwenden, also ... <br><br>  <b>- Ich habe Python zwei Jahre lang verwendet, bevor ich bemerkte, dass es Dekorateure gab.</b>  <b>(Frage von Jaroslaw Dynnikow vom Tarantool-Team)</b> <br><br>  - Ja, und wenn Sie eine Bibliothek verwenden m√∂chten, m√ºssen Sie dieses Zeug lernen und verstehen API usw. nicht.  Python gibt die Illusion, dass es einfach, aber ziemlich komplex ist. <br><br>  ... Und Julia, ich wei√ü nicht viel √ºber Julia, aber es erinnerte mich an LuaJIT in dem Sinne, dass es manchmal wie der Stolz des Benutzers aussieht.  Sie k√∂nnen sehr gute Ergebnisse erzielen, aber Sie m√ºssen wirklich verstehen, was los ist.  Es ist nicht so, dass Sie Code schreiben und gute Ergebnisse erzielen.  Nein, Sie schreiben Code und manchmal sind die Ergebnisse gut, manchmal sind sie schrecklich.  Und wenn die Ergebnisse schrecklich sind, haben Sie viele gute Tools, die Ihnen die Zwischensprache zeigen, die einmal generiert wurde. Sie √ºberpr√ºfen sie und gehen dann den gesamten fast Assembler-Code durch.  Dann merkt man: Oh, das wird deshalb nicht optimiert.  Das ist das Problem der Programmierer, sie m√∂gen Spiele und manchmal m√∂gen sie Dinge, weil es schwierig ist, nicht weil es einfach ist. <br><br>  Ich wei√ü nicht viel √ºber Julia, aber ich habe einmal ein Gespr√§ch dar√ºber gesehen.  Und der Typ, der redet, war derjenige, der diesen Standpunkt vertrat: Sehen Sie, wie sch√∂n es ist, wir haben dieses Programm geschrieben und es ist perfekt.  Ich erinnere mich nicht viel an etwas √ºber Matrixmultiplikation, denke ich.  Und dann sind die Wagen perfekt, dann sind die Doppel perfekt, und dann setzen sie komplexe [Zahlen] ... und es war eine Trag√∂die.  Wie hundertmal langsamer. <br><br>  (sarkastisch) 'Sehen Sie, wie sch√∂n es ist, wir haben dieses Werkzeug, wir k√∂nnen die gesamte Baugruppe [Auflistung] sehen, und dann gehen Sie und √§ndern das und das und das.  Sehen Sie, wie effizient dies ist.  Ja, ich verstehe, ich kann direkt in der Montage programmieren. <br><br>  Aber das war nur ein Gespr√§ch.  Ich habe ein wenig R studiert und habe einige Benutzererfahrungen mit Python f√ºr kleine Dinge. <br><br>  <b>- Was denkst du √ºber Erlang?</b> <br><br>  - Erlang ist eine lustige Sprache.  Es hat einige wirklich gute Anwendungen, Fehlertoleranz ist wirklich interessant.  Aber sie behaupten, es sei eine funktionale Sprache und die ganze Idee der funktionalen Sprache ist, dass Sie keinen Zustand haben. <br><br>  Und Erlang hat einen riesigen versteckten Zustand in den Nachrichten, die gesendet und noch nicht empfangen werden.  Jeder kleine Prozess ist also voll funktionsf√§hig, aber das Programm selbst ist v√∂llig funktionsunf√§hig. <br><br>  Es ist ein Durcheinander von versteckten Daten, das viel schlimmer ist als globale Variablen, denn wenn es globale Variablen w√§ren, w√ºrden Sie sie drucken.  Nachrichten, die den tats√§chlichen Status Ihres Systems darstellen.  Wie ist der Zustand des Systems in jedem einzelnen Moment?  Es werden all diese Nachrichten hier und da gesendet.  Es ist √ºberhaupt nicht funktionsf√§hig. <br><br>  <b>- Erlang l√ºgt also, funktional zu sein, und Python l√ºgt, einfach zu sein.</b>  <b>Wor√ºber l√ºgt Lua?</b> <br><br>  - Lua l√ºgt ein bisschen dar√ºber, klein zu sein.  Es ist immer noch kleiner als die meisten anderen Sprachen, aber wenn Sie eine wirklich kleine Sprache wollen, ist Lua gr√∂√üer als Sie wollen. <br><br>  <b>- Was ist dann eine kleine Sprache?</b> <br><br>  - Forth ist, ich liebe Forth. <br><br>  <b>- Gibt es Platz f√ºr eine kleinere Version von Lua?</b> <br><br>  - Vielleicht, aber es ist schwierig.  Ich liebe Tische, aber Tische sind nicht sehr klein.  Wenn Sie kleine Dinge darstellen m√∂chten, passt die ganze Idee hinter Tischen nicht zu Ihnen.  Es w√§re die Syntax von Lua, wir w√ºrden es Lua nennen, aber es ist nicht Lua. <br><br>  Es w√§re genau wie bei der Java Micro Edition.  Sie nennen es Java, aber hat es Multithreading?  Nein, das tut es nicht.  Hat es ein Spiegelbild?  Nein, das tut es nicht.  Warum also?  Es hat eine Java-Syntax, das gleiche System, aber es ist √ºberhaupt kein Java.  Es ist eine andere Sprache, die leichter zu lernen ist, wenn Sie Java kennen, aber nicht Java. <br><br>  Wenn Sie eine kleine Sprache erstellen m√∂chten, die wie Lua aussieht, Lua ohne Tabellen jedoch nicht ... Wahrscheinlich sollten Sie Tabellen deklarieren m√ºssen, so etwas wie FFI, um klein sein zu k√∂nnen. <br><br>  <b>- Gibt es kleinere Anpassungen von Lua?</b> <br><br>  - Vielleicht wei√ü ich es nicht. <br><br>  <b>- Ist Lua bereit f√ºr eine reine funktionale Programmierung?</b>  <b>Schaffst du das mit Lua?</b> <br><br>  - Nat√ºrlich kannst du.  Es ist nicht besonders effizient, aber nur Haskell ist daf√ºr wirklich effizient.  Wenn Sie anfangen, Monaden und √§hnliches zu verwenden, neue Funktionen erstellen, Funktionen komponieren usw. Sie k√∂nnen [das] mit Lua tun, es l√§uft ziemlich vern√ºnftig, aber Sie ben√∂tigen Implementierungstechniken, die sich von normalen imperativen Sprachen unterscheiden, um etwas wirklich Effizientes zu tun. <br><br> <b>‚Äî Actually, there is a library for functional programming in Lua.</b> <br><br> ‚Äî Yes, it's reasonable and usable, if you do really need performance; you can do a lot of stuff with it. I love functional stuff and I do it all the time. <br><br> <b>‚Äî My question is more about the garbage collector, because we only have only mutable objects and we have to use them efficiently. Will Lua be good for that?</b> <br><br> ‚Äî I think a new incarnation of garbage collector will help a lot, but again‚Ä¶ <br><br> <b>‚Äî Young die young? The one that seems to work with young objects?</b> <br><br> ‚Äî Exactly, yes. But as I said even with the standard garbage collector we don't have optimal performance but it can be reasonable. More often you don't even need that performance for most actions unless you are writing servers and having big operations. <br><br> <b>‚Äî What functional programming tasks do you perform in Lua?</b> <br><br> ‚Äî A simple example. My book, I'm writing my own format and I have a formatter that transforms that in LaTex or DocBook. It's completely functional, it has a big pattern matching‚Ä¶ It's slightly inspired by LaTex but much more uniformed. There's @ symbol instead of backslash, a name of a macro and one single argument in curly brackets. So I have gsub that recognizes this kind of stuff and then it calls a function, the function does something and returns something. It's all functional, just functions on top of functions on top of functions, and the final function gives a big result. <br><br> <b>‚Äî Why don't you program with LaTeX?</b> <br><br> ‚Äî Plain LaTeX? First, it's too tricky for a lot of stuff and so difficult. I have several things that I don't know how to do in LaTex. For example, I want to put a piece of inline code inside a text. Then there is a slash verb, standard stuff. But slash verb gives fixed space. And the space between stuff is never right. All real spaces are variable, it depends on how the line is adjusted, so it expands in some spaces and compacts in others depending on a lot of stuff. And those spaces are fixed, so sometimes they look too large, sometimes too small. It also depends on what you put in code. <br><br> <b>‚Äî But you still render your own format to LaTeX?</b> <br><br> ‚Äî Yes, but with a lot of preprocessing. I write my own verb but then it changes and becomes not a verb but a lot of stuff. For example, when I write 3+1 I write a very small space here. In verb, if I don't put any space here, it shrinks, and if I do, it's too large. So I do the preprocessing, inserting a variable space. It's very small but can be a little larger if it needs to adjust. But if I put 'and' after 1 then I put a larger space. This function here does all that. This is a small example but there are other things‚Ä¶ <br><br> <b>‚Äî Do you have a source?</b> <br><br> ‚Äî I do have the source, it is in the <a href="">git</a> . The program's called <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2html</a> . The current version only generates HTML‚Ä¶ Sorry, that's a kind of a mess. I created it for a book but also another one for the manual. The one in the git is for the manual. But the other one is more complicated and not public, I can't make it public. But the main problem is that TeX is not there. It's almost impossible to process TeX files without TeX itself. <br><br> <b>‚Äî Is it not machine-readable?</b> <br><br> ‚Äî Yes, it's not machine-readable. I mean, it is readable because TeX reads it. It's so hard to test, so many strange rules etc. So this is much more uniformed and as I said I generate DocBook format, sometimes I need it. That started when I had this contract for a book. <br><br> <b>‚Äî So you use 2html to generate DocBook?</b> <br><br> ‚Äî Yes, it generates DocBook directly. <br><br> <b>‚Äî Ok, thank you very much for the interview!</b> <br><br><hr><br> If you have any more questions, you can ask them in the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lua Mailing List</a> . See you soon! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459466/">https://habr.com/ru/post/de459466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459456/index.html">Dagaz: Episoden (Teil 1)</a></li>
<li><a href="../de459458/index.html">ok.tech: Daten erkl√§ren # 2</a></li>
<li><a href="../de459460/index.html">Die Schwierigkeiten bei der Arbeit mit Redux und deren L√∂sung</a></li>
<li><a href="../de459462/index.html">SEO f√ºr Yandex. Alle suchen?</a></li>
<li><a href="../de459464/index.html">Lua in Moskau 2019: Interview mit Roberto Jerusalem</a></li>
<li><a href="../de459470/index.html">Teil 4: Linux l√§uft immer noch unter RISC-V RISC-V</a></li>
<li><a href="../de459472/index.html">Heroku + Docker + Spring Boot</a></li>
<li><a href="../de459474/index.html">So erstellen Sie in einer Sekunde perfekt getippten Text: ein Makro in Word f√ºr diejenigen, die viel schreiben</a></li>
<li><a href="../de459478/index.html">Meine Erfahrung beim Erstellen einer Multithread-Anwendung f√ºr die Arbeit mit Backups</a></li>
<li><a href="../de459480/index.html">Vivaldi: Wie verdient der Browser Geld?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>