<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§± üìÑ ü§ò Practical Go: Tipps zum Schreiben unterst√ºtzter Programme in der realen Welt üßíüèº üçà ü§≤üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf bew√§hrte Methoden zum Schreiben von Go-Code. Es ist im Pr√§sentationsstil komponiert, jedoch ohne die √ºblichen Fol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Practical Go: Tipps zum Schreiben unterst√ºtzter Programme in der realen Welt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441842/">  Dieser Artikel konzentriert sich auf bew√§hrte Methoden zum Schreiben von Go-Code.  Es ist im Pr√§sentationsstil komponiert, jedoch ohne die √ºblichen Folien.  Wir werden versuchen, jeden Punkt kurz und klar durchzugehen. <br><br>  Zun√§chst m√ºssen Sie sich darauf einigen, was die <i>Best</i> Practices f√ºr eine Programmiersprache bedeuten.  Hier k√∂nnen Sie sich an die Worte von Russ Cox, technischer Direktor von Go, erinnern: <br><br><blockquote>  Software-Engineering passiert mit der Programmierung, wenn Sie den Zeitfaktor und andere Programmierer hinzuf√ºgen. </blockquote><br>  So unterscheidet Russ zwischen den Konzepten der <i>Programmierung</i> und der <i>Softwareentwicklung</i> .  Im ersten Fall schreiben Sie ein Programm f√ºr sich selbst, im zweiten erstellen Sie ein Produkt, an dem andere Programmierer im Laufe der Zeit arbeiten werden.  Ingenieure kommen und gehen.  Teams wachsen oder schrumpfen.  Neue Funktionen wurden hinzugef√ºgt und Fehler behoben.  Dies ist die Natur der Softwareentwicklung. <br><a name="habracut"></a><br><a name="0"></a><h1>  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Grundprinzipien</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einfachheit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesbarkeit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Produktivit√§t</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Kennungen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namenskennungen basieren eher auf Klarheit als auf K√ºrze</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ID L√§nge</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benennen Sie Variablen nicht nach Typ</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden Sie einen einzelnen Namensstil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden Sie einen einzelnen Deklarationsstil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeite f√ºr das Team</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Kommentare</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare in Variablen und Konstanten sollten ihren Inhalt beschreiben, nicht den Zweck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentieren Sie immer √∂ffentlich verf√ºgbare Zeichen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Paketstruktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein gutes Paket beginnt mit einem guten Namen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vermeiden Sie Namen wie base, common oder util</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komm schnell zur√ºck, ohne tief zu tauchen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Machen Sie den Nullwert n√ºtzlich</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vermeiden Sie den Status auf Paketebene</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Projektstruktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weniger Pakete, aber gr√∂√üer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das kleinste Hauptpaket</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. API-Struktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Design-APIs, die vom Design her schwer zu missbrauchen sind</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwerfen Sie eine API f√ºr einen grundlegenden Anwendungsfall</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lassen Sie die Funktionen das gew√ºnschte Verhalten bestimmen.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Fehlerbehandlung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beseitigen Sie die Notwendigkeit der Fehlerbehandlung, indem Sie die Fehler selbst entfernen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Behandeln Sie den Fehler nur einmal</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Parallelit√§t</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mach die ganze Zeit etwas Arbeit.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberlassen Sie die Parallelit√§t dem Anrufer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºhren Sie niemals Goroutine aus, ohne zu wissen, wann es aufh√∂ren wird</a> </li></ul></li></ul><br><a name="1"></a><h1>  1. Grundprinzipien </h1><br>  Ich bin vielleicht einer der ersten Benutzer von Go unter Ihnen, aber dies ist nicht meine pers√∂nliche Meinung.  Diese Grundprinzipien liegen Go selbst zugrunde: <br><br><ol><li>  Einfachheit </li><li>  Lesbarkeit </li><li>  Produktivit√§t </li></ol><br>  <i>Hinweis</i>  <i>Bitte beachten Sie, dass ich weder "Leistung" noch "Parallelit√§t" erw√§hnt habe.</i>  <i>Es gibt Sprachen, die schneller als Go sind, aber sie k√∂nnen sicherlich nicht einfach verglichen werden.</i>  <i>Es gibt Sprachen, bei denen Parallelit√§t oberste Priorit√§t hat, die jedoch hinsichtlich Lesbarkeit oder Programmierproduktivit√§t nicht verglichen werden k√∂nnen.</i> <i><br><br></i>  <i>Leistung und Parallelit√§t sind wichtige Attribute, aber nicht so wichtig wie Einfachheit, Lesbarkeit und Produktivit√§t.</i> <br><br><a name="1_1"></a><h2>  Einfachheit </h2><br><blockquote>  <i>‚ÄûEinfachheit ist Voraussetzung f√ºr Zuverl√§ssigkeit‚Äú</i> - Edsger Dijkstra </blockquote><br>  Warum nach Einfachheit streben?  Warum ist es wichtig, dass Go-Programme einfach sind? <br><br>  Jeder von uns ist auf einen unverst√§ndlichen Code gesto√üen, oder?  Wenn Sie Angst haben, √Ñnderungen vorzunehmen, weil dadurch ein anderer Teil des Programms besch√§digt wird, den Sie nicht ganz verstehen und den Sie nicht beheben k√∂nnen.  Das ist die Schwierigkeit. <br><br><blockquote>  <i>‚ÄûEs gibt zwei M√∂glichkeiten, Software zu entwerfen: Die erste besteht darin, sie so einfach zu gestalten, dass keine offensichtlichen M√§ngel vorliegen, und die zweite darin, sie so komplex zu gestalten, dass keine offensichtlichen M√§ngel vorliegen.</i>  <i>Das erste ist viel schwieriger. ‚Äù</i> - C. E. R. Hoar </blockquote><br>  Komplexit√§t macht zuverl√§ssige Software unzuverl√§ssig.  Komplexit√§t ist das, was Softwareprojekte t√∂tet.  Einfachheit ist daher das ultimative Ziel von Go.  Welche Programme wir auch schreiben, sie sollten einfach sein. <br><br><a name="1_2"></a><h2>  1.2.  Lesbarkeit </h2><br><blockquote>  <i>‚ÄûLesbarkeit ist ein wesentlicher Bestandteil der Wartbarkeit‚Äú</i> - Mark Reinhold, JVM-Konferenz, 2018 </blockquote><br>  Warum ist es wichtig, dass der Code lesbar ist?  Warum sollten wir uns um Lesbarkeit bem√ºhen? <br><br><blockquote>  <i>"Programme sollten f√ºr Menschen geschrieben werden, und Maschinen f√ºhren sie einfach aus"</i> - Hal Abelson und Gerald Sassman, "Struktur und Interpretation von Computerprogrammen" </blockquote><br>  Nicht nur Go-Programme, sondern im Allgemeinen wird die gesamte Software von Menschen f√ºr Menschen geschrieben.  Die Tatsache, dass Maschinen auch Code verarbeiten, ist zweitrangig. <br><br>  Einmal geschriebener Code wird wiederholt von Menschen gelesen: hunderte, wenn nicht tausende Male. <br><br><blockquote>  <i>‚ÄûDie wichtigste F√§higkeit eines Programmierers ist die F√§higkeit, Ideen effektiv zu kommunizieren.‚Äú</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gaston Horker</a> </blockquote><br>  Lesbarkeit ist der Schl√ºssel zum Verst√§ndnis der Funktionsweise eines Programms.  Wenn Sie den Code nicht verstehen k√∂nnen, wie k√∂nnen Sie ihn pflegen?  Wenn die Software nicht unterst√ºtzt werden kann, wird sie neu geschrieben.  Dies ist m√∂glicherweise das letzte Mal, dass Ihr Unternehmen Go verwendet. <br><br>  Wenn Sie ein Programm f√ºr sich selbst schreiben, tun Sie, was f√ºr Sie funktioniert.  Wenn dies jedoch Teil eines gemeinsamen Projekts ist oder das Programm lange genug verwendet wird, um die Anforderungen, Funktionen oder die Umgebung, in der es funktioniert, zu √§ndern, besteht Ihr Ziel darin, das Programm wartbar zu machen. <br><br>  Der erste Schritt zum Schreiben unterst√ºtzter Software besteht darin, sicherzustellen, dass der Code klar ist. <br><br><a name="1_3"></a><h2>  1.3.  Produktivit√§t </h2><br><blockquote>  <i>‚ÄûDesign ist die Kunst, Code so zu organisieren, dass er heute funktioniert, aber immer Ver√§nderungen unterst√ºtzt.‚Äú</i> - Sandy Mets </blockquote><br>  Als letztes Grundprinzip m√∂chte ich die Produktivit√§t des Entwicklers nennen.  Dies ist ein gro√ües Thema, aber es kommt auf das Verh√§ltnis an: wie viel Zeit Sie f√ºr n√ºtzliche Arbeit aufwenden und wie viel - auf eine Antwort von Tools oder hoffnungslose Irrfahrten in einer unverst√§ndlichen Codebasis warten.  Go-Programmierer sollten das Gef√ºhl haben, dass sie viel Arbeit erledigen k√∂nnen. <br><br>  Es ist ein Witz, dass die Go-Sprache w√§hrend des Kompilierens des C ++ - Programms entwickelt wurde.  Die schnelle Kompilierung ist ein wichtiges Merkmal von Go und ein Schl√ºsselfaktor f√ºr die Gewinnung neuer Entwickler.  Obwohl die Compiler verbessert werden, dauert die Minutenkompilierung in anderen Sprachen im Allgemeinen einige Sekunden.  So f√ºhlen sich Go-Entwickler genauso produktiv wie Programmierer in dynamischen Sprachen, jedoch ohne Probleme mit der Zuverl√§ssigkeit dieser Sprachen. <br><br>  Wenn wir grundlegend √ºber die Produktivit√§t von Entwicklern sprechen, verstehen Go-Programmierer, dass das Lesen von Code wesentlich wichtiger ist als das Schreiben.  In dieser Logik geht Go sogar so weit, die Werkzeuge zu verwenden, um den gesamten Code in einem bestimmten Stil zu formatieren.  Dies beseitigt die geringste Schwierigkeit, den spezifischen Dialekt eines bestimmten Projekts zu lernen, und hilft, Fehler zu identifizieren, da sie im Vergleich zu normalem Code einfach falsch <i>aussehen</i> . <br><br>  Go-Programmierer verbringen keine Tage damit, seltsame Kompilierungsfehler, komplexe Build-Skripte oder das Bereitstellen von Code in einer Produktionsumgebung zu debuggen.  Und vor allem verschwenden sie keine Zeit damit, zu verstehen, was ein Kollege geschrieben hat. <br><br>  Wenn Go-Entwickler √ºber <i>Skalierbarkeit</i> sprechen, bedeutet dies Produktivit√§t. <br><br><a name="2"></a><h1>  2. Kennungen </h1><br>  Das erste Thema, das wir diskutieren werden - <i>Bezeichner</i> - ist ein Synonym f√ºr <i>Namen</i> : Namen von Variablen, Funktionen, Methoden, Typen, Paketen usw. <br><br><blockquote>  <i>"Schlechter Name ist ein Symptom f√ºr schlechtes Design"</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave Cheney</a> </blockquote><br>  Aufgrund der eingeschr√§nkten Syntax von Go haben Objektnamen einen gro√üen Einfluss auf die Programmlesbarkeit.  Die Lesbarkeit ist ein Schl√ºsselfaktor f√ºr guten Code, daher ist die Auswahl guter Namen von entscheidender Bedeutung. <br><br><a name="2_1"></a><h2>  2.1.  Namenskennungen basieren eher auf Klarheit als auf K√ºrze </h2><br><blockquote>  <i>‚ÄûEs ist wichtig, dass der Code offensichtlich ist.</i>  <i>Was Sie in einer Zeile tun k√∂nnen, m√ºssen Sie in drei tun. ‚Äú</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ukia Smith</a> </blockquote><br>  Go ist nicht f√ºr knifflige Einzeiler oder die Mindestanzahl von Zeilen in einem Programm optimiert.  Wir optimieren weder die Gr√∂√üe des Quellcodes auf der Festplatte noch die Zeit, die zum Eingeben des Programms in den Editor erforderlich ist. <br><br><blockquote>  <i>‚ÄûEin guter Name ist wie ein guter Witz.</i>  <i>Wenn Sie es erkl√§ren m√ºssen, ist es nicht mehr lustig. "</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave Cheney</a> </blockquote><br>  Der Schl√ºssel zu maximaler Klarheit sind die Namen, die wir zur Identifizierung von Programmen ausw√§hlen.  Welche Eigenschaften hat ein guter Name? <br><br><ul><li>  <b>Ein guter Name ist pr√§gnant</b> .  Es muss nicht das k√ºrzeste sein, enth√§lt aber keinen √úberschuss.  Es hat ein hohes Signal-Rausch-Verh√§ltnis. </li><li>  <b>Ein guter Name ist beschreibend</b> .  Es beschreibt die Verwendung einer Variablen oder Konstante, <i>nicht des</i> Inhalts.  Ein guter Name beschreibt das Ergebnis einer Funktion oder das Verhalten einer Methode, <i>nicht einer</i> Implementierung.  Der Zweck des Pakets, <i>nicht</i> sein Inhalt.  Je genauer der Name das Identifizierende beschreibt, desto besser. </li><li>  <b>Ein guter Name ist vorhersehbar</b> .  Unter einem Namen m√ºssen Sie verstehen, wie das Objekt verwendet wird.  Die Namen sollten beschreibend sein, aber es ist auch wichtig, der Tradition zu folgen.  Das ist es, was Go-Programmierer meinen, wenn sie <i>"idiomatisch"</i> sagen. </li></ul><br>  Lassen Sie uns jede dieser Eigenschaften genauer betrachten. <br><br><a name="2_2"></a><h2>  2.2.  ID L√§nge </h2><br>  Manchmal wird Go's Stil f√ºr kurze Variablennamen kritisiert.  Wie Rob Pike <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> : "Go-Programmierer wollen Bezeichner mit der <i>richtigen</i> L√§nge." <br><br>  Andrew Gerrand bietet l√§ngere Kennungen an, um die Wichtigkeit anzuzeigen. <br><br><blockquote>  <i>‚ÄûJe gr√∂√üer der Abstand zwischen der Angabe eines Namens und der Verwendung eines Objekts ist,</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">desto</a> <i>l√§nger sollte der Name sein‚Äú</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Gerrand</a> </blockquote><br>  Daher k√∂nnen einige Empfehlungen gegeben werden: <br><br><ul><li>  Kurze Variablennamen sind gut, wenn der Abstand zwischen der Deklaration und der <i>letzten</i> Verwendung gering ist. <br></li><li>  Lange Variablennamen sollten sich rechtfertigen;  Je l√§nger sie sind, desto wichtiger sollten sie sein.  Ausf√ºhrliche Titel enthalten wenig Signal in Bezug auf ihr Gewicht auf der Seite. <br></li><li>  F√ºgen Sie den Typnamen nicht in den Variablennamen ein. <br></li><li>  Konstante Namen sollten den internen Wert beschreiben, nicht wie der Wert verwendet wird. <br></li><li>  Bevorzugen Sie Einzelbuchstabenvariablen f√ºr Schleifen und Verzweigungen, separate W√∂rter f√ºr Parameter und R√ºckgabewerte, mehrere W√∂rter f√ºr Funktionen und Deklarationen auf Paketebene. <br></li><li>  Bevorzugen Sie einzelne W√∂rter f√ºr Methoden, Schnittstellen und Pakete. <br></li><li>  Denken Sie daran, dass der Paketname Teil des Namens ist, den der Aufrufer als Referenz verwendet. </li></ul><br>  Betrachten Sie ein Beispiel. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// AverageAge returns the average age of people. func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count }</span></span></code> </pre> <br>  In der zehnten Zeile wird eine Variable des Bereichs <code>p</code> deklariert und ab der n√§chsten Zeile nur einmal aufgerufen.  Das hei√üt, die Variable lebt f√ºr eine sehr kurze Zeit auf der Seite.  Wenn der Leser an der Rolle von <code>p</code> im Programm interessiert ist, muss er nur zwei Zeilen lesen. <br><br>  Zum Vergleich werden <code>people</code> in Funktionsparametern deklariert und sieben Zeilen leben.  Das Gleiche gilt f√ºr <code>sum</code> und <code>count</code> , daher rechtfertigen sie ihre l√§ngeren Namen.  Der Leser muss mehr Code scannen, um sie zu finden. Dies rechtfertigt die differenzierteren Namen. <br><br>  Sie k√∂nnen <code>s</code> f√ºr <code>sum</code> und <code>c</code> (oder <code>n</code> ) f√ºr <code>count</code> w√§hlen, dies reduziert jedoch die Bedeutung aller Variablen im Programm auf die gleiche Ebene.  Sie k√∂nnen <code>people</code> durch <code>p</code> ersetzen, aber es wird ein Problem geben, wie die Iterationsvariable <code>for ... range</code> aufgerufen <code>for ... range</code> .  Eine einzelne <code>person</code> sieht seltsam aus, da eine kurzlebige Iterationsvariable einen l√§ngeren Namen erh√§lt als mehrere Werte, von denen sie abgeleitet ist. <br><br><blockquote>  <b>Tipp</b> .  Trennen Sie den Funktionsstrom durch leere Zeilen, da leere Zeilen zwischen Abs√§tzen den Textfluss unterbrechen.  In <code>AverageAge</code> haben wir drei aufeinanderfolgende Operationen.  √úberpr√ºfen Sie zuerst die Division durch Null, dann die Schlussfolgerung des Gesamtalters und der Anzahl der Personen und zuletzt die Berechnung des Durchschnittsalters. </blockquote><br><h3>  2.2.1.  Die Hauptsache ist der Kontext </h3><br>  Es ist wichtig zu verstehen, dass die meisten Benennungstipps kontextspezifisch sind.  Ich m√∂chte sagen, dass dies ein Prinzip ist, keine Regel. <br><br>  Was ist der Unterschied zwischen <code>i</code> und <code>index</code> ?  Zum Beispiel k√∂nnen Sie nicht eindeutig sagen, dass ein solcher Code <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index := <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); index++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  grunds√§tzlich besser lesbar als <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); i++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  Ich glaube, dass die zweite Option nicht schlechter ist, da in diesem Fall der Bereich <code>i</code> oder der <code>index</code> durch den K√∂rper der <code>for</code> Schleife begrenzt ist und die zus√§tzliche Ausf√ºhrlichkeit wenig zum Verst√§ndnis des Programms beitr√§gt. <br><br>  Aber welche dieser Funktionen ist besser lesbar? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oid []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, index </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  oder <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  In diesem Beispiel ist <code>oid</code> eine Abk√ºrzung f√ºr SNMP Object ID, und die zus√§tzliche Abk√ºrzung f√ºr <code>o</code> zwingt Sie, beim Lesen von Code von einer dokumentierten zu einer k√ºrzeren Notation im Code zu wechseln.  In √§hnlicher Weise ist das Verstehen des <code>index</code> auf <code>i</code> schwieriger zu verstehen, da in SNMP-Nachrichten der Unterwert jeder OID als Index bezeichnet wird. <br><br><blockquote>  <b>Tipp</b> .  Kombinieren Sie keine langen und kurzen formalen Parameter in einer Anzeige. </blockquote><br><a name="2_3"></a><h2>  2.3.  Benennen Sie Variablen nicht nach Typ </h2><br>  Sie nennen Ihre Haustiere nicht "Hund" und "Katze", oder?  Aus dem gleichen Grund sollten Sie den Typnamen nicht in den Variablennamen aufnehmen.  Es sollte den Inhalt beschreiben, nicht seinen Typ.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*User</code> </pre> <br>  Was n√ºtzt diese Ank√ºndigung?  Wir sehen, dass dies eine Karte ist und etwas mit dem <code>*User</code> zu tun hat: Dies ist wahrscheinlich gut.  Aber <code>usersMap</code> ist <i>wirklich eine</i> Map, und Go als statisch typisierte Sprache verwendet diesen Namen nicht versehentlich, wenn eine skalare Variable erforderlich ist, sodass das <code>Map</code> Suffix redundant ist. <br><br>  Stellen Sie sich eine Situation vor, in der andere Variablen hinzugef√ºgt werden: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( companiesMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Company productsMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Products )</code> </pre> <br>  Jetzt haben wir drei Variablen der <code>usersMap</code> : <code>usersMap</code> , <code>companiesMap</code> und <code>productsMap</code> , und alle Zeilen werden verschiedenen Typen zugeordnet.  Wir wissen, dass dies Karten sind, und wir wissen auch, dass der Compiler einen Fehler ausl√∂st, wenn wir versuchen, <code>companiesMap</code> zu verwenden <code>companiesMap</code> bei dem der Code <code>map[string]*User</code> erwartet.  In dieser Situation ist klar, dass das <code>Map</code> Suffix die Klarheit des Codes nicht verbessert. Dies sind nur zus√§tzliche Zeichen. <br><br>  Ich schlage vor, Suffixe zu vermeiden, die dem Typ einer Variablen √§hneln. <br><br><blockquote>  <b>Tipp</b> .  Wenn der Name " <code>users</code> " die Essenz nicht klar genug beschreibt, wird auch " <code>usersMap</code> . </blockquote><br>  Dieser Tipp gilt auch f√ºr Funktionsparameter.  Zum Beispiel: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } func WriteConfig(w io.Writer, config *Config)</span></span></code> </pre> <br>  Der <code>config</code> f√ºr den Parameter <code>*Config</code> ist redundant.  Wir wissen bereits, dass dies <code>*Config</code> , es wird sofort daneben geschrieben. <br><br>  Betrachten <code>conf</code> in diesem Fall <code>conf</code> oder <code>c</code> wenn die Lebensdauer der Variablen kurz genug ist. <br><br>  Wenn es in unserer Region irgendwann mehr als eine <code>*Config</code> , sind die Namen <code>conf1</code> und <code>conf2</code> weniger aussagekr√§ftig als die <code>original</code> und <code>updated</code> , da letztere schwieriger zu verwechseln sind. <br><br><blockquote>  <b>Hinweis</b>  Lassen Sie Paketnamen keine guten Variablennamen stehlen. <br><br>  Der Name des importierten Bezeichners enth√§lt den Namen des Pakets.  Beispielsweise wird der <code>context.Context</code> im <code>context</code> als <code>context.Context</code> .  Dies macht es unm√∂glich, eine Variable oder einen Kontexttyp in Ihrem Paket zu verwenden. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  Dies wird nicht kompiliert.  Aus diesem Grund werden beim Deklarieren von <code>context.Context</code> lokal verwendet, z. B. Namen wie <code>ctx</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </blockquote><br><a name="2_4"></a><h2>  2.4.  Verwenden Sie einen einzelnen Namensstil </h2><br>  Eine weitere Eigenschaft eines guten Namens ist, dass er vorhersehbar sein sollte.  Der Leser muss es sofort verstehen.  Wenn dies ein <i>gebr√§uchlicher</i> Name ist, hat der Leser das Recht anzunehmen, dass er die Bedeutung gegen√ºber dem vorherigen Zeitpunkt nicht ge√§ndert hat. <br><br>  Wenn der Code beispielsweise den Datenbankdeskriptor umgeht, sollte er bei jeder Anzeige des Parameters denselben Namen haben.  Anstelle aller Arten von Kombinationen wie <code>d *sql.DB</code> , <code>dbase *sql.DB</code> , <code>DB *sql.DB</code> und <code>database *sql.DB</code> es besser, eines zu verwenden: <br><br><pre> <code class="go hljs">db *sql.DB</code> </pre> <br>  Es ist einfacher, den Code zu verstehen.  Wenn Sie <code>db</code> , wissen Sie, dass es sich um <code>*sql.DB</code> und dass es lokal deklariert oder vom Aufrufer bereitgestellt wird. <br><br>  √Ñhnliche Ratschl√§ge bez√ºglich der Empf√§nger einer Methode;  Verwenden Sie f√ºr jede Methode dieses Typs denselben Empf√§ngernamen.  So wird es f√ºr den Leser einfacher sein, die Verwendung des Empf√§ngers unter den verschiedenen Methoden dieses Typs zu lernen. <br><br><blockquote>  <b>Hinweis</b>  Go Recipient Short Name Agreement widerspricht zuvor ge√§u√üerten Empfehlungen.  Dies ist einer der F√§lle, in denen die fr√ºh getroffene Auswahl zum Standardstil wird, z. B. die Verwendung von <code>CamelCase</code> anstelle von <code>snake_case</code> . </blockquote><br><blockquote>  <b>Tipp</b> .  Der Go-Stil verweist auf Einzelbuchstaben oder Abk√ºrzungen f√ºr Empf√§nger, die von ihrem Typ abgeleitet sind.  Es kann sich herausstellen, dass der Empf√§ngername manchmal mit dem Parameternamen in der Methode in Konflikt steht.  In diesem Fall wird empfohlen, den Parameternamen etwas l√§nger zu machen und nicht zu vergessen, ihn nacheinander zu verwenden. </blockquote><br>  Schlie√ülich sind einige Ein-Buchstaben-Variablen traditionell mit Schleifen und Z√§hlen verbunden.  Zum Beispiel sind <code>i</code> , <code>j</code> und <code>k</code> normalerweise induktive Variablen in <code>for</code> Schleifen, <code>n</code> normalerweise einem Z√§hler oder einem akkumulativen Addierer zugeordnet, <code>v</code> ist eine typische Abk√ºrzung f√ºr den Wert in einer Codierungsfunktion, <code>k</code> normalerweise f√ºr einen Kartenschl√ºssel verwendet und <code>s</code> h√§ufig als Abk√ºrzung f√ºr Parameter vom Typ <code>string</code> . <br><br>  Wie im obigen <code>db</code> Beispiel <i>erwarten</i> Programmierer, <i>dass</i> <code>i</code> eine induktive Variable ist.  Wenn sie es im Code sehen, erwarten sie bald eine Schleife. <br><br><blockquote>  <b>Tipp</b> .  Wenn Sie so viele verschachtelte Schleifen haben, dass Ihnen die Variablen <code>i</code> , <code>j</code> und <code>k</code> , m√∂chten Sie die Funktion m√∂glicherweise in kleinere Einheiten aufteilen. </blockquote><br><a name="2_5"></a><h2>  2.5.  Verwenden Sie einen einzelnen Deklarationsstil </h2><br>  Go hat mindestens sechs verschiedene M√∂glichkeiten, eine Variable zu deklarieren. <br><br><ul><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> </li><li><pre> <code class="go hljs">x := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li></ul><br>  Ich bin sicher, ich habe mich noch nicht an alles erinnert.  Go-Entwickler halten dies wahrscheinlich f√ºr einen Fehler, aber es ist zu sp√§t, um etwas zu √§ndern.  Wie kann mit dieser Wahl ein einheitlicher Stil sichergestellt werden? <br><br>  Ich m√∂chte einen Stil f√ºr die Deklaration von Variablen vorschlagen, den ich selbst zu verwenden versuche, wo immer dies m√∂glich ist. <br><br><ul><li>  <b>Verwenden Sie <code>var</code> wenn Sie eine Variable ohne Initialisierung deklarieren</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 var things []Thing // an empty slice of Things var thing Thing // empty Thing struct json.Unmarshall(reader, &amp;thing)</span></span></code> </pre> <br>  <code>var</code> dient als Hinweis darauf, dass diese Variable <i>absichtlich</i> als Nullwert des angegebenen Typs deklariert wird.  Dies steht im Einklang mit der Anforderung, Variablen auf Paketebene mit <code>var</code> zu deklarieren <code>var</code> im Gegensatz zur Syntax f√ºr kurze Deklarationen, obwohl ich sp√§ter argumentieren werde, dass Variablen auf Paketebene √ºberhaupt nicht verwendet werden sollten. </li><li>  <b>Verwenden Sie beim Deklarieren mit der Initialisierung <code>:=</code></b> .  Dies macht dem Leser klar, dass die Variable links von <code>:=</code> absichtlich initialisiert wird. <br><br>  Um zu erkl√§ren, warum, schauen wir uns das vorherige Beispiel an, aber dieses Mal initialisieren wir jede Variable speziell: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing *Thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> </li></ul><br>  Da Go keine automatischen Konvertierungen von einem Typ in einen anderen hat, muss im ersten und dritten Beispiel der Typ auf der linken Seite des Zuweisungsoperators mit dem Typ auf der rechten Seite identisch sein.  Der Compiler kann den Typ der deklarierten Variablen aus dem Typ rechts ableiten, sodass das Beispiel pr√§ziser geschrieben werden kann: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> <br>  Hier werden <code>players</code> explizit auf <code>0</code> initialisiert, was redundant ist, da der Anfangswert von <code>players</code> auf jeden Fall Null ist.  Daher ist es besser klar zu machen, dass wir einen Nullwert verwenden m√∂chten: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  Was ist mit dem zweiten Operator?  Wir k√∂nnen den Typ nicht bestimmen und schreiben <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br>  Weil <code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keinen Typ hat</a> .  Stattdessen haben wir die Wahl: oder wir verwenden einen Nullwert, um ... <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing</code> </pre> <br>  ... oder ein Slice mit null Elementen erstellen? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Im zweiten Fall ist der Wert f√ºr das Slice <i>nicht</i> Null, und wir machen es dem Leser anhand einer kurzen Deklarationsform klar: <br><br><pre> <code class="go hljs">things := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Dies sagt dem Leser, dass wir beschlossen haben, die <code>things</code> explizit zu initialisieren. <br><br>  Also kommen wir zur dritten Erkl√§rung: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Hier sowohl die explizite Initialisierung der Variablen als auch die Einf√ºhrung des "eindeutigen" Schl√ºsselworts <code>new</code> , das einige Go-Programmierer nicht m√∂gen.  Die Verwendung der empfohlenen kurzen Syntax ergibt <br><br><pre> <code class="go hljs">thing := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Dies macht deutlich, dass das <code>thing</code> explizit auf das Ergebnis von <code>new(Thing)</code> initialisiert wird, aber immer noch ein atypisches <code>new</code> hinterl√§sst.  Das Problem k√∂nnte mit einem Literal gel√∂st werden: <br><br><pre> <code class="go hljs">thing := &amp;Thing{}</code> </pre> <br>  Das ist √§hnlich wie bei <code>new(Thing)</code> , und eine solche Vervielf√§ltigung st√∂rt einige Go-Programmierer.  Dies bedeutet jedoch, dass wir das <code>thing</code> explizit mit einem Zeiger auf <code>Thing{}</code> und einem <code>Thing</code> Wert von Null initialisieren. <br><br>  Es ist jedoch besser, die Tatsache zu ber√ºcksichtigen, dass das <code>thing</code> mit einem Nullwert deklariert ist, und die Adresse des Operators zu verwenden, um die Adresse des <code>thing</code> in <code>json.Unmarshall</code> zu √ºbergeben. <code>json.Unmarshall</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing Thing json.Unmarshall(reader, &amp;thing)</code> </pre> <br><blockquote>  <b>Hinweis</b>  Nat√ºrlich gibt es Ausnahmen zu jeder Regel.  Zum Beispiel sind manchmal zwei Variablen eng miteinander verbunden, so dass es seltsam ist, zu schreiben <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max := <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Lesbarere Erkl√§rung: <br><br><pre> <code class="go hljs">min, max := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> </blockquote><br>  Zusammenfassend: <br><br><ul><li>  Verwenden Sie beim Deklarieren einer Variablen ohne Initialisierung die <code>var</code> Syntax. <br></li><li>  Verwenden Sie beim Deklarieren und expliziten Initialisieren einer Variablen <code>:=</code> . </li></ul><br><blockquote>  <b>Tipp</b> .  Weisen Sie explizit auf komplexe Dinge hin. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> = <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Hier kann die <code>length</code> mit der Bibliothek verwendet werden, f√ºr die ein bestimmter numerischer Typ erforderlich ist, und diese Option zeigt deutlicher an, dass die Typl√§nge speziell als uint32 ausgew√§hlt ist als in der kurzen Deklaration: <br><br><pre> <code class="go hljs">length := <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>(<span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br>  Im ersten Beispiel versto√üe ich absichtlich gegen meine Regel, indem ich die var-Deklaration mit expliziter Initialisierung verwende.  Eine Abweichung vom Standard l√§sst den Leser verstehen, dass etwas Ungew√∂hnliches passiert. </blockquote><br><a name="2_6"></a><h2>  2.6.  Arbeite f√ºr das Team </h2><br>  Ich habe bereits gesagt, dass die Essenz der Softwareentwicklung die Erstellung von lesbarem, unterst√ºtztem Code ist.  Der gr√∂√üte Teil Ihrer Karriere wird wahrscheinlich an gemeinsamen Projekten arbeiten.  Mein Rat in dieser Situation: Folgen Sie dem im Team gew√§hlten Stil. <br><br>  Das √Ñndern von Stilen in der Mitte der Datei ist √§rgerlich.  Konsistenz ist wichtig, wenn auch zum Nachteil der pers√∂nlichen Pr√§ferenz.  Meine Faustregel lautet: Wenn der Code durch <code>gofmt</code> passt, ist das Problem normalerweise nicht die Diskussion wert. <br><br><blockquote>  <b>Tipp</b> .  Wenn Sie die gesamte Codebasis umbenennen m√∂chten, mischen Sie dies nicht mit anderen √Ñnderungen.  Wenn jemand Git Bisect verwendet, wird er nicht gerne Tausende von Umbenennungen durchgehen, um einen anderen ge√§nderten Code zu finden. </blockquote><br><h1>  3. Kommentare </h1><br>  Bevor wir zu wichtigeren Punkten √ºbergehen, m√∂chte ich einige Minuten dauern, um einen Kommentar abzugeben. <br><br><blockquote>  <i>‚ÄûEin guter Code hat viele Kommentare, und ein schlechter Code braucht viele Kommentare.‚Äú</i> - Dave Thomas und Andrew Hunt, Pragmatic Programmer </blockquote><br>  Kommentare sind sehr wichtig f√ºr die Lesbarkeit des Programms.  Jeder Kommentar sollte eines - und nur eines - von drei Dingen tun: <br><br><ol><li>  Erkl√§ren Sie, <i>was der</i> Code tut. </li><li>  Erkl√§ren Sie, <i>wie</i> er es macht. </li><li>  Erkl√§ren Sie <i>warum</i> . </li></ol><br>  Die erste Form ist ideal zum Kommentieren √∂ffentlicher Charaktere: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Open     . //           .</span></span></code> </pre> <br>  Die zweite ist ideal f√ºr Kommentare innerhalb einer Methode: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var results []chan error for _, dep := range a.Deps { results = append(results, execute(seen, dep)) }</span></span></code> </pre> <br>  Die dritte Form (‚ÄûWarum‚Äú) ist insofern einzigartig, als sie die ersten beiden nicht ersetzt oder ersetzt.  Solche Kommentare erkl√§ren die externen Faktoren, die zum Schreiben des Codes in seiner aktuellen Form gef√ºhrt haben.  Ohne diesen Kontext ist es oft schwierig zu verstehen, warum der Code so geschrieben ist. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;v2.Cluster_CommonLbConfig{ <span class="hljs-comment"><span class="hljs-comment">//  HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, }, }</span></span></code> </pre> <br>  In diesem Beispiel ist m√∂glicherweise nicht sofort klar, was passiert, wenn HealthyPanicThreshold auf null Prozent festgelegt ist.  Der Kommentar soll klarstellen, dass ein Wert von 0 die Panikschwelle deaktiviert. <br><br><a name="3_1"></a><h2>  3.1.  Kommentare in Variablen und Konstanten sollten ihren Inhalt beschreiben, nicht den Zweck </h2><br>  Ich habe vorhin gesagt, dass der Name einer Variablen oder Konstante ihren Zweck beschreiben sollte.  Ein Kommentar zu einer Variablen oder Konstante sollte jedoch genau den <i>Inhalt</i> und nicht den <i>Zweck beschreiben</i> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br>  In diesem Beispiel beschreibt ein Kommentar, <i>warum</i> <code>randomNumber</code> auf 6 gesetzt ist und woher es stammt.  Der Kommentar beschreibt nicht, wo <code>randomNumber</code> verwendet wird.  Hier sind einige weitere Beispiele: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusContinue = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">// RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1</span></span></code> </pre> <br>  <i>Im Zusammenhang mit HTTP wird die</i> Nummer <code>100</code> als <code>StatusContinue</code> , wie in RFC 7231, Abschnitt 6.2.1 definiert. <br><br><blockquote>  <b>Tipp</b> .  Bei Variablen ohne Anfangswert sollte der Kommentar beschreiben, wer f√ºr die Initialisierung dieser Variablen verantwortlich ist. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sizeCalculationDisabled ,   //     . . dowidth. var sizeCalculationDisabled bool</span></span></code> </pre> <br>  Hier sagt ein Kommentar dem Leser, dass die <code>dowidth</code> Funktion f√ºr die Aufrechterhaltung des Status von <code>sizeCalculationDisabled</code> . </blockquote><br><blockquote>  <b>Tipp</b> .  In Sichtweite verstecken.  Dies ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rat von Kate Gregory</a> .  Manchmal ist der beste Name f√ºr eine Variable in den Kommentaren versteckt. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   SQL var registry = make(map[string]*sql.Driver)</span></span></code> </pre> <br>  Der Autor hat einen Kommentar hinzugef√ºgt, weil die Namensregistrierung ihren Zweck nicht ausreichend erkl√§rt - dies ist eine Registrierung, aber was ist die Registrierung? <br><br>  Wenn Sie eine Variable in sqlDrivers umbenennen, wird deutlich, dass sie SQL-Treiber enth√§lt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlDrivers = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*sql.Driver)</code> </pre> <br>  Jetzt ist der Kommentar √ºberfl√ºssig geworden und kann gel√∂scht werden. </blockquote><br><a name="3_2"></a><h2>  3.2.  Dokumentieren Sie immer √∂ffentlich verf√ºgbare Zeichen </h2><br>  Die Dokumentation f√ºr Ihr Paket wird von godoc generiert. Sie sollten daher jedem im Paket deklarierten √∂ffentlichen Zeichen einen Kommentar hinzuf√ºgen: eine Variable, eine Konstante, eine Funktion und eine Methode. <br><br>  Hier sind zwei Richtlinien aus dem Google Style Guide: <br><br><ul><li>  Jede √∂ffentliche Funktion, die nicht offensichtlich und pr√§gnant ist, sollte kommentiert werden. <br></li><li>  Jede Funktion in der Bibliothek sollte kommentiert werden, unabh√§ngig von L√§nge oder Komplexit√§t. </li></ul><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ioutil <span class="hljs-comment"><span class="hljs-comment">// ReadAll   r      (EOF)   // ..    err == nil, not err == EOF. //  ReadAll     ,     //  . func ReadAll(r io.Reader) ([]byte, error)</span></span></code> </pre> <br>  Es gibt eine Ausnahme von dieser Regel: Sie m√ºssen keine Methoden dokumentieren, die die Schnittstelle implementieren.  Tun Sie dies insbesondere nicht: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Read   io.Reader func (r *FileReader) Read(buf []byte) (int, error)</span></span></code> </pre> <br>  Dieser Kommentar hat nichts zu bedeuten.  Er sagt nicht, was die Methode macht: Schlimmer noch, er schickt irgendwohin, um nach Dokumentation zu suchen.  In dieser Situation schlage ich vor, den Kommentar vollst√§ndig zu l√∂schen. <br><br>  Hier ist ein Beispiel aus dem <code>io</code> Paket. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// LimitReader  Reader,    r, //    EOF  n . //   *LimitedReader. func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} } // LimitedReader   R,     //   N .   Read  N  //    . // Read  EOF,  N &lt;= 0    R  EOF. type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining } func (l *LimitedReader) Read(p []byte) (n int, err error) { if lN &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; lN { p = p[0:lN] } n, err = lRRead(p) lN -= int64(n) return }</span></span></code> </pre> <br>  Beachten Sie, dass der <code>LimitedReader</code> Deklaration unmittelbar die Funktion vorausgeht, die sie verwendet, und dass die <code>LimitedReader.Read</code> Deklaration der Deklaration von <code>LimitedReader</code> selbst folgt.  Obwohl <code>LimitedReader.Read</code> selbst nicht dokumentiert ist, kann verstanden werden, dass dies eine Implementierung von <code>io.Reader</code> . <br><br><blockquote>  <b>Tipp</b> .  Schreiben Sie vor dem Schreiben einer Funktion einen Kommentar, der sie beschreibt.  Wenn Sie Schwierigkeiten haben, einen Kommentar zu schreiben, ist dies ein Zeichen daf√ºr, dass der Code, den Sie schreiben m√∂chten, schwer zu verstehen ist. </blockquote><br><h3>  3.2.1.  Kommentieren Sie keinen schlechten Code, schreiben Sie ihn neu </h3><br><blockquote>  <i>"Kommentieren Sie keinen schlechten Code - schreiben Sie ihn neu"</i> - Brian Kernighan </blockquote><br>  Es reicht nicht aus, in den Kommentaren die Schwierigkeit des Codefragments anzugeben.  Wenn Sie auf einen dieser Kommentare sto√üen, sollten Sie ein Ticket mit einer Erinnerung an das Refactoring starten.  Sie k√∂nnen mit technischen Schulden leben, solange deren H√∂he bekannt ist. <br><br>  Es ist √ºblich, Kommentare in der Standardbibliothek im TODO-Stil mit dem Namen des Benutzers zu hinterlassen, der das Problem bemerkt hat. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TODO(dfc)  O(N^2),     .</span></span></code> </pre> <br>  Dies ist keine Verpflichtung, das Problem zu beheben, aber der angegebene Benutzer ist m√∂glicherweise die beste Person, um eine Frage zu stellen.  Andere Projekte begleiten TODO mit einem Datum oder einer Ticketnummer. <br><br><h3>  3.2.2.  Anstatt den Code zu kommentieren, √ºberarbeiten Sie ihn </h3><br><blockquote>  <i>‚ÄûGuter Code ist die beste Dokumentation.</i>  <i>Wenn Sie einen Kommentar hinzuf√ºgen m√∂chten, stellen Sie sich die Frage: "Wie kann der Code verbessert werden, sodass dieser Kommentar nicht ben√∂tigt wird?"</i>  <i>Refactor und hinterlasse einen Kommentar, um es noch klarer zu machen. ‚Äú</i> - Steve McConnell </blockquote><br>  Funktionen sollten nur eine Aufgabe ausf√ºhren.  Wenn Sie einen Kommentar schreiben m√∂chten, weil ein Fragment nicht mit dem Rest der Funktion zusammenh√§ngt, sollten Sie es in eine separate Funktion extrahieren. <br><br>  Kleinere Funktionen sind nicht nur klarer, sondern auch einfacher voneinander zu testen.  Wenn Sie den Code in eine separate Funktion isoliert haben, kann sein Name einen Kommentar ersetzen. <br><br><a name="4"></a><h1>  4. Paketstruktur </h1><br><blockquote>  <i>‚ÄûSchreiben Sie einen bescheidenen Code: Module, die f√ºr andere Module nichts √úberfl√ºssiges anzeigen und nicht auf die Implementierung anderer Module angewiesen sind‚Äú</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave Thomas</a> </blockquote><br>  Jedes Paket ist im Wesentlichen ein separates kleines Go-Programm.  Ebenso wie die Implementierung einer Funktion oder Methode f√ºr den Aufrufer keine Rolle spielt, spielt die Implementierung der Funktionen, Methoden und Typen, aus denen die √∂ffentliche API Ihres Pakets besteht, keine Rolle. <br><br>  Ein gutes Go-Paket strebt eine minimale Konnektivit√§t mit anderen Paketen auf Quellcodeebene an, damit √Ñnderungen in einem Paket nicht mit der gesamten Codebasis kaskadiert werden, wenn das Projekt w√§chst.  Solche Situationen behindern Programmierer, die an dieser Codebasis arbeiten, erheblich. <br><br>  In diesem Abschnitt werden wir uns mit dem Paketdesign befassen, einschlie√ülich seines Namens und Tipps zum Schreiben von Methoden und Funktionen. <br><br><a name="4_1"></a><h2>  4.1.  Ein gutes Paket beginnt mit einem guten Namen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein gutes Go-Paket beginnt mit einem Qualit√§tsnamen. </font><font style="vertical-align: inherit;">Stellen Sie sich das als eine kurze Pr√§sentation vor, die auf nur ein Wort beschr√§nkt ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie die Variablennamen im vorherigen Abschnitt ist der Paketname sehr wichtig. </font><font style="vertical-align: inherit;">Sie m√ºssen nicht √ºber die Datentypen in diesem Paket nachdenken. Stellen Sie besser die Frage: "Welchen Service bietet dieses Paket?" </font><font style="vertical-align: inherit;">Normalerweise lautet die Antwort nicht "Dieses Paket bietet Typ X", sondern "Mit diesem Paket k√∂nnen Sie eine Verbindung √ºber HTTP herstellen."</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> W√§hlen Sie einen Paketnamen anhand seiner Funktionalit√§t und nicht anhand seines Inhalts. </font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1. </font><font style="vertical-align: inherit;">Gute Paketnamen m√ºssen eindeutig sein</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Paket hat einen eindeutigen Namen im Projekt. </font><font style="vertical-align: inherit;">Es ist kein Problem, wenn Sie den Rat befolgen, Namen f√ºr die Zwecke der Pakete anzugeben. </font><font style="vertical-align: inherit;">Wenn sich herausstellt, dass die beiden Pakete denselben Namen haben, wahrscheinlich:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Paketname ist zu allgemein. </font></font></li><li>       .       ,     . </li></ol><br><a name="4_2"></a><h2>  4.2.    <code>base</code> , <code>common</code>  <code>util</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein h√§ufiger Grund f√ºr schlechte Namen sind die sogenannten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service-Pakete</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei denen sich im Laufe der Zeit verschiedene Helfer und Service-Codes ansammeln. Da ist es schwierig, dort einen eindeutigen Namen zu finden. Dies f√ºhrt h√§ufig dazu, dass der Paketname von dem abgeleitet wird, was er </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dienstprogramme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namen wie </font></font><code>utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden normalerweise in gro√üen Projekten gefunden, in denen eine tiefe Hierarchie von Paketen verwurzelt ist und Hilfsfunktionen gemeinsam genutzt werden. Wenn Sie eine Funktion in ein neues Paket extrahieren, wird der Import abgebrochen. In diesem Fall spiegelt der Name des Pakets nicht den Zweck des Pakets wider, sondern nur die Tatsache, dass die Importfunktion aufgrund einer nicht ordnungsgem√§√üen Organisation des Projekts fehlgeschlagen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In solchen Situationen empfehle ich zu analysieren, woher die Pakete aufgerufen werden.</font></font><code>utils</code> <code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verschieben Sie nach M√∂glichkeit die entsprechenden Funktionen in das aufrufende Paket. </font><font style="vertical-align: inherit;">Selbst wenn dies das Duplizieren eines Hilfscodes impliziert, ist es besser, als eine Importabh√§ngigkeit zwischen zwei Paketen einzuf√ºhren.</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"[Ein wenig] Vervielf√§ltigung ist viel billiger als eine falsche Abstraktion"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sandy Mets</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Dienstprogrammfunktionen an vielen Stellen verwendet werden, ist es besser, anstelle eines monolithischen Pakets mit Dienstprogrammfunktionen mehrere Pakete zu erstellen, die sich jeweils auf einen Aspekt konzentrieren. </font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie den Plural f√ºr Servicepakete. </font><font style="vertical-align: inherit;">Zum Beispiel </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr Dienstprogramme zur Zeichenfolgenverarbeitung.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pakete mit Namen wie </font></font><code>base</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden h√§ufig angetroffen, wenn eine bestimmte gemeinsame Funktionalit√§t von zwei oder mehr Implementierungen oder gemeinsamen Typen f√ºr einen Client und einen Server in einem separaten Paket zusammengef√ºhrt wird. </font><font style="vertical-align: inherit;">Ich glaube, dass es in solchen F√§llen notwendig ist, die Anzahl der Pakete zu reduzieren, indem Client, Server und allgemeiner Code in einem Paket mit einem Namen kombiniert werden, der seiner Funktion entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel, </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht die einzelne Pakete </font></font><code>client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen gibt es Dateien </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit den entsprechenden Datentypen sowie </font></font><code>transport.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr den gesamten Verkehr.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist wichtig zu beachten, dass der Bezeichnername den Paketnamen enth√§lt. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus einem Paket </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird zu einem </font></font><code>http.Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link aus einem anderen Paket.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Typ </font></font><code>Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus einem Paket wird </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Import in andere Pakete umgewandelt </font></font><code>strings.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schnittstelle </font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem Paket ist </font></font><code>net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eindeutig mit Netzwerkfehlern verbunden.</font></font></li></ul></blockquote><br><a name="4_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3. </font><font style="vertical-align: inherit;">Komm schnell zur√ºck, ohne tief zu tauchen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Go keine Ausnahmen im Kontrollfluss verwendet, m√ºssen Sie nicht tief in den Code eintauchen, um eine Struktur auf oberster Ebene f√ºr </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">Bl√∂cke bereitzustellen </font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstelle einer mehrstufigen Hierarchie wird der Go-Code im Verlauf der Funktion auf dem Bildschirm angezeigt. </font><font style="vertical-align: inherit;">Mein Freund Matt Ryer nennt diese Praxis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"line of sight"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wird mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Randoperatoren erreicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Bedingte Bl√∂cke mit einer Vorbedingung am Eingang der Funktion. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel aus dem Paket </font></font><code>bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &lt;= opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Aufrufen der Funktion </font></font><code>UnreadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird der Status √ºberpr√ºft. </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der vorherige Vorgang nicht ausgef√ºhrt wurde </font></font><code>ReadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird sofort ein Fehler zur√ºckgegeben. Der Rest der Funktion basiert auf dem, was </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gr√∂√üer als ist </font></font><code>opInvalid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen Sie mit derselben Funktion, jedoch ohne den Grenzoperator:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &gt; opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der K√∂rper eines wahrscheinlicher erfolgreichen Zweigs ist in die erste Bedingung eingebettet </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und die Bedingung f√ºr einen erfolgreichen Ausgang </font></font><code>return nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss durch sorgf√§ltiges Anpassen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schlie√üenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klammern ermittelt werden. </font><font style="vertical-align: inherit;">Die letzte Zeile der Funktion gibt jetzt einen Fehler zur√ºck, und Sie m√ºssen die Ausf√ºhrung der Funktion in der entsprechenden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∂ffnenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klammer </font><font style="vertical-align: inherit;">verfolgen </font><font style="vertical-align: inherit;">, um herauszufinden, wie Sie zu diesem Punkt gelangen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Option ist schwerer zu lesen, was die Qualit√§t der Programmierung und der Codeunterst√ºtzung beeintr√§chtigt. Daher bevorzugt Go die Verwendung von Grenzoperatoren und gibt Fehler fr√ºhzeitig zur√ºck.</font></font><br><br><a name="4_4"></a><h2>  4.4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Machen Sie den Nullwert n√ºtzlich </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Variablendeklaration wird unter der Annahme, dass kein expliziter Initialisierer vorhanden ist, automatisch mit einem Wert initialisiert, der dem Inhalt des auf Null gesetzten Speichers entspricht, dh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Wertetyp wird durch eine der folgenden Optionen bestimmt: f√ºr numerische Typen - Null, f√ºr Zeigertypen - Null, f√ºr Slices, Maps und Kan√§le gleich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die M√∂glichkeit, immer einen bekannten Standardwert festzulegen, ist wichtig f√ºr die Sicherheit und Korrektheit Ihres Programms und kann Ihre Go-Programme einfacher und kompakter machen. Dies ist, was Go-Programmierer denken, wenn sie sagen: "Geben Sie Strukturen einen n√ºtzlichen Nullwert." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen Typ vor </font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der zwei ganzzahlige Felder enth√§lt, die den internen Status des Mutex darstellen. Diese Felder sind in jeder Deklaration automatisch null.</font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Tatsache wird im Code ber√ºcksichtigt, sodass der Typ f√ºr die Verwendung ohne explizite Initialisierung geeignet ist.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mu sync.Mutex val <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i MyInt <span class="hljs-comment"><span class="hljs-comment">// i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Beispiel f√ºr einen Typ mit einem n√ºtzlichen Nullwert ist </font></font><code>bytes.Buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie k√∂nnen ohne explizite Initialisierung deklarieren und mit dem Schreiben beginnen.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>) io.Copy(os.Stdout, &amp;b) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Nullwert dieser Struktur bedeutet, dass </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beide </font></font><code>cap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich sind </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und y </font></font><code>array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Zeiger auf den Speicher mit dem Inhalt des Sicherungs-Slice-Arrays, Wert </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie nicht explizit schneiden m√ºssen, sondern es einfach deklarieren k√∂nnen.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// s := make([]string, 0) // s := []string{} var s []string s = append(s, "Hello") s = append(s, "world") fmt.Println(strings.Join(s, " ")) }</span></span></code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>var s []string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√§hnlich den beiden kommentierten Zeilen oben, aber nicht identisch mit ihnen. </font><font style="vertical-align: inherit;">Es gibt einen Unterschied zwischen einem Slice-Wert von Null und einem Slice-Wert von Null L√§nge. </font><font style="vertical-align: inherit;">Der folgende Code gibt false aus.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fmt.Println(reflect.DeepEqual(s1, s2)) }</code> </pre> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine n√ºtzliche, wenn auch unerwartete Eigenschaft nicht initialisierter Zeigervariablen - Nullzeiger - ist die F√§higkeit, Methoden f√ºr Typen aufzurufen, die Null sind. </font><font style="vertical-align: inherit;">Dies kann verwendet werden, um einfach Standardwerte bereitzustellen.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/home"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.path } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c1 *Config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c2 = &amp;Config{ path: <span class="hljs-string"><span class="hljs-string">"/export"</span></span>, } fmt.Println(c1.Path(), c2.Path()) }</code> </pre> <br><a name="4_5"></a><h2>  4.5.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie den Status auf Paketebene </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schl√ºssel zum Schreiben von einfach zu unterst√ºtzenden Programmen, die schwach verbunden sind, besteht darin, dass das √Ñndern eines Pakets eine geringe Wahrscheinlichkeit haben sollte, ein anderes Paket zu beeinflussen, das nicht direkt vom ersten abh√§ngig ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei gro√üartige M√∂glichkeiten, um eine schwache Konnektivit√§t in Go zu erreichen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie Schnittstellen, um das f√ºr Funktionen oder Methoden erforderliche Verhalten zu beschreiben. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie den globalen Status. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Go k√∂nnen wir Variablen im Bereich einer Funktion oder Methode sowie im Bereich eines Pakets deklarieren. </font><font style="vertical-align: inherit;">Wenn eine Variable mit einem Bezeichner mit Gro√übuchstaben √∂ffentlich verf√ºgbar ist, ist ihr G√ºltigkeitsbereich f√ºr das gesamte Programm global: Jedes Paket </font><font style="vertical-align: inherit;">sieht </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu jeder Zeit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Typ und den Inhalt dieser Variablen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der ver√§nderbare globale Zustand stellt eine enge Beziehung zwischen den unabh√§ngigen Teilen des Programms her, da globale Variablen zu einem unsichtbaren Parameter f√ºr jede Funktion im Programm werden! </font><font style="vertical-align: inherit;">Jede Funktion, die auf einer globalen Variablen beruht, kann verletzt werden, wenn sich der Typ dieser Variablen √§ndert. </font><font style="vertical-align: inherit;">Jede Funktion, die vom Status einer globalen Variablen abh√§ngt, kann verletzt werden, wenn ein anderer Teil des Programms diese Variable √§ndert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So reduzieren Sie die Konnektivit√§t, die eine globale Variable erzeugt: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben Sie die entsprechenden Variablen als Felder in die Strukturen, die sie ben√∂tigen. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie Schnittstellen, um die Verbindung zwischen dem Verhalten und der Implementierung dieses Verhaltens zu verringern. </font></font></li></ol><br><a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Projektstruktur </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns dar√ºber sprechen, wie Pakete zu einem Projekt kombiniert werden. </font><font style="vertical-align: inherit;">Dies ist normalerweise ein einzelnes Git-Repository. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie das Paket sollte jedes Projekt ein klares Ziel haben. </font><font style="vertical-align: inherit;">Wenn es sich um eine Bibliothek handelt, muss sie eine Aufgabe ausf√ºhren, z. B. XML-Analyse oder Journaling. </font><font style="vertical-align: inherit;">Sie sollten nicht mehrere Ziele in einem Projekt kombinieren, um eine unheimliche Bibliothek zu vermeiden </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach meiner Erfahrung ist das Repository </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letztendlich eng mit dem gr√∂√üten Konsumenten verbunden, und dies macht es schwierig, Korrekturen an fr√ºheren Versionen (Back-Port-Korrekturen) vorzunehmen, ohne sowohl </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Konsumenten als auch den Konsumenten in der Blockierungsphase </font><font style="vertical-align: inherit;">zu aktualisieren </font><font style="vertical-align: inherit;">, was zu vielen nicht verwandten √Ñnderungen f√ºhrt und sie auf dem Weg brechen API</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Anwendung haben (Webanwendung, Kubernetes-Controller usw.), enth√§lt das Projekt m√∂glicherweise ein oder mehrere Hauptpakete. </font><font style="vertical-align: inherit;">In meinem Kubernetes-Controller gibt es beispielsweise ein Paket </font></font><code>cmd/contour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das als Server dient, der in einem Kubernetes-Cluster bereitgestellt wird, und als Debug-Client.</font></font><br><br><a name="5_1"></a><h2>  5.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weniger Pakete, aber gr√∂√üer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Code√ºberpr√ºfung habe ich einen der typischen Fehler von Programmierern festgestellt, die aus anderen Sprachen zu Go gewechselt sind: Sie neigen dazu, Pakete zu missbrauchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie </font><font style="vertical-align: inherit;">nicht das ausgekl√ºgelte System von Sichtbarkeit: die Sprache Modifikatoren wie in der Java nicht genug Zugang ist ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>protected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und implizit </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Es gibt kein Analogon f√ºr freundliche Klassen aus C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Go haben wir nur zwei Zugriffsmodifikatoren: Dies sind √∂ffentliche und private Bezeichner, die durch den ersten Buchstaben des Bezeichners (Gro√ü- / Kleinschreibung) angegeben werden. </font><font style="vertical-align: inherit;">Wenn der Bezeichner √∂ffentlich ist, beginnt sein Name mit einem Gro√übuchstaben und kann von jedem anderen Go-Paket referenziert werden.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie konnten die W√∂rter "exportiert" oder "nicht exportiert" als Synonyme f√ºr √∂ffentlich und privat h√∂ren.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Welche Methoden k√∂nnen angesichts der eingeschr√§nkten Zugriffssteuerungsfunktionen verwendet werden, um zu komplexe Pakethierarchien zu vermeiden? </font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jedem Paket muss zus√§tzlich zu </font></font><code>cmd/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode vorhanden sein.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe wiederholt gesagt, dass es besser ist, weniger gr√∂√üere Pakete zu bevorzugen. </font><font style="vertical-align: inherit;">Ihre Standardposition sollte sein, kein neues Paket zu erstellen. </font><font style="vertical-align: inherit;">Dies f√ºhrt dazu, dass zu viele Typen √∂ffentlich werden, wodurch ein breiter und kleiner Bereich der verf√ºgbaren API erstellt wird. </font><font style="vertical-align: inherit;">Nachfolgend betrachten wir diese These ausf√ºhrlicher.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kam aus Java? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie aus der Java- oder C # -Welt stammen, beachten Sie die unausgesprochene Regel: Ein Java-Paket entspricht einer einzelnen Quelldatei </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Go-Paket entspricht dem gesamten Maven-Modul oder der gesamten .NET-Assembly.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.1. </font><font style="vertical-align: inherit;">Sortieren des Codes nach Datei mithilfe von Importanweisungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Pakete nach Service organisieren, sollten Sie dasselbe f√ºr die Dateien im Paket tun? </font><font style="vertical-align: inherit;">Woher wissen, wann eine Datei </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in mehrere aufgeteilt werden muss? </font><font style="vertical-align: inherit;">Woher wissen Sie, ob Sie zu weit gegangen sind und √ºber das Zusammenf√ºhren von Dateien nachdenken m√ºssen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind die Empfehlungen, die ich verwende:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starten Sie jedes Paket mit einer Datei </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Geben Sie dieser Datei den gleichen Namen wie dem Verzeichnis. </font><font style="vertical-align: inherit;">Das Paket </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte sich beispielsweise in einer Datei </font></font><code>http.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem Verzeichnis befinden </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Paket w√§chst, k√∂nnen Sie die verschiedenen Funktionen in mehrere Dateien aufteilen. </font><font style="vertical-align: inherit;">Zum Beispiel kann die Datei </font></font><code>messages.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt die Typen </font></font><code>Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateityp</font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><code>Client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Datei </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Servertyp.</font></font><br></li><li>       ,    .  ,       . <br></li><li>        . , <code>messages.go</code>     HTTP-       , <code>http.go</code>      , <code>client.go</code>  <code>server.go</code> ‚Äî    HTTP     . </li></ul><br><blockquote>  <b>Tipp</b> .      . </blockquote><br><blockquote> <b></b> .  Go    .      <i></i> ( ‚Äî      Go).           . </blockquote><br><h3> 5.1.2.     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Tool </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterst√ºtzt das Paket </font></font><code>testing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an zwei Stellen. Wenn Sie ein Paket haben </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen Sie eine Datei schreiben </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Paketdeklaration verwenden </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es kompiliert den Code </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es Teil des Pakets ist </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der Umgangssprache wird ein solcher Test als intern bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Werkzeug </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterst√ºtzt auch ein spezielles Paket Erkl√§rung, die an den Enden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh </font></font><code>http_test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen die Testdateien im selben Paket wie der Code gespeichert werden. Wenn solche Tests jedoch kompiliert werden, sind sie nicht Teil des Codes Ihres Pakets, sondern befinden sich in einem eigenen Paket. Auf diese Weise k√∂nnen Sie Tests so schreiben, als w√ºrde ein anderes Paket Ihren Code aufrufen. Solche Tests werden als extern bezeichnet.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich empfehle die Verwendung interner Tests f√ºr Unit-Unit-Tests. Auf diese Weise k√∂nnen Sie jede Funktion oder Methode direkt testen und so die B√ºrokratie externer Tests vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist jedoch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erforderlich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Beispiele f√ºr Testfunktionen ( </font></font><code>Example</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">in einer externen Testdatei abzulegen </font><font style="vertical-align: inherit;">. Dies stellt sicher, dass die Beispiele bei Betrachtung in godoc das entsprechende Paketpr√§fix erhalten und einfach kopiert werden k√∂nnen.</font></font><br><br><blockquote>  <b>Tipp</b> .    ,     . <br><br>   ,    ,   Go      <code>go</code> . ,  <code>net/http</code>       <code>net</code> . <br><br>           <code>.go</code> , ,    . </blockquote><br><h3> 5.1.3.   ,     API </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihr Projekt mehrere Pakete enth√§lt, finden Sie m√∂glicherweise exportierte Funktionen, die von anderen Paketen verwendet werden sollen, jedoch nicht f√ºr die √∂ffentliche API. </font><font style="vertical-align: inherit;">In einer solchen Situation </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erkennt </font><font style="vertical-align: inherit;">das Tool </font><font style="vertical-align: inherit;">einen speziellen Ordnernamen </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Code platziert werden kann, der f√ºr Ihr Projekt ge√∂ffnet, f√ºr andere jedoch geschlossen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein solches Paket zu erstellen, platzieren Sie es in einem Verzeichnis mit einem Namen </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder in seinem Unterverzeichnis. </font><font style="vertical-align: inherit;">Wenn das Team </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Import des Pakets mit dem Pfad sieht </font></font><code>internal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √ºberpr√ºft es den Speicherort des aufrufenden Pakets in einem Verzeichnis oder Unterverzeichnis </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise kann ein Paket </font></font><code>.../a/b/c/internal/d/e/f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur ein Paket aus einem Verzeichnisbaum importieren </font></font><code>.../a/b/c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jedoch √ºberhaupt nicht </font></font><code>.../a/b/g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder ein anderes Repository (siehe</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><a name="5_2"></a><h2>  5.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das kleinste Hauptpaket </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ein Paket </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√ºssen nur √ºber minimale Funktionen verf√ºgen, da sie sich </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie ein Singleton verhalten: Ein Programm kann nur eine Funktion haben </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, einschlie√ülich Tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es sich </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um ein Singleton handelt, gibt es viele Einschr√§nkungen f√ºr aufgerufene Objekte: Sie werden nur w√§hrend </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>main.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einmal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgerufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies erschwert das Schreiben von Codetests </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie sich bem√ºhen, so viel Logik wie m√∂glich aus der Hauptfunktion und im Idealfall aus dem Hauptpaket abzuleiten.</font></font><br><br><blockquote>  <b>Tipp</b> . <code>func main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muss Flags analysieren, Verbindungen zu Datenbanken, Loggern usw. √∂ffnen und dann die Ausf√ºhrung auf ein √ºbergeordnetes Objekt √ºbertragen. </font></font></blockquote><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. API-Struktur </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Design-Rat f√ºr das Projekt halte ich f√ºr den wichtigsten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle vorhergehenden S√§tze sind grunds√§tzlich unverbindlich. </font><font style="vertical-align: inherit;">Dies sind nur Empfehlungen, die auf pers√∂nlichen Erfahrungen beruhen. </font><font style="vertical-align: inherit;">Ich dr√ºcke diese Empfehlungen nicht zu sehr in eine Code√ºberpr√ºfung ein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die API ist eine andere Sache, hier nehmen wir die Fehler ernster, weil alles andere behoben werden kann, ohne die Abw√§rtskompatibilit√§t zu beeintr√§chtigen: Zum gr√∂√üten Teil sind dies nur Implementierungsdetails. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es um √∂ffentliche APIs geht, lohnt es sich, die Struktur von Anfang an ernsthaft zu betrachten, da nachfolgende √Ñnderungen f√ºr die Benutzer destruktiv sind.</font></font><br><br><a name="6_1"></a><h2>  6.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Design-APIs, die vom Design her schwer zu missbrauchen sind </font></font></h2><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"APIs m√ºssen f√ºr die ordnungsgem√§√üe Verwendung einfach und f√ºr die falsche schwierig sein"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Bloch</font></font></a> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Blochs Rat ist vielleicht der wertvollste in diesem Artikel. </font><font style="vertical-align: inherit;">Wenn es schwierig ist, die API f√ºr einfache Dinge zu verwenden, ist jeder API-Aufruf komplizierter als n√∂tig. </font><font style="vertical-align: inherit;">Wenn ein API-Aufruf komplex und nicht offensichtlich ist, wird er wahrscheinlich √ºbersehen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1.1. </font><font style="vertical-align: inherit;">Seien Sie vorsichtig mit Funktionen, die mehrere Parameter desselben Typs akzeptieren.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein gutes Beispiel f√ºr eine auf den ersten Blick einfache, aber schwierig zu verwendende API ist, wenn zwei oder mehr Parameter desselben Typs erforderlich sind. </font><font style="vertical-align: inherit;">Vergleichen Sie zwei Funktionssignaturen:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist der Unterschied zwischen diesen beiden Funktionen? </font><font style="vertical-align: inherit;">Offensichtlich gibt einer maximal zwei Zahlen zur√ºck und der andere kopiert die Datei. </font><font style="vertical-align: inherit;">Aber das ist nicht der Punkt.</font></font><br><br><pre> <code class="go hljs">Max(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 10 Max(10, 8) // 10</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Max ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kommutativ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Reihenfolge der Parameter spielt keine Rolle. </font><font style="vertical-align: inherit;">Maximal acht und zehn sind zehn, unabh√§ngig davon, ob acht und zehn oder zehn und acht verglichen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei CopyFile ist dies jedoch nicht der Fall.</font></font><br><br><pre> <code class="go hljs">CopyFile(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>) CopyFile(<span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welcher dieser Operatoren sichert Ihre Pr√§sentation und welcher √ºberschreibt sie mit der Version der letzten Woche? </font><font style="vertical-align: inherit;">Sie k√∂nnen nicht sagen, bis Sie die Dokumentation √ºberpr√ºfen. </font><font style="vertical-align: inherit;">Im Verlauf der Code√ºberpr√ºfung ist unklar, ob die Reihenfolge der Argumente korrekt ist oder nicht. </font><font style="vertical-align: inherit;">Schauen Sie sich noch einmal die Dokumentation an. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine m√∂gliche L√∂sung besteht darin, einen Hilfstyp einzuf√ºhren, der f√ºr den korrekten Anruf verantwortlich ist </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Source <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src Source)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dest </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CopyFile(dest, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(src)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from Source = <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span> from.CopyTo(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird hier </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer richtig aufgerufen - dies kann mit einem Unit-Test festgestellt werden - und kann privat durchgef√ºhrt werden, was die Wahrscheinlichkeit einer falschen Verwendung weiter verringert.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine API mit mehreren Parametern desselben Typs ist schwer korrekt zu verwenden. </font></font></blockquote><br><a name="6_2"></a><h2>  6.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entwerfen Sie eine API f√ºr einen grundlegenden Anwendungsfall </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor einigen Jahren hielt ich eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§sentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºber die Verwendung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsoptionen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die API standardm√§√üig zu vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wesentliche der Pr√§sentation war, dass Sie eine API f√ºr den Hauptanwendungsfall entwickeln sollten. </font><font style="vertical-align: inherit;">Mit anderen Worten, die API sollte vom Benutzer nicht verlangen, zus√§tzliche Parameter anzugeben, die ihn nicht interessieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.1. </font><font style="vertical-align: inherit;">Die Verwendung von nil als Parameter wird nicht empfohlen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe zun√§chst gesagt, dass Sie den Benutzer nicht zwingen sollten, API-Parameter anzugeben, die ihn nicht interessieren. </font><font style="vertical-align: inherit;">Dies bedeutet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dass die APIs f√ºr den Hauptanwendungsfall entworfen werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Standardoption). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel aus dem net / http-Paket.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-comment"><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error {</span></span></code> </pre> <br> <code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert zwei Parameter: eine TCP-Adresse zum Abh√∂ren eingehender Verbindungen und </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Verarbeiten einer eingehenden HTTP-Anforderung. </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erm√∂glicht den zweiten Parameter zu sein </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In den Kommentaren wird darauf hingewiesen, dass das aufrufende Objekt normalerweise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tats√§chlich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √ºbergeben wird </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was auf den Wunsch hinweist, es </font></font><code>http.DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als impliziten Parameter zu verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt hat der Anrufer </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei M√∂glichkeiten, dasselbe zu tun.</font></font><br><br><pre> <code class="go hljs">http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Optionen machen dasselbe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Anwendung </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbreitet sich wie ein Virus. </font><font style="vertical-align: inherit;">Das Paket </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat auch einen Helfer </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so dass Sie sich die Struktur der Funktion vorstellen k√∂nnen </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenAndServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> l.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Serve(l, handler) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Aufrufer </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den zweiten Parameter √ºbergeben kann, wird </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Verhalten ebenfalls unterst√ºtzt. </font><font style="vertical-align: inherit;">In der Tat ist es in der </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logik implementiert "wenn der Handler gleich ist </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verwenden </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Die Akzeptanz </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eines Parameters kann den Aufrufer zu der </font><font style="vertical-align: inherit;">Annahme </font><font style="vertical-align: inherit;">veranlassen, dass er </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr beide Parameter √ºbergeben werden kann. </font><font style="vertical-align: inherit;">Aber so</font></font><code>Serve</code> <br><br><pre> <code class="go hljs">http.Serve(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºhrt zu einer schrecklichen Panik. </font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischen Sie keine Parameter in derselben Funktionssignatur </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Autor hat </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versucht, das Leben der API-Benutzer f√ºr den Standardfall zu vereinfachen, die Sicherheit war jedoch beeintr√§chtigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Gegenwart </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">keinen Unterschied in der Anzahl der Zeilen zwischen expliziter und indirekter Verwendung </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Vergleich zu </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> War es die Verwirrung wert, eine Zeile zu halten? </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux)</code> </pre> <br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberlegen Sie ernsthaft, wie viel Zeit die Hilfsfunktionen dem Programmierer ersparen. </font><font style="vertical-align: inherit;">Klarheit ist besser als K√ºrze.</font></font></blockquote><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie √∂ffentliche APIs mit Parametern, die nur Tests ben√∂tigen. </font><font style="vertical-align: inherit;">Vermeiden Sie den Export von APIs mit Parametern, deren Werte sich nur w√§hrend des Tests unterscheiden. </font><font style="vertical-align: inherit;">Exportieren Sie stattdessen Wrapper-Funktionen, die die √úbertragung solcher Parameter verbergen, und verwenden Sie in Tests √§hnliche Hilfsfunktionen, die die f√ºr den Test erforderlichen Werte √ºbergeben.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.2. </font><font style="vertical-align: inherit;">Verwenden Sie Argumente mit variabler L√§nge anstelle von [] T.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sehr oft nimmt eine Funktion oder Methode einen Werteschnitt an. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShutdownVMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist nur ein erfundenes Beispiel, aber dies ist sehr h√§ufig. Das Problem ist, dass diese Signaturen davon ausgehen, dass sie mit mehr als einem Datensatz aufgerufen werden. Wie die Erfahrung zeigt, werden sie h√§ufig mit nur einem Argument aufgerufen, das in das Slice ‚Äûgepackt‚Äú werden muss, um die Anforderungen der Funktionssignatur zu erf√ºllen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Parameter </font></font><code>ids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Slice ist, k√∂nnen Sie au√üerdem ein leeres Slice oder eine Null an die Funktion √ºbergeben, und der Compiler wird sich freuen. Dies erh√∂ht die Testlast zus√§tzlich, da die Tests solche F√§lle abdecken sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Beispiel f√ºr eine solche API-Klasse zu geben, habe ich k√ºrzlich die Logik √ºberarbeitet, die die Installation einiger zus√§tzlicher Felder erforderte, wenn mindestens einer der Parameter ungleich Null war. Die Logik sah ungef√§hr so ‚Äã‚Äãaus:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> svc.MaxConnections &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxPendingRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRetries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Operator </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr lang wurde, wollte ich die Validierungslogik in eine separate Funktion ziehen. </font><font style="vertical-align: inherit;">Folgendes habe ich mir ausgedacht:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies erm√∂glichte es, die Bedingung, unter der das Innenger√§t ausgef√ºhrt wird, klar anzugeben: </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch ein Problem mit </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jemand k√∂nnte es versehentlich so nennen:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive() { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird zur√ºckkehren </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist nicht die schlechteste Option. </font><font style="vertical-align: inherit;">Schlimmer noch, wenn die </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckkehr </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Abwesenheit von Argumenten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist jedoch besser, die Signatur von anyPositive √§ndern zu k√∂nnen, um sicherzustellen, dass mindestens ein Argument an den Aufrufer √ºbergeben wird. </font><font style="vertical-align: inherit;">Dies kann durch Kombinieren von Parametern f√ºr normale Argumente und Argumente variabler L√§nge (varargs) erfolgen:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie nicht mit weniger als einem Argument aufrufen.</font></font><br><br><a name="6_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3. </font><font style="vertical-align: inherit;">Lassen Sie die Funktionen das gew√ºnschte Verhalten bestimmen.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, ich habe die Aufgabe erhalten, eine Funktion zu schreiben, die die Struktur </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Festplatte beibeh√§lt.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich k√∂nnte eine Funktion schreiben </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine Datei </font><font style="vertical-align: inherit;">schreibt </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es gibt jedoch einige Probleme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Signatur verhindert </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die M√∂glichkeit, Daten √ºber das Netzwerk aufzuzeichnen. Wenn eine solche Anforderung in Zukunft auftritt, muss die Signatur der Funktion ge√§ndert werden, was sich auf alle aufrufenden Objekte auswirkt. </font></font><br><br> <code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch unangenehm zu testen, da es direkt mit Dateien auf der Festplatte funktioniert. Um den Betrieb zu √ºberpr√ºfen, muss der Test daher den Inhalt der Datei nach dem Schreiben lesen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und ich muss sicherstellen, dass es </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einen tempor√§ren Ordner geschrieben und anschlie√üend gel√∂scht wird. </font></font><br><br> <code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert auch viele Methoden, die sich nicht auf das </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen von Verzeichnissen und das √úberpr√ºfen, ob ein Pfad eine symbolische Verkn√ºpfung ist, </font><font style="vertical-align: inherit;">beziehen </font><font style="vertical-align: inherit;">. Na wenn die Unterschrift</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beschrieb nur die relevanten Teile </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  Was kann getan werden? <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser k√∂nnen Sie das Prinzip der Schnittstellentrennung anwenden - und es </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf einer Schnittstelle </font><font style="vertical-align: inherit;">neu definieren </font><font style="vertical-align: inherit;">, die die allgemeineren Eigenschaften der Datei beschreibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach einer solchen √Ñnderung kann jeder Typ, der die Schnittstelle implementiert </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, durch den vorherigen ersetzt werden </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erweitert gleichzeitig den Bereich </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verdeutlicht dem Aufrufer, welche Typmethoden </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit seiner Operation zusammenh√§ngen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und der Autor </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann diese nicht verwandten Methoden nicht mehr aufrufen </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, weil er sich hinter der Schnittstelle versteckt </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen das Prinzip der Schnittstellentrennung jedoch noch weiter ausbauen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens wenn</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach dem Prinzip der Einzelverantwortung ist es unwahrscheinlich, dass er die Datei, die er gerade geschrieben hat, liest, um ihren Inhalt zu √ºberpr√ºfen - anderer Code sollte dies tun. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher k√∂nnen Sie die Spezifikationen der Schnittstelle eingrenzen, um </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur zu schreiben und zu schlie√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens ist der Thread-Schlie√ümechanismus y </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Erbe der Zeit, als er mit der Datei arbeitete. </font><font style="vertical-align: inherit;">Die Frage ist, unter welchen Umst√§nden </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es geschlossen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ob die </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ursache </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unbedingt, ob im Fall des Erfolgs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies stellt ein Problem f√ºr den Anrufer dar, da er m√∂glicherweise Daten zum Stream hinzuf√ºgen m√∂chte, nachdem das Dokument geschrieben wurde.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die beste Option ist, Save neu zu definieren, um nur mit zu arbeiten </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und den Operator vor allen anderen Funktionen zu sch√ºtzen, au√üer dem Schreiben von Daten in den Stream. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Anwendung des Prinzips der Schnittstellentrennung wurde die Funktion gleichzeitig sowohl spezifischer in Bezug auf die Anforderungen (sie ben√∂tigt nur ein Objekt, in das sie geschrieben werden kann) als auch allgemeiner in Bezug auf die Funktionalit√§t, da wir sie jetzt verwenden k√∂nnen </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um Daten dort zu speichern, wo sie implementiert sind </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Fehlerbehandlung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehrere Pr√§sentationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu diesem Thema im Blog, also werde ich nicht wiederholen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stattdessen m√∂chte ich zwei weitere Bereiche im Zusammenhang mit der Fehlerbehandlung behandeln.</font></font><br><br><a name="7_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1. </font><font style="vertical-align: inherit;">Beseitigen Sie die Notwendigkeit der Fehlerbehandlung, indem Sie die Fehler selbst entfernen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe viele Vorschl√§ge zur Verbesserung der Fehlerbehandlungssyntax gemacht, aber die beste Option ist, sie √ºberhaupt nicht zu behandeln. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich sage nicht "Fehlerbehandlung l√∂schen". </font><font style="vertical-align: inherit;">Ich schlage vor, den Code so zu √§ndern, dass keine Fehler bei der Verarbeitung auftreten.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Osterhouts j√ºngstes Buch zur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Philosophie der Softwareentwicklung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat mich zu diesem Vorschlag inspiriert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eines der Kapitel tr√§gt den Titel ‚ÄûFehler aus der Realit√§t entfernen‚Äú. </font><font style="vertical-align: inherit;">Versuchen wir, diesen Rat anzuwenden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.1. </font><font style="vertical-align: inherit;">Zeilenanzahl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden eine Funktion schreiben, um die Anzahl der Zeilen in einer Datei zu z√§hlen. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir den Ratschl√§gen aus den vorhergehenden Abschnitten folgen, </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nicht </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; Es ist bereits Aufgabe des Anrufers, anzugeben, </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wessen Inhalt wir z√§hlen m√∂chten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erstellen </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Methode und rufen sie dann in einer Schleife auf </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wobei wir den Z√§hler erh√∂hen, bis wir das Ende der Datei erreichen. Dann geben wir die Anzahl der gelesenen Zeilen zur√ºck. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zumindest wollen wir solchen Code schreiben, aber die Funktion ist mit Fehlerbehandlung belastet. Zum Beispiel gibt es so eine seltsame Konstruktion:</font></font><br><br><pre> <code class="go hljs"> _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erh√∂hen die Anzahl der Zeilen, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">nach Fehlern suchen - das sieht seltsam aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund, warum wir es so schreiben sollten, ist, dass es </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Fehler zur√ºckgibt, wenn es das Ende der Datei fr√ºher als das Zeilenumbruchzeichen findet. </font><font style="vertical-align: inherit;">Dies kann passieren, wenn am Ende der Datei keine neue Zeile steht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu beheben, √§ndern Sie die Logik des Zeilenz√§hlers und pr√ºfen Sie, ob die Schleife verlassen werden muss.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diese Logik ist immer noch nicht perfekt. K√∂nnen Sie einen Fehler finden?</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben jedoch noch nicht nach Fehlern gesucht. </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird zur√ºckgegeben, </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Ende der Datei erreicht ist. </font><font style="vertical-align: inherit;">Dies ist die erwartete Situation. </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen also auf irgendeine Weise sagen: "Stopp, es gibt nichts mehr zu lesen." </font><font style="vertical-align: inherit;">Bevor Sie den Fehler an das aufrufende Objekt zur√ºckgeben </font></font><code>CountLine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, m√ºssen Sie daher √ºberpr√ºfen, ob der Fehler nicht mit dem Fehler zusammenh√§ngt </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und ihn dann weiterleiten. Andernfalls kehren wir zur√ºck </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sagen, dass alles in Ordnung ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, dies ist ein gutes Beispiel f√ºr Russ Cox 'These, wie die Fehlerbehandlung die Funktion verbergen kann. </font><font style="vertical-align: inherit;">Schauen wir uns die verbesserte Version an.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese verbesserte Version verwendet </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter der Haube </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, f√ºgt aber eine gute Abstraktionsebene hinzu, die zur Beseitigung der Fehlerbehandlung beitr√§gt.</font></font><br><br><blockquote> <b></b> . <code>bufio.Scanner</code>    ,      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>sc.Scan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt einen Wert zur√ºck, </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn der Scanner auf eine Zeichenfolge gesto√üen ist und keinen Fehler gefunden hat. Daher wird der Schleifenk√∂rper </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur aufgerufen, wenn sich eine Textzeile im Scannerpuffer befindet. Dies bedeutet, dass der neue </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√§lle behandelt, wenn keine neue Zeile vorhanden ist oder wenn die Datei leer ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens </font><font style="vertical-align: inherit;">endet </font><font style="vertical-align: inherit;">der Zyklus </font><font style="vertical-align: inherit;">, da er </font></font><code>sc.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur√ºckkehrt, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn ein Fehler erkannt wird, </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn er das Ende der Datei erreicht oder ein Fehler erkannt wird. Der Typ </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merkt sich den ersten aufgetretenen Fehler. Mit der Methode k√∂nnen </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir diesen Fehler wiederherstellen, sobald wir die Schleife verlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√ºmmert </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">sich um die Verarbeitung </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und konvertiert sie, </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Ende der Datei fehlerfrei erreicht ist.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie auf eine √ºberm√§√üige Fehlerbehandlung sto√üen, versuchen Sie, einige Vorg√§nge in einen Hilfstyp zu extrahieren. </font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2. </font><font style="vertical-align: inherit;">Antwort des Autors</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein zweites Beispiel wird per Post inspiriert </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûErrors - diesen Wert‚Äú</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor haben wir Beispiele daf√ºr gesehen, wie eine Datei ge√∂ffnet, geschrieben und geschlossen wird. </font><font style="vertical-align: inherit;">Es gibt eine Fehlerbehandlung, die jedoch nicht zu umfangreich ist, da Vorg√§nge in Hilfsprogrammen wie </font></font><code>ioutil.ReadFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">gekapselt werden k√∂nnen </font></font><code>ioutil.WriteFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei der Arbeit mit Netzwerkprotokollen auf niedriger Ebene muss jedoch eine Antwort direkt mithilfe von E / A-Grundelementen erstellt werden. </font><font style="vertical-align: inherit;">In diesem Fall kann die Fehlerbehandlung aufdringlich werden. </font><font style="vertical-align: inherit;">Stellen Sie sich ein Fragment eines HTTP-Servers vor, das eine HTTP-Antwort erstellt.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zun√§chst die Statusleiste mit </font></font><code>fmt.Fprintf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und √ºberpr√ºfen Sie den Fehler. Dann schreiben wir f√ºr jede √úberschrift einen Schl√ºssel und einen √úberschriftenwert, wobei jedes Mal ein Fehler √ºberpr√ºft wird. Schlie√ülich vervollst√§ndigen wir den Header-Abschnitt mit einem zus√§tzlichen </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √ºberpr√ºfen den Fehler und kopieren den Antworttext auf den Client. Obwohl wir den Fehler nicht √ºberpr√ºfen m√ºssen </font></font><code>io.Copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, m√ºssen wir ihn von zwei R√ºckgabewerten in den einzigen zur√ºckgeben, der zur√ºckgibt </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist viel eint√∂nige Arbeit. Sie k√∂nnen Ihre Aufgabe jedoch vereinfachen, indem Sie einen kleinen Wrapper anwenden </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erf√ºllt den Vertrag </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so dass es als Wrapper verwendet werden kann. </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leitet Datens√§tze durch die Funktion, bis ein Fehler erkannt wird. In diesem Fall werden die Eintr√§ge zur√ºckgewiesen und der vorherige Fehler zur√ºckgegeben.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich </font><font style="vertical-align: inherit;">bewerben , </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Code Klarheit deutlich verbessert. </font><font style="vertical-align: inherit;">Sie m√ºssen nicht mehr bei jedem einzelnen Vorgang nach Fehlern suchen. </font><font style="vertical-align: inherit;">Die Fehlermeldung wird als </font></font><code>ew.err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feldpr√ºfung </font><font style="vertical-align: inherit;">an das Ende der Funktion </font><font style="vertical-align: inherit;">verschoben, um die st√∂rende √úbersetzung der zur√ºckgegebenen io.Copy-Werte zu vermeiden.</font></font><br><br><a name="7_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2. </font><font style="vertical-align: inherit;">Behandeln Sie den Fehler nur einmal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschlie√üend m√∂chte ich darauf hinweisen, dass Fehler nur einmal behandelt werden sollten. </font><font style="vertical-align: inherit;">Verarbeitung bedeutet, die Bedeutung des Fehlers zu √ºberpr√ºfen und eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzige</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entscheidung zu treffen.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer. func WriteAll(w io.Writer, buf []byte) { w.Write(buf) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie weniger als eine Entscheidung treffen, ignorieren Sie den Fehler. </font><font style="vertical-align: inherit;">Wie wir hier sehen, wird der Fehler von </font></font><code>w.WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ignoriert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es </font><font style="vertical-align: inherit;">ist aber auch falsch </font><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehr als eine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entscheidung als Reaktion auf einen Fehler </font><i><font style="vertical-align: inherit;">zu</font></i><font style="vertical-align: inherit;"> treffen. </font><font style="vertical-align: inherit;">Unten ist der Code, auf den ich oft sto√üe.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"unable to write:"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// annotated error goes to log file return err // unannotated error returned to caller } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn in diesem Beispiel w√§hrend der Zeit ein Fehler auftritt </font></font><code>w.Write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird die Zeile in das Protokoll geschrieben und auch an das aufrufende Objekt zur√ºckgegeben, das es m√∂glicherweise auch protokolliert und an die oberste Ebene des Programms weiterleitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂chstwahrscheinlich macht der Anrufer dasselbe:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Somit wird ein Stapel sich wiederholender Zeilen im Protokoll erstellt. </font></font><br><br><pre> <code class="go hljs">unable to write: io.EOF could not write config: io.EOF</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aber oben im Programm erhalten Sie einen urspr√ºnglichen Fehler ohne Kontext. </font></font><br><br><pre> <code class="go hljs">err := WriteConfig(f, &amp;conf) fmt.Println(err) <span class="hljs-comment"><span class="hljs-comment">// io.EOF</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich m√∂chte dieses Thema genauer analysieren, da ich das Problem der gleichzeitigen R√ºckgabe eines Fehlers und der Protokollierung meiner pers√∂nlichen Einstellungen nicht in Betracht ziehe. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println("could not write config: %v", err) return err } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich sto√üe oft auf ein Problem, das ein Programmierer vergisst, um von einem Fehler zur√ºckzukehren. Wie bereits erw√§hnt, besteht der Stil von Go darin, Grenzoperatoren zu verwenden, die Voraussetzungen bei der Ausf√ºhrung der Funktion zu √ºberpr√ºfen und fr√ºhzeitig zur√ºckzukehren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Beispiel hat der Autor den Fehler √ºberpr√ºft, registriert, aber </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vergessen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , zur√ºckzukehren. Aus diesem Grund entsteht ein subtiles Problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Go-Fehlerbehandlungsvertrag besagt, dass bei Vorliegen eines Fehlers keine Annahmen √ºber den Inhalt anderer R√ºckgabewerte getroffen werden k√∂nnen. Da das JSON-Marshalling fehlgeschlagen ist, ist der Inhalt </font></font><code>buf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unbekannt: Es enth√§lt m√∂glicherweise nichts, aber schlimmer noch, es enth√§lt m√∂glicherweise ein halb geschriebenes JSON-Fragment.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Programmierer nach √úberpr√ºfung und Registrierung des Fehlers vergessen hat, zur√ºckzukehren, wird der besch√§digte Puffer √ºbertragen </font></font><code>WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Vorgang ist wahrscheinlich erfolgreich und daher wird die Konfigurationsdatei nicht korrekt geschrieben. </font><font style="vertical-align: inherit;">Die Funktion wird jedoch normal ausgef√ºhrt, und das einzige Anzeichen daf√ºr, dass ein Problem aufgetreten ist, ist eine Zeile im Protokoll, in der das JSON-Marshalling fehlgeschlagen ist, und kein Fehler im Konfigurationsdatensatz.</font></font><br><br><h3>  7.2.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hinzuf√ºgen von Kontext zu Fehlern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Fehler ist aufgetreten, weil der Autor versucht hat, der Fehlermeldung einen Kontext hinzuzuf√ºgen. </font><font style="vertical-align: inherit;">Er versuchte, eine Markierung zu hinterlassen, um die Fehlerquelle anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns einen anderen Weg an, um dasselbe zu tun </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"write failed: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie den Fehlerdatensatz mit der R√ºckgabe in einer Zeile kombinieren, ist es schwieriger, die R√ºckgabe zu vergessen und eine versehentliche Fortsetzung zu vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beim Schreiben der Datei ein E / A-Fehler auftritt, erzeugt die Methode </font></font><code>Error()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes:</font></font><br><br><pre> <code class="go hljs">could not write config: write failed: input/output error</code> </pre> <br><h3>  7.2.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler beim Umschlie√üen mit github.com/pkg/errors </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vorlage </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert gut f√ºr die </font><font style="vertical-align: inherit;">Aufzeichnung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachrichten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehlern, aber die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Art des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehlers geht auf der Strecke. </font><font style="vertical-align: inherit;">Ich habe argumentiert, dass die Behandlung von Fehlern als undurchsichtige Werte f√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lose gekoppelte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekte </font><font style="vertical-align: inherit;">wichtig ist. </font><font style="vertical-align: inherit;">Daher sollte die Art des Quellfehlers keine Rolle spielen, wenn wir nur mit seinem Wert arbeiten m√ºssen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie sicher, dass es nicht Null ist. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie es auf dem Bildschirm an oder protokollieren Sie es. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kommt jedoch vor, dass Sie den urspr√ºnglichen Fehler wiederherstellen m√ºssen. </font><font style="vertical-align: inherit;">Um solche Fehler zu kommentieren, k√∂nnen Sie so etwas wie mein Paket verwenden </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { f, err := os.Open(path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"open failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> f.Close() buf, err := ioutil.ReadAll(f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { home := os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) config, err := ReadFile(filepath.Join(home, <span class="hljs-string"><span class="hljs-string">".settings.xml"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config, errors.WithMessage(err, <span class="hljs-string"><span class="hljs-string">"could not read config"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt wird die Nachricht zu einem netten Fehler im K &amp; D-Stil: </font></font><br><br><pre> <code class="go hljs">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und sein Wert enth√§lt einen Link zum urspr√ºnglichen Grund. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"original error: %T %v\n"</span></span>, errors.Cause(err), errors.Cause(err)) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"stack trace:\n%+v\n"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf diese Weise k√∂nnen Sie den urspr√ºnglichen Fehler wiederherstellen und die Stapelverfolgung anzeigen: </font></font><br><br><pre> <code class="plaintext hljs">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory stack trace: open /Users/dfc/.settings.xml: no such file or directory open failed main.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16 main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29 main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35 runtime.main /Users/dfc/go/src/runtime/proc.go:201 runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333 could not read config</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Paket </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen Sie Fehlerwerten in einem praktischen Format sowohl f√ºr eine Person als auch f√ºr eine Maschine einen Kontext hinzuf√ºgen. </font><font style="vertical-align: inherit;">Bei einer k√ºrzlich gehaltenen Pr√§sentation habe ich Ihnen gesagt, dass in der kommenden Version von Go ein solcher Wrapper in der Standardbibliothek erscheinen wird.</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Parallelit√§t </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go wird h√§ufig aufgrund seiner Parallelit√§tsfunktionen ausgew√§hlt. Die Entwickler haben viel getan, um die Effizienz (in Bezug auf Hardwareressourcen) und Produktivit√§t zu steigern, aber die Parallelit√§tsfunktionen von Go k√∂nnen verwendet werden, um Code zu schreiben, der weder produktiv noch zuverl√§ssig ist. Am Ende des Artikels m√∂chte ich einige Tipps geben, wie Sie einige der Fallstricke von Go-Parallelit√§tsfunktionen vermeiden k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erstklassige Parallelit√§tsunterst√ºtzung von Go wird von den Kan√§len sowie von Anweisungen </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">bereitgestellt</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie Go-Theorie aus Lehrb√ºchern oder an einer Universit√§t studiert haben, haben Sie vielleicht bemerkt, dass der Parallelit√§tsabschnitt immer einer der letzten im Kurs ist. </font><font style="vertical-align: inherit;">Unser Artikel ist nicht anders: Ich habe beschlossen, am Ende √ºber Parallelit√§t zu sprechen, als etwas zus√§tzlich zu den √ºblichen F√§higkeiten, die der Go-Programmierer lernen sollte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier gibt es eine gewisse Zweiteilung, da das Hauptmerkmal von Go unser einfaches, leichtes Modell der Parallelit√§t ist. </font><font style="vertical-align: inherit;">Als Produkt verkauft sich unsere Sprache auf Kosten fast dieser einen Funktion. </font><font style="vertical-align: inherit;">Andererseits ist Parallelit√§t eigentlich nicht so einfach zu verwenden, sonst h√§tten die Autoren es nicht zum letzten Kapitel in ihren B√ºchern gemacht, und wir h√§tten unseren Code nicht mit Bedauern betrachtet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Abschnitt werden einige der Fallstricke der naiven Verwendung von Go-Parallelit√§tsfunktionen erl√§utert.</font></font><br><br><a name="8_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1. </font><font style="vertical-align: inherit;">Mach die ganze Zeit etwas Arbeit.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist das Problem mit diesem Programm? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Programm macht das, was wir beabsichtigt haben: Es dient einem einfachen Webserver. </font><font style="vertical-align: inherit;">Gleichzeitig verbringt es CPU-Zeit in einer Endlosschleife, da </font></font><code>for{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der letzten Zeile </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutin Main blockiert wird, ohne dass eine E / A ausgef√ºhrt wird, und nicht auf das Blockieren, Senden oder Empfangen von Nachrichten oder eine Verbindung mit dem Sheduler gewartet werden muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Go-Laufzeit normalerweise von einem Sheduler bedient wird, wird dieses Programm sinnlos auf dem Prozessor ausgef√ºhrt und kann in einer aktiven Sperre (Live-Sperre) enden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann ich das beheben? </font><font style="vertical-align: inherit;">Hier ist eine Option.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { runtime.Gosched() } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es mag albern aussehen, aber dies ist eine √ºbliche L√∂sung, die mir im wirklichen Leben einf√§llt. </font><font style="vertical-align: inherit;">Dies ist ein Symptom f√ºr ein Missverst√§ndnis des zugrunde liegenden Problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie etwas erfahrener mit Go sind, k√∂nnen Sie so etwas schreiben.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine leere Anweisung ist </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr immer gesperrt. </font><font style="vertical-align: inherit;">Dies ist n√ºtzlich, da wir jetzt nicht den gesamten Prozessor nur f√ºr einen Anruf drehen </font></font><code>runtime.GoSched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir behandeln jedoch nur das Symptom, nicht die Ursache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich m√∂chte Ihnen eine andere L√∂sung zeigen, die Ihnen hoffentlich bereits in den Sinn gekommen ist. </font><font style="vertical-align: inherit;">Anstatt </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Goroutine zu </font><font style="vertical-align: inherit;">laufen </font><font style="vertical-align: inherit;">und das Hauptproblem der Goroutine zu verlassen, laufen Sie einfach </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Hauptgoroutine.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Funktion verlassen </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird das Go-Programm bedingungslos beendet, unabh√§ngig davon, was andere Goroutinen w√§hrend der Ausf√ºhrung des Programms ausf√ºhren.</font></font></blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist also mein erster Rat: Wenn Goroutine keine Fortschritte machen kann, bis er ein Ergebnis von einem anderen erh√§lt, ist es oft einfacher, die Arbeit selbst zu erledigen, als sie zu delegieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch entf√§llt h√§ufig viel Statusverfolgung und Kanalmanipulation, die erforderlich sind, um das Ergebnis von Goroutine zur√ºck an den Prozessinitiator zu √ºbertragen.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Go-Programmierer missbrauchen Goroutinen, besonders am Anfang. </font><font style="vertical-align: inherit;">Wie alles andere im Leben ist M√§√üigung der Schl√ºssel zum Erfolg.</font></font></blockquote><br><a name="8_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2. </font><font style="vertical-align: inherit;">√úberlassen Sie die Parallelit√§t dem Anrufer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist der Unterschied zwischen den beiden APIs? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns the contents of dir. func ListDirectory(dir string) ([]string, error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns a channel over which // directory entries will be published. When the list // of entries is exhausted, the channel will be closed. func ListDirectory(dir string) chan string</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erw√§hnen die offensichtlichen Unterschiede: Das erste Beispiel liest das Verzeichnis in ein Slice und gibt dann das gesamte Slice oder den Fehler zur√ºck, wenn etwas schief gelaufen ist. Dies geschieht synchron, der Aufrufer blockiert, </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis alle Verzeichniseintr√§ge gelesen wurden. Je nachdem, wie gro√ü das Verzeichnis ist, kann es viel Zeit und m√∂glicherweise viel Speicher in Anspruch nehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie das zweite Beispiel. Es ist ein bisschen mehr wie bei der klassischen Go-Programmierung, hier wird </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Kanal zur√ºckgegeben, √ºber den Verzeichniseintr√§ge √ºbertragen werden. Wenn der Kanal geschlossen ist, ist dies ein Zeichen daf√ºr, dass keine Katalogeintr√§ge mehr vorhanden sind. Da das F√ºllen des Kanals nach der R√ºckkehr erfolgt </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kann davon ausgegangen werden, dass Goroutinen beginnen, den Kanal zu f√ºllen.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bei der zweiten Option ist es nicht erforderlich, Goroutine tats√§chlich zu verwenden: Sie k√∂nnen einen Kanal ausw√§hlen, der ausreicht, um alle Verzeichniseintr√§ge ohne Blockierung zu speichern, ihn ausf√ºllen, schlie√üen und dann den Kanal an den Anrufer zur√ºckgeben. </font><font style="vertical-align: inherit;">Dies ist jedoch unwahrscheinlich, da in diesem Fall dieselben Probleme auftreten, wenn eine gro√üe Speichermenge verwendet wird, um alle Ergebnisse im Kanal zu puffern.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanalversion hat zwei weitere Probleme:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung eines geschlossenen Kanals als Signal daf√ºr, dass keine Elemente mehr verarbeitet werden m√ºssen, </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann den Aufrufer aufgrund eines Fehlers nicht √ºber einen unvollst√§ndigen Satz von Elementen informieren. </font><font style="vertical-align: inherit;">Der Anrufer hat keine M√∂glichkeit, den Unterschied zwischen einem leeren Verzeichnis und einem Fehler zu vermitteln. </font><font style="vertical-align: inherit;">In beiden F√§llen scheint der Kanal sofort geschlossen zu werden.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Anrufer muss beim Schlie√üen des Kanals weiterlesen, da nur so zu verstehen ist, dass die Kanalf√ºll-Goroutine nicht mehr funktioniert. </font><font style="vertical-align: inherit;">Dies ist eine schwerwiegende Einschr√§nkung der Verwendung </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Der Anrufer verbringt viel Zeit damit, vom Kanal zu lesen, selbst wenn er alle erforderlichen Daten erhalten hat. </font><font style="vertical-align: inherit;">Dies ist wahrscheinlich effizienter in Bezug auf die Speichernutzung f√ºr mittlere und gro√üe Verzeichnisse, aber die Methode ist nicht schneller als die urspr√ºngliche Slice-basierte Methode.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In beiden F√§llen besteht die L√∂sung darin, einen R√ºckruf zu verwenden: eine Funktion, die bei der Ausf√ºhrung im Kontext jedes Verzeichniseintrags aufgerufen wird. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es √ºberrascht nicht, dass die Funktion so </font></font><code>filepath.WalkDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihre Funktion Goroutine startet, m√ºssen Sie dem Aufrufer eine M√∂glichkeit bieten, diese Routine explizit zu stoppen. </font><font style="vertical-align: inherit;">Es ist oft am einfachsten, den asynchronen Ausf√ºhrungsmodus f√ºr den Anrufer zu belassen.</font></font></blockquote><br><a name="8_3"></a><h2>  8.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºhren Sie niemals Goroutine aus, ohne zu wissen, wann es aufh√∂ren wird </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Beispiel wurde Goroutine unn√∂tig verwendet. </font><font style="vertical-align: inherit;">Eine der Hauptst√§rken von Go sind jedoch die erstklassigen Parallelit√§tsfunktionen. </font><font style="vertical-align: inherit;">In der Tat ist in vielen F√§llen Parallelarbeit durchaus angebracht, und dann m√ºssen Goroutinen verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese einfache Anwendung bedient den HTTP-Verkehr an zwei verschiedenen Ports: Port 8080 f√ºr den Anwendungsverkehr und Port 8001 f√ºr den Zugriff auf den Endpunkt </font></font><code>/debug/pprof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) <span class="hljs-comment"><span class="hljs-comment">// debug http.ListenAndServe("0.0.0.0:8080", mux) // app traffic }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl das Programm unkompliziert ist, ist es die Grundlage einer echten Anwendung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anwendung in ihrer aktuellen Form weist mehrere Probleme auf, die beim Wachstum auftreten. Schauen wir uns daher einige davon sofort an.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() serveApp() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brechen - </font><font style="vertical-align: inherit;">Handler </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf verschiedene Funktionen, die </font><font style="vertical-align: inherit;">wir haben sie von getrennt </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir folgten auch die vorherige Beratung und sorgte daf√ºr , </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lassen Sie </font><font style="vertical-align: inherit;">die Aufgabe , </font><font style="vertical-align: inherit;">die Parallelit√§t des Anrufers zu gew√§hrleisten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch einige Probleme mit der Leistung eines solchen Programms. </font><font style="vertical-align: inherit;">Wenn wir kommen </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dann aus </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das Programm schaltet sich </font><font style="vertical-align: inherit;">ab und startet den Prozess - </font><font style="vertical-align: inherit;">Manager.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So wie Funktionen in Go dem Aufrufer Parallelit√§t √ºberlassen, sollten Anwendungen die √úberwachung ihres Status beenden und das Programm, das sie aufgerufen hat, neu starten. </font><font style="vertical-align: inherit;">Machen Sie Ihre Anwendungen nicht f√ºr den Neustart selbst verantwortlich. Dieses Verfahren wird am besten von au√üerhalb der Anwendung ausgef√ºhrt.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnt jedoch in einer separaten Goroutine, und im Falle seiner Ver√∂ffentlichung endet die Goroutine, w√§hrend der Rest des Programms fortgesetzt wird. </font><font style="vertical-align: inherit;">Ihren Entwicklern wird es nicht gefallen, dass Sie keine Anwendungsstatistiken erhalten k√∂nnen, da der Handler </font></font><code>/debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schon lange nicht mehr funktioniert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen sicherstellen, dass die Anwendung geschlossen ist, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Goroutine, die sie serviert, </font><font style="vertical-align: inherit;">aufh√∂rt </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveApp() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>serverApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontrollfehler aus </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ggf. Ursache </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da beide Handler in Goroutinen arbeiten, erstellen wir die Hauptroutine in </font></font><code>select{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Ansatz weist eine Reihe von Problemen auf:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Fehler zur√ºckgegeben wird </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, erfolgt kein Aufruf </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und der HTTP-Dienst an diesem Port wird beendet, ohne die Anwendung zu stoppen.</font></font><br></li><li> <code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruft </font></font><code>os.Exit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Programm bedingungslos auf; </font><font style="vertical-align: inherit;">Zur√ºckgestellte Anrufe funktionieren nicht, andere Goroutinen werden nicht √ºber den Abschluss informiert, das Programm wird einfach gestoppt. </font><font style="vertical-align: inherit;">Dies macht es schwierig, Tests f√ºr diese Funktionen zu schreiben.</font></font></li></ol><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr Funktionen </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder verwenden </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich m√∂chten wir dem Sch√∂pfer der Goroutine jeden Fehler mitteilen, der auftritt, damit er herausfinden kann, warum sie den Prozess gestoppt und sauber abgeschlossen hat.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveDebug() }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveApp() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(done); i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := &lt;-done; err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error: %v"</span></span>, err) } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Goroutine-R√ºckgabestatus kann √ºber den Kanal abgerufen werden. Die Kanalgr√∂√üe entspricht der Anzahl der Goroutinen, die wir steuern m√∂chten, sodass das Senden an den Kanal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht blockiert wird, da dies das Herunterfahren von Goroutinen blockiert und ein Leck verursacht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Kanal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht sicher geschlossen werden kann, k√∂nnen wir die Redewendung nicht f√ºr </font></font><code>for range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Kanalzyklus verwenden, bis alle Goroutinen gemeldet haben. Stattdessen f√ºhren wir alle laufenden Goroutinen in einem Zyklus aus, der der Kapazit√§t des Kanals entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die M√∂glichkeit, jede Goroutine sauber zu beenden und alle aufgetretenen Fehler zu beheben. Es bleibt nur ein Signal zu senden, um die Arbeit von der ersten Goroutine an alle anderen abzuschlie√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Appell an</font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber die Fertigstellung, also habe ich diese Logik in eine Hilfsfunktion eingewickelt. </font><font style="vertical-align: inherit;">Der Helfer </font></font><code>serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert die Adresse und </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ebenso </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Kanal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √ºber den wir die Methode ausf√ºhren </font></font><code>Shutdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler http.Handler, stop &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s := http.Server{ Addr: addr, Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-stop <span class="hljs-comment"><span class="hljs-comment">// wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe() } func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, "Hello, QCon!") }) return serve("0.0.0.0:8080", mux, stop) } func serveDebug(stop &lt;-chan struct{}) error { return serve("127.0.0.1:8001", http.DefaultServeMux, stop) } func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println("error: %v", err) } if !stopped { stopped = true close(stop) } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schlie√üen wir </font><font style="vertical-align: inherit;">f√ºr jeden Wert im Kanal </font><font style="vertical-align: inherit;">den Kanal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch jeder Gorutin auf diesem Kanal seinen eigenen schlie√üt </font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies f√ºhrt wiederum zu einer R√ºckgabe aller verbleibenden Goroutinen </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn alle laufenden Gorutine gestoppt sind, </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">endet es und der Prozess stoppt sauber.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Logik selbst zu schreiben, ist sich wiederholende Arbeit und das Risiko von Fehlern. </font><font style="vertical-align: inherit;">Schauen Sie sich so etwas wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Paket an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das den gr√∂√üten Teil der Arbeit f√ºr Sie erledigt.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441842/">https://habr.com/ru/post/de441842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441826/index.html">Was passiert auf dem Audio-Streaming-Markt? Diskussion √ºber die Entwicklung von Streaming-Plattformen</a></li>
<li><a href="../de441830/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 4</a></li>
<li><a href="../de441832/index.html">Wer ist der Projektmanager nach Meinung des Gesch√§ftsinhabers und wie geht man damit um?</a></li>
<li><a href="../de441834/index.html">Nicht zur Arbeit nehmen. Aber was ist, wenn die Sache in dir liegt?</a></li>
<li><a href="../de441836/index.html">Eine Cloud-Geschichte: Huawei + 3data = Cloud</a></li>
<li><a href="../de441844/index.html">iRobot Scooba: Erfahrung und L√∂sungen f√ºr h√§ufig auftretende Probleme eines Waschroboterreinigers</a></li>
<li><a href="../de441848/index.html">Praktika f√ºr Entwickler in Avito: K√§mpfe gegen Missionen und arbeite mit erfahrenen Mentoren</a></li>
<li><a href="../de441850/index.html">Wahrsagerei in neuronalen Netzen: ob der Autor selbst in den Kommentaren zum Beitrag vermerkt hat</a></li>
<li><a href="../de441852/index.html">42 Silicon Valley: So werden Sie ausgew√§hlt</a></li>
<li><a href="../de441854/index.html">RUHE? Nimm einen dummen JSON-RPC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>