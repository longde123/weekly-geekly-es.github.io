<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱 📄 🤘 Practical Go: Tipps zum Schreiben unterstützter Programme in der realen Welt 🧒🏼 🍈 🤲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel konzentriert sich auf bewährte Methoden zum Schreiben von Go-Code. Es ist im Präsentationsstil komponiert, jedoch ohne die üblichen Fol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Practical Go: Tipps zum Schreiben unterstützter Programme in der realen Welt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441842/">  Dieser Artikel konzentriert sich auf bewährte Methoden zum Schreiben von Go-Code.  Es ist im Präsentationsstil komponiert, jedoch ohne die üblichen Folien.  Wir werden versuchen, jeden Punkt kurz und klar durchzugehen. <br><br>  Zunächst müssen Sie sich darauf einigen, was die <i>Best</i> Practices für eine Programmiersprache bedeuten.  Hier können Sie sich an die Worte von Russ Cox, technischer Direktor von Go, erinnern: <br><br><blockquote>  Software-Engineering passiert mit der Programmierung, wenn Sie den Zeitfaktor und andere Programmierer hinzufügen. </blockquote><br>  So unterscheidet Russ zwischen den Konzepten der <i>Programmierung</i> und der <i>Softwareentwicklung</i> .  Im ersten Fall schreiben Sie ein Programm für sich selbst, im zweiten erstellen Sie ein Produkt, an dem andere Programmierer im Laufe der Zeit arbeiten werden.  Ingenieure kommen und gehen.  Teams wachsen oder schrumpfen.  Neue Funktionen wurden hinzugefügt und Fehler behoben.  Dies ist die Natur der Softwareentwicklung. <br><a name="habracut"></a><br><a name="0"></a><h1>  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Grundprinzipien</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einfachheit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesbarkeit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Produktivität</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Kennungen</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Namenskennungen basieren eher auf Klarheit als auf Kürze</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ID Länge</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benennen Sie Variablen nicht nach Typ</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden Sie einen einzelnen Namensstil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden Sie einen einzelnen Deklarationsstil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeite für das Team</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Kommentare</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentare in Variablen und Konstanten sollten ihren Inhalt beschreiben, nicht den Zweck</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentieren Sie immer öffentlich verfügbare Zeichen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Paketstruktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein gutes Paket beginnt mit einem guten Namen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vermeiden Sie Namen wie base, common oder util</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komm schnell zurück, ohne tief zu tauchen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Machen Sie den Nullwert nützlich</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vermeiden Sie den Status auf Paketebene</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Projektstruktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weniger Pakete, aber größer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das kleinste Hauptpaket</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. API-Struktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Design-APIs, die vom Design her schwer zu missbrauchen sind</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwerfen Sie eine API für einen grundlegenden Anwendungsfall</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lassen Sie die Funktionen das gewünschte Verhalten bestimmen.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Fehlerbehandlung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beseitigen Sie die Notwendigkeit der Fehlerbehandlung, indem Sie die Fehler selbst entfernen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Behandeln Sie den Fehler nur einmal</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Parallelität</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mach die ganze Zeit etwas Arbeit.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überlassen Sie die Parallelität dem Anrufer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Führen Sie niemals Goroutine aus, ohne zu wissen, wann es aufhören wird</a> </li></ul></li></ul><br><a name="1"></a><h1>  1. Grundprinzipien </h1><br>  Ich bin vielleicht einer der ersten Benutzer von Go unter Ihnen, aber dies ist nicht meine persönliche Meinung.  Diese Grundprinzipien liegen Go selbst zugrunde: <br><br><ol><li>  Einfachheit </li><li>  Lesbarkeit </li><li>  Produktivität </li></ol><br>  <i>Hinweis</i>  <i>Bitte beachten Sie, dass ich weder "Leistung" noch "Parallelität" erwähnt habe.</i>  <i>Es gibt Sprachen, die schneller als Go sind, aber sie können sicherlich nicht einfach verglichen werden.</i>  <i>Es gibt Sprachen, bei denen Parallelität oberste Priorität hat, die jedoch hinsichtlich Lesbarkeit oder Programmierproduktivität nicht verglichen werden können.</i> <i><br><br></i>  <i>Leistung und Parallelität sind wichtige Attribute, aber nicht so wichtig wie Einfachheit, Lesbarkeit und Produktivität.</i> <br><br><a name="1_1"></a><h2>  Einfachheit </h2><br><blockquote>  <i>„Einfachheit ist Voraussetzung für Zuverlässigkeit“</i> - Edsger Dijkstra </blockquote><br>  Warum nach Einfachheit streben?  Warum ist es wichtig, dass Go-Programme einfach sind? <br><br>  Jeder von uns ist auf einen unverständlichen Code gestoßen, oder?  Wenn Sie Angst haben, Änderungen vorzunehmen, weil dadurch ein anderer Teil des Programms beschädigt wird, den Sie nicht ganz verstehen und den Sie nicht beheben können.  Das ist die Schwierigkeit. <br><br><blockquote>  <i>„Es gibt zwei Möglichkeiten, Software zu entwerfen: Die erste besteht darin, sie so einfach zu gestalten, dass keine offensichtlichen Mängel vorliegen, und die zweite darin, sie so komplex zu gestalten, dass keine offensichtlichen Mängel vorliegen.</i>  <i>Das erste ist viel schwieriger. ”</i> - C. E. R. Hoar </blockquote><br>  Komplexität macht zuverlässige Software unzuverlässig.  Komplexität ist das, was Softwareprojekte tötet.  Einfachheit ist daher das ultimative Ziel von Go.  Welche Programme wir auch schreiben, sie sollten einfach sein. <br><br><a name="1_2"></a><h2>  1.2.  Lesbarkeit </h2><br><blockquote>  <i>„Lesbarkeit ist ein wesentlicher Bestandteil der Wartbarkeit“</i> - Mark Reinhold, JVM-Konferenz, 2018 </blockquote><br>  Warum ist es wichtig, dass der Code lesbar ist?  Warum sollten wir uns um Lesbarkeit bemühen? <br><br><blockquote>  <i>"Programme sollten für Menschen geschrieben werden, und Maschinen führen sie einfach aus"</i> - Hal Abelson und Gerald Sassman, "Struktur und Interpretation von Computerprogrammen" </blockquote><br>  Nicht nur Go-Programme, sondern im Allgemeinen wird die gesamte Software von Menschen für Menschen geschrieben.  Die Tatsache, dass Maschinen auch Code verarbeiten, ist zweitrangig. <br><br>  Einmal geschriebener Code wird wiederholt von Menschen gelesen: hunderte, wenn nicht tausende Male. <br><br><blockquote>  <i>„Die wichtigste Fähigkeit eines Programmierers ist die Fähigkeit, Ideen effektiv zu kommunizieren.“</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gaston Horker</a> </blockquote><br>  Lesbarkeit ist der Schlüssel zum Verständnis der Funktionsweise eines Programms.  Wenn Sie den Code nicht verstehen können, wie können Sie ihn pflegen?  Wenn die Software nicht unterstützt werden kann, wird sie neu geschrieben.  Dies ist möglicherweise das letzte Mal, dass Ihr Unternehmen Go verwendet. <br><br>  Wenn Sie ein Programm für sich selbst schreiben, tun Sie, was für Sie funktioniert.  Wenn dies jedoch Teil eines gemeinsamen Projekts ist oder das Programm lange genug verwendet wird, um die Anforderungen, Funktionen oder die Umgebung, in der es funktioniert, zu ändern, besteht Ihr Ziel darin, das Programm wartbar zu machen. <br><br>  Der erste Schritt zum Schreiben unterstützter Software besteht darin, sicherzustellen, dass der Code klar ist. <br><br><a name="1_3"></a><h2>  1.3.  Produktivität </h2><br><blockquote>  <i>„Design ist die Kunst, Code so zu organisieren, dass er heute funktioniert, aber immer Veränderungen unterstützt.“</i> - Sandy Mets </blockquote><br>  Als letztes Grundprinzip möchte ich die Produktivität des Entwicklers nennen.  Dies ist ein großes Thema, aber es kommt auf das Verhältnis an: wie viel Zeit Sie für nützliche Arbeit aufwenden und wie viel - auf eine Antwort von Tools oder hoffnungslose Irrfahrten in einer unverständlichen Codebasis warten.  Go-Programmierer sollten das Gefühl haben, dass sie viel Arbeit erledigen können. <br><br>  Es ist ein Witz, dass die Go-Sprache während des Kompilierens des C ++ - Programms entwickelt wurde.  Die schnelle Kompilierung ist ein wichtiges Merkmal von Go und ein Schlüsselfaktor für die Gewinnung neuer Entwickler.  Obwohl die Compiler verbessert werden, dauert die Minutenkompilierung in anderen Sprachen im Allgemeinen einige Sekunden.  So fühlen sich Go-Entwickler genauso produktiv wie Programmierer in dynamischen Sprachen, jedoch ohne Probleme mit der Zuverlässigkeit dieser Sprachen. <br><br>  Wenn wir grundlegend über die Produktivität von Entwicklern sprechen, verstehen Go-Programmierer, dass das Lesen von Code wesentlich wichtiger ist als das Schreiben.  In dieser Logik geht Go sogar so weit, die Werkzeuge zu verwenden, um den gesamten Code in einem bestimmten Stil zu formatieren.  Dies beseitigt die geringste Schwierigkeit, den spezifischen Dialekt eines bestimmten Projekts zu lernen, und hilft, Fehler zu identifizieren, da sie im Vergleich zu normalem Code einfach falsch <i>aussehen</i> . <br><br>  Go-Programmierer verbringen keine Tage damit, seltsame Kompilierungsfehler, komplexe Build-Skripte oder das Bereitstellen von Code in einer Produktionsumgebung zu debuggen.  Und vor allem verschwenden sie keine Zeit damit, zu verstehen, was ein Kollege geschrieben hat. <br><br>  Wenn Go-Entwickler über <i>Skalierbarkeit</i> sprechen, bedeutet dies Produktivität. <br><br><a name="2"></a><h1>  2. Kennungen </h1><br>  Das erste Thema, das wir diskutieren werden - <i>Bezeichner</i> - ist ein Synonym für <i>Namen</i> : Namen von Variablen, Funktionen, Methoden, Typen, Paketen usw. <br><br><blockquote>  <i>"Schlechter Name ist ein Symptom für schlechtes Design"</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave Cheney</a> </blockquote><br>  Aufgrund der eingeschränkten Syntax von Go haben Objektnamen einen großen Einfluss auf die Programmlesbarkeit.  Die Lesbarkeit ist ein Schlüsselfaktor für guten Code, daher ist die Auswahl guter Namen von entscheidender Bedeutung. <br><br><a name="2_1"></a><h2>  2.1.  Namenskennungen basieren eher auf Klarheit als auf Kürze </h2><br><blockquote>  <i>„Es ist wichtig, dass der Code offensichtlich ist.</i>  <i>Was Sie in einer Zeile tun können, müssen Sie in drei tun. “</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ukia Smith</a> </blockquote><br>  Go ist nicht für knifflige Einzeiler oder die Mindestanzahl von Zeilen in einem Programm optimiert.  Wir optimieren weder die Größe des Quellcodes auf der Festplatte noch die Zeit, die zum Eingeben des Programms in den Editor erforderlich ist. <br><br><blockquote>  <i>„Ein guter Name ist wie ein guter Witz.</i>  <i>Wenn Sie es erklären müssen, ist es nicht mehr lustig. "</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave Cheney</a> </blockquote><br>  Der Schlüssel zu maximaler Klarheit sind die Namen, die wir zur Identifizierung von Programmen auswählen.  Welche Eigenschaften hat ein guter Name? <br><br><ul><li>  <b>Ein guter Name ist prägnant</b> .  Es muss nicht das kürzeste sein, enthält aber keinen Überschuss.  Es hat ein hohes Signal-Rausch-Verhältnis. </li><li>  <b>Ein guter Name ist beschreibend</b> .  Es beschreibt die Verwendung einer Variablen oder Konstante, <i>nicht des</i> Inhalts.  Ein guter Name beschreibt das Ergebnis einer Funktion oder das Verhalten einer Methode, <i>nicht einer</i> Implementierung.  Der Zweck des Pakets, <i>nicht</i> sein Inhalt.  Je genauer der Name das Identifizierende beschreibt, desto besser. </li><li>  <b>Ein guter Name ist vorhersehbar</b> .  Unter einem Namen müssen Sie verstehen, wie das Objekt verwendet wird.  Die Namen sollten beschreibend sein, aber es ist auch wichtig, der Tradition zu folgen.  Das ist es, was Go-Programmierer meinen, wenn sie <i>"idiomatisch"</i> sagen. </li></ul><br>  Lassen Sie uns jede dieser Eigenschaften genauer betrachten. <br><br><a name="2_2"></a><h2>  2.2.  ID Länge </h2><br>  Manchmal wird Go's Stil für kurze Variablennamen kritisiert.  Wie Rob Pike <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte</a> : "Go-Programmierer wollen Bezeichner mit der <i>richtigen</i> Länge." <br><br>  Andrew Gerrand bietet längere Kennungen an, um die Wichtigkeit anzuzeigen. <br><br><blockquote>  <i>„Je größer der Abstand zwischen der Angabe eines Namens und der Verwendung eines Objekts ist,</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">desto</a> <i>länger sollte der Name sein“</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Gerrand</a> </blockquote><br>  Daher können einige Empfehlungen gegeben werden: <br><br><ul><li>  Kurze Variablennamen sind gut, wenn der Abstand zwischen der Deklaration und der <i>letzten</i> Verwendung gering ist. <br></li><li>  Lange Variablennamen sollten sich rechtfertigen;  Je länger sie sind, desto wichtiger sollten sie sein.  Ausführliche Titel enthalten wenig Signal in Bezug auf ihr Gewicht auf der Seite. <br></li><li>  Fügen Sie den Typnamen nicht in den Variablennamen ein. <br></li><li>  Konstante Namen sollten den internen Wert beschreiben, nicht wie der Wert verwendet wird. <br></li><li>  Bevorzugen Sie Einzelbuchstabenvariablen für Schleifen und Verzweigungen, separate Wörter für Parameter und Rückgabewerte, mehrere Wörter für Funktionen und Deklarationen auf Paketebene. <br></li><li>  Bevorzugen Sie einzelne Wörter für Methoden, Schnittstellen und Pakete. <br></li><li>  Denken Sie daran, dass der Paketname Teil des Namens ist, den der Aufrufer als Referenz verwendet. </li></ul><br>  Betrachten Sie ein Beispiel. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// AverageAge returns the average age of people. func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count }</span></span></code> </pre> <br>  In der zehnten Zeile wird eine Variable des Bereichs <code>p</code> deklariert und ab der nächsten Zeile nur einmal aufgerufen.  Das heißt, die Variable lebt für eine sehr kurze Zeit auf der Seite.  Wenn der Leser an der Rolle von <code>p</code> im Programm interessiert ist, muss er nur zwei Zeilen lesen. <br><br>  Zum Vergleich werden <code>people</code> in Funktionsparametern deklariert und sieben Zeilen leben.  Das Gleiche gilt für <code>sum</code> und <code>count</code> , daher rechtfertigen sie ihre längeren Namen.  Der Leser muss mehr Code scannen, um sie zu finden. Dies rechtfertigt die differenzierteren Namen. <br><br>  Sie können <code>s</code> für <code>sum</code> und <code>c</code> (oder <code>n</code> ) für <code>count</code> wählen, dies reduziert jedoch die Bedeutung aller Variablen im Programm auf die gleiche Ebene.  Sie können <code>people</code> durch <code>p</code> ersetzen, aber es wird ein Problem geben, wie die Iterationsvariable <code>for ... range</code> aufgerufen <code>for ... range</code> .  Eine einzelne <code>person</code> sieht seltsam aus, da eine kurzlebige Iterationsvariable einen längeren Namen erhält als mehrere Werte, von denen sie abgeleitet ist. <br><br><blockquote>  <b>Tipp</b> .  Trennen Sie den Funktionsstrom durch leere Zeilen, da leere Zeilen zwischen Absätzen den Textfluss unterbrechen.  In <code>AverageAge</code> haben wir drei aufeinanderfolgende Operationen.  Überprüfen Sie zuerst die Division durch Null, dann die Schlussfolgerung des Gesamtalters und der Anzahl der Personen und zuletzt die Berechnung des Durchschnittsalters. </blockquote><br><h3>  2.2.1.  Die Hauptsache ist der Kontext </h3><br>  Es ist wichtig zu verstehen, dass die meisten Benennungstipps kontextspezifisch sind.  Ich möchte sagen, dass dies ein Prinzip ist, keine Regel. <br><br>  Was ist der Unterschied zwischen <code>i</code> und <code>index</code> ?  Zum Beispiel können Sie nicht eindeutig sagen, dass ein solcher Code <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index := <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); index++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  grundsätzlich besser lesbar als <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); i++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  Ich glaube, dass die zweite Option nicht schlechter ist, da in diesem Fall der Bereich <code>i</code> oder der <code>index</code> durch den Körper der <code>for</code> Schleife begrenzt ist und die zusätzliche Ausführlichkeit wenig zum Verständnis des Programms beiträgt. <br><br>  Aber welche dieser Funktionen ist besser lesbar? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oid []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, index </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  oder <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  In diesem Beispiel ist <code>oid</code> eine Abkürzung für SNMP Object ID, und die zusätzliche Abkürzung für <code>o</code> zwingt Sie, beim Lesen von Code von einer dokumentierten zu einer kürzeren Notation im Code zu wechseln.  In ähnlicher Weise ist das Verstehen des <code>index</code> auf <code>i</code> schwieriger zu verstehen, da in SNMP-Nachrichten der Unterwert jeder OID als Index bezeichnet wird. <br><br><blockquote>  <b>Tipp</b> .  Kombinieren Sie keine langen und kurzen formalen Parameter in einer Anzeige. </blockquote><br><a name="2_3"></a><h2>  2.3.  Benennen Sie Variablen nicht nach Typ </h2><br>  Sie nennen Ihre Haustiere nicht "Hund" und "Katze", oder?  Aus dem gleichen Grund sollten Sie den Typnamen nicht in den Variablennamen aufnehmen.  Es sollte den Inhalt beschreiben, nicht seinen Typ.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*User</code> </pre> <br>  Was nützt diese Ankündigung?  Wir sehen, dass dies eine Karte ist und etwas mit dem <code>*User</code> zu tun hat: Dies ist wahrscheinlich gut.  Aber <code>usersMap</code> ist <i>wirklich eine</i> Map, und Go als statisch typisierte Sprache verwendet diesen Namen nicht versehentlich, wenn eine skalare Variable erforderlich ist, sodass das <code>Map</code> Suffix redundant ist. <br><br>  Stellen Sie sich eine Situation vor, in der andere Variablen hinzugefügt werden: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( companiesMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Company productsMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Products )</code> </pre> <br>  Jetzt haben wir drei Variablen der <code>usersMap</code> : <code>usersMap</code> , <code>companiesMap</code> und <code>productsMap</code> , und alle Zeilen werden verschiedenen Typen zugeordnet.  Wir wissen, dass dies Karten sind, und wir wissen auch, dass der Compiler einen Fehler auslöst, wenn wir versuchen, <code>companiesMap</code> zu verwenden <code>companiesMap</code> bei dem der Code <code>map[string]*User</code> erwartet.  In dieser Situation ist klar, dass das <code>Map</code> Suffix die Klarheit des Codes nicht verbessert. Dies sind nur zusätzliche Zeichen. <br><br>  Ich schlage vor, Suffixe zu vermeiden, die dem Typ einer Variablen ähneln. <br><br><blockquote>  <b>Tipp</b> .  Wenn der Name " <code>users</code> " die Essenz nicht klar genug beschreibt, wird auch " <code>usersMap</code> . </blockquote><br>  Dieser Tipp gilt auch für Funktionsparameter.  Zum Beispiel: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } func WriteConfig(w io.Writer, config *Config)</span></span></code> </pre> <br>  Der <code>config</code> für den Parameter <code>*Config</code> ist redundant.  Wir wissen bereits, dass dies <code>*Config</code> , es wird sofort daneben geschrieben. <br><br>  Betrachten <code>conf</code> in diesem Fall <code>conf</code> oder <code>c</code> wenn die Lebensdauer der Variablen kurz genug ist. <br><br>  Wenn es in unserer Region irgendwann mehr als eine <code>*Config</code> , sind die Namen <code>conf1</code> und <code>conf2</code> weniger aussagekräftig als die <code>original</code> und <code>updated</code> , da letztere schwieriger zu verwechseln sind. <br><br><blockquote>  <b>Hinweis</b>  Lassen Sie Paketnamen keine guten Variablennamen stehlen. <br><br>  Der Name des importierten Bezeichners enthält den Namen des Pakets.  Beispielsweise wird der <code>context.Context</code> im <code>context</code> als <code>context.Context</code> .  Dies macht es unmöglich, eine Variable oder einen Kontexttyp in Ihrem Paket zu verwenden. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  Dies wird nicht kompiliert.  Aus diesem Grund werden beim Deklarieren von <code>context.Context</code> lokal verwendet, z. B. Namen wie <code>ctx</code> . <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </blockquote><br><a name="2_4"></a><h2>  2.4.  Verwenden Sie einen einzelnen Namensstil </h2><br>  Eine weitere Eigenschaft eines guten Namens ist, dass er vorhersehbar sein sollte.  Der Leser muss es sofort verstehen.  Wenn dies ein <i>gebräuchlicher</i> Name ist, hat der Leser das Recht anzunehmen, dass er die Bedeutung gegenüber dem vorherigen Zeitpunkt nicht geändert hat. <br><br>  Wenn der Code beispielsweise den Datenbankdeskriptor umgeht, sollte er bei jeder Anzeige des Parameters denselben Namen haben.  Anstelle aller Arten von Kombinationen wie <code>d *sql.DB</code> , <code>dbase *sql.DB</code> , <code>DB *sql.DB</code> und <code>database *sql.DB</code> es besser, eines zu verwenden: <br><br><pre> <code class="go hljs">db *sql.DB</code> </pre> <br>  Es ist einfacher, den Code zu verstehen.  Wenn Sie <code>db</code> , wissen Sie, dass es sich um <code>*sql.DB</code> und dass es lokal deklariert oder vom Aufrufer bereitgestellt wird. <br><br>  Ähnliche Ratschläge bezüglich der Empfänger einer Methode;  Verwenden Sie für jede Methode dieses Typs denselben Empfängernamen.  So wird es für den Leser einfacher sein, die Verwendung des Empfängers unter den verschiedenen Methoden dieses Typs zu lernen. <br><br><blockquote>  <b>Hinweis</b>  Go Recipient Short Name Agreement widerspricht zuvor geäußerten Empfehlungen.  Dies ist einer der Fälle, in denen die früh getroffene Auswahl zum Standardstil wird, z. B. die Verwendung von <code>CamelCase</code> anstelle von <code>snake_case</code> . </blockquote><br><blockquote>  <b>Tipp</b> .  Der Go-Stil verweist auf Einzelbuchstaben oder Abkürzungen für Empfänger, die von ihrem Typ abgeleitet sind.  Es kann sich herausstellen, dass der Empfängername manchmal mit dem Parameternamen in der Methode in Konflikt steht.  In diesem Fall wird empfohlen, den Parameternamen etwas länger zu machen und nicht zu vergessen, ihn nacheinander zu verwenden. </blockquote><br>  Schließlich sind einige Ein-Buchstaben-Variablen traditionell mit Schleifen und Zählen verbunden.  Zum Beispiel sind <code>i</code> , <code>j</code> und <code>k</code> normalerweise induktive Variablen in <code>for</code> Schleifen, <code>n</code> normalerweise einem Zähler oder einem akkumulativen Addierer zugeordnet, <code>v</code> ist eine typische Abkürzung für den Wert in einer Codierungsfunktion, <code>k</code> normalerweise für einen Kartenschlüssel verwendet und <code>s</code> häufig als Abkürzung für Parameter vom Typ <code>string</code> . <br><br>  Wie im obigen <code>db</code> Beispiel <i>erwarten</i> Programmierer, <i>dass</i> <code>i</code> eine induktive Variable ist.  Wenn sie es im Code sehen, erwarten sie bald eine Schleife. <br><br><blockquote>  <b>Tipp</b> .  Wenn Sie so viele verschachtelte Schleifen haben, dass Ihnen die Variablen <code>i</code> , <code>j</code> und <code>k</code> , möchten Sie die Funktion möglicherweise in kleinere Einheiten aufteilen. </blockquote><br><a name="2_5"></a><h2>  2.5.  Verwenden Sie einen einzelnen Deklarationsstil </h2><br>  Go hat mindestens sechs verschiedene Möglichkeiten, eine Variable zu deklarieren. <br><br><ul><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> </li><li><pre> <code class="go hljs">x := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li></ul><br>  Ich bin sicher, ich habe mich noch nicht an alles erinnert.  Go-Entwickler halten dies wahrscheinlich für einen Fehler, aber es ist zu spät, um etwas zu ändern.  Wie kann mit dieser Wahl ein einheitlicher Stil sichergestellt werden? <br><br>  Ich möchte einen Stil für die Deklaration von Variablen vorschlagen, den ich selbst zu verwenden versuche, wo immer dies möglich ist. <br><br><ul><li>  <b>Verwenden Sie <code>var</code> wenn Sie eine Variable ohne Initialisierung deklarieren</b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 var things []Thing // an empty slice of Things var thing Thing // empty Thing struct json.Unmarshall(reader, &amp;thing)</span></span></code> </pre> <br>  <code>var</code> dient als Hinweis darauf, dass diese Variable <i>absichtlich</i> als Nullwert des angegebenen Typs deklariert wird.  Dies steht im Einklang mit der Anforderung, Variablen auf Paketebene mit <code>var</code> zu deklarieren <code>var</code> im Gegensatz zur Syntax für kurze Deklarationen, obwohl ich später argumentieren werde, dass Variablen auf Paketebene überhaupt nicht verwendet werden sollten. </li><li>  <b>Verwenden Sie beim Deklarieren mit der Initialisierung <code>:=</code></b> .  Dies macht dem Leser klar, dass die Variable links von <code>:=</code> absichtlich initialisiert wird. <br><br>  Um zu erklären, warum, schauen wir uns das vorherige Beispiel an, aber dieses Mal initialisieren wir jede Variable speziell: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing *Thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> </li></ul><br>  Da Go keine automatischen Konvertierungen von einem Typ in einen anderen hat, muss im ersten und dritten Beispiel der Typ auf der linken Seite des Zuweisungsoperators mit dem Typ auf der rechten Seite identisch sein.  Der Compiler kann den Typ der deklarierten Variablen aus dem Typ rechts ableiten, sodass das Beispiel präziser geschrieben werden kann: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> <br>  Hier werden <code>players</code> explizit auf <code>0</code> initialisiert, was redundant ist, da der Anfangswert von <code>players</code> auf jeden Fall Null ist.  Daher ist es besser klar zu machen, dass wir einen Nullwert verwenden möchten: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  Was ist mit dem zweiten Operator?  Wir können den Typ nicht bestimmen und schreiben <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br>  Weil <code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keinen Typ hat</a> .  Stattdessen haben wir die Wahl: oder wir verwenden einen Nullwert, um ... <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing</code> </pre> <br>  ... oder ein Slice mit null Elementen erstellen? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Im zweiten Fall ist der Wert für das Slice <i>nicht</i> Null, und wir machen es dem Leser anhand einer kurzen Deklarationsform klar: <br><br><pre> <code class="go hljs">things := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Dies sagt dem Leser, dass wir beschlossen haben, die <code>things</code> explizit zu initialisieren. <br><br>  Also kommen wir zur dritten Erklärung: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Hier sowohl die explizite Initialisierung der Variablen als auch die Einführung des "eindeutigen" Schlüsselworts <code>new</code> , das einige Go-Programmierer nicht mögen.  Die Verwendung der empfohlenen kurzen Syntax ergibt <br><br><pre> <code class="go hljs">thing := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Dies macht deutlich, dass das <code>thing</code> explizit auf das Ergebnis von <code>new(Thing)</code> initialisiert wird, aber immer noch ein atypisches <code>new</code> hinterlässt.  Das Problem könnte mit einem Literal gelöst werden: <br><br><pre> <code class="go hljs">thing := &amp;Thing{}</code> </pre> <br>  Das ist ähnlich wie bei <code>new(Thing)</code> , und eine solche Vervielfältigung stört einige Go-Programmierer.  Dies bedeutet jedoch, dass wir das <code>thing</code> explizit mit einem Zeiger auf <code>Thing{}</code> und einem <code>Thing</code> Wert von Null initialisieren. <br><br>  Es ist jedoch besser, die Tatsache zu berücksichtigen, dass das <code>thing</code> mit einem Nullwert deklariert ist, und die Adresse des Operators zu verwenden, um die Adresse des <code>thing</code> in <code>json.Unmarshall</code> zu übergeben. <code>json.Unmarshall</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing Thing json.Unmarshall(reader, &amp;thing)</code> </pre> <br><blockquote>  <b>Hinweis</b>  Natürlich gibt es Ausnahmen zu jeder Regel.  Zum Beispiel sind manchmal zwei Variablen eng miteinander verbunden, so dass es seltsam ist, zu schreiben <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max := <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Lesbarere Erklärung: <br><br><pre> <code class="go hljs">min, max := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> </blockquote><br>  Zusammenfassend: <br><br><ul><li>  Verwenden Sie beim Deklarieren einer Variablen ohne Initialisierung die <code>var</code> Syntax. <br></li><li>  Verwenden Sie beim Deklarieren und expliziten Initialisieren einer Variablen <code>:=</code> . </li></ul><br><blockquote>  <b>Tipp</b> .  Weisen Sie explizit auf komplexe Dinge hin. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> = <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Hier kann die <code>length</code> mit der Bibliothek verwendet werden, für die ein bestimmter numerischer Typ erforderlich ist, und diese Option zeigt deutlicher an, dass die Typlänge speziell als uint32 ausgewählt ist als in der kurzen Deklaration: <br><br><pre> <code class="go hljs">length := <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>(<span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br>  Im ersten Beispiel verstoße ich absichtlich gegen meine Regel, indem ich die var-Deklaration mit expliziter Initialisierung verwende.  Eine Abweichung vom Standard lässt den Leser verstehen, dass etwas Ungewöhnliches passiert. </blockquote><br><a name="2_6"></a><h2>  2.6.  Arbeite für das Team </h2><br>  Ich habe bereits gesagt, dass die Essenz der Softwareentwicklung die Erstellung von lesbarem, unterstütztem Code ist.  Der größte Teil Ihrer Karriere wird wahrscheinlich an gemeinsamen Projekten arbeiten.  Mein Rat in dieser Situation: Folgen Sie dem im Team gewählten Stil. <br><br>  Das Ändern von Stilen in der Mitte der Datei ist ärgerlich.  Konsistenz ist wichtig, wenn auch zum Nachteil der persönlichen Präferenz.  Meine Faustregel lautet: Wenn der Code durch <code>gofmt</code> passt, ist das Problem normalerweise nicht die Diskussion wert. <br><br><blockquote>  <b>Tipp</b> .  Wenn Sie die gesamte Codebasis umbenennen möchten, mischen Sie dies nicht mit anderen Änderungen.  Wenn jemand Git Bisect verwendet, wird er nicht gerne Tausende von Umbenennungen durchgehen, um einen anderen geänderten Code zu finden. </blockquote><br><h1>  3. Kommentare </h1><br>  Bevor wir zu wichtigeren Punkten übergehen, möchte ich einige Minuten dauern, um einen Kommentar abzugeben. <br><br><blockquote>  <i>„Ein guter Code hat viele Kommentare, und ein schlechter Code braucht viele Kommentare.“</i> - Dave Thomas und Andrew Hunt, Pragmatic Programmer </blockquote><br>  Kommentare sind sehr wichtig für die Lesbarkeit des Programms.  Jeder Kommentar sollte eines - und nur eines - von drei Dingen tun: <br><br><ol><li>  Erklären Sie, <i>was der</i> Code tut. </li><li>  Erklären Sie, <i>wie</i> er es macht. </li><li>  Erklären Sie <i>warum</i> . </li></ol><br>  Die erste Form ist ideal zum Kommentieren öffentlicher Charaktere: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Open     . //           .</span></span></code> </pre> <br>  Die zweite ist ideal für Kommentare innerhalb einer Methode: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var results []chan error for _, dep := range a.Deps { results = append(results, execute(seen, dep)) }</span></span></code> </pre> <br>  Die dritte Form („Warum“) ist insofern einzigartig, als sie die ersten beiden nicht ersetzt oder ersetzt.  Solche Kommentare erklären die externen Faktoren, die zum Schreiben des Codes in seiner aktuellen Form geführt haben.  Ohne diesen Kontext ist es oft schwierig zu verstehen, warum der Code so geschrieben ist. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;v2.Cluster_CommonLbConfig{ <span class="hljs-comment"><span class="hljs-comment">//  HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, }, }</span></span></code> </pre> <br>  In diesem Beispiel ist möglicherweise nicht sofort klar, was passiert, wenn HealthyPanicThreshold auf null Prozent festgelegt ist.  Der Kommentar soll klarstellen, dass ein Wert von 0 die Panikschwelle deaktiviert. <br><br><a name="3_1"></a><h2>  3.1.  Kommentare in Variablen und Konstanten sollten ihren Inhalt beschreiben, nicht den Zweck </h2><br>  Ich habe vorhin gesagt, dass der Name einer Variablen oder Konstante ihren Zweck beschreiben sollte.  Ein Kommentar zu einer Variablen oder Konstante sollte jedoch genau den <i>Inhalt</i> und nicht den <i>Zweck beschreiben</i> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br>  In diesem Beispiel beschreibt ein Kommentar, <i>warum</i> <code>randomNumber</code> auf 6 gesetzt ist und woher es stammt.  Der Kommentar beschreibt nicht, wo <code>randomNumber</code> verwendet wird.  Hier sind einige weitere Beispiele: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusContinue = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">// RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1</span></span></code> </pre> <br>  <i>Im Zusammenhang mit HTTP wird die</i> Nummer <code>100</code> als <code>StatusContinue</code> , wie in RFC 7231, Abschnitt 6.2.1 definiert. <br><br><blockquote>  <b>Tipp</b> .  Bei Variablen ohne Anfangswert sollte der Kommentar beschreiben, wer für die Initialisierung dieser Variablen verantwortlich ist. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sizeCalculationDisabled ,   //     . . dowidth. var sizeCalculationDisabled bool</span></span></code> </pre> <br>  Hier sagt ein Kommentar dem Leser, dass die <code>dowidth</code> Funktion für die Aufrechterhaltung des Status von <code>sizeCalculationDisabled</code> . </blockquote><br><blockquote>  <b>Tipp</b> .  In Sichtweite verstecken.  Dies ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rat von Kate Gregory</a> .  Manchmal ist der beste Name für eine Variable in den Kommentaren versteckt. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   SQL var registry = make(map[string]*sql.Driver)</span></span></code> </pre> <br>  Der Autor hat einen Kommentar hinzugefügt, weil die Namensregistrierung ihren Zweck nicht ausreichend erklärt - dies ist eine Registrierung, aber was ist die Registrierung? <br><br>  Wenn Sie eine Variable in sqlDrivers umbenennen, wird deutlich, dass sie SQL-Treiber enthält. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlDrivers = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*sql.Driver)</code> </pre> <br>  Jetzt ist der Kommentar überflüssig geworden und kann gelöscht werden. </blockquote><br><a name="3_2"></a><h2>  3.2.  Dokumentieren Sie immer öffentlich verfügbare Zeichen </h2><br>  Die Dokumentation für Ihr Paket wird von godoc generiert. Sie sollten daher jedem im Paket deklarierten öffentlichen Zeichen einen Kommentar hinzufügen: eine Variable, eine Konstante, eine Funktion und eine Methode. <br><br>  Hier sind zwei Richtlinien aus dem Google Style Guide: <br><br><ul><li>  Jede öffentliche Funktion, die nicht offensichtlich und prägnant ist, sollte kommentiert werden. <br></li><li>  Jede Funktion in der Bibliothek sollte kommentiert werden, unabhängig von Länge oder Komplexität. </li></ul><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ioutil <span class="hljs-comment"><span class="hljs-comment">// ReadAll   r      (EOF)   // ..    err == nil, not err == EOF. //  ReadAll     ,     //  . func ReadAll(r io.Reader) ([]byte, error)</span></span></code> </pre> <br>  Es gibt eine Ausnahme von dieser Regel: Sie müssen keine Methoden dokumentieren, die die Schnittstelle implementieren.  Tun Sie dies insbesondere nicht: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Read   io.Reader func (r *FileReader) Read(buf []byte) (int, error)</span></span></code> </pre> <br>  Dieser Kommentar hat nichts zu bedeuten.  Er sagt nicht, was die Methode macht: Schlimmer noch, er schickt irgendwohin, um nach Dokumentation zu suchen.  In dieser Situation schlage ich vor, den Kommentar vollständig zu löschen. <br><br>  Hier ist ein Beispiel aus dem <code>io</code> Paket. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// LimitReader  Reader,    r, //    EOF  n . //   *LimitedReader. func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} } // LimitedReader   R,     //   N .   Read  N  //    . // Read  EOF,  N &lt;= 0    R  EOF. type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining } func (l *LimitedReader) Read(p []byte) (n int, err error) { if lN &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; lN { p = p[0:lN] } n, err = lRRead(p) lN -= int64(n) return }</span></span></code> </pre> <br>  Beachten Sie, dass der <code>LimitedReader</code> Deklaration unmittelbar die Funktion vorausgeht, die sie verwendet, und dass die <code>LimitedReader.Read</code> Deklaration der Deklaration von <code>LimitedReader</code> selbst folgt.  Obwohl <code>LimitedReader.Read</code> selbst nicht dokumentiert ist, kann verstanden werden, dass dies eine Implementierung von <code>io.Reader</code> . <br><br><blockquote>  <b>Tipp</b> .  Schreiben Sie vor dem Schreiben einer Funktion einen Kommentar, der sie beschreibt.  Wenn Sie Schwierigkeiten haben, einen Kommentar zu schreiben, ist dies ein Zeichen dafür, dass der Code, den Sie schreiben möchten, schwer zu verstehen ist. </blockquote><br><h3>  3.2.1.  Kommentieren Sie keinen schlechten Code, schreiben Sie ihn neu </h3><br><blockquote>  <i>"Kommentieren Sie keinen schlechten Code - schreiben Sie ihn neu"</i> - Brian Kernighan </blockquote><br>  Es reicht nicht aus, in den Kommentaren die Schwierigkeit des Codefragments anzugeben.  Wenn Sie auf einen dieser Kommentare stoßen, sollten Sie ein Ticket mit einer Erinnerung an das Refactoring starten.  Sie können mit technischen Schulden leben, solange deren Höhe bekannt ist. <br><br>  Es ist üblich, Kommentare in der Standardbibliothek im TODO-Stil mit dem Namen des Benutzers zu hinterlassen, der das Problem bemerkt hat. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TODO(dfc)  O(N^2),     .</span></span></code> </pre> <br>  Dies ist keine Verpflichtung, das Problem zu beheben, aber der angegebene Benutzer ist möglicherweise die beste Person, um eine Frage zu stellen.  Andere Projekte begleiten TODO mit einem Datum oder einer Ticketnummer. <br><br><h3>  3.2.2.  Anstatt den Code zu kommentieren, überarbeiten Sie ihn </h3><br><blockquote>  <i>„Guter Code ist die beste Dokumentation.</i>  <i>Wenn Sie einen Kommentar hinzufügen möchten, stellen Sie sich die Frage: "Wie kann der Code verbessert werden, sodass dieser Kommentar nicht benötigt wird?"</i>  <i>Refactor und hinterlasse einen Kommentar, um es noch klarer zu machen. “</i> - Steve McConnell </blockquote><br>  Funktionen sollten nur eine Aufgabe ausführen.  Wenn Sie einen Kommentar schreiben möchten, weil ein Fragment nicht mit dem Rest der Funktion zusammenhängt, sollten Sie es in eine separate Funktion extrahieren. <br><br>  Kleinere Funktionen sind nicht nur klarer, sondern auch einfacher voneinander zu testen.  Wenn Sie den Code in eine separate Funktion isoliert haben, kann sein Name einen Kommentar ersetzen. <br><br><a name="4"></a><h1>  4. Paketstruktur </h1><br><blockquote>  <i>„Schreiben Sie einen bescheidenen Code: Module, die für andere Module nichts Überflüssiges anzeigen und nicht auf die Implementierung anderer Module angewiesen sind“</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dave Thomas</a> </blockquote><br>  Jedes Paket ist im Wesentlichen ein separates kleines Go-Programm.  Ebenso wie die Implementierung einer Funktion oder Methode für den Aufrufer keine Rolle spielt, spielt die Implementierung der Funktionen, Methoden und Typen, aus denen die öffentliche API Ihres Pakets besteht, keine Rolle. <br><br>  Ein gutes Go-Paket strebt eine minimale Konnektivität mit anderen Paketen auf Quellcodeebene an, damit Änderungen in einem Paket nicht mit der gesamten Codebasis kaskadiert werden, wenn das Projekt wächst.  Solche Situationen behindern Programmierer, die an dieser Codebasis arbeiten, erheblich. <br><br>  In diesem Abschnitt werden wir uns mit dem Paketdesign befassen, einschließlich seines Namens und Tipps zum Schreiben von Methoden und Funktionen. <br><br><a name="4_1"></a><h2>  4.1.  Ein gutes Paket beginnt mit einem guten Namen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein gutes Go-Paket beginnt mit einem Qualitätsnamen. </font><font style="vertical-align: inherit;">Stellen Sie sich das als eine kurze Präsentation vor, die auf nur ein Wort beschränkt ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie die Variablennamen im vorherigen Abschnitt ist der Paketname sehr wichtig. </font><font style="vertical-align: inherit;">Sie müssen nicht über die Datentypen in diesem Paket nachdenken. Stellen Sie besser die Frage: "Welchen Service bietet dieses Paket?" </font><font style="vertical-align: inherit;">Normalerweise lautet die Antwort nicht "Dieses Paket bietet Typ X", sondern "Mit diesem Paket können Sie eine Verbindung über HTTP herstellen."</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wählen Sie einen Paketnamen anhand seiner Funktionalität und nicht anhand seines Inhalts. </font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1.1. </font><font style="vertical-align: inherit;">Gute Paketnamen müssen eindeutig sein</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Paket hat einen eindeutigen Namen im Projekt. </font><font style="vertical-align: inherit;">Es ist kein Problem, wenn Sie den Rat befolgen, Namen für die Zwecke der Pakete anzugeben. </font><font style="vertical-align: inherit;">Wenn sich herausstellt, dass die beiden Pakete denselben Namen haben, wahrscheinlich:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Paketname ist zu allgemein. </font></font></li><li>       .       ,     . </li></ol><br><a name="4_2"></a><h2>  4.2.    <code>base</code> , <code>common</code>  <code>util</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein häufiger Grund für schlechte Namen sind die sogenannten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service-Pakete</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bei denen sich im Laufe der Zeit verschiedene Helfer und Service-Codes ansammeln. Da ist es schwierig, dort einen eindeutigen Namen zu finden. Dies führt häufig dazu, dass der Paketname von dem abgeleitet wird, was er </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dienstprogramme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namen wie </font></font><code>utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden normalerweise in großen Projekten gefunden, in denen eine tiefe Hierarchie von Paketen verwurzelt ist und Hilfsfunktionen gemeinsam genutzt werden. Wenn Sie eine Funktion in ein neues Paket extrahieren, wird der Import abgebrochen. In diesem Fall spiegelt der Name des Pakets nicht den Zweck des Pakets wider, sondern nur die Tatsache, dass die Importfunktion aufgrund einer nicht ordnungsgemäßen Organisation des Projekts fehlgeschlagen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In solchen Situationen empfehle ich zu analysieren, woher die Pakete aufgerufen werden.</font></font><code>utils</code> <code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verschieben Sie nach Möglichkeit die entsprechenden Funktionen in das aufrufende Paket. </font><font style="vertical-align: inherit;">Selbst wenn dies das Duplizieren eines Hilfscodes impliziert, ist es besser, als eine Importabhängigkeit zwischen zwei Paketen einzuführen.</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"[Ein wenig] Vervielfältigung ist viel billiger als eine falsche Abstraktion"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sandy Mets</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Dienstprogrammfunktionen an vielen Stellen verwendet werden, ist es besser, anstelle eines monolithischen Pakets mit Dienstprogrammfunktionen mehrere Pakete zu erstellen, die sich jeweils auf einen Aspekt konzentrieren. </font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie den Plural für Servicepakete. </font><font style="vertical-align: inherit;">Zum Beispiel </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Dienstprogramme zur Zeichenfolgenverarbeitung.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pakete mit Namen wie </font></font><code>base</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden häufig angetroffen, wenn eine bestimmte gemeinsame Funktionalität von zwei oder mehr Implementierungen oder gemeinsamen Typen für einen Client und einen Server in einem separaten Paket zusammengeführt wird. </font><font style="vertical-align: inherit;">Ich glaube, dass es in solchen Fällen notwendig ist, die Anzahl der Pakete zu reduzieren, indem Client, Server und allgemeiner Code in einem Paket mit einem Namen kombiniert werden, der seiner Funktion entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Beispiel, </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht die einzelne Pakete </font></font><code>client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen gibt es Dateien </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit den entsprechenden Datentypen sowie </font></font><code>transport.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für den gesamten Verkehr.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist wichtig zu beachten, dass der Bezeichnername den Paketnamen enthält. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus einem Paket </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird zu einem </font></font><code>http.Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link aus einem anderen Paket.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Typ </font></font><code>Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus einem Paket wird </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beim Import in andere Pakete umgewandelt </font></font><code>strings.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schnittstelle </font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus dem Paket ist </font></font><code>net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eindeutig mit Netzwerkfehlern verbunden.</font></font></li></ul></blockquote><br><a name="4_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3. </font><font style="vertical-align: inherit;">Komm schnell zurück, ohne tief zu tauchen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Go keine Ausnahmen im Kontrollfluss verwendet, müssen Sie nicht tief in den Code eintauchen, um eine Struktur auf oberster Ebene für </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">Blöcke bereitzustellen </font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anstelle einer mehrstufigen Hierarchie wird der Go-Code im Verlauf der Funktion auf dem Bildschirm angezeigt. </font><font style="vertical-align: inherit;">Mein Freund Matt Ryer nennt diese Praxis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"line of sight"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wird mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Randoperatoren erreicht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Bedingte Blöcke mit einer Vorbedingung am Eingang der Funktion. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel aus dem Paket </font></font><code>bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &lt;= opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Aufrufen der Funktion </font></font><code>UnreadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird der Status überprüft. </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der vorherige Vorgang nicht ausgeführt wurde </font></font><code>ReadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird sofort ein Fehler zurückgegeben. Der Rest der Funktion basiert auf dem, was </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">größer als ist </font></font><code>opInvalid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen Sie mit derselben Funktion, jedoch ohne den Grenzoperator:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &gt; opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Körper eines wahrscheinlicher erfolgreichen Zweigs ist in die erste Bedingung eingebettet </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und die Bedingung für einen erfolgreichen Ausgang </font></font><code>return nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss durch sorgfältiges Anpassen der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schließenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klammern ermittelt werden. </font><font style="vertical-align: inherit;">Die letzte Zeile der Funktion gibt jetzt einen Fehler zurück, und Sie müssen die Ausführung der Funktion in der entsprechenden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">öffnenden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klammer </font><font style="vertical-align: inherit;">verfolgen </font><font style="vertical-align: inherit;">, um herauszufinden, wie Sie zu diesem Punkt gelangen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Option ist schwerer zu lesen, was die Qualität der Programmierung und der Codeunterstützung beeinträchtigt. Daher bevorzugt Go die Verwendung von Grenzoperatoren und gibt Fehler frühzeitig zurück.</font></font><br><br><a name="4_4"></a><h2>  4.4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Machen Sie den Nullwert nützlich </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Variablendeklaration wird unter der Annahme, dass kein expliziter Initialisierer vorhanden ist, automatisch mit einem Wert initialisiert, der dem Inhalt des auf Null gesetzten Speichers entspricht, dh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Wertetyp wird durch eine der folgenden Optionen bestimmt: für numerische Typen - Null, für Zeigertypen - Null, für Slices, Maps und Kanäle gleich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Möglichkeit, immer einen bekannten Standardwert festzulegen, ist wichtig für die Sicherheit und Korrektheit Ihres Programms und kann Ihre Go-Programme einfacher und kompakter machen. Dies ist, was Go-Programmierer denken, wenn sie sagen: "Geben Sie Strukturen einen nützlichen Nullwert." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen Typ vor </font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der zwei ganzzahlige Felder enthält, die den internen Status des Mutex darstellen. Diese Felder sind in jeder Deklaration automatisch null.</font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Diese Tatsache wird im Code berücksichtigt, sodass der Typ für die Verwendung ohne explizite Initialisierung geeignet ist.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mu sync.Mutex val <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i MyInt <span class="hljs-comment"><span class="hljs-comment">// i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres Beispiel für einen Typ mit einem nützlichen Nullwert ist </font></font><code>bytes.Buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie können ohne explizite Initialisierung deklarieren und mit dem Schreiben beginnen.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>) io.Copy(os.Stdout, &amp;b) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Nullwert dieser Struktur bedeutet, dass </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beide </font></font><code>cap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich sind </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und y </font></font><code>array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der Zeiger auf den Speicher mit dem Inhalt des Sicherungs-Slice-Arrays, Wert </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie nicht explizit schneiden müssen, sondern es einfach deklarieren können.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// s := make([]string, 0) // s := []string{} var s []string s = append(s, "Hello") s = append(s, "world") fmt.Println(strings.Join(s, " ")) }</span></span></code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>var s []string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ähnlich den beiden kommentierten Zeilen oben, aber nicht identisch mit ihnen. </font><font style="vertical-align: inherit;">Es gibt einen Unterschied zwischen einem Slice-Wert von Null und einem Slice-Wert von Null Länge. </font><font style="vertical-align: inherit;">Der folgende Code gibt false aus.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fmt.Println(reflect.DeepEqual(s1, s2)) }</code> </pre> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine nützliche, wenn auch unerwartete Eigenschaft nicht initialisierter Zeigervariablen - Nullzeiger - ist die Fähigkeit, Methoden für Typen aufzurufen, die Null sind. </font><font style="vertical-align: inherit;">Dies kann verwendet werden, um einfach Standardwerte bereitzustellen.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/home"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.path } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c1 *Config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c2 = &amp;Config{ path: <span class="hljs-string"><span class="hljs-string">"/export"</span></span>, } fmt.Println(c1.Path(), c2.Path()) }</code> </pre> <br><a name="4_5"></a><h2>  4.5.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie den Status auf Paketebene </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schlüssel zum Schreiben von einfach zu unterstützenden Programmen, die schwach verbunden sind, besteht darin, dass das Ändern eines Pakets eine geringe Wahrscheinlichkeit haben sollte, ein anderes Paket zu beeinflussen, das nicht direkt vom ersten abhängig ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt zwei großartige Möglichkeiten, um eine schwache Konnektivität in Go zu erreichen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie Schnittstellen, um das für Funktionen oder Methoden erforderliche Verhalten zu beschreiben. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vermeiden Sie den globalen Status. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Go können wir Variablen im Bereich einer Funktion oder Methode sowie im Bereich eines Pakets deklarieren. </font><font style="vertical-align: inherit;">Wenn eine Variable mit einem Bezeichner mit Großbuchstaben öffentlich verfügbar ist, ist ihr Gültigkeitsbereich für das gesamte Programm global: Jedes Paket </font><font style="vertical-align: inherit;">sieht </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu jeder Zeit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Typ und den Inhalt dieser Variablen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der veränderbare globale Zustand stellt eine enge Beziehung zwischen den unabhängigen Teilen des Programms her, da globale Variablen zu einem unsichtbaren Parameter für jede Funktion im Programm werden! </font><font style="vertical-align: inherit;">Jede Funktion, die auf einer globalen Variablen beruht, kann verletzt werden, wenn sich der Typ dieser Variablen ändert. </font><font style="vertical-align: inherit;">Jede Funktion, die vom Status einer globalen Variablen abhängt, kann verletzt werden, wenn ein anderer Teil des Programms diese Variable ändert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So reduzieren Sie die Konnektivität, die eine globale Variable erzeugt: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschieben Sie die entsprechenden Variablen als Felder in die Strukturen, die sie benötigen. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie Schnittstellen, um die Verbindung zwischen dem Verhalten und der Implementierung dieses Verhaltens zu verringern. </font></font></li></ol><br><a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Projektstruktur </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns darüber sprechen, wie Pakete zu einem Projekt kombiniert werden. </font><font style="vertical-align: inherit;">Dies ist normalerweise ein einzelnes Git-Repository. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie das Paket sollte jedes Projekt ein klares Ziel haben. </font><font style="vertical-align: inherit;">Wenn es sich um eine Bibliothek handelt, muss sie eine Aufgabe ausführen, z. B. XML-Analyse oder Journaling. </font><font style="vertical-align: inherit;">Sie sollten nicht mehrere Ziele in einem Projekt kombinieren, um eine unheimliche Bibliothek zu vermeiden </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach meiner Erfahrung ist das Repository </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">letztendlich eng mit dem größten Konsumenten verbunden, und dies macht es schwierig, Korrekturen an früheren Versionen (Back-Port-Korrekturen) vorzunehmen, ohne sowohl </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Konsumenten als auch den Konsumenten in der Blockierungsphase </font><font style="vertical-align: inherit;">zu aktualisieren </font><font style="vertical-align: inherit;">, was zu vielen nicht verwandten Änderungen führt und sie auf dem Weg brechen API</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie eine Anwendung haben (Webanwendung, Kubernetes-Controller usw.), enthält das Projekt möglicherweise ein oder mehrere Hauptpakete. </font><font style="vertical-align: inherit;">In meinem Kubernetes-Controller gibt es beispielsweise ein Paket </font></font><code>cmd/contour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das als Server dient, der in einem Kubernetes-Cluster bereitgestellt wird, und als Debug-Client.</font></font><br><br><a name="5_1"></a><h2>  5.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weniger Pakete, aber größer </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Codeüberprüfung habe ich einen der typischen Fehler von Programmierern festgestellt, die aus anderen Sprachen zu Go gewechselt sind: Sie neigen dazu, Pakete zu missbrauchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie </font><font style="vertical-align: inherit;">nicht das ausgeklügelte System von Sichtbarkeit: die Sprache Modifikatoren wie in der Java nicht genug Zugang ist ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>protected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und implizit </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Es gibt kein Analogon für freundliche Klassen aus C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Go haben wir nur zwei Zugriffsmodifikatoren: Dies sind öffentliche und private Bezeichner, die durch den ersten Buchstaben des Bezeichners (Groß- / Kleinschreibung) angegeben werden. </font><font style="vertical-align: inherit;">Wenn der Bezeichner öffentlich ist, beginnt sein Name mit einem Großbuchstaben und kann von jedem anderen Go-Paket referenziert werden.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie konnten die Wörter "exportiert" oder "nicht exportiert" als Synonyme für öffentlich und privat hören.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Welche Methoden können angesichts der eingeschränkten Zugriffssteuerungsfunktionen verwendet werden, um zu komplexe Pakethierarchien zu vermeiden? </font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In jedem Paket muss zusätzlich zu </font></font><code>cmd/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode vorhanden sein.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe wiederholt gesagt, dass es besser ist, weniger größere Pakete zu bevorzugen. </font><font style="vertical-align: inherit;">Ihre Standardposition sollte sein, kein neues Paket zu erstellen. </font><font style="vertical-align: inherit;">Dies führt dazu, dass zu viele Typen öffentlich werden, wodurch ein breiter und kleiner Bereich der verfügbaren API erstellt wird. </font><font style="vertical-align: inherit;">Nachfolgend betrachten wir diese These ausführlicher.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kam aus Java? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie aus der Java- oder C # -Welt stammen, beachten Sie die unausgesprochene Regel: Ein Java-Paket entspricht einer einzelnen Quelldatei </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Go-Paket entspricht dem gesamten Maven-Modul oder der gesamten .NET-Assembly.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.1. </font><font style="vertical-align: inherit;">Sortieren des Codes nach Datei mithilfe von Importanweisungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie Pakete nach Service organisieren, sollten Sie dasselbe für die Dateien im Paket tun? </font><font style="vertical-align: inherit;">Woher wissen, wann eine Datei </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in mehrere aufgeteilt werden muss? </font><font style="vertical-align: inherit;">Woher wissen Sie, ob Sie zu weit gegangen sind und über das Zusammenführen von Dateien nachdenken müssen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind die Empfehlungen, die ich verwende:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starten Sie jedes Paket mit einer Datei </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Geben Sie dieser Datei den gleichen Namen wie dem Verzeichnis. </font><font style="vertical-align: inherit;">Das Paket </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sollte sich beispielsweise in einer Datei </font></font><code>http.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einem Verzeichnis befinden </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Paket wächst, können Sie die verschiedenen Funktionen in mehrere Dateien aufteilen. </font><font style="vertical-align: inherit;">Zum Beispiel kann die Datei </font></font><code>messages.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält die Typen </font></font><code>Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dateityp</font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><code>Client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Datei </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Servertyp.</font></font><br></li><li>       ,    .  ,       . <br></li><li>        . , <code>messages.go</code>     HTTP-       , <code>http.go</code>      , <code>client.go</code>  <code>server.go</code> —    HTTP     . </li></ul><br><blockquote>  <b>Tipp</b> .      . </blockquote><br><blockquote> <b></b> .  Go    .      <i></i> ( —      Go).           . </blockquote><br><h3> 5.1.2.     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Tool </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterstützt das Paket </font></font><code>testing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an zwei Stellen. Wenn Sie ein Paket haben </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können Sie eine Datei schreiben </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Paketdeklaration verwenden </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es kompiliert den Code </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es Teil des Pakets ist </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In der Umgangssprache wird ein solcher Test als intern bezeichnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Werkzeug </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unterstützt auch ein spezielles Paket Erklärung, die an den Enden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh </font></font><code>http_test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise können die Testdateien im selben Paket wie der Code gespeichert werden. Wenn solche Tests jedoch kompiliert werden, sind sie nicht Teil des Codes Ihres Pakets, sondern befinden sich in einem eigenen Paket. Auf diese Weise können Sie Tests so schreiben, als würde ein anderes Paket Ihren Code aufrufen. Solche Tests werden als extern bezeichnet.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich empfehle die Verwendung interner Tests für Unit-Unit-Tests. Auf diese Weise können Sie jede Funktion oder Methode direkt testen und so die Bürokratie externer Tests vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist jedoch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erforderlich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Beispiele für Testfunktionen ( </font></font><code>Example</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">in einer externen Testdatei abzulegen </font><font style="vertical-align: inherit;">. Dies stellt sicher, dass die Beispiele bei Betrachtung in godoc das entsprechende Paketpräfix erhalten und einfach kopiert werden können.</font></font><br><br><blockquote>  <b>Tipp</b> .    ,     . <br><br>   ,    ,   Go      <code>go</code> . ,  <code>net/http</code>       <code>net</code> . <br><br>           <code>.go</code> , ,    . </blockquote><br><h3> 5.1.3.   ,     API </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihr Projekt mehrere Pakete enthält, finden Sie möglicherweise exportierte Funktionen, die von anderen Paketen verwendet werden sollen, jedoch nicht für die öffentliche API. </font><font style="vertical-align: inherit;">In einer solchen Situation </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erkennt </font><font style="vertical-align: inherit;">das Tool </font><font style="vertical-align: inherit;">einen speziellen Ordnernamen </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mit dem Code platziert werden kann, der für Ihr Projekt geöffnet, für andere jedoch geschlossen ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein solches Paket zu erstellen, platzieren Sie es in einem Verzeichnis mit einem Namen </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder in seinem Unterverzeichnis. </font><font style="vertical-align: inherit;">Wenn das Team </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Import des Pakets mit dem Pfad sieht </font></font><code>internal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, überprüft es den Speicherort des aufrufenden Pakets in einem Verzeichnis oder Unterverzeichnis </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispielsweise kann ein Paket </font></font><code>.../a/b/c/internal/d/e/f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur ein Paket aus einem Verzeichnisbaum importieren </font></font><code>.../a/b/c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jedoch überhaupt nicht </font></font><code>.../a/b/g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder ein anderes Repository (siehe</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><a name="5_2"></a><h2>  5.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das kleinste Hauptpaket </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ein Paket </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">müssen nur über minimale Funktionen verfügen, da sie sich </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie ein Singleton verhalten: Ein Programm kann nur eine Funktion haben </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, einschließlich Tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da es sich </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um ein Singleton handelt, gibt es viele Einschränkungen für aufgerufene Objekte: Sie werden nur während </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>main.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einmal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgerufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies erschwert das Schreiben von Codetests </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher müssen Sie sich bemühen, so viel Logik wie möglich aus der Hauptfunktion und im Idealfall aus dem Hauptpaket abzuleiten.</font></font><br><br><blockquote>  <b>Tipp</b> . <code>func main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muss Flags analysieren, Verbindungen zu Datenbanken, Loggern usw. öffnen und dann die Ausführung auf ein übergeordnetes Objekt übertragen. </font></font></blockquote><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. API-Struktur </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der letzte Design-Rat für das Projekt halte ich für den wichtigsten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle vorhergehenden Sätze sind grundsätzlich unverbindlich. </font><font style="vertical-align: inherit;">Dies sind nur Empfehlungen, die auf persönlichen Erfahrungen beruhen. </font><font style="vertical-align: inherit;">Ich drücke diese Empfehlungen nicht zu sehr in eine Codeüberprüfung ein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die API ist eine andere Sache, hier nehmen wir die Fehler ernster, weil alles andere behoben werden kann, ohne die Abwärtskompatibilität zu beeinträchtigen: Zum größten Teil sind dies nur Implementierungsdetails. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es um öffentliche APIs geht, lohnt es sich, die Struktur von Anfang an ernsthaft zu betrachten, da nachfolgende Änderungen für die Benutzer destruktiv sind.</font></font><br><br><a name="6_1"></a><h2>  6.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Design-APIs, die vom Design her schwer zu missbrauchen sind </font></font></h2><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"APIs müssen für die ordnungsgemäße Verwendung einfach und für die falsche schwierig sein"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Bloch</font></font></a> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Blochs Rat ist vielleicht der wertvollste in diesem Artikel. </font><font style="vertical-align: inherit;">Wenn es schwierig ist, die API für einfache Dinge zu verwenden, ist jeder API-Aufruf komplizierter als nötig. </font><font style="vertical-align: inherit;">Wenn ein API-Aufruf komplex und nicht offensichtlich ist, wird er wahrscheinlich übersehen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1.1. </font><font style="vertical-align: inherit;">Seien Sie vorsichtig mit Funktionen, die mehrere Parameter desselben Typs akzeptieren.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein gutes Beispiel für eine auf den ersten Blick einfache, aber schwierig zu verwendende API ist, wenn zwei oder mehr Parameter desselben Typs erforderlich sind. </font><font style="vertical-align: inherit;">Vergleichen Sie zwei Funktionssignaturen:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist der Unterschied zwischen diesen beiden Funktionen? </font><font style="vertical-align: inherit;">Offensichtlich gibt einer maximal zwei Zahlen zurück und der andere kopiert die Datei. </font><font style="vertical-align: inherit;">Aber das ist nicht der Punkt.</font></font><br><br><pre> <code class="go hljs">Max(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 10 Max(10, 8) // 10</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Max ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kommutativ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Die Reihenfolge der Parameter spielt keine Rolle. </font><font style="vertical-align: inherit;">Maximal acht und zehn sind zehn, unabhängig davon, ob acht und zehn oder zehn und acht verglichen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei CopyFile ist dies jedoch nicht der Fall.</font></font><br><br><pre> <code class="go hljs">CopyFile(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>) CopyFile(<span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welcher dieser Operatoren sichert Ihre Präsentation und welcher überschreibt sie mit der Version der letzten Woche? </font><font style="vertical-align: inherit;">Sie können nicht sagen, bis Sie die Dokumentation überprüfen. </font><font style="vertical-align: inherit;">Im Verlauf der Codeüberprüfung ist unklar, ob die Reihenfolge der Argumente korrekt ist oder nicht. </font><font style="vertical-align: inherit;">Schauen Sie sich noch einmal die Dokumentation an. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine mögliche Lösung besteht darin, einen Hilfstyp einzuführen, der für den korrekten Anruf verantwortlich ist </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Source <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src Source)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dest </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CopyFile(dest, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(src)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from Source = <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span> from.CopyTo(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird hier </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">immer richtig aufgerufen - dies kann mit einem Unit-Test festgestellt werden - und kann privat durchgeführt werden, was die Wahrscheinlichkeit einer falschen Verwendung weiter verringert.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine API mit mehreren Parametern desselben Typs ist schwer korrekt zu verwenden. </font></font></blockquote><br><a name="6_2"></a><h2>  6.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entwerfen Sie eine API für einen grundlegenden Anwendungsfall </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vor einigen Jahren hielt ich eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präsentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über die Verwendung von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsoptionen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die API standardmäßig zu vereinfachen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wesentliche der Präsentation war, dass Sie eine API für den Hauptanwendungsfall entwickeln sollten. </font><font style="vertical-align: inherit;">Mit anderen Worten, die API sollte vom Benutzer nicht verlangen, zusätzliche Parameter anzugeben, die ihn nicht interessieren.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.1. </font><font style="vertical-align: inherit;">Die Verwendung von nil als Parameter wird nicht empfohlen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe zunächst gesagt, dass Sie den Benutzer nicht zwingen sollten, API-Parameter anzugeben, die ihn nicht interessieren. </font><font style="vertical-align: inherit;">Dies bedeutet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dass die APIs für den Hauptanwendungsfall entworfen werden</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Standardoption). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Beispiel aus dem net / http-Paket.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-comment"><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error {</span></span></code> </pre> <br> <code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert zwei Parameter: eine TCP-Adresse zum Abhören eingehender Verbindungen und </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Verarbeiten einer eingehenden HTTP-Anforderung. </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ermöglicht den zweiten Parameter zu sein </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In den Kommentaren wird darauf hingewiesen, dass das aufrufende Objekt normalerweise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tatsächlich</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> übergeben wird </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was auf den Wunsch hinweist, es </font></font><code>http.DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als impliziten Parameter zu verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt hat der Anrufer </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zwei Möglichkeiten, dasselbe zu tun.</font></font><br><br><pre> <code class="go hljs">http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Optionen machen dasselbe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Anwendung </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbreitet sich wie ein Virus. </font><font style="vertical-align: inherit;">Das Paket </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat auch einen Helfer </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so dass Sie sich die Struktur der Funktion vorstellen können </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenAndServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> l.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Serve(l, handler) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Aufrufer </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den zweiten Parameter übergeben kann, wird </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Verhalten ebenfalls unterstützt. </font><font style="vertical-align: inherit;">In der Tat ist es in der </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logik implementiert "wenn der Handler gleich ist </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, verwenden </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Die Akzeptanz </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eines Parameters kann den Aufrufer zu der </font><font style="vertical-align: inherit;">Annahme </font><font style="vertical-align: inherit;">veranlassen, dass er </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für beide Parameter übergeben werden kann. </font><font style="vertical-align: inherit;">Aber so</font></font><code>Serve</code> <br><br><pre> <code class="go hljs">http.Serve(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> führt zu einer schrecklichen Panik. </font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mischen Sie keine Parameter in derselben Funktionssignatur </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Autor hat </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versucht, das Leben der API-Benutzer für den Standardfall zu vereinfachen, die Sicherheit war jedoch beeinträchtigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Gegenwart </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">keinen Unterschied in der Anzahl der Zeilen zwischen expliziter und indirekter Verwendung </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im Vergleich zu </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> War es die Verwirrung wert, eine Zeile zu halten? </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux)</code> </pre> <br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überlegen Sie ernsthaft, wie viel Zeit die Hilfsfunktionen dem Programmierer ersparen. </font><font style="vertical-align: inherit;">Klarheit ist besser als Kürze.</font></font></blockquote><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie öffentliche APIs mit Parametern, die nur Tests benötigen. </font><font style="vertical-align: inherit;">Vermeiden Sie den Export von APIs mit Parametern, deren Werte sich nur während des Tests unterscheiden. </font><font style="vertical-align: inherit;">Exportieren Sie stattdessen Wrapper-Funktionen, die die Übertragung solcher Parameter verbergen, und verwenden Sie in Tests ähnliche Hilfsfunktionen, die die für den Test erforderlichen Werte übergeben.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.2. </font><font style="vertical-align: inherit;">Verwenden Sie Argumente mit variabler Länge anstelle von [] T.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sehr oft nimmt eine Funktion oder Methode einen Werteschnitt an. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShutdownVMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist nur ein erfundenes Beispiel, aber dies ist sehr häufig. Das Problem ist, dass diese Signaturen davon ausgehen, dass sie mit mehr als einem Datensatz aufgerufen werden. Wie die Erfahrung zeigt, werden sie häufig mit nur einem Argument aufgerufen, das in das Slice „gepackt“ werden muss, um die Anforderungen der Funktionssignatur zu erfüllen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Parameter </font></font><code>ids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Slice ist, können Sie außerdem ein leeres Slice oder eine Null an die Funktion übergeben, und der Compiler wird sich freuen. Dies erhöht die Testlast zusätzlich, da die Tests solche Fälle abdecken sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um ein Beispiel für eine solche API-Klasse zu geben, habe ich kürzlich die Logik überarbeitet, die die Installation einiger zusätzlicher Felder erforderte, wenn mindestens einer der Parameter ungleich Null war. Die Logik sah ungefähr so ​​aus:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> svc.MaxConnections &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxPendingRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRetries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Operator </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr lang wurde, wollte ich die Validierungslogik in eine separate Funktion ziehen. </font><font style="vertical-align: inherit;">Folgendes habe ich mir ausgedacht:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ermöglichte es, die Bedingung, unter der das Innengerät ausgeführt wird, klar anzugeben: </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch ein Problem mit </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jemand könnte es versehentlich so nennen:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive() { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird zurückkehren </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist nicht die schlechteste Option. </font><font style="vertical-align: inherit;">Schlimmer noch, wenn die </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückkehr </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Abwesenheit von Argumenten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist jedoch besser, die Signatur von anyPositive ändern zu können, um sicherzustellen, dass mindestens ein Argument an den Aufrufer übergeben wird. </font><font style="vertical-align: inherit;">Dies kann durch Kombinieren von Parametern für normale Argumente und Argumente variabler Länge (varargs) erfolgen:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie nicht mit weniger als einem Argument aufrufen.</font></font><br><br><a name="6_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3. </font><font style="vertical-align: inherit;">Lassen Sie die Funktionen das gewünschte Verhalten bestimmen.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, ich habe die Aufgabe erhalten, eine Funktion zu schreiben, die die Struktur </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf der Festplatte beibehält.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich könnte eine Funktion schreiben </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine Datei </font><font style="vertical-align: inherit;">schreibt </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es gibt jedoch einige Probleme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Signatur verhindert </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Möglichkeit, Daten über das Netzwerk aufzuzeichnen. Wenn eine solche Anforderung in Zukunft auftritt, muss die Signatur der Funktion geändert werden, was sich auf alle aufrufenden Objekte auswirkt. </font></font><br><br> <code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch unangenehm zu testen, da es direkt mit Dateien auf der Festplatte funktioniert. Um den Betrieb zu überprüfen, muss der Test daher den Inhalt der Datei nach dem Schreiben lesen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und ich muss sicherstellen, dass es </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in einen temporären Ordner geschrieben und anschließend gelöscht wird. </font></font><br><br> <code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert auch viele Methoden, die sich nicht auf das </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesen von Verzeichnissen und das Überprüfen, ob ein Pfad eine symbolische Verknüpfung ist, </font><font style="vertical-align: inherit;">beziehen </font><font style="vertical-align: inherit;">. Na wenn die Unterschrift</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beschrieb nur die relevanten Teile </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  Was kann getan werden? <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser können Sie das Prinzip der Schnittstellentrennung anwenden - und es </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf einer Schnittstelle </font><font style="vertical-align: inherit;">neu definieren </font><font style="vertical-align: inherit;">, die die allgemeineren Eigenschaften der Datei beschreibt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach einer solchen Änderung kann jeder Typ, der die Schnittstelle implementiert </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, durch den vorherigen ersetzt werden </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies erweitert gleichzeitig den Bereich </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und verdeutlicht dem Aufrufer, welche Typmethoden </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit seiner Operation zusammenhängen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und der Autor </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann diese nicht verwandten Methoden nicht mehr aufrufen </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, weil er sich hinter der Schnittstelle versteckt </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können das Prinzip der Schnittstellentrennung jedoch noch weiter ausbauen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens wenn</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nach dem Prinzip der Einzelverantwortung ist es unwahrscheinlich, dass er die Datei, die er gerade geschrieben hat, liest, um ihren Inhalt zu überprüfen - anderer Code sollte dies tun. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher können Sie die Spezifikationen der Schnittstelle eingrenzen, um </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur zu schreiben und zu schließen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens ist der Thread-Schließmechanismus y </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Erbe der Zeit, als er mit der Datei arbeitete. </font><font style="vertical-align: inherit;">Die Frage ist, unter welchen Umständen </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es geschlossen wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ob die </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ursache </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unbedingt, ob im Fall des Erfolgs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies stellt ein Problem für den Anrufer dar, da er möglicherweise Daten zum Stream hinzufügen möchte, nachdem das Dokument geschrieben wurde.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die beste Option ist, Save neu zu definieren, um nur mit zu arbeiten </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und den Operator vor allen anderen Funktionen zu schützen, außer dem Schreiben von Daten in den Stream. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Anwendung des Prinzips der Schnittstellentrennung wurde die Funktion gleichzeitig sowohl spezifischer in Bezug auf die Anforderungen (sie benötigt nur ein Objekt, in das sie geschrieben werden kann) als auch allgemeiner in Bezug auf die Funktionalität, da wir sie jetzt verwenden können </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um Daten dort zu speichern, wo sie implementiert sind </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Fehlerbehandlung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehrere Präsentationen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu diesem Thema im Blog, also werde ich nicht wiederholen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stattdessen möchte ich zwei weitere Bereiche im Zusammenhang mit der Fehlerbehandlung behandeln.</font></font><br><br><a name="7_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1. </font><font style="vertical-align: inherit;">Beseitigen Sie die Notwendigkeit der Fehlerbehandlung, indem Sie die Fehler selbst entfernen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich habe viele Vorschläge zur Verbesserung der Fehlerbehandlungssyntax gemacht, aber die beste Option ist, sie überhaupt nicht zu behandeln. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich sage nicht "Fehlerbehandlung löschen". </font><font style="vertical-align: inherit;">Ich schlage vor, den Code so zu ändern, dass keine Fehler bei der Verarbeitung auftreten.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Osterhouts jüngstes Buch zur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Philosophie der Softwareentwicklung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat mich zu diesem Vorschlag inspiriert </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eines der Kapitel trägt den Titel „Fehler aus der Realität entfernen“. </font><font style="vertical-align: inherit;">Versuchen wir, diesen Rat anzuwenden.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.1. </font><font style="vertical-align: inherit;">Zeilenanzahl</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden eine Funktion schreiben, um die Anzahl der Zeilen in einer Datei zu zählen. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir den Ratschlägen aus den vorhergehenden Abschnitten folgen, </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nicht </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; Es ist bereits Aufgabe des Anrufers, anzugeben, </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wessen Inhalt wir zählen möchten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erstellen </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Methode und rufen sie dann in einer Schleife auf </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wobei wir den Zähler erhöhen, bis wir das Ende der Datei erreichen. Dann geben wir die Anzahl der gelesenen Zeilen zurück. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zumindest wollen wir solchen Code schreiben, aber die Funktion ist mit Fehlerbehandlung belastet. Zum Beispiel gibt es so eine seltsame Konstruktion:</font></font><br><br><pre> <code class="go hljs"> _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhöhen die Anzahl der Zeilen, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bevor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir </font><font style="vertical-align: inherit;">nach Fehlern suchen - das sieht seltsam aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Grund, warum wir es so schreiben sollten, ist, dass es </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Fehler zurückgibt, wenn es das Ende der Datei früher als das Zeilenumbruchzeichen findet. </font><font style="vertical-align: inherit;">Dies kann passieren, wenn am Ende der Datei keine neue Zeile steht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dies zu beheben, ändern Sie die Logik des Zeilenzählers und prüfen Sie, ob die Schleife verlassen werden muss.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diese Logik ist immer noch nicht perfekt. Können Sie einen Fehler finden?</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben jedoch noch nicht nach Fehlern gesucht. </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird zurückgegeben, </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Ende der Datei erreicht ist. </font><font style="vertical-align: inherit;">Dies ist die erwartete Situation. </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie müssen also auf irgendeine Weise sagen: "Stopp, es gibt nichts mehr zu lesen." </font><font style="vertical-align: inherit;">Bevor Sie den Fehler an das aufrufende Objekt zurückgeben </font></font><code>CountLine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, müssen Sie daher überprüfen, ob der Fehler nicht mit dem Fehler zusammenhängt </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und ihn dann weiterleiten. Andernfalls kehren wir zurück </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und sagen, dass alles in Ordnung ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich denke, dies ist ein gutes Beispiel für Russ Cox 'These, wie die Fehlerbehandlung die Funktion verbergen kann. </font><font style="vertical-align: inherit;">Schauen wir uns die verbesserte Version an.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese verbesserte Version verwendet </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stattdessen </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter der Haube </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fügt aber eine gute Abstraktionsebene hinzu, die zur Beseitigung der Fehlerbehandlung beiträgt.</font></font><br><br><blockquote> <b></b> . <code>bufio.Scanner</code>    ,      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>sc.Scan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt einen Wert zurück, </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn der Scanner auf eine Zeichenfolge gestoßen ist und keinen Fehler gefunden hat. Daher wird der Schleifenkörper </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur aufgerufen, wenn sich eine Textzeile im Scannerpuffer befindet. Dies bedeutet, dass der neue </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fälle behandelt, wenn keine neue Zeile vorhanden ist oder wenn die Datei leer ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens </font><font style="vertical-align: inherit;">endet </font><font style="vertical-align: inherit;">der Zyklus </font><font style="vertical-align: inherit;">, da er </font></font><code>sc.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurückkehrt, </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn ein Fehler erkannt wird, </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn er das Ende der Datei erreicht oder ein Fehler erkannt wird. Der Typ </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merkt sich den ersten aufgetretenen Fehler. Mit der Methode können </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir diesen Fehler wiederherstellen, sobald wir die Schleife verlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kümmert </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">sich um die Verarbeitung </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und konvertiert sie, </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn das Ende der Datei fehlerfrei erreicht ist.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie auf eine übermäßige Fehlerbehandlung stoßen, versuchen Sie, einige Vorgänge in einen Hilfstyp zu extrahieren. </font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2. </font><font style="vertical-align: inherit;">Antwort des Autors</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mein zweites Beispiel wird per Post inspiriert </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Errors - diesen Wert“</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuvor haben wir Beispiele dafür gesehen, wie eine Datei geöffnet, geschrieben und geschlossen wird. </font><font style="vertical-align: inherit;">Es gibt eine Fehlerbehandlung, die jedoch nicht zu umfangreich ist, da Vorgänge in Hilfsprogrammen wie </font></font><code>ioutil.ReadFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">gekapselt werden können </font></font><code>ioutil.WriteFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei der Arbeit mit Netzwerkprotokollen auf niedriger Ebene muss jedoch eine Antwort direkt mithilfe von E / A-Grundelementen erstellt werden. </font><font style="vertical-align: inherit;">In diesem Fall kann die Fehlerbehandlung aufdringlich werden. </font><font style="vertical-align: inherit;">Stellen Sie sich ein Fragment eines HTTP-Servers vor, das eine HTTP-Antwort erstellt.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie zunächst die Statusleiste mit </font></font><code>fmt.Fprintf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und überprüfen Sie den Fehler. Dann schreiben wir für jede Überschrift einen Schlüssel und einen Überschriftenwert, wobei jedes Mal ein Fehler überprüft wird. Schließlich vervollständigen wir den Header-Abschnitt mit einem zusätzlichen </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, überprüfen den Fehler und kopieren den Antworttext auf den Client. Obwohl wir den Fehler nicht überprüfen müssen </font></font><code>io.Copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, müssen wir ihn von zwei Rückgabewerten in den einzigen zurückgeben, der zurückgibt </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist viel eintönige Arbeit. Sie können Ihre Aufgabe jedoch vereinfachen, indem Sie einen kleinen Wrapper anwenden </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfüllt den Vertrag </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so dass es als Wrapper verwendet werden kann. </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leitet Datensätze durch die Funktion, bis ein Fehler erkannt wird. In diesem Fall werden die Einträge zurückgewiesen und der vorherige Fehler zurückgegeben.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich </font><font style="vertical-align: inherit;">bewerben , </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Code Klarheit deutlich verbessert. </font><font style="vertical-align: inherit;">Sie müssen nicht mehr bei jedem einzelnen Vorgang nach Fehlern suchen. </font><font style="vertical-align: inherit;">Die Fehlermeldung wird als </font></font><code>ew.err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feldprüfung </font><font style="vertical-align: inherit;">an das Ende der Funktion </font><font style="vertical-align: inherit;">verschoben, um die störende Übersetzung der zurückgegebenen io.Copy-Werte zu vermeiden.</font></font><br><br><a name="7_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2. </font><font style="vertical-align: inherit;">Behandeln Sie den Fehler nur einmal</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschließend möchte ich darauf hinweisen, dass Fehler nur einmal behandelt werden sollten. </font><font style="vertical-align: inherit;">Verarbeitung bedeutet, die Bedeutung des Fehlers zu überprüfen und eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einzige</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entscheidung zu treffen.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer. func WriteAll(w io.Writer, buf []byte) { w.Write(buf) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie weniger als eine Entscheidung treffen, ignorieren Sie den Fehler. </font><font style="vertical-align: inherit;">Wie wir hier sehen, wird der Fehler von </font></font><code>w.WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ignoriert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es </font><font style="vertical-align: inherit;">ist aber auch falsch </font><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehr als eine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entscheidung als Reaktion auf einen Fehler </font><i><font style="vertical-align: inherit;">zu</font></i><font style="vertical-align: inherit;"> treffen. </font><font style="vertical-align: inherit;">Unten ist der Code, auf den ich oft stoße.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"unable to write:"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// annotated error goes to log file return err // unannotated error returned to caller } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn in diesem Beispiel während der Zeit ein Fehler auftritt </font></font><code>w.Write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird die Zeile in das Protokoll geschrieben und auch an das aufrufende Objekt zurückgegeben, das es möglicherweise auch protokolliert und an die oberste Ebene des Programms weiterleitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Höchstwahrscheinlich macht der Anrufer dasselbe:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Somit wird ein Stapel sich wiederholender Zeilen im Protokoll erstellt. </font></font><br><br><pre> <code class="go hljs">unable to write: io.EOF could not write config: io.EOF</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aber oben im Programm erhalten Sie einen ursprünglichen Fehler ohne Kontext. </font></font><br><br><pre> <code class="go hljs">err := WriteConfig(f, &amp;conf) fmt.Println(err) <span class="hljs-comment"><span class="hljs-comment">// io.EOF</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich möchte dieses Thema genauer analysieren, da ich das Problem der gleichzeitigen Rückgabe eines Fehlers und der Protokollierung meiner persönlichen Einstellungen nicht in Betracht ziehe. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println("could not write config: %v", err) return err } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich stoße oft auf ein Problem, das ein Programmierer vergisst, um von einem Fehler zurückzukehren. Wie bereits erwähnt, besteht der Stil von Go darin, Grenzoperatoren zu verwenden, die Voraussetzungen bei der Ausführung der Funktion zu überprüfen und frühzeitig zurückzukehren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Beispiel hat der Autor den Fehler überprüft, registriert, aber </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vergessen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , zurückzukehren. Aus diesem Grund entsteht ein subtiles Problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Go-Fehlerbehandlungsvertrag besagt, dass bei Vorliegen eines Fehlers keine Annahmen über den Inhalt anderer Rückgabewerte getroffen werden können. Da das JSON-Marshalling fehlgeschlagen ist, ist der Inhalt </font></font><code>buf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unbekannt: Es enthält möglicherweise nichts, aber schlimmer noch, es enthält möglicherweise ein halb geschriebenes JSON-Fragment.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Programmierer nach Überprüfung und Registrierung des Fehlers vergessen hat, zurückzukehren, wird der beschädigte Puffer übertragen </font></font><code>WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Vorgang ist wahrscheinlich erfolgreich und daher wird die Konfigurationsdatei nicht korrekt geschrieben. </font><font style="vertical-align: inherit;">Die Funktion wird jedoch normal ausgeführt, und das einzige Anzeichen dafür, dass ein Problem aufgetreten ist, ist eine Zeile im Protokoll, in der das JSON-Marshalling fehlgeschlagen ist, und kein Fehler im Konfigurationsdatensatz.</font></font><br><br><h3>  7.2.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hinzufügen von Kontext zu Fehlern </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Fehler ist aufgetreten, weil der Autor versucht hat, der Fehlermeldung einen Kontext hinzuzufügen. </font><font style="vertical-align: inherit;">Er versuchte, eine Markierung zu hinterlassen, um die Fehlerquelle anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns einen anderen Weg an, um dasselbe zu tun </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"write failed: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie den Fehlerdatensatz mit der Rückgabe in einer Zeile kombinieren, ist es schwieriger, die Rückgabe zu vergessen und eine versehentliche Fortsetzung zu vermeiden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn beim Schreiben der Datei ein E / A-Fehler auftritt, erzeugt die Methode </font></font><code>Error()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes:</font></font><br><br><pre> <code class="go hljs">could not write config: write failed: input/output error</code> </pre> <br><h3>  7.2.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehler beim Umschließen mit github.com/pkg/errors </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vorlage </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert gut für die </font><font style="vertical-align: inherit;">Aufzeichnung von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachrichten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehlern, aber die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Art des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehlers geht auf der Strecke. </font><font style="vertical-align: inherit;">Ich habe argumentiert, dass die Behandlung von Fehlern als undurchsichtige Werte für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lose gekoppelte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projekte </font><font style="vertical-align: inherit;">wichtig ist. </font><font style="vertical-align: inherit;">Daher sollte die Art des Quellfehlers keine Rolle spielen, wenn wir nur mit seinem Wert arbeiten müssen:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie sicher, dass es nicht Null ist. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeigen Sie es auf dem Bildschirm an oder protokollieren Sie es. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kommt jedoch vor, dass Sie den ursprünglichen Fehler wiederherstellen müssen. </font><font style="vertical-align: inherit;">Um solche Fehler zu kommentieren, können Sie so etwas wie mein Paket verwenden </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { f, err := os.Open(path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"open failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> f.Close() buf, err := ioutil.ReadAll(f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { home := os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) config, err := ReadFile(filepath.Join(home, <span class="hljs-string"><span class="hljs-string">".settings.xml"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config, errors.WithMessage(err, <span class="hljs-string"><span class="hljs-string">"could not read config"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt wird die Nachricht zu einem netten Fehler im K &amp; D-Stil: </font></font><br><br><pre> <code class="go hljs">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und sein Wert enthält einen Link zum ursprünglichen Grund. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"original error: %T %v\n"</span></span>, errors.Cause(err), errors.Cause(err)) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"stack trace:\n%+v\n"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf diese Weise können Sie den ursprünglichen Fehler wiederherstellen und die Stapelverfolgung anzeigen: </font></font><br><br><pre> <code class="plaintext hljs">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory stack trace: open /Users/dfc/.settings.xml: no such file or directory open failed main.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16 main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29 main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35 runtime.main /Users/dfc/go/src/runtime/proc.go:201 runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333 could not read config</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Paket </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können Sie Fehlerwerten in einem praktischen Format sowohl für eine Person als auch für eine Maschine einen Kontext hinzufügen. </font><font style="vertical-align: inherit;">Bei einer kürzlich gehaltenen Präsentation habe ich Ihnen gesagt, dass in der kommenden Version von Go ein solcher Wrapper in der Standardbibliothek erscheinen wird.</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Parallelität </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go wird häufig aufgrund seiner Parallelitätsfunktionen ausgewählt. Die Entwickler haben viel getan, um die Effizienz (in Bezug auf Hardwareressourcen) und Produktivität zu steigern, aber die Parallelitätsfunktionen von Go können verwendet werden, um Code zu schreiben, der weder produktiv noch zuverlässig ist. Am Ende des Artikels möchte ich einige Tipps geben, wie Sie einige der Fallstricke von Go-Parallelitätsfunktionen vermeiden können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erstklassige Parallelitätsunterstützung von Go wird von den Kanälen sowie von Anweisungen </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">bereitgestellt</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie Go-Theorie aus Lehrbüchern oder an einer Universität studiert haben, haben Sie vielleicht bemerkt, dass der Parallelitätsabschnitt immer einer der letzten im Kurs ist. </font><font style="vertical-align: inherit;">Unser Artikel ist nicht anders: Ich habe beschlossen, am Ende über Parallelität zu sprechen, als etwas zusätzlich zu den üblichen Fähigkeiten, die der Go-Programmierer lernen sollte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier gibt es eine gewisse Zweiteilung, da das Hauptmerkmal von Go unser einfaches, leichtes Modell der Parallelität ist. </font><font style="vertical-align: inherit;">Als Produkt verkauft sich unsere Sprache auf Kosten fast dieser einen Funktion. </font><font style="vertical-align: inherit;">Andererseits ist Parallelität eigentlich nicht so einfach zu verwenden, sonst hätten die Autoren es nicht zum letzten Kapitel in ihren Büchern gemacht, und wir hätten unseren Code nicht mit Bedauern betrachtet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Abschnitt werden einige der Fallstricke der naiven Verwendung von Go-Parallelitätsfunktionen erläutert.</font></font><br><br><a name="8_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1. </font><font style="vertical-align: inherit;">Mach die ganze Zeit etwas Arbeit.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist das Problem mit diesem Programm? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Programm macht das, was wir beabsichtigt haben: Es dient einem einfachen Webserver. </font><font style="vertical-align: inherit;">Gleichzeitig verbringt es CPU-Zeit in einer Endlosschleife, da </font></font><code>for{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der letzten Zeile </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorutin Main blockiert wird, ohne dass eine E / A ausgeführt wird, und nicht auf das Blockieren, Senden oder Empfangen von Nachrichten oder eine Verbindung mit dem Sheduler gewartet werden muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Go-Laufzeit normalerweise von einem Sheduler bedient wird, wird dieses Programm sinnlos auf dem Prozessor ausgeführt und kann in einer aktiven Sperre (Live-Sperre) enden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie kann ich das beheben? </font><font style="vertical-align: inherit;">Hier ist eine Option.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { runtime.Gosched() } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es mag albern aussehen, aber dies ist eine übliche Lösung, die mir im wirklichen Leben einfällt. </font><font style="vertical-align: inherit;">Dies ist ein Symptom für ein Missverständnis des zugrunde liegenden Problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie etwas erfahrener mit Go sind, können Sie so etwas schreiben.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine leere Anweisung ist </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für immer gesperrt. </font><font style="vertical-align: inherit;">Dies ist nützlich, da wir jetzt nicht den gesamten Prozessor nur für einen Anruf drehen </font></font><code>runtime.GoSched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir behandeln jedoch nur das Symptom, nicht die Ursache. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich möchte Ihnen eine andere Lösung zeigen, die Ihnen hoffentlich bereits in den Sinn gekommen ist. </font><font style="vertical-align: inherit;">Anstatt </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Goroutine zu </font><font style="vertical-align: inherit;">laufen </font><font style="vertical-align: inherit;">und das Hauptproblem der Goroutine zu verlassen, laufen Sie einfach </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Hauptgoroutine.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Funktion verlassen </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird das Go-Programm bedingungslos beendet, unabhängig davon, was andere Goroutinen während der Ausführung des Programms ausführen.</font></font></blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist also mein erster Rat: Wenn Goroutine keine Fortschritte machen kann, bis er ein Ergebnis von einem anderen erhält, ist es oft einfacher, die Arbeit selbst zu erledigen, als sie zu delegieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch entfällt häufig viel Statusverfolgung und Kanalmanipulation, die erforderlich sind, um das Ergebnis von Goroutine zurück an den Prozessinitiator zu übertragen.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Go-Programmierer missbrauchen Goroutinen, besonders am Anfang. </font><font style="vertical-align: inherit;">Wie alles andere im Leben ist Mäßigung der Schlüssel zum Erfolg.</font></font></blockquote><br><a name="8_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2. </font><font style="vertical-align: inherit;">Überlassen Sie die Parallelität dem Anrufer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist der Unterschied zwischen den beiden APIs? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns the contents of dir. func ListDirectory(dir string) ([]string, error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns a channel over which // directory entries will be published. When the list // of entries is exhausted, the channel will be closed. func ListDirectory(dir string) chan string</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erwähnen die offensichtlichen Unterschiede: Das erste Beispiel liest das Verzeichnis in ein Slice und gibt dann das gesamte Slice oder den Fehler zurück, wenn etwas schief gelaufen ist. Dies geschieht synchron, der Aufrufer blockiert, </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis alle Verzeichniseinträge gelesen wurden. Je nachdem, wie groß das Verzeichnis ist, kann es viel Zeit und möglicherweise viel Speicher in Anspruch nehmen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie das zweite Beispiel. Es ist ein bisschen mehr wie bei der klassischen Go-Programmierung, hier wird </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Kanal zurückgegeben, über den Verzeichniseinträge übertragen werden. Wenn der Kanal geschlossen ist, ist dies ein Zeichen dafür, dass keine Katalogeinträge mehr vorhanden sind. Da das Füllen des Kanals nach der Rückkehr erfolgt </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kann davon ausgegangen werden, dass Goroutinen beginnen, den Kanal zu füllen.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bei der zweiten Option ist es nicht erforderlich, Goroutine tatsächlich zu verwenden: Sie können einen Kanal auswählen, der ausreicht, um alle Verzeichniseinträge ohne Blockierung zu speichern, ihn ausfüllen, schließen und dann den Kanal an den Anrufer zurückgeben. </font><font style="vertical-align: inherit;">Dies ist jedoch unwahrscheinlich, da in diesem Fall dieselben Probleme auftreten, wenn eine große Speichermenge verwendet wird, um alle Ergebnisse im Kanal zu puffern.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanalversion hat zwei weitere Probleme:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung eines geschlossenen Kanals als Signal dafür, dass keine Elemente mehr verarbeitet werden müssen, </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kann den Aufrufer aufgrund eines Fehlers nicht über einen unvollständigen Satz von Elementen informieren. </font><font style="vertical-align: inherit;">Der Anrufer hat keine Möglichkeit, den Unterschied zwischen einem leeren Verzeichnis und einem Fehler zu vermitteln. </font><font style="vertical-align: inherit;">In beiden Fällen scheint der Kanal sofort geschlossen zu werden.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Anrufer muss beim Schließen des Kanals weiterlesen, da nur so zu verstehen ist, dass die Kanalfüll-Goroutine nicht mehr funktioniert. </font><font style="vertical-align: inherit;">Dies ist eine schwerwiegende Einschränkung der Verwendung </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Der Anrufer verbringt viel Zeit damit, vom Kanal zu lesen, selbst wenn er alle erforderlichen Daten erhalten hat. </font><font style="vertical-align: inherit;">Dies ist wahrscheinlich effizienter in Bezug auf die Speichernutzung für mittlere und große Verzeichnisse, aber die Methode ist nicht schneller als die ursprüngliche Slice-basierte Methode.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In beiden Fällen besteht die Lösung darin, einen Rückruf zu verwenden: eine Funktion, die bei der Ausführung im Kontext jedes Verzeichniseintrags aufgerufen wird. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es überrascht nicht, dass die Funktion so </font></font><code>filepath.WalkDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funktioniert.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Ihre Funktion Goroutine startet, müssen Sie dem Aufrufer eine Möglichkeit bieten, diese Routine explizit zu stoppen. </font><font style="vertical-align: inherit;">Es ist oft am einfachsten, den asynchronen Ausführungsmodus für den Anrufer zu belassen.</font></font></blockquote><br><a name="8_3"></a><h2>  8.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Führen Sie niemals Goroutine aus, ohne zu wissen, wann es aufhören wird </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Beispiel wurde Goroutine unnötig verwendet. </font><font style="vertical-align: inherit;">Eine der Hauptstärken von Go sind jedoch die erstklassigen Parallelitätsfunktionen. </font><font style="vertical-align: inherit;">In der Tat ist in vielen Fällen Parallelarbeit durchaus angebracht, und dann müssen Goroutinen verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese einfache Anwendung bedient den HTTP-Verkehr an zwei verschiedenen Ports: Port 8080 für den Anwendungsverkehr und Port 8001 für den Zugriff auf den Endpunkt </font></font><code>/debug/pprof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) <span class="hljs-comment"><span class="hljs-comment">// debug http.ListenAndServe("0.0.0.0:8080", mux) // app traffic }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl das Programm unkompliziert ist, ist es die Grundlage einer echten Anwendung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anwendung in ihrer aktuellen Form weist mehrere Probleme auf, die beim Wachstum auftreten. Schauen wir uns daher einige davon sofort an.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() serveApp() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brechen - </font><font style="vertical-align: inherit;">Handler </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf verschiedene Funktionen, die </font><font style="vertical-align: inherit;">wir haben sie von getrennt </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir folgten auch die vorherige Beratung und sorgte dafür , </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lassen Sie </font><font style="vertical-align: inherit;">die Aufgabe , </font><font style="vertical-align: inherit;">die Parallelität des Anrufers zu gewährleisten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch einige Probleme mit der Leistung eines solchen Programms. </font><font style="vertical-align: inherit;">Wenn wir kommen </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dann aus </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das Programm schaltet sich </font><font style="vertical-align: inherit;">ab und startet den Prozess - </font><font style="vertical-align: inherit;">Manager.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So wie Funktionen in Go dem Aufrufer Parallelität überlassen, sollten Anwendungen die Überwachung ihres Status beenden und das Programm, das sie aufgerufen hat, neu starten. </font><font style="vertical-align: inherit;">Machen Sie Ihre Anwendungen nicht für den Neustart selbst verantwortlich. Dieses Verfahren wird am besten von außerhalb der Anwendung ausgeführt.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnt jedoch in einer separaten Goroutine, und im Falle seiner Veröffentlichung endet die Goroutine, während der Rest des Programms fortgesetzt wird. </font><font style="vertical-align: inherit;">Ihren Entwicklern wird es nicht gefallen, dass Sie keine Anwendungsstatistiken erhalten können, da der Handler </font></font><code>/debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schon lange nicht mehr funktioniert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen sicherstellen, dass die Anwendung geschlossen ist, wenn </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Goroutine, die sie serviert, </font><font style="vertical-align: inherit;">aufhört </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveApp() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>serverApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontrollfehler aus </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ggf. Ursache </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Da beide Handler in Goroutinen arbeiten, erstellen wir die Hauptroutine in </font></font><code>select{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Ansatz weist eine Reihe von Problemen auf:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Fehler zurückgegeben wird </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, erfolgt kein Aufruf </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und der HTTP-Dienst an diesem Port wird beendet, ohne die Anwendung zu stoppen.</font></font><br></li><li> <code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruft </font></font><code>os.Exit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Programm bedingungslos auf; </font><font style="vertical-align: inherit;">Zurückgestellte Anrufe funktionieren nicht, andere Goroutinen werden nicht über den Abschluss informiert, das Programm wird einfach gestoppt. </font><font style="vertical-align: inherit;">Dies macht es schwierig, Tests für diese Funktionen zu schreiben.</font></font></li></ol><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nur </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für Funktionen </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder verwenden </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich möchten wir dem Schöpfer der Goroutine jeden Fehler mitteilen, der auftritt, damit er herausfinden kann, warum sie den Prozess gestoppt und sauber abgeschlossen hat.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveDebug() }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveApp() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(done); i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := &lt;-done; err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error: %v"</span></span>, err) } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Goroutine-Rückgabestatus kann über den Kanal abgerufen werden. Die Kanalgröße entspricht der Anzahl der Goroutinen, die wir steuern möchten, sodass das Senden an den Kanal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht blockiert wird, da dies das Herunterfahren von Goroutinen blockiert und ein Leck verursacht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der Kanal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht sicher geschlossen werden kann, können wir die Redewendung nicht für </font></font><code>for range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Kanalzyklus verwenden, bis alle Goroutinen gemeldet haben. Stattdessen führen wir alle laufenden Goroutinen in einem Zyklus aus, der der Kapazität des Kanals entspricht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir die Möglichkeit, jede Goroutine sauber zu beenden und alle aufgetretenen Fehler zu beheben. Es bleibt nur ein Signal zu senden, um die Arbeit von der ersten Goroutine an alle anderen abzuschließen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Appell an</font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">über die Fertigstellung, also habe ich diese Logik in eine Hilfsfunktion eingewickelt. </font><font style="vertical-align: inherit;">Der Helfer </font></font><code>serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert die Adresse und </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ebenso </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Kanal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, über den wir die Methode ausführen </font></font><code>Shutdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler http.Handler, stop &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s := http.Server{ Addr: addr, Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-stop <span class="hljs-comment"><span class="hljs-comment">// wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe() } func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, "Hello, QCon!") }) return serve("0.0.0.0:8080", mux, stop) } func serveDebug(stop &lt;-chan struct{}) error { return serve("127.0.0.1:8001", http.DefaultServeMux, stop) } func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println("error: %v", err) } if !stopped { stopped = true close(stop) } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schließen wir </font><font style="vertical-align: inherit;">für jeden Wert im Kanal </font><font style="vertical-align: inherit;">den Kanal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wodurch jeder Gorutin auf diesem Kanal seinen eigenen schließt </font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies führt wiederum zu einer Rückgabe aller verbleibenden Goroutinen </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn alle laufenden Gorutine gestoppt sind, </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">endet es und der Prozess stoppt sauber.</font></font><br><br><blockquote>  <b>Tipp</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine solche Logik selbst zu schreiben, ist sich wiederholende Arbeit und das Risiko von Fehlern. </font><font style="vertical-align: inherit;">Schauen Sie sich so etwas wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Paket an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das den größten Teil der Arbeit für Sie erledigt.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441842/">https://habr.com/ru/post/de441842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441826/index.html">Was passiert auf dem Audio-Streaming-Markt? Diskussion über die Entwicklung von Streaming-Plattformen</a></li>
<li><a href="../de441830/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 4</a></li>
<li><a href="../de441832/index.html">Wer ist der Projektmanager nach Meinung des Geschäftsinhabers und wie geht man damit um?</a></li>
<li><a href="../de441834/index.html">Nicht zur Arbeit nehmen. Aber was ist, wenn die Sache in dir liegt?</a></li>
<li><a href="../de441836/index.html">Eine Cloud-Geschichte: Huawei + 3data = Cloud</a></li>
<li><a href="../de441844/index.html">iRobot Scooba: Erfahrung und Lösungen für häufig auftretende Probleme eines Waschroboterreinigers</a></li>
<li><a href="../de441848/index.html">Praktika für Entwickler in Avito: Kämpfe gegen Missionen und arbeite mit erfahrenen Mentoren</a></li>
<li><a href="../de441850/index.html">Wahrsagerei in neuronalen Netzen: ob der Autor selbst in den Kommentaren zum Beitrag vermerkt hat</a></li>
<li><a href="../de441852/index.html">42 Silicon Valley: So werden Sie ausgewählt</a></li>
<li><a href="../de441854/index.html">RUHE? Nimm einen dummen JSON-RPC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>