<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐢 👳🏿 👩🏼‍🎤 Comment fonctionne la recherche Yandex.Market et que se passera-t-il si l'un des serveurs plante 🤰🏿 💩 🧙🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut, je m'appelle Eugene. Je travaille dans l'infrastructure de recherche Yandex.Market. Je veux parler à la communauté Habr de la cuisine interne d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment fonctionne la recherche Yandex.Market et que se passera-t-il si l'un des serveurs plante</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/475848/">  Salut, je m'appelle Eugene.  Je travaille dans l'infrastructure de recherche Yandex.Market.  Je veux parler à la communauté Habr de la cuisine interne du marché - mais il y a quelque chose à dire.  Tout d'abord, comment fonctionnent la recherche de marché, les processus et l'architecture.  Comment gérer les situations d'urgence: que se passe-t-il si un serveur tombe en panne?  Et s'il y a 100 serveurs de ce type? <br><br>  Vous apprendrez également comment nous implémentons immédiatement de nouvelles fonctionnalités sur un groupe de serveurs.  Et comment tester des services complexes directement en production, sans déranger les utilisateurs.  En général, comment fonctionne la recherche du marché, pour que tout le monde aille bien. <br><br><img src="https://habrastorage.org/webt/-x/ye/eb/-xyeebvixa2pxxh3ad-peaoukyo.png"><br><a name="habracut"></a><br><h2>  Un peu sur nous: quel problème résolvons-nous </h2><br>  Lorsque vous saisissez du texte, recherchez des produits par paramètres ou comparez les prix dans différents magasins, toutes les demandes arrivent au service de recherche.  La recherche est le plus grand service du marché. <br><br>  Nous traitons toutes les requêtes de recherche: depuis market.yandex.ru, beru.ru, le service Supercheck, Yandex.Advisor et les applications mobiles.  Nous incluons également des offres de produits dans les résultats de recherche sur yandex.ru. <br><br><img width="500" src="https://habrastorage.org/webt/yt/_h/5d/yt_h5de7hmx0zmkv8gdk7glq-kc.png"><br><br>  Par service de recherche, je veux dire non seulement la recherche directe, mais aussi une base de données avec toutes les offres sur le marché.  L'échelle est la suivante: plus d'un milliard de requêtes de recherche sont traitées par jour.  Et tout devrait fonctionner rapidement, sans interruption et toujours produire le résultat souhaité. <br><br><h2>  Qu'est-ce que: l'architecture du marché </h2><br>  Décrivez brièvement l'architecture actuelle du marché.  Classiquement, il peut être décrit par le schéma ci-dessous: <br><img src="https://habrastorage.org/webt/ra/yq/jv/rayqjvvmbjvxhsc8lokpysg_rvw.jpeg"><br>  Disons qu'un magasin partenaire vient à nous.  Il dit que je veux vendre un jouet: ce méchant chat avec un couineur.  Et un chat diabolique sans tweeter.  Et juste un chat.  Ensuite, le magasin doit préparer des offres sur lesquelles le marché recherche.  Le magasin forme un xml spécial avec des offres et communique le chemin vers ce xml via une interface partenaire.  Ensuite, l'indexeur télécharge périodiquement ce fichier XML, vérifie les erreurs et stocke toutes les informations dans une énorme base de données. <br><br>  Il existe de nombreux fichiers XML de ce type.  Un index de recherche est créé à partir de cette base de données.  L'index est stocké au format interne.  Après avoir créé l'index, le service Layouts le télécharge sur les moteurs de recherche. <br><br>  En conséquence, un chat maléfique avec un couineur apparaît dans la base de données et un index de chat apparaît sur le serveur. <br><br>  Je vais parler de la façon dont nous recherchons un chat dans la partie sur l'architecture de recherche. <br><br><h2>  Architecture de recherche de marché </h2><br>  Nous vivons dans le monde des microservices: chaque demande entrante sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">market.yandex.ru</a> provoque de nombreuses sous-requêtes, et des dizaines de services participent à leur traitement.  Le diagramme n'en montre que quelques-uns: <br><br><img src="https://habrastorage.org/webt/92/n9/iu/92n9iutvet9ls6k7djh29brfdq0.jpeg"><br>  <i>Schéma de traitement des demandes simplifié</i> <br><br>  Chaque service a une chose merveilleuse - son propre équilibreur avec un nom unique: <br><br><img src="https://habrastorage.org/webt/qb/_c/t4/qb_ct4mdpio2xprdlos2pi1oym8.jpeg"><br><br>  L'équilibreur nous offre une grande flexibilité dans la gestion du service: par exemple, vous pouvez désactiver les serveurs, ce qui est souvent nécessaire pour les mises à jour.  L'équilibreur voit que le serveur n'est pas disponible et redirige automatiquement les demandes vers d'autres serveurs ou centres de données.  Lorsque vous ajoutez ou supprimez un serveur, la charge est automatiquement redistribuée entre les serveurs. <br><br>  Le nom unique de l'équilibreur ne dépend pas du centre de données.  Lorsque le service A fait une demande à B, alors par défaut, l'équilibreur B redirige la demande vers le centre de données actuel.  Si le service n'est pas disponible ou absent dans le centre de données actuel, la demande est redirigée vers d'autres centres de données. <br><br>  Un FQDN unique pour tous les centres de données permet au service A de se désengager généralement des emplacements.  Sa demande au service B sera toujours traitée.  Une exception est le cas lorsque le service est dans tous les centres de données. <br><br>  Mais tout n'est pas si rose avec cet équilibreur: nous avons un composant intermédiaire supplémentaire.  L'équilibreur peut être instable et ce problème est résolu par des serveurs redondants.  Il existe également un délai supplémentaire entre les services A et B. Mais en pratique, il est inférieur à 1 ms et pour la plupart des services, ce n'est pas critique. <br><br><h3>  Lutter contre l'inattendu: services de recherche équilibrés et résilients </h3><br>  Imaginez qu'un effondrement se soit produit: vous devez trouver un chat avec un couinement, mais le serveur tombe en panne.  Ou 100 serveurs.  Comment sortir?  Allons-nous vraiment laisser l'utilisateur sans chat? <br><br>  La situation est terrible, mais nous y sommes prêts.  Je vais te le dire dans l'ordre. <br><br>  L'infrastructure de recherche est située dans plusieurs centres de données: <br><br><img src="https://habrastorage.org/webt/_i/wa/f9/_iwaf97__hrhmaspgxcl-euqqnq.jpeg"><br><br>  Lors de la conception, nous laissons la possibilité de désactiver un centre de données.  La vie est pleine de surprises - par exemple, une excavatrice peut couper un câble souterrain (oui, c'était comme ça).  Les capacités des autres centres de données devraient être suffisantes pour résister à la charge de pointe. <br><br>  Prenons un seul centre de données.  Dans chaque centre de données, le même schéma d'équilibreurs: <br><br><img src="https://habrastorage.org/webt/x6/rp/hx/x6rphx-hrlcb1gciennukyjeudi.jpeg"><br>  Un équilibreur est composé d'au moins trois serveurs physiques.  Une telle redondance est faite pour la fiabilité.  Les équilibreurs travaillent sur HAProx. <br><br>  Nous avons choisi HAProx en raison de ses performances élevées, de ses faibles besoins en ressources et de ses nombreuses fonctionnalités.  À l'intérieur de chaque serveur, notre logiciel de recherche fonctionne. <br><br>  La probabilité de défaillance d'un serveur est faible.  Mais si vous avez plusieurs serveurs, la probabilité qu'au moins une chute augmente. <br><br>  C'est ce qui se passe en réalité: les serveurs se bloquent.  Par conséquent, vous devez constamment surveiller l'état de tous les serveurs.  Si le serveur ne répond plus, il est automatiquement déconnecté du trafic.  Pour cela, HAProxy a un bilan de santé intégré.  Il va à tous les serveurs avec la requête HTTP «/ ping» une fois par seconde. <br><br>  Une autre fonctionnalité de HAProxy: l'agent-check vous permet de charger tous les serveurs de manière uniforme.  Pour ce faire, HAProxy se connecte à tous les serveurs et renvoie leur poids en fonction de la charge actuelle de 1 à 100. Le poids est calculé en fonction du nombre de demandes dans la file d'attente de traitement et de la charge sur le processeur. <br><br>  Maintenant sur la recherche d'un chat.  Demandes du formulaire <b>/ recherche? Texte = en colère + chat</b> arrive à la <b>recherche</b> .  Pour que la recherche soit rapide, l'index de chat entier doit être placé dans la RAM.  Même la lecture à partir d'un SSD n'est pas assez rapide. <br><br>  Il était une fois, la base de l'offre était petite et il y avait suffisamment de RAM pour un serveur.  Au fur et à mesure que la base de données des propositions s'est développée, tout a cessé de tenir dans cette RAM et les données ont été divisées en deux parties: le fragment 1 et le fragment 2. <br><br><img src="https://habrastorage.org/webt/kz/od/j5/kzodj5ghrqccc_necth6gmylzgy.jpeg"><br>  Mais cela arrive toujours: toute solution, même bonne, pose d'autres problèmes. <br><br>  L'équilibreur est toujours allé sur n'importe quel serveur.  Mais sur la machine d'où venait la demande, il n'y avait que la moitié de l'index.  Le reste était sur d'autres serveurs.  Par conséquent, le serveur devait se rendre sur une machine voisine.  Après avoir reçu les données des deux serveurs, les résultats ont été combinés et réorganisés. <br><br>  Étant donné que l'équilibreur distribue les demandes de manière égale, tous les serveurs ont été impliqués dans la réorganisation, et pas seulement dans la transmission des données. <br><br>  Le problème s'est produit si le serveur voisin n'était pas disponible.  La solution a été de spécifier plusieurs serveurs avec des priorités différentes comme serveur "voisin".  Tout d'abord, la demande a été envoyée aux serveurs du rack actuel.  Si aucune réponse n'a été reçue, la demande a été envoyée à tous les serveurs de ce centre de données.  Enfin et surtout, la demande a été envoyée à d'autres centres de données. <br>  À mesure que le nombre de propositions augmentait, les données étaient divisées en quatre parties.  Mais ce n'était pas la limite. <br><br>  Maintenant, une configuration de huit fragments est utilisée.  De plus, pour économiser davantage de mémoire, l'index a été divisé en la partie de recherche (par laquelle la recherche a lieu) et la partie d'extrait de code (qui n'est pas impliquée dans la recherche). <br><br>  Un serveur contient des informations sur un seul fragment.  Par conséquent, pour effectuer une recherche sur l'index complet, vous devez rechercher sur huit serveurs contenant des fragments différents. <br><br>  Les serveurs sont regroupés en clusters.  Chaque cluster contient huit moteurs de recherche et un extrait. <br><br><img src="https://habrastorage.org/webt/1b/om/dl/1bomdlbzui-uxhswoq1kfq9h7os.jpeg"><br>  La base de données de valeurs-clés avec des données statiques s'exécute sur le serveur d'extraits de code.  Ils sont nécessaires pour délivrer des documents, par exemple, une description d'un chat avec un couineur.  Les données sont spécialement extraites sur un serveur séparé afin de ne pas charger la mémoire des moteurs de recherche. <br><br>  Étant donné que les ID de document sont uniques uniquement dans le cadre d'un index, une situation peut se produire en l'absence de documents dans les extraits de code.  Eh bien ou que sur un ID il y aura un autre contenu.  Par conséquent, pour que la recherche fonctionne et que la recherche se produise, un besoin est apparu pour la cohérence de l'ensemble du cluster.  Je parlerai de la façon dont nous surveillons la cohérence un peu plus tard. <br><br>  La recherche elle-même est organisée comme suit: une requête de recherche peut arriver à l'un des huit serveurs.  Disons qu'il est venu sur le serveur 1. Ce serveur traite tous les arguments et comprend quoi et comment chercher.  Selon la demande entrante, le serveur peut faire des demandes supplémentaires aux services externes pour les informations nécessaires.  Une demande peut être suivie par jusqu'à dix demandes adressées à des services externes. <br><br>  Après avoir collecté les informations nécessaires, une recherche commence dans la base de données des offres.  Pour ce faire, des sous-requêtes sont effectuées pour les huit serveurs du cluster. <br><br>  Après avoir reçu les réponses, les résultats sont combinés.  Au final, pour générer le problème, vous devrez peut-être plusieurs sous-requêtes supplémentaires sur le serveur d'extraits de code. <br><br>  Les requêtes de recherche au sein du cluster sont: <b>/ shard1? Text = angry + cat</b> .  De plus, des sous-requêtes de la forme: <b>/ status</b> sont constamment effectuées entre tous les serveurs du cluster une fois par seconde. <br><br>  La demande <b>/ status</b> détecte une situation où le serveur n'est pas disponible. <br><br>  Il contrôle également que sur tous les serveurs, la version du moteur de recherche et la version d'index sont identiques, sinon il y aura des données incohérentes à l'intérieur du cluster. <br><br>  Malgré le fait qu'un serveur d'extraits de code traite les demandes de huit moteurs de recherche, son processeur est très légèrement chargé.  Par conséquent, nous transférons maintenant les données d'extrait de code vers un service distinct. <br><br><img src="https://habrastorage.org/webt/3u/q5/ng/3uq5ngicgxwxg60diggqot7iiky.jpeg"><br><br>  Pour transférer des données, nous avons introduit des clés universelles pour les documents.  Maintenant, la situation est impossible lorsqu'une clé renvoie le contenu d'un autre document. <br><br>  Mais la transition vers une autre architecture n'est pas encore terminée.  Nous voulons maintenant nous débarrasser du serveur d'extraits dédié.  Et ensuite, éloignez-vous généralement de la structure du cluster.  Cela nous permettra de continuer à évoluer facilement.  Un bonus supplémentaire est une importante économie de fer. <br><br>  Et maintenant aux histoires effrayantes avec une fin heureuse.  Considérez plusieurs cas d'indisponibilité du serveur. <br><br><h4>  Terrible s'est produit: un serveur n'est pas disponible </h4><br>  Disons qu'un serveur n'est pas disponible.  Les autres serveurs du cluster peuvent alors continuer de répondre, mais les résultats de la recherche seront incomplets. <br><br>  Grâce à une vérification de l'état, les serveurs voisins comprennent que l'un n'est pas disponible.  Par conséquent, pour maintenir l'exhaustivité, tous les serveurs du cluster commencent à répondre à la demande <b>/ ping</b> à l'équilibreur qu'ils sont également indisponibles.  Il s'avère que tous les serveurs du cluster sont morts (ce qui n'est pas le cas).  C'est le principal inconvénient de notre schéma de cluster - par conséquent, nous voulons nous en éloigner. <br><br><img src="https://habrastorage.org/webt/hr/ko/2o/hrko2ovb9b5q2hjb8xqgnubynec.jpeg"><br><br>  Demandes qui se sont terminées par une erreur, l'équilibreur demande à nouveau sur d'autres serveurs. <br>  De plus, l'équilibreur cesse d'envoyer du trafic utilisateur aux serveurs morts, mais continue de vérifier leur état. <br><br>  Lorsque le serveur devient disponible, il commence à répondre à <b>/ ping</b> .  Dès que les réponses normales aux pings des serveurs morts commencent à arriver, les équilibreurs commencent à y envoyer du trafic utilisateur.  Le cluster est rétabli, applaudissements. <br><br><h4>  Pire encore: de nombreux serveurs indisponibles </h4><br>  Une partie importante des serveurs du centre de données est coupée.  Que faire, où courir?  L'équilibreur vient à nouveau à la rescousse.  Chaque équilibreur garde constamment en mémoire le nombre actuel de serveurs actifs.  Il considère toujours la quantité maximale de trafic que le centre de données actuel peut gérer. <br><br>  Lorsque de nombreux serveurs du centre de données tombent, l'équilibreur comprend que ce centre de données ne peut pas traiter tout le trafic. <br><br>  Ensuite, le trafic excédentaire commence distribué de manière aléatoire vers d'autres centres de données.  Tout fonctionne, tout le monde est content. <br><br><img src="https://habrastorage.org/webt/cp/g-/if/cpg-ifevj3dzyvmedn1v-g5lzpg.jpeg"><br><h2>  Comment nous le faisons: versions de sortie </h2><br>  Maintenant, comment nous publions les modifications apportées au service.  Ici, nous avons emprunté la voie de la rationalisation des processus: le déploiement d'une nouvelle version est presque entièrement automatisé. <br>  Lorsqu'un certain nombre de modifications sont accumulées dans le projet, une nouvelle version est automatiquement créée et son assemblage est lancé. <br><br><img src="https://habrastorage.org/webt/cy/to/0f/cyto0f3qhsuxs7bgd2momnccebe.jpeg"><br><br>  Ensuite, le service est déployé pour les tests, où la stabilité est vérifiée. <br><br>  Parallèlement, les tests de performances automatiques sont lancés.  Il est engagé dans un service spécial.  Je ne parlerai pas de lui maintenant - sa description mérite un article séparé. <br><br>  Si la publication dans testing est réussie, la publication de la version dans prestable démarre automatiquement.  Prestable est un cluster spécial où le trafic utilisateur normal est dirigé.  S'il renvoie une erreur, l'équilibreur fait une nouvelle demande en production. <br><br>  En pré-stable, les temps de réponse sont mesurés et comparés à la version précédente en production.  Si tout va bien, la personne se connecte: vérifie les graphiques et les résultats des tests de charge, puis commence le déploiement en production. <br><br><h2>  Tout le meilleur pour l'utilisateur: test A / B </h2><br>  Il n'est pas toujours évident que les changements apportés au service apporteront de réels avantages.  Pour mesurer l'utilité du changement, les gens ont proposé des tests A / B.  Je vais parler un peu de la façon dont cela fonctionne dans la recherche Yandex.Market. <br><br>  Tout commence par l'ajout d'un nouveau paramètre CGI qui inclut de nouvelles fonctionnalités.  Soit notre paramètre: <i>market_new_functionality = 1</i> .  Ensuite, dans le code, activez cette fonctionnalité avec l'indicateur: <br><br><pre><code class="cpp hljs">If (cgi.experiments.market_new_functionality) { <span class="hljs-comment"><span class="hljs-comment">// enable new functionality }</span></span></code> </pre> <br>  De nouvelles fonctionnalités sont déployées en production. <br><br>  Il existe un service dédié à l'automatisation des tests A / B, qui est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">décrit</a> en détail <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Une expérience est créée dans le service.  La part du trafic est fixée, par exemple, à 15%.  L'intérêt n'est pas défini pour les demandes, mais pour les utilisateurs.  Le temps de l'expérience, par exemple une semaine, est également indiqué. <br><br>  Plusieurs expériences peuvent être lancées en même temps.  Dans les paramètres, vous pouvez spécifier si l'intersection avec d'autres expériences est possible. <br><br>  Par conséquent, le service ajoute automatiquement l'argument <i>market_new_functionality = 1</i> à 15% des utilisateurs.  Il calcule également automatiquement les métriques sélectionnées.  Après l'expérience, les analystes examinent les résultats et tirent des conclusions.  Sur la base des résultats, une décision est prise de déployer en production ou en raffinement. <br><br><h2>  Agilité du marché: tests de production </h2><br>  Il arrive souvent qu'il soit nécessaire de vérifier le fonctionnement de nouvelles fonctionnalités en production, mais il n'y a aucune certitude sur la manière dont elles se comporteront dans des conditions de «combat» sous forte charge. <br><br>  Il existe une solution: les indicateurs des paramètres CGI peuvent être utilisés non seulement pour les tests A / B, mais également pour tester de nouvelles fonctionnalités. <br><br>  Nous avons créé un outil qui vous permet de modifier instantanément la configuration sur des milliers de serveurs sans exposer le service à des risques.  Cela s'appelle "Stop Crane".  L'idée originale était la possibilité de désactiver rapidement certaines fonctionnalités sans mise en page.  Ensuite, l'outil s'est développé et est devenu plus complexe. <br><br>  Le schéma du service est présenté ci-dessous: <br><br><img src="https://habrastorage.org/webt/va/la/n8/valan8guj5dkld2j788pw7ytbwy.jpeg"><br><br>  L'API définit des valeurs d'indicateur.  Le service de gestion stocke ces valeurs dans une base de données.  Tous les serveurs accèdent à la base de données toutes les dix secondes, pompent les valeurs des indicateurs et appliquent ces valeurs à chaque demande. <br><br>  Dans Stop Crane, vous pouvez définir deux types de valeurs: <br><br>  1) Expressions conditionnelles.  Appliquer lorsque l'une des valeurs est exécutée.  Par exemple: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>:<span class="hljs-string"><span class="hljs-string">"IS_DC1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>:<span class="hljs-string"><span class="hljs-string">"3"</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>: <span class="hljs-string"><span class="hljs-string">"CLUSTER==2 and IS_BERU"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"4!"</span></span> }</code> </pre> <br>  La valeur «3» sera appliquée lorsque la demande sera traitée dans l'emplacement DC1.  Et la valeur est «4» lorsque la demande est traitée sur le deuxième cluster pour le site beru.ru. <br><br>  2) Valeurs inconditionnelles.  Ils sont utilisés par défaut si aucune des conditions n'est remplie.  Par exemple: <br><br>  <i>valeur, valeur!</i> <br><br>  Si la valeur se termine par un point d'exclamation, elle reçoit une priorité plus élevée. <br><br>  L'analyseur des paramètres CGI analyse l'URL.  Applique ensuite les valeurs du robinet d'arrêt. <br><br>  Les valeurs avec les priorités suivantes s'appliquent: <br><br><ol><li>  Priorité plus élevée à l'arrêt du robinet (point d'exclamation). </li><li>  La valeur de la requête. </li><li>  La valeur par défaut provient du robinet d'arrêt. </li><li>  La valeur par défaut dans le code. </li></ol><br>  Il y a beaucoup de drapeaux qui sont indiqués dans des valeurs conditionnelles - ils sont suffisants pour tous les scénarios que nous connaissons: <br><br><ul><li>  Centre de données. </li><li>  Environnement: production, tests, ombre. </li><li>  Lieu: marché, beru. </li><li>  Numéro de cluster. </li></ul><br>  Avec cet outil, vous pouvez activer de nouvelles fonctionnalités sur un groupe de serveurs (par exemple, uniquement dans un centre de données) et tester la fonctionnalité de cette fonctionnalité sans risque particulier pour l'ensemble du service.  Même si vous avez fait une grave erreur quelque part, tout a commencé à tomber et tout le centre de données a baissé, les équilibreurs redirigeront les demandes vers un autre centre de données.  Les utilisateurs finaux ne remarqueront rien. <br><br>  Si vous remarquez un problème, vous pouvez immédiatement renvoyer la valeur précédente de l'indicateur et les modifications seront annulées. <br><br>  Ce service a ses inconvénients: les développeurs l'aiment beaucoup et essaient souvent de pousser tous les changements dans le Stop Crane.  Nous essayons de lutter contre les abus. <br><br>  L'approche Stop Crane fonctionne bien lorsque vous disposez déjà d'un code stable, prêt à être déployé en production.  Dans le même temps, vous avez encore des doutes et vous souhaitez vérifier le code dans des conditions de "combat". <br><br>  Cependant, le robinet d'arrêt n'est pas adapté aux tests pendant le développement.  Pour les développeurs, il existe un cluster séparé appelé «cluster virtuel». <br><br><h2>  Test secret: cluster fantôme </h2><br>  Les demandes de l'un des clusters sont dupliquées sur le cluster reflet.  Mais l'équilibreur ignore complètement les réponses de ce cluster.  Le schéma de son travail est présenté ci-dessous. <br><br><img src="https://habrastorage.org/webt/ie/xt/dp/iextdpgmvcam7ehqatcbwdjyjxe.jpeg"><br><br>  Nous obtenons un cluster de test qui est en conditions réelles de «combat».  Le trafic normal des utilisateurs y circule.  Le matériel des deux clusters est le même, vous pouvez donc comparer les performances et les erreurs. <br><br>  Et puisque l'équilibreur ignore complètement les réponses, les utilisateurs finaux ne verront pas les réponses du cluster fantôme.  Par conséquent, il n'est pas effrayant de se tromper. <br><br><h2>  Conclusions </h2><br>  Alors, comment avons-nous construit une recherche de marché? <br><br>  Pour que tout se passe bien, nous séparons la fonctionnalité en services distincts.  Vous ne pouvez donc mettre à l'échelle que les composants dont nous avons besoin et simplifier les composants.  Il est facile de donner un composant séparé à une autre équipe et de partager les responsabilités pour y travailler.  Et des économies importantes de fer avec cette approche sont un avantage évident. <br><br>  Le cluster virtuel nous aide également: vous pouvez développer des services, les tester dans le processus et en même temps ne pas déranger l'utilisateur. <br><br>  Eh bien et vérifiez la production, bien sûr.  Besoin de changer la configuration sur mille serveurs?  Facile, utilisez une grue d'arrêt.  Ainsi, vous pouvez immédiatement déployer une solution complexe prête à l'emploi et revenir à une version stable en cas de problème. <br><br>  J'espère avoir pu montrer comment nous rendons le marché rapide et stable avec une base d'offres toujours croissante.  Comment résoudre les problèmes de serveur, traiter un grand nombre de demandes, améliorer la flexibilité des services et le faire sans interrompre les processus de travail. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475848/">https://habr.com/ru/post/fr475848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475830/index.html">Console rétro portable à faire soi-même</a></li>
<li><a href="../fr475832/index.html">Les expressions multimédias CSS ont une largeur supérieure à la largeur maximale</a></li>
<li><a href="../fr475834/index.html">Scrum ne vous aidera pas. Nous comprenons pourquoi</a></li>
<li><a href="../fr475838/index.html">CHANGER les gens. Ou ... changer les gens. Comment «décoller» le projet de transformation</a></li>
<li><a href="../fr475842/index.html">Remplacer l'URL d'action et l'URI dans les téléphones SIP ou gérer via des sockets Web?</a></li>
<li><a href="../fr475850/index.html">Comment commencer à construire une carrière dans l'informatique, si vous n'avez pas encore d'expérience</a></li>
<li><a href="../fr475854/index.html">Pools JDBC et gestion efficace des fichiers: Java mitap le 3 décembre à Saint-Pétersbourg</a></li>
<li><a href="../fr475856/index.html">Google App Script, Mikrotik, Telegram et VPNBook ont ​​commencé à jouer un quatuor</a></li>
<li><a href="../fr475858/index.html">Divertir la crypto-énergie: la chaleur de l'exploitation minière pour les humains et la chaleur des humains pour l'exploitation minière</a></li>
<li><a href="../fr475860/index.html">Apache NiFi. 28 novembre à la salle de conférence Deworkacy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>