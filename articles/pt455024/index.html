<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📗 🙏🏼 🎺 5 princípios de bom senso para criar aplicativos nativos da nuvem 🚐 😳 👈🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplicativos "baseados em nuvem" (nativos da nuvem) ou apenas "nuvem" são criados especificamente para uso em infraestruturas em nuvem. Geralmente eles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 princípios de bom senso para criar aplicativos nativos da nuvem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/455024/">  Aplicativos "baseados em nuvem" (nativos da nuvem) ou apenas "nuvem" são criados especificamente para uso em infraestruturas em nuvem.  Geralmente eles são criados como um conjunto de microsserviços fracamente acoplados, embalados em contêineres, que, por sua vez, são gerenciados por uma plataforma em nuvem.  Esses aplicativos, por padrão, estão prontos para falhas, o que significa que eles funcionam de forma confiável e escalável, mesmo em caso de falhas graves no nível da infraestrutura.  O outro lado da moeda é o conjunto de restrições (contratos) que a plataforma em nuvem impõe aos aplicativos de contêiner para poder gerenciá-los automaticamente. <br><br><img src="https://habrastorage.org/webt/i4/jg/_8/i4jg_8cdsmt7yazeyaz_e2lclmo.png" width="100%"><br><br>  Conscientes da necessidade e importância de mudar para aplicativos em nuvem, muitas organizações ainda não sabem por onde começar.  Nesta publicação, consideraremos vários princípios, conformidade com os quais, durante o desenvolvimento de aplicativos de contêiner, perceberemos o potencial das plataformas em nuvem e obteremos operação e escalabilidade confiáveis ​​de aplicativos, mesmo em caso de falhas graves no nível da infraestrutura de TI.  O objetivo final dos princípios descritos aqui é aprender a criar aplicativos que podem ser gerenciados automaticamente por plataformas em nuvem como o Kubernetes. <br><a name="habracut"></a><br><h3>  Princípios de design de software </h3><br>  No mundo da programação, os princípios são entendidos como regras bastante gerais que devem ser observadas no desenvolvimento de software.  Eles podem ser usados ​​ao trabalhar com qualquer linguagem de programação.  Cada princípio tem seus próprios objetivos, os modelos e práticas geralmente servem como um instrumento para sua conquista.  Há também vários princípios fundamentais para a criação de software de alta qualidade, dos quais todos os outros seguem.  Aqui estão alguns exemplos de princípios fundamentais: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BEIJO</a> (Seja simples, estúpido) - não complique; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SECA</a> (não se repita) - não repita; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YAGNI</a> (Você não vai precisar disso) - não crie algo em que não haja necessidade imediata; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SoC</a> (Separação de preocupações) - para compartilhar responsabilidades. </li></ul><br>  Como você pode ver, esses princípios não estabelecem regras específicas, mas pertencem à categoria das chamadas considerações de senso comum, com base na experiência prática compartilhada por muitos desenvolvedores e à qual eles se referem regularmente. <br>  Além disso, há o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SOLID</a> - um conjunto dos cinco primeiros princípios de programação e design orientado a objetos, formulado por Robert Martin.  O SOLID inclui princípios mutuamente complementares, generalizados e abertos à interpretação, os quais - quando aplicados em conjunto - ajudam a criar melhores sistemas de software e a melhor suporte a longo prazo. <br><br>  Os princípios do SOLID se aplicam ao POO e são formulados em termos de conceitos e conceitos como classes, interfaces e herança.  Por analogia, para aplicativos em nuvem, você também pode formular os princípios de desenvolvimento, apenas o elemento básico aqui não será uma classe, mas um contêiner.  Seguindo esses princípios, você pode criar aplicativos em contêiner que atendam melhor às metas e objetivos de plataformas em nuvem como o Kubernetes. <br><br><h3>  Contêineres baseados em nuvem: abordagem da Red Hat </h3><br>  Hoje, quase qualquer aplicativo é relativamente fácil de embalar em contêineres.  Porém, para que os aplicativos sejam automatizados e orquestrados com eficiência em uma plataforma em nuvem como o Kubernetes, é necessário um esforço extra. <br>  As idéias apresentadas abaixo foram baseadas na metodologia do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Twelve-Factor App</a> e em muitos outros trabalhos sobre vários aspectos da criação de aplicativos da Web, do controle de origem aos modelos em escala.  Os princípios descritos se aplicam apenas ao desenvolvimento de aplicativos de contêiner criados com base em microsserviços e projetados para plataformas em nuvem como o Kubernetes.  O elemento básico em nossa discussão é a imagem do contêiner, e o tempo de execução do contêiner de destino é a plataforma de orquestração do contêiner.  O objetivo dos princípios propostos é criar contêineres para os quais, na maioria das plataformas de orquestração, é possível automatizar tarefas de agendamento (agendamento - escolha de um host para executar a instância do contêiner), dimensionamento e monitoramento.  Os princípios são estabelecidos em ordem aleatória. <br><br><h3>  Princípio da preocupação única (SCP) </h3><br>  Esse princípio é, em muitos aspectos, semelhante ao Princípio de responsabilidade única ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SRP</a> ), que faz parte do conjunto SOLID e afirma que cada objeto deve ter uma responsabilidade e que essa responsabilidade deve ser totalmente encapsulada na classe.  A essência do SRP é que cada dever é um motivo de mudança, e uma classe deve ter um e apenas um motivo de mudança. <br><br>  No SCP, em vez da palavra "responsabilidade", usamos a palavra "preocupação" para indicar um nível mais alto de abstração e um objetivo mais amplo do contêiner em comparação com a classe OOP.  E se o objetivo do SRP é ter apenas um motivo para a mudança, o SCP deseja expandir as possibilidades de reutilizar e substituir contêineres.  Ao seguir o SRP e criar um contêiner que resolve uma única tarefa e a conclui funcionalmente, você aumenta as chances de reutilizar a imagem desse contêiner em vários contextos de aplicativos. <br><br>  O princípio do SCP afirma que cada contêiner deve resolver uma única tarefa e fazê-lo bem.  Além disso, o SCP no mundo dos contêineres é alcançado mais facilmente do que o SRP no mundo da OOP, porque os contêineres geralmente executam um único processo e, na maioria das vezes, esse processo resolve uma única tarefa. <br><br>  Se um microsserviço de contêiner precisar resolver vários problemas ao mesmo tempo, ele poderá ser dividido em contêineres de tarefa única e mesclados em um pod (unidades de implantação da plataforma de contêiner) usando modelos de side-car e contêineres init  Além disso, o SCP facilita a substituição de um contêiner antigo (como um servidor da Web ou um intermediário de mensagens) por um novo que resolva o mesmo problema, mas possui funcionalidade aprimorada ou dimensiona melhor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/4j/3o/ud4j3okts2jt7hdfr68-tdjlkw4.png"></div><br><br><h3>  Princípio da conveniência do monitoramento (Princípio da Alta Observabilidade, HOP) </h3><br>  Ao usar contêineres como uma forma unificada de empacotar e iniciar aplicativos, os próprios aplicativos são considerados uma "caixa preta".  No entanto, se esses são contêineres na nuvem, eles devem fornecer ao tempo de execução APIs especiais para monitorar a integridade dos contêineres e tomar as medidas apropriadas, se necessário.  Sem isso, não será possível unificar a automação da atualização de contêineres e gerenciar seu ciclo de vida, o que, por sua vez, piorará a estabilidade e a usabilidade do sistema de software. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/_y/lh/nm_ylhsfix0alpq7uwqmjy8smf0.png"></div><br>  Na prática, um aplicativo de contêiner deve, no mínimo, ter uma API para vários tipos de verificações de saúde: testes de vivacidade e testes de prontidão.  Se o aplicativo alegar ser maior, ele deve fornecer outros meios de monitorar sua condição.  Por exemplo, registrando eventos importantes por meio de STDERR e STDOUT para agregar logs usando Fluentd, Logstash e outras ferramentas semelhantes.  Bem como a integração com bibliotecas de rastreamento e coleção de métricas como OpenTracing, Prometheus, etc. <br><br>  Em geral, o aplicativo ainda pode ser considerado como uma "caixa preta", mas, ao mesmo tempo, deve estar equipado com todas as APIs necessárias à plataforma para monitorá-lo e gerenciá-lo da melhor maneira. <br><br><h3>  Princípio de conformidade do ciclo de vida (LCP) </h3><br>  LCP é a antítese da HOP.  Se o HOP indicar que o contêiner deve fornecer à API APIs para leitura, o LCP exigirá que o aplicativo possa receber informações da plataforma.  Além disso, o contêiner não deve apenas receber eventos, mas também se adaptar, em outras palavras, responder a eles.  Daí o nome do princípio, que pode ser considerado um requisito para fornecer à plataforma APIs para gravação. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bd/3s/p8/bd3sp8v4heoylqg4rzjmk5oiyue.png"></div><br>  As plataformas têm diferentes tipos de eventos que ajudam a gerenciar o ciclo de vida do contêiner.  Mas cabe ao aplicativo decidir qual deles perceber e como responder. <br><br>  É claro que alguns eventos são mais importantes que outros.  Por exemplo, se o aplicativo não tolera o desligamento de emergência, ele deve aceitar as mensagens signal: terminate (SIGTERM) e iniciar seu procedimento de terminação o mais rápido possível para capturar o sinal: kill (SIGKILL) que vem após o SIGTERM. <br><br>  Além disso, eventos como PostStart e PreStop podem ser importantes para o ciclo de vida do aplicativo.  Por exemplo, após iniciar o aplicativo, pode levar algum tempo para "aquecer" antes que ele possa responder às solicitações.  Ou o aplicativo deve, de alguma forma, liberar recursos no desligamento. <br><br><h3>  O princípio da imutabilidade da imagem do recipiente (Princípio da imutabilidade da imagem, IIP) </h3><br>  É geralmente aceito que aplicativos em contêiner devem permanecer inalterados após a montagem, mesmo se executados em ambientes diferentes.  Isso implica na necessidade de externalizar o armazenamento de dados em tempo de execução (em outras palavras, usar ferramentas externas para isso), além de contar com configurações externas configuradas para um ambiente de tempo de execução específico, em vez de modificar ou criar contêineres exclusivos para cada ambiente.  Após qualquer alteração no aplicativo, a imagem do contêiner deve ser remontada e implantada em todos os ambientes utilizados.  A propósito, ao gerenciar sistemas de TI, um princípio semelhante é usado, conhecido como o princípio da imutabilidade de servidores e infraestrutura. <br><br>  O objetivo do IIP é impedir a criação de imagens de contêiner separadas para diferentes ambientes de tempo de execução e usar a mesma imagem em todos os lugares, juntamente com a configuração apropriada para um ambiente específico.  Seguir esse princípio permite implementar práticas importantes do ponto de vista da automação de sistemas em nuvem, como retroceder e avançar as atualizações de aplicativos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hl/rr/t9/hlrrt9r4lw4f7wcik19j3o5zmou.png"></div><br><h3>  Princípio da descartabilidade do processo (PDP) </h3><br>  Uma das características mais importantes de um contêiner é sua efemeridade: uma instância de contêiner é facilmente criada e destruída, para que possa ser facilmente substituída por outra instância a qualquer momento.  Pode haver muitos motivos para essa substituição: falha no teste de integridade, dimensionamento do aplicativo, transferência para outro host, esgotamento dos recursos da plataforma ou outras situações. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/qw/lq/tkqwlqu9-qyusgg6n-wpgl0hxks.png"></div><br>  Como resultado, os aplicativos de contêiner devem manter seu estado usando alguns meios externos ou usar circuitos distribuídos internos com redundância para isso.  Além disso, o aplicativo deve ser iniciado rapidamente e encerrado rapidamente e estar preparado para uma súbita falha fatal de hardware. <br><br>  Uma prática que ajuda a implementar esse princípio é criar pequenos contêineres.  Os ambientes em nuvem podem selecionar automaticamente um host para iniciar uma instância de contêiner; portanto, quanto menor o contêiner, mais rápido ele será iniciado - ele será simplesmente copiado para o host de destino pela rede mais rapidamente. <br><br><h3>  Princípio de autocontenção (S-CP) </h3><br>  De acordo com este princípio, na fase de montagem, todos os componentes necessários são incluídos no recipiente.  O contêiner deve ser construído na expectativa de que o sistema tenha apenas um kernel Linux limpo, para que todas as bibliotecas adicionais necessárias sejam colocadas no próprio contêiner.  Coisas também devem estar localizadas lá, como o tempo de execução da linguagem de programação correspondente, a plataforma do aplicativo (se necessário) e outras dependências que serão necessárias durante a operação do aplicativo de contêiner. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/ia/qb/p7iaqbxksacennpuyk5vvhzdnw4.png"></div><br><br>  Exceções são feitas apenas para configurações que variam de ambiente para ambiente e devem ser fornecidas em tempo de execução, por exemplo, através do Kubernetes ConfigMap. <br><br>  Um aplicativo pode incluir vários componentes em contêiner, por exemplo, um contêiner DBMS separado como parte de um aplicativo de contêiner da web.  De acordo com o princípio S-CP, esses contêineres não devem ser combinados em um, mas feitos para que o contêiner DBMS contenha tudo o necessário para o banco de dados funcionar e o contêiner de aplicativo da web contenha tudo o necessário para o aplicativo da Web funcionar, o mesmo servidor da Web .  Como resultado, no tempo de execução, o contêiner de aplicativo da web dependerá do contêiner do DBMS e o acessará conforme necessário. <br><br><h3>  Princípio de confinamento de tempo de execução (RCP) </h3><br>  O princípio S-CP define como um contêiner deve ser montado e o que um arquivo de imagem binário deve conter.  Mas um contêiner não é apenas uma "caixa preta", que possui apenas uma característica - tamanho do arquivo.  No tempo de execução, o contêiner adquire outras dimensões: a quantidade de memória usada, tempo do processador e outros recursos do sistema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/v5/vb/e5v5vbk3witcr7oe1bgs23forks.png"></div><br>  E aqui o princípio RCP é útil, segundo o qual o contêiner deve decapitar seus requisitos de recursos do sistema e transferi-los para a plataforma.  Com os perfis de recursos de cada contêiner (quantos recursos de CPU, memória, rede e sistema de disco precisam), a plataforma pode otimizar o agendamento e o dimensionamento automático, gerenciar as capacidades de TI e dar suporte aos níveis de SLA para contêineres. <br><br>  Além de atender aos requisitos de recursos do contêiner, também é importante que o aplicativo não ultrapasse a estrutura designada por ele.  Caso contrário, se houver escassez de recursos, é mais provável que a plataforma a inclua na lista de aplicativos que precisam ser interrompidos ou migrados. <br><br>  Falando sobre o foco na nuvem, queremos dizer principalmente a maneira como trabalhamos. <br>  Acima, formulamos vários princípios gerais que estabelecem a base metodológica para a criação de aplicativos de contêineres de alta qualidade para ambientes em nuvem. <br><br>  Observe que, além desses princípios gerais, você também precisará de métodos e técnicas avançadas adicionais para trabalhar com contêineres.  Além disso, temos algumas breves recomendações mais específicas e devem ser aplicadas (ou não aplicadas) dependendo da situação: <br><br><ul><li>  Tente reduzir o tamanho das imagens: exclua arquivos temporários e não coloque pacotes desnecessários - quanto menor o contêiner, mais rápido ele será coletado e copiado para o host de destino na rede. </li><li>  Concentre-se em IDs de usuário arbitrários: não use o comando sudo ou qualquer ID de usuário especial para executar seus contêineres. </li><li>  Rotular portas importantes: os números de porta também podem ser definidos em tempo de execução, mas é melhor especificá-los usando o comando EXPOSE - será mais fácil para outras pessoas e programas usarem suas imagens. </li><li>  Manter dados persistentes nos volumes: os dados que devem permanecer após a destruição do contêiner devem ser gravados nos volumes. </li><li>  Escreva metadados de imagem: tags, rótulos e anotações facilitam o uso de imagens - outros desenvolvedores ficarão agradecidos. </li><li>  Sincronizar o host e as imagens: para alguns aplicativos de contêiner, é necessário sincronizar o contêiner com o host de acordo com certos atributos, como horário ou ID da máquina. </li><li>  Em conclusão, compartilhamos modelos e práticas recomendadas que ajudarão a implementar de maneira mais eficaz os princípios acima: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.slideshare.net/luebken/container-patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.projectatomic.io/container-best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.openshift.com/enterprise/3.0/creating_images/guidelines.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">leanpub.com/k8spatterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">12factor.net</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>Seminário on-line sobre a nova versão do OpenShift Container Platform - 4</b></a> <br>  11 de junho às 11h00 <br><br>  O que você aprenderá: <br><br><ul><li>  Imutável Red Hat Enterprise Linux CoreOS </li><li>  Malha de serviço Openshift </li><li>  Estrutura do operador </li><li>  Quadro Knative </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455024/">https://habr.com/ru/post/pt455024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455010/index.html">Scripts de usuário assíncronos em Rust puro, sem estruturas e SMS</a></li>
<li><a href="../pt455012/index.html">Perguntas frequentes sobre interceptação celular: O que são interceptores IMSI / SCATs e posso protegê-los?</a></li>
<li><a href="../pt455016/index.html">Criamos o site mais inacessível com uma classificação ideal</a></li>
<li><a href="../pt455018/index.html">O post de grande amor para pequenas empresas</a></li>
<li><a href="../pt455022/index.html">Como executar o Scrum com eficiência em 2019? Guia rápido para iniciantes</a></li>
<li><a href="../pt455026/index.html">Telefonia com Snom: para quem trabalha em casa</a></li>
<li><a href="../pt455030/index.html">Especificações PHP</a></li>
<li><a href="../pt455032/index.html">Não é um bug, mas uma característica: um estudo da motilidade e atividade cerebral de uma pessoa com polidactilia</a></li>
<li><a href="../pt455038/index.html">Sobre como o Plesk visitou o KubeCon</a></li>
<li><a href="../pt455048/index.html">Implementação técnica do método de potenciais térmicos para análise de territórios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>