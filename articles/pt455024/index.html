<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“— ğŸ™ğŸ¼ ğŸº 5 princÃ­pios de bom senso para criar aplicativos nativos da nuvem ğŸš ğŸ˜³ ğŸ‘ˆğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aplicativos "baseados em nuvem" (nativos da nuvem) ou apenas "nuvem" sÃ£o criados especificamente para uso em infraestruturas em nuvem. Geralmente eles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 princÃ­pios de bom senso para criar aplicativos nativos da nuvem</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/455024/">  Aplicativos "baseados em nuvem" (nativos da nuvem) ou apenas "nuvem" sÃ£o criados especificamente para uso em infraestruturas em nuvem.  Geralmente eles sÃ£o criados como um conjunto de microsserviÃ§os fracamente acoplados, embalados em contÃªineres, que, por sua vez, sÃ£o gerenciados por uma plataforma em nuvem.  Esses aplicativos, por padrÃ£o, estÃ£o prontos para falhas, o que significa que eles funcionam de forma confiÃ¡vel e escalÃ¡vel, mesmo em caso de falhas graves no nÃ­vel da infraestrutura.  O outro lado da moeda Ã© o conjunto de restriÃ§Ãµes (contratos) que a plataforma em nuvem impÃµe aos aplicativos de contÃªiner para poder gerenciÃ¡-los automaticamente. <br><br><img src="https://habrastorage.org/webt/i4/jg/_8/i4jg_8cdsmt7yazeyaz_e2lclmo.png" width="100%"><br><br>  Conscientes da necessidade e importÃ¢ncia de mudar para aplicativos em nuvem, muitas organizaÃ§Ãµes ainda nÃ£o sabem por onde comeÃ§ar.  Nesta publicaÃ§Ã£o, consideraremos vÃ¡rios princÃ­pios, conformidade com os quais, durante o desenvolvimento de aplicativos de contÃªiner, perceberemos o potencial das plataformas em nuvem e obteremos operaÃ§Ã£o e escalabilidade confiÃ¡veis â€‹â€‹de aplicativos, mesmo em caso de falhas graves no nÃ­vel da infraestrutura de TI.  O objetivo final dos princÃ­pios descritos aqui Ã© aprender a criar aplicativos que podem ser gerenciados automaticamente por plataformas em nuvem como o Kubernetes. <br><a name="habracut"></a><br><h3>  PrincÃ­pios de design de software </h3><br>  No mundo da programaÃ§Ã£o, os princÃ­pios sÃ£o entendidos como regras bastante gerais que devem ser observadas no desenvolvimento de software.  Eles podem ser usados â€‹â€‹ao trabalhar com qualquer linguagem de programaÃ§Ã£o.  Cada princÃ­pio tem seus prÃ³prios objetivos, os modelos e prÃ¡ticas geralmente servem como um instrumento para sua conquista.  HÃ¡ tambÃ©m vÃ¡rios princÃ­pios fundamentais para a criaÃ§Ã£o de software de alta qualidade, dos quais todos os outros seguem.  Aqui estÃ£o alguns exemplos de princÃ­pios fundamentais: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BEIJO</a> (Seja simples, estÃºpido) - nÃ£o complique; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SECA</a> (nÃ£o se repita) - nÃ£o repita; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YAGNI</a> (VocÃª nÃ£o vai precisar disso) - nÃ£o crie algo em que nÃ£o haja necessidade imediata; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SoC</a> (SeparaÃ§Ã£o de preocupaÃ§Ãµes) - para compartilhar responsabilidades. </li></ul><br>  Como vocÃª pode ver, esses princÃ­pios nÃ£o estabelecem regras especÃ­ficas, mas pertencem Ã  categoria das chamadas consideraÃ§Ãµes de senso comum, com base na experiÃªncia prÃ¡tica compartilhada por muitos desenvolvedores e Ã  qual eles se referem regularmente. <br>  AlÃ©m disso, hÃ¡ o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SOLID</a> - um conjunto dos cinco primeiros princÃ­pios de programaÃ§Ã£o e design orientado a objetos, formulado por Robert Martin.  O SOLID inclui princÃ­pios mutuamente complementares, generalizados e abertos Ã  interpretaÃ§Ã£o, os quais - quando aplicados em conjunto - ajudam a criar melhores sistemas de software e a melhor suporte a longo prazo. <br><br>  Os princÃ­pios do SOLID se aplicam ao POO e sÃ£o formulados em termos de conceitos e conceitos como classes, interfaces e heranÃ§a.  Por analogia, para aplicativos em nuvem, vocÃª tambÃ©m pode formular os princÃ­pios de desenvolvimento, apenas o elemento bÃ¡sico aqui nÃ£o serÃ¡ uma classe, mas um contÃªiner.  Seguindo esses princÃ­pios, vocÃª pode criar aplicativos em contÃªiner que atendam melhor Ã s metas e objetivos de plataformas em nuvem como o Kubernetes. <br><br><h3>  ContÃªineres baseados em nuvem: abordagem da Red Hat </h3><br>  Hoje, quase qualquer aplicativo Ã© relativamente fÃ¡cil de embalar em contÃªineres.  PorÃ©m, para que os aplicativos sejam automatizados e orquestrados com eficiÃªncia em uma plataforma em nuvem como o Kubernetes, Ã© necessÃ¡rio um esforÃ§o extra. <br>  As idÃ©ias apresentadas abaixo foram baseadas na metodologia do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The Twelve-Factor App</a> e em muitos outros trabalhos sobre vÃ¡rios aspectos da criaÃ§Ã£o de aplicativos da Web, do controle de origem aos modelos em escala.  Os princÃ­pios descritos se aplicam apenas ao desenvolvimento de aplicativos de contÃªiner criados com base em microsserviÃ§os e projetados para plataformas em nuvem como o Kubernetes.  O elemento bÃ¡sico em nossa discussÃ£o Ã© a imagem do contÃªiner, e o tempo de execuÃ§Ã£o do contÃªiner de destino Ã© a plataforma de orquestraÃ§Ã£o do contÃªiner.  O objetivo dos princÃ­pios propostos Ã© criar contÃªineres para os quais, na maioria das plataformas de orquestraÃ§Ã£o, Ã© possÃ­vel automatizar tarefas de agendamento (agendamento - escolha de um host para executar a instÃ¢ncia do contÃªiner), dimensionamento e monitoramento.  Os princÃ­pios sÃ£o estabelecidos em ordem aleatÃ³ria. <br><br><h3>  PrincÃ­pio da preocupaÃ§Ã£o Ãºnica (SCP) </h3><br>  Esse princÃ­pio Ã©, em muitos aspectos, semelhante ao PrincÃ­pio de responsabilidade Ãºnica ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SRP</a> ), que faz parte do conjunto SOLID e afirma que cada objeto deve ter uma responsabilidade e que essa responsabilidade deve ser totalmente encapsulada na classe.  A essÃªncia do SRP Ã© que cada dever Ã© um motivo de mudanÃ§a, e uma classe deve ter um e apenas um motivo de mudanÃ§a. <br><br>  No SCP, em vez da palavra "responsabilidade", usamos a palavra "preocupaÃ§Ã£o" para indicar um nÃ­vel mais alto de abstraÃ§Ã£o e um objetivo mais amplo do contÃªiner em comparaÃ§Ã£o com a classe OOP.  E se o objetivo do SRP Ã© ter apenas um motivo para a mudanÃ§a, o SCP deseja expandir as possibilidades de reutilizar e substituir contÃªineres.  Ao seguir o SRP e criar um contÃªiner que resolve uma Ãºnica tarefa e a conclui funcionalmente, vocÃª aumenta as chances de reutilizar a imagem desse contÃªiner em vÃ¡rios contextos de aplicativos. <br><br>  O princÃ­pio do SCP afirma que cada contÃªiner deve resolver uma Ãºnica tarefa e fazÃª-lo bem.  AlÃ©m disso, o SCP no mundo dos contÃªineres Ã© alcanÃ§ado mais facilmente do que o SRP no mundo da OOP, porque os contÃªineres geralmente executam um Ãºnico processo e, na maioria das vezes, esse processo resolve uma Ãºnica tarefa. <br><br>  Se um microsserviÃ§o de contÃªiner precisar resolver vÃ¡rios problemas ao mesmo tempo, ele poderÃ¡ ser dividido em contÃªineres de tarefa Ãºnica e mesclados em um pod (unidades de implantaÃ§Ã£o da plataforma de contÃªiner) usando modelos de side-car e contÃªineres init  AlÃ©m disso, o SCP facilita a substituiÃ§Ã£o de um contÃªiner antigo (como um servidor da Web ou um intermediÃ¡rio de mensagens) por um novo que resolva o mesmo problema, mas possui funcionalidade aprimorada ou dimensiona melhor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/4j/3o/ud4j3okts2jt7hdfr68-tdjlkw4.png"></div><br><br><h3>  PrincÃ­pio da conveniÃªncia do monitoramento (PrincÃ­pio da Alta Observabilidade, HOP) </h3><br>  Ao usar contÃªineres como uma forma unificada de empacotar e iniciar aplicativos, os prÃ³prios aplicativos sÃ£o considerados uma "caixa preta".  No entanto, se esses sÃ£o contÃªineres na nuvem, eles devem fornecer ao tempo de execuÃ§Ã£o APIs especiais para monitorar a integridade dos contÃªineres e tomar as medidas apropriadas, se necessÃ¡rio.  Sem isso, nÃ£o serÃ¡ possÃ­vel unificar a automaÃ§Ã£o da atualizaÃ§Ã£o de contÃªineres e gerenciar seu ciclo de vida, o que, por sua vez, piorarÃ¡ a estabilidade e a usabilidade do sistema de software. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/_y/lh/nm_ylhsfix0alpq7uwqmjy8smf0.png"></div><br>  Na prÃ¡tica, um aplicativo de contÃªiner deve, no mÃ­nimo, ter uma API para vÃ¡rios tipos de verificaÃ§Ãµes de saÃºde: testes de vivacidade e testes de prontidÃ£o.  Se o aplicativo alegar ser maior, ele deve fornecer outros meios de monitorar sua condiÃ§Ã£o.  Por exemplo, registrando eventos importantes por meio de STDERR e STDOUT para agregar logs usando Fluentd, Logstash e outras ferramentas semelhantes.  Bem como a integraÃ§Ã£o com bibliotecas de rastreamento e coleÃ§Ã£o de mÃ©tricas como OpenTracing, Prometheus, etc. <br><br>  Em geral, o aplicativo ainda pode ser considerado como uma "caixa preta", mas, ao mesmo tempo, deve estar equipado com todas as APIs necessÃ¡rias Ã  plataforma para monitorÃ¡-lo e gerenciÃ¡-lo da melhor maneira. <br><br><h3>  PrincÃ­pio de conformidade do ciclo de vida (LCP) </h3><br>  LCP Ã© a antÃ­tese da HOP.  Se o HOP indicar que o contÃªiner deve fornecer Ã  API APIs para leitura, o LCP exigirÃ¡ que o aplicativo possa receber informaÃ§Ãµes da plataforma.  AlÃ©m disso, o contÃªiner nÃ£o deve apenas receber eventos, mas tambÃ©m se adaptar, em outras palavras, responder a eles.  DaÃ­ o nome do princÃ­pio, que pode ser considerado um requisito para fornecer Ã  plataforma APIs para gravaÃ§Ã£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bd/3s/p8/bd3sp8v4heoylqg4rzjmk5oiyue.png"></div><br>  As plataformas tÃªm diferentes tipos de eventos que ajudam a gerenciar o ciclo de vida do contÃªiner.  Mas cabe ao aplicativo decidir qual deles perceber e como responder. <br><br>  Ã‰ claro que alguns eventos sÃ£o mais importantes que outros.  Por exemplo, se o aplicativo nÃ£o tolera o desligamento de emergÃªncia, ele deve aceitar as mensagens signal: terminate (SIGTERM) e iniciar seu procedimento de terminaÃ§Ã£o o mais rÃ¡pido possÃ­vel para capturar o sinal: kill (SIGKILL) que vem apÃ³s o SIGTERM. <br><br>  AlÃ©m disso, eventos como PostStart e PreStop podem ser importantes para o ciclo de vida do aplicativo.  Por exemplo, apÃ³s iniciar o aplicativo, pode levar algum tempo para "aquecer" antes que ele possa responder Ã s solicitaÃ§Ãµes.  Ou o aplicativo deve, de alguma forma, liberar recursos no desligamento. <br><br><h3>  O princÃ­pio da imutabilidade da imagem do recipiente (PrincÃ­pio da imutabilidade da imagem, IIP) </h3><br>  Ã‰ geralmente aceito que aplicativos em contÃªiner devem permanecer inalterados apÃ³s a montagem, mesmo se executados em ambientes diferentes.  Isso implica na necessidade de externalizar o armazenamento de dados em tempo de execuÃ§Ã£o (em outras palavras, usar ferramentas externas para isso), alÃ©m de contar com configuraÃ§Ãµes externas configuradas para um ambiente de tempo de execuÃ§Ã£o especÃ­fico, em vez de modificar ou criar contÃªineres exclusivos para cada ambiente.  ApÃ³s qualquer alteraÃ§Ã£o no aplicativo, a imagem do contÃªiner deve ser remontada e implantada em todos os ambientes utilizados.  A propÃ³sito, ao gerenciar sistemas de TI, um princÃ­pio semelhante Ã© usado, conhecido como o princÃ­pio da imutabilidade de servidores e infraestrutura. <br><br>  O objetivo do IIP Ã© impedir a criaÃ§Ã£o de imagens de contÃªiner separadas para diferentes ambientes de tempo de execuÃ§Ã£o e usar a mesma imagem em todos os lugares, juntamente com a configuraÃ§Ã£o apropriada para um ambiente especÃ­fico.  Seguir esse princÃ­pio permite implementar prÃ¡ticas importantes do ponto de vista da automaÃ§Ã£o de sistemas em nuvem, como retroceder e avanÃ§ar as atualizaÃ§Ãµes de aplicativos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hl/rr/t9/hlrrt9r4lw4f7wcik19j3o5zmou.png"></div><br><h3>  PrincÃ­pio da descartabilidade do processo (PDP) </h3><br>  Uma das caracterÃ­sticas mais importantes de um contÃªiner Ã© sua efemeridade: uma instÃ¢ncia de contÃªiner Ã© facilmente criada e destruÃ­da, para que possa ser facilmente substituÃ­da por outra instÃ¢ncia a qualquer momento.  Pode haver muitos motivos para essa substituiÃ§Ã£o: falha no teste de integridade, dimensionamento do aplicativo, transferÃªncia para outro host, esgotamento dos recursos da plataforma ou outras situaÃ§Ãµes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/qw/lq/tkqwlqu9-qyusgg6n-wpgl0hxks.png"></div><br>  Como resultado, os aplicativos de contÃªiner devem manter seu estado usando alguns meios externos ou usar circuitos distribuÃ­dos internos com redundÃ¢ncia para isso.  AlÃ©m disso, o aplicativo deve ser iniciado rapidamente e encerrado rapidamente e estar preparado para uma sÃºbita falha fatal de hardware. <br><br>  Uma prÃ¡tica que ajuda a implementar esse princÃ­pio Ã© criar pequenos contÃªineres.  Os ambientes em nuvem podem selecionar automaticamente um host para iniciar uma instÃ¢ncia de contÃªiner; portanto, quanto menor o contÃªiner, mais rÃ¡pido ele serÃ¡ iniciado - ele serÃ¡ simplesmente copiado para o host de destino pela rede mais rapidamente. <br><br><h3>  PrincÃ­pio de autocontenÃ§Ã£o (S-CP) </h3><br>  De acordo com este princÃ­pio, na fase de montagem, todos os componentes necessÃ¡rios sÃ£o incluÃ­dos no recipiente.  O contÃªiner deve ser construÃ­do na expectativa de que o sistema tenha apenas um kernel Linux limpo, para que todas as bibliotecas adicionais necessÃ¡rias sejam colocadas no prÃ³prio contÃªiner.  Coisas tambÃ©m devem estar localizadas lÃ¡, como o tempo de execuÃ§Ã£o da linguagem de programaÃ§Ã£o correspondente, a plataforma do aplicativo (se necessÃ¡rio) e outras dependÃªncias que serÃ£o necessÃ¡rias durante a operaÃ§Ã£o do aplicativo de contÃªiner. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/ia/qb/p7iaqbxksacennpuyk5vvhzdnw4.png"></div><br><br>  ExceÃ§Ãµes sÃ£o feitas apenas para configuraÃ§Ãµes que variam de ambiente para ambiente e devem ser fornecidas em tempo de execuÃ§Ã£o, por exemplo, atravÃ©s do Kubernetes ConfigMap. <br><br>  Um aplicativo pode incluir vÃ¡rios componentes em contÃªiner, por exemplo, um contÃªiner DBMS separado como parte de um aplicativo de contÃªiner da web.  De acordo com o princÃ­pio S-CP, esses contÃªineres nÃ£o devem ser combinados em um, mas feitos para que o contÃªiner DBMS contenha tudo o necessÃ¡rio para o banco de dados funcionar e o contÃªiner de aplicativo da web contenha tudo o necessÃ¡rio para o aplicativo da Web funcionar, o mesmo servidor da Web .  Como resultado, no tempo de execuÃ§Ã£o, o contÃªiner de aplicativo da web dependerÃ¡ do contÃªiner do DBMS e o acessarÃ¡ conforme necessÃ¡rio. <br><br><h3>  PrincÃ­pio de confinamento de tempo de execuÃ§Ã£o (RCP) </h3><br>  O princÃ­pio S-CP define como um contÃªiner deve ser montado e o que um arquivo de imagem binÃ¡rio deve conter.  Mas um contÃªiner nÃ£o Ã© apenas uma "caixa preta", que possui apenas uma caracterÃ­stica - tamanho do arquivo.  No tempo de execuÃ§Ã£o, o contÃªiner adquire outras dimensÃµes: a quantidade de memÃ³ria usada, tempo do processador e outros recursos do sistema. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/v5/vb/e5v5vbk3witcr7oe1bgs23forks.png"></div><br>  E aqui o princÃ­pio RCP Ã© Ãºtil, segundo o qual o contÃªiner deve decapitar seus requisitos de recursos do sistema e transferi-los para a plataforma.  Com os perfis de recursos de cada contÃªiner (quantos recursos de CPU, memÃ³ria, rede e sistema de disco precisam), a plataforma pode otimizar o agendamento e o dimensionamento automÃ¡tico, gerenciar as capacidades de TI e dar suporte aos nÃ­veis de SLA para contÃªineres. <br><br>  AlÃ©m de atender aos requisitos de recursos do contÃªiner, tambÃ©m Ã© importante que o aplicativo nÃ£o ultrapasse a estrutura designada por ele.  Caso contrÃ¡rio, se houver escassez de recursos, Ã© mais provÃ¡vel que a plataforma a inclua na lista de aplicativos que precisam ser interrompidos ou migrados. <br><br>  Falando sobre o foco na nuvem, queremos dizer principalmente a maneira como trabalhamos. <br>  Acima, formulamos vÃ¡rios princÃ­pios gerais que estabelecem a base metodolÃ³gica para a criaÃ§Ã£o de aplicativos de contÃªineres de alta qualidade para ambientes em nuvem. <br><br>  Observe que, alÃ©m desses princÃ­pios gerais, vocÃª tambÃ©m precisarÃ¡ de mÃ©todos e tÃ©cnicas avanÃ§adas adicionais para trabalhar com contÃªineres.  AlÃ©m disso, temos algumas breves recomendaÃ§Ãµes mais especÃ­ficas e devem ser aplicadas (ou nÃ£o aplicadas) dependendo da situaÃ§Ã£o: <br><br><ul><li>  Tente reduzir o tamanho das imagens: exclua arquivos temporÃ¡rios e nÃ£o coloque pacotes desnecessÃ¡rios - quanto menor o contÃªiner, mais rÃ¡pido ele serÃ¡ coletado e copiado para o host de destino na rede. </li><li>  Concentre-se em IDs de usuÃ¡rio arbitrÃ¡rios: nÃ£o use o comando sudo ou qualquer ID de usuÃ¡rio especial para executar seus contÃªineres. </li><li>  Rotular portas importantes: os nÃºmeros de porta tambÃ©m podem ser definidos em tempo de execuÃ§Ã£o, mas Ã© melhor especificÃ¡-los usando o comando EXPOSE - serÃ¡ mais fÃ¡cil para outras pessoas e programas usarem suas imagens. </li><li>  Manter dados persistentes nos volumes: os dados que devem permanecer apÃ³s a destruiÃ§Ã£o do contÃªiner devem ser gravados nos volumes. </li><li>  Escreva metadados de imagem: tags, rÃ³tulos e anotaÃ§Ãµes facilitam o uso de imagens - outros desenvolvedores ficarÃ£o agradecidos. </li><li>  Sincronizar o host e as imagens: para alguns aplicativos de contÃªiner, Ã© necessÃ¡rio sincronizar o contÃªiner com o host de acordo com certos atributos, como horÃ¡rio ou ID da mÃ¡quina. </li><li>  Em conclusÃ£o, compartilhamos modelos e prÃ¡ticas recomendadas que ajudarÃ£o a implementar de maneira mais eficaz os princÃ­pios acima: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.slideshare.net/luebken/container-patterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.projectatomic.io/container-best-practices</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">docs.openshift.com/enterprise/3.0/creating_images/guidelines.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">leanpub.com/k8spatterns</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">12factor.net</a> </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b>SeminÃ¡rio on-line sobre a nova versÃ£o do OpenShift Container Platform - 4</b></a> <br>  11 de junho Ã s 11h00 <br><br>  O que vocÃª aprenderÃ¡: <br><br><ul><li>  ImutÃ¡vel Red Hat Enterprise Linux CoreOS </li><li>  Malha de serviÃ§o Openshift </li><li>  Estrutura do operador </li><li>  Quadro Knative </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455024/">https://habr.com/ru/post/pt455024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455010/index.html">Scripts de usuÃ¡rio assÃ­ncronos em Rust puro, sem estruturas e SMS</a></li>
<li><a href="../pt455012/index.html">Perguntas frequentes sobre interceptaÃ§Ã£o celular: O que sÃ£o interceptores IMSI / SCATs e posso protegÃª-los?</a></li>
<li><a href="../pt455016/index.html">Criamos o site mais inacessÃ­vel com uma classificaÃ§Ã£o ideal</a></li>
<li><a href="../pt455018/index.html">O post de grande amor para pequenas empresas</a></li>
<li><a href="../pt455022/index.html">Como executar o Scrum com eficiÃªncia em 2019? Guia rÃ¡pido para iniciantes</a></li>
<li><a href="../pt455026/index.html">Telefonia com Snom: para quem trabalha em casa</a></li>
<li><a href="../pt455030/index.html">EspecificaÃ§Ãµes PHP</a></li>
<li><a href="../pt455032/index.html">NÃ£o Ã© um bug, mas uma caracterÃ­stica: um estudo da motilidade e atividade cerebral de uma pessoa com polidactilia</a></li>
<li><a href="../pt455038/index.html">Sobre como o Plesk visitou o KubeCon</a></li>
<li><a href="../pt455048/index.html">ImplementaÃ§Ã£o tÃ©cnica do mÃ©todo de potenciais tÃ©rmicos para anÃ¡lise de territÃ³rios</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>