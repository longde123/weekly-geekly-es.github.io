<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèª ü§º üë©üèø‚Äç‚öñÔ∏è Primeiros passos com o Unicorn Engine ‚èØÔ∏è ‚öúÔ∏è üßîüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ao pesquisar "Unicorn Engine" no Habr, fiquei surpreso ao descobrir que essa ferramenta nunca foi destaque em artigos. Vou tentar preencher esse vazio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Primeiros passos com o Unicorn Engine</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431058/"><p>  Ao pesquisar "Unicorn Engine" no Habr, fiquei surpreso ao descobrir que essa ferramenta nunca foi destaque em artigos.  Vou tentar preencher esse vazio.  Vamos come√ßar com o b√°sico e ver um exemplo de uso do emulador na vida real.  Para n√£o reinventar a roda, decidi simplesmente traduzir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este</a> manual.  <em>Antes de come√ßar, direi que todos os meus coment√°rios ou coment√°rios ficar√£o assim</em> . </p><a name="habracut"></a><br><h1 id="chto-takoe-unicorn-engine">  O que √© um Unicorn Engine? </h1><br><p>  <em>Os pr√≥prios desenvolvedores escrevem sobre</em> <del>  <em>Mecanismo unic√≥rnio</em> </del>  <em>Unicorn Engine assim:</em> </p><br><blockquote>  Unicorn √© um emulador leve, multiplataforma e multi-arquitetura de processador. </blockquote><p>  Este n√£o √© um emulador padr√£o.  N√£o emula a opera√ß√£o de todo o programa ou de todo o sistema operacional.  Ele n√£o suporta comandos do sistema (como abrir um arquivo, enviar um caractere para o console etc.).  Voc√™ ter√° que fazer a marca√ß√£o da mem√≥ria e carregar os dados nela, e ent√£o voc√™ simplesmente inicia a execu√ß√£o a partir de um endere√ßo espec√≠fico. </p><br><p>  Ent√£o, como isso √© √∫til? </p><br><ul><li>  Ao analisar v√≠rus, voc√™ pode chamar fun√ß√µes √∫nicas sem criar um processo malicioso. </li><li>  Para resolver o CTF. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para fuzzing</a> . </li><li>  <a href="">Um plugin para o gdb</a> para prever o estado futuro, por exemplo, saltos futuros ou valores de registro. </li><li>  Emula√ß√£o de um c√≥digo rico em recursos. </li></ul><br><p>  Do que voc√™ precisa? </p><br><ul><li>  Mecanismo Unicorn instalado com liga√ß√£o Python. </li><li>  Desmontador </li></ul><br><h1 id="primer">  Exemplo </h1><br><p>  Como exemplo, fa√ßa uma tarefa com hxp CTF 2017 com o nome <strong><em>Fibonacci</em></strong> .  O bin√°rio pode ser baixado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Quando voc√™ inicia o programa, ele come√ßa a exibir nossa bandeira no console, mas muito lentamente.  Cada byte de flag subsequente √© considerado cada vez mais lento. </p><br><pre><code class="bash hljs">The flag is: hxp{F</code> </pre> <br><p>  Isso significa que, para obter a bandeira em um per√≠odo de tempo razo√°vel, precisamos otimizar a opera√ß√£o desse aplicativo. </p><br><p>  Usando o IDA Pro ( <em>eu pessoalmente usei o radare2 + Cutter</em> ), descompilamos o c√≥digo em um pseudoc√≥digo do tipo C.  Apesar do fato de o c√≥digo n√£o ter sido descompilado corretamente, ainda podemos obter informa√ß√µes sobre o que est√° acontecendo l√° dentro. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo descompilado</b> <div class="spoiler_text"><pre> <code class="cpp hljs">__int64 __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__int64 a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **a3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *v3; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 int v4; // ebx@1 signed __int64 v5; // r8@2 char v6; // r9@3 __int64 v7; // r8@3 char v8; // cl@3 __int64 v9; // r9@5 int a2a; // [sp+Ch] [bp-1Ch]@3 v3 = &amp;encrypted_flag; v4 = 0; setbuf(stdout, 0LL); printf("The flag is: ", 0LL); while ( 1 ) { LODWORD(v5) = 0; do { a2a = 0; fibonacci(v4 + v5, &amp;a2a); v8 = v7; v5 = v7 + 1; } while ( v5 != 8 ); v4 += 8; if ( (unsigned __int8)(a2a &lt;&lt; v8) == v6 ) break; v3 = (char *)v3 + 1; _IO_putc((char)(v6 ^ ((_BYTE)a2a &lt;&lt; v8)), stdout); v9 = *((char *)v3 - 1); } _IO_putc(10, stdout); return 0LL; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">fastcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, _DWORD *a2)</span></span></span><span class="hljs-function"> </span></span>{ _DWORD *v2; <span class="hljs-comment"><span class="hljs-comment">// rbp@1 unsigned int v3; // er12@3 unsigned int result; // eax@3 unsigned int v5; // edx@3 unsigned int v6; // esi@3 unsigned int v7; // edx@4 v2 = a2; if ( i ) { if ( i == 1 ) { result = fibonacci(0, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } else { v3 = fibonacci(i - 2, a2); result = v3 + fibonacci(i - 1, a2); v5 = result - ((result &gt;&gt; 1) &amp; 0x55555555); v6 = ((result - ((result &gt;&gt; 1) &amp; 0x55555555)) &gt;&gt; 2) &amp; 0x33333333; } v7 = v6 + (v5 &amp; 0x33333333) + ((v6 + (v5 &amp; 0x33333333)) &gt;&gt; 4); *v2 ^= ((BYTE1(v7) &amp; 0xF) + (v7 &amp; 0xF) + (unsigned __int8)((((v7 &gt;&gt; 8) &amp; 0xF0F0F) + (v7 &amp; 0xF0F0F0F)) &gt;&gt; 16)) &amp; 1; } else { *a2 ^= 1u; result = 1; } return result; }</span></span></code> </pre> </div></div><br><p>  Aqui est√° o c√≥digo do assembler das fun√ß√µes <em>principais</em> e <em>fibonacci</em> : </p><br><div class="spoiler">  <b class="spoiler_title">principal</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x4004E0 main proc near ; DATA XREF: start+1Do .text:0x4004E0 .text:0x4004E0 var_1C = dword ptr -1Ch .text:0x4004E0 .text:0x4004E0 push rbp .text:0x4004E1 push rbx .text:0x4004E2 xor esi, esi ; buf .text:0x4004E4 mov ebp, offset unk_4007E1 .text:0x4004E9 xor ebx, ebx .text:0x4004EB sub rsp, 18h .text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x4004FB mov edi, offset format ; "The flag is: " .text:0x400500 xor eax, eax .text:0x400502 call _printf .text:0x400507 mov r9d, 49h .text:0x40050D nop dword ptr [rax] .text:0x400510 .text:0x400510 loc_400510: ; CODE XREF: main+8Aj .text:0x400510 xor r8d, r8d .text:0x400513 jmp short loc_40051B .text:0x400513 ; --------------------------------------------------------------------------- .text:0x400515 align 8 .text:0x400518 .text:0x400518 loc_400518: ; CODE XREF: main+67j .text:0x400518 mov r9d, edi .text:0x40051B .text:0x40051B loc_40051B: ; CODE XREF: main+33j .text:0x40051B lea edi, [rbx+r8] .text:0x40051F lea rsi, [rsp+28h+var_1C] .text:0x400524 mov [rsp+28h+var_1C], 0 .text:0x40052C call fibonacci .text:0x400531 mov edi, [rsp+28h+var_1C] .text:0x400535 mov ecx, r8d .text:0x400538 add r8, 1 .text:0x40053C shl edi, cl .text:0x40053E mov eax, edi .text:0x400540 xor edi, r9d .text:0x400543 cmp r8, 8 .text:0x400547 jnz short loc_400518 .text:0x400549 add ebx, 8 .text:0x40054C cmp al, r9b .text:0x40054F mov rsi, cs:stdout ; fp .text:0x400556 jz short loc_400570 .text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc .text:0x400565 movzx r9d, byte ptr [rbp-1] .text:0x40056A jmp short loc_400510 .text:0x40056A ; --------------------------------------------------------------------------- .text:0x40056C align 10h .text:0x400570 .text:0x400570 loc_400570: ; CODE XREF: main+76j .text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc .text:0x40057A add rsp, 18h .text:0x40057E xor eax, eax .text:0x400580 pop rbx .text:0x400581 pop rbp .text:0x400582 retn .text:0x400582 main endp</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">fibonacci</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.text:0x400670 fibonacci proc near ; CODE XREF: main+4Cp .text:0x400670 ; fibonacci+19p ... .text:0x400670 test edi, edi .text:0x400672 push r12 .text:0x400674 push rbp .text:0x400675 mov rbp, rsi .text:0x400678 push rbx .text:0x400679 jz short loc_4006F8 .text:0x40067B cmp edi, 1 .text:0x40067E mov ebx, edi .text:0x400680 jz loc_400710 .text:0x400686 lea edi, [rdi-2] .text:0x400689 call fibonacci .text:0x40068E lea edi, [rbx-1] .text:0x400691 mov r12d, eax .text:0x400694 mov rsi, rbp .text:0x400697 call fibonacci .text:0x40069C add eax, r12d .text:0x40069F mov edx, eax .text:0x4006A1 mov ebx, eax .text:0x4006A3 shr edx, 1 .text:0x4006A5 and edx, 55555555h .text:0x4006AB sub ebx, edx .text:0x4006AD mov ecx, ebx .text:0x4006AF mov edx, ebx .text:0x4006B1 shr ecx, 2 .text:0x4006B4 and ecx, 33333333h .text:0x4006BA mov esi, ecx .text:0x4006BC .text:0x4006BC loc_4006BC: ; CODE XREF: fibonacci+C2j .text:0x4006BC and edx, 33333333h .text:0x4006C2 lea ecx, [rsi+rdx] .text:0x4006C5 mov edx, ecx .text:0x4006C7 shr edx, 4 .text:0x4006CA add edx, ecx .text:0x4006CC mov esi, edx .text:0x4006CE and edx, 0F0F0F0Fh .text:0x4006D4 shr esi, 8 .text:0x4006D7 and esi, 0F0F0Fh .text:0x4006DD lea ecx, [rsi+rdx] .text:0x4006E0 mov edx, ecx .text:0x4006E2 shr edx, 10h .text:0x4006E5 add edx, ecx .text:0x4006E7 and edx, 1 .text:0x4006EA xor [rbp+0], edx .text:0x4006ED pop rbx .text:0x4006EE pop rbp .text:0x4006EF pop r12 .text:0x4006F1 retn .text:0x4006F1 ; --------------------------------------------------------------------------- .text:0x4006F2 align 8 .text:0x4006F8 .text:0x4006F8 loc_4006F8: ; CODE XREF: fibonacci+9j .text:0x4006F8 mov edx, 1 .text:0x4006FD xor [rbp+0], edx .text:0x400700 mov eax, 1 .text:0x400705 pop rbx .text:0x400706 pop rbp .text:0x400707 pop r12 .text:0x400709 retn .text:0x400709 ; --------------------------------------------------------------------------- .text:0x40070A align 10h .text:0x400710 .text:0x400710 loc_400710: ; CODE XREF: fibonacci+10j .text:0x400710 xor edi, edi .text:0x400712 call fibonacci .text:0x400717 mov edx, eax .text:0x400719 mov edi, eax .text:0x40071B shr edx, 1 .text:0x40071D and edx, 55555555h .text:0x400723 sub edi, edx .text:0x400725 mov esi, edi .text:0x400727 mov edx, edi .text:0x400729 shr esi, 2 .text:0x40072C and esi, 33333333h .text:0x400732 jmp short loc_4006BC .text:0x400732 fibonacci endp</code> </pre> </div></div><br><p>  Nesta fase, temos muitas oportunidades para resolver este problema.  Por exemplo, podemos restaurar o c√≥digo usando uma das linguagens de programa√ß√£o e aplicar a otimiza√ß√£o, mas o processo de recupera√ß√£o do c√≥digo √© uma tarefa muito dif√≠cil, durante a qual podemos cometer erros.  Bem, comparar o c√≥digo para encontrar o erro geralmente n√£o vale nada.  Por√©m, se usarmos o Unicorn Engine, podemos pular o est√°gio de reconstru√ß√£o do c√≥digo e evitar o problema descrito acima.  Obviamente, podemos evitar esses problemas usando frida ou escrevendo scripts para o gdb, mas n√£o √© sobre isso. </p><br><p>  Antes de iniciar a otimiza√ß√£o, executaremos a emula√ß√£o no Unicorn Engine sem alterar o programa.  E somente ap√≥s um lan√ßamento bem-sucedido, vamos para a otimiza√ß√£o. </p><br><h2 id="shag-1-da-priydet-virtualizaciya">  Etapa 1: Deixe a virtualiza√ß√£o chegar </h2><br><p>  Vamos criar o arquivo fibonacci.py e salv√°-lo ao lado do bin√°rio. </p><br><p>  Vamos come√ßar importando as bibliotecas necess√°rias: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> unicorn.x86_const <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct</code> </pre> <br><p>  A primeira linha carrega as principais constantes bin√°rias e b√°sicas do unic√≥rnio.  A segunda linha carrega as constantes para as duas arquiteturas x86 e x86_64. </p><br><p>  Em seguida, adicione algumas fun√ß√µes necess√°rias: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(name) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.read() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.unpack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, data)[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> struct.pack(<span class="hljs-string"><span class="hljs-string">"I"</span></span>, num)</code> </pre> <br><p>  Aqui anunciamos as fun√ß√µes que precisaremos posteriormente: </p><br><ul><li>  <strong>read</strong> simplesmente retorna o conte√∫do do arquivo, </li><li>  <strong>O u32</strong> pega uma string de 4 bytes na codifica√ß√£o LE e converte em int, </li><li>  <strong>O p32</strong> faz o oposto - pega um n√∫mero e o transforma em uma sequ√™ncia de 4 bytes na codifica√ß√£o LE. </li></ul><br><p>  Nota: Se voc√™ instalou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pwntools</a> , n√£o precisar√° criar essas fun√ß√µes, basta import√°-las: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre> <br><p>  E ent√£o, finalmente, vamos come√ßar a inicializar nossa classe Unicorn Engine para a arquitetura x86_64: </p><br><pre> <code class="python hljs">mu = Uc (UC_ARCH_X86, UC_MODE_64)</code> </pre> <br><p>  Aqui chamamos as fun√ß√µes <strong>Uc</strong> com os seguintes par√¢metros: </p><br><ul><li>  O primeiro par√¢metro √© a arquitetura principal.  As constantes come√ßam com <strong>UC_ARCH_</strong> ; </li><li>  o segundo par√¢metro √© a especifica√ß√£o da arquitetura.  As constantes come√ßam com <strong>UC_MODE_</strong> . </li></ul><br><p>  Voc√™ pode encontrar todas as constantes na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha de dicas</a> . </p><br><p>  Como escrevi acima, para usar o Unicorn Engine, precisamos inicializar a mem√≥ria virtual manualmente.  Neste exemplo, precisamos colocar o c√≥digo e a pilha em algum lugar da mem√≥ria. </p><br><p>  O endere√ßo base (endere√ßo base) do bin√°rio come√ßa em 0x400000.  Vamos colocar nossa pilha em 0x0 e alocar 1024 * 1024 de mem√≥ria para ela.  Provavelmente, n√£o precisamos de muito espa√ßo, mas ainda n√£o d√≥i. </p><br><p>  Podemos marcar a mem√≥ria chamando o m√©todo <strong>mem_map</strong> . </p><br><p>  Adicione estas linhas: </p><br><pre> <code class="python hljs">BASE = <span class="hljs-number"><span class="hljs-number">0x400000</span></span> STACK_ADDR = <span class="hljs-number"><span class="hljs-number">0x0</span></span> STACK_SIZE = <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span> mu.mem_map(BASE, <span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>) mu.mem_map(STACK_ADDR, STACK_SIZE)</code> </pre> <br><p>  Agora precisamos carregar o bin√°rio em seu endere√ßo principal da mesma maneira que o gerenciador de inicializa√ß√£o.  Depois disso, precisamos definir o <strong>RSP</strong> no final da pilha. </p><br><pre> <code class="python hljs">mu.mem_write(BASE, read(<span class="hljs-string"><span class="hljs-string">"./fibonacci"</span></span>)) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><p>  Agora podemos iniciar a emula√ß√£o e executar o c√≥digo, mas precisamos descobrir com qual endere√ßo come√ßar o trabalho e quando o emulador deve parar. </p><br><p>  Pegue o endere√ßo do primeiro comando em <strong>main ()</strong> , podemos iniciar a emula√ß√£o de 0x004004e0.  O final ser√° considerado uma chamada para <strong>putc ("\ n")</strong> , localizada em 0x00400575, ap√≥s a exibi√ß√£o do sinalizador inteiro. </p><br><pre> <code class="plaintext hljs">.text:0x400570 mov edi, 0Ah ; c .text:0x400575 call __IO_putc</code> </pre> <br><p>  Podemos come√ßar a emular: </p><br><pre> <code class="python hljs">mu.emu_start(<span class="hljs-number"><span class="hljs-number">0x004004e0</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400575</span></span>)</code> </pre> <br><p>  Agora execute o script: </p><br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 32, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  Ops, algo deu errado, mas nem sabemos o qu√™.  Antes de chamar <strong>mu.emu_start,</strong> podemos adicionar: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code)</code> </pre> <br><p>  Este c√≥digo adiciona um gancho.  Declaramos nossa pr√≥pria fun√ß√£o <strong>hook_code</strong> , que √© chamada pelo emulador antes de cada comando.  S√£o necess√°rios os seguintes par√¢metros: </p><br><ul><li>  nossa c√≥pia do <strong>Uc</strong> , </li><li>  endere√ßo de instru√ß√£o </li><li>  instru√ß√µes de tamanho </li><li>  dados do usu√°rio (podemos passar esse valor com um argumento opcional para <strong>hook_add ()</strong> ). <br>  Agora, se executarmos o script, veremos a seguinte sa√≠da: <br><pre> <code class="bash hljs">a@x:~/Desktop/unicorn_engine_lessons$ python solve.py &gt;&gt;&gt; Tracing instruction at 0x4004e0, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e1, instruction size = 0x1 &gt;&gt;&gt; Tracing instruction at 0x4004e2, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004e4, instruction size = 0x5 &gt;&gt;&gt; Tracing instruction at 0x4004e9, instruction size = 0x2 &gt;&gt;&gt; Tracing instruction at 0x4004eb, instruction size = 0x4 &gt;&gt;&gt; Tracing instruction at 0x4004ef, instruction size = 0x7 Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"solve.py"</span></span>, line 41, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; mu.emu_start(0x00000000004004E0, 0x0000000000400575) File <span class="hljs-string"><span class="hljs-string">"/usr/local/lib/python2.7/dist-packages/unicorn/unicorn.py"</span></span>, line 288, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> emu_start raise UcError(status) unicorn.unicorn.UcError: Invalid memory <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> (UC_ERR_READ_UNMAPPED)</code> </pre> <br><p>  No endere√ßo em que ocorreu o erro, podemos entender que nosso script n√£o pode processar este comando: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream</code> </pre> <br><p>  Esta instru√ß√£o l√™ dados do endere√ßo 0x601038 (voc√™ pode v√™-los no IDA Pro).  Esta √© a se√ß√£o <strong>.bss</strong> que n√£o marcamos.  Minha solu√ß√£o seria simplesmente pular todas as instru√ß√µes problem√°ticas se isso n√£o afetar a l√≥gica do programa. <br>  Abaixo est√° outra instru√ß√£o problem√°tica: <br></p><pre> <code class="plaintext hljs">.text:0x4004F6 call _setbuf</code> </pre> <br><p>  N√£o podemos chamar nenhuma fun√ß√£o com o glibc, pois n√£o temos o glibc carregado na mem√≥ria.  De qualquer forma, n√£o precisamos deste comando, portanto tamb√©m podemos ignor√°-lo. <br>  Aqui est√° a lista completa de comandos a serem ignorados: <br></p><pre> <code class="plaintext hljs">.text:0x4004EF mov rdi, cs:stdout ; stream .text:0x4004F6 call _setbuf .text:0x400502 call _printf .text:0x40054F mov rsi, cs:stdout ; fp</code> </pre> <br><p>  Para pular comandos, precisamos reescrever o <strong>RIP</strong> com a seguinte instru√ß√£o: <br></p><pre> <code class="python hljs">mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Agora <strong>hook_code</strong> deve ser algo como isto: </p><br><p></p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">'&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x'</span></span> %(address, size)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size)</code> </pre> <br><p>  Tamb√©m precisamos fazer algo com instru√ß√µes que exibam o sinalizador no console byte a byte. </p><br><pre> <code class="plaintext hljs">.text:0x400558 movsx edi, dil ; c .text:0x40055C add rbp, 1 .text:0x400560 call __IO_putc</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">__IO_putc</a> recebe bytes para sa√≠da como o <strong>primeiro argumento</strong> (este √© o registro <strong>RDI</strong> ). </p><br><p>  Podemos ler dados diretamente do registro, enviar dados para o console e pular este conjunto de instru√ß√µes.  O <strong>hook_code</strong> atualizado √© apresentado abaixo: </p><br><pre> <code class="python hljs">instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu, address, size, user_data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#print('&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: # c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size)</span></span></code> </pre> <br><p>  Podemos correr e tudo vai funcionar, mas ainda lentamente. </p><br><h1 id="shag-2-uvelichim-skorost">  Etapa 2: aumentar a velocidade! </h1><br><p>  Vamos pensar em aumentar a velocidade do trabalho.  Por que esse programa √© t√£o lento? </p><br><p>  Se olharmos para o c√≥digo descompilado, veremos que <strong>main ()</strong> chama <strong>fibonacci ()</strong> v√°rias vezes e <strong>fibonacci ()</strong> √© uma fun√ß√£o recursiva.  Vamos dar uma olhada mais de perto nesta fun√ß√£o, que pega e retorna dois argumentos.  O primeiro valor de retorno √© passado pelo registro <strong>RAX</strong> , o segundo √© retornado pelo link que foi passado pelo segundo argumento para a fun√ß√£o.  Se examinarmos mais profundamente a rela√ß√£o entre <strong>main ()</strong> e <strong>fibonacci ()</strong> , veremos que o segundo argumento usa apenas dois valores poss√≠veis: 0 ou 1. Se voc√™ ainda n√£o v√™ isso, execute <strong>gdb</strong> e coloque um ponto de interrup√ß√£o no in√≠cio da fun√ß√£o <strong>fibonacci ()</strong> . </p><br><p>  Para otimizar a opera√ß√£o do algoritmo, podemos usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a programa√ß√£o din√¢mica</a> para lembrar o valor de retorno dos par√¢metros recebidos.  Pense por si mesmo, o segundo argumento pode ter apenas dois valores poss√≠veis, ent√£o tudo o que precisamos fazer √© lembrar <math> </math> $ inline $ 2 * MAX \ _OF \ _FIRST \ _ARGUMENT $ inline $   vapor </p><br><div class="spoiler">  <b class="spoiler_title">Para quem n√£o entende</b> <div class="spoiler_text"><p>  <strong>fibonacci</strong> √© uma fun√ß√£o recursiva que calcula o pr√≥ximo valor como a soma dos dois anteriores.  A cada passo ela se aprofunda.  Cada vez que ela recome√ßa, segue o mesmo caminho de antes, mais um novo significado. </p><br><p>  Um exemplo: <br>  Suponha profundidade = 6, ent√£o: <strong>1 1 2 3 5 8</strong> . <br>  E agora profundidade = 8, ent√£o: <strong>1 1 2 3 5 8</strong> 13 21. </p><br><p>  Podemos lembrar que os 6 primeiros membros s√£o <strong>1 1 2 3 5 8</strong> e, quando pedem que conte mais do que lembr√°vamos, pegamos o que lembramos e contamos apenas o que est√° faltando. </p></div></div><br><p>  Quando o <strong>RIP</strong> estiver no in√≠cio de <strong>fibonacci ()</strong> , podemos obter os argumentos da fun√ß√£o.  Sabemos que uma fun√ß√£o retorna um resultado quando sai de uma fun√ß√£o.  Como n√£o podemos operar com dois par√¢metros ao mesmo tempo, precisamos de uma pilha para retornar os par√¢metros.  Quando <strong>inserimos fibonacci (),</strong> precisamos colocar os argumentos na pilha e busc√°-los quando sairmos.  Para armazenar os pares contados, podemos usar um dicion√°rio. </p><br><p>  Como processar um par de valores? </p><br><ul><li>  No in√≠cio da fun√ß√£o, podemos verificar se esse par est√° nos resultados que j√° sabemos: <br><ul><li>  se houver, podemos devolver este par.  S√≥ precisamos escrever os valores de retorno em <strong>RAX</strong> e no endere√ßo do link, que est√° no segundo argumento.  Tamb√©m atribu√≠mos um endere√ßo <strong>RIP</strong> para sair da fun√ß√£o.  N√£o podemos usar o <strong>RET</strong> em <strong>fibonacci ()</strong> , j√° que essas chamadas s√£o conectadas, portanto, <strong>pegaremos</strong> um <strong>RET</strong> de <strong>main ()</strong> ; </li><li>  se esses valores n√£o forem, simplesmente os adicionamos √† pilha. </li></ul></li><li>  Antes de sair da fun√ß√£o, podemos salvar o par retornado.  Conhecemos os argumentos de entrada, pois podemos l√™-los em nossa pilha. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Este c√≥digo √© apresentado aqui.</b> <div class="spoiler_text"><pre> <code class="python hljs">FIBONACCI_ENTRY = <span class="hljs-number"><span class="hljs-number">0x00400670</span></span> FIBONACCI_END = [ <span class="hljs-number"><span class="hljs-number">0x004006f1</span></span>, <span class="hljs-number"><span class="hljs-number">0x00400709</span></span>] instructions_skip_list = [<span class="hljs-number"><span class="hljs-number">0x004004ef</span></span>,<span class="hljs-number"><span class="hljs-number">0x004004f6</span></span>,<span class="hljs-number"><span class="hljs-number">0x00400502</span></span>,<span class="hljs-number"><span class="hljs-number">0x0040054f</span></span>] <span class="hljs-comment"><span class="hljs-comment">#     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET ,       fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref)</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Aqui est√° o script inteiro</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding: utf-8 -*- from __future__ import print_function from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack("I", data)[0] def p32(num): return struct.pack("I", num) FIBONACCI_ENTRY = 0x00400670 FIBONACCI_END = [ 0x004006f1, 0x00400709] instructions_skip_list = [0x004004ef,0x004004f6,0x00400502,0x0040054f] #     stack = [] # ,       d = {} def hook_code(mu, address, size, user_data): if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) #      elif address == 0x400560: c = mu.reg_read(UC_X86_REG_RDI) print(chr(c),end="") mu.reg_write(UC_X86_REG_RIP, address+size) #     ? elif address == FIBONACCI_ENTRY: #     RDI arg0 = mu.reg_read(UC_X86_REG_RDI) #    () r_rsi = mu.reg_read(UC_X86_REG_RSI) #   ,    arg1 = u32(mu.mem_read(r_rsi, 4)) # ,    ? if (arg0,arg1) in d: (ret_rax, ret_ref) = d[(arg0,arg1)] #     RAX mu.reg_write(UC_X86_REG_RAX, ret_rax) #     mu.mem_write(r_rsi, p32(ret_ref)) #  RIP  RET .     fibonacci mu.reg_write(UC_X86_REG_RIP, 0x400582) else: #      ,      stack.append((arg0,arg1,r_rsi)) elif address in FIBONACCI_END: #     (arg0, arg1, r_rsi) = stack.pop() #     RAX ret_rax = mu.reg_read(UC_X86_REG_RAX) #  ,      ret_ref = u32(mu.mem_read(r_rsi,4)) #      d[(arg0, arg1)]=(ret_rax, ret_ref) mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read("./fibonacci")) mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x004004e0, 0x00400575) print()</span></span></code> </pre></div></div><br><p>  Hooray, finalmente conseguimos otimizar o aplicativo usando o Unicorn Engine.  Bom trabalho! </p><br><h1 id="zametka">  Uma nota </h1><br><p>  Agora eu decidi fazer um pouco de li√ß√£o de casa. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui voc√™ encontra</a> mais tr√™s tarefas, cada uma com uma dica e uma solu√ß√£o completa.  Voc√™ pode espiar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha de dicas</a> enquanto resolve problemas. </p><br><p>  Um dos problemas mais irritantes √© lembrar o nome da constante desejada.  √â f√°cil lidar com isso se voc√™ usar complementos de tabula√ß√£o no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IPython</a> .  Quando voc√™ tiver o IPython instalado, poder√° escrever <strong>na importa√ß√£o de unic√≥rnio UC_ARCH_ e</strong> pressionar Tab e ser√£o <strong>mostradas</strong> todas as constantes que come√ßam da mesma maneira. </p><p></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt431058/">https://habr.com/ru/post/pt431058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt431046/index.html">Como o z-index realmente funciona</a></li>
<li><a href="../pt431048/index.html">A m√°quina de eventos protege o ciclo de vida</a></li>
<li><a href="../pt431050/index.html">A ilus√£o de pureza: a mineraliza√ß√£o da √°gua afeta sua qualidade e como o medidor TDS nos ajudar√°?</a></li>
<li><a href="../pt431052/index.html">Frontend DevDay: mapas, equipes, duas consultas</a></li>
<li><a href="../pt431056/index.html">USPACE: Hora dos Drones</a></li>
<li><a href="../pt431060/index.html">Falsifica√ß√£o de identidade alem√£ com autentica√ß√£o on-line e financiamento de refugiados na Alemanha</a></li>
<li><a href="../pt431064/index.html">Manifesto de programador r√≠gido</a></li>
<li><a href="../pt431066/index.html">DEFCON 16. Como posso contat√°-lo? Deixe-me listar os caminhos. Parte 2</a></li>
<li><a href="../pt431068/index.html">A arte da educa√ß√£o: a ideologia das m√°quinas ca√ßa-n√≠queis</a></li>
<li><a href="../pt431070/index.html">Hara come? Estamos falando dos h√°bitos alimentares de um especialista em TI moderno</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>