<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèº üåæ ü§õüèæ Mikrokernel seL4. Formale √úberpr√ºfung von Programmen in der realen Welt üåÜ üî≠ üíØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein wissenschaftlicher Artikel wurde in Communications of the ACM , Oktober 2018, Band 61, Nummer 10, S. 68‚Äì77, doi: 10.1145 / 3230627, ver√∂ffentlicht...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mikrokernel seL4. Formale √úberpr√ºfung von Programmen in der realen Welt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437406/">  <font color="gray">Ein wissenschaftlicher Artikel wurde in <i>Communications of the ACM</i> , Oktober 2018, Band 61, Nummer 10, S. 68‚Äì77, doi: 10.1145 / 3230627, ver√∂ffentlicht</font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/549/555/096/549555096952b991fe97a964cd19d97b.jpg" align="left">  Im Februar 2017 startete ein Hubschrauber von der Landebahn der Boeing in Arizona mit der √ºblichen Mission: um die n√§chsten H√ºgel zu fliegen.  Er flog v√∂llig autonom.  Gem√§√ü den Sicherheitsanforderungen der US Federal Aviation Administration hat der Pilot die Bedienelemente nicht ber√ºhrt.  Dies war nicht der erste autonome Flug AH-6, den das Unternehmen als unbemannten kleinen Vogel (ULB) bezeichnet.  Er fliegt seit vielen Jahren so.  Diesmal wurde der Hubschrauber jedoch mitten im Flug einem Cyberangriff ausgesetzt.  Der Bordcomputer griff die sch√§dliche Software des Camcorders sowie den Virus an, der √ºber das infizierte Flash-Laufwerk √ºbertragen wurde, das w√§hrend der Wartung eingesetzt wurde.  Der Angriff bedrohte einige Subsysteme, konnte jedoch den sicheren Betrieb des Flugzeugs nicht beeintr√§chtigen. <br><a name="habracut"></a><br><h1>  Schl√ºsselideen </h1><br><ul><li>  Formale Beweise aus der Softwarearchitektur eines verifizierten Mikrokernels k√∂nnen kosteng√ºnstig auf reale Systeme skaliert werden. </li><li>  Unterschiedliche Sicherheits- und Zuverl√§ssigkeitsniveaus innerhalb desselben Systems sind m√∂glich und w√ºnschenswert.  Es ist nicht erforderlich, die maximale Zuverl√§ssigkeit des gesamten Codes sicherzustellen. </li><li>  Ein moderates Redesign und Refactoring reicht aus, um vorhandene Systeme auf das Niveau eines hochzuverl√§ssigen Codes zu heben. </li></ul><br>  Sie k√∂nnten denken, dass die milit√§rische Luftfahrt einen solchen Cyberangriff leicht abwehren kann.  In Wirklichkeit hat das von der DARPA-Agentur im Rahmen des HACMS-Programms (High Assurance Cyber ‚Äã‚ÄãMilitary Systems) beauftragte Team professioneller Pentester 2013 erfolgreich die erste Version der ULB-Software gehackt, die urspr√ºnglich entwickelt wurde, um Flugsicherheit und nicht Schutz zu gew√§hrleisten von Cyberangriffen.  Hacker hatten die M√∂glichkeit, einen Hubschrauber zum Absturz zu bringen oder ihn an einem beliebigen Ort zu landen.  Daher kann das Risiko solcher Angriffe mit einem Passagier an Bord kaum √ºbersch√§tzt werden, und ein erfolgloser Hacking-Versuch im Februar 2017 weist auf einige grundlegende √Ñnderungen in der Software hin. <br><br>  Dieser Artikel erkl√§rt diese √Ñnderungen und die Technologie, die sie erm√∂glicht hat.  Dies ist eine Technologie, die im Rahmen des HACMS-Programms entwickelt wurde, um den sicheren Betrieb kritischer Systeme in einer feindlichen Cyberumgebung zu gew√§hrleisten - in diesem Fall mehrerer autonomer Fahrzeuge.  Die Technologie basiert auf einer formalen Software√ºberpr√ºfung - dies sind Programme mit automatisch verifizierten mathematischen Beweisen, die gem√§√ü ihren Spezifikationen arbeiten.  Obwohl der Artikel nicht den formalen Methoden selbst gewidmet ist, wird erl√§utert, wie die Artefakt√ºberpr√ºfung zum Schutz realer Systeme in der Praxis verwendet wird. <br><br>  Das vielleicht beeindruckendste Ergebnis von HACMS ist, dass die Technologie auf vorhandene reale Systeme erweitert werden kann, wodurch deren Schutz vor Cyberangriffen erheblich verbessert wird.  Dieser Prozess wird als "Nachr√ºstung der seismischen Sicherheit" bezeichnet, √§hnlich wie bei der Aufr√ºstung seismischer Geb√§ude.  Dar√ºber hinaus wurde der gr√∂√üte Teil des Reengineerings von Boeing-Ingenieuren und nicht von Spezialisten f√ºr formale Verifizierungen durchgef√ºhrt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6f/fbc/1ac/e6ffbc1ac1fb4083ac3961fe43bf8f6e.jpg"><br>  <font color="gray">"Vogel" w√§hrend eines unbemannten Testfluges</font> <br><br>  Nicht jede Hubschraubersoftware basiert auf mathematischen Modellen und Beweisen.  Der Bereich der formalen √úberpr√ºfung ist f√ºr eine solche Skala noch nicht bereit.  Das HACMS-Programm hat jedoch gezeigt, dass die strategische Anwendung formaler Methoden auf die wichtigsten Teile des Gesamtsystems den Schutz erheblich verbessert.  Der HACMS-Ansatz funktioniert f√ºr Systeme, in denen das gew√ºnschte Sicherheitsmerkmal durch reine Durchsetzung auf Architekturebene erreicht werden kann.  Es basiert auf unserem sel4-verifizierten Mikrokernel, √ºber den wir weiter unten sprechen werden.  Es garantiert die Isolation zwischen Subsystemen mit Ausnahme klar definierter Kommunikationskan√§le, die den Sicherheitsrichtlinien des Systems unterliegen.  Diese Isolation wird auf Architekturebene mit dem von CAmkES verifizierten Framework f√ºr Systemkomponenten garantiert.  Verwendung dom√§nenspezifischer Sprachen von Galois Inc.  CAmkES l√§sst sich in Architekturanalysetools von Rockwell Collins und der University of Minnesota sowie in hochzuverl√§ssige Softwarekomponenten integrieren. <br><br>  HACMS-Erfolge basieren auf dem alten treuen Freund eines Software-Ingenieurs - der Modularisierung.  Die Neuerung besteht darin, dass formale Methoden die Beobachtbarkeit von Schnittstellen und die Kapselung von Modulinternalen belegen.  Diese garantierte Einhaltung der Modularit√§t erm√∂glicht es Ingenieuren, die keine Experten f√ºr formale Methoden sind (wie bei Boeing), neue Systeme zu erstellen oder sogar zu modernisieren und eine hohe Stabilit√§t zu erreichen.  Obwohl die Tools noch keinen vollst√§ndigen Nachweis der Systemsicherheit liefern. <br><br><h1>  Formale √úberpr√ºfung </h1><br>  Der Nachweis der mathematischen Korrektheit von Programmen reicht mindestens bis in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die 1960er Jahre zur√ºck</a> , doch lange Zeit waren ihre tats√§chlichen Vorteile f√ºr die Softwareentwicklung in Umfang und Tiefe begrenzt.  In den letzten Jahren gab es jedoch eine Reihe beeindruckender Durchbr√ºche bei der formalen Verifizierung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeebene</a> realer Systeme, vom verifizierten C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompCert-</a> Compiler bis zum verifizierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seL4-</a> Mikrokernel (siehe die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wissenschaftlichen</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> dazu), dem von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoCon</a> verifizierten Konferenzsystem, dem verifizierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CakeML</a> ML-Compiler und verifizierten Programmen Um die Theoreme von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Milawa</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Candle</a> zu beweisen, sind das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FSCQ-</a> verifizierte ausfallsichere Dateisystem, das verifizierte verteilte IronFleet-System und das verifizierte CertiKOS-Parallelkernel- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Framework</a> ebenfalls wichtig  mathematische Theoreme, einschlie√ülich der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Probleme von vier Farben</a> , des automatischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beweises der Kepler-Hypothese</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des Faith-Thompson-Theorems in ungerader Reihenfolge</a> .  All dies sind echte Systeme.  Beispielsweise ist CompCert ein kommerzielles Produkt, der seL4-Mikrokernel wird in der Luft- und Raumfahrt sowie in unbemannten Flugzeugen als Plattform f√ºr das Internet der Dinge verwendet, und das CoCon-System wurde auf zahlreichen gro√üen wissenschaftlichen Konferenzen verwendet. <br><br>  Diese Verifizierungsprojekte erfordern einen erheblichen Aufwand.  Um formale Methoden √∂ffentlich zug√§nglich zu machen, m√ºssen diese Anstrengungen reduziert werden.  Hier zeigen wir, wie eine strategische Kombination aus formalen und informellen Methoden, eine teilweise Automatisierung formaler Methoden und eine sorgf√§ltige Softwareentwicklung zur Maximierung der Vorteile isolierter Komponenten es uns erm√∂glicht haben, die Zuverl√§ssigkeit von Systemen, deren Gesamtgr√∂√üe und Komplexit√§t um Gr√∂√üenordnungen h√∂her sind als die oben genannten, erheblich zu erh√∂hen. <br><br>  Bitte beachten Sie, dass wir die formale √úberpr√ºfung haupts√§chlich f√ºr den Code anwenden, von dem die Sicherheit des Systems abh√§ngt.  Es gibt aber noch andere Vorteile.  Wenn Sie beispielsweise nachweisen, dass der Code korrekt ist, werden Annahmen √ºber den Kontext getroffen, in dem er ausgef√ºhrt wird (z. B. Hardwareverhalten und Softwarekonfiguration).  Durch die formale √úberpr√ºfung werden diese Annahmen explizit, sodass sich Entwickler auf andere √úberpr√ºfungswerkzeuge wie das Testen konzentrieren k√∂nnen.  Dar√ºber hinaus enth√§lt das System in vielen F√§llen sowohl verifizierten als auch nicht verifizierten Code.  W√§hrend der Code√ºberpr√ºfung, des Testens und des Debuggens wirkt die formale √úberpr√ºfung wie eine Linse und konzentriert sich auf kritischen, nicht verifizierten Systemcode. <br><br><h1>  seL4 </h1><br>  Beginnen wir mit der Grundlage f√ºr den Aufbau nachweislich zuverl√§ssiger Systeme - dem Kernel des Betriebssystems (OS).  Dies ist der wichtigste Teil, der die Zuverl√§ssigkeit des gesamten Systems auf kosteng√ºnstige Weise garantiert. <br><br>  Der seL4-Mikrokernel bietet einen formal verifizierten Mindestsatz an Mechanismen zur Implementierung sicherer Systeme.  Im Gegensatz zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardkerneln</a> ist es zweckm√§√üig universell und daher zur Implementierung einer Reihe von Sicherheitsrichtlinien und Systemanforderungen geeignet. <br><br>  Eines der Hauptziele bei der Entwicklung von seL4 ist die Bereitstellung einer starken Isolation zwischen gegenseitig misstrauischen Komponenten, die auf dem Kernel ausgef√ºhrt werden.  Es unterst√ºtzt seine Arbeit als Hypervisor beispielsweise f√ºr ganze Linux-Betriebssysteme und h√§lt sie gleichzeitig von sicherheitskritischen Komponenten isoliert, die zusammenarbeiten k√∂nnen (siehe Abbildung 1). Mit dieser Funktion k√∂nnen Systementwickler insbesondere √§ltere Komponenten mit versteckten Komponenten verwenden Schwachstellen neben hochzuverl√§ssigen Komponenten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8c/e73/dfe/c8ce73dfe32eec8ecbef90268fd802d3.jpg"><br>  <i><font color="gray">Abb.</font></i>  <i><font color="gray">1. Isolation und kontrollierte Kommunikation in seL4</font></i> <br><br>  Der seL4-Kern nimmt unter Allzweck-Mikrokernen eine Sonderstellung ein.  Es bietet nicht nur eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bessere Leistung in seiner Klasse</a> , seine 10.000 Zeilen C-Code wurden einer strengeren formalen √úberpr√ºfung unterzogen als jede andere √∂ffentlich verf√ºgbare Software in der Geschichte der Menschheit, nicht nur hinsichtlich der Beweislinien, sondern auch hinsichtlich der St√§rke der nachgewiesenen Eigenschaften.  Es basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nachweis der ‚Äûfunktionalen Korrektheit‚Äú der Kernimplementierung in C.</a>  Es stellt sicher, dass jedes Verhalten des Kernels durch seine formale abstrakte Spezifikation vorhergesagt wird: In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-Bewerbung finden Sie</a> eine Vorstellung davon, wie diese Beweise aussehen.  Nach dieser Garantie haben wir zus√§tzliche Beweise hinzugef√ºgt, die wir nach Einf√ºhrung in die grundlegenden Mechanismen des Kerns erkl√§ren werden. <br><br><h3>  seL4 API </h3><br>  Der seL4-Kernel bietet nur minimale Mechanismen zur Implementierung sicherer Systeme: Streams, F√§higkeitsmanagement, virtuelle Adressr√§ume, Interprozesskommunikation (IPC), Signalisierung und Interrupt-Zustellung. <br><br>  Der Kernel beh√§lt seinen Status in den "Kernelobjekten".  Beispielsweise gibt es f√ºr jeden Thread im System ein ‚ÄûFlow-Objekt‚Äú, in dem Informationen zu Sheding, Ausf√ºhrung und Zugriffskontrolle gespeichert sind.  User-Space-Programme k√∂nnen nur indirekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber sogenannte "F√§higkeiten"</a> oder "F√§higkeiten" auf Kernel-Objekte verweisen, die eine Verkn√ºpfung zu einem Objekt mit einer Reihe von Zugriffsrechten darauf kombinieren.  Beispielsweise kann ein Thread keinen anderen Thread starten oder stoppen, wenn er nicht √ºber die "F√§higkeit" f√ºr das entsprechende Thread-Objekt verf√ºgt. <br><br>  Threads interagieren und synchronisieren sich, indem sie Nachrichten √ºber ‚ÄûEndpunkte‚Äú der Interprozesskommunikation senden.  Ein Thread mit der F√§higkeit zum Senden an den entsprechenden Endpunkt kann eine Nachricht an einen anderen Thread senden, der die F√§higkeit zum Empfangen an diesen Endpunkt hat.  Benachrichtigungsobjekte bieten eine Synchronisation √ºber S√§tze von bin√§ren Semaphoren hinweg.  Die √úbersetzung virtueller Adressen wird von Kernelobjekten gesteuert, die Seitenverzeichnisse, Seitentabellen und Rahmenobjekte oder subtile Abstraktionen √ºber die entsprechenden Prozessorarchitekturobjekte darstellen.  Jeder Stream verf√ºgt √ºber eine bestimmte VSpace-F√§higkeit, die auf die Wurzel des Baums der Stream-Adress√ºbersetzungsobjekte verweist.  Die Funktionen selbst werden vom Kernel verwaltet und in den Kernelobjekten ‚ÄûCNodes‚Äú in der Struktur des Diagramms gespeichert, die Links zu Objekten mit Zugriffsrechten zuordnen, √§hnlich wie beim Vergleich virtueller Seitentabellen mit physischen Adressen im Speicher.  Jeder Thread hat seine eigene F√§higkeit, den Root-CNode zu identifizieren.  Die Funktionen, die in diesem Stammverzeichnis verf√ºgbar sind, werden als "CSpace Stream" bezeichnet.  F√§higkeiten k√∂nnen √ºber Endpunkte mit Job√ºbertragung √ºbertragen und mithilfe eines gemeinsamen CSpace als gemeinsam genutzt deklariert werden.  Abbildung 2 zeigt diese Kernelobjekte. <br><br> <a href=""><img src="https://habrastorage.org/webt/cy/vr/ea/cyvreajptf3s4kcvgrlj7oyjfw8.png"></a> <br>  <i><font color="gray">Abb.</font></i>  <i><font color="gray">2. Kernelobjekte in einem seL4-System mit zwei Threads, die √ºber einen Endpunkt interagieren</font></i> <br><br><h3>  Sicherheitsnachweise </h3><br>  Aufgrund ihrer Vielseitigkeit sind die seL4-Kernel-APIs auf niedriger Ebene und unterst√ºtzen hochdynamische Systemarchitekturen.  Daher ist es schwierig, direkte Beweise f√ºr diese APIs zu erhalten. <br><br>  Das √ºbergeordnete Konzept der Zugriffssteuerungsrichtlinien abstrahiert von einzelnen Objekten und Kernelfunktionen und erfasst stattdessen die Zugriffssteuerungskonfiguration des Systems mithilfe einer Reihe abstrakter ‚ÄûSubjekte‚Äú (Komponenten) und der Befugnisse, die jeder von ihnen gegen√ºber anderen hat (z. B. zum Lesen von Daten und zum Senden von Nachrichten). .  Im Beispiel in Abb.  In 2 erhielten die Komponenten A und B die Autorit√§t √ºber den Endpunkt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sewell und Kollegen haben</a> bewiesen, dass die seL4-Zugriffssteuerungsrichtlinien sicherstellen, dass zwei grundlegende Sicherheitsfunktionen eingehalten werden: Einschr√§nkung von Berechtigungen und Integrit√§t. <br><br>  Die Einschr√§nkung der Berechtigung bedeutet, dass die Zugriffssteuerungsrichtlinie eine statische (unver√§nderte) sichere Ann√§herung an bestimmte Funktionen und Kernelobjekte im System f√ºr jeden zuk√ºnftigen Status ist.  Diese Eigenschaft impliziert, dass unabh√§ngig von der Entwicklung des Systems keine Komponente jemals mehr Autorit√§t erhalten wird, als die Zugriffssteuerungsrichtlinie vorhersagt.  In Abbildung 2 hat die Richtlinie f√ºr Komponente B keinen Schreibzugriff auf Komponente A. Daher kann Komponente B diesen Zugriff in Zukunft nie mehr erhalten.  Diese Eigenschaft impliziert, dass das Denken auf Richtlinienebene eine sichere Ann√§herung an das Denken √ºber den spezifischen Status der Zugriffskontrolle im System darstellt. <br><br>  Integrit√§t bedeutet, dass die Komponente unabh√§ngig von ihrer T√§tigkeit niemals Daten im System √§ndern kann (einschlie√ülich aller Systemaufrufe, die sie ausf√ºhren kann), sodass die Zugriffssteuerungsrichtlinie eindeutig nicht ge√§ndert werden darf.  Zum Beispiel in Abb.  2 ist die einzige Komponente der Autorit√§t von A √ºber eine andere Komponente das Recht, Daten an den Endpunkt zu senden, von dem Komponente B Informationen empf√§ngt. Dies bedeutet, dass Komponente A nur ihren Status, den Status von Thread B und den Status des Nachrichtenpuffers √§ndern kann.  Es kann keine anderen Teile des Systems √§ndern. <br><br>  Ein Nebeneffekt der Integrit√§t ist die Vertraulichkeit, wenn eine Komponente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht in der Lage ist, Informationen von einer anderen Komponente ohne Erlaubnis zu lesen</a> : Dies ist eine nachgewiesene starke Eigenschaft der nicht-transitiven Nicht-Interferenz von seL4.  Das hei√üt, in einem ordnungsgem√§√ü konfigurierten System (mit strengeren Einschr√§nkungen als nur aus Gr√ºnden der Integrit√§t) kann keine der Komponenten ohne Erlaubnis Informationen √ºber eine andere Komponente oder deren Ausf√ºhrung herausfinden.  Der Proof dr√ºckt diese Eigenschaft in Form der Informationsflussrichtlinie aus, die aus der Zugriffssteuerungsrichtlinie extrahiert werden kann, die f√ºr den Integrit√§tsnachweis verwendet wird.  Informationen werden nur √ºbertragen, wenn dies ausdr√ºcklich durch die Richtlinie gestattet ist.  Der Proof deckt explizite Informationsfl√ºsse sowie potenzielle versteckte Speicherkan√§le im Kernel ab.  Die Synchronisationskan√§le befinden sich jedoch au√üerhalb ihres Bereichs und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">m√ºssen auf andere Weise verarbeitet werden</a> . <br><br>  Ein weiterer Beweis in seL4 ist eine Erweiterung der Funktionskorrektheit und damit der Sicherheitss√§tze auf eine bin√§re Ebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr die ARMv7-Architektur</a> und ein Worst-Case-Laufzeitprofil f√ºr den Kernel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2</a> ), das f√ºr Echtzeitsysteme erforderlich ist.  Der seL4-Kern ist f√ºr verschiedene Architekturen verf√ºgbar: ARMv6, ARMv7, ARMv7a, ARMv8, RISC-V, Intel x86 und Intel x64.  Derzeit wurden Maschinentests f√ºr die ARMv7-Architektur f√ºr den gesamten Verifizierungsstapel sowie f√ºr ARMv7a mit Hypervisor-Erweiterungen f√ºr die Funktionskorrektheit bestanden. <br><br><h1>  Architektur-Sicherheit </h1><br>  Im vorherigen Abschnitt wurden die Programmiermethoden beschrieben, mit denen der seL4-Kernel eine solide Grundlage f√ºr nachweislich zuverl√§ssige Systeme schafft.  Der Kernel bildet eine zuverl√§ssige Computerbasis (TCB) - eine wesentliche Komponente der Software, die f√ºr eine garantierte Systemsicherheit ordnungsgem√§√ü funktionieren muss.  In realen Systemen ist diese Basis viel breiter als nur ein Mikrokernel.  Es ist erforderlich, einen zus√§tzlichen Software-Stack zu √ºberpr√ºfen, um das gleiche Ma√ü an Sicherheit wie f√ºr den Kernel zu erhalten.  Es gibt jedoch Klassen von Systemen, f√ºr die eine solche √úberpr√ºfung nicht erforderlich ist: Sie ben√∂tigen Isolationss√§tze auf Kernelebene, um bestimmte Sicherheitseigenschaften auf Systemebene abzuleiten.  Dieser Abschnitt enth√§lt ein Beispiel f√ºr ein solches System. <br><br>  Dies sind Systeme, in denen Komponentenarchitekturen bereits eine kritische Eigenschaft implementiert haben, m√∂glicherweise zusammen mit mehreren kleinen vertrauensw√ºrdigen Komponenten.  Unser Beispiel ist die Quadcopter-Flugsteuerungssoftware, ein Demoger√§t im zuvor erw√§hnten HACMS-Programm. <br><br>  Abbildung 3 zeigt die wichtigsten Hardwarekomponenten des Quadrocopters.  Die Architektur ist absichtlich komplexer als die vom Quadcopter geforderte, da sie ULB darstellen sollte und auf dieser Abstraktionsebene der Architektur von ULB √§hnelt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f4/a7d/3bd/0f4a7d3bd00cb793457c03e11db9bd08.jpg"><br>  <i><font color="gray">Abb.</font></i>  <i><font color="gray">3. Architektur eines autonomen Flugzeugs</font></i> <br><br>  Die Abbildung zeigt zwei Hauptcomputer: einen Bordcomputer, der mit der Bodenstation kommuniziert und die an Bord befindliche Software (z. B. die Kamera) steuert, und einen Navigationscomputer, der den Flug des Fahrzeugs steuert, Sensordaten liest und Triebwerke steuert.  Computer sind √ºber ein internes Netzwerk oder einen CAN-Bus an einem Quadrocopter und Ethernet an der ULB verbunden.  Der Quadrocopter verf√ºgt au√üerdem √ºber einen ungesch√ºtzten WLAN-Punkt, mit dem zus√§tzliche Schutzmethoden demonstriert werden k√∂nnen. <br><br>  Stellen Sie sich in diesem Beispiel einen Bordcomputer vor.  Daf√ºr m√ºssen vier grundlegende Eigenschaften erf√ºllt sein: <br><br><ul><li>  ordnungsgem√§√üe Authentifizierung von Befehlen von der Bodenstation; <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenschutz von kryptografischen Schl√ºsseln; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keine zus√§tzlichen Nachrichten f√ºr den Navigationscomputer; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unzuverl√§ssige Software von anderen Bordsystemen kann den Flug des Ger√§ts nicht beeintr√§chtigen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Arbeitshypothese lautet, dass die Kamera unzuverl√§ssig, potenziell kompromittiert oder b√∂swillig ist, dass ihre Treiber und veraltete Software potenziell kompromittiert sind sowie externe Kommunikationskan√§le. </font><font style="vertical-align: inherit;">In diesem Beispiel gehen wir von einer korrekten und starken Kryptographie aus, dh, der Schl√ºssel kann nicht abgeholt werden, und wir gehen √ºber den Rahmen der Aufgabe hinaus, die Funkkommunikation des Feindes mit einer Bodenstation zu unterdr√ºcken.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 4 zeigt, wie die Quadrocopter-Architektur diese Eigenschaften bietet. </font><font style="vertical-align: inherit;">Die virtuelle Linux-Maschine (VM) dient als Container f√ºr √§ltere integrierte Ger√§tesoftware, Kameratreiber und WLAN-Hotspots. </font><font style="vertical-align: inherit;">Wir isolieren das Kryptografiesteuerungsmodul in einer eigenen Komponente mit Verbindungen zum CAN-Bus, zum Bodenstationskanal und zur virtuellen Linux-Maschine, um Daten an die Bodenstation zu senden. </font><font style="vertical-align: inherit;">Die Aufgabe der kryptografischen Komponente besteht darin, (nur) autorisierte Nachrichten √ºber die CAN-Schnittstelle des Stapels an den Bordcomputer zu senden und Diagnosedaten an die Bodenstation zur√ºckzusenden. </font><font style="vertical-align: inherit;">Die Funkkomponente sendet und empf√§ngt Rohnachrichten, die von der kryptografischen Komponente verschl√ºsselt und (mit Authentifizierung) entschl√ºsselt werden.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c50/909/098/c5090909891798d51b0af4045fc2d19a.jpg"><br> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. 4. </font><font style="vertical-align: inherit;">Vereinfachte Quadcopter-Bordcomputerarchitektur</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Festlegen der gew√ºnschten Eigenschaften des Systems reduziert sich ausschlie√ülich auf die Eigenschaften der Isolation und das Verhalten der Architektur im Hinblick auf den Informationsfluss sowie auf das Verhalten einer einzelnen vertrauensw√ºrdigen kryptografischen Komponente. Unter der Annahme des korrekten Verhaltens dieser Komponente k√∂nnen die Schl√ºssel nicht gef√§hrdet werden, da keine andere Komponente Zugriff auf sie hat. Der Kanal zwischen Linux und der kryptografischen Komponente in Abb. 4 ist nur f√ºr Nachrichten gedacht und gew√§hrt keinen Zugriff auf den Speicher. Nur autorisierte Nachrichten k√∂nnen in den CAN-Bus gelangen, da die kryptografische Komponente die einzige Kommunikation mit dem Bus ist. Unzuverl√§ssige Software und WLAN sind als Teil der virtuellen Linux-Maschine durch Komponentenisolation gekapselt und k√∂nnen nur √ºber eine vertrauensw√ºrdige kryptografische Komponente mit dem Rest des Systems interagieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist leicht vorstellbar, dass eine solche Analyse der Architektur weitgehend automatisiert werden kann, indem Modelle und Werkzeuge des mechanischen Denkens auf einer h√∂heren Ebene √ºberpr√ºft werden. Wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr MILS-Systeme erw√§hnt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sind die Grenzen von Komponenten in einer solchen Architektur nicht nur ein praktisches Werkzeug f√ºr die Partitionierung und das Code-Management, sondern bieten bei erzwungener Isolation effektive Grenzen f√ºr formale √úberlegungen zum Verhalten des Systems. Es h√§ngt jedoch alles von der richtigen Anwendung der Komponentengrenzen zur Laufzeit in der endg√ºltigen Implementierung des Bin√§rsystems ab.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zuvor diskutierten Mechanismen des seL4-Kernels sind in der Lage, eine solche Implementierung bereitzustellen, aber der Abstraktionsgrad der Mechanismen steht in starkem Kontrast zu den Bl√∂cken und Pfeilen des Architekturschemas: Eine noch abstraktere Zugriffssteuerungsrichtlinie enth√§lt noch viel mehr Details als das Architekturschema. </font><font style="vertical-align: inherit;">In einem realen System dieser Gr√∂√üe werden Zehntausende von Kernelobjekten und ‚ÄûF√§higkeiten‚Äú von der Software erstellt, und Konfigurationsfehler k√∂nnen zu Sicherheitsverletzungen f√ºhren. </font><font style="vertical-align: inherit;">Anschlie√üend diskutieren wir, wie wir nicht nur die Konfiguration und Erstellung eines solchen Codes automatisieren, sondern auch automatisch die Einhaltung der Grenzen der Architektur nachweisen k√∂nnen.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √úberpr√ºfung der Komponentenansicht </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Sicherheitsnachweise durch formale Abstraktionen von Sicherheitsrichtlinien vereinfacht werden, hilft die Abstraktion auch beim Systemdesign. </font><font style="vertical-align: inherit;">Die Komponenten- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camkes-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plattform </font><font style="vertical-align: inherit;">l√§uft auf seL4-Abstraktionen √ºber den Kernelmechanismen auf niedriger Ebene, stellt Kommunikationsprimitive bereit und zerlegt das System in funktionale Einheiten, wie in Abb. 1 dargestellt. </font><font style="vertical-align: inherit;">5. Mithilfe dieser Plattform k√∂nnen Systemarchitekten Systeme auf der Basis von seL4 in Bezug auf √ºbergeordnete Komponenten entwerfen und erstellen, die √ºber Konnektoren wie Remote Procedure Calls (RPC), Datenports und Ereignisse miteinander und mit Hardwareger√§ten interagieren.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/887/212/48b/88721248b5536a3f3b80501ba3a11d1c.jpg"><br>  <i><font color="gray">Abb.</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. CAmkES-Workflow</font></font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Codegenerierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intern implementiert CAmkES diese Abstraktionen mithilfe von Kernelobjekten auf niedriger Ebene in seL4. Jede Komponente enth√§lt (mindestens) einen Stream, CSpace und VSpace. RPC-Konnektoren verwenden Endpunktobjekte, und CAmkES generiert Zwischencode, um Nachrichten zu verarbeiten und an IPC-Endpunkte zu senden. In √§hnlicher Weise wird der Datenport-Konnektor √ºber einen gemeinsam genutzten Speicher implementiert - gemeinsame Rahmen, die in den Adressr√§umen zweier Komponenten vorhanden sind - und kann optional die Richtung der Daten√ºbertragung begrenzen. Schlie√ülich wird der Ereignis-Connector mithilfe des seL4-Benachrichtigungsmechanismus implementiert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CAmkES generiert in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capDL auch eine</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Low-Level-Spezifikation der Erstkonfiguration von Objekten und der Funktionen des Kernels des Systems. Diese Spezifikation wird in den seL4-Initialisierer eingegeben, der</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es startet zuerst nach dem Laden und f√ºhrt die erforderlichen seL4-Operationen aus, um eine Instanz zu erstellen und das System zu initialisieren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit generiert die Komponentenplattform Code ohne zus√§tzlichen Aufwand seitens des Entwicklers. </font><font style="vertical-align: inherit;">Die Komponentenarchitektur beschreibt eine Reihe von Bl√∂cken und Pfeilen, und die Implementierungsaufgabe besteht darin, einfach die Felder auszuf√ºllen. </font><font style="vertical-align: inherit;">Die Plattform generiert den Rest und stellt die Implementierung der beschriebenen Architektur bereit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf einer Plattform mit herk√∂mmlichen Komponenten erweitert der generierte Code die vertrauensw√ºrdige Computerbasis des Systems, da er die Funktionalit√§t der Komponenten beeintr√§chtigen kann. </font><font style="vertical-align: inherit;">CAmkES generiert jedoch auch Beweise.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Automatische Beweise </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Generieren von "Zwischen" -Code erstellt CAmkES formale Beweise in Isabelle / HOL, f√ºhrt eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Validierung w√§hrend der √úbersetzung durch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und zeigt, dass der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generierte "Zwischen" -Code einer √ºbergeordneten Spezifikation entspricht und die generierte capDL-Spezifikation eine korrekte Verfeinerung der CAmkES-Beschreibung ist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir haben auch bewiesen, dass der seL4-Initialisierer das System in der erforderlichen Erstkonfiguration korrekt konfiguriert. Gleichzeitig automatisieren wir den gr√∂√üten Teil des Systemaufbaus, ohne die vertrauensw√ºrdige Computerbasis zu erweitern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwickler befassen sich selten mit der Ausgabe von Codegeneratoren, sie interessieren sich nur f√ºr Funktionalit√§t und Gesch√§ftslogik. </font><font style="vertical-align: inherit;">Wir gehen auch davon aus, dass Beweise f√ºr Zwischencode nicht √ºberpr√ºft werden m√ºssen, dh Entwickler k√∂nnen sich darauf konzentrieren, die Richtigkeit ihres eigenen Codes zu beweisen. </font><font style="vertical-align: inherit;">So wie der generierte CAmkES-Header dem Entwickler eine API f√ºr den generierten Code gibt, erstellen die Lemma-Operatoren der obersten Ebene eine API zum Beweis. </font><font style="vertical-align: inherit;">Lemmas beschreiben das erwartete Verhalten von Steckverbindern. </font><font style="vertical-align: inherit;">Im RPC-Middleware-Beispiel in Abbildung </font><font style="vertical-align: inherit;">6 generierte Funktion</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bietet eine M√∂glichkeit, eine Remote-Funktion aufzurufen</font></font><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in einer anderen Komponente. </font><font style="vertical-align: inherit;">Rufen Sie auf, um die Abstraktion zu speichern</font></font><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> g </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sollte gleichbedeutend mit aufrufen sein</font></font><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> g </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das vom System erzeugte Lemma stellt dies sicher </font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus dem generierten RPC-Code verh√§lt sich wie ein direkter Aufruf</font></font><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> f </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> g </script>  . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61e/b0f/111/61eb0f111ab2d64688c3c42aadaba3ab.jpg"><br>  <i><font color="gray">Abb.</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Generierter RPC-Code</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºr die tats√§chliche Verwendung von vom System generierten Beweisen m√ºssen sie mit (fast) willk√ºrlichen Beweisen, die der Benutzer f√ºr eine Funktion bereitstellt, zusammengesetzt werden k√∂nnen</font></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und f√ºr Kontexte, in denen</font></font><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> g </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.116ex" height="1.817ex" viewBox="0 -520.7 480.5 782.1" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-67" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> g </script>  und <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.279ex" height="2.419ex" viewBox="0 -780.1 550.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/437406/&amp;usg=ALkJrhgV3MC6PvMmkYH0mn8nV9kuzOzseA#MJMATHI-66" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> f </script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um diese Zusammensetzbarkeit zu erreichen, wird die Steckerspezifikation durch vom Benutzer bereitgestellte Spezifikationen f√ºr Remote-Funktionen parametrisiert. Auf diese Weise k√∂nnen Ingenieure √ºber ihre Architektur nachdenken, indem sie Spezifikationen und Nachweise f√ºr ihre Komponenten bereitstellen und sich auf Spezifikationen f√ºr den generierten Code verlassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir diesen Prozess von Anfang bis Ende mit dem speziellen CAmkES RPC-Anschluss ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">demonstriert </font><font style="vertical-align: inherit;">. Da Vorlagen f√ºr andere Konnektoren (Datenports und Ereignisse) viel einfacher als RPCs sind, ist es nicht schwierig, den Beweisgenerator zu erweitern, um diese Konnektoren zu unterst√ºtzen, sodass Sie vielf√§ltigere verifizierte Systeme erstellen k√∂nnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Kommunikationscode erstellt CAmkES die anf√§ngliche Zugriffssteuerungskonfiguration, um die Grenzen der Architektur anzuwenden. Um zu beweisen, dass diese beiden Systembeschreibungen - capDL und CAmkES - miteinander √ºbereinstimmen, betrachten Sie die CAmkES-Beschreibung als Abstraktion f√ºr die capDL-Beschreibung. Wir verwenden das zuvor </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getestete Framework</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Autorit√§t eines Objekts gegen√ºber einem anderen Objekt aus der capDL-Beschreibung abzuleiten. Wir werden also die Beweise auf die Ebene der Politik bringen. Dar√ºber hinaus haben wir in der CAmkES-Beschreibung Regeln f√ºr den Entzug der Berechtigung zwischen Komponenten definiert. Dieser Beweis stellt sicher, dass capDL-Objekte, die als Berechtigungsdiagramm mit nach Komponenten gruppierten Objekten dargestellt werden, </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieselben Grenzen zwischen Gruppen aufweisen wie im entsprechenden CAmkES-Komponentendiagramm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Intuitiv bedeutet diese Entsprechung von Grenzen, dass die Analyse der Richtlinienarchitektur aus der CAmkES-Beschreibung die Richtlinie aus der von capDL generierten Beschreibung speichert, die wiederum garantiert die Anforderungen der Einschr√§nkung der Autorit√§t, Integrit√§t und Vertraulichkeit erf√ºllt, wie bereits erw√§hnt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die korrekte Initialisierung zu beweisen, verwendet CAmkES einen universellen Initialisierer, der als erste Benutzeraufgabe nach dem Laden startet. In seL4 hat diese erste (und eindeutige) Benutzeraufgabe Zugriff auf den gesamten verf√ºgbaren Speicher, um Objekte und ‚ÄûF√§higkeiten‚Äú gem√§√ü der detaillierten Beschreibung von capDL zu erstellen, die sie als Eingabe akzeptiert. Es ist bewiesen, dass</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zustand nach Ausf√ºhrung des Initialisierers erf√ºllt den in der angegebenen Spezifikation beschriebenen Zustand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dieser Beweis gilt f√ºr das genaue Initialisierungsmodell, jedoch noch nicht auf Implementierungsebene. </font><font style="vertical-align: inherit;">Im Vergleich zur Tiefe der restlichen Evidenzkette mag diese Einschr√§nkung schwach erscheinen, es handelt sich jedoch bereits um formellere Evidenz, als dies auf der h√∂chsten Ebene (EAL7) der allgemeinen Sicherheitsbewertungskriterien erforderlich ist.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seismic Security Upgrade </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Praxis ist es aus Sicherheitsgr√ºnden schwierig, die Entwicklung eines Systems von Grund auf sicherzustellen. Daher ist die M√∂glichkeit, alte Software zu aktualisieren, f√ºr die Entwicklung sicherer Systeme von entscheidender Bedeutung. Unser seL4-basiertes Framework unterst√ºtzt einen iterativen Prozess, den wir als "seismische Sicherheitsupgrades" bezeichnen, da ein regul√§rer Architekt vorhandene Geb√§ude f√ºr eine gr√∂√üere seismische Stabilit√§t upgraden wird. Wir veranschaulichen den Prozess am Beispiel einer schrittweisen Anpassung der vorhandenen Softwarearchitektur eines unbemannten Hubschraubers, wobei wir vom traditionellen Testschema zu einem hochzuverl√§ssigen System mit Theoremen √ºbergehen, die durch formale Methoden unterst√ºtzt werden. Obwohl dieses Beispiel auf einem echten ULB-Projekt basiert, wird es hier vereinfacht und enth√§lt nicht alle Details.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die urspr√ºngliche Architektur des Hubschraubers stimmt mit der in Abb. </font><font style="vertical-align: inherit;">3. Seine Funktionalit√§t wird von zwei separaten Computern bereitgestellt: Der Navigationscomputer steuert den tats√§chlichen Flug, und der Bordcomputer f√ºhrt Aufgaben auf hoher Ebene aus (z. B. Kommunikation mit einer Bodenstation und Navigation des Bildes von der Kamera aus). </font><font style="vertical-align: inherit;">Die urspr√ºngliche Version des Bordcomputers war eine monolithische Anwendung f√ºr Linux. </font><font style="vertical-align: inherit;">W√§hrend des Modernisierungsprozesses verwendeten die Boeing-Ingenieure die von HACMS-Partnern bereitgestellten Methoden, Werkzeuge und Komponenten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 1. Virtualisierung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Schritt bestand darin, das System so zu nehmen, wie es ist, und es in einer virtuellen Maschine auf einem sicheren Hypervisor auszuf√ºhren (siehe Abbildung 7). In der Metapher der seismischen Modernisierung entspricht dies einer mobilen Aufstellung des Systems. Eine virtuelle Maschine √ºber seL4 in diesem System besteht aus einer CAmkES-Komponente, zu der ein Virtual Machine Monitor (VMM) und ein Gastbetriebssystem geh√∂ren, in diesem Fall Linux. Der Kernel stellt Virtualisierungshardware-Abstraktionen bereit, und VMM verwaltet diese Abstraktionen f√ºr die virtuelle Maschine. Der seL4-Kernel beschr√§nkt nicht nur das Gastbetriebssystem, sondern auch VMM, sodass Sie der VMM-Implementierung nicht vertrauen m√ºssen, um eine erzwungene Isolation bereitzustellen. Ein VMM-Fehler f√ºhrt zu einem Ausfall des Gastbetriebssystems, jedoch nicht zu einem Ausfall des gesamten Systems.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e55/a43/855/e55a4385528bb6b66ed266100f601341.jpg"><br>  <i><font color="gray">Abb.</font></i> <i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Alle Funktionen in einer virtuellen Maschine</font></font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abh√§ngig von der Systemkonfiguration kann die virtuelle Maschine √ºber paravirtualisierte Treiber, Pass-Through-Treiber oder beides auf Ger√§te zugreifen. </font><font style="vertical-align: inherit;">Bei Pass-Through-Treibern k√∂nnen Entwickler die System-MMU oder -IOMMU verwenden, um eine Verletzung der Isolationsgrenzen durch Hardwareger√§te und Treiber im Gastsystem zu verhindern. </font><font style="vertical-align: inherit;">Beachten Sie, dass das einfache Starten des Systems in einer virtuellen Maschine keine zus√§tzlichen Sicherheits- oder Zuverl√§ssigkeitsvorteile bietet. </font><font style="vertical-align: inherit;">Schritt 1 wird nur ben√∂tigt, um sich auf Schritt 2 vorzubereiten.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 2. Mehrere virtuelle Maschinen </font></font></h3><br>  Der zweite Schritt der seismischen Modernisierung st√§rkt bestehende Mauern.  In der Software kann ein Entwickler die Sicherheit und Zuverl√§ssigkeit erh√∂hen, indem er das Quellsystem in mehrere Subsysteme unterteilt, von denen jedes aus einer virtuellen Maschine besteht, auf der nur ein Teil des Quellsystemcodes ausgef√ºhrt wird.  Jede VM / VMM-Kombination wird in einer separaten CAmkES-Komponente ausgef√ºhrt, die die Isolation zwischen verschiedenen Subsystemen einf√ºhrt, ohne dass diese sich gegenseitig beeinflussen k√∂nnen, und dann die Koexistenz verschiedener Sicherheitsstufen erm√∂glicht. <br><br>  Im Allgemeinen folgen die Abschnitte der vorhandenen Softwarearchitektur. Wenn die Architektur f√ºr eine effektive Isolierung nicht ausreicht, ist m√∂glicherweise eine Neugestaltung erforderlich. <br><br>  In der Regel sollten Abschnitte miteinander interagieren, daher werden an dieser Stelle auch Kommunikationskan√§le hinzugef√ºgt.  Um die Sicherheit zu gew√§hrleisten, m√ºssen diese Schnittstellen unbedingt eng sein, sodass die Verbindung zwischen Partitionen nur auf das absolut Notwendige beschr√§nkt ist.  Dar√ºber hinaus m√ºssen Schnittstellenprotokolle mit einer Mindestanzahl von Nachrichten oder Datenvolumen effizient sein.  Es ist wichtig, dass Sie mit seL4 den Speicheraustausch zwischen Partitionen steuern und begrenzen k√∂nnen, um die Datenmenge zu minimieren. <br><br>  Zus√§tzlich zu den virtuellen Maschinen, die die Subsysteme des Quellsystems darstellen, extrahieren und implementieren wir auch Komponenten f√ºr alle gemeinsam genutzten Ressourcen (z. B. eine Netzwerkschnittstelle). <br><br>  Sie k√∂nnen Schritt 2 wiederholen, bis wir das gew√ºnschte Detail der Abschnitte erreicht haben.  Die korrekte Detaillierung ist ein Kompromiss zwischen der Isolationsfestigkeit einerseits und dem erh√∂hten Kommunikationsaufwand und den Rekonstruktionskosten andererseits. <br><br>  In unserem Beispiel haben wir drei Abschnitte: eine virtuelle Maschine, die die Kommunikationsfunktionen einer Bodenstation unter Linux implementiert;  eine andere virtuelle Maschine, die kamerabasierte Navigationsfunktionen implementiert (auch unter Linux);  und eine native Netzwerkfreigabekomponente, wie in Abb.  8. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a25/bd9/760/a25bd97602571f9b3b485b156767a4ec.jpg"><br>  <i><font color="gray">Abb. 8.</font></i>  <i><font color="gray">Funktionalit√§t in mehrere virtuelle Maschinen unterteilt</font></i> <br><br><h3>  Schritt 3. Native Komponenten </h3><br>  Wenn ein System in separate Abschnitte einer virtuellen Maschine zerlegt wird, k√∂nnen einige oder alle einzelnen Abschnitte als native Komponenten und nicht als virtuelle Maschinen erneut implementiert werden.  Dadurch wird die Angriffsfl√§che bei gleicher Funktionalit√§t erheblich reduziert.  Ein zus√§tzlicher Vorteil der Konvertierung einer Komponente in Maschinencode besteht darin, die Last zu reduzieren und die Produktivit√§t zu steigern, das Gastbetriebssystem zu entfernen und den Aufwand f√ºr die Codeausf√ºhrung und die VMM-Kommunikation zu verringern. <br><br>  Native Komponenten erh√∂hen auch das Potenzial f√ºr die Anwendung formaler Verifizierungen und anderer Methoden, um die Zuverl√§ssigkeit einer Komponente zu erh√∂hen.  Die Optionen sind unterschiedlich: von der vollst√§ndigen Funktions√ºberpr√ºfung des nativen Codes bis zur gemeinsamen Generierung von Code und Beweisen, der Modell√ºberpr√ºfung, der Verwendung typsicherer Programmiersprachen, der statischen Analyse oder dem traditionellen strengen Testen einer kleineren Codebasis. <br><br>  Dank der Isolation von seL4 und der Komponentenarchitektur ist es m√∂glich, in einem System von Komponenten mit unterschiedlichen Zuverl√§ssigkeitsstufen zusammenzuarbeiten.  In diesem Fall verringern Komponenten mit geringer Zuverl√§ssigkeit nicht die allgemeine Zuverl√§ssigkeit des Systems, und Entwickler profitieren von der Tatsache, dass Sie keine Anstrengungen zur √úberpr√ºfung dieses Codes unternehmen m√ºssen. <br><br>  In unserem Beispiel analysieren wir die virtuelle Maschine f√ºr den Kommunikationskanal zwischen dem Bordcomputer und der Bodenstation in native Module.  In den nativen Komponenten sind die Kommunikations-, Kryptographie- und Kontrollfunktionen (Mission-Manager) implementiert.  Wir werden die Kamera und das WLAN in der virtuellen Maschine als unzuverl√§ssige veraltete Komponente belassen (siehe Abb. 9).  Diese Trennung ist zu einem Kompromiss zwischen den Bem√ºhungen um die Neugestaltung von Subsystemen und den Vorteilen der Verwendung nativer Komponenten in Bezug auf Leistung und Zuverl√§ssigkeit geworden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/86b/5fb/f1086b5fbf5aa5bd1c0f8b73e0c2207b.jpg"><br>  <i><font color="gray">Abb.</font></i>  <i><font color="gray">9. In nativen Komponenten implementierte Funktionalit√§t</font></i> <br><br><h3>  Schritt 4. Zuverl√§ssigkeit des Gesamtsystems </h3><br>  Nachdem wir alle erforderlichen Module erhalten haben, machen wir den letzten Schritt: Analyse des gesamten Systems auf der Grundlage der Zuverl√§ssigkeit der Architektur und der einzelnen Komponenten. <br><br>  Im Rahmen von HACMS werden Kommunikation, Kryptographie und ein Steuermodul in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nachweislich typsicheren objektorientierten Sprache Ivory implementiert</a> , wobei eine feste Speichermenge auf dem Heap zugewiesen wird.  Ohne zus√§tzliche √úberpr√ºfung gibt uns Ivory keine Garantie f√ºr die Funktionsrichtigkeit, sondern Vertrauen in Fehlertoleranz und Notfallzuverl√§ssigkeit.  Angesichts der Isolation von Komponenten glauben wir, dass diese Garantien auch bei unzuverl√§ssigen Komponenten (wie der virtuellen Kamera-Maschine) bestehen bleiben. <br><br>  Die Netzwerkkomponente ist in Standard-C-Code implementiert, der aus Benutzercode f√ºr die Plattform und vorhandenem Bibliothekscode besteht.  Sein Zuverl√§ssigkeitsgrad entspricht dem Grad, der durch sorgf√§ltige Implementierung bekannten Codes erreicht wird.  Die Zuverl√§ssigkeit kann ohne gro√üe Kosten verbessert werden, indem Methoden wie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Treibersynthese</a> sowie typsichere Sprachen wie Ivory verwendet werden.  Bei einer allgemeinen Analyse der Systemsicherheit wirkt sich ein Kompromiss einer Netzwerkkomponente nur auf Netzwerkpakete aus.  Da der Datenverkehr verschl√ºsselt ist, gef√§hrdet ein solcher Angriff nicht den Zustand der Spezifikationen, dass nur autorisierte Befehle in den Bordcomputer gelangen. <br><br>  Die virtuelle Maschine des Camcorders ist der schw√§chste Teil des Systems, da sie auf dem Linux-System ausgef√ºhrt wird und Schwachstellen enthalten soll.  Die VM ist jedoch isoliert. Wenn Angreifer sie knacken, k√∂nnen sie nicht zu anderen Komponenten wechseln.  Das Schlimmste, was ein Angreifer tun kann, ist, die falschen Daten an die Steuerungskomponente zu senden.  Wie beim Quadrocopter √ºberpr√ºft diese Komponente die von der Kamera empfangenen Daten.  Und er hat den am Anfang des Artikels erw√§hnten Cyber-Angriff erfolgreich √ºberstanden.  Es war ein ‚ÄûWhite-Box‚Äú -Angriff, bei dem das Pentesters-Team Zugriff auf den gesamten Code und die gesamte Dokumentation sowie auf alle externen Kommunikationskan√§le erhielt.  Sie erhielt absichtlich Root-Zugriff auf die virtuelle Maschine der Kamera, um einen erfolgreichen Angriff auf veraltete Software zu simulieren.  Die Eind√§mmung des Angriffs und die F√§higkeit, sich gegen dieses sehr m√§chtige Szenario zu verteidigen, wurden zu einem w√ºrdigen Test unserer Sicherheitsanforderungen und zur Identifizierung fehlender Annahmen, Schnittstellenprobleme oder anderer Sicherheitsprobleme, die das Forschungsteam m√∂glicherweise nicht erkennt. <br><br><h1>  Einschr√§nkungen und zuk√ºnftige Arbeit </h1><br>  Dieser Artikel bietet einen √úberblick √ºber die Methode zum Erreichen eines sehr hohen Sicherheitsniveaus f√ºr Systeme, in denen die Sicherheitsfunktion √ºber die Komponentenarchitektur anwendbar ist.  Wir haben Theoreme f√ºr die Kernelebene und ihre korrekte Konfiguration sowie Theoreme bewiesen, die gew√§hrleisten, dass die Komponentenplattform die Sicherheitsgrenzen gem√§√ü der Beschreibung ihrer Architektur korrekt festlegt und den richtigen Code f√ºr Remoteprozeduraufrufe generiert.  Die Verbindung mit der Sicherheitsanalyse des Systems auf hoher Ebene bleibt informell, und die Kommunikationscodes√§tze decken nicht alle von der Plattform bereitgestellten Kommunikationsprimitive ab.  Um automatisch einen Satz zu erhalten, der das gesamte System von Anfang bis Ende abdeckt, sind zus√§tzliche Arbeiten erforderlich.  Zum gegenw√§rtigen Zeitpunkt ist jedoch klar, dass dies eine machbare Aufgabe ist. <br><br>  Das Hauptziel der vorgestellten Arbeit ist es, den Verifizierungsaufwand f√ºr bestimmte Systemklassen drastisch zu reduzieren.  Der hier beschriebene rein architektonische Ansatz kann auf andere Systeme als ULB ausgedehnt werden, ist jedoch eindeutig dadurch begrenzt, dass nur Eigenschaften ausgedr√ºckt werden k√∂nnen, die von der Komponentenarchitektur des Systems bestimmt werden.  Die R√ºckgabe verringert sich, wenn sich diese Architektur w√§hrend der Programmausf√ºhrung √§ndert und wenn die Eigenschaften entscheidend vom Verhalten zu vieler vertrauensw√ºrdiger Komponenten oder Komponenten mit zu gro√üer Gr√∂√üe abh√§ngen. <br><br>  Der erste Schritt zur Lockerung dieser Einschr√§nkungen besteht darin, eine Bibliothek vorab getesteter Komponenten mit einem hohen Ma√ü an Zuverl√§ssigkeit zu erstellen, die als zuverl√§ssige Bausteine ‚Äã‚Äãin solchen Architekturen verwendet werden k√∂nnen.  Diese Bibliothek kann Sicherheitsmuster (wie Desinfektion von Eingabedaten, Ausgabefiltern, Datenschutz- und Laufzeitmonitoren) enthalten, die m√∂glicherweise aus √ºbergeordneten Spezifikationen generiert wurden, sowie Infrastrukturkomponenten wie wiederverwendbare Kryptomodule, Schl√ºsselspeicher, Dateisysteme, Hochzuverl√§ssige Netzwerkstacks und Treiber.  Wenn die Sicherheit von mehr als einer solchen Komponente abh√§ngt, muss die Zuverl√§ssigkeit ihrer Interaktion und gemeinsamen Nutzung gerechtfertigt werden.  Die wichtigsten technischen Probleme sind hier Diskussionen √ºber Parallelit√§t und Protokolle sowie den Informationsfluss bei Vorhandensein vertrauensw√ºrdiger Komponenten.  Trotz dieser Einschr√§nkungen zeigt die Arbeit die rasche Entwicklung realer hochzuverl√§ssiger Systeme auf Basis von seL4.  Derzeit ist die Erstellung solcher Systeme zu geringeren Kosten als bei herk√∂mmlichen Tests m√∂glich. <br><br><h1>  Anwendung: Arbeitskosten </h1><br>  Die Entwicklung des Designs und des Codes f√ºr seL4 dauerte zwei Mannjahre.  Wenn wir alle serotypspezifischen Nachweise hinzuf√ºgen, werden f√ºr 8700 Codezeilen f√ºr C insgesamt 18 Personenjahre erhalten. Zum Vergleich: Die Entwicklung eines Mikrokerns L4Ka :: Pistachio vergleichbarer Gr√∂√üe aus der seL4-Familie dauerte sechs Mannjahre und lieferte kein signifikantes Ma√ü an Zuverl√§ssigkeit.  Dies bedeutet einen nur 3,3-fachen Unterschied in der Entwicklungsgeschwindigkeit zwischen verifizierter und herk√∂mmlicher Software.  Nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Bewertungsmethode von Colbert und Bohm</a> dauert die Zertifizierung nach traditionellen EAL7-Kriterien f√ºr 8700 Zeilen C-Code mehr als 45,9 Personenjahre.  Dies bedeutet, dass die formale √úberpr√ºfung der Implementierung auf Bin√§rebene bereits 2,3-mal billiger ist als die h√∂chste Zertifizierungsstufe nach allgemeinen Kriterien und gleichzeitig eine deutlich h√∂here Zuverl√§ssigkeit bietet. <br><br>  Zum Vergleich verwendet der hier beschriebene HACMS-Ansatz nur vorhandene Beweise f√ºr jedes neue System, einschlie√ülich der von den Tools generierten Beweise.  Daher betr√§gt der allgemeine Beweisaufwand f√ºr ein System, das diesem Ansatz entspricht, Mannwochen und nicht Jahre, und Tests werden nur durchgef√ºhrt, um Annahmen zu validieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437406/">https://habr.com/ru/post/de437406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437386/index.html">Interviews - Interviewer Look</a></li>
<li><a href="../de437390/index.html">"Geheimnisse" DPAPI. Schau dir den Esel an</a></li>
<li><a href="../de437396/index.html">Warum wird CarPrice von k√ºnstlicher Intelligenz angetrieben?</a></li>
<li><a href="../de437400/index.html">Die Cloud-Ausgaben √ºbertrafen zum ersten Mal die herk√∂mmlichen Infrastrukturausgaben - was bedeutet das?</a></li>
<li><a href="../de437402/index.html">Wie ich dem Roboter beigebracht habe, auf YouTube-Videos zu laufen</a></li>
<li><a href="../de437408/index.html">802.1x, EX2200, NPS und alles in allem ...</a></li>
<li><a href="../de437410/index.html">Einf√ºhrung in Spring Boot mit Spring Data Mongo</a></li>
<li><a href="../de437414/index.html">Wo in Russland mehr als 20 Millionen Transportkarten gef√§hrdet sind: Wir zerlegen und entwickeln MIFARE Classic</a></li>
<li><a href="../de437416/index.html">Kapazit√§tsmanagement: Das perfekte Gleichgewicht finden</a></li>
<li><a href="../de437418/index.html">Informationen zu Entit√§ten, DTO, ORM und Lazy Load</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>