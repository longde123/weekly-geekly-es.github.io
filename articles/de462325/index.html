<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚮 🤸🏻 🤶🏼 Web Worker einfacher als Sie dachten 👼🏾 🧑🏼‍🤝‍🧑🏻 🗑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird eine schmutzige, unsichere, instabile und beängstigende <em>eval</em> -Methode beschrieben. Wenn Ihnen das unangenehm ist, höre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Web Worker einfacher als Sie dachten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/462325/"><p><img src="https://habrastorage.org/webt/ve/ti/ox/vetioxg-vqohhdt25j7qmzayvww.jpeg" alt="Web Worker einfacher als Sie dachten"></p><br><p> In diesem Artikel wird eine schmutzige, unsichere, instabile und beängstigende <code>&lt;em&gt;eval&lt;/em&gt;</code> -Methode beschrieben.  Wenn Ihnen das unangenehm ist, hören Sie sofort auf zu lesen. </p><br><p>  Zunächst einmal blieben einige Probleme mit der Bequemlichkeit ungelöst: In Code, der an Web-Web-Worker gesendet wird, kann das Schließen nicht verwendet werden. </p><br><hr><br><p>  Wir alle mögen neue Technologien, und wir alle mögen neue Technologien, die bequem zu bedienen sind.  Bei Web-Workern ist dies jedoch nicht genau der Fall.  Web-Worker akzeptieren Dateien oder Links zu Dateien, was nicht bequem ist.  Es wäre gut, wenn Sie Web-Workern jede Aufgabe übertragen könnten, nicht nur speziell geplanten Code. </p><br><p>  Was brauchen wir, um die Bedienung von Web-Mitarbeitern zu vereinfachen?  Ich glaube, es ist das Folgende: </p><br><ul><li>  Eine Möglichkeit, in Web Workern jeden Code jederzeit zu starten </li><li>  Eine Möglichkeit, komplizierte Daten (Klasseninstanzen, Funktionen) an Web-Worker zu senden </li><li>  Eine Möglichkeit, ein Versprechen mit einer Antwort von einem Web-Worker zu erhalten. </li></ul><a name="habracut"></a><br><p>  Versuchen wir es zu schreiben.  Für den Anfang benötigen wir ein Kommunikationsprotokoll zwischen einem Web-Worker und dem Hauptfenster.  Im Allgemeinen ist ein Protokoll nur eine Struktur und ein Datentyp, die für die Kommunikation zwischen einem Browserfenster und einem Web Worker verwendet werden.  Es ist ziemlich einfach.  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies verwenden</a> oder Ihre eigene Version schreiben.  Jede Nachricht hat eine ID und Daten, die für einen bestimmten Nachrichtentyp typisch sind.  Zunächst haben wir zwei Arten von Nachrichten für Web-Worker: </p><br><ul><li>  Hinzufügen von Bibliotheken / Dateien zu einem Web Worker </li><li>  Starten. </li></ul><br><h2 id="a-file-that-will-be-inside-a-web-worker">  Eine Datei, die sich in einem Web Worker befindet </h2><br><p>  Bevor wir einen Web-Worker schreiben, müssen wir eine Datei beschreiben, die sich darin befindet und das oben beschriebene Protokoll unterstützt.  Ich mag objektorientierte Programmierung (OOP), daher wird dies eine Klasse namens workerBody sein.  Diese Klasse muss ein Ereignis aus dem übergeordneten Fenster abonnieren. </p><br><pre> <code class="javascript hljs">self.onmessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMessage(message.data); };</code> </pre><br><p>  Jetzt können wir Ereignisse aus dem übergeordneten Fenster abhören.  Wir haben zwei Arten von Ereignissen: solche, die eine Antwort implizieren, und alles andere.  Lassen Sie uns Ereignisse durchführen: \ <br>  Bibliotheken und Dateien werden einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webworker</a> mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">importScripts-</a> API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugefügt</a> . </p><br><p>  Und jetzt der gruseligste Teil: Zum Starten einer Zufallsfunktion verwenden wir <em>eval</em> . </p><br><pre> <code class="javascript hljs">... onMessage(message) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (message.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.ADD_LIBS: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addLibs(message.libs); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> MESSAGE_TYPE.WORK: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doWork(message); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } doWork(message) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processor = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(message.job); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> params = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parser.parse(message.params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = processor(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result &amp;&amp; result.then &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> result.then === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { result.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: data }); }, (error) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { error = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(error); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: error }); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: result }); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.send({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: message.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }); } } send(data) { data.body = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._serializer.serialize(data.body); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { self.postMessage(data); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> toSet = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: data.id, <span class="hljs-attr"><span class="hljs-attr">state</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(e) }; self.postMessage(toSet); } }</code> </pre> <br><p>  Die Methode <em>onMessage</em> ist für den Empfang einer Nachricht und die Auswahl eines <em>Handlers</em> verantwortlich. <em>DoWork</em> startet eine gesendete Funktion und <em>send</em> sendet eine Antwort an das übergeordnete Fenster. </p><br><h2 id="parser-and-serializer">  Parser und Serializer </h2><br><p>  Nachdem wir den Inhalt des Web-Workers haben, müssen wir lernen, alle Daten zu serialisieren und zu analysieren, damit sie an den Web-Worker gesendet werden können.  Beginnen wir mit einem Serializer.  Wir möchten in der Lage sein, alle Daten, einschließlich Klasseninstanzen, Klassen und Funktionen, an den Web Worker zu senden, während die native Kapazität des Web Workers das Senden nur von JSON-ähnlichen Daten ermöglicht.  Um das zu umgehen, brauchen wir _ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eval</a> _.  Wir werden alle Daten, die JSON nicht akzeptieren kann, in entsprechende Sting-Strukturen verpacken und auf der anderen Seite starten.  Um die Unveränderlichkeit zu erhalten, werden empfangene Daten im laufenden Betrieb geklont und alles, was mit normalen Methoden nicht serialisiert werden kann, durch Serviceobjekte ersetzt, die auf der anderen Seite durch einen Parser ersetzt werden.  Auf den ersten Blick ist diese Aufgabe nicht schwierig, aber es gibt viele Fallstricke.  Die gruseligste Einschränkung dieses Ansatzes ist die Unfähigkeit, Closure zu verwenden, was zu einem etwas anderen Code-Schreibstil führt.  Beginnen wir mit dem einfachsten Teil, der Funktion.  Zuerst müssen wir lernen, eine Funktion von einem Klassenkonstruktor zu unterscheiden.  Lass uns das machen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isFunction(Factory){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Factory.prototype) { <span class="hljs-comment"><span class="hljs-comment">// Arrow function has no prototype return true; } const prototypePropsLength = Object.getOwnPropertyNames(Factory.prototype) .filter(item =&gt; item !== 'constructor') .length; return prototypePropsLength === 0 &amp;&amp; Serializer.getClassParents(Factory).length === 1; } static getClassParents(Factory) { const result = [Factory]; let tmp = Factory; let item = Object.getPrototypeOf(tmp); while (item.prototype) { result.push(item); tmp = item; item = Object.getPrototypeOf(tmp); } return result.reverse(); }</span></span></code> </pre><br><p>  Zuerst prüfen wir, ob die Funktion einen Prototyp hat.  Wenn nicht, ist dies sicherlich eine Funktion.  Dann schauen wir uns die Anzahl der Merkmale des Prototyps an.  Wenn es nur einen Konstruktor hat und die Funktion kein Nachfolger einer anderen Klasse ist, betrachten wir sie als Funktion. </p><br><p>  Wenn wir eine Funktion entdecken, ersetzen wir sie einfach durch ein Serviceobjekt mit den Feldern __type = "serialized-function" und die Vorlage entspricht der Vorlage dieser Funktion (func.toString ()). </p><br><p>  Im Moment überspringen wir die Klasse und schauen uns die Klasseninstanz an.  Später müssen wir zwischen regulären Objekten und Klasseninstanzen unterscheiden. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> isInstance(some) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> = some.<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>; if (!<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !Serializer.isNative(<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>); } static isNative(data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-regexp"><span class="hljs-regexp">/function .*?\(\) \{ \[native code\] \}/</span></span>.test(data.toString()); }</code> </pre> <br><p>  Wir glauben, dass ein Objekt regulär ist, wenn es keinen Konstruktor hat oder sein Konstruktor eine native Funktion ist.  Sobald wir eine Klasseninstanz entdeckt haben, ersetzen wir sie durch ein Serviceobjekt mit den folgenden Feldern: </p><br><ul><li>  __type: 'serialisierte Instanz' </li><li>  Daten sind Daten, die in der Instanz enthalten sind </li><li>  index ist der Klassenindex dieser Instanz in der Serviceklassenliste. </li></ul><br><p>  Um Daten zu senden, müssen wir ein zusätzliches Feld erstellen, in dem wir eine Liste der von uns gesendeten eindeutigen Klassen speichern.  Es gibt jedoch eine Herausforderung: Um eine Klasse zu entdecken, müssen wir nicht nur ihre Vorlage, sondern auch die Vorlagen aller übergeordneten Klassen als unabhängige Klassen speichern, sodass jede übergeordnete Klasse nur einmal gesendet wird und auch eine Beweisinstanz gespeichert wird.  Das Erkennen einer Klasse ist einfach: Dies ist eine Funktion, bei der unser Serializer.isFunction-Beweis fehlgeschlagen ist.  Beim Hinzufügen einer Klasse überprüfen wir das Vorhandensein dieser Klasse in der Liste der serialisierten Daten und fügen nur eindeutige Klassen hinzu.  Code, der eine Klasse zu einer Vorlage zusammenfügt, ist ziemlich groß und hier verfügbar. </p><br><p>  Im Parser überprüfen wir zunächst alle an uns gesendeten Klassen und kompilieren sie, wenn sie nicht gesendet wurden.  Anschließend überprüfen wir rekursiv jedes Datenfeld und ersetzen Serviceobjekte durch kompilierte Daten.  Der interessanteste Teil sind Klasseninstanzen.  Wir haben eine Klasse und Daten, die in ihrer Instanz waren, aber wir können nicht einfach eine Instanz erstellen, da eine Konstruktoranforderung möglicherweise Parameter erfordert, die wir nicht haben.  Wir erhalten das von der fast vergessenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Object.create-</a> Methode, die ein Objekt mit einem festgelegten Prototyp erstellt.  Auf diese Weise vermeiden wir, einen Konstruktor anzufordern, eine Klasseninstanz abzurufen und nur Eigenschaften in die Instanz zu kopieren. </p><br><h2 id="creating-a-web-worker">  Erstellen eines Web-Workers </h2><br><p>  Damit ein Web-Worker erfolgreich arbeiten kann, benötigen wir einen Parser und einen Serializer innerhalb und außerhalb des Web-Workers.  Also nehmen wir einen Serializer und verwandeln ihn, Parser und Web Worker Body in eine Vorlage.  Aus der Vorlage erstellen wir einen Blob und erstellen einen Download-Link über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">URL.createObjectURL</a> (diese Methode funktioniert möglicherweise nicht für einige "Content-Security-Policy").  Diese Methode eignet sich auch zum Starten von Zufallscode aus einer Zeichenfolge. </p><br><pre> <code class="javascript hljs">_createworker(customworker) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> template = <span class="hljs-string"><span class="hljs-string">`var Myworker = </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._createTemplate(customworker)}</span></span></span><span class="hljs-string">;`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> blob = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Blob([template], { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'application/javascript'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> worker(URL.createObjectURL(blob)); } _createTemplate(workerBody) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Name = Serializer.getFnName(workerBody); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Name) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unnamed worker Body class! Please add name to worker Body class!'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'(function () {'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Serializer, <span class="hljs-string"><span class="hljs-string">'Serializer'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(Parser, <span class="hljs-string"><span class="hljs-string">'Parser'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._getFullClassTemplate(workerBody, <span class="hljs-string"><span class="hljs-string">'workerBody'</span></span>), <span class="hljs-string"><span class="hljs-string">`return new workerBody(Serializer, Parser)})();`</span></span> ].join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); }</code> </pre><br><h2 id="outcome">  Ergebnis </h2><br><p>  Wir haben also eine einfach zu verwendende Bibliothek, die jeden Code an den Web Worker senden kann.  Es unterstützt TypeScript-Klassen, zum Beispiel: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = workerWrapper.create(); wrapper.process(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">params</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// This code in worker. Cannot use closure! // do some hard work return 100; // or return Promise.resolve(100) }, params).then((result) =&gt; { // result = 100; }); wrapper.terminate() // terminate for kill worker process</span></span></code> </pre> <br><h2 id="future-development">  Zukünftige Entwicklung </h2><br><p>  Leider ist diese Bibliothek alles andere als ideal.  Wir müssen die Unterstützung von Setzern und Gettern für Klassen, Objekte, Prototypen und statische Merkmale hinzufügen.  Außerdem müssen wir Caching hinzufügen, einen alternativen <code>URL.createObjectURL</code> ohne <code>URL.createObjectURL</code> stattdessen <code>URL.createObjectURL</code> verwendet.  Schließlich muss der Assembly eine Datei mit dem Web-Worker-Inhalt hinzugefügt werden (falls keine On-the-Fly-Erstellung verfügbar ist) usw.  Besuchen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462325/">https://habr.com/ru/post/de462325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462313/index.html">Tipps und Tricks von meinem Telegramm-Kanal @pythonetc, Juli 2019</a></li>
<li><a href="../de462315/index.html">Büro-Energieeffizienz: Wie kann der reale Energieverbrauch gesenkt werden?</a></li>
<li><a href="../de462317/index.html">Tipps zur Optimierung Ihrer Laravel-Architektur mit AWS</a></li>
<li><a href="../de462321/index.html">Internationales SEO | Internationale SEO-Ranking-Faktoren</a></li>
<li><a href="../de462323/index.html">Fettleibigkeit - Entspannen und einbeziehen</a></li>
<li><a href="../de462327/index.html">Quietschen eines Krebstumors: Wissenschaftler von NUST „MISiS“ haben einen Laser-Ultraschall zur Diagnose von Krebs entwickelt</a></li>
<li><a href="../de462329/index.html">Bewegen Sie das Netzteil zur Vorderseite des Gehäuses</a></li>
<li><a href="../de462331/index.html">GAZ-66 Spielzeug auf dem Bedienfeld. Teil 2</a></li>
<li><a href="../de462333/index.html">Erstellen eines einfachen Chatbots für Konversationen in Python</a></li>
<li><a href="../de462335/index.html">Nicht lesen, erneut lesen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>