<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ざ   Swift funcional es f谩cil   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los art铆culos sobre programaci贸n funcional escriben mucho sobre c贸mo el enfoque de FP mejora el desarrollo: se vuelve f谩cil escribir, leer, transmitir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift funcional es f谩cil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/455359/"><p><img src="https://habrastorage.org/webt/ly/by/ev/lybyevylxskr_odybeuhzn4ywa4.jpeg" alt="imagen"></p><br><p>  Los art铆culos sobre programaci贸n funcional escriben mucho sobre c贸mo el enfoque de FP mejora el desarrollo: se vuelve f谩cil escribir, leer, transmitir, codificar, probar, construir una arquitectura pobre <del>  y el cabello se vuelve suave y sedoso </del>  . </p><br><p>  Un inconveniente es el alto umbral de entrada.  Intentando comprender la PF, me encontr茅 con una gran cantidad de teor铆a, functores, m贸nadas, teor铆a de categor铆as y tipos de datos algebraicos.  Y c贸mo aplicar AF en la pr谩ctica no estaba claro.  Adem谩s, se dieron ejemplos en idiomas desconocidos para m铆: Haskell y rock. </p><br><p>  Entonces decid铆 resolver el FP desde el principio.  Me di cuenta y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">le dije a codefest</a> que FP es realmente solo que ya lo usamos en Swift y podemos usarlo a煤n m谩s eficientemente. </p><a name="habracut"></a><br><h2 id="funkcionalnoe-programmirovanie-chistye-funkcii-i-otsutstvie-sostoyaniy">  Programaci贸n funcional: funciones puras y falta de estados. </h2><br><p>  Determinar lo que significa escribir en un paradigma particular no es una tarea f谩cil.  Los paradigmas se han formado durante d茅cadas por personas con diferentes visiones, incorporados en idiomas con enfoques diferentes, y est谩n rodeados de herramientas.  Estas herramientas y enfoques se consideran una parte integral de los paradigmas, pero en realidad no lo son. </p><br><p>  Por ejemplo, se cree que la programaci贸n orientada a objetos se basa en tres pilares: herencia, encapsulaci贸n y polimorfismo.  Pero la encapsulaci贸n y el polimorfismo se implementan en funciones con la misma facilidad que en los objetos.  O cierres: nacieron en lenguajes funcionales puros, pero migraron tanto tiempo a idiomas industriales que dejaron de estar asociados con la FP.  Las m贸nadas tambi茅n llegan a los idiomas industriales, pero a煤n no han perdido su membres铆a en el Haskell condicional en la mente de las personas. </p><br><p>  Como resultado, resulta que es imposible determinar claramente qu茅 es un paradigma particular.  Una vez m谩s, me encontr茅 con esto en codefest 2019, donde todos los expertos en FP, hablando sobre el paradigma funcional, llamaron cosas diferentes. </p><br><p>  Personalmente, me gust贸 la definici贸n de la wiki: </p><br><p>  "La programaci贸n funcional es una rama de las matem谩ticas discretas y un paradigma de programaci贸n en el que el proceso de c谩lculo se interpreta como el c谩lculo de los valores de las funciones en la comprensi贸n matem谩tica de este 煤ltimo (a diferencia de las funciones como subprogramas en la programaci贸n de procedimientos)". </p><br><p>  驴Qu茅 es una funci贸n matem谩tica?  Esta es una funci贸n cuyo resultado depende solo de los datos a los que se aplica. </p><br><p>  Un ejemplo de una funci贸n matem谩tica en cuatro l铆neas de c贸digo se ve as铆: </p><br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Llamando a la funci贸n summ con los argumentos de entrada 2 y 3, obtenemos 5. Este resultado no cambia.  Cambie el programa, el hilo, el lugar de ejecuci贸n: el resultado seguir谩 siendo el mismo. </p><br><p>  Y una funci贸n no matem谩tica es cuando una variable global se declara en alg煤n lugar. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><p>  La funci贸n suma ahora agrega los argumentos de entrada y el valor de z. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + z } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Mayor dependencia del estado global.  Ahora es imposible predecir sin ambig眉edad el valor de x.  Cambiar谩 constantemente dependiendo de cu谩ndo se llam贸 la funci贸n.  Llamamos a la funci贸n 10 veces seguidas, y cada vez podemos obtener un resultado diferente. </p><br><p>  Otra versi贸n de la funci贸n no matem谩tica: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { z = b - a <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b }</code> </pre> <br><p>  Adem谩s de devolver la suma de los argumentos de entrada, la funci贸n cambia la variable global z.  Esta caracter铆stica tiene un efecto secundario. </p><br><p>  La programaci贸n funcional tiene un t茅rmino especial para funciones matem谩ticas: funciones puras.  Una funci贸n pura es una funci贸n que devuelve el mismo resultado para el mismo conjunto de valores de entrada y no tiene efectos secundarios. </p><br><p>  Las funciones puras son la piedra angular de FP, todo lo dem谩s es secundario.  Se supone que, siguiendo este paradigma, solo los usamos.  Y si no trabaja con estados globales o mutables, entonces no estar谩n en la aplicaci贸n. </p><br><h2 id="klassy-i-struktury-v-funkcionalnoy-paradigme">  Clases y estructuras en un paradigma funcional </h2><br><p>  Inicialmente, pens茅 que FP se trata solo de funciones, y las clases y estructuras se usan solo en OOP.  Pero result贸 que las clases tambi茅n encajan en el concepto de FP.  Solo ellos deber铆an ser, digamos, "limpios". </p><br><p>  Una clase "pura" es una clase, cuyos m茅todos son funciones puras y las propiedades son inmutables.  (Este es un t茅rmino no oficial, acu帽ado en preparaci贸n para el informe). </p><br><p>  Echa un vistazo a esta clase: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname } }</code> </pre> <br><p>  Se puede considerar como encapsulaci贸n de datos ... </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre><br><p>  y funciones para trabajar con ellos. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname }</code> </pre> <br><p>  Desde el punto de vista de FP, usar la clase Usuario no es diferente de trabajar con primitivas y funciones. </p><br><p>  Declare el valor - usuario Vanya. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ivan = <span class="hljs-type"><span class="hljs-type">User</span></span>( name: <span class="hljs-string"><span class="hljs-string">""</span></span>, surname: <span class="hljs-string"><span class="hljs-string">""</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ivanov@example.com"</span></span> )</code> </pre> <br><p>  Aplique la funci贸n getFullname. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = ivan.getFullname()</code> </pre> <br><p>  Como resultado, obtenemos un nuevo valor: el nombre de usuario completo.  Como no puede cambiar los par谩metros de la propiedad ivan, el resultado de llamar a getFullname no cambia. </p><br><p>  Por supuesto, un lector atento puede decir: "Espera un minuto, el m茅todo getFullname devuelve el resultado basado en valores globales para 茅l: propiedades de clase, no argumentos".  Pero en realidad un m茅todo es solo una funci贸n en la que se pasa un objeto como argumento. </p><br><p>  Swift incluso admite esta entrada expl铆citamente: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = <span class="hljs-type"><span class="hljs-type">User</span></span>.getFullname(ivan)()</code> </pre> <br><p>  Si necesitamos cambiar alg煤n valor del objeto, por ejemplo, correo electr贸nico, tendremos que crear un nuevo objeto.  Esto puede hacerse por el m茅todo apropiado. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">User</span></span>(name: name, surname: surname, email: email) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIvan = ivan.change(email: <span class="hljs-string"><span class="hljs-string">"god@example.com"</span></span>)</code> </pre> <br><h2 id="funkcionalnye-atributy-v-swift">  Atributos funcionales en Swift </h2><br><p>  Ya escrib铆 que muchas herramientas, implementaciones y enfoques que se consideran parte de un paradigma en realidad pueden usarse en otros paradigmas.  Por ejemplo, las m贸nadas, los tipos de datos algebraicos, la inferencia autom谩tica de tipos, la tipificaci贸n estricta, los tipos dependientes y la validaci贸n de programas durante la compilaci贸n se consideran parte del FP.  Pero muchas de estas herramientas las podemos encontrar en Swift. </p><br><p>  La tipificaci贸n fuerte y la inferencia de tipos es parte de Swift.  No necesitan ser entendidos o introducidos en el proyecto, solo los tenemos. </p><br><p>  No hay tipos dependientes, aunque no me negar铆a a verificar la cadena por el compilador que es un correo electr贸nico, una matriz, que no est谩 vac铆o, un diccionario, que contiene la clave de Apple.  Por cierto, tampoco hay tipos dependientes en Haskell. </p><br><p>  Los tipos de datos algebraicos est谩n disponibles, y esta es una cosa matem谩tica genial, pero dif铆cil de entender.  La belleza es que no necesita ser entendido matem谩ticamente para usarlo.  Por ejemplo, Int, enum, Opcional, Hashable son tipos algebraicos.  Y si Int est谩 en muchos idiomas, y Protocol est谩 en Objective-C, entonces enumeraci贸n con valores asociados, protocolos con implementaci贸n predeterminada y tipos asociativos est谩n lejos de todas partes. </p><br><p>  A menudo se hace referencia a la validaci贸n de compilaci贸n cuando se habla de lenguajes como el 贸xido o el haskell.  Se entiende que el lenguaje es tan expresivo que le permite describir todos los casos l铆mite para que el compilador los verifique.  Entonces, si el programa fue compilado, entonces ciertamente funcionar谩.  Nadie discute que puede contener errores en la l贸gica, porque filtr贸 incorrectamente los datos para mostrarlos al usuario.  Pero no caer谩, porque no recibi贸 datos de la base de datos, el servidor devolvi贸 la respuesta incorrecta que estaba contando o el usuario ingres贸 su fecha de nacimiento como una cadena, no como un n煤mero. </p><br><p>  No puedo decir que compilar un c贸digo r谩pido puede detectar todos los errores: por ejemplo, es f谩cil evitar una p茅rdida de memoria.  Pero la tipificaci贸n fuerte y la protecci贸n opcional contra muchos errores est煤pidos.  Lo principal es limitar la extracci贸n forzada. </p><br><h2 id="monady-ne-chast-paradigmy-fp-a-instrument-neobyazatelnyy">  M贸nadas: no forma parte del paradigma FP, sino una herramienta (opcional) </h2><br><p>  Muy a menudo, los FP y las m贸nadas se usan en la misma aplicaci贸n.  En un momento, incluso pens茅 que las m贸nadas son programaci贸n funcional.  Cuando los entend铆 (pero esto no es exacto), hice varias conclusiones: </p><br><ul><li>  son simples </li><li>  son c贸modos </li><li>  enti茅ndelos opcionalmente, es suficiente para poder aplicar; </li><li>  puedes prescindir f谩cilmente de ellos. </li></ul><br><p>  Swift ya tiene dos m贸nadas est谩ndar: Opcional y Resultado.  Ambos son necesarios para hacer frente a los efectos secundarios.  Opcional protege contra posibles nulos.  Resultado - de varias situaciones excepcionales. </p><br><p>  Considere el ejemplo llevado al punto del absurdo.  Supongamos que tenemos funciones que devuelven un n煤mero entero de la base de datos y del servidor.  El segundo puede devolver nulo, pero usamos extracci贸n impl铆cita para obtener un comportamiento de tiempo objetivo-C. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span></code> </pre> <br><p>  Continuamos ignorando Opcional e implementamos una funci贸n para sumar estos n煤meros. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer()! <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ }</code> </pre> <br><p>  Llamamos a la funci贸n final y usamos el resultado. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result)</code> </pre> <br><p>  驴Funcionar谩 este ejemplo?  Bueno, definitivamente se compila, pero nadie sabe si tenemos el bloqueo en tiempo de ejecuci贸n o no.  Este c贸digo es bueno, muestra perfectamente nuestras intenciones (necesitamos la suma de algunos dos n煤meros) y no contiene nada superfluo.  Pero 茅l es peligroso.  Por lo tanto, solo los j贸venes y las personas seguras escriben de esta manera. </p><br><p>  Cambie el ejemplo para que sea seguro. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = intFromServer { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Este c贸digo es bueno, es seguro.  Usando extracci贸n expl铆cita, nos defendimos contra posibles nulos.  Pero se volvi贸 engorroso, y entre los controles seguros ya es dif铆cil discernir nuestra intenci贸n.  Todav铆a necesitamos la suma de algunos dos n煤meros, no un control de seguridad. </p><br><p>  En este caso, Opcional tiene un m茅todo de mapa, heredado del tipo Quiz谩s de Haskell.  Lo aplicamos y el ejemplo cambiar谩. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  O incluso m谩s compacto. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getintFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getintFromServer().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + getIntFromDB() } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Usamos map para convertir intFromServer al resultado que necesitamos sin extracci贸n. </p><br><p>  Nos deshicimos del cheque dentro de las sumas, pero lo dejamos en el nivel superior.  Esto se hace intencionalmente, ya que al final de la cadena de c谩lculo debemos elegir un m茅todo para procesar la falta de resultados. </p><br><p>  Expulsar </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre><br><p>  Usar valor predeterminado </p><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  O muestre una advertencia si no se reciben datos. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre> <br><p>  Ahora el c贸digo en el ejemplo no contiene demasiado, como en el primer ejemplo, y es seguro, como en el segundo. </p><br><p>  Pero el mapa no siempre funciona como deber铆a </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Optional&lt;Int&gt;&gt;</span></span></code> </pre> <br><p>  Si pasamos una funci贸n al mapa, cuyo resultado es opcional, obtenemos un doble Opcional.  Pero no necesitamos doble protecci贸n contra nada.  Uno es suficiente  El m茅todo flatMap permite resolver el problema, es un an谩logo del mapa con una diferencia, despliega las mu帽ecas de anidaci贸n. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.flatMap { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Int&gt;.</span></span></code> </pre> <br><p>  Otro ejemplo donde map y flatMap no es muy conveniente de usar. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + b! }</code> </pre><br><p>  驴Qu茅 pasa si una funci贸n toma dos argumentos y ambos son opcionales?  Por supuesto, FP tiene una soluci贸n: este es un functor aplicativo y curry.  Pero estas herramientas se ven bastante inc贸modas sin usar operadores especiales que no est谩n en nuestro idioma, y escribir operadores personalizados se considera una mala forma.  Por lo tanto, consideramos una forma m谩s intuitiva: escribimos una funci贸n especial. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-function">&lt;Result, U, Z&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transform: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(U, Z)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional1: <span class="hljs-type"><span class="hljs-type">U?</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional2: <span class="hljs-type"><span class="hljs-type">Z?</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rethrows</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional1 = optional1, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional2 = optional2 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> transform(optional1, optional2) }</code> </pre> <br><p>  Toma dos valores opcionales como argumentos y una funci贸n con dos argumentos.  Si ambas opciones tienen valores, se les aplica una funci贸n. <br>  Ahora podemos trabajar con varias opciones sin implementarlas. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = perform(+, a, b)</code> </pre> <br><p>  La segunda m贸nada, Result, tambi茅n tiene m茅todos map y flatMap.  Por lo tanto, puede trabajar con 茅l exactamente de la misma manera. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result) = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  En realidad, esto es lo que une a las m贸nadas: la capacidad de trabajar con el valor dentro del contenedor sin eliminarlo.  En mi opini贸n, esto hace que el c贸digo sea conciso.  Pero si no te gusta, solo usa extractos expl铆citos, esto no contradice el paradigma FP. </p><br><h2 id="primer-sokraschaem-chislo-gryaznyh-funkciy">  Ejemplo: reducir el n煤mero de funciones sucias </h2><br><p>  Desafortunadamente, en los programas reales, los estados globales y los efectos secundarios est谩n en todas partes: solicitudes de red, fuentes de datos, IU.  Y solo las funciones puras no pueden prescindirse.  Pero esto no significa que el FP sea completamente inaccesible para nosotros: podemos intentar reducir el n煤mero de funciones sucias, que generalmente son muchas. </p><br><p>  Veamos un peque帽o ejemplo cercano al desarrollo de la producci贸n.  Cree una interfaz de usuario, espec铆ficamente un formulario de inscripci贸n.  El formulario tiene algunas limitaciones: </p><br><p>  1) Inicie sesi贸n no menos de 3 caracteres <br>  2) Contrase帽a de al menos 6 caracteres <br>  3) El bot贸n "Iniciar sesi贸n" est谩 activo si ambos campos son v谩lidos. <br>  4) El color del marco de campo refleja su estado, negro - es v谩lido, rojo - no es v谩lido </p><br><p>  El c贸digo que describe estas restricciones puede verse as铆: </p><br><p>  Manejo de cualquier entrada del usuario </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { // 3. - loginButton.isEnabled = false return } let loginIsValid = login.count &gt; constants.loginMinLenght if loginIsValid { // 4. - loginView.layer.borderColor = constants.normalColor } let passwordIsValid = password.count &gt; constants.passwordMinLenght if passwordIsValid { // 5. - passwordView.layer.borderColor = constants.normalColor } // 6. - loginButton.isEnabled = loginIsValid &amp;&amp; passwordIsValid }</span></span></code> </pre> <br><p>  Proceso de finalizaci贸n de inicio de sesi贸n: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let login = loginView.text, login.count &gt; 3 { color = constants.normalColor } else { color = constants.errorColor } // 3.   loginView.layer.borderColor = color }</span></span></code> </pre> <br><p>  Proceso de finalizaci贸n de contrase帽a: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let password = passwordView.text, password.count &gt; 6 { color = constants.normalColor } else { color = constants.errorColor } // 3. - passwordView.layer.borderColor = color }</span></span></code> </pre> <br><p>  Presionando el bot贸n enter: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { return } auth(login: login, password: password) { [weak self] user, error in if let user = user { /*  */ } else if error is AuthError { guard let `self` = self else { return } // 3. - self.passwordView.layer.borderColor = self.constants.errorColor // 4. - self.loginView.layer.borderColor = self.constants.errorColor } else { /*   */ } } }</span></span></code> </pre> <br><p>  Este c贸digo puede no ser el mejor, pero en general es bueno y funciona.  Es cierto que tiene varios problemas: </p><br><ul><li>  4 extractos expl铆citos; </li><li>  4 dependencias del estado global; </li><li>  8 efectos secundarios; </li><li>  estados finales no obvios; </li><li>  flujo no lineal. </li></ul><br><p>  El principal problema es que no puedes simplemente tomar y decir lo que est谩 sucediendo con nuestra pantalla.  Mirando un m茅todo, vemos lo que hace con un estado global, pero no sabemos qui茅n, d贸nde y cu谩ndo toca el estado.  Como resultado, para comprender lo que est谩 sucediendo, debe encontrar todos los puntos de trabajo con las vistas y comprender en qu茅 orden se producen las influencias.  Tener todo esto en mente es muy dif铆cil. </p><br><p>  Si el proceso de cambiar el estado es lineal, puede estudiarlo paso a paso, lo que reducir谩 la carga cognitiva en el programador. </p><br><p>  Intentemos cambiar el ejemplo, haci茅ndolo m谩s funcional. </p><br><p>  Primero, definimos un modelo que describe el estado actual de la pantalla.  Esto le permitir谩 saber exactamente qu茅 informaci贸n es necesaria para el trabajo. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginOutputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> login: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> password: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> login.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> passwordIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> password.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">6</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loginIsValid &amp;&amp; passwordIsValid } }</code> </pre> <br><p>  Un modelo que describe los cambios aplicados a la pantalla.  Ella necesita saber exactamente qu茅 cambiaremos. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginInputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> passwordBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginButtonEnable: <span class="hljs-type"><span class="hljs-type">Bool?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popupErrorMessage: <span class="hljs-type"><span class="hljs-type">String?</span></span> }</code> </pre> <br><p>  Eventos que pueden conducir a un nuevo estado de pantalla.  Entonces sabremos exactamente qu茅 acciones cambian la pantalla. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> textFieldTextDidChange <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> passwordDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginPressed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> authFailure(<span class="hljs-type"><span class="hljs-type">Error</span></span>) }</code> </pre> <br><p>  Ahora describimos el m茅todo principal de cambio.  Esta funci贸n pura, basada en el evento de estado actual, recopila un nuevo estado de la pantalla. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeInputModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event: Event, outputModel: LoginOutputModel?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> event { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .textFieldTextDidChange: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapValidToColor: (<span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> = { $<span class="hljs-number"><span class="hljs-number">0</span></span> ? normalColor : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>( loginBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.loginIsValid } .flatMap(mapValidToColor), passwordBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.passwordIsValid } .flatMap(mapValidToColor), loginButtonEnable: outputModel?.passwordIsValid ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .passwordDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginPressed: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AuthError</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) } }</code> </pre> <br><p>  Lo m谩s importante es que este m茅todo es el 煤nico al que se le permite participar en la construcci贸n de un nuevo estado, y est谩 limpio.  Se puede estudiar paso a paso.  Vea c贸mo los eventos transforman la pantalla del punto A al punto B. Si algo se rompe, entonces el problema est谩 exactamente aqu铆.  Y es f谩cil de probar. </p><br><p>  Agregue una propiedad auxiliar para obtener el estado actual, este es el 煤nico m茅todo que depende del estado global. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputModel: <span class="hljs-type"><span class="hljs-type">LoginOutputModel?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> perform(<span class="hljs-type"><span class="hljs-type">LoginOutputModel</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>, loginView.text, passwordView.text) }</code> </pre> <br><p>  Agregue otro m茅todo "sucio" para crear los efectos secundarios de cambiar la pantalla. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: Event)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inputModel = makeInputModel(event: event, outputModel: outputModel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.loginBorderColor { loginView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.passwordBorderColor { passwordView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isEnable = inputModel.loginButtonEnable { loginButton.isEnabled = isEnable } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = inputModel.popupErrorMessage { showPopup(error) } }</code> </pre> <br><p>  Aunque el m茅todo updateView no est谩 limpio, es el 煤nico lugar donde cambian las propiedades de la pantalla.  El primer y 煤ltimo elemento de la cadena de c谩lculos.  Y si algo sali贸 mal, aqu铆 es donde estar谩 el punto de ruptura. </p><br><p>  Solo queda comenzar la conversi贸n en los lugares correctos. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.textFieldTextDidChange) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginDidEndEdit) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.passwordDidEndEdit) }</code> </pre> <br><p>  El m茅todo loginPressed sali贸 un poco 煤nico. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginPressed) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> completion: (<span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">User</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user): <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.updateView(.authFailure(error)) } } outputModel.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { auth(login: $<span class="hljs-number"><span class="hljs-number">0</span></span>.login, password: $<span class="hljs-number"><span class="hljs-number">0</span></span>.password, completion: completion) } }</code> </pre> <br><p>  El hecho es que al hacer clic en el bot贸n "Iniciar sesi贸n" se inician dos cadenas de c谩lculos, lo cual no est谩 prohibido. </p><br><h2 id="zaklyuchenie">  Conclusi贸n </h2><br><p>  Antes de estudiar FP, hice un fuerte 茅nfasis en los paradigmas de programaci贸n.  Para m铆 era importante que el c贸digo siguiera a OOP, no me gustaban las funciones est谩ticas ni los objetos sin estado, no escrib铆a funciones globales. </p><br><p>  Ahora me parece que todas esas cosas que consider茅 parte de un paradigma son bastante arbitrarias.  Lo principal es un c贸digo limpio y comprensible.  Para lograr este objetivo, puede usar todo lo que sea posible: funciones puras, clases, m贸nadas, herencia, composici贸n, inferencia de tipos.  Todos se llevan bien y mejoran el c贸digo, simplemente apl铆quelos al lugar. </p><br><h2 id="chto-esche-pochitat-po-teme">  驴Qu茅 m谩s leer sobre el tema? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definici贸n de programaci贸n funcional de Wikipedia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Haskell Starter Book</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Explicaci贸n de functores, m贸nadas y fundores aplicativos en los dedos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Libro de Haskell sobre pr谩cticas para el uso de Maybe (opcional)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Libro sobre la naturaleza funcional de Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definici贸n de tipos de datos algebraicos de una wiki</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un art铆culo sobre tipos de datos algebraicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otro art铆culo sobre tipos de datos algebraicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informe Yandex sobre programaci贸n funcional en Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci贸n de la biblioteca est谩ndar de Preludio (Haskell) en Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca con herramientas funcionales en Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otra biblioteca</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Y uno mas</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455359/">https://habr.com/ru/post/455359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455345/index.html">Precauci贸n Doctor</a></li>
<li><a href="../455347/index.html">Interfaces funcionales ... en VBA</a></li>
<li><a href="../455351/index.html">VMware EMPOWER 2019: los principales anuncios y conclusiones de la conferencia</a></li>
<li><a href="../455353/index.html">Aceleraci贸n de hardware de redes neuronales profundas: GPU, FPGA, ASIC, TPU, VPU, IPU, DPU, NPU, RPU, NNP y otras letras</a></li>
<li><a href="../455355/index.html">Redes de TV por cable para los m谩s peque帽os. Parte 8: red troncal 贸ptica</a></li>
<li><a href="../455361/index.html">Creamos una extensi贸n de navegador que verifica los resultados del examen.</a></li>
<li><a href="../455367/index.html">C贸digo m铆nimo VueJs + MVC funcionalidad m谩xima</a></li>
<li><a href="../455369/index.html">Certificaci贸n de administradores de bases de datos y mucho m谩s en el aniversario DevConfX (21-22 de junio en Mosc煤)</a></li>
<li><a href="../455371/index.html">Fuente de corriente estable de 5 渭A a 20 mA</a></li>
<li><a href="../455373/index.html">驴C贸mo ajustar la ley de Spring para que se convierta en un est铆mulo para los peque帽os proveedores? Cancelarlo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>