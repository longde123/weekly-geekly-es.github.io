<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏼 🤟🏽 👉🏽 Swift funcional es fácil 🕠 🔙 👖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los artículos sobre programación funcional escriben mucho sobre cómo el enfoque de FP mejora el desarrollo: se vuelve fácil escribir, leer, transmitir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Swift funcional es fácil</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/455359/"><p><img src="https://habrastorage.org/webt/ly/by/ev/lybyevylxskr_odybeuhzn4ywa4.jpeg" alt="imagen"></p><br><p>  Los artículos sobre programación funcional escriben mucho sobre cómo el enfoque de FP mejora el desarrollo: se vuelve fácil escribir, leer, transmitir, codificar, probar, construir una arquitectura pobre <del>  y el cabello se vuelve suave y sedoso </del>  . </p><br><p>  Un inconveniente es el alto umbral de entrada.  Intentando comprender la PF, me encontré con una gran cantidad de teoría, functores, mónadas, teoría de categorías y tipos de datos algebraicos.  Y cómo aplicar AF en la práctica no estaba claro.  Además, se dieron ejemplos en idiomas desconocidos para mí: Haskell y rock. </p><br><p>  Entonces decidí resolver el FP desde el principio.  Me di cuenta y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">le dije a codefest</a> que FP es realmente solo que ya lo usamos en Swift y podemos usarlo aún más eficientemente. </p><a name="habracut"></a><br><h2 id="funkcionalnoe-programmirovanie-chistye-funkcii-i-otsutstvie-sostoyaniy">  Programación funcional: funciones puras y falta de estados. </h2><br><p>  Determinar lo que significa escribir en un paradigma particular no es una tarea fácil.  Los paradigmas se han formado durante décadas por personas con diferentes visiones, incorporados en idiomas con enfoques diferentes, y están rodeados de herramientas.  Estas herramientas y enfoques se consideran una parte integral de los paradigmas, pero en realidad no lo son. </p><br><p>  Por ejemplo, se cree que la programación orientada a objetos se basa en tres pilares: herencia, encapsulación y polimorfismo.  Pero la encapsulación y el polimorfismo se implementan en funciones con la misma facilidad que en los objetos.  O cierres: nacieron en lenguajes funcionales puros, pero migraron tanto tiempo a idiomas industriales que dejaron de estar asociados con la FP.  Las mónadas también llegan a los idiomas industriales, pero aún no han perdido su membresía en el Haskell condicional en la mente de las personas. </p><br><p>  Como resultado, resulta que es imposible determinar claramente qué es un paradigma particular.  Una vez más, me encontré con esto en codefest 2019, donde todos los expertos en FP, hablando sobre el paradigma funcional, llamaron cosas diferentes. </p><br><p>  Personalmente, me gustó la definición de la wiki: </p><br><p>  "La programación funcional es una rama de las matemáticas discretas y un paradigma de programación en el que el proceso de cálculo se interpreta como el cálculo de los valores de las funciones en la comprensión matemática de este último (a diferencia de las funciones como subprogramas en la programación de procedimientos)". </p><br><p>  ¿Qué es una función matemática?  Esta es una función cuyo resultado depende solo de los datos a los que se aplica. </p><br><p>  Un ejemplo de una función matemática en cuatro líneas de código se ve así: </p><br><pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Llamando a la función summ con los argumentos de entrada 2 y 3, obtenemos 5. Este resultado no cambia.  Cambie el programa, el hilo, el lugar de ejecución: el resultado seguirá siendo el mismo. </p><br><p>  Y una función no matemática es cuando una variable global se declara en algún lugar. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><p>  La función suma ahora agrega los argumentos de entrada y el valor de z. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + z } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = summ(a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><p>  Mayor dependencia del estado global.  Ahora es imposible predecir sin ambigüedad el valor de x.  Cambiará constantemente dependiendo de cuándo se llamó la función.  Llamamos a la función 10 veces seguidas, y cada vez podemos obtener un resultado diferente. </p><br><p>  Otra versión de la función no matemática: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: Int, b: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { z = b - a <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b }</code> </pre> <br><p>  Además de devolver la suma de los argumentos de entrada, la función cambia la variable global z.  Esta característica tiene un efecto secundario. </p><br><p>  La programación funcional tiene un término especial para funciones matemáticas: funciones puras.  Una función pura es una función que devuelve el mismo resultado para el mismo conjunto de valores de entrada y no tiene efectos secundarios. </p><br><p>  Las funciones puras son la piedra angular de FP, todo lo demás es secundario.  Se supone que, siguiendo este paradigma, solo los usamos.  Y si no trabaja con estados globales o mutables, entonces no estarán en la aplicación. </p><br><h2 id="klassy-i-struktury-v-funkcionalnoy-paradigme">  Clases y estructuras en un paradigma funcional </h2><br><p>  Inicialmente, pensé que FP se trata solo de funciones, y las clases y estructuras se usan solo en OOP.  Pero resultó que las clases también encajan en el concepto de FP.  Solo ellos deberían ser, digamos, "limpios". </p><br><p>  Una clase "pura" es una clase, cuyos métodos son funciones puras y las propiedades son inmutables.  (Este es un término no oficial, acuñado en preparación para el informe). </p><br><p>  Echa un vistazo a esta clase: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname } }</code> </pre> <br><p>  Se puede considerar como encapsulación de datos ... </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre><br><p>  y funciones para trabajar con ellos. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFullname</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name + <span class="hljs-string"><span class="hljs-string">" "</span></span> + surname }</code> </pre> <br><p>  Desde el punto de vista de FP, usar la clase Usuario no es diferente de trabajar con primitivas y funciones. </p><br><p>  Declare el valor - usuario Vanya. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ivan = <span class="hljs-type"><span class="hljs-type">User</span></span>( name: <span class="hljs-string"><span class="hljs-string">""</span></span>, surname: <span class="hljs-string"><span class="hljs-string">""</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ivanov@example.com"</span></span> )</code> </pre> <br><p>  Aplique la función getFullname. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = ivan.getFullname()</code> </pre> <br><p>  Como resultado, obtenemos un nuevo valor: el nombre de usuario completo.  Como no puede cambiar los parámetros de la propiedad ivan, el resultado de llamar a getFullname no cambia. </p><br><p>  Por supuesto, un lector atento puede decir: "Espera un minuto, el método getFullname devuelve el resultado basado en valores globales para él: propiedades de clase, no argumentos".  Pero en realidad un método es solo una función en la que se pasa un objeto como argumento. </p><br><p>  Swift incluso admite esta entrada explícitamente: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullName = <span class="hljs-type"><span class="hljs-type">User</span></span>.getFullname(ivan)()</code> </pre> <br><p>  Si necesitamos cambiar algún valor del objeto, por ejemplo, correo electrónico, tendremos que crear un nuevo objeto.  Esto puede hacerse por el método apropiado. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> surname: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">User</span></span>(name: name, surname: surname, email: email) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIvan = ivan.change(email: <span class="hljs-string"><span class="hljs-string">"god@example.com"</span></span>)</code> </pre> <br><h2 id="funkcionalnye-atributy-v-swift">  Atributos funcionales en Swift </h2><br><p>  Ya escribí que muchas herramientas, implementaciones y enfoques que se consideran parte de un paradigma en realidad pueden usarse en otros paradigmas.  Por ejemplo, las mónadas, los tipos de datos algebraicos, la inferencia automática de tipos, la tipificación estricta, los tipos dependientes y la validación de programas durante la compilación se consideran parte del FP.  Pero muchas de estas herramientas las podemos encontrar en Swift. </p><br><p>  La tipificación fuerte y la inferencia de tipos es parte de Swift.  No necesitan ser entendidos o introducidos en el proyecto, solo los tenemos. </p><br><p>  No hay tipos dependientes, aunque no me negaría a verificar la cadena por el compilador que es un correo electrónico, una matriz, que no está vacío, un diccionario, que contiene la clave de Apple.  Por cierto, tampoco hay tipos dependientes en Haskell. </p><br><p>  Los tipos de datos algebraicos están disponibles, y esta es una cosa matemática genial, pero difícil de entender.  La belleza es que no necesita ser entendido matemáticamente para usarlo.  Por ejemplo, Int, enum, Opcional, Hashable son tipos algebraicos.  Y si Int está en muchos idiomas, y Protocol está en Objective-C, entonces enumeración con valores asociados, protocolos con implementación predeterminada y tipos asociativos están lejos de todas partes. </p><br><p>  A menudo se hace referencia a la validación de compilación cuando se habla de lenguajes como el óxido o el haskell.  Se entiende que el lenguaje es tan expresivo que le permite describir todos los casos límite para que el compilador los verifique.  Entonces, si el programa fue compilado, entonces ciertamente funcionará.  Nadie discute que puede contener errores en la lógica, porque filtró incorrectamente los datos para mostrarlos al usuario.  Pero no caerá, porque no recibió datos de la base de datos, el servidor devolvió la respuesta incorrecta que estaba contando o el usuario ingresó su fecha de nacimiento como una cadena, no como un número. </p><br><p>  No puedo decir que compilar un código rápido puede detectar todos los errores: por ejemplo, es fácil evitar una pérdida de memoria.  Pero la tipificación fuerte y la protección opcional contra muchos errores estúpidos.  Lo principal es limitar la extracción forzada. </p><br><h2 id="monady-ne-chast-paradigmy-fp-a-instrument-neobyazatelnyy">  Mónadas: no forma parte del paradigma FP, sino una herramienta (opcional) </h2><br><p>  Muy a menudo, los FP y las mónadas se usan en la misma aplicación.  En un momento, incluso pensé que las mónadas son programación funcional.  Cuando los entendí (pero esto no es exacto), hice varias conclusiones: </p><br><ul><li>  son simples </li><li>  son cómodos </li><li>  entiéndelos opcionalmente, es suficiente para poder aplicar; </li><li>  puedes prescindir fácilmente de ellos. </li></ul><br><p>  Swift ya tiene dos mónadas estándar: Opcional y Resultado.  Ambos son necesarios para hacer frente a los efectos secundarios.  Opcional protege contra posibles nulos.  Resultado - de varias situaciones excepcionales. </p><br><p>  Considere el ejemplo llevado al punto del absurdo.  Supongamos que tenemos funciones que devuelven un número entero de la base de datos y del servidor.  El segundo puede devolver nulo, pero usamos extracción implícita para obtener un comportamiento de tiempo objetivo-C. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span></code> </pre> <br><p>  Continuamos ignorando Opcional e implementamos una función para sumar estos números. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer()! <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ }</code> </pre> <br><p>  Llamamos a la función final y usamos el resultado. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result)</code> </pre> <br><p>  ¿Funcionará este ejemplo?  Bueno, definitivamente se compila, pero nadie sabe si tenemos el bloqueo en tiempo de ejecución o no.  Este código es bueno, muestra perfectamente nuestras intenciones (necesitamos la suma de algunos dos números) y no contiene nada superfluo.  Pero él es peligroso.  Por lo tanto, solo los jóvenes y las personas seguras escriben de esta manera. </p><br><p>  Cambie el ejemplo para que sea seguro. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = intFromServer { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> summ = intFromDB + intFromServer <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> summ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Este código es bueno, es seguro.  Usando extracción explícita, nos defendimos contra posibles nulos.  Pero se volvió engorroso, y entre los controles seguros ya es difícil discernir nuestra intención.  Todavía necesitamos la suma de algunos dos números, no un control de seguridad. </p><br><p>  En este caso, Opcional tiene un método de mapa, heredado del tipo Quizás de Haskell.  Lo aplicamos y el ejemplo cambiará. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  O incluso más compacto. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getintFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getintFromServer().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + getIntFromDB() } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  Usamos map para convertir intFromServer al resultado que necesitamos sin extracción. </p><br><p>  Nos deshicimos del cheque dentro de las sumas, pero lo dejamos en el nivel superior.  Esto se hace intencionalmente, ya que al final de la cadena de cálculo debemos elegir un método para procesar la falta de resultados. </p><br><p>  Expulsar </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre><br><p>  Usar valor predeterminado </p><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result ?? <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br><p>  O muestre una advertencia si no se reciben datos. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) }</code> </pre> <br><p>  Ahora el código en el ejemplo no contiene demasiado, como en el primer ejemplo, y es seguro, como en el segundo. </p><br><p>  Pero el mapa no siempre funciona como debería </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Optional&lt;Int&gt;&gt;</span></span></code> </pre> <br><p>  Si pasamos una función al mapa, cuyo resultado es opcional, obtenemos un doble Opcional.  Pero no necesitamos doble protección contra nada.  Uno es suficiente  El método flatMap permite resolver el problema, es un análogo del mapa con una diferencia, despliega las muñecas de anidación. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">String?</span></span> = <span class="hljs-string"><span class="hljs-string">"7"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = a.flatMap { <span class="hljs-type"><span class="hljs-type">Int</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>) } type(of: b)<span class="hljs-comment"><span class="hljs-comment">//Optional&lt;Int&gt;.</span></span></code> </pre> <br><p>  Otro ejemplo donde map y flatMap no es muy conveniente de usar. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = a.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> + b! }</code> </pre><br><p>  ¿Qué pasa si una función toma dos argumentos y ambos son opcionales?  Por supuesto, FP tiene una solución: este es un functor aplicativo y curry.  Pero estas herramientas se ven bastante incómodas sin usar operadores especiales que no están en nuestro idioma, y ​​escribir operadores personalizados se considera una mala forma.  Por lo tanto, consideramos una forma más intuitiva: escribimos una función especial. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@discardableResult</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">perform</span></span></span><span class="hljs-function">&lt;Result, U, Z&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transform: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(U, Z)</span></span></span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional1: <span class="hljs-type"><span class="hljs-type">U?</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> optional2: <span class="hljs-type"><span class="hljs-type">Z?</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rethrows</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional1 = optional1, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optional2 = optional2 <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> transform(optional1, optional2) }</code> </pre> <br><p>  Toma dos valores opcionales como argumentos y una función con dos argumentos.  Si ambas opciones tienen valores, se les aplica una función. <br>  Ahora podemos trabajar con varias opciones sin implementarlas. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = perform(+, a, b)</code> </pre> <br><p>  La segunda mónada, Result, también tiene métodos map y flatMap.  Por lo tanto, puede trabajar con él exactamente de la misma manera. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromDB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getIntFromServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summInts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">ServerError</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromDB = getIntFromDB() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> intFromServer = getIntFromServer() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> intFromServer.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> x + intFromDB } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result) = summInts() { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(result) }</code> </pre> <br><p>  En realidad, esto es lo que une a las mónadas: la capacidad de trabajar con el valor dentro del contenedor sin eliminarlo.  En mi opinión, esto hace que el código sea conciso.  Pero si no te gusta, solo usa extractos explícitos, esto no contradice el paradigma FP. </p><br><h2 id="primer-sokraschaem-chislo-gryaznyh-funkciy">  Ejemplo: reducir el número de funciones sucias </h2><br><p>  Desafortunadamente, en los programas reales, los estados globales y los efectos secundarios están en todas partes: solicitudes de red, fuentes de datos, IU.  Y solo las funciones puras no pueden prescindirse.  Pero esto no significa que el FP sea completamente inaccesible para nosotros: podemos intentar reducir el número de funciones sucias, que generalmente son muchas. </p><br><p>  Veamos un pequeño ejemplo cercano al desarrollo de la producción.  Cree una interfaz de usuario, específicamente un formulario de inscripción.  El formulario tiene algunas limitaciones: </p><br><p>  1) Inicie sesión no menos de 3 caracteres <br>  2) Contraseña de al menos 6 caracteres <br>  3) El botón "Iniciar sesión" está activo si ambos campos son válidos. <br>  4) El color del marco de campo refleja su estado, negro - es válido, rojo - no es válido </p><br><p>  El código que describe estas restricciones puede verse así: </p><br><p>  Manejo de cualquier entrada del usuario </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { // 3. - loginButton.isEnabled = false return } let loginIsValid = login.count &gt; constants.loginMinLenght if loginIsValid { // 4. - loginView.layer.borderColor = constants.normalColor } let passwordIsValid = password.count &gt; constants.passwordMinLenght if passwordIsValid { // 5. - passwordView.layer.borderColor = constants.normalColor } // 6. - loginButton.isEnabled = loginIsValid &amp;&amp; passwordIsValid }</span></span></code> </pre> <br><p>  Proceso de finalización de inicio de sesión: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let login = loginView.text, login.count &gt; 3 { color = constants.normalColor } else { color = constants.errorColor } // 3.   loginView.layer.borderColor = color }</span></span></code> </pre> <br><p>  Proceso de finalización de contraseña: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: <span class="hljs-type"><span class="hljs-type">CGColor</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   if let password = passwordView.text, password.count &gt; 6 { color = constants.normalColor } else { color = constants.errorColor } // 3. - passwordView.layer.borderColor = color }</span></span></code> </pre> <br><p>  Presionando el botón enter: </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1.     // 2.   guard let login = loginView.text, let password = passwordView.text else { return } auth(login: login, password: password) { [weak self] user, error in if let user = user { /*  */ } else if error is AuthError { guard let `self` = self else { return } // 3. - self.passwordView.layer.borderColor = self.constants.errorColor // 4. - self.loginView.layer.borderColor = self.constants.errorColor } else { /*   */ } } }</span></span></code> </pre> <br><p>  Este código puede no ser el mejor, pero en general es bueno y funciona.  Es cierto que tiene varios problemas: </p><br><ul><li>  4 extractos explícitos; </li><li>  4 dependencias del estado global; </li><li>  8 efectos secundarios; </li><li>  estados finales no obvios; </li><li>  flujo no lineal. </li></ul><br><p>  El principal problema es que no puedes simplemente tomar y decir lo que está sucediendo con nuestra pantalla.  Mirando un método, vemos lo que hace con un estado global, pero no sabemos quién, dónde y cuándo toca el estado.  Como resultado, para comprender lo que está sucediendo, debe encontrar todos los puntos de trabajo con las vistas y comprender en qué orden se producen las influencias.  Tener todo esto en mente es muy difícil. </p><br><p>  Si el proceso de cambiar el estado es lineal, puede estudiarlo paso a paso, lo que reducirá la carga cognitiva en el programador. </p><br><p>  Intentemos cambiar el ejemplo, haciéndolo más funcional. </p><br><p>  Primero, definimos un modelo que describe el estado actual de la pantalla.  Esto le permitirá saber exactamente qué información es necesaria para el trabajo. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginOutputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> login: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> password: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loginIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> login.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> passwordIsValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> password.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> &gt; <span class="hljs-number"><span class="hljs-number">6</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isValid: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loginIsValid &amp;&amp; passwordIsValid } }</code> </pre> <br><p>  Un modelo que describe los cambios aplicados a la pantalla.  Ella necesita saber exactamente qué cambiaremos. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginInputModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> passwordBorderColor: <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginButtonEnable: <span class="hljs-type"><span class="hljs-type">Bool?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popupErrorMessage: <span class="hljs-type"><span class="hljs-type">String?</span></span> }</code> </pre> <br><p>  Eventos que pueden conducir a un nuevo estado de pantalla.  Entonces sabremos exactamente qué acciones cambian la pantalla. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> textFieldTextDidChange <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> passwordDidEndEdit <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> loginPressed <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> authFailure(<span class="hljs-type"><span class="hljs-type">Error</span></span>) }</code> </pre> <br><p>  Ahora describimos el método principal de cambio.  Esta función pura, basada en el evento de estado actual, recopila un nuevo estado de la pantalla. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeInputModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( event: Event, outputModel: LoginOutputModel?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> event { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .textFieldTextDidChange: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mapValidToColor: (<span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">CGColor?</span></span> = { $<span class="hljs-number"><span class="hljs-number">0</span></span> ? normalColor : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>( loginBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.loginIsValid } .flatMap(mapValidToColor), passwordBorderColor: outputModel .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.passwordIsValid } .flatMap(mapValidToColor), loginButtonEnable: outputModel?.passwordIsValid ) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .passwordDidEndEdit: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .loginPressed: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AuthError</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .authFailure: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LoginInputModel</span></span>(<span class="hljs-comment"><span class="hljs-comment">/**/</span></span>) } }</code> </pre> <br><p>  Lo más importante es que este método es el único al que se le permite participar en la construcción de un nuevo estado, y está limpio.  Se puede estudiar paso a paso.  Vea cómo los eventos transforman la pantalla del punto A al punto B. Si algo se rompe, entonces el problema está exactamente aquí.  Y es fácil de probar. </p><br><p>  Agregue una propiedad auxiliar para obtener el estado actual, este es el único método que depende del estado global. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputModel: <span class="hljs-type"><span class="hljs-type">LoginOutputModel?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> perform(<span class="hljs-type"><span class="hljs-type">LoginOutputModel</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>, loginView.text, passwordView.text) }</code> </pre> <br><p>  Agregue otro método "sucio" para crear los efectos secundarios de cambiar la pantalla. </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: Event)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> inputModel = makeInputModel(event: event, outputModel: outputModel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.loginBorderColor { loginView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color = inputModel.passwordBorderColor { passwordView.layer.borderColor = color } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isEnable = inputModel.loginButtonEnable { loginButton.isEnabled = isEnable } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = inputModel.popupErrorMessage { showPopup(error) } }</code> </pre> <br><p>  Aunque el método updateView no está limpio, es el único lugar donde cambian las propiedades de la pantalla.  El primer y último elemento de la cadena de cálculos.  Y si algo salió mal, aquí es donde estará el punto de ruptura. </p><br><p>  Solo queda comenzar la conversión en los lugares correctos. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textFieldTextDidChange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.textFieldTextDidChange) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginDidEndEdit) } <span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">passwordDidEndEdit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.passwordDidEndEdit) }</code> </pre> <br><p>  El método loginPressed salió un poco único. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBAction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loginPressed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { updateView(.loginPressed) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> completion: (<span class="hljs-type"><span class="hljs-type">Result</span></span>&lt;<span class="hljs-type"><span class="hljs-type">User</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt;) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> result { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .success(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user): <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .failure(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error): <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.updateView(.authFailure(error)) } } outputModel.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { auth(login: $<span class="hljs-number"><span class="hljs-number">0</span></span>.login, password: $<span class="hljs-number"><span class="hljs-number">0</span></span>.password, completion: completion) } }</code> </pre> <br><p>  El hecho es que al hacer clic en el botón "Iniciar sesión" se inician dos cadenas de cálculos, lo cual no está prohibido. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  Antes de estudiar FP, hice un fuerte énfasis en los paradigmas de programación.  Para mí era importante que el código siguiera a OOP, no me gustaban las funciones estáticas ni los objetos sin estado, no escribía funciones globales. </p><br><p>  Ahora me parece que todas esas cosas que consideré parte de un paradigma son bastante arbitrarias.  Lo principal es un código limpio y comprensible.  Para lograr este objetivo, puede usar todo lo que sea posible: funciones puras, clases, mónadas, herencia, composición, inferencia de tipos.  Todos se llevan bien y mejoran el código, simplemente aplíquelos al lugar. </p><br><h2 id="chto-esche-pochitat-po-teme">  ¿Qué más leer sobre el tema? </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definición de programación funcional de Wikipedia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Haskell Starter Book</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Explicación de functores, mónadas y fundores aplicativos en los dedos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Libro de Haskell sobre prácticas para el uso de Maybe (opcional)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Libro sobre la naturaleza funcional de Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definición de tipos de datos algebraicos de una wiki</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un artículo sobre tipos de datos algebraicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otro artículo sobre tipos de datos algebraicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informe Yandex sobre programación funcional en Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementación de la biblioteca estándar de Preludio (Haskell) en Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Biblioteca con herramientas funcionales en Swift</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otra biblioteca</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Y uno mas</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/455359/">https://habr.com/ru/post/455359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455345/index.html">Precaución Doctor</a></li>
<li><a href="../455347/index.html">Interfaces funcionales ... en VBA</a></li>
<li><a href="../455351/index.html">VMware EMPOWER 2019: los principales anuncios y conclusiones de la conferencia</a></li>
<li><a href="../455353/index.html">Aceleración de hardware de redes neuronales profundas: GPU, FPGA, ASIC, TPU, VPU, IPU, DPU, NPU, RPU, NNP y otras letras</a></li>
<li><a href="../455355/index.html">Redes de TV por cable para los más pequeños. Parte 8: red troncal óptica</a></li>
<li><a href="../455361/index.html">Creamos una extensión de navegador que verifica los resultados del examen.</a></li>
<li><a href="../455367/index.html">Código mínimo VueJs + MVC funcionalidad máxima</a></li>
<li><a href="../455369/index.html">Certificación de administradores de bases de datos y mucho más en el aniversario DevConfX (21-22 de junio en Moscú)</a></li>
<li><a href="../455371/index.html">Fuente de corriente estable de 5 μA a 20 mA</a></li>
<li><a href="../455373/index.html">¿Cómo ajustar la ley de Spring para que se convierta en un estímulo para los pequeños proveedores? Cancelarlo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>