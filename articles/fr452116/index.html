<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèª üëâüèª üòÆ Index dans PostgreSQL - 8 (RUM) üêû üë¶üèª üôÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous avons d√©j√† discut√© du moteur d'indexation PostgreSQL, de l'interface des m√©thodes d'acc√®s et des principales m√©thodes d'acc√®s, telles que: les in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Index dans PostgreSQL - 8 (RUM)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452116/">  Nous avons d√©j√† discut√© du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteur d'indexation</a> PostgreSQL, de l'interface des m√©thodes d'acc√®s et des principales m√©thodes d'acc√®s, telles que: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les index de hachage</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les arbres B</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SP-GiST</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GIN</a> .  Dans cet article, nous verrons comment le gin se transforme en rhum. <br><br><h1>  RHUM </h1><br>  Bien que les auteurs affirment que le gin est un g√©nie puissant, le th√®me des boissons a finalement gagn√©: le GIN de nouvelle g√©n√©ration a √©t√© appel√© RUM. <br><br>  Cette m√©thode d'acc√®s √©largit le concept qui sous-tend GIN et nous permet d'effectuer une recherche en texte int√©gral encore plus rapidement.  Dans cette s√©rie d'articles, c'est la seule m√©thode qui n'est pas incluse dans une livraison PostgreSQL standard et c'est une extension externe.  Plusieurs options d'installation sont disponibles pour cela: <br><br><ul><li>  Prenez le paquet "yum" ou "apt" du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©p√¥t PGDG</a> .  Par exemple, si vous avez install√© PostgreSQL √† partir du package "postgresql-10", installez √©galement "postgresql-10-rum". </li><li>  Construisez √† partir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">du code source sur github</a> et installez-le vous-m√™me (les instructions sont l√† aussi). </li><li>  √Ä utiliser dans le cadre de Postgres Pro Enterprise (ou au moins lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la documentation √†</a> partir de l√†). </li></ul><br><h2>  Limitations du gin </h2><br>  Quelles limitations de GIN RUM nous permet-il de transcender? <br><br>  Tout d'abord, le type de donn√©es "tsvector" contient non seulement des lex√®mes, mais √©galement des informations sur leur position √† l'int√©rieur du document.  Comme nous l'avons observ√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">derni√®re fois</a> , l'indice GIN ne stocke pas ces informations.  Pour cette raison, les op√©rations de recherche de phrases, apparues dans la version 9.6, sont prises en charge par l'index GIN de mani√®re inefficace et doivent acc√©der aux donn√©es d'origine pour une nouvelle v√©rification. <br><br>  Deuxi√®mement, les syst√®mes de recherche renvoient g√©n√©ralement les r√©sultats tri√©s par pertinence (quoi que cela signifie).  Nous pouvons utiliser les fonctions de classement "ts_rank" et "ts_rank_cd" √† cette fin, mais elles doivent √™tre calcul√©es pour chaque ligne du r√©sultat, ce qui est certainement lent. <br><br>  Pour une premi√®re approximation, la m√©thode d'acc√®s RUM peut √™tre consid√©r√©e comme GIN qui stocke en outre les informations de position et peut renvoyer les r√©sultats dans un ordre n√©cessaire (comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GiST</a> peut renvoyer les voisins les plus proches).  Passons √©tape par √©tape. <br><a name="habracut"></a><br><h2>  Recherche de phrases </h2><br>  Une requ√™te de recherche en texte int√©gral peut contenir des op√©rateurs sp√©ciaux qui prennent en compte la distance entre les lex√®mes.  Par exemple, nous pouvons trouver des documents dans lesquels "main" est s√©par√© de "cuisse" avec deux autres mots: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;3&gt; thigh'</span></span>);</code> </pre> <pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Ou nous pouvons indiquer que les mots doivent √™tre situ√©s l'un apr√®s l'autre: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hand &lt;-&gt; slap'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Un index GIN r√©gulier peut renvoyer les documents qui contiennent les deux lex√®mes, mais nous ne pouvons v√©rifier la distance entre eux qu'en regardant tsvector: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Clap your hands, slap your thigh'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector -------------------------------------- 'clap':1 'hand':3 'slap':4 'thigh':6 (1 row)</code> </pre><br>  Dans l'index RUM, chaque lex√®me ne fait pas seulement r√©f√©rence aux lignes du tableau: chaque TID est fourni avec la liste des positions o√π le lex√®me appara√Æt dans le document.  C'est ainsi que l'on peut envisager l'index cr√©√© sur la table "slit-sheet", qui nous est d√©j√† assez familier (la classe d'op√©rateur "rum_tsvector_ops" est utilis√©e par d√©faut pour tsvector): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> rum; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(doc_tsv);</code> </pre><br><br><img src="https://habrastorage.org/webt/k0/up/gn/k0upgnbhka1wfwq6oozy9qo24ka.png"><br><br>  Les carr√©s gris sur la figure contiennent les informations de position ajout√©es: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  GIN fournit √©galement une insertion diff√©r√©e lorsque le param√®tre "fastupdate" est sp√©cifi√©;  cette fonctionnalit√© est supprim√©e de RUM. <br><br>  Pour voir comment l'index fonctionne sur les donn√©es en direct, utilisons l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">archive</a> famili√®re de la liste de diffusion pgsql-hackers. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> default_text_search_config = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">... UPDATE 356125</code> </pre><br>  Voici comment une requ√™te qui utilise la recherche de phrases est effectu√©e avec l'index GIN: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv); fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.490..18.088 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Rows Removed by Index Recheck: 1517 Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual time=2.204..2.204 rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.266 ms Execution time: 18.151 ms (8 rows)</code> </pre><br>  Comme nous pouvons le voir sur le plan, l'index GIN est utilis√©, mais il renvoie 1776 correspondances potentielles, dont 259 sont laiss√©es et 1517 sont supprim√©es au stade de la nouvelle v√©rification. <br><br>  Supprimons l'index GIN et construisons RUM. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_gin; fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> tsv_rum <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv);</code> </pre><br>  L'index contient d√©sormais toutes les informations n√©cessaires et la recherche est effectu√©e avec pr√©cision: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &lt;-&gt; hackers'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on mail_messages (actual time=2.798..3.015 rows=259 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Heap Blocks: exact=250 -&gt; Bitmap Index Scan on tsv_rum (actual time=2.768..2.768 rows=259 loops=1) Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) Planning time: 0.245 ms Execution time: 3.053 ms (7 rows)</code> </pre><br><h2>  Tri par pertinence </h2><br>  Pour renvoyer les documents facilement dans l'ordre requis, l'index RUM prend en charge les op√©rateurs de commande, dont nous avons discut√© dans l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">relatif</a> √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GiST</a> .  L'extension RUM d√©finit un tel op√©rateur, <code>&lt;=&gt;</code> , qui renvoie une certaine distance entre le document ("tsvector") et la requ√™te ("tsquery").  Par exemple: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&amp;gtl to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 16.4493 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>) &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'sheet'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 13.1595 (1 row)</code> </pre><br>  Le document semble √™tre plus pertinent pour la premi√®re requ√™te que pour la seconde: plus le mot appara√Æt souvent, moins il a de ¬´valeur¬ª. <br><br>  Essayons √† nouveau de comparer GIN et RUM sur une taille de donn√©es relativement importante: nous s√©lectionnerons les dix documents les plus pertinents contenant "bonjour" et "pirates". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ts_rank(tsv,to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------- Limit (actual time=27.076..27.078 rows=10 loops=1) -&gt; Sort (actual time=27.075..27.076 rows=10 loops=1) Sort Key: (ts_rank(tsv, to_tsquery('hello &amp; hackers'::text))) Sort Method: top-N heapsort Memory: 29kB -&gt; Bitmap Heap Scan on mail_messages (actual ... rows=1776 loops=1) Recheck Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Heap Blocks: exact=1503 -&gt; Bitmap Index Scan on tsv_gin (actual ... rows=1776 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Planning time: 0.276 ms Execution time: 27.121 ms (11 rows)</code> </pre><br>  L'index GIN renvoie 1776 correspondances, qui sont ensuite tri√©es en tant qu'√©tape distincte pour s√©lectionner les dix meilleurs r√©sultats. <br><br>  Avec l'index RUM, la requ√™te est effectu√©e √† l'aide d'une simple num√©risation d'index: aucun document suppl√©mentaire n'est examin√© et aucun tri s√©par√© n'est requis: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> tsv &lt;=&gt; to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello &amp; hackers'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------- Limit (actual time=5.083..5.171 rows=10 loops=1) -&gt; Index Scan using tsv_rum on mail_messages (actual ... rows=10 loops=1) Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) Order By: (tsv &lt;=&gt; to_tsquery('hello &amp; hackers'::text)) Planning time: 0.244 ms Execution time: 5.207 ms (6 rows)</code> </pre><br><h2>  Informations compl√©mentaires </h2><br>  L'index RUM, ainsi que GIN, peuvent √™tre construits sur plusieurs champs.  Mais alors que GIN stocke les lex√®mes de chaque colonne ind√©pendamment de ceux d'une autre colonne, RUM nous permet ¬´d'associer¬ª le champ principal (¬´tsvector¬ª dans ce cas) √† un autre.  Pour ce faire, nous devons utiliser une classe d'op√©rateur sp√©cialis√©e "rum_tsvector_addon_ops": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(tsv RUM_TSVECTOR_ADDON_OPS, sent) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (ATTACH=<span class="hljs-string"><span class="hljs-string">'sent'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span>=<span class="hljs-string"><span class="hljs-string">'tsv'</span></span>);</code> </pre><br>  Nous pouvons utiliser cet index pour renvoyer les r√©sultats tri√©s sur le champ suppl√©mentaire: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | sent | ?column? ---------+---------------------+---------- 2298548 | 2017-01-01 15:03:22 | 202 2298547 | 2017-01-01 14:53:13 | 407 2298545 | 2017-01-01 13:28:12 | 5508 2298554 | 2017-01-01 18:30:45 | 12645 2298530 | 2016-12-31 20:28:48 | 66672 2298587 | 2017-01-02 12:39:26 | 77966 2298588 | 2017-01-02 12:43:22 | 78202 2298597 | 2017-01-02 13:48:02 | 82082 2298606 | 2017-01-02 15:50:50 | 89450 2298628 | 2017-01-02 18:55:49 | 100549 (10 rows)</code> </pre><br>  Ici, nous recherchons des lignes correspondantes aussi proches que possible de la date sp√©cifi√©e, peu importe plus t√¥t ou plus tard.  Pour obtenir les r√©sultats qui pr√©c√®dent (ou suivent) strictement la date sp√©cifi√©e, nous devons utiliser <code>&lt;=|</code>  (ou <code>|=&gt;</code> ). <br><br>  Comme nous nous y attendons, la requ√™te est effectu√©e simplement par un simple scan d'index: <br><br><pre> <code class="pgsql hljs">ts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, sent, sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent &lt;=&gt; <span class="hljs-string"><span class="hljs-string">'2017-01-01 15:00:00'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Limit -&gt; Index Scan using mail_messages_tsv_sent_idx on mail_messages Index Cond: (tsv @@ to_tsquery('hello'::text)) Order By: (sent &lt;=&gt; '2017-01-01 15:00:00'::timestamp without time zone) (4 rows)</code> </pre><br>  Si nous cr√©ons l'index sans les informations suppl√©mentaires sur l'association de champs, pour une requ√™te similaire, nous devons trier tous les r√©sultats de l'analyse d'index. <br><br>  En plus de la date, nous pouvons certainement ajouter des champs d'autres types de donn√©es √† l'index RUM.  Pratiquement tous les types de base sont pris en charge.  Par exemple, une boutique en ligne peut afficher rapidement les marchandises par nouveaut√© (date), prix (num√©rique) et popularit√© ou valeur de remise (entier ou virgule flottante). <br><br><h2>  Autres classes d'op√©rateurs </h2><br>  Pour compl√©ter le tableau, mentionnons les autres classes d'op√©rateurs disponibles. <br><br>  Commen√ßons par <strong>"rum_tsvector_hash_ops"</strong> et <strong>"rum_tsvector_hash_addon_ops"</strong> .  Ils sont similaires √† "rum_tsvector_ops" et "rum_tsvector_addon_ops" d√©j√† discut√©s, mais l'index stocke le code de hachage du lex√®me plut√¥t que le lex√®me lui-m√™me.  Cela peut r√©duire la taille de l'index, mais bien s√ªr, la recherche devient moins pr√©cise et n√©cessite une nouvelle v√©rification.  En outre, l'index ne prend plus en charge la recherche d'une correspondance partielle. <br><br>  Il est int√©ressant de regarder la classe d'op√©rateur <strong>"rum_tsquery_ops"</strong> .  Il nous permet de r√©soudre un probl√®me "inverse": trouver des requ√™tes qui correspondent au document.  Pourquoi cela pourrait-il √™tre n√©cessaire?  Par exemple, pour abonner un utilisateur √† de nouveaux biens selon son filtre ou pour classer automatiquement les nouveaux documents.  Regardez cet exemple simple: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> categories(query <span class="hljs-type"><span class="hljs-type">tsquery</span></span>, category <span class="hljs-type"><span class="hljs-type">text</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (to_tsquery(<span class="hljs-string"><span class="hljs-string">'vacuum | autovacuum | freeze'</span></span>), <span class="hljs-string"><span class="hljs-string">'vacuum'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'xmin | xmax | snapshot | isolation'</span></span>), <span class="hljs-string"><span class="hljs-string">'mvcc'</span></span>), (to_tsquery(<span class="hljs-string"><span class="hljs-string">'wal | (write &amp; ahead &amp; log) | durability'</span></span>), <span class="hljs-string"><span class="hljs-string">'wal'</span></span>); fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> rum(query); fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> array_agg(category) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> categories <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> to_tsvector( <span class="hljs-string"><span class="hljs-string">'Hello hackers, the attached patch greatly improves performance of tuple freezing and also reduces size of generated write-ahead logs.'</span></span> ) @@ query;</code> </pre><pre> <code class="plaintext hljs"> array_agg -------------- {vacuum,wal} (1 row)</code> </pre><br>  Les classes d'op√©rateurs restantes <strong>"rum_anyarray_ops"</strong> et <strong>"rum_anyarray_addon_ops"</strong> sont con√ßues pour manipuler des tableaux plut√¥t que "tsvector".  Cela a d√©j√† √©t√© discut√© pour GIN la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">derni√®re fois</a> et n'a pas besoin d'√™tre r√©p√©t√©. <br><br><h2>  Tailles de l'index et du journal d'√©criture anticip√©e (WAL) </h2><br>  Il est clair que puisque RUM stocke plus d'informations que GIN, il doit avoir une taille plus grande.  Nous comparions la taille de diff√©rents indices la derni√®re fois;  ajoutons RUM √† ce tableau: <br><br><pre> <code class="plaintext hljs"> rum | gin | gist | btree --------+--------+--------+-------- 457 MB | 179 MB | 125 MB | 546 MB</code> </pre><br>  Comme nous pouvons le voir, la taille a augment√© de mani√®re assez importante, ce qui est le co√ªt d'une recherche rapide. <br><br>  Il convient de pr√™ter attention √† un autre point non √©vident: RUM est une extension, c'est-√†-dire qu'il peut √™tre install√© sans aucune modification du c≈ìur du syst√®me.  Cela a √©t√© activ√© dans la version 9.6 gr√¢ce √† un patch d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexander Korotkov</a> .  Un des probl√®mes qui devait √™tre r√©solu √† cette fin √©tait la g√©n√©ration d'enregistrements de journal.  Une technique de journalisation des op√©rations doit √™tre absolument fiable, par cons√©quent, une extension ne peut pas √™tre laiss√©e dans cette cuisine.  Au lieu de permettre √† l'extension de cr√©er ses propres types d'enregistrements de journal, les √©l√©ments suivants sont en place: le code de l'extension communique son intention de modifier une page, y apporte des modifications et signale l'ach√®vement, et c'est le c≈ìur du syst√®me, qui compare les anciennes et les nouvelles versions de la page et g√©n√®re les enregistrements de journal unifi√©s requis. <br><br>  L'algorithme de g√©n√©ration de journal actuel compare les pages octet par octet, d√©tecte les fragments mis √† jour et enregistre chacun de ces fragments, ainsi que son d√©calage par rapport au d√©but de la page.  Cela fonctionne tr√®s bien lors de la mise √† jour de seulement plusieurs octets ou de la page enti√®re.  Mais si nous ajoutons un fragment √† l'int√©rieur d'une page, en d√©pla√ßant le reste du contenu vers le bas (ou vice versa, en supprimant un fragment, en d√©pla√ßant le contenu vers le haut), beaucoup plus d'octets changeront que ce qui a √©t√© r√©ellement ajout√© ou supprim√©. <br><br>  De ce fait, un indice RUM en constante √©volution peut g√©n√©rer des enregistrements de journal d'une taille consid√©rablement plus grande que GIN (qui, n'√©tant pas une extension, mais une partie du noyau, g√®re le journal de lui-m√™me).  L'ampleur de cet effet g√™nant d√©pend grandement de la charge de travail r√©elle, mais pour avoir un aper√ßu du probl√®me, essayons de supprimer et d'ajouter plusieurs lignes plusieurs fois, entrela√ßant ces op√©rations avec le ¬´vide¬ª.  Nous pouvons √©valuer la taille des enregistrements de journal comme suit: au d√©but et √† la fin, rappelez-vous la position dans le journal en utilisant la fonction "pg_current_wal_location" ("pg_current_xlog_location" dans les versions ant√©rieures √† dix), puis regardez la diff√©rence. <br><br>  Mais bien s√ªr, nous devons consid√©rer de nombreux aspects ici.  Nous devons nous assurer qu'un seul utilisateur travaille avec le syst√®me (sinon, les enregistrements "suppl√©mentaires" seront pris en compte).  M√™me si c'est le cas, nous prenons en compte non seulement RUM, mais aussi les mises √† jour de la table elle-m√™me et de l'index qui supporte la cl√© primaire.  Les valeurs des param√®tres de configuration affectent √©galement la taille (le niveau de journal "r√©plique", sans compression, a √©t√© utilis√© ici).  Mais essayons quand m√™me. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> start_lsn \gset</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3576</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3590</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3605</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">98</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3637</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> mail_messages(parent_id, sent, subject, author, body_plain, tsv) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> parent_id, sent, subject, author, body_plain, tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 3625</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> id % <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">97</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 3668</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> mail_messages;</code> </pre><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_current_wal_location() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> end_lsn \gset fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(:<span class="hljs-string"><span class="hljs-string">'end_lsn'</span></span>::pg_lsn - :<span class="hljs-string"><span class="hljs-string">'start_lsn'</span></span>::pg_lsn);</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 3114 MB (1 row)</code> </pre><br>  Nous obtenons donc environ 3 Go.  Mais si nous r√©p√©tons la m√™me exp√©rience avec l'indice GIN, cela ne fera qu'environ 700 Mo. <br><br>  Par cons√©quent, il est souhaitable d'avoir un algorithme diff√©rent, qui trouvera le nombre minimal d'op√©rations d'insertion et de suppression qui peuvent transformer un √©tat de la page en un autre.  L'utilitaire "Diff" fonctionne de mani√®re similaire.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Oleg Ivanov</a> a d√©j√† impl√©ment√© un tel algorithme, et son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> est en cours de discussion.  Dans l'exemple ci-dessus, ce correctif nous permet de r√©duire la taille des enregistrements de journaux de 1,5 fois, √† 1900 Mo, au prix d'un petit ralentissement. <br><br><blockquote>  Malheureusement, le patch est bloqu√© et il n'y a aucune activit√© autour de lui. <br></blockquote><br><h2>  Propri√©t√©s </h2><br>  Comme d'habitude, regardons les propri√©t√©s de la m√©thode d'acc√®s RUM, en faisant attention aux diff√©rences avec GIN (des requ√™tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ont d√©j√† √©t√© fournies</a> ). <br><br>  Voici les propri√©t√©s de la m√©thode d'acc√®s: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- rum | can_order | f rum | can_unique | f rum | can_multi_col | t rum | can_exclude | t -- f for gin</code> </pre><br>  Les propri√©t√©s de couche d'index suivantes sont disponibles: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | t -- f for gin bitmap_scan | t backward_scan | f</code> </pre><br>  Notez que, contrairement √† GIN, RUM prend en charge l'analyse d'index - sinon, il n'aurait pas √©t√© possible de renvoyer exactement le nombre requis de r√©sultats dans les requ√™tes avec la clause "limit".  Il n'y a pas besoin de l'√©quivalent du param√®tre "gin_fuzzy_search_limit" en cons√©quence.  Et en cons√©quence, l'indice peut √™tre utilis√© pour prendre en charge les contraintes d'exclusion. <br><br>  Les propri√©t√©s de couche de colonne sont les suivantes: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | t -- f for gin returnable | f search_array | f search_nulls | f</code> </pre><br>  La diff√©rence ici est que RUM prend en charge les op√©rateurs de commande.  Cependant, cela n'est pas vrai pour toutes les classes d'op√©rateurs: par exemple, cela est faux pour "tsquery_ops". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452116/">https://habr.com/ru/post/fr452116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452106/index.html">Nous invitons les conf√©renciers √† la r√©union de bricolage d'√©t√© du 16 juin 2019</a></li>
<li><a href="../fr452108/index.html">Docker: des conseils inoffensifs</a></li>
<li><a href="../fr452110/index.html">Automatisez le remplacement de disque avec Ansible</a></li>
<li><a href="../fr452112/index.html">CRM ++</a></li>
<li><a href="../fr452114/index.html">HolyJS 2019: d√©briefing de SEMrush (Partie 1)</a></li>
<li><a href="../fr452118/index.html">Un scientifique rompt le code du myst√©rieux manuscrit de Voynich</a></li>
<li><a href="../fr452122/index.html">"Pilule du d√©mon" en mouvement</a></li>
<li><a href="../fr452124/index.html">¬´Nous avons besoin de connaissances et de r√©alisations¬ª - √† quoi ressemble un testeur chez Alfa-Bank</a></li>
<li><a href="../fr452128/index.html">Id√©es re√ßues sur la r√©sistance aux radiations des microcircuits</a></li>
<li><a href="../fr452130/index.html">La lune se r√©tr√©cit, elle provoque des tremblements de lune</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>