<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏿 🤒 ♎️ 256行裸机C ++：几小时内从头开始编写光线跟踪器 🌆 👲 🤢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我将发布我的计算机图形学课程的下一章（ 在这里，您可以阅读俄语原文，尽管英语版本较新）。 这次，对话的主题是使用光线跟踪绘制场景 。 像往常一样，我会尽量避免使用第三方库，因为这会使学生看起来很隐秘。 

 互联网上已经有很多类似的项目，但是几乎所有这些项目都显示出非常难以理解的完成程序。 例如，这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256行裸机C ++：几小时内从头开始编写光线跟踪器</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436790/"> 我将发布我的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算机图形学课程的</a>下一章（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，您可以阅读</a>俄语原文，尽管英语版本较新）。 这次，对话的主题是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用光线跟踪绘制场景</a> 。 像往常一样，我会尽量避免使用第三方库，因为这会使学生看起来很隐秘。 <br><br> 互联网上已经有很多类似的项目，但是几乎所有这些项目都显示出非常难以理解的完成程序。 例如，这里有一个非常著名的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">渲染程序，可以放在名片上</a> 。 令人印象深刻的结果，但是理解此代码非常困难。 我的目标不是展示自己的能力，而是详细说明如何重现这一点。 而且，在我看来，这堂课对计算机图形学的培训甚至没有什么用，而是作为一种编程工具。 我将始终如一地展示如何从头开始获得最终结果：如何将复杂的问题分解为基本可解决的阶段。 <br><br>  <i>注意：仅查看我的代码，以及仅用手捧着一杯茶阅读这篇文章是没有意义的。</i>  <i>本文旨在帮助您抓住键盘并编写自己的引擎。</i>  <i>他肯定会比我的好。</i>  <i>好吧，或者只是更改编程语言！</i> <br><br> 因此，今天我将展示如何绘制此类图片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1> 第一阶段：将图片保存到磁盘 </h1><br> 我不想打扰窗口管理器，鼠标/键盘处理等。 我们程序的结果将是一张保存到磁盘的简单图片。 因此，我们需要做的第一件事就是将图片保存到磁盘。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这</a>是允许您执行此操作的代码。 让我给你它的主要文件： <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br> 在main函数中，仅调用render（）函数，仅此而已。  render（）函数内部是什么？ 首先，我将图片定义为Vec3f类型的帧缓冲区值的一维数组，这些是简单的三维向量，为我们提供了每个像素的颜色（r，g，b）。 <br><br> 向量的类别存在于geometry.h文件中，这里不再赘述：首先，在那里一切都很琐碎，对二维和三维向量进行简单的操作（加，减，赋值，乘以标量，标量积），其次， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">gbg</a>作为计算机图形学课程的一部分已经对其进行了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细描述</a> 。 <br><br> 我将图片保存为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ppm格式</a> ; 尽管并非总是最方便的进一步查看方式，但这是保存图像的最简单方法。 如果要保存为其他格式，我仍然建议连接第三方库，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">stb</a> 。 这是一个很棒的库：在项目中包含一个头文件stb_image_write.h就足够了，这甚至可以保存为png和jpg。 <br><br> 总而言之，此阶段的目标是确保我们可以a）在内存中创建图片并在其中写入不同的颜色值b）将结果保存到磁盘，以便可以在第三方程序中查看。 结果如下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1> 第二阶段，最困难的是：直接光线跟踪 </h1><br> 这是整个链中最重要和最困难的阶段。 我想在代码中定义一个球体，并在屏幕上显示它，而不会打扰材质或照明。 这是我们的结果应如下所示： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br> 为了方便起见，在我的存储库中，每个阶段都有一个提交；  Github使得查看更改非常方便。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例如</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里，</a>与第一次提交相比，第二次提交中发生了什么变化。 <br><br> 首先：我们需要在计算机内存中代表一个球形吗？ 对于我们来说，四个数字就足够了：一个具有球体中心的三维矢量和一个描述半径的标量： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br> 这段代码中唯一不平凡的事情是一个函数，该函数使您可以检查给定的射线（从orig起源于dir方向）是否与我们的球体相交。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处阅读</a>有关检查光束与球面相交的算法的详细说明，我强烈建议您这样做并检查我的代码。 <br><br> 光线追踪如何工作？ 很简单 在第一阶段，我们仅用渐变覆盖图像： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br> 现在，对于每个像素，我们将形成一条来自坐标中心并穿过像素的射线，并检查该射线是否与我们的球面相交。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br> 如果没有与球体相交，则将放置color1，否则放置color2： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre><br> 在这一点上，我建议用铅笔在纸上检查所有计算，包括光线与球体的交点以及光线对图片的扫描。 以防万一，我们的相机由以下因素决定： <br><br><ul><li> 影像宽度 </li><li> 图片高度 </li><li> 视角，前视 </li><li> 摄像头位置Vec3f（0,0,0） </li><li> 沿z轴的注视方向为负无穷大方向 </li></ul><br><h1> 第三阶段：添加更多球体 </h1><br> 最艰难的时刻已经过去，现在我们的道路万里无云。 如果我们能画一个球体。 那么显然再增加一些工作并不困难。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里您可以</a>看到代码中的更改，结果如下： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1> 第四阶段：照明 </h1><br> 每个人都擅长于我们的照片，但这仅仅是光线不足。 在本文的其余部分中，我们只会谈论这一点。 添加一些点光源： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br> 考虑到真实的照明是一项非常非常艰巨的任务，因此，像其他所有人一样，我们将通过绘制完全不真实，但最可能，最合理的结果来欺骗眼睛。 第一句话：为什么冬天冷，夏天热？ 因为加热地球表面取决于阳光的入射角。 地平线上方的太阳越高，则照亮的表面越亮。 反之亦然，视野越低，强度就越弱。 好吧，太阳落山之后，光子根本无法到达我们。 关于我们的球体：这是我们从相机发出的光束（与光子无关，请注意！）与球体相交。 我们如何了解交点是如何照亮的？ 您可以简单地查看此点的法向矢量和描述光的方向的矢量之间的角度。 角度越小，表面照明越好。 为了使其更加方便，您可以简单地将法线向量和光照向量之间的标量乘积。 我记得两个向量a和b之间的标量乘积等于向量范数乘以向量之间角度的余弦值的乘积：a * b = | a |  | b |  cos（alpha（a，b））。 如果我们采用单位长度的矢量，那么最简单的标量积将为我们提供表面照明的强度。 <br><br> 因此，在cast_ray函数中，我们将考虑光源的情况下返回颜色，而不是恒定的颜色： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请在此处查看</a>更改，但<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">查看</a>程序的结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1> 第五阶段：有光泽的表面 </h1><br> 在法向矢量和光矢量之间具有标量积的技巧可以很好地逼近粗糙表面的照明，在文献中将其称为漫射照明。 如果我们想要光滑有光泽怎么办？ 我想得到这张照片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br> 看看需要进行的更改<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很少</a> 。 简而言之，发亮表面上的反射越亮，视角方向与<i>反射</i>光方向之间的角度越小。 好吧，当然，我们将像以前一样遍历标量产品。 <br><br> 这种带有哑光和发光表面的体操被称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Phong模型</a> 。  Wiki对这种光照模型有相当详细的描述；与我的代码并行比较时，它读起来很好。 这是要了解的关键图片： <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1> 第六阶段：阴影 </h1><br> 为什么我们有光却没有阴影？ 乱！ 我想要这张照片： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">只有六行代码</a>允许我们实现这一点：绘制每个点时，我们仅要确保点光源不与场景对象相交，如果确实相交，则当前光源将跳过。 只有一点点微妙之处：我将点向法线方向移动一点： <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br> 怎么了 是的，只是我们的点位于对象的表面上，并且（不包括数字误差）该点的任何光线都将穿过我们的场景。 <br><br><h1> 第七步：思考 </h1><br> 这令人难以置信，但是要将反射添加到场景中，我们只需要添加三行代码： <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br> 亲眼<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">看看：</a>在与对象的交点处，我们只需对反射光线进行计数（从计算凹凸起的函数就派上用场了！），然后在反射射线的方向上递归调用cast_ray函数。 确保使用<a href="">递归深度</a> ，将其设置为4，从头开始，图片会发生什么变化？ 这是我的工作反射和四个深度的结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1> 第八阶段：折射 </h1><br> 通过学习计算反射， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以计算出完全相同的折射</a> 。 一个函数可让您计算折射射线的方向（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">根据斯涅尔定律</a> ），递归函数cast_ray中包含三行代码。 结果是，最近的球变成“玻璃”，它折射并稍微反射： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1> 阶段九：添加更多对象 </h1><br> 为什么我们所有人都没有牛奶，但是没有牛奶。 在此之前，我们仅渲染球体，因为这是最简单的非平凡数学对象之一。 让我们添加一个平面。 这种类型的经典作品是棋盘。 为此，考虑到光束与场景相交的函数中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">十几条线</a>对我们来说已经足够了。 <br><br> 好吧，这是结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br> 正如我所承诺的那样，准确地计算256行代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">就可以为自己计算</a> ！ <br><br><h1> 第十阶段：作业 </h1><br> 我们已经走了很长一段路：我们学习了如何在场景中添加对象，如何考虑相当复杂的照明。 让我把两项任务留作功课。 绝对所有的准备工作都已经在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">homework_assignment</a>分支中完成了。 每个作业最多需要十行代码。 <br><br><h3> 任务一：环境图 </h3><br> 目前，如果光束没有穿过场景，那么我们只需将其设置为恒定的颜色即可。 为何实际上是永久性的？ 让我们拍一张球形照片（ <a href="">envmap.jpg</a>文件）并将其用作背景！ 为了使生活更轻松，我将我们的项目与stb库链接在一起，以方便使用jpeg。 这应该是这样的渲染： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3> 第二项任务：嘎嘎！ </h3><br> 我们可以同时渲染球体和平面（请参见棋盘）。 因此，让我们添加一个三角模型图！ 我编写了代码以读取三角形的网格，并在其中添加了射线-三角形相交函数。 现在，将鸭子添加到我们的场景中应该是微不足道的！ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1> 结论 </h1><br> 我的主要任务是显示有趣（容易）的项目进行编程，我真的希望我能做到。 这一点非常重要，因为我坚信程序员应该写很多又有品位的东西。 我不了解您，但是个人会计和精打细算的代码复杂程度相当，根本无法吸引我。 <br><br> 实际上，可以在几个小时内写出250行光线追踪。 几天内可以掌握<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">五百行</a>软件光栅化器。 下次，我们将对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">广播</a>进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分类</a> ，同时，我还将展示我的一年级学生在教授C ++编程时编写的最简单的游戏。 敬请期待！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436790/">https://habr.com/ru/post/zh-CN436790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436778/index.html">defi.js是一个基于Object.defineProperty的反应式库</a></li>
<li><a href="../zh-CN436780/index.html">Google Play即时开发的陷阱</a></li>
<li><a href="../zh-CN436784/index.html">顶针（Mozilla）移至毛刺</a></li>
<li><a href="../zh-CN436786/index.html">我们如何监控Black Hat Europe 2018</a></li>
<li><a href="../zh-CN436788/index.html">在企业环境中部署Office 2019（适用于IT专业人员）</a></li>
<li><a href="../zh-CN436792/index.html">DEFCON会议19.匿名，我们。 第一部分</a></li>
<li><a href="../zh-CN436828/index.html">向Boost-1.65.1的过渡和出现的错误</a></li>
<li><a href="../zh-CN436830/index.html">直到2019年的Android机器人技术：真实的故事； 分5部分； 第5部分</a></li>
<li><a href="../zh-CN436836/index.html">分析防火墙中的7级应用程序的好处。 第2部分。安全性</a></li>
<li><a href="../zh-CN436838/index.html">通过PyTorch中的可视化了解卷积神经网络</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>