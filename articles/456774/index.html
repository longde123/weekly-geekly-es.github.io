<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📊 👩🏿‍🍳 👨🏼‍🚀 Lo que extraño en Java después de trabajar con Kotlin / Scala 💇🏽 🥦 ✌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, a menudo escucho que Java se ha convertido en un lenguaje obsoleto en el que es difícil construir grandes aplicaciones compatibles. En ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo que extraño en Java después de trabajar con Kotlin / Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/456774/">  Recientemente, a menudo escucho que Java se ha convertido en un lenguaje obsoleto en el que es difícil construir grandes aplicaciones compatibles.  En general, no estoy de acuerdo con este punto de vista.  En mi opinión, el lenguaje sigue siendo adecuado para escribir aplicaciones rápidas y bien organizadas.  Sin embargo, lo admito, también sucede que cuando escribes código todos los días, a veces piensas: "qué tan bien se resolvería con esto desde otro idioma".  En este artículo, quería compartir mi dolor y experiencia.  Analizaremos algunos problemas de Java y cómo podrían resolverse en Kotlin / Scala.  Si tiene una sensación similar o simplemente se pregunta qué pueden ofrecer otros idiomas, le pregunto bajo cat. <br><br><img src="https://habrastorage.org/webt/gs/ur/yw/gsurywchgpevsavhgdjdaw1_sw4.jpeg"><br><a name="habracut"></a><br><h3>  Extender clases existentes </h3><br>  A veces sucede que es necesario expandir una clase existente sin cambiar su contenido interno.  Es decir, después de crear la clase, la complementamos con otras clases.  Considere un pequeño ejemplo.  Supongamos que tenemos una clase que es un punto en el espacio bidimensional.  En diferentes lugares de nuestro código, necesitamos serializarlo tanto en Json como en XML. <br><br><div class="spoiler">  <b class="spoiler_title">Veamos cómo puede verse en Java usando el patrón Visitor</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DotDemo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dot</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Visitor visitor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> visitor.visit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dot dot)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonVisitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dot dot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String .format(<span class="hljs-string"><span class="hljs-string">""</span></span> + <span class="hljs-string"><span class="hljs-string">"{"</span></span> + <span class="hljs-string"><span class="hljs-string">"\"x\"=%d, "</span></span> + <span class="hljs-string"><span class="hljs-string">"\"y\"=%d "</span></span> + <span class="hljs-string"><span class="hljs-string">"}"</span></span>, dot.getX(), dot.getY()); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XMLVisitor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Visitor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">visit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dot dot)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;dot&gt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" &lt;x&gt;"</span></span> + dot.getX() + <span class="hljs-string"><span class="hljs-string">"&lt;/x&gt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">" &lt;y&gt;"</span></span> + dot.getY() + <span class="hljs-string"><span class="hljs-string">"&lt;/y&gt;"</span></span> + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + <span class="hljs-string"><span class="hljs-string">"&lt;/dot&gt;"</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Dot dot = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dot(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"-------- JSON -----------"</span></span>); System.out.println(dot.accept(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonVisitor())); System.out.println(<span class="hljs-string"><span class="hljs-string">"-------- XML ------------"</span></span>); System.out.println(dot.accept(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLVisitor())); } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más información sobre el patrón y su uso.</a> <br></div></div><br>  Se ve bastante voluminoso, ¿verdad?  ¿Es posible resolver este problema de manera más elegante con la ayuda de herramientas de lenguaje?  Scala y Kotlin asienten positivamente.  Esto se logra utilizando el mecanismo de extensión del método.  Veamos como se ve. <br><br><div class="spoiler">  <b class="spoiler_title">Extensiones en Kotlin</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dot</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      fun Dot.convertToJson(): String = "{\"x\"=$x, \"y\"=$y}" fun Dot.convertToXml(): String = """&lt;dot&gt; &lt;x&gt;$x&lt;/x&gt; &lt;y&gt;$y&lt;/y&gt; &lt;/dot&gt;""" fun main() { val dot = Dot(1, 2) println("-------- JSON -----------") println(dot.convertToJson()) println("-------- XML -----------") println(dot.convertToXml()) }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Extensiones en Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DotDemo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// val is default case class Dot(x: Int, y: Int) implicit class DotConverters(dot: Dot) { def convertToJson(): String = s"""{"x"=${dot.x}, "y"=${dot.y}}""" def convertToXml(): String = s"""&lt;dot&gt; &lt;x&gt;${dot.x}&lt;/x&gt; &lt;y&gt;${dot.y}&lt;/y&gt; &lt;/dot&gt;""" } val dot = Dot(1, 2) println("-------- JSON -----------") println(dot.convertToJson()) println("-------- XML -----------") println(dot.convertToXml()) }</span></span></code> </pre><br></div></div><br>  Se ve mucho mejor.  A veces esto no es suficiente con un mapeo abundante y otras transformaciones. <br><br><h3>  Cadena informática multiproceso </h3><br>  Ahora todo el mundo habla de computación asincrónica y las prohibiciones de bloquear hilos de ejecución.  Imaginemos el siguiente problema: tenemos varias fuentes de números, donde el primero solo devuelve el número, el segundo, devuelve la respuesta después de calcular el primero.  Como resultado, debemos devolver una cadena con dos números. <br><br><div class="spoiler">  <b class="spoiler_title">Esquemáticamente, esto se puede representar de la siguiente manera</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sl/en/2s/slen2s9wvmnlguh2sh1nh8435au.png"><br></div></div><br>  Intentemos resolver el problema en Java primero <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de Java</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CompletableFuture&lt;Optional&lt;String&gt;&gt; calcResultOfTwoServices ( Supplier&lt;Optional&lt;Integer&gt;&gt; getResultFromFirstService, Function&lt;Integer, Optional&lt;Integer&gt;&gt; getResultFromSecondService ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture .supplyAsync(getResultFromFirstService) .thenApplyAsync(firstResultOptional -&gt; firstResultOptional.flatMap(first -&gt; getResultFromSecondService.apply(first).map(second -&gt; first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second ) ) ); }</code> </pre> <br></div></div><br>  En este ejemplo, nuestro número está envuelto en Opcional para controlar el resultado.  Además, todas las acciones se realizan dentro de CompletableFuture para un trabajo conveniente con subprocesos.  La acción principal tiene lugar en el método thenApplyAsync.  En este método, obtenemos Opcional como argumento.  A continuación, se llama a flatMap para controlar el contexto.  Si el Opcional recibido regresó como Opcional.empty, entonces no iremos al segundo servicio. <br><br>  ¿El total que recibimos?  Al usar las características CompletableFuture y Opcional con flatMap y map, pudimos resolver el problema.  Aunque, en mi opinión, la solución no se ve de la manera más elegante: antes de comprender qué sucede, debe leer el código.  ¿Y qué pasaría con dos o más fuentes de datos? <br><br>  ¿Podría el lenguaje ayudarnos de alguna manera a resolver el problema?  Y de nuevo, dirígete a Scala.  Así es como puede resolverlo con las herramientas Scala. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcResultOfTwoServices</span></span></span></span>(getResultFromFirstService: <span class="hljs-type"><span class="hljs-type">Unit</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], getResultFromSecondService: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]) = <span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromFirstService() }.flatMap { firsResultOption =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> { firsResultOption.flatMap(first =&gt; getResultFromSecondService(first).map(second =&gt; <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$second</span></span></span><span class="hljs-string">"</span></span> ) )} }</code> </pre> <br></div></div><br>  Se ve familiar.  Y esto no es casualidad.  Utiliza la biblioteca scala.concurrent, que es principalmente un contenedor sobre java.concurrent.  Bueno, ¿con qué más nos puede ayudar Scala?  El hecho es que las cadenas de la forma flatMap, ..., map se pueden representar como una secuencia para. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de segunda versión en Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcResultOfTwoServices</span></span></span></span>(getResultFromFirstService: <span class="hljs-type"><span class="hljs-type">Unit</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], getResultFromSecondService: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]) = <span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromFirstService() }.flatMap { firstResultOption =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { first &lt;- firstResultOption second &lt;- getResultFromSecondService(first) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$second</span></span></span><span class="hljs-string">"</span></span> } }</code> </pre> <br></div></div><br>  Ha mejorado, pero intentemos cambiar nuestro código nuevamente.  Conecta la biblioteca de gatos. <br><br><div class="spoiler">  <b class="spoiler_title">Tercera versión del ejemplo de Scala</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.instances.future._ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calcResultOfTwoServices</span></span></span></span>(getResultFromFirstService: <span class="hljs-type"><span class="hljs-type">Unit</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>], getResultFromSecondService: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]] = (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { first &lt;- <span class="hljs-type"><span class="hljs-type">OptionT</span></span>(<span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromFirstService() }) second &lt;- <span class="hljs-type"><span class="hljs-type">OptionT</span></span>(<span class="hljs-type"><span class="hljs-type">Future</span></span> { getResultFromSecondService(first) }) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$second</span></span></span><span class="hljs-string">"</span></span>).value</code> </pre> <br></div></div><br>  Ahora no es tan importante lo que significa OptionT.  Solo quiero mostrar cuán simple y breve puede ser esta operación. <br><br>  ¿Pero qué hay de Kotlin?  Tratemos de hacer algo similar en las corutinas. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de Kotlin</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = async { withContext(Dispatchers.Default) { getResultFromFirstService() }?.let { first -&gt; withContext(Dispatchers.Default) { getResultFromSecondService(first) }?.let { second -&gt; <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> } } }</code> </pre> <br></div></div><br>  Este código tiene sus propias peculiaridades.  Primero, utiliza el mecanismo Kotlin de la corutina.  Las tareas dentro de asíncrono se realizan en un grupo de subprocesos especial (no ForkJoin) con un mecanismo de robo de trabajo.  En segundo lugar, este código requiere un contexto especial, del que se toman palabras clave como async y withContext. <br><br>  Si te gustó Scala Future, pero escribes en Kotlin, entonces puedes prestar atención a envoltorios Scala similares.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Escribe tal.</a> <br><br><h4>  Trabaja con streams </h4><br>  Para mostrar el problema con más detalle arriba, intentemos expandir el ejemplo anterior: recurrimos a las herramientas de programación Java más populares - <i>Reactor</i> , en Scala - <i>fs2</i> . <br><br>  Considere la lectura línea por línea de 3 archivos en una secuencia e intente encontrar coincidencias allí. <br>  Aquí está la forma más fácil de hacer esto con Reactor en Java. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de reactor en Java</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Flux&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glueFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filename1, String filename2, String filename3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getLinesOfFile(filename1).flatMap(lineFromFirstFile -&gt; getLinesOfFile(filename2) .filter(line -&gt; line.equals(lineFromFirstFile)) .flatMap(lineFromSecondFile -&gt; getLinesOfFile(filename3) .filter(line -&gt; line.equals(lineFromSecondFile)) .map(lineFromThirdFile -&gt; lineFromThirdFile ) ) ); }</code> </pre> <br></div></div><br>  No es la forma más óptima, sino indicativa.  No es difícil adivinar que con más lógica y acceso a recursos de terceros, la complejidad del código crecerá.  Veamos la sintaxis de azúcar para la comprensión alternativa. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de fs2 en Scala</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUniqueLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename1: String, filename2: String, filename3: String)</span></span></span><span class="hljs-function">: Stream[IO, String] </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { lineFromFirstFile &lt;- readFile(filename1) lineFromSecondFile &lt;- readFile(filename2).filter(_.equals(lineFromFirstFile)) result &lt;- readFile(filename3).filter(_.equals(lineFromSecondFile)) } yield result</code> </pre> <br></div></div><br>  Parece que no hay muchos cambios, pero se ve mucho mejor. <br><br><h4>  Separar la lógica de negocios con una clase superior e implícita </h4><br>  Sigamos adelante y veamos cómo podemos mejorar nuestro código.  Quiero advertir que la siguiente parte puede no ser inmediatamente comprensible.  Quiero mostrar las posibilidades y dejar el método de implementación fuera de los corchetes por ahora.  Una explicación detallada requiere al menos un artículo separado.  Si hay un deseo / comentarios, seguiré los comentarios para responder preguntas y escribiré la segunda parte con una descripción más detallada :) <br><br>  Por lo tanto, imagine un mundo en el que podamos establecer la lógica empresarial independientemente de los efectos técnicos que puedan surgir durante el desarrollo.  Por ejemplo, podemos hacer que cada solicitud posterior a un DBMS o un servicio de terceros se realice en un hilo separado.  En las pruebas unitarias, necesitamos hacer una estúpida simulación en la que no pasa nada.  Y así sucesivamente. <br><br>  Quizás algunas personas pensaron en el motor BPM, pero hoy no se trata de él.  Resulta que este problema puede resolverse con la ayuda de algunos patrones de programación funcional y soporte de lenguaje.  En un lugar podemos describir la lógica de esta manera. <br><br><div class="spoiler">  <b class="spoiler_title">En un lugar, podemos describir la lógica como esta</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCatHappy</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>[_]: <span class="hljs-type"><span class="hljs-type">Monad</span></span>: <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>](): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { catId &lt;- <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>].getHungryCat memberId &lt;- <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>].getFreeMember _ &lt;- <span class="hljs-type"><span class="hljs-type">CatClinicClient</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>].feedCatByFreeMember(catId, memberId) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> ()</code> </pre> <br></div></div><br>  Aquí F [_] (leído como "ef con un agujero") significa un tipo sobre un tipo (a veces se llama una especie en la literatura rusa).  Puede ser Lista, Conjunto, Opción, Futuro, etc.  Todo eso es un contenedor de un tipo diferente. <br><br>  A continuación, solo cambiamos el contexto de la ejecución del código.  Por ejemplo, para el entorno de producción podemos hacer algo como esto. <br><br><div class="spoiler">  <b class="spoiler_title">¿Cómo podría ser el código de combate?</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RealCatClinicClient</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatClinicClient</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Future</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHungryCat</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-type"><span class="hljs-type">Future</span></span> { <span class="hljs-type"><span class="hljs-type">Thread</span></span>.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// doing some calls to db (waiting 1 second) 40 } override def getFreeMember: Future[Int] = Future { Thread.sleep(1000) // doing some calls to db (waiting 1 second) 2 } override def feedCatByFreeMember(catId: Int, memberId: Int): Future[Unit] = Future { Thread.sleep(1000) // happy cat (waiting 1 second) println("so testy!") // Don't do like that. It is just for debug } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Cómo se vería el código de prueba</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MockCatClinicClient</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CatClinicClient</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHungryCat</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Id</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFreeMember</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Id</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">feedCatByFreeMember</span></span></span></span>(catId: <span class="hljs-type"><span class="hljs-type">Int</span></span>, memberId: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Id</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = { println(<span class="hljs-string"><span class="hljs-string">"so testy!"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Don't do like that. It is just for debug } }</span></span></code> </pre> <br></div></div><br>  Nuestra lógica de negocios ahora no depende de qué marcos, clientes http y servidores usamos.  En cualquier momento, podemos cambiar el contexto y la herramienta cambiará. <br><br>  Esto se logra mediante características tales como higherKind e implícito.  Consideremos el primero, y para esto volveremos a Java. <br><br><div class="spoiler">  <b class="spoiler_title">Miremos el código</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calcer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> CompletableFuture&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCalc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br></div></div><br>  ¿Cuántas formas de devolver el resultado?  Bastante mucho.  Podemos restar, sumar, intercambiar y mucho más.  Ahora imagine que se nos han dado requisitos claros.  Necesitamos agregar el primer número al segundo.  ¿De cuántas maneras podemos hacer esto?  <s>si te esfuerzas y te refinas mucho ...</s> en general, solo uno. <br><br><div class="spoiler">  <b class="spoiler_title">Aqui esta</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calcer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> CompletableFuture&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCalc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CompletableFuture.supplyAsync(() -&gt; x + y); } }</code> </pre> <br></div></div><br>  Pero, ¿qué sucede si la llamada a este método está oculta y queremos probar en un entorno de subproceso único?  O qué pasa si queremos cambiar la implementación de la clase eliminando / reemplazando CompletableFuture.  Desafortunadamente, en Java somos impotentes y tenemos que cambiar el método API.  Echa un vistazo a la alternativa en Scala. <br><br><div class="spoiler">  <b class="spoiler_title">Considerar rasgo</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calcer</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCulc</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">Int</span></span>, y: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] }</code> </pre><br></div></div><br>  Creamos rasgos (el análogo más cercano es la interfaz en Java) sin especificar el tipo de contenedor de nuestro valor entero. <br><br>  Además, simplemente podemos crear varias implementaciones si es necesario. <br><br><div class="spoiler">  <b class="spoiler_title">Como asi</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> futureCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> {x + y} <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> optionCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>(x + y)</code> </pre><br></div></div><br>  Además, hay algo tan interesante como lo implícito.  Le permite crear el contexto de nuestro entorno y seleccionar implícitamente la implementación del rasgo basado en él. <br><br><div class="spoiler">  <b class="spoiler_title">Como asi</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userCalcer</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>[_]](<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> calcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>]): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = calcer.getCulc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doItInFutureContext</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> futureCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span> {x + y} println(userCalcer) } doItInFutureContext() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doItInOptionContext</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> optionCalcer: <span class="hljs-type"><span class="hljs-type">Calcer</span></span>[<span class="hljs-type"><span class="hljs-type">Option</span></span>] = (x, y) =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>(x + y) println(userCalcer) } doItInOptionContext()</code> </pre> <br></div></div><br>  Simplificado implícito antes de val: agregar una variable al entorno actual e implícito como argumento de una función significa tomar la variable del entorno.  Esto recuerda un poco a un cierre implícito. <br><br>  En conjunto, resulta que podemos crear un entorno de combate y prueba de manera bastante concisa sin usar bibliotecas de terceros. <br><div class="spoiler">  <b class="spoiler_title">¿Pero qué hay de Kotlin?</b> <div class="spoiler_text">  En realidad, de manera similar, podemos hacer en Kotlin: <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: T } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> FutureCalculator : Calculator&lt;CompletableFuture&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = CompletableFuture.supplyAsync { x + y } } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> OptionalCalculator : Calculator&lt;Optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = Optional.of(x + y) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Calculator</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useCalculator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = eval(<span class="hljs-number"><span class="hljs-number">1</span></span>, y) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { with (FutureCalculator) { println(useCalculator(<span class="hljs-number"><span class="hljs-number">2</span></span>)) } with (OptionalCalculator) { println(useCalculator(<span class="hljs-number"><span class="hljs-number">2</span></span>)) } }</code> </pre> <br>  Aquí también establecemos el contexto de ejecución de nuestro código, pero a diferencia de Scala, lo marcamos explícitamente. <br>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Beholder</a> por el ejemplo. <br></div></div><br><br><h4>  Conclusión </h4><br>  En general, estos no son todos mis dolores.  Hay mas.  Creo que cada desarrollador tiene el suyo.  Por mi parte, me di cuenta de que lo principal es entender lo que realmente es necesario para el beneficio del proyecto.  Por ejemplo, en mi opinión, si tenemos un servicio de descanso que actúa como un tipo de adaptador con un montón de mapeo y lógica simple, entonces toda la funcionalidad anterior no es muy útil.  Spring Boot + Java / Kotlin es perfecto para tales tareas.  Hay otros casos con una gran cantidad de integraciones y agregación de cierta información.  Para tales tareas, en mi opinión, la última opción se ve muy bien.  En general, es genial si puedes elegir una herramienta basada en una tarea. <br><br>  Recursos utiles: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace a todos los ejemplos completos anteriores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Más sobre Corotin en Kotlin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un buen libro introductorio sobre programación funcional en Scala</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456774/">https://habr.com/ru/post/456774/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456760/index.html">Crowdsourcing en ML Boot Camp. Consideramos mIOU sin imágenes para una nueva tarea de Odnoklassniki</a></li>
<li><a href="../456762/index.html">De Witcher 3 a Cyberpunk: la evolución del diseño de CD Projekt Quest</a></li>
<li><a href="../456768/index.html">4 dificultades para localizar juegos móviles usando Fishing Clash como ejemplo - traducción</a></li>
<li><a href="../456770/index.html">Carrera armamentista</a></li>
<li><a href="../456772/index.html">Fusiones y adquisiciones para equipos de proyecto: ¿Cómo gestionar los datos y procesos del proyecto de manera efectiva?</a></li>
<li><a href="../456780/index.html">9 maneras de impulsar la eficiencia del desarrollador de aplicaciones móviles</a></li>
<li><a href="../456782/index.html">Diseño orientado a modelos: cómo no repetir Chernobyl</a></li>
<li><a href="../456790/index.html">Resumen de noticias de PostgreSQL. Edición n. 16</a></li>
<li><a href="../456792/index.html">Implemente Kubernetes Cluster en OpenStack con Kubespray</a></li>
<li><a href="../456794/index.html">Arquitectura de la interfaz de usuario web: un pasado de madera, un presente extraño y un futuro brillante</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>