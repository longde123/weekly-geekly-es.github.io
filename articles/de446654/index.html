<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ üñïüèΩ Wie wir die Code√ºberpr√ºfung gespeichert haben üåü ‚òÇÔ∏è üì∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin ein f√ºhrender Java-Entwickler bei Yandex.Money. 


 An jedem Arbeitsmorgen im Jahr 2018 warteten ungef√§hr 30 Pull-Anfragen auf eine √úberpr√ºfun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die Code√ºberpr√ºfung gespeichert haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/446654/"><p><img src="https://habrastorage.org/webt/6x/su/21/6xsu21mfqcq5d7qqvafxwbmkdgq.png"></p><br><p>  Ich bin ein f√ºhrender Java-Entwickler bei Yandex.Money. </p><br><p>  An jedem Arbeitsmorgen im Jahr 2018 warteten ungef√§hr 30 Pull-Anfragen auf eine √úberpr√ºfung, und ich hatte nicht genug Zeit, um sie alle an einem Tag zu sortieren.  Am Ende des Sommers machte ich Urlaub und als ich zur√ºckkam, fand ich eine Warteschlange von 50 PR, die mir zugewiesen war.  Es gab keine Lust, sie zu harken, aber tats√§chlich war es nur die Spitze des Eisbergs, die ich mit meinen eigenen Augen sah.  An diesem Tag entschied ich, dass es Zeit war, etwas zu √§ndern. </p><br><p>  Dies ist eine Geschichte dar√ºber, wie wir die Code√ºberpr√ºfung beschleunigt, die f√ºhrenden Entwickler entladen und die Tools verbessert haben, die wir jeden Tag verwenden. </p><a name="habracut"></a><br><h2 id="kod-revyu-10-kak-bylo-ranshe">  Code Review 1.0.  Wie war es vorher? </h2><br><p>  In Yandex.Money war eine Code√ºberpr√ºfung lange Zeit eine obligatorische Entwicklungsphase, und jeder war lange daran gew√∂hnt.  Einige erkannten, dass dies genauso eine Sache war wie das Testen;  andere betrachteten dies als notwendiges √úbel, und jemand stie√ü nur als Autor von Pull-Anfragen auf eine Code√ºberpr√ºfung, verzichtete jedoch auf die Code√ºberpr√ºfung eines anderen.  Ich denke, dass viele nacheinander vom letzten zum ersten gereist sind, und das ist normal. </p><br><p>  F√ºr die Code√ºberpr√ºfung haben wir von Anfang an Bitbucket verwendet.  F√ºr jedes Komponenten-Repository wurde eine Liste mit 3-4 Standardpr√ºfern hinzugef√ºgt, die allen PRs hinzugef√ºgt wurden.  Normalerweise wurde diese Liste vom Abteilungsleiter zusammengestellt und bearbeitet, und manchmal wurden dort Freiwillige hinzugef√ºgt, die selbst eine bestimmte Komponente √ºberpr√ºfen wollten.  Die Bibliotheks-Repositorys waren etwas einfacher - die Liste der Pr√ºfer war f√ºr alle Bibliotheken gleich, und leitende Entwickler wurden dort aufgenommen. </p><br><p>  Infolgedessen fiel fast die gesamte Belastung auf die Pr√ºfer unter den leitenden Entwicklern, die nach und nach nicht mehr ausreichten. Dies ber√ºcksichtigte das Wachstum der Abteilung auf 60 Mitarbeiter, die Zunahme der Anzahl der Repositories (√ºber 60 Komponenten, √ºber 100 Bibliotheken) und die Beschleunigung unserer CI / CD. </p><br><p>  Neben der hohen Arbeitsbelastung und dem Mangel an Ressourcen f√ºr Pr√ºfer gab es weitere Probleme: </p><br><ul><li>  in einigen Komponenten k√∂nnte man eine Reaktion der Rezensenten f√ºr mehr als einen Tag erwarten, </li><li>  hohe Arbeitsbelastung der als Gutachter ernannten Personen in mehreren Komponenten, </li><li>  Es ist schwierig, neue Rezensenten zu gewinnen, auch aufgrund des vorherigen Absatzes. </li><li>  Wenn der Hauptpr√ºfer krank wurde oder im Urlaub war, nahm die √úberpr√ºfung des Zeitcodes der Komponenten merklich zu. </li><li>  Die benannten Pr√ºfer verf√ºgten nicht immer √ºber echte Fachkenntnisse in der Komponente, da die Qualit√§t der Code√ºberpr√ºfung darunter litt. </li></ul><br><p>  Bevor Sie diese Probleme l√∂sen, m√ºssen Sie entscheiden, was wir im Allgemeinen von einer Code√ºberpr√ºfung erwarten. </p><br><h2 id="pravilnoe-kod-revyu--eto-kak">  Die richtige Code√ºberpr√ºfung ist wie? </h2><br><p>  Wir haben vier Punkte identifiziert, die in der aktualisierten Code√ºberpr√ºfung enthalten sein sollten: </p><br><ol><li>  <strong>√úberpr√ºfen Sie die L√∂sungsarchitektur</strong> .  Ziemlich offensichtliche Sache.  Wir erwarten dies von erfahrenen Entwicklern mit Fachkenntnissen in dieser Komponente. </li><li>  <strong>√úberpr√ºfung der technischen Umsetzung</strong> , die wir auch von hochrangigen und mittleren Spezialisten mit Fachkenntnissen in dieser Komponente erwarten. </li><li>  <strong>Der Wissenstransfer</strong> , der in der Untersuchung der Gesch√§ftslogik und der Codebasis durch Anf√§nger und Juni durch Code√ºberpr√ºfungen besteht. </li><li> <strong>F√§higkeit, die harten F√§higkeiten von Entwicklern zu bewerten</strong> .  Ich m√∂chte, dass jedem Entwickler ein Mentor zugewiesen wird, der das Wachstum bewertet, den Entwicklungsvektor bestimmt, einige M√§ngel feststellt, Kommentare abgibt und so weiter.  Daher sollte der Mentor auch den Code seiner Schutzzauber sehen. </li></ol><br><p>  Vielleicht sieht jemand andere Ziele oder ist mit unseren nicht einverstanden - teilen Sie in den Kommentaren.  In der Zwischenzeit werde ich von der Formulierung von Zielen zur Suche nach Mitteln zur Erreichung dieser Ziele √ºbergehen - wir haben beschlossen, dass wir alle und (fast) sofort erreichen wollen. </p><br><h2 id="kod-revyu-20-kak-stalo">  Code Review 2.0.  Wie ist es </h2><br><p>  Was haben wir uns ausgedacht?  Wir begannen Schritt f√ºr Schritt zu argumentieren. </p><br><p>  In Yandex.Money arbeiten Entwickler in Teams in Gesch√§ftsbereichen, normalerweise 2-4 Backend-Entwickler in einem Team. </p><br><p>  Angenommen, ich werde eine Pull-Anfrage √∂ffnen, dh ich bin der <strong>Autor</strong> .  Ich habe <strong>mein Team</strong> , dessen Entwickler sich der Gesch√§ftslogik meiner Arbeit bewusst sind, weil wir alle an gemeinsamen Projekten teilnehmen, oft synchronisieren und im Allgemeinen aktiv interagieren.  Daher m√∂chte ich sie zun√§chst zu meinen Pull-Anfragen hinzuf√ºgen, damit sie zumindest auf dem neuesten Stand sind, was ich tue. </p><br><p>  Jede Komponente in Yandex.Money verf√ºgt √ºber ein Team, das f√ºr die Produktion verantwortlich ist und diese begleitet. </p><br><p>  Wenn ich eine Komponente √§ndere, f√ºr die ein anderes Team verantwortlich ist, erscheint es logisch, Entwickler aus diesem Team zu den √úberpr√ºfern hinzuzuf√ºgen. Sie sind f√ºr diese Komponente verantwortlich und m√ºssen die Qualit√§t ihres Codes √ºberwachen.  Um die Rezensenten nicht zu √ºberlasten, nehmen wir nur eine zuf√§llige Person aus diesem Team - wir glauben, dass dies ausreicht. </p><br><p>  Es kann vorkommen, dass das <strong>f√ºr die Komponente verantwortliche Team</strong> nicht √ºber ausreichende Fachkenntnisse verf√ºgt.  Dies geschieht, wenn Neulinge im Team erscheinen oder ihnen erst k√ºrzlich diese Komponente anvertraut wurde.  Ich wei√ü jedoch, dass wir in diesem Unternehmen echte Experten f√ºr dieses Repository haben, und es w√§re gro√üartig, wenn einer von ihnen meinen Code betrachten w√ºrde!  Nat√ºrlich ist mein Wissen schwer zu formalisieren, aber Sie k√∂nnen den Verlauf des Repositorys verwenden und die Code√ºberpr√ºfung basierend auf der Anzahl der PRs und Statistiken berechnen, die viel an diesem Code gearbeitet und / oder viel √ºberpr√ºft haben.  Wir berechnen die Expertise-Metrik im Repository, w√§hlen die Top-Entwickler f√ºr diese Metrik aus, nennen sie <strong>Experten</strong> und f√ºgen den Reviewern einen zuf√§lligen Experten hinzu. </p><br><p>  Im Jahr 2018 haben wir das Mentoring-Institut im Unternehmen eingef√ºhrt. Jetzt beobachtet ein Mentor unter den leitenden Entwicklern jedes Team.  Au√üerdem hat jeder Neuling im Unternehmen zun√§chst einen pers√∂nlichen Mentor. </p><br><p>  Lassen Sie meinen Mentor meinen Code beobachten!  Er kann bei Problemen bei der Code√ºberpr√ºfung helfen und hat auch eine Vorstellung von meinen St√§rken und Schw√§chen bei den technischen F√§higkeiten. </p><br><p><img src="https://habrastorage.org/webt/li/vz/hm/livzhmai-uj6ykbxn3g2jpgqqbm.png"></p><br><p>  Insgesamt k√∂nnen f√ºnf bis sechs Personen zu den √úberpr√ºfern jeder Pull-Anfrage hinzugef√ºgt werden.  Tats√§chlich sind sie jedoch normalerweise etwas kleiner, da verschiedene Rollen in einer Person kombiniert werden k√∂nnen.  Mein Mentor kann gleichzeitig ein Experte sein, und mein Team kann f√ºr die Komponente verantwortlich sein.  Subjektiv w√§ren 3-4 Pr√ºfer f√ºr Pull-Anfragen optimal. </p><br><h2 id="kod-revyu-20-chto-pod-kapotom">  Code Review 2.0.  Was ist unter der Haube? </h2><br><p>  Der Punkt ist klein: alles zum Laufen bringen.  Es hat hier geholfen, dass alle unsere Aufstellungen bereits in einem separaten System eingerichtet wurden, das die REST-API f√ºr den Empfang bereitstellt.  Daher wurde nach ein paar Wochen gem√§chlicher Entwicklung in meiner Freizeit die erste Version des Plug-Ins f√ºr Bitbucket geboren, die im Herbst schrittweise weiterentwickelt und mit allen erforderlichen Funktionen ausgestattet wurde. </p><br><h4 id="kak-rabotaet-plagin">  Wie das Plugin funktioniert </h4><br><p>  Normalerweise f√ºllt Bitbucket beim Erstellen einer PR die Viewer vor, die in den Projekt- oder Repository-Einstellungen angegeben sind.  Aus Sicht des Benutzers hat sich hier nichts ge√§ndert - alle Pr√ºfer werden auch beim √ñffnen dieser Seite vorab ausgef√ºllt, au√üer dass ein Feld mit einer Beschreibung hinzugef√ºgt wurde, welcher Pr√ºfer in welcher Rolle hinzugef√ºgt wurde.  Und die Rollen der Rezensenten sind wie folgt erschienen: </p><br><ul><li>  Teamkollege ist ein Mitglied des Teams des PR-Autors. Dank der REST-API mit Team-Kompositionen kann es problemlos hinzugef√ºgt werden </li><li>  Repository-Eigent√ºmer - ein zuf√§lliges Mitglied des Teams, das f√ºr die Komponente verantwortlich ist;  In den Repository-Einstellungen musste die M√∂glichkeit gegeben werden, das verantwortliche Team auszuw√§hlen. </li><li>  Repository-Experte - zuf√§lliger Repository-Experte;  Ich werde Ihnen sp√§ter mehr dar√ºber erz√§hlen </li><li>  Mentor - Ein Mentor f√ºr ein Team oder einen Anf√§nger, ist auch √ºber die REST-API bei einem Dienst mit Teamzusammensetzungen erh√§ltlich. </li></ul><br><h4 id="eksperty-po-repozitoriyam">  Repository-Experten </h4><br><p>  Ich werde Ihnen etwas mehr dar√ºber erz√§hlen, wie wir Experten betrachten.  Jeden Tag durchl√§uft das Plugin alle Repositorys, √ºberpr√ºft alle Pull-Anforderungen des letzten Jahres und ber√ºcksichtigt zwei einfache Metriken: </p><br><ul><li>  die Anzahl der vom Entwickler erstellten Pull-Anforderungen, </li><li>  Die Anzahl der PRs, die er √ºberpr√ºft und genehmigt hat, muss bearbeitet oder abgelehnt werden. </li></ul><br><p>  Wir f√ºgen diesen Metriken Gewichte hinzu, basierend auf der Tatsache, dass aus Sicht des Fachwissens im Code die Verfeinerung dieses Codes wichtiger ist als die √úberpr√ºfung.  Zuerst haben wir die Anzahl der Pull-Anfragen gesch√§tzt, die eineinhalb Mal wichtiger sind als eine √úberpr√ºfung, und sp√§ter haben wir das Verh√§ltnis auf drei zu eins erh√∂ht.  Wir fassen die Metriken multipliziert mit ihren Gewichten zusammen und erhalten die Entwicklerbewertung. </p><br><p>  Als n√§chstes sortieren wir alle diese Entwickler nach Bewertungen, w√§hlen die Top 5 auf dem Weg aus und schneiden diejenigen ab, deren Bewertung unter dem Schwellenwert liegt, um gelegentliche Passanten auszuschlie√üen.  Normalerweise erhalten wir drei bis f√ºnf Experten f√ºr jedes Repository. </p><br><p>  Oben habe ich Ihnen den Ansatz f√ºr die Auswahl der Pr√ºfer beschrieben, den wir ausgew√§hlt und implementiert haben. Dabei haben wir jedoch mehrere kleine Verbesserungen gleichzeitig implementiert, wodurch der Code√ºberpr√ºfungsprozess noch schneller, bequemer und angenehmer wurde. </p><br><h4 id="zapret-merge-pull-rekvesta-poka-ne-proverena-zadacha-v-jira">  Verbinden Sie die Pull-Anforderung, bis die Aufgabe in Jira eingecheckt wurde </h4><br><p>  Solch eine offensichtliche und notwendige Sache, die leider nicht sofort einsatzbereit ist.  Wir erhalten nur stabilen Code in dev, der nicht nur statische Pr√ºfungen und Entwicklertests, sondern auch Integrationstests zusammen mit anderen Diensten bestanden hat.  Der Status solcher Tests spiegelt sich nur in der Jira-Aufgabe wider. Daher mussten Entwickler zuvor manuell pr√ºfen, ob die Aufgabe √ºberpr√ºft wurde, um die Pull-Anforderung zu verlangsamen. </p><br><h4 id="avtomaticheskiy-merge-pull-rekvestov">  Automatische Merge-Pull-Anforderung </h4><br><p>  Pull-Request kann einen betr√§chtlichen Teil seines Lebens in einem Zustand verbringen, in dem ihn nichts daran hindert, sich Zeit zu nehmen, aber eine Person vergisst dies oder nicht sofort.  Ein bemerkenswertes Beispiel ist die Erwartung, eine Aufgabe zu testen, ohne die wir sie nicht in dev behalten.  Hier bietet sich eine automatische Zusammenf√ºhrung an, die nach einem einfachen Prinzip funktioniert: Wenn PR eingefroren werden kann, tun wir dies. </p><br><p>  Alle notwendigen Bedingungen f√ºr die Zusammenf√ºhrung werden durch Schecks abgedeckt.  Wir √ºberpr√ºfen den Erfolg der Assembly, den Grad der Testabdeckung, das Fehlen von Snapshot-Abh√§ngigkeiten der Bibliotheken, den Status der Aufgabe in Jira und das Vorhandensein aller erforderlichen Aktualisierungen.  Das hei√üt, wir haben alles, um diese Funktionalit√§t zu nutzen und PR zu vergessen, sobald wir die Code√ºberpr√ºfung bestanden und die Aufgabe getestet haben (es sei denn, die Qualit√§tssicherung findet nat√ºrlich Probleme darin). </p><br><p>  Und wir haben dies auf eine recht bequeme Weise implementiert: Wir haben einen speziellen AutoMergeBot-Bot eingef√ºhrt, den wir nur den √úberpr√ºfern hinzuf√ºgen m√ºssen, damit er diese Pull-Anforderung √ºberwachen und zu gegebener Zeit einfrieren kann. </p><br><h4 id="uchet-otsutstviy-revyuerov">  Ber√ºcksichtigung der Abwesenheit von Gutachtern </h4><br><p>  Befindet sich der Eigent√ºmer oder Experte der Komponente im Urlaub oder im Krankheitsurlaub, wird er vom Pr√ºfer nicht hinzugef√ºgt, und sein Platz wird von demjenigen eingenommen, der am Arbeitsplatz ist.  Als Bonus f√§llt ein Berg von Pull-Anfragen anderer Leute beim Verlassen des Urlaubs nicht auf diesen Rezensenten.  Dies zu realisieren war nicht schwierig, da der gesamte Mangel an Mitarbeitern bei uns mit Antr√§gen in Jira eingereicht wurde. </p><br><h4 id="uchet-zanyatosti-revyuerov">  Bilanzierung der Besch√§ftigung von Gutachtern </h4><br><p>  Jemand √ºberpr√ºft zehn PRs pro Tag und f√ºnf.  Jemand hat bereits 20 nicht angezeigte PRs gesammelt, w√§hrend jemand fast keine hat.  All dies ber√ºcksichtigen wir, um die Belastung der Pr√ºfer gleichm√§√üiger zu verteilen.  Je mehr Last, desto weniger wird es neuen PRs hinzugef√ºgt - alles ist einfach. </p><br><h4 id="markirovka-razmerov-pr-pri-sozdanii">  PR-Gr√∂√üen beim Erstellen markieren </h4><br><p>  Auf der Seite zum Erstellen von Pull-Anforderungen kann der Autor die ungef√§hre Gr√∂√üe ausw√§hlen: S, M oder L. Dies hilft den √úberpr√ºfern, die ungef√§hre Zeit zu sch√§tzen, die sie f√ºr die Code√ºberpr√ºfung aufwenden werden.  Zum Beispiel habe ich 5 Minuten Zeit und ich verstehe, dass ich es schaffen kann, die Gr√∂√üenanforderung Pull-Anfrage S zu sehen. Es ist nicht sinnvoll, M oder L zu √∂ffnen, da ich keine Zeit habe, sie anzusehen und das n√§chste Mal von vorne anfangen muss. </p><br><p>  In Zukunft wollen wir diese Attribute bei der Berechnung der PR-Statistik ber√ºcksichtigen. </p><br><h4 id="markirovka-srochnyh-pr">  Kennzeichnung dringender PR </h4><br><p>  Au√üerdem kann der Autor beim Erstellen einer PR angeben, dass die Aufgabe sehr dringend ist, indem er dem Namen PR ein solches Symbol hinzuf√ºgt.  Es wird sofort von den Rezensenten gesehen und versucht, es zuerst zu sehen.  Es scheint eine Kleinigkeit zu sein, aber sehr n√ºtzlich und bequem. </p><br><h4 id="treking-nachala-i-okonchaniya-kod-revyu">  Verfolgung der √úberpr√ºfung des Start- und Endcodes </h4><br><p>  Wenn es w√§hrend der Verbesserung des Prozesses unm√∂glich ist zu verstehen, um wie viel er sich verbessert hat, macht es keinen Sinn, damit zu beginnen. </p><br><p>  So ist es auch mit der Code√ºberpr√ºfung - wir k√∂nnen versuchen, sie so weit zu verbessern, wie wir m√∂chten, aber wie k√∂nnen wir uns einer positiven Dynamik ohne Metriken und Statistiken sicher sein?  In unserem Fall ist dies nicht die einfachste Aufgabe - Bitbucket und Jira gaben sofort nicht die M√∂glichkeit, die Code√ºberpr√ºfungszeit zu verfolgen.  Wir waren nur mit der PR-Lebensdauermetrik ausgestattet, was nicht ganz zu uns passte, da wir erst nach dem Ende der Testaufgabe eine Pull-Anfrage stellten. Daher wurden in dieser Metrik Fremdindikatoren gemischt. </p><br><p>  Jira speichert und erm√∂glicht das Hochladen aller Kontrollpunkte des Task-Lebenszyklus. Daher hielten wir es f√ºr richtig, diese Daten mit zwei zus√§tzlichen Beschriftungen anzureichern: der Start- und Endzeit der Code√ºberpr√ºfung.  Es war nur notwendig, das Plugin f√ºr Bitbucket zu lehren, um diese Tags in Jira zu pushen.  Somit war und ist Jira ein einziger Wahrheitspunkt f√ºr die Aufgabe, und anhand dieses Datensatzes k√∂nnen wir den Zeitpunkt der Code√ºberpr√ºfung vom Zeitpunkt des Testens der Aufgabe trennen. </p><br><p>  Der d√ºnnste Punkt hier ist, wie man bestimmt, wann eine Code√ºberpr√ºfung beendet werden soll.  Vielleicht ist dies die Zeit, um die erste App zu bekommen, vielleicht die letzte, oder vielleicht ist dies die Zeit f√ºr die letzten √Ñnderungen, die der Autor von PR vorgenommen hat?  Ich habe keine Antwort auf diese Frage, hier muss ich mich nur einigen und eine Sache ausw√§hlen oder alle drei Ereignisse mit Metriken abdecken und den Abweichungen folgen. </p><br><h4 id="treking-zagruzki-revyuerov">  Verfolgung von Downloads von Rezensenten </h4><br><p>  Eine weitere n√ºtzliche Metrik ist die Arbeitsbelastung der Pr√ºfer.  Wie ich oben geschrieben habe, ber√ºcksichtigen wir dies bei der Zuweisung von Gutachtern zu neuen PRs, ver√∂ffentlichen diese Informationen jedoch auch, um die Dynamik von Teams, Abteilungen oder Unternehmen zu √ºberwachen.  Manchmal hilft dies dabei, Anomalien und potenzielle Probleme zu erkennen: Wenn klar ist, dass eine oder mehrere Personen in einem Team t√§glich 10 oder mehr nicht angezeigte PRs h√§ngen, gibt es einen Grund, herauszufinden, ob alles in Ordnung ist. </p><br><h4 id="prosmotr-metrik-v-grafana">  Anzeigen von Metriken in Grafana </h4><br><p>  Das Erstellen von Berichten zu Daten von Jira ist n√ºtzlich, aber nicht sehr praktisch. Daher haben wir auch das Senden von Metriken f√ºr die Hauptereignisse in StatsD hinzugef√ºgt, um Diagramme zu Betriebsdaten in Grafana zu erstellen.  Wir √ºberwachen die durchschnittliche Zeit bis zum ersten Test, die durchschnittliche Lebensdauer der PR, und untersuchen auch die anomalen Werte f√ºr diese Metriken, um Probleme schnell zu finden und zu l√∂sen. </p><br><p>  Zum Zeitpunkt des Schreibens sieht unser Dashboard folgenderma√üen aus: </p><br><p><img src="https://habrastorage.org/webt/7t/ci/q0/7tciq07igrzqnejdy0cir6smqks.png"></p><br><h1 id="chto-poluchili-v-itoge">  Was hast du am Ende bekommen? </h1><br><p>  Leider sind wir alle im Nachhinein stark, so dass wir die oben genannten Metriken f√ºr die Code√ºberpr√ºfung nicht eingef√ºhrt haben, bevor sich der Prozess selbst zu √§ndern begann (September bis Oktober 2018), sondern bereits auf dem Weg dorthin, sodass wir Verbesserungen oder Verschlechterungen erst ab Anfang Dezember 2018 zuverl√§ssig verfolgen k√∂nnen Was haben wir bemerkt? </p><br><p>  Das erste, was auff√§llt, ist die Verringerung der Belastung f√ºr leitende Gutachter, und ich habe dies anhand meines eigenen Beispiels gesp√ºrt.  Wie ich bereits erw√§hnte, war es f√ºr mich normal, morgens ungef√§hr 30 PRs in der Schlange zu sehen, aber jetzt schwankt diese Zahl zwischen 10 und 15. Statistiken der Abteilung best√§tigen dies: Seit Dezember 2018 wurde die maximale Anzahl von PRs, die auf eine √úberpr√ºfung warten, von niemandem erh√∂ht √ºber 15. Im Durchschnitt beobachten wir ein Bild, das darauf hindeutet, dass jeder Entwickler im Durchschnitt 4-5 nicht angezeigte PRs am Morgen erwartet, was eine ziemlich angemessene Zahl zu sein scheint. </p><br><p><img src="https://habrastorage.org/webt/g9/a6/aj/g9a6ajl7hnnuaizyigu7rcjkoqo.png"></p><br><p>  In Bezug auf die Relevanz der Auswahl der Pr√ºfer und die Qualit√§t der Code√ºberpr√ºfung k√∂nnen wir uns hier nur auf subjektive Indikatoren st√ºtzen.  Laut Umfragen von Kollegen haben wir wirklich eine hervorragende Auswahl an Gutachtern erhalten, jetzt muss niemand mehr manuell hinzuf√ºgen, und keine PRs werden aufgegeben und vergessen. </p><br><p><img src="https://habrastorage.org/webt/mc/jw/7q/mcjw7qch8z_30nfwtc3c5i3at68.png"></p><br><p>  Wenn wir √ºber die Zeit sprechen, die zum Bestehen der Code√ºberpr√ºfung ben√∂tigt wird, ist es zu fr√ºh, um Statistiken zu diesem Indikator zu berechnen, da wir k√ºrzlich mit der Erfassung begonnen haben.  Zu unserer Verf√ºgung steht nur die Lebensdauer von Pull-Anfragen, die tats√§chlich nicht gestiegen oder gefallen sind.  Diese Metrik enth√§lt die Zeit zum Testen der Aufgabe. Daher ist es schwierig, eindeutige Schlussfolgerungen zu ziehen. Au√üerdem haben wir den √úberpr√ºfungscode nicht ge√§ndert, da wir ihn ge√§ndert haben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446654/">https://habr.com/ru/post/de446654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446644/index.html">So f√ºhren Sie SMM 2019 aus: 17 Diagramme von Neil Patel</a></li>
<li><a href="../de446646/index.html">InterSystems IRIS 2019.1 Release</a></li>
<li><a href="../de446648/index.html">Kubernetes Operator-Entwicklung mit Operator Framework</a></li>
<li><a href="../de446650/index.html">Wie viel kosten Tester und wovon h√§ngen ihre Geh√§lter ab? Erstellen eines Portr√§ts eines erfolgreichen QS-Spezialisten</a></li>
<li><a href="../de446652/index.html">MVCC-4. Datenschnappsch√ºsse</a></li>
<li><a href="../de446656/index.html">1600bit / s Sprachcodierung mit dem neuronalen Vocoder LPCNet</a></li>
<li><a href="../de446658/index.html">Interview mit Andrei Stankevich √ºber Sportprogrammierung</a></li>
<li><a href="../de446660/index.html">KI, Sch√ºler und gro√üer Preis: Wie man maschinelles Lernen in der 8. Klasse macht</a></li>
<li><a href="../de446662/index.html">Transaktionen und Mechanismen zu ihrer Kontrolle</a></li>
<li><a href="../de446664/index.html">Das SAP Forum 2019 ist nur noch 2 Wochen entfernt! Was wird da sein?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>