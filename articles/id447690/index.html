<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏻 💿 🍸 Konfigurasi yang dapat dikompilasi dari sistem terdistribusi 🐱 ⛪️ 👍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting ini kami ingin berbagi cara menarik untuk berurusan dengan konfigurasi sistem terdistribusi. 
 Konfigurasi diwakili secara langsung dala...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konfigurasi yang dapat dikompilasi dari sistem terdistribusi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/primetalk/blog/447690/"><p>  Dalam posting ini kami ingin berbagi cara menarik untuk berurusan dengan konfigurasi sistem terdistribusi. <br>  Konfigurasi diwakili secara langsung dalam bahasa Scala dalam jenis yang aman.  Contoh implementasi dijelaskan secara rinci.  Berbagai aspek proposal dibahas, termasuk pengaruhnya terhadap keseluruhan proses pembangunan. </p><br><p><img src="https://habrastorage.org/webt/71/bl/ax/71blaxtldz-ia4yftyebaxbam7c.png" alt="Keseluruhan proses manajemen konfigurasi"></p><br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam bahasa Rusia</a> ) </p><a name="habracut"></a><br><h3 id="introduction">  Pendahuluan </h3><br><p>  Membangun sistem terdistribusi yang kuat membutuhkan penggunaan konfigurasi yang benar dan koheren pada semua node.  Solusi khas adalah dengan menggunakan deskripsi penyebaran teks (terraform, mungkin atau sesuatu yang serupa) dan file konfigurasi yang dihasilkan secara otomatis (sering - didedikasikan untuk setiap node / peran).  Kami juga ingin menggunakan protokol yang sama dari versi yang sama pada setiap node yang berkomunikasi (jika tidak kita akan mengalami masalah ketidakcocokan).  Dalam dunia JVM ini berarti bahwa setidaknya perpustakaan perpesanan harus dari versi yang sama pada semua node yang berkomunikasi. </p><br><p>  Bagaimana dengan pengujian sistem?  Tentu saja, kita harus melakukan tes unit untuk semua komponen sebelum datang ke tes integrasi.  Untuk dapat mengekstrapolasi hasil pengujian pada saat runtime, kita harus memastikan bahwa versi semua pustaka dijaga tetap identik di kedua runtime dan lingkungan pengujian. </p><br><p>  Saat menjalankan tes integrasi, seringkali lebih mudah untuk memiliki classpath yang sama di semua node.  Kita hanya perlu memastikan bahwa classpath yang sama digunakan pada penyebaran.  (Dimungkinkan untuk menggunakan classpath yang berbeda pada node yang berbeda, tetapi lebih sulit untuk merepresentasikan konfigurasi ini dan menyebarkannya dengan benar.) Jadi, untuk mempermudah, kita hanya akan mempertimbangkan classpath identik pada semua node. </p><br><p>  Konfigurasi cenderung berkembang bersama dengan perangkat lunak.  Kami biasanya menggunakan versi untuk mengidentifikasi berbagai <br>  tahapan evolusi perangkat lunak.  Tampaknya masuk akal untuk membahas konfigurasi di bawah manajemen versi dan mengidentifikasi berbagai konfigurasi dengan beberapa label.  Jika hanya ada satu konfigurasi dalam produksi, kami dapat menggunakan versi tunggal sebagai pengenal.  Kadang-kadang kita mungkin memiliki beberapa lingkungan produksi.  Dan untuk setiap lingkungan kita mungkin memerlukan cabang konfigurasi yang terpisah.  Jadi konfigurasi mungkin diberi label dengan cabang dan versi untuk secara unik mengidentifikasi konfigurasi yang berbeda.  Setiap label dan versi cabang berhubungan dengan kombinasi tunggal dari node terdistribusi, port, sumber daya eksternal, versi pustaka classpath pada setiap node.  Di sini kita hanya akan membahas cabang tunggal dan mengidentifikasi konfigurasi dengan versi tiga desimal (1.2.3), dengan cara yang sama seperti artefak lainnya. </p><br><p>  Dalam lingkungan modern file konfigurasi tidak dimodifikasi secara manual lagi.  Biasanya kami menghasilkan <br>  konfigurasikan file pada waktu penyebaran dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jangan pernah menyentuhnya</a> sesudahnya.  Jadi orang bisa bertanya mengapa kita masih menggunakan format teks untuk file konfigurasi?  Opsi yang layak adalah menempatkan konfigurasi di dalam unit kompilasi dan mendapat manfaat dari validasi konfigurasi waktu kompilasi. </p><br><p>  Dalam posting ini kita akan memeriksa ide menjaga konfigurasi dalam artefak yang dikompilasi. </p><br><h3 id="compilable-configuration">  Konfigurasi yang dapat dikompilasi </h3><br><p>  Pada bagian ini kita akan membahas contoh konfigurasi statis.  Dua layanan sederhana - layanan gema dan klien dari layanan gema sedang dikonfigurasi dan diimplementasikan.  Kemudian dua sistem terdistribusi yang berbeda dengan kedua layanan instantiated.  Satu untuk konfigurasi node tunggal dan satu lagi untuk konfigurasi dua node. </p><br><p>  Sistem terdistribusi tipikal terdiri dari beberapa node.  Node dapat diidentifikasi menggunakan beberapa jenis: </p><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Backend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Frontend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span></span></code> </pre> <br><p>  atau adil </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">hostName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  atau bahkan </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span></code> </pre> <br><p>  Node-node ini menjalankan berbagai peran, menjalankan beberapa layanan dan harus dapat berkomunikasi dengan node lain melalui koneksi TCP / HTTP. </p><br><p>  Untuk koneksi TCP setidaknya diperlukan nomor port.  Kami juga ingin memastikan bahwa klien dan server berbicara protokol yang sama.  Untuk memodelkan koneksi antara node, mari kita mendeklarasikan kelas berikut: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TcpEndPoint</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">node: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">NodeId</span></span></span></span><span class="hljs-class"><span class="hljs-params">, port: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Port</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Protocol</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  di mana <code>Port</code> hanya sebuah <code>Int</code> dalam rentang yang diizinkan: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortNumber</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Closed</span></span>[_0, <span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-number"><span class="hljs-number">65535</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jenis halus</b> <div class="spoiler_text"><p>  Lihat perpustakaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disempurnakan</a> .  Singkatnya, ini memungkinkan untuk menambahkan batasan waktu kompilasi ke tipe lain.  Dalam hal ini, <code>Int</code> hanya diperbolehkan memiliki nilai 16-bit yang dapat mewakili nomor port.  Tidak ada persyaratan untuk menggunakan perpustakaan ini untuk pendekatan konfigurasi ini.  Sepertinya pas sekali. </p></div></div><br><p>  Untuk HTTP (REST) ​​kami mungkin juga memerlukan jalur layanan: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UrlPathPrefix</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">MatchesRegex</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-string"><span class="hljs-string">"[a-zA-Z_0-9/]*"</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortWithPrefix</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">portNumber: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">PortNumber</span></span></span></span><span class="hljs-class"><span class="hljs-params">, pathPrefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">UrlPathPrefix</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Tipe hantu</b> <div class="spoiler_text"><p>  Untuk mengidentifikasi protokol selama kompilasi, kami menggunakan fitur Scala untuk mendeklarasikan tipe argumen <code>Protocol</code> yang tidak digunakan di kelas.  Ini disebut <em>tipe hantu</em> .  Saat runtime kita jarang membutuhkan instance pengenal protokol, itu sebabnya kami tidak menyimpannya.  Selama kompilasi, tipe hantu ini memberikan keamanan tipe tambahan.  Kami tidak dapat melewati port dengan protokol yang salah. </p></div></div><br><p>  Salah satu protokol yang paling banyak digunakan adalah REST API dengan serialisasi Json: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonHttpRestProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  di mana <code>RequestMessage</code> adalah jenis pesan dasar yang dapat dikirim klien ke server dan <code>ResponseMessage</code> adalah pesan respons dari server.  Tentu saja, kami dapat membuat deskripsi protokol lain yang menentukan protokol komunikasi dengan presisi yang diinginkan. </p><br><p>  Untuk keperluan posting ini kami akan menggunakan versi protokol yang lebih sederhana: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleHttpGetRest</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  Dalam protokol ini pesan permintaan ditambahkan ke url dan pesan respons dikembalikan sebagai string biasa. </p><br><p>  Konfigurasi layanan dapat dijelaskan oleh nama layanan, kumpulan port dan beberapa dependensi.  Ada beberapa cara yang mungkin bagaimana cara mewakili semua elemen ini di Scala (misalnya, <code>HList</code> , tipe data aljabar).  Untuk keperluan posting ini kami akan menggunakan Pola Kue dan mewakili potongan-potongan (modul) yang dapat dikombinasikan sebagai ciri.  (Pola Kue bukan persyaratan untuk pendekatan konfigurasi yang dapat dikompilasi ini. Ini hanya salah satu kemungkinan penerapan ide.) </p><br><p>  Ketergantungan dapat direpresentasikan menggunakan Pola Kue sebagai titik akhir dari simpul lain: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">SimpleHttpGetRest</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8081</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoPort</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]](portNumber, <span class="hljs-string"><span class="hljs-string">"echo"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoService</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = providedSimpleService(echoPort) }</code> </pre> <br><p>  Layanan gema hanya membutuhkan port yang dikonfigurasi.  Dan kami menyatakan bahwa port ini mendukung protokol gema.  Perhatikan bahwa kita tidak perlu menentukan port tertentu saat ini, karena sifat memungkinkan deklarasi metode abstrak.  Jika kita menggunakan metode abstrak, kompiler akan membutuhkan implementasi dalam contoh konfigurasi.  Di sini kami telah menyediakan implementasi ( <code>8081</code> ) dan itu akan digunakan sebagai nilai default jika kita melewatkannya dalam konfigurasi konkret. </p><br><p>  Kami dapat mendeklarasikan ketergantungan dalam konfigurasi klien layanan gema: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMessage</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"test"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pollInterval</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FiniteDuration</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoServiceDependency</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[_, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] }</code> </pre> <br><p>  Ketergantungan memiliki tipe yang sama dengan <code>echoService</code> .  Secara khusus, ini menuntut protokol yang sama.  Oleh karena itu, kita dapat yakin bahwa jika kita menghubungkan kedua dependensi ini, keduanya akan berfungsi dengan benar. </p><br><div class="spoiler">  <b class="spoiler_title">Implementasi layanan</b> <div class="spoiler_text"><p>  Suatu layanan membutuhkan fungsi untuk memulai dan mematikan dengan anggun.  (Kemampuan untuk mematikan layanan sangat penting untuk pengujian.) Sekali lagi ada beberapa opsi untuk menentukan fungsi seperti itu untuk konfigurasi yang diberikan (misalnya, kita bisa menggunakan kelas tipe).  Untuk posting ini kita akan kembali menggunakan Pola Kue.  Kami dapat mewakili layanan menggunakan <code>cats.Resource</code> yang sudah menyediakan bracketing dan rilis sumber daya.  Untuk memperoleh sumber daya, kita harus menyediakan konfigurasi dan beberapa konteks runtime.  Jadi fungsi awal layanan mungkin terlihat seperti: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceReader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Resource</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> implicit resolver: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">AddressResolver</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], timer: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Timer</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], contextShift: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ContextShift</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], ec: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ExecutionContext</span></span></span></span><span class="hljs-class"><span class="hljs-params">, applicative: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Applicative</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">] </span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] }</code> </pre> <br><p>  dimana </p><br><ul><li>  <code>Config</code> - jenis konfigurasi yang diperlukan oleh starter layanan ini </li><li>  <code>AddressResolver</code> - objek runtime yang memiliki kemampuan untuk mendapatkan alamat nyata dari node lain (terus membaca untuk detail). </li></ul><br><p>  jenis lainnya berasal dari <code>cats</code> : </p><br><ul><li>  <code>F[_]</code> - jenis efek (Dalam kasus paling sederhana <code>F[A]</code> bisa saja <code>() =&gt; A</code> Dalam posting ini kita akan menggunakan <code>cats.IO</code> ) </li><li>  <code>Reader[A,B]</code> - kurang lebih adalah sinonim untuk fungsi <code>A =&gt; B</code> </li><li>  <code>cats.Resource</code> - memiliki cara untuk memperoleh dan melepaskan </li><li>  <code>Timer</code> - memungkinkan untuk tidur / mengukur waktu </li><li>  <code>ContextShift</code> - analog dari <code>ExecutionContext</code> </li><li>  <code>Applicative</code> - pembungkus fungsi yang berlaku (hampir monad) (akhirnya kami mungkin akan menggantinya dengan yang lain) </li></ul><br><p>  Dengan menggunakan antarmuka ini, kami dapat mengimplementasikan beberapa layanan.  Misalnya, layanan yang tidak melakukan apa pun: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Any</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resource</span></span></span></span>(...): <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">Reader</span></span>(_ =&gt; <span class="hljs-type"><span class="hljs-type">Resource</span></span>.pure[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>](())) }</code> </pre> </div></div><br><p>  (Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> sumber untuk implementasi layanan lain - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layanan gema</a> , <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien echo</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengontrol seumur hidup</a> .) </p><br><p>  Node adalah objek tunggal yang menjalankan beberapa layanan (memulai rangkaian sumber daya diaktifkan oleh Pola Kue): </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Perhatikan bahwa dalam node kami menentukan jenis konfigurasi yang tepat yang diperlukan oleh node ini.  Compiler tidak akan membiarkan kita membangun objek (Kue) dengan tipe yang tidak cukup, karena setiap sifat layanan menyatakan kendala pada tipe <code>Config</code> .  Kami juga tidak akan dapat memulai simpul tanpa menyediakan konfigurasi lengkap. </p><br><div class="spoiler">  <b class="spoiler_title">Resolusi alamat simpul</b> <div class="spoiler_text"><p>  Untuk membuat koneksi, kita memerlukan alamat host nyata untuk setiap node.  Ini mungkin diketahui kemudian daripada bagian lain dari konfigurasi.  Oleh karena itu, kita memerlukan cara untuk menyediakan pemetaan antara id node dan alamat aktualnya.  Pemetaan ini adalah fungsi: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeAddress</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeId</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">host: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Uri</span></span></span></span><span class="hljs-class"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Host</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressResolver</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>](nodeId: <span class="hljs-type"><span class="hljs-type">NodeId</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">NodeAddress</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>]] }</code> </pre> <br><p>  Ada beberapa cara yang mungkin untuk mengimplementasikan fungsi tersebut. </p><br><ol><li>  Jika kita mengetahui alamat aktual sebelum penyebaran, selama instance node host, maka kita dapat menghasilkan kode Scala dengan alamat aktual dan menjalankan build sesudahnya (yang melakukan pemeriksaan waktu kompilasi dan kemudian menjalankan suite uji integrasi).  Dalam hal ini fungsi pemetaan kami dikenal secara statis dan dapat disederhanakan menjadi sesuatu seperti <code>Map[NodeId, NodeAddress]</code> . </li><li>  Kadang-kadang kami mendapatkan alamat aktual hanya pada titik kemudian ketika node benar-benar dimulai, atau kami tidak memiliki alamat node yang belum dimulai.  Dalam hal ini kami mungkin memiliki layanan pencarian yang dimulai sebelum semua node lain dan setiap node dapat mengiklankan alamat itu di layanan itu dan berlangganan dependensi. </li><li>  Jika kita dapat memodifikasi <code>/etc/hosts</code> , kita dapat menggunakan nama host yang telah ditentukan (seperti <code>my-project-main-node</code> dan <code>echo-backend</code> ) dan hanya mengasosiasikan nama ini dengan alamat ip pada waktu penyebaran. </li></ol><br><p>  Dalam posting ini kami tidak membahas kasus-kasus ini secara lebih rinci.  Bahkan dalam contoh mainan kami semua node akan memiliki alamat IP yang sama - <code>127.0.0.1</code> . </p></div></div><br><p>  Dalam posting ini kita akan mempertimbangkan dua tata letak sistem terdistribusi: </p><br><ol><li>  Tata letak simpul tunggal, tempat semua layanan ditempatkan pada simpul tunggal. </li><li>  Tata letak dua simpul, di mana layanan dan klien berada di simpul yang berbeda. </li></ol><br><p>  Konfigurasi untuk tata letak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">simpul tunggal</a> adalah sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi simpul tunggal</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identifier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">single</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">configuration</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span> <span class="hljs-comment"><span class="hljs-comment">/** Type safe service port specification. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8088</span></span> <span class="hljs-comment"><span class="hljs-comment">// configuration of client /** We'll use the service provided by the same host. */ def echoServiceDependency = echoService override def testMessage: UrlPathElement = "hello" def pollInterval: FiniteDuration = 1.second // lifecycle controller configuration def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 requests, not 9. }</span></span></code> </pre> </div></div><br><p>  Di sini kita membuat satu konfigurasi yang memperluas konfigurasi server dan klien.  Kami juga mengkonfigurasi pengontrol siklus hidup yang biasanya akan mengakhiri klien dan server setelah melewati interval <code>lifetime</code> . </p><br><p>  Rangkaian implementasi dan konfigurasi layanan yang sama dapat digunakan untuk membuat tata letak sistem dengan dua node terpisah.  Kami hanya perlu membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua konfigurasi simpul terpisah</a> dengan layanan yang sesuai: </p><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi dua node</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigTermLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeIdImpl</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeServer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8080</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeClientConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NB! dependency specification def echoServiceDependency = NodeServerConfig.echoService def pollInterval: FiniteDuration = 1.second def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 request, not 9. def testMessage: String = "dolly" }</span></span></code> </pre> </div></div><br><p>  Lihat bagaimana kami menentukan ketergantungan.  Kami menyebutkan layanan yang disediakan node lain sebagai ketergantungan dari node saat ini.  Jenis ketergantungan diperiksa karena mengandung jenis hantu yang menggambarkan protokol.  Dan pada saat runtime kita akan memiliki id simpul yang benar.  Ini adalah salah satu aspek penting dari pendekatan konfigurasi yang diusulkan.  Ini memberi kami kemampuan untuk mengatur port hanya sekali dan memastikan bahwa kami mereferensikan port yang benar. </p><br><div class="spoiler">  <b class="spoiler_title">Implementasi dua node</b> <div class="spoiler_text"><p>  Untuk konfigurasi ini kami menggunakan implementasi layanan yang persis sama.  Tidak ada perubahan sama sekali.  Namun, kami membuat dua implementasi simpul berbeda yang berisi rangkaian layanan berbeda: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeServerImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigIntLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">SigTermLifecycleConfig</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeClientImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Node pertama mengimplementasikan server dan hanya perlu konfigurasi sisi server.  Node kedua mengimplementasikan klien dan membutuhkan bagian lain dari konfigurasi.  Kedua node memerlukan spesifikasi seumur hidup.  Untuk keperluan simpul layanan pos ini akan memiliki masa hidup tak terbatas yang dapat diakhiri menggunakan <code>SIGTERM</code> , sementara klien gema akan berakhir setelah durasi terbatas yang dikonfigurasi.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi starter</a> untuk detailnya. </p></div></div><br><h4 id="overall-development-process">  Keseluruhan proses pengembangan </h4><br><p>  Mari kita lihat bagaimana pendekatan ini mengubah cara kita bekerja dengan konfigurasi. </p><br><p>  Konfigurasi sebagai kode akan dikompilasi dan menghasilkan artefak.  Tampaknya masuk akal untuk memisahkan artefak konfigurasi dari artefak kode lainnya.  Seringkali kita dapat memiliki banyak konfigurasi pada basis kode yang sama.  Dan tentu saja, kita dapat memiliki beberapa versi dari berbagai cabang konfigurasi.  Dalam konfigurasi, kami dapat memilih versi perpustakaan tertentu dan ini akan tetap konstan setiap kali kami menggunakan konfigurasi ini. </p><br><p>  Perubahan konfigurasi menjadi perubahan kode.  Jadi harus dicakup oleh proses penjaminan kualitas yang sama: </p><br><p>  Tiket -&gt; PR -&gt; ulasan -&gt; penggabungan -&gt; integrasi berkelanjutan -&gt; penyebaran berkelanjutan </p><br><p>  Ada konsekuensi berikut dari pendekatan ini: </p><br><ol><li><p>  Konfigurasi ini koheren untuk instance sistem tertentu.  Tampaknya tidak ada cara untuk memiliki koneksi yang salah antara node. </p><br></li><li><p>  Tidak mudah mengubah konfigurasi hanya dalam satu node.  Tampaknya tidak masuk akal untuk masuk dan mengubah beberapa file teks.  Jadi konfigurasi drift menjadi kurang memungkinkan. </p><br></li><li><p>  Perubahan konfigurasi kecil tidak mudah dilakukan. </p><br></li><li><p>  Sebagian besar perubahan konfigurasi akan mengikuti proses pengembangan yang sama, dan akan melewati beberapa tinjauan. </p><br></li></ol><br><p>  Apakah kita memerlukan repositori terpisah untuk konfigurasi produksi?  Konfigurasi produksi mungkin berisi informasi sensitif yang kami ingin jauhkan dari jangkauan banyak orang.  Jadi mungkin perlu menyimpan repositori terpisah dengan akses terbatas yang akan berisi konfigurasi produksi.  Kami dapat membagi konfigurasi menjadi dua bagian - satu yang berisi sebagian besar parameter produksi terbuka dan satu yang berisi bagian rahasia dari konfigurasi.  Ini akan memungkinkan akses ke sebagian besar pengembang ke sebagian besar parameter sambil membatasi akses ke hal-hal yang sangat sensitif.  Sangat mudah untuk mencapai ini menggunakan sifat perantara dengan nilai parameter default. </p><br><h3 id="variations">  Variasi </h3><br><p>  Mari kita lihat pro dan kontra dari pendekatan yang diusulkan dibandingkan dengan teknik manajemen konfigurasi lainnya. </p><br><p>  Pertama-tama, kami akan mencantumkan beberapa alternatif untuk berbagai aspek dari cara yang diusulkan untuk menangani konfigurasi: </p><br><ol><li>  File teks pada mesin target. </li><li>  Penyimpanan nilai kunci terpusat (seperti <code>etcd</code> / <code>zookeeper</code> ). </li><li>  Komponen subproses yang dapat dikonfigurasi ulang / dihidupkan ulang tanpa memulai kembali proses. </li><li>  Konfigurasi di luar artefak dan kontrol versi. </li></ol><br><p>  File teks memberikan beberapa fleksibilitas dalam hal perbaikan ad-hoc.  Administrator sistem dapat masuk ke node target, melakukan perubahan, dan cukup memulai kembali layanan.  Ini mungkin tidak sebagus sistem yang lebih besar.  Tidak ada jejak yang tertinggal di balik perubahan.  Perubahan tidak ditinjau oleh sepasang mata lain.  Mungkin sulit untuk mengetahui apa yang menyebabkan perubahan itu.  Itu belum diuji.  Dari perspektif sistem terdistribusi, seorang administrator bisa saja lupa untuk memperbarui konfigurasi di salah satu node lainnya. </p><br><p>  (Btw, jika pada akhirnya akan ada kebutuhan untuk mulai menggunakan file konfigurasi teks, kita hanya perlu menambahkan parser + validator yang bisa menghasilkan tipe <code>Config</code> sama dan itu sudah cukup untuk mulai menggunakan konfigurasi teks. Ini juga menunjukkan bahwa kompleksitas konfigurasi waktu kompilasi sedikit lebih kecil daripada kompleksitas konfigurasi berbasis teks, karena dalam versi berbasis teks kita memerlukan beberapa kode tambahan.) </p><br><p>  Penyimpanan nilai kunci terpusat adalah mekanisme yang baik untuk mendistribusikan parameter meta aplikasi.  Di sini kita perlu berpikir tentang apa yang kita anggap sebagai nilai konfigurasi dan apa yang hanya data.  Diberikan fungsi <code>C =&gt; A =&gt; B</code> kita biasanya memanggil nilai <code>C</code> "konfigurasi" yang jarang berubah, sementara data <code>A</code> sering berubah - hanya input data.  Konfigurasi harus disediakan untuk fungsi lebih awal dari data <code>A</code>  Dengan gagasan ini, kita dapat mengatakan bahwa frekuensi perubahan yang diharapkan dapat digunakan untuk membedakan data konfigurasi dari hanya data.  Juga data biasanya berasal dari satu sumber (pengguna) dan konfigurasi berasal dari sumber yang berbeda (admin).  Berurusan dengan parameter yang dapat diubah setelah inisialisasi proses mengarah pada peningkatan kompleksitas aplikasi.  Untuk parameter seperti itu kita harus menangani mekanisme pengiriman, penguraian dan validasi, menangani nilai yang salah.  Oleh karena itu, untuk mengurangi kompleksitas program, lebih baik kita mengurangi jumlah parameter yang dapat berubah saat runtime (atau bahkan menghilangkan semuanya). </p><br><p>  Dari perspektif posting ini kita harus membuat perbedaan antara parameter statis dan dinamis.  Jika logika layanan memerlukan perubahan langka pada beberapa parameter saat runtime, maka kami dapat menyebutnya parameter dinamis.  Kalau tidak, mereka statis dan dapat dikonfigurasi menggunakan pendekatan yang diusulkan.  Untuk konfigurasi ulang dinamis, pendekatan lain mungkin diperlukan.  Sebagai contoh, bagian dari sistem mungkin di-restart dengan parameter konfigurasi baru dengan cara yang sama untuk memulai kembali proses terpisah dari sistem terdistribusi. <br>  (Pendapat saya yang sederhana adalah untuk menghindari konfigurasi ulang runtime karena menambah kompleksitas sistem. <br>  Mungkin lebih mudah untuk hanya mengandalkan dukungan OS untuk memulai kembali proses.  Padahal, itu mungkin tidak selalu mungkin.) </p><br><p>  Salah satu aspek penting dari menggunakan konfigurasi statis yang terkadang membuat orang menganggap konfigurasi dinamis (tanpa alasan lain) adalah gangguan layanan selama pembaruan konfigurasi.  Memang, jika kita harus membuat perubahan pada konfigurasi statis, kita harus me-restart sistem sehingga nilai-nilai baru menjadi efektif.  Persyaratan untuk waktu henti bervariasi untuk sistem yang berbeda, sehingga mungkin tidak terlalu penting.  Jika sangat penting, maka kita harus merencanakan ke depan untuk memulai ulang sistem apa pun.  Misalnya, kita bisa menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengeringan koneksi AWS ELB</a> .  Dalam skenario ini setiap kali kita perlu me-restart sistem, kita memulai instance baru dari sistem secara paralel, kemudian beralih ELB ke situ, sambil membiarkan sistem lama menyelesaikan layanan koneksi yang ada. </p><br><p>  Bagaimana dengan menjaga konfigurasi di dalam artefak berversi atau di luar?  Menyimpan konfigurasi di dalam artefak berarti dalam sebagian besar kasus konfigurasi ini telah melewati proses penjaminan kualitas yang sama dengan artefak lainnya.  Jadi orang mungkin yakin bahwa konfigurasinya berkualitas baik dan dapat dipercaya.  Sebaliknya konfigurasi dalam file yang terpisah berarti bahwa tidak ada jejak siapa dan mengapa membuat perubahan pada file itu.  Apakah ini penting?  Kami percaya bahwa untuk sebagian besar sistem produksi lebih baik memiliki konfigurasi yang stabil dan berkualitas tinggi. </p><br><p>  Versi artefak memungkinkan untuk mencari tahu kapan itu dibuat, nilai-nilai apa yang dikandungnya, fitur apa yang diaktifkan / dinonaktifkan, siapa yang bertanggung jawab untuk membuat setiap perubahan dalam konfigurasi.  Mungkin memerlukan beberapa upaya untuk menjaga konfigurasi di dalam artefak dan itu adalah pilihan desain untuk dibuat. </p><br><h3 id="pros--cons">  Pro &amp; kontra </h3><br><p>  Di sini kami ingin menyoroti beberapa kelebihan dan mendiskusikan beberapa kelemahan dari pendekatan yang diusulkan. </p><br><h4 id="advantages">  Keuntungan </h4><br><p>  Fitur konfigurasi yang dapat dikompilasi dari sistem terdistribusi lengkap: </p><br><ol><li>  Pemeriksaan konfigurasi statis.  Ini memberikan tingkat kepercayaan yang tinggi, bahwa konfigurasi sudah benar diberikan batasan tipe. </li><li>  Bahasa konfigurasi yang kaya.  Biasanya pendekatan konfigurasi lain terbatas pada paling banyak penggantian variabel. <br>  Menggunakan Scala satu dapat menggunakan berbagai fitur bahasa untuk membuat konfigurasi lebih baik.  Sebagai contoh, kita dapat menggunakan ciri-ciri untuk memberikan nilai default, objek untuk mengatur ruang lingkup yang berbeda, kita dapat merujuk pada nilai yang didefinisikan hanya sekali dalam lingkup luar (KERING).  Dimungkinkan untuk menggunakan urutan literal, atau instance dari kelas tertentu ( <code>Seq</code> , <code>Map</code> , dll.). </li><li>  DSL  Scala memiliki dukungan yang layak untuk penulis DSL.  Seseorang dapat menggunakan fitur ini untuk membuat bahasa konfigurasi yang lebih nyaman dan ramah pengguna akhir, sehingga konfigurasi akhir setidaknya dapat dibaca oleh pengguna domain. </li><li>  Integritas dan koherensi antar node.  Salah satu manfaat memiliki konfigurasi untuk keseluruhan sistem terdistribusi di satu tempat adalah bahwa semua nilai didefinisikan secara ketat sekali dan kemudian digunakan kembali di semua tempat di mana kita membutuhkannya.  Juga ketikkan deklarasi port aman memastikan bahwa dalam semua kemungkinan konfigurasi yang benar node sistem akan berbicara bahasa yang sama.  Ada ketergantungan eksplisit antara node yang membuatnya sulit untuk lupa menyediakan beberapa layanan. </li><li>  Kualitas perubahan yang tinggi.  Pendekatan keseluruhan melewati perubahan konfigurasi melalui proses PR normal menetapkan standar kualitas yang tinggi juga dalam konfigurasi. </li><li>  Perubahan konfigurasi simultan.  Setiap kali kami melakukan perubahan dalam konfigurasi penerapan otomatis memastikan bahwa semua node diperbarui. </li><li>  Penyederhanaan aplikasi.  Aplikasi tidak perlu menguraikan dan memvalidasi konfigurasi dan menangani nilai konfigurasi yang salah.  Ini menyederhanakan aplikasi keseluruhan.  (Beberapa peningkatan kompleksitas ada dalam konfigurasi itu sendiri, tetapi ini merupakan trade-off sadar terhadap keselamatan.) Cukup mudah untuk kembali ke konfigurasi biasa - cukup tambahkan bagian yang hilang.  Lebih mudah untuk memulai dengan konfigurasi yang dikompilasi dan menunda implementasi potongan-potongan tambahan untuk beberapa waktu kemudian. </li><li>  Konfigurasi berversi.  Karena kenyataan bahwa perubahan konfigurasi mengikuti proses pengembangan yang sama, akibatnya kami mendapatkan artefak dengan versi unik.  Ini memungkinkan kita untuk beralih konfigurasi kembali jika diperlukan.  Kami bahkan dapat menggunakan konfigurasi yang digunakan setahun yang lalu dan itu akan bekerja dengan cara yang persis sama.  Konfigurasi yang stabil meningkatkan kemampuan prediksi dan keandalan sistem terdistribusi.  Konfigurasi ini diperbaiki pada waktu kompilasi dan tidak dapat dengan mudah diubah pada sistem produksi. </li><li>  Modularitas  Kerangka yang diusulkan adalah modular dan modul dapat dikombinasikan dengan berbagai cara <br>  mendukung berbagai konfigurasi (pengaturan / tata letak).  Secara khusus, dimungkinkan untuk memiliki tata letak simpul tunggal skala kecil dan pengaturan multi simpul skala besar.  Masuk akal untuk memiliki beberapa tata letak produksi. </li><li>  Pengujian  Untuk tujuan pengujian seseorang dapat mengimplementasikan layanan tiruan dan menggunakannya sebagai ketergantungan dengan cara yang aman.  Beberapa tata letak pengujian yang berbeda dengan berbagai bagian yang diganti dengan tiruan dapat dipertahankan secara bersamaan. </li><li>  Pengujian integrasi.  Terkadang dalam sistem terdistribusi, sulit untuk menjalankan tes integrasi.  Menggunakan pendekatan yang dijelaskan untuk mengetik konfigurasi aman dari sistem terdistribusi lengkap, kita dapat menjalankan semua bagian yang didistribusikan pada server tunggal dengan cara yang terkendali.  Sangat mudah untuk meniru situasi <br>  ketika salah satu layanan menjadi tidak tersedia. </li></ol><br><h4 id="disadvantages">  Kekurangan </h4><br><p>  Pendekatan konfigurasi yang dikompilasi berbeda dari konfigurasi "normal" dan mungkin tidak sesuai dengan semua kebutuhan.  Berikut adalah beberapa kelemahan dari konfigurasi yang dikompilasi: </p><br><ol><li>  Konfigurasi statis.  Mungkin tidak cocok untuk semua aplikasi.  Dalam beberapa kasus ada kebutuhan untuk segera memperbaiki konfigurasi dalam produksi dengan melewati semua langkah-langkah keamanan.  Pendekatan ini membuatnya lebih sulit.  Kompilasi dan pemindahan diperlukan setelah membuat perubahan dalam konfigurasi.  Ini adalah fitur dan bebannya. </li><li>  Generasi konfigurasi.  Ketika konfigurasi dihasilkan oleh beberapa alat otomasi, pendekatan ini membutuhkan kompilasi berikutnya (yang mungkin gagal).  Mungkin diperlukan upaya tambahan untuk mengintegrasikan langkah tambahan ini ke sistem build. </li><li>  Instrumen.  Ada banyak alat yang digunakan saat ini yang bergantung pada konfigurasi berbasis teks.  Beberapa dari mereka <br>  tidak akan berlaku ketika konfigurasi dikompilasi. </li><li>  Diperlukan pergeseran pola pikir.  Pengembang dan DevOps terbiasa dengan file konfigurasi teks.  Gagasan mengkompilasi konfigurasi mungkin tampak aneh bagi mereka. </li><li>  Sebelum memperkenalkan konfigurasi yang dapat dikompilasi, diperlukan proses pengembangan perangkat lunak berkualitas tinggi. </li></ol><br><p>  Ada beberapa batasan contoh yang diterapkan: </p><br><ol><li>  Jika kami memberikan konfigurasi tambahan yang tidak diminta oleh implementasi node, compiler tidak akan membantu kami untuk mendeteksi implementasi yang tidak ada.  Ini dapat diatasi dengan menggunakan <code>HList</code> atau ADT (kelas kasus) untuk konfigurasi simpul, bukan sifat dan Pola Kue. </li><li>  Kami harus menyediakan beberapa boilerplate dalam file konfigurasi: ( <code>package</code> , <code>import</code> , deklarasi <code>object</code> ; <br>  <code>override def</code> untuk parameter yang memiliki nilai default).  Ini mungkin sebagian ditangani menggunakan DSL. </li><li>  Dalam posting ini kami tidak membahas konfigurasi ulang dinamis dari cluster node yang sama. </li></ol><br><h3 id="conclusion">  Kesimpulan </h3><br><p>  Dalam posting ini kita telah membahas ide untuk mewakili konfigurasi secara langsung dalam kode sumber dengan cara yang aman.  Pendekatan ini dapat digunakan dalam banyak aplikasi sebagai pengganti xml- dan konfigurasi berbasis teks lainnya.  Meskipun contoh kita telah diimplementasikan dalam Scala, itu juga dapat diterjemahkan ke bahasa kompilasi lainnya (seperti Kotlin, C #, Swift, dll.).  Orang bisa mencoba pendekatan ini dalam proyek baru dan, jika itu tidak cocok, beralih ke cara lama. </p><br><p>  Tentu saja, konfigurasi yang dapat dikompilasi membutuhkan proses pengembangan yang berkualitas tinggi.  Sebagai imbalannya ia berjanji untuk memberikan konfigurasi yang kuat dan berkualitas tinggi. </p><br><p>  Pendekatan ini dapat diperluas dengan berbagai cara: </p><br><ol><li>  Seseorang dapat menggunakan makro untuk melakukan validasi konfigurasi dan gagal pada waktu kompilasi jika terjadi kegagalan kendala logika bisnis. </li><li>  DSL dapat diimplementasikan untuk mewakili konfigurasi dengan cara yang ramah pengguna-domain. </li><li>  Manajemen sumber daya yang dinamis dengan penyesuaian konfigurasi otomatis.  Sebagai contoh, ketika kita menyesuaikan jumlah node cluster kita mungkin ingin (1) node untuk mendapatkan konfigurasi yang sedikit dimodifikasi;  (2) manajer cluster untuk menerima info node baru. </li></ol><br><h3 id="thanks">  Terima kasih </h3><br><p>  Saya ingin mengucapkan terima kasih kepada Andrey Saksonov, Pavel Popov, Anton Nehaev karena memberikan umpan balik inspirasional pada draft posting ini yang membantu saya membuatnya lebih jelas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447690/">https://habr.com/ru/post/id447690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447680/index.html">Latihan emulasi: manual Xbox 360 FMA</a></li>
<li><a href="../id447682/index.html">Space Data Center: 24 jam sebelum peluncuran</a></li>
<li><a href="../id447684/index.html">Cara menunjukkan nilai-nilai perusahaan di kantor (tanpa poster dan slogan)</a></li>
<li><a href="../id447686/index.html">Parameter yang sangat penting dari lampu LED, yang hanya sedikit orang ketahui</a></li>
<li><a href="../id447688/index.html">Untuk pertanyaan tentang bitset</a></li>
<li><a href="../id447694/index.html">Konfigurasi Sistem Terdistribusi yang Dikompilasi</a></li>
<li><a href="../id447696/index.html">Mengapa kota menentang Amazon Go, toko non-tunai pertama</a></li>
<li><a href="../id447698/index.html">Red Hogwarts: Akademisi tanpa ijazah</a></li>
<li><a href="../id447700/index.html">Fleksibilitas emosional adalah kunci pertumbuhan pribadi.</a></li>
<li><a href="../id447702/index.html">Lingkaran matematika yang ideal tidak ada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>