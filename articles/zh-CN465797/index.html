<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏥 🏀 ✉️ 遗传算法（或者客户永远是王者-常常是傻瓜） 🌒 👩🏻‍🤝‍👨🏼 ✍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="（第2版，修正了错别字-希望大家...） 

 哈Ha！ 

 现在他坐在那里，为一个朋友制作了遗传算法的原型。 启发分享，以及其他一些想法... 

 给定（客户订购）：在某个王国中，仓库有100个牢房。 货物在里面。 如何取数量X以便将所有涉及的单元排空？ 嗯，也就是说，您具有一个单元格类型[3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>遗传算法（或者客户永远是王者-常常是傻瓜）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465797/"> （第2版，修正了错别字-希望大家...） <br><br> 哈Ha！ <br><br> 现在他坐在那里，为一个朋友制作了遗传算法的原型。 启发分享，以及其他一些想法... <br><br> 给定（客户订购）：在某个<s>王国中，</s>仓库有100个牢房。 货物在里面。 如何取数量X以便将所有涉及的单元排空？ 嗯，也就是说，您具有一个单元格类型[34、10、32、32、33、41、44、4、28、23、22、28、29、14、28、15、38、49、30、24， 18、9、15、8、17、9、2、7、30、29、29、2、28、23、19、4、15、30、38、3、14、21、43、50、29， 14，17，12，25，15，23，28，47，38，29，7，36，45，25，6，25，11，10，1，19，37，24，27，50，12， 1，1，44，22，48，13，46，49，11，33，29，4，19，33，12，3，47，27，26，45，40，37，21，2，8， 41，5，1，9，5]-如何拨号，例如40 <br><br> 好吧，你可以破产，肯定有什么聪明的，但是你可以用遗传算法来解决... <br><a name="habracut"></a><br><br> 第一个问题：为什么要动脑筋，因为如果您只浏览列表，则需要从前两个单元格中提取-但是，第二个将是其余的。 而且您不必走太远。 但是要知道，客户是一位完美主义者，他希望它像药房一样。 大概在一个值得金重的牢房仓库里。 它发生了。 <br><br> 第二个问题：如果按升序排序，则肯定可以刷更多的单元格...在我们的示例中，有很多单元格少于十个单元格。 可能，客户也不想；）我也遇到过这样的人：我是老板。 他们告诉您-这样做，不要问问题。 <br><br>  （嗯，不是我的客户，否则我将再次对人的思想失去信心...） <br><br> 好吧，上帝与他同在，每个人都有自己的优先级...然后我们将讨论遗传算法-我们必须以某种方式解决该问题...我们将用Java编写。 <br><br> 对于那些以前从未真正听说过的人：模仿自然母亲。 <br><ol><li> 编码行为 </li><li> 我们借助合适的基准来检查每个选项的工作情况 </li><li> 最好地将其属性传递给下一代 </li></ol><br><br> 在自然界的最后一步，有两个组成部分：交换（染色体相同部分之间的字符交换）和突变（遗传密码的自发改变）。 嗨，高中；） <br><br> 仅此而已。 我们将编码从哪个单元格获取，从哪个单元格获取。 我们有100个单元，这意味着我们的染色体将包含100个真/假元素，为此我选择了String，其中将写入零和一。 当然，他们将是100。 <br><br> 基准测试是此过程中最重要的事情。 大自然正在寻找一个利基市场，而计算机自然将在基准测试中寻找一个漏洞，以愚弄它并生存下来。 太好了，说实话... <br><br> 说了这么多，像这样： <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String chromosome, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> verbose)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] cArr = chromosome.toCharArray(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cnt_bins; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cArr[i] == <span class="hljs-string"><span class="hljs-string">'1'</span></span>) { sum += stock[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (verbose) System.out.println(<span class="hljs-string"><span class="hljs-string">"storage bin "</span></span> + i + <span class="hljs-string"><span class="hljs-string">":\t+"</span></span> + stock[i] + <span class="hljs-string"><span class="hljs-string">"\t= "</span></span> + sum); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == target_qty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.abs(target_qty - sum); }</code> </pre> <br><br> 这个想法是，我们离期望的数字40越远，效果越差。 如果我们获得40分，那么我们在染色体上不会走得更远，我们赢了。 当然，我们将按升序排序-罚分越少越好。 <br><br> 第一代是随机创建的： <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// create 1st generation for (int i = 0; i &lt; generation_size; i++) { StringWriter sw = new StringWriter(); for (int j = 0; j &lt; cnt_bins; j++) { // take stock from this bin? sw.append(rnd.nextBoolean() ? "1" : "0"); } chromosomes.add(sw.toString()); sw.close(); }</span></span></code> </pre> <br><br> 实际上，由于遗传算法可以达到目标，但并不总是可以实现，因此限制世代数很重要。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> generationNo = <span class="hljs-number"><span class="hljs-number">0</span></span>; generationNo &lt; maxGenerationCnt; generationNo++) { <span class="hljs-comment"><span class="hljs-comment">// evaluate List&lt;SimpleEntry&lt;String, Integer&gt;&gt; evaluated = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; chromosomes.size(); i++) { evaluated.add( new SimpleEntry&lt;String, Integer&gt;(chromosomes.get(i), benchmark(chromosomes.get(i), false))); } // ...    , .  ... } System.out.println("No solution found after " + maxGenerationCnt + " iterations");</span></span></code> </pre> <br><br> 排序，留下最好的： <br><br><pre> <code class="java hljs">... <span class="hljs-comment"><span class="hljs-comment">// sort evaluated = evaluated.stream().sorted((e1, e2) -&gt; Integer.compare(e1.getValue(), e2.getValue())) .collect(Collectors.toList()); System.out.println("Generation " + generationNo + "; Best / last parent / worst: " + evaluated.get(0).getValue() + " / " + evaluated.get(best_size).getValue() + " / " + evaluated.get(evaluated.size() - 1).getValue()); if (evaluated.get(0).getValue() == 0) { System.out.println("Solution found"); benchmark(evaluated.get(0).getKey(), true); System.exit(0); } // leave only the best evaluated = evaluated.subList(0, best_size); ...</span></span></code> </pre><br><br> 我们繁殖繁殖，恢复人口规模。 也就是说，我们随机选择父母，组合相同的符号（如果幸运的话，请参阅交换标志），变异（变异标志），等待奇迹... <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// replication List&lt;String&gt; parents = evaluated.stream().map(e -&gt; e.getKey()).collect(Collectors.toList()); chromosomes.clear(); while (chromosomes.size() &lt; generation_size) { int parent1 = rnd.nextInt(evaluated.size()); int parent2 = rnd.nextInt(evaluated.size()); char[] cArr1 = parents.get(parent1).toCharArray(); char[] cArr2 = parents.get(parent2).toCharArray(); for (int i = 0; i &lt; cnt_bins; i++) { boolean exchange = rnd.nextDouble() &lt; exchange_rate; if (exchange) { char c1 = cArr1[i]; char c2 = cArr2[i]; // exchange both values cArr1[i] = c2; cArr2[i] = c1; } // mutation boolean mutation = rnd.nextDouble() &lt; mutation_rate; if (mutation) { cArr1[i] = rnd.nextBoolean() ? '1' : '0'; } mutation = rnd.nextDouble() &lt; mutation_rate; if (mutation) { cArr2[i] = rnd.nextBoolean() ? '1' : '0'; } } chromosomes.add(new String(cArr1)); chromosomes.add(new String(cArr2)); }</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">好吧，这是给你一个奇迹：</b> <div class="spoiler_text"> 目标值：40 <br> 库存：[34、10、32、32、33、41、44、4、28、23、22、28、29、14、28、15、38、49、30、24、18、9、15、8 ，17、9、2、7、30、29、29、2、28、23、19、4、15、30、38、3、14、21、43、50、29、14、17、12、25 ，15，23，28，47，38，29，7，36，45，25，6，25，11，10，1，19，37，24，27，50，12，1，1，44，22 ，48、13、46、49、11、33、29、4、19、33、12、3、47、27、26、45、40、37、21、2、8、41、5、1、9 ，5] <br> 第0代； 最好/最后一个父母/最坏：705/991/1580 <br> 第1代； 最好/最后一个父母/最差：576/846/1175 <br> 第2代； 最好/最后一个父母/最坏：451/722/1108 <br> 第三代； 最好/最后一个父母/最差：0/613/904 <br> 找到解决方案 <br> 储物箱7：+4 = 4 <br> 储物箱10：+22 = 26 <br> 储物箱13：+14 = 40 <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">这是整个代码</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ypk; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.StringWriter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.AbstractMap.SimpleEntry; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Collectors; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.List; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">YPK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> generation_size = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> best_size = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt_bins = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max_stock = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> exchange_rate = .<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> mutation_rate = .<span class="hljs-number"><span class="hljs-number">01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Random rnd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> target_qty = rnd.nextInt(cnt_bins * max_stock / <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// some quantity private static List&lt;String&gt; chromosomes = new ArrayList&lt;&gt;(); private static int maxGenerationCnt = 20; private static int[] stock = new int[cnt_bins]; public static void main(String[] args) throws IOException { System.out.println("Target value: " + target_qty); // create sample stock stock = new int[cnt_bins]; for (int i = 0; i &lt; cnt_bins; i++) { stock[i] = rnd.nextInt(max_stock) + 1; } System.out.println("Stock: " + Arrays.toString(stock)); // create 1st generation for (int i = 0; i &lt; generation_size; i++) { StringWriter sw = new StringWriter(); for (int j = 0; j &lt; cnt_bins; j++) { // take stock from this bin? sw.append(rnd.nextBoolean() ? "1" : "0"); } chromosomes.add(sw.toString()); sw.close(); } for (int generationNo = 0; generationNo &lt; maxGenerationCnt; generationNo++) { // evaluate List&lt;SimpleEntry&lt;String, Integer&gt;&gt; evaluated = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; chromosomes.size(); i++) { evaluated.add( new SimpleEntry&lt;String, Integer&gt;(chromosomes.get(i), benchmark(chromosomes.get(i), false))); } // sort evaluated = evaluated.stream().sorted((e1, e2) -&gt; Integer.compare(e1.getValue(), e2.getValue())) .collect(Collectors.toList()); System.out.println("Generation " + generationNo + "; Best / last parent / worst: " + evaluated.get(0).getValue() + " / " + evaluated.get(best_size).getValue() + " / " + evaluated.get(evaluated.size() - 1).getValue()); if (evaluated.get(0).getValue() == 0) { System.out.println("Solution found"); benchmark(evaluated.get(0).getKey(), true); System.exit(0); } // leave only the best evaluated = evaluated.subList(0, best_size); // replication List&lt;String&gt; parents = evaluated.stream().map(e -&gt; e.getKey()).collect(Collectors.toList()); chromosomes.clear(); while (chromosomes.size() &lt; generation_size) { int parent1 = rnd.nextInt(evaluated.size()); int parent2 = rnd.nextInt(evaluated.size()); char[] cArr1 = parents.get(parent1).toCharArray(); char[] cArr2 = parents.get(parent2).toCharArray(); for (int i = 0; i &lt; cnt_bins; i++) { boolean exchange = rnd.nextDouble() &lt; exchange_rate; if (exchange) { char c1 = cArr1[i]; char c2 = cArr2[i]; // exchange both values cArr1[i] = c2; cArr2[i] = c1; } // mutation boolean mutation = rnd.nextDouble() &lt; mutation_rate; if (mutation) { cArr1[i] = rnd.nextBoolean() ? '1' : '0'; } mutation = rnd.nextDouble() &lt; mutation_rate; if (mutation) { cArr2[i] = rnd.nextBoolean() ? '1' : '0'; } } chromosomes.add(new String(cArr1)); chromosomes.add(new String(cArr2)); } } System.out.println("No solution found after " + maxGenerationCnt + " iterations"); } private static int benchmark(String chromosome, boolean verbose) { int sum = 0; char[] cArr = chromosome.toCharArray(); for (int i = 0; i &lt; cnt_bins; i++) { if (cArr[i] == '1') { sum += stock[i]; if (verbose) System.out.println("storage bin " + i + ":\t+" + stock[i] + "\t= " + sum); } if (sum == target_qty) { return 0; } } return Math.abs(target_qty - sum); } }</span></span></code> </pre> <br></div></div><br><br> 最后：如果您混淆了参数-太多的突变，太小的人口规模等等。  -会停滞甚至产生所有最差的结果。 <br><br> 顺便说一句，这个问题通常已经随机解决了，不需要下一代:)如果您想使计算机的寿命复杂化，请从基准中删除此回报： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == target_qty) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br> 这会使任务复杂化，并使计算机遭受一些冲击。 <br><br> 祝你好运 <br><br>  m_OO_m </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465797/">https://habr.com/ru/post/zh-CN465797/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465787/index.html">爱山羊</a></li>
<li><a href="../zh-CN465789/index.html">培训Cisco 200-125 CCNA v3.0。 第29天。PAT和NAT</a></li>
<li><a href="../zh-CN465791/index.html">零售商漏洞-可以在请求中获得OTP的三种情况</a></li>
<li><a href="../zh-CN465793/index.html">前端每周摘要（2019年8月26日至9月1日）</a></li>
<li><a href="../zh-CN465795/index.html">上周第378期（2019年8月26日至9月1日）的前端世界摘要</a></li>
<li><a href="../zh-CN465801/index.html">食品设计文摘，2019年8月</a></li>
<li><a href="../zh-CN465803/index.html">建立Go项目的Maven方法</a></li>
<li><a href="../zh-CN465805/index.html">Gigatron-不含处理器的自制微型计算机</a></li>
<li><a href="../zh-CN465807/index.html">流行的JavaScript库如何开始在终端上展示广告的故事</a></li>
<li><a href="../zh-CN465809/index.html">不要陷入过早优化的陷阱</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>