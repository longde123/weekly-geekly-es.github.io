<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏜️ 🕉️ 👩🏻‍🏭 Attention - GAZ! ou comment nous avons fait des contrats intelligents non gazéifiés 👩🏽‍⚕️ 📃 🗞️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La blockchain et les contrats intelligents sont toujours un sujet brûlant chez les développeurs et les techniciens. Il y a beaucoup de recherches et d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Attention - GAZ! ou comment nous avons fait des contrats intelligents non gazéifiés</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/440702/"><p><img src="https://habrastorage.org/webt/ps/lh/d4/pslhd4hgoxgjskexszwtn40mivo.png"></p><br><p>  La blockchain et les contrats intelligents sont toujours un sujet brûlant chez les développeurs et les techniciens.  Il y a beaucoup de recherches et de discussions sur leur avenir et où tout va et où cela mènera.  Chez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Waves Platform,</a> nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">avons</a> notre propre opinion sur ce que devraient être les contrats intelligents, et dans cet article, je vous dirai comment nous les avons fait, quels problèmes nous avons rencontrés et pourquoi ils ne sont pas comme les contrats intelligents d'autres projets de blockchain (tout d'abord Ethereum). </p><br><p>  Cet article est également un guide pour ceux qui veulent comprendre le fonctionnement des contrats intelligents dans le réseau Waves, essayer d'écrire votre propre contrat et vous familiariser avec les outils dont les développeurs disposent déjà. </p><a name="habracut"></a><br><h2 id="kak-my-doshli-do-zhizni-takoy">  Comment en sommes-nous arrivés à une telle vie? </h2><br><p>  On nous a souvent demandé quand avons-nous obtenu des contrats intelligents, car les développeurs ont apprécié la facilité de travailler avec le réseau, la vitesse du réseau (grâce à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Waves NG</a> ) et le faible niveau de commissions.  Cependant, les contrats intelligents offrent beaucoup plus de place à l'imagination. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les contrats intelligents</a> sont devenus très populaires ces dernières années en raison de la propagation de la blockchain.  Ceux qui ont rencontré la technologie blockchain dans leur travail, lorsqu'ils mentionnent les contrats intelligents, pensent généralement à Ethereum et Solidity.  Mais il existe de nombreuses plates-formes blockchain avec des contrats intelligents, et la plupart d'entre elles ont simplement répété ce qu'Ethereum a fait (machine virtuelle + leur propre langage de contrat).  Une liste intéressante avec différentes langues et approches se trouve dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce référentiel</a> . </p><br><h2 id="chto-takoe-smart-kontrakt">  Qu'est-ce qu'un contrat intelligent? </h2><br><p>  Au sens large, un contrat intelligent est un protocole conçu pour soutenir, vérifier et faire respecter les termes d'une transaction ou l'exécution de contrats entre des parties.  L'idée a été proposée pour la première fois en 1996 par Nick Szabo, mais les contrats intelligents ne sont devenus populaires que ces dernières années. </p><br><p>  D'un point de vue technique (qui nous intéresse davantage), un contrat intelligent est un algorithme (code) qui est exécuté non pas sur un seul serveur ou ordinateur, mais sur de nombreux (ou tous) nœuds du réseau de la blockchain, c'est-à-dire  décentralisé. </p><br><h2 id="kak-eto-rabotaet">  Comment ça marche? </h2><br><p>  Le premier prototype d'un contrat intelligent sur la blockchain est correctement considéré comme un script Bitcoin - incomplet par Turing, un langage basé sur la pile sur le réseau Bitcoin.  Il n'y a pas de concept de compte dans Bitcoin, mais des entrées et des sorties.  Dans Bitcoin, lors d'une transaction (création d'une sortie), il est nécessaire de se référer à la transaction de réception (entrée).  Si vous êtes intéressé par les détails techniques de l'appareil Bitcoin, je vous recommande de lire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette série d'articles</a> .  Puisqu'il n'y a pas de compte dans Bitcoin, Bitcoin Script détermine dans quel cas l'une ou l'autre sortie peut être dépensée. </p><br><p> Ethereum offre beaucoup plus de fonctionnalités, comme  Fournit Solidity, un langage complet de Turing qui s'exécute dans une machine virtuelle à l'intérieur de chaque nœud.  Une grande puissance s'accompagne d'une grande responsabilité et d'un large éventail de possibilités - un nombre assez important de restrictions, dont nous parlerons plus tard. </p><br><h1 id="smart-kontrakty-waves">  Contrats intelligents Waves </h1><br><p>  Comme je l'ai écrit ci-dessus, on nous a souvent posé des questions sur les contrats intelligents, mais nous ne voulions pas faire «comme à l'antenne» ou «comme dans n'importe quel nom de chaîne», et il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plusieurs raisons à cela</a> .  Par conséquent, nous avons analysé les cas existants pour les contrats et comment nous pouvons aider à résoudre de vrais problèmes avec leur aide. </p><br><p>  Après avoir analysé les scénarios d'utilisation, nous avons découvert qu'il existe 2 grandes catégories de tâches qui sont généralement résolues à l'aide de contrats intelligents: </p><br><ol><li>  Tâches simples et directes comme multisig, swaps atomiques ou séquestre. </li><li>  dApps, applications décentralisées à part entière avec logique utilisateur.  Pour être plus précis, il s'agit d'un backend pour les applications décentralisées.  Les exemples les plus frappants sont Cryptokitties ou Bancor. </li></ol><br><p>  Il existe également un troisième type de contrat, le plus populaire - les jetons.  Sur le réseau Ethereum, par exemple, la grande majorité des contrats de travail sont des jetons standard ERC20.  Dans Waves, pour créer des jetons, il n'est pas nécessaire de créer des contrats intelligents, car  ils font partie de la blockchain elle-même, et pour émettre un jeton (avec la possibilité de l'échanger immédiatement sur un échange décentralisé (DEX)), il suffit d'envoyer une transaction du type d'émission (transaction d'émission). </p><br><p>  Pour les deux types de tâches ci-dessus (pour des raisons de simplicité, nous appellerons des cas simples et complexes) les exigences concernant la langue, les contrats et les concepts sont très différentes.  Oui, nous pouvons dire qu'avoir un langage complet de Turing peut résoudre à la fois des problèmes simples et complexes, mais il y a une condition importante: le langage devrait aider à éviter les erreurs.  Cette exigence est également importante pour les langues ordinaires et pour les langues des contrats intelligents, elle est particulièrement importante, car  les opérations sont financièrement liées, et les contrats sont souvent immuables, et il n'y a aucun moyen de corriger une erreur rapidement et facilement. </p><br><p>  Compte tenu des types de tâches décrites ci-dessus, nous avons décidé de progresser progressivement et de donner un outil pour résoudre des problèmes simples comme première étape, et de donner un langage qui puisse facilement implémenter n'importe quelle logique utilisateur comme étape suivante.  En conséquence, le système s'est avéré être beaucoup plus puissant que nous ne l'imaginions au début du voyage. </p><br><h2 id="sdelaem-akkaunty-umnymi">  Rendons les comptes intelligents </h2><br><p>  Progressivement, nous sommes arrivés au concept de comptes intelligents, qui sont conçus pour résoudre des tâches principalement simples.  Leur idée est très similaire à Bitcoin Script: des règles supplémentaires peuvent être ajoutées au compte qui déterminent la validité de la transaction sortante.  Les principales exigences pour les comptes intelligents étaient: </p><br><ol><li>  Sécurité maximale.  Presque chaque mois, vous pouvez trouver des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouvelles</a> qu'une autre vulnérabilité a été trouvée dans les contrats modèles Ethereum.  Nous voulions éviter cela. </li><li>  Pas besoin de gaz, donc la commission est fixe.  Pour ce faire, le script doit être exécuté dans un délai prévisible et avoir des limites de taille assez strictes. </li></ol><br><p>  Avant de passer aux détails techniques de la mise en œuvre et de la rédaction des contrats, nous décrivons certaines caractéristiques de la blockchain Waves qui seront importantes pour une meilleure compréhension: </p><br><ol><li>  La blockchain Waves compte actuellement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">13 types de transactions différents.</a> </li></ol><br><p><img src="https://habrastorage.org/webt/dx/to/mz/dxtomzcjjyp7jgwa9wcsmfana1u.png"></p><br><ol><li>  Dans la blockchain Waves, pas les entrées et sorties (comme dans Bitcoin), mais les comptes (comme, par exemple, dans Nxt).  Une transaction est effectuée pour le compte d'un compte spécifique. </li><li>  Par défaut, l'exactitude d'une transaction est déterminée par l'état actuel de la blockchain et la validité de la signature au nom de laquelle la transaction est envoyée.  La représentation JSON de la transaction semble assez simple: </li></ol><br><p><img src="https://habrastorage.org/webt/gl/0a/m-/gl0am-s8dyjwnsgnksk0tf1fzyu.png"></p><br><p> Étant donné que nous avons déjà différents types de transactions dans la blockchain, nous avons décidé de ne pas créer une entité distincte en tant que compte intelligent, mais d'ajouter une nouvelle transaction qui transforme un compte régulier en un compte intelligent.  Tout compte peut devenir un compte intelligent avec des règles de validation de transaction modifiées, pour cela, le compte doit simplement envoyer une transaction du type <code>SetScriptTransaction</code> , qui contient le contrat compilé. </p><br><p>  Dans le cas d'un compte intelligent, le contrat est une règle de validation pour chaque _ transaction sortante. </p><br><h2 id="a-chto-tam-s-gazom">  Et le gaz? </h2><br><p>  L'une des principales tâches que nous nous sommes fixées est de nous débarrasser du gaz pour des opérations simples.  Cela ne signifie pas qu'il n'y aura pas de commission.  Il est nécessaire pour que les mineurs aient intérêt à exécuter des scripts.  Nous avons abordé la question du côté pratique et décidé de procéder à des tests de performance et de calculer la vitesse des différentes opérations.  Pour cela, des benchmarks utilisant JMH ont été développés.  Les résultats peuvent être vus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Les limitations qui en résultent sont: </p><br><ol><li>  Le script doit s'exécuter plus rapidement que 20 opérations de vérification de signature, ce qui signifie que les vérifications pour un compte intelligent ne seront pas plus de 20 fois plus lentes que pour un compte normal.  La taille du script ne doit pas dépasser 8 Ko. </li><li>  Pour rendre rentable pour les mineurs l'exécution de contrats intelligents, nous avons fixé une commission supplémentaire minimale pour les comptes intelligents d'un montant de 0,004 ONDES.  La commission minimale dans le réseau Waves pour une transaction est de 0,001 WAVES, dans le cas d'un compte intelligent - 0,005 WAVES. </li></ol><br><h1 id="yazyk-dlya-smart-kontraktov">  Langage pour les contrats intelligents </h1><br><p>  L'une des tâches les plus difficiles a été la création de leur propre langage de contrats intelligents.  Prendre n'importe quel langage existant et l'adapter (découper) pour nos tâches semble tirer à partir d'un canon sur des moineaux: en plus de cela, dépendre de la base de code de quelqu'un d'autre dans un projet de blockchain est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extrêmement risqué</a> . </p><br><p>  Essayons d'imaginer quel devrait être le langage idéal pour les contrats intelligents.  À mon avis, tout langage de programmation devrait forcer à écrire du code "correct" et sûr, c'est-à-dire  idéalement, il ne devrait y avoir qu'une seule bonne façon.  Oui, si vous le souhaitez, vous pouvez écrire du code complètement illisible et non pris en charge dans n'importe quelle langue, mais cela devrait être plus difficile que de l'écrire correctement (bonjour PHP et JavaScript).  Dans le même temps, le langage devrait être pratique pour le développement.  Étant donné que le langage s'exécute sur tous les nœuds du réseau, il est nécessaire qu'il soit aussi efficace que possible - une exécution paresseuse peut économiser beaucoup de ressources.  J'aimerais aussi avoir un système de typage puissant dans la langue, de préférence algébrique, car il permet de décrire le contrat le plus clairement possible et de se rapprocher du rêve de "Code is law".  Si nous formalisons un peu plus nos exigences, nous obtenons les paramètres de langue suivants: </p><br><ol><li>  Soyez strictement et statiquement tapé.  Un typage fort élimine automatiquement de nombreuses erreurs de programmation potentielles. </li><li>  Ayez un système de frappe puissant pour vous empêcher de vous tirer une balle dans le pied. </li><li>  Soyez paresseux pour ne pas perdre de précieux cycles de traitement. </li><li>  Avoir des fonctions spécifiques dans la bibliothèque standard pour travailler avec la blockchain, par exemple, les hachages.  Dans le même temps, la bibliothèque de langues standard ne doit pas être surchargée, car il doit toujours y avoir une bonne façon. </li><li>  Ne pas avoir d'exceptions lors de l'exécution. </li></ol><br><p>  Dans notre langage RIDE, nous avons essayé de prendre en compte ces fonctionnalités importantes, et comme nous développons beaucoup sur Scala et comme la programmation fonctionnelle, le langage est à certains égards similaire à Scala et F #. </p><br><p>  Les plus gros problèmes dans la mise en œuvre dans la pratique se sont posés avec la dernière exigence, car si vous n'avez pas d'exceptions dans la langue, alors, par exemple, l'opération d'ajout devra renvoyer une <em>option</em> , qui devra être vérifiée pour le débordement, ce qui sera certainement gênant pour les développeurs.  Les exceptions étaient un compromis, mais sans possibilité de les intercepter - s'il y avait une exception, la transaction n'était pas valide.  Un autre problème était de transférer dans la langue tous les modèles de données que nous avons dans la blockchain.  J'ai déjà décrit que dans Waves, il existe 13 types de transactions différents qui doivent être pris en charge dans la langue et avoir accès à tous leurs domaines. </p><br><p>  Des informations complètes sur les opérations disponibles et les types de données dans RIDE se trouvent sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la page de description du langage</a> .  Parmi les caractéristiques intéressantes de la langue, nous pouvons également souligner le fait que la langue est basée sur l'expression, c'est-à-dire que tout est expression, ainsi que la présence d'une correspondance de modèle, ce qui vous permet de décrire facilement les conditions de différents types de transactions: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t:<span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.recepient <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t:<span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; t.transfers <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> }</code> </pre> <br><p>  Toute personne intéressée à apprendre comment fonctionne le code RIDE vaut la peine de consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le livre blanc</a> , qui décrit toutes les étapes de l'utilisation d'un contrat: analyse, compilation, désérialisation, calcul de la complexité et de l'exécution du script.  Les deux premières étapes - l'analyse et la compilation sont effectuées hors chaîne, seul le contrat compilé en base64 entre dans la blockchain.  La désérialisation, le calcul de la complexité et l'exécution se font en chaîne et plusieurs fois à différentes étapes: </p><br><ol><li>  Lorsque vous recevez une transaction et l'ajoutez à UTX, sinon il y aura une situation où la transaction sera acceptée par le nœud de la chaîne de blocs, par exemple via l'API REST, mais n'entrera jamais dans le bloc. </li><li>  Lorsqu'un bloc est formé, le nœud d'exploration de données valide les transactions et le script est requis. </li><li>  Dès réception par les nœuds non miniers d'un bloc et validation des transactions qui y sont incluses. </li></ol><br><p>  Chaque optimisation dans l'utilisation des contrats devient précieuse, car elle est effectuée plusieurs fois sur de nombreux nœuds de réseau.  Désormais, les nœuds Waves s'exécutent silencieusement sur des machines virtuelles pour 15 $ chez DigitalOcean, malgré l'augmentation des charges de travail après la publication des comptes intelligents. </p><br><h2 id="a-chto-v-itoge">  Quel est le résultat? </h2><br><p>  Voyons maintenant ce que nous avons obtenu à Waves.  Nous rédigerons notre premier contrat, que ce soit un contrat multisig 2-of-3 standard.  Pour rédiger un contrat, vous pouvez utiliser l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDE en ligne</a> (réglage de la langue - un sujet pour un article séparé).  Créez un nouveau contrat vide (Nouveau → Contrat vide). </p><br><p>  Tout d'abord, nous annoncerons les clés publiques d'Alice, Bob et Cooper, qui contrôleront le compte.  Vous aurez besoin de 2 de leurs 3 signatures: </p><br><pre> <code class="scala hljs">let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'B1Yz7fH1bJ2gVDjyJnuyKNTdMFARkKEp</span></span>V' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'7hghYeWtiekfebgAcuCg9ai2NXbRreNz</span></span>c' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8'</code> </pre> <br><p>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation décrit</a> la fonction <code>sigVerify</code> , qui vous permet de vérifier la signature de la transaction: </p><br><p><img src="https://habrastorage.org/webt/fw/am/py/fwampygopgdhgrmb9v4z67mkszq.png"></p><br><p>  Les arguments de la fonction sont le corps de la transaction, la signature vérifiée et la clé publique.  Un objet <code>tx</code> est disponible dans le contrat dans la portée globale, dans lequel les informations de transaction sont stockées.  Cet objet a un champ <code>tx.bodyBytes</code> qui contient les octets de la transaction envoyée.  Il existe également un tableau de <code>tx.proofs</code> , qui stocke des signatures, qui peuvent aller jusqu'à 8. Il convient de noter qu'en fait, vous pouvez envoyer non seulement des signatures à <code>tx.proofs</code> , mais toute autre information pouvant être utilisée par le contrat. </p><br><p>  Nous pouvons nous assurer que toutes les signatures sont présentées et qu'elles sont dans le bon ordre en utilisant 3 lignes simples: </p><br><pre> <code class="scala hljs">let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Eh bien, la dernière étape sera de vérifier qu'au moins 2 signatures sont soumises. </p><br><pre> <code class="scala hljs">aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  L'ensemble du contrat de multi-signature 2 sur 3 ressemble à ceci: </p><br><pre> <code class="scala hljs">#    let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'B1Yz7fH1bJ2gVDjyJnuyKNTdMFARkKEp</span></span>V' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'7hghYeWtiekfebgAcuCg9ai2NXbRreNz</span></span>c' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8' #       let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> # ,      <span class="hljs-number"><span class="hljs-number">2</span></span>   aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  Remarque: il n'y a pas de mots-clés comme <code>return</code> dans le code, car la dernière ligne exécutée est considérée comme le résultat du script, et c'est pourquoi il doit toujours retourner <code>true</code> ou <code>false</code> </p><br><p>  En comparaison, le contrat multi-signature Ethereum commun <a href="">semble beaucoup plus compliqué</a> .  Même des variantes relativement simples ressemblent à ceci: </p><br><pre> <code class="plaintext hljs"> pragma solidity ^0.4.22; contract SimpleMultiSig { uint public nonce; // (only) mutable state uint public threshold; // immutable state mapping (address =&gt; bool) isOwner; // immutable state address[] public ownersArr; // immutable state // Note that owners_ must be strictly increasing, in order to prevent duplicates constructor(uint threshold_, address[] owners_) public { require(owners_.length &lt;= 10 &amp;&amp; threshold_ &lt;= owners_.length &amp;&amp; threshold_ &gt;= 0); address lastAdd = address(0); for (uint i = 0; i &lt; owners_.length; i++) { require(owners_[i] &gt; lastAdd); isOwner[owners_[i]] = true; lastAdd = owners_[i]; } ownersArr = owners_; threshold = threshold_; } // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length &amp;&amp; sigR.length == sigV.length); // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191 bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce); address lastAdd = address(0); // cannot have address(0) as an owner for (uint i = 0; i &lt; threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered &gt; lastAdd &amp;&amp; isOwner[recovered]); lastAdd = recovered; } // If we make it here all signatures are accounted for. // The address.call() syntax is no longer recommended, see: // https://github.com/ethereum/solidity/issues/2884 nonce = nonce + 1; bool success = false; assembly { success := call(gas, destination, value, add(data, 0x20), mload(data), 0, 0) } require(success); } function () payable public {} }</code> </pre> <br><p>  L'IDE a une console intégrée qui vous permet de compiler immédiatement un contrat, de le déployer, de créer des transactions et de voir le résultat de l'exécution.  Et si vous voulez travailler sérieusement avec les contrats, je vous recommande de regarder les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèques pour différents langages</a> et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plugin pour Visual Studio Code</a> . </p><br><p>  Si vos mains vous démangent, à la fin de l'article, il y a les liens les plus importants avec lesquels commencer la plongée. </p><br><h2 id="sistema-moschnee-chem-yazyk">  Le système est plus puissant que la langue </h2><br><p>  La blockchain Waves a des types de données spéciaux pour stocker des données - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transactions de données</a> .  Ils fonctionnent comme un stockage de valeur-clé associé à un compte, c'est-à-dire, dans un sens, c'est l'état du compte. </p><br><p><img src="https://habrastorage.org/webt/3o/oh/4h/3ooh4hitfov4sdfhobfhglpec98.png"></p><br><p>  La date de transaction peut contenir des chaînes, des nombres, des valeurs booléennes et des tableaux d'octets jusqu'à 32 Ko par clé.  Un exemple d'utilisation des transactions de données, qui vous permet d'envoyer une transaction uniquement si le stockage de valeurs-clés du compte contient déjà le numéro 42 sur la <code>key</code> : </p><br><pre> <code class="scala hljs">let keyName = <span class="hljs-string"><span class="hljs-string">"key"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (tx) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tx:<span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let x = extract(getInteger(tx.sender, keyName)) x == <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><blockquote>  Grâce à Data Transaction, les comptes intelligents deviennent un outil extrêmement puissant qui vous permet de travailler avec des oracles, de gérer l'état et de décrire facilement les comportements. </blockquote><p><img src="https://habrastorage.org/webt/ew/ce/gf/ewcegfy0nsj4s8t34c6sn2v7hew.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cet article</a> décrit comment vous pouvez implémenter des NFT (jetons non fongibles) à l'aide de transactions de données et d'un contrat intelligent qui contrôle l'état.  Par conséquent, le style du compte contiendra des entrées du formulaire: </p><br><pre> <code class="plaintext hljs">+------------+-----------------------------------------------+ | Token Name | Owner Publc Key | +------------+-----------------------------------------------+ | "Token #1" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | | "Token #2" | "3tNLxyJnyxLzDkMkqiZmUjRqXe1UuwFeSyQ14GRYnGL" | | "Token #3" | "3wH7rENpbS78uohErXHq77yKzQwRyKBYhzCR9nKU17q" | | "Token #4" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | | "Token #5" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | +------------+-----------------------------------------------+</code> </pre> <br><p>  Le contrat NFT lui-même semble extrêmement simple: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dt: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let oldOwner = extract(getString(dt.sender, dt.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) let newOwner = getBinary(dt.data, <span class="hljs-number"><span class="hljs-number">0</span></span>) size(dt.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; sigVerify(dt.bodyBytes, dt.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], fromBase58String(oldOwner)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h1 id="a-chto-dalshe">  Et ensuite? </h1><br><p>  Le développement ultérieur des contrats intelligents Waves est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ride4DApps</a> , qui permettra d'appeler des contrats sur d'autres comptes, et un langage (ou système) complet de Turing qui vous permettra de résoudre tous les types de tâches, de déclencher d'autres tâches, etc. </p><br><p>  Une autre direction intéressante pour le développement de contrats intelligents dans l'écosystème Waves est Smart Assets, qui fonctionne sur un principe similaire - les contrats de Turing incomplets qui se rapportent au jeton.  Le contrat contrôle les conditions dans lesquelles les transactions de jetons peuvent être effectuées.  Par exemple, avec leur aide, il sera possible de geler les jetons à une certaine hauteur de blockchain ou d'interdire le trading de jetons p2p.  Vous pouvez en savoir plus sur les actifs intelligents <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le blog</a> . </p><br><p>  Eh bien, à la fin, je vais à nouveau vous donner une liste de ce qui sera nécessaire pour commencer à travailler avec des contrats intelligents sur le réseau Waves. </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La documentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IDE avec console</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Livre blanc pour les plus curieux</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr440702/">https://habr.com/ru/post/fr440702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr440692/index.html">Quel est le problème avec les tests A / B</a></li>
<li><a href="../fr440694/index.html">Créez une scène de base dans A-Frame</a></li>
<li><a href="../fr440696/index.html">Boîte à outils de refactorisation de base de données: Flyway vs. Liquibase</a></li>
<li><a href="../fr440698/index.html">6 idées d'applications de réalité augmentée (RA) intéressantes</a></li>
<li><a href="../fr440700/index.html">«Forces spéciales» de Data Science en interne</a></li>
<li><a href="../fr440706/index.html">InoThings ++ Professional IoT Conference - Ce qui était et ce qui sera</a></li>
<li><a href="../fr440708/index.html">Webinaire ouvert "Travail: le sien et celui d'un autre"</a></li>
<li><a href="../fr440710/index.html">Deux aspects de WebView: démarrage rapide de projets et vol de données personnelles</a></li>
<li><a href="../fr440712/index.html">Le cloud n'est que l'ordinateur de quelqu'un</a></li>
<li><a href="../fr440714/index.html">Comment la baisse du taux d'acquisition nous affecte (titulaires de carte)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>