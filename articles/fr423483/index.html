<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 👩🏼‍🌾 👩‍👩‍👦‍👦 Trouver la bonne façon de séparer le contenu d'un site Web à l'aide de Webpack 💆🏽 🐗 🔜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Trouver la meilleure façon d'organiser le matériel d'un projet Web peut être une tâche ardue. Il existe de nombreux scénarios différents permettant au...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trouver la bonne façon de séparer le contenu d'un site Web à l'aide de Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423483/">  Trouver la meilleure façon d'organiser le matériel d'un projet Web peut être une tâche ardue.  Il existe de nombreux scénarios différents permettant aux utilisateurs de travailler avec des projets, de nombreuses technologies et d'autres facteurs qui doivent être pris en compte. <br><br>  L'auteur du matériel, dont nous publions la traduction aujourd'hui, dit qu'il veut dire ici tout ce que vous devez savoir pour la préparation compétente du matériel de projet Web pour le travail.  Premièrement, il s'agira de choisir une stratégie de séparation des fichiers de site la mieux adaptée à un projet particulier et à ses utilisateurs.  Deuxièmement, les moyens de mettre en œuvre la stratégie choisie seront examinés. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/7fe/270/c2c/7fe270c2cd5aad585ca616a6f3704704.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Informations générales</font> </h2><br>  Selon le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">glossaire Webpack</a> , il existe deux stratégies de partage de fichiers.  Il s'agit du fractionnement de bundle et du fractionnement de code.  Ces termes peuvent sembler être utilisés de manière interchangeable, mais ils ne le sont pas. <br><br><ul><li>  Le fractionnement d'un bundle est une technique pour diviser de gros bundles en plusieurs parties, qui sont des fichiers plus petits.  Ces fichiers, dans tous les cas, comme lorsque vous travaillez avec un seul bundle, seront téléchargés par tous les utilisateurs du site.  La force de cette technique est d'améliorer l'utilisation des mécanismes de mise en cache basés sur un navigateur. </li><li>  La séparation de code est une approche qui implique de charger dynamiquement le code selon les besoins.  Cela conduit au fait que l'utilisateur ne télécharge que le code dont il a besoin pour travailler avec une certaine partie du site à un certain moment. </li></ul><br>  Le fractionnement de code semble être beaucoup plus intéressant que le fractionnement de code.  Et, en fait, on a le sentiment que dans de nombreux articles sur notre sujet, l'accent est mis sur la séparation du code, cette technique est considérée comme le seul moyen intéressant d'optimiser les matériaux du site. <br><br>  Cependant, je voudrais dire que pour de nombreux sites, c'est la première stratégie qui a beaucoup plus de valeur - la séparation des bundles.  Et, peut-être, littéralement, tous les projets Web peuvent gagner à sa mise en œuvre. <br><br>  Parlons de cela plus en détail. <br><br><h2>  <font color="#3AC1EF">Séparation des faisceaux</font> </h2><br>  La technique de fractionnement des faisceaux est basée sur une idée très simple.  Si vous avez un gros fichier et que vous y changez une seule ligne de code, l'utilisateur régulier devra télécharger l'intégralité du fichier lors de sa prochaine visite sur le site.  Cependant, si vous divisez ce fichier en deux fichiers, le même utilisateur devra télécharger uniquement celui qui a été modifié et le deuxième fichier sera extrait du cache du navigateur. <br><br>  Il convient de noter que, puisque l'optimisation des matériaux du site en fractionnant les bundles est liée à la mise en cache, les utilisateurs visitant le site pour la première fois devront de toute façon télécharger tous les matériaux, donc cela ne fait aucune différence pour eux que ces matériaux soient présentés sous la forme d'un fichier unique ou de plusieurs . <br><br>  Il me semble que trop de discussions sur la performance des projets web sont dédiées aux utilisateurs qui visitent le site pour la première fois.  C'est peut-être le cas, en partie à cause de l'importance de la première impression que le projet va donner à l'utilisateur, ainsi que du fait que la quantité de données transmises aux utilisateurs lors de leur première visite sur le site est simple et pratique à mesurer. <br><br>  En ce qui concerne les visiteurs réguliers, il peut être difficile de mesurer l'impact des techniques d'optimisation des matériaux qui leur sont appliquées.  Mais nous devons simplement connaître les conséquences de telles optimisations. <br><br>  Pour analyser ces choses, vous avez besoin de quelque chose comme une feuille de calcul.  Vous devrez également créer une liste stricte de conditions dans lesquelles nous pouvons tester chacune des stratégies de mise en cache étudiées. <br><br>  Voici un script qui correspond à la description générale donnée dans le paragraphe précédent: <br><br><ul><li>  Alice visite notre site une fois par semaine pendant 10 semaines. </li><li>  Nous mettons à jour le site une fois par semaine. </li><li>  Chaque semaine, nous mettons à jour la page de liste des produits. </li><li>  De plus, nous avons une page avec les détails du produit, mais nous n'y travaillons pas encore. </li><li>  Au cours de la cinquième semaine, nous ajoutons un nouveau package npm aux documents du projet. </li><li>  Au cours de la huitième semaine, nous mettons à jour l'un des packages npm déjà utilisés dans le projet. </li></ul><br>  Il y a des gens (comme moi) qui essaieront de rendre un tel scénario aussi réaliste que possible.  Mais vous n'avez pas besoin de faire ça.  Le vrai scénario ici n'a pas vraiment d'importance.  Pourquoi en est-il ainsi - nous le saurons bientôt. <br><br><h3>  <font color="#3AC1EF">▍ Conditions initiales</font> </h3><br>  Supposons que la taille totale de notre package JavaScript soit considérable de 400 Ko et que, dans les conditions actuelles, nous transférons tout cela à l'utilisateur sous la forme d'un seul fichier <code>main.js</code>  Nous avons une configuration Webpack, qui, en termes généraux, est similaire à la suivante (j'ai supprimé les choses qui ne sont pas pertinentes pour notre conversation): <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); module.exports = { entry: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'src/index.js'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: {   <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'dist'</span></span>),   filename: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].js'</span></span>, }, };</code> </pre> <br>  Webpack nomme le fichier <code>main.js</code> résultant lorsqu'il existe une seule entrée dans la configuration. <br><br>  Si vous n'avez pas une très bonne idée de travailler avec le cache, gardez à l'esprit que chaque fois que j'écris <code>main.js</code> ici, je veux dire quelque chose comme <code>main.xMePWxHo.js</code> .  Une séquence de caractères fous est un hachage du contenu d'un fichier, ce qu'on appelle <code>contenthash</code> dans la configuration.  L'utilisation de cette approche conduit au fait que, lors du changement de code, les noms de fichiers changent également, ce qui oblige le navigateur à télécharger de nouveaux fichiers. <br><br>  Conformément au scénario ci-dessus, lorsque nous <code>contenthash</code> des modifications au code du site chaque semaine, la ligne <code>contenthash</code> du package change.  En conséquence, visitant chaque semaine notre site, Alice est obligée de télécharger un nouveau fichier de 400 Ko. <br><br>  Si nous fabriquons une belle tablette (avec une ligne de résultat inutile jusqu'à présent) contenant des données sur le volume hebdomadaire de chargement de données par ce fichier, alors nous obtenons ce qui suit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b6/fa6/424/3b6fa6424d43c147b40c5347e4dfa104.png"></div><br>  <i><font color="#999999">La quantité de données téléchargées par l'utilisateur</font></i> <br><br>  En conséquence, il apparaît que l'utilisateur, en 10 semaines, a téléchargé 4,12 Mo de code.  Cet indicateur peut être amélioré. <br><br><h3>  <font color="#3AC1EF">▍Séparation des packages tiers du code principal</font> </h3><br>  Divisez le grand emballage en deux parties.  Notre propre code sera dans le fichier <code>main.js</code> et le code tiers dans le fichier <code>vendor.js</code> .  C'est facile à faire, la configuration Webpack suivante nous aidera avec ceci: <br><br><pre> <code class="hljs lua">const <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); module.exports = { entry: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'src/index.js'</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>: {   <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>.resolve(__dirname, <span class="hljs-string"><span class="hljs-string">'dist'</span></span>),   filename: <span class="hljs-string"><span class="hljs-string">'[name].[contenthash].js'</span></span>, }, optimization: {   splitChunks: {     chunks: <span class="hljs-string"><span class="hljs-string">'all'</span></span>,   }, }, };</code> </pre> <br>  Webpack 4 essaie de rendre la vie aussi simple que possible pour le développeur, il fait donc tout ce qu'il peut et ne lui demande pas de savoir exactement comment diviser les bundles en parties. <br><br>  Ce type de comportement automatique du programme conduit à quelques délices, tels que: "Eh bien, quel charme ce Webpack est", et à de nombreuses questions dans l'esprit: "Qu'est-ce que cela fait avec mes bundles?". <br><br>  Dans tous les cas, l'ajout d' <code>optimization.splitChunks.chunks = 'all'</code> à la configuration de configuration indique à Webpack que nous en avons besoin pour tout prendre dans <code>node_modules</code> et le mettre dans le <code>vendors~main.js</code> <br><br>  Après avoir fait une telle séparation de base du bundle, Alice, qui visite régulièrement notre site chaque semaine, téléchargera le fichier <code>main.js</code> de 200 Ko à chaque fois qu'elle visite.  Mais elle ne téléchargera le fichier <code>vendor.js</code> que trois fois.  Cela se produira lors des visites des première, cinquième et huitième semaines.  Voici le tableau correspondant, dans lequel, par la volonté du destin, les tailles des <code>vendor.js</code> <code>main.js</code> et <code>vendor.js</code> au cours des quatre premières semaines coïncident et sont égales à 200 Ko. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f52/61f/49f/f5261f49f5f3dba9c34fec5f83a142b2.png"></div><br>  <i><font color="#999999">La quantité de données téléchargées par l'utilisateur</font></i> <br><br>  En conséquence, il s'avère que la quantité de données téléchargées par l'utilisateur sur 10 semaines était de 2,64 Mo.  Autrement dit, par rapport à ce qui était avant la séparation du faisceau, le volume a diminué de 36%.  Pas un si mauvais résultat obtenu en ajoutant quelques lignes au fichier de configuration.  Soit dit en passant, avant de poursuivre la lecture - faites de même dans votre projet.  Et si vous avez besoin de passer de Webpack 3 à 4 - faites-le et ne vous inquiétez pas, car le processus est assez simple et toujours gratuit. <br><br>  Il me semble que l'amélioration considérée ici semble quelque peu abstraite, puisqu'elle s'étale sur 10 semaines.  Cependant, si l'on considère la quantité de données envoyées à un utilisateur fidèle, il s'agit d'une réduction honnête de ce volume de 36%.  C'est un très bon résultat, mais il peut être amélioré. <br><br><h3>  <font color="#3AC1EF">▍ Mettez en surbrillance les packages dans des fichiers séparés</font> </h3><br>  Le fichier <code>vendor.js</code> souffre du même problème que l'original <code>main.js</code>  Il consiste en ce que la modification de tout package inclus dans ce fichier oblige un utilisateur régulier à télécharger à nouveau l'intégralité du fichier. <br><br>  Pourquoi ne créons-nous pas des fichiers séparés pour chaque paquet npm?  Ce n'est pas difficile à faire, alors décomposons notre <code>react</code> , <code>lodash</code> , <code>redux</code> , <code>moment</code> , etc. dans des fichiers séparés.  La configuration Webpack suivante nous aidera avec ceci: <br><br><pre> <code class="hljs markdown">const path = require('path'); const webpack = require('webpack'); module.exports = { entry: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/index.js'), plugins: [   new webpack.HashedModuleIdsPlugin(), //        ], output: {   path: path.resolve(__</span></span>dirname, 'dist'),   filename: '[<span class="hljs-string"><span class="hljs-string">name</span></span>].[<span class="hljs-string"><span class="hljs-string">contenthash</span></span>].js', }, optimization: {   runtimeChunk: 'single',   splitChunks: {     chunks: 'all',     maxInitialRequests: Infinity,     minSize: 0,     cacheGroups: {       vendor: {         test: /[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules[\\/]/,         name(module) {           //  ,   node_</span></span>modules/packageName/not/this/part.js           //  node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules/packageName           const packageName = module.context.match(/[\\/]node_</span></span>modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>](<span class="hljs-link"><span class="hljs-link">.*?</span></span>)([\\/]|$)/)[1];           //  npm- ,   ,           //  URL,        @           return <span class="hljs-code"><span class="hljs-code">`npm.${packageName.replace('@', '')}`</span></span>;         },       },     },   }, }, };</code> </pre> <br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation,</a> vous pouvez trouver une excellente explication des constructions utilisées ici, mais je consacre encore un peu de temps à raconter certaines choses, car il m'a fallu beaucoup de temps pour les utiliser correctement. <br><br><ul><li>  Webpack a des installations standard tout à fait raisonnables, qui, en fait, ne sont pas si raisonnables.  Par exemple, le nombre maximal de fichiers de sortie est défini sur 3, la taille de fichier minimale est de 30 Ko (c'est-à-dire que les fichiers plus petits seront fusionnés).  Je l'ai redéfini. </li><li>  <code>cacheGroups</code> est l'endroit où nous définissons les règles de regroupement des données par Webpack dans les fichiers de sortie.  J'ai un groupe ici, <code>vendor</code> , qui sera utilisé pour tout module chargé à partir de <code>node_modules</code> .  Habituellement, le nom du fichier de sortie est donné sous forme de chaîne.  Mais j'ai donné un <code>name</code> tant que fonction qui sera appelée pour chaque fichier traité.  Ensuite, je prends le nom du package dans le chemin du module.  En conséquence, nous obtenons un fichier pour chaque package.  Par exemple, <code>npm.react-dom.899sadfhj4.js</code> . </li><li>  Les noms de package, afin qu'ils puissent être publiés dans npm, doivent être adaptés à une utilisation dans les <a href="">URL</a> , nous n'avons donc pas besoin d'effectuer l'opération <code>encodeURI</code> sur les noms de <code>packageName</code> .  Cependant, je suis tombé sur un problème que le serveur .NET refuse de travailler avec des fichiers qui ont le symbole <code>@</code> dans leurs noms (ces noms sont utilisés pour les packages avec une portée de nom donnée, les soi-disant packages de portée), donc moi, dans le correspondant fragment de code, je me débarrasse de ces caractères. </li></ul><br>  La configuration ci-dessus de Webpack est bonne en ce sens que vous pouvez la configurer une fois, puis l'oublier.  Il ne nécessite pas de faire référence à des packages spécifiques par leur nom.Par conséquent, après sa création, il reste pertinent, même lors de la modification de la composition des packages. <br><br>  Alice, notre visiteur régulier, <code>main.js</code> toujours <code>main.js</code> 200 kilo-octets chaque semaine, et la première fois qu'elle visite le site, elle doit télécharger 200 Ko de packages npm, mais elle n'a pas à télécharger les mêmes packages deux fois. <br><br>  Vous trouverez ci-dessous une nouvelle version du tableau avec des informations sur le volume de téléchargements de données hebdomadaires.  Par une étrange coïncidence, la taille de chaque fichier avec les packages npm est de 20 Ko. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/787/006/f98787006dc9320ca37b680b23534e71.png"></div><br>  <i><font color="#999999">La quantité de données téléchargées par l'utilisateur</font></i> <br><br>  Maintenant, le volume de données téléchargées en 10 semaines est de 2,24 Mo.  Cela signifie que nous avons amélioré le taux de base de 44%.  Le résultat est déjà très décent, mais la question se pose de savoir s'il est possible de le faire pour obtenir un résultat supérieur à 50%.  Si cela se produit, ce sera tout simplement génial. <br><br><h3>  <font color="#3AC1EF">▍ Division du code d'application en fragments</font> </h3><br>  Nous revenons au fichier <code>main.js</code> , que la malheureuse Alice doit constamment télécharger. <br><br>  Comme je l'ai dit ci-dessus, il y a deux sections distinctes sur notre site Web.  Le premier est une liste de produits, le second est une page avec des informations détaillées sur le produit.  La taille du code, unique pour chacun d'eux, est de 25 Ko (et 150 Ko de code sont utilisés à la fois là et là). <br><br>  La page d'information sur le produit n'est pas sujette à changement, comme nous l'avons déjà perfectionnée.  Par conséquent, si nous extrayons son code dans un fichier séparé, ce fichier, la plupart du temps utilisé avec le site, sera téléchargé dans le navigateur depuis le cache. <br><br>  De plus, il s'est avéré que nous avons un énorme fichier SVG intégré utilisé pour le rendu des icônes, qui pèse jusqu'à 25 Ko et change rarement. <br><br>  Il faut faire quelque chose avec ça. <br><br>  Nous avons créé manuellement plusieurs points d'entrée, indiquant à Webpack qu'il devait créer un fichier distinct pour chacune de ces entités. <br><br><pre> <code class="hljs markdown">module.exports = { entry: {   main: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/index.js'),   ProductList: path.resolve(__</span></span>dirname, 'src/ProductList/ProductList.js'),   ProductPage: path.resolve(<span class="hljs-strong"><span class="hljs-strong">__dirname, 'src/ProductPage/ProductPage.js'),   Icon: path.resolve(__</span></span>dirname, 'src/Icon/Icon.js'), }, output: {   path: path.resolve(<span class="hljs-emphasis"><span class="hljs-emphasis">__dirname, 'dist'),   filename: '[name].[contenthash:8].js', }, plugins: [   new webpack.HashedModuleIdsPlugin(), //        ], optimization: {   runtimeChunk: 'single',   splitChunks: {     chunks: 'all',     maxInitialRequests: Infinity,     minSize: 0,     cacheGroups: {       vendor: {         test: /[\\/]node_</span></span>modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]/,         name(module) {           //  ,   node<span class="hljs-emphasis"><span class="hljs-emphasis">_modules/packageName/not/this/part.js           //  node_</span></span>modules/packageName           const packageName = module.context.match(/[<span class="hljs-string"><span class="hljs-string">\\/</span></span>]node_modules[<span class="hljs-string"><span class="hljs-string">\\/</span></span>](<span class="hljs-link"><span class="hljs-link">.*?</span></span>)([\\/]|$)/)[1];           //  npm- ,   ,           //  URL,        @           return <span class="hljs-code"><span class="hljs-code">`npm.${packageName.replace('@', '')}`</span></span>;         },       },     },   }, }, };</code> </pre> <br>  Le Webpack, qui travaille dur, créera en outre des fichiers pour ce qui est courant, par exemple, <code>ProductList</code> et <code>ProductPage</code> , c'est-à-dire qu'il n'y aura pas de code en double. <br><br>  Ce que nous venons de faire permettra à Alice d'économiser 50 Ko de trafic presque chaque semaine.  Veuillez noter que nous avons modifié le fichier de description des icônes au cours de la sixième semaine.  Voici notre table traditionnelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62f/b9e/8ed/62fb9e8ed563fd4aa7a61fdcec61fc2d.png"></div><br>  <i><font color="#999999">La quantité de données téléchargées par l'utilisateur</font></i> <br><br>  Maintenant, en seulement dix semaines, seulement 1,815 Mo de données ont été téléchargées.  Cela signifie que les économies de trafic ont été impressionnantes de 56%.  Conformément à notre scénario théorique, un utilisateur régulier travaillera toujours avec ce niveau d'économies. <br><br>  Tout cela est dû aux modifications apportées à la configuration de Webpack.  Nous n'avons pas modifié le code d'application pour obtenir de tels résultats. <br><br>  Plus tôt, j'ai parlé du fait que le scénario spécifique dans lequel un tel test est effectué, en fait, ne joue pas un rôle spécial.  Cela est dû au fait que, quel que soit le scénario utilisé, la conclusion de tout ce dont nous avons parlé sera la même: la division de l'application en petits fichiers qui ont du sens lorsqu'elle est appliquée à son architecture nous permet de réduire le volume des données du site, chargé par ses utilisateurs réguliers. <br><br>  Nous allons bientôt commencer à parler de séparation de code, mais je voudrais d'abord répondre à trois questions auxquelles vous pensez probablement maintenant. <br><br><h3>  <font color="#3AC1EF">▍ Question numéro 1.</font>  <font color="#3AC1EF">La nécessité d'effectuer de nombreuses requêtes ne nuit-elle pas à la vitesse de chargement du site?</font> </h3><br>  Vous pouvez donner une réponse courte et simple à cette question: "Non, cela ne fait pas de mal."  Une situation similaire a entraîné un problème dans le passé, lorsque le protocole HTTP / 1.1 était utilisé, et lors de l'utilisation de HTTP / 2, ce n'est plus pertinent. <br><br>  Cependant, il convient de noter que dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://medium.com/%40asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-">cet</a> article, publié en 2016, et dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=http://engineering.khanacademy.org/posts/js-packaging-">cet</a> article de la Khan Academy 2015, les conclusions sont tirées que même en utilisant HTTP / 2, l'utilisation d'un trop grand nombre de fichiers ralentit le téléchargement.  Mais dans ces deux matériaux, «trop» signifie «plusieurs centaines».  Par conséquent, il convient de se rappeler que si vous devez travailler avec des centaines de fichiers, les restrictions sur le traitement parallèle des données peuvent affecter leur vitesse de téléchargement. <br><br>  Si vous êtes intéressé, la prise en charge HTTP / 2 est disponible dans IE 11 sur Windows 10. De plus, j'ai fait une étude complète parmi ceux qui utilisent des systèmes plus anciens.  Ils ont déclaré à l'unanimité que la vitesse de chargement de leur site Web n'était pas particulièrement préoccupante. <br><br><h3>  <font color="#3AC1EF">▍ Question numéro 2.</font>  <font color="#3AC1EF">Les bundles Webpack ont ​​un code d'assistance.</font>  <font color="#3AC1EF">Cela crée-t-il une charge supplémentaire sur le système?</font> </h3><br>  Oui. <br><br><h3>  <font color="#3AC1EF">▍ Question numéro 3.</font>  <font color="#3AC1EF">Lorsque vous travaillez avec de nombreux petits fichiers, leur niveau de compression se détériore, non?</font> </h3><br>  Oui, c'est également vrai.  En fait, je voudrais dire ceci: <br><br><ul><li>  Plus de fichiers signifie plus de code d'assistance Webpack. </li><li>  Plus de fichiers signifie moins de compression. </li></ul><br>  Voyons cela pour comprendre à quel point c'est mauvais. <br><br>  Je viens d'effectuer un test dans lequel le code d'un fichier de 190 Ko a été divisé en 19 parties.  Cela a ajouté environ 2% à la quantité de données envoyées au navigateur. <br><br>  En conséquence, il s'avère que lors de la première visite sur le site, l'utilisateur téléchargera 2% de données en plus, et lors des visites suivantes - 60% de moins, et cela continuera pendant très, très longtemps. <br>  Cela vaut-il la peine de s'inquiéter?  Non, ça n'en vaut pas la peine. <br><br>  Lorsque j'ai comparé un système utilisant 1 fichier et un système avec 19 fichiers, je l'ai testé en utilisant différents protocoles, dont HTTP / 1.1.  Le tableau ci-dessous soutient fortement l'idée qu'avoir plus de fichiers signifie mieux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/2fa/47c/a852fa47c36befc2234794c9cae1b9c1.png"></div><br>  <i><font color="#999999">Données sur l'utilisation de 2 versions d'un site hébergé sur un hébergement statique Firebase, dont le code mesure 190 Ko, mais, dans le premier cas, il est regroupé dans 1 fichier et dans le second, il est divisé en 19</font></i> <br><br>  Lorsque vous travaillez dans des réseaux 3G et 4G, le téléchargement d'un site avec 19 fichiers a pris 30% moins de temps que le téléchargement d'un site avec un fichier. <br><br>  Il y a beaucoup de bruit dans les données présentées dans le tableau.  Par exemple, une session de téléchargement d'un site par 4G (Exécution 2 dans le tableau) a pris 646 ms, une autre (Exécution 4) - 1116 ms, ce qui est 73% plus long.  Par conséquent, il y a un sentiment que dire que HTTP / 2 est "30% plus rapide" est quelque peu malhonnête. <br><br>  J'ai créé ce tableau afin de voir ce que donne l'utilisation de HTTP / 2.  Mais, en fait, la seule chose que l'on puisse dire ici, c'est que l'utilisation de HTTP / 2 n'affecte probablement pas particulièrement le chargement des pages. <br><br>  Les deux dernières lignes de ce tableau ont été une véritable surprise.  Voici les résultats pour pas la dernière version de Windows avec IE11 et HTTP / 1.1.  Si j'essayais de prédire les résultats du test à l'avance, je dirais certainement qu'une telle configuration chargerait les matériaux beaucoup plus lentement que les autres.  Certes, une connexion réseau très rapide a été utilisée ici, et moi, pour de tels tests, je devrais probablement utiliser quelque chose de plus lent. <br><br>  Et maintenant je vais vous raconter une histoire.  Pour explorer mon site sur un système très ancien, j'ai téléchargé la machine virtuelle Windows 7 depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de</a> Microsoft.  IE8 y était installé, que j'ai décidé de mettre à niveau vers IE9.  Pour ce faire, je suis allé sur la page Microsoft conçue pour télécharger IE 9. Mais je n'ai pas pu le faire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/ee6/529/a3bee65295b45bf2467da37252674cf0.png"></div><br>  <i><font color="#999999">Cette malchance ...</font></i> <br><br>  Soit dit en passant, si nous parlons de HTTP / 2, je tiens à noter que ce protocole est intégré dans Node.js.  Si vous voulez expérimenter, vous pouvez utiliser le petit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">serveur HTTP / 2 que</a> j'ai écrit avec le support du cache de réponse, gzip et brotli. <br><br>  Peut-être, j'ai dit tout ce que je voulais sur la méthode de séparation des faisceaux.  Je pense que le seul inconvénient de cette approche, lors de l'utilisation de laquelle les utilisateurs doivent télécharger un grand nombre de fichiers, en fait, n'est pas un tel «inconvénient». <br><br>  Parlons maintenant de la séparation du code. <br><br><h2>  <font color="#3AC1EF">Séparation de code</font> </h2><br>  L'idée principale de la technique de fractionnement de code est: "Ne téléchargez pas de code inutile."  On m'a dit que l'utilisation de cette approche n'a de sens que pour certains sites. <br><br>  Je préfère, en ce qui concerne la séparation de code, utiliser la règle 20/20 que je viens de formuler.  S'il y a une partie du site qui n'est visitée que par 20% des utilisateurs, et que sa fonctionnalité est fournie par plus de 20% du code JavaScript du site, alors ce code doit être téléchargé uniquement sur demande. <br><br>  Bien entendu, ces chiffres ne sont pas absolus, ils peuvent être ajustés à une situation spécifique et, en réalité, il existe des scénarios beaucoup plus complexes que celui décrit ci-dessus.  La chose la plus importante ici est l'équilibre, et il est tout à fait normal de ne pas utiliser du tout la séparation de code, si cela n'a aucun sens pour votre site. <br><br><h3>  <font color="#3AC1EF">▍ Séparé ou non?</font> </h3><br>  Comment trouver la réponse à la question de savoir si vous avez besoin d'une séparation de code ou non?  Supposons que vous ayez une boutique en ligne et que vous envisagiez de séparer du reste du code le code utilisé pour recevoir le paiement des clients, car seulement 30% des visiteurs achètent quelque chose chez vous. <br><br>  Que puis-je dire?  Tout d'abord, vous devez travailler à remplir le magasin et à vendre quelque chose qui serait intéressant pour plus de visiteurs du site.  Deuxièmement, vous devez comprendre combien de code est complètement unique pour la section du site où le paiement est accepté.  Étant donné que vous devriez toujours faire un «fractionnement de bundle» avant le «fractionnement de code», et vous l'espérez, vous savez probablement déjà de quelles tailles le code nous intéresse. <br><br>  Peut-être que ce code peut s'avérer plus petit que vous ne le pensez, donc avant de vous réjouir de la nouvelle opportunité d'optimiser votre site, vous devez tout calculer en toute sécurité.  Si vous, par exemple, avez un site React, alors le référentiel, les réducteurs, le système de routage, les actions seront partagés par toutes les parties du site.  Unique pour différentes parties du code du site sera principalement représenté par des composants et des fonctions auxiliaires pour eux. <br><br>  Ainsi, vous avez découvert qu'un code complètement unique de la section du site utilisée pour payer les achats prend 7 Ko.  La taille du reste du code du site est de 300 Ko.  Dans une telle situation, je ne m'engagerais pas dans la séparation de code pour plusieurs raisons: <br><br><ul><li>  Si vous téléchargez ces 7 Ko à l'avance, le site ne ralentira pas.  N'oubliez pas que les fichiers sont téléchargés en parallèle et essayez de mesurer la différence nécessaire pour télécharger 300 Ko et 307 Ko de code. </li><li>  Si vous téléchargez ce code plus tard, l'utilisateur devra attendre après avoir cliqué sur le bouton "Payer".  Et c'est le moment même où vous avez besoin de tout pour que tout se passe le mieux possible. </li><li>  La séparation du code nécessite des modifications de l'application.  Dans le code, là où tout a été fait de manière synchrone auparavant, la logique asynchrone apparaît. ,        ,       , ,   ,           . </li></ul><br>  , ,        ,  . <br><br>        . <br><br><h3> <font color="#3AC1EF">▍</font> </h3><br>      ,   ,    ,       . <br><br>           .     ,     .      : <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'whatwg-fetch'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'intl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'url-polyfill'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/web/dom-collections'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/map'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/string'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/array'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6/object'</span></span>);</code> </pre> <br>         <code>index.js</code> ,      : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./polyfills'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App/App'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> render = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('root')); } render(); // ,     </span></span></code> </pre> <br>    Webpack   ,        ,        npm-.     25 , 90%    ,      . <br><br>   Webpack 4    <code>import()</code> (      <code>import</code> ),      : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App/App'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./index.css'</span></span>; const render = () =&gt; { ReactDOM.render(&lt;App /&gt;, document.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-string"><span class="hljs-string">'fetch'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'Intl'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'URL'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'Map'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">window</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'forEach'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> NodeList.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'startsWith'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'endsWith'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'includes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> String.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'includes'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype &amp;&amp; <span class="hljs-string"><span class="hljs-string">'assign'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'entries'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> &amp;&amp; <span class="hljs-string"><span class="hljs-string">'keys'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> ) { render(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./polyfills'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(render); }</code> </pre> <br>  ,  ,   ,  —     .   —        <code>render()</code> .      ,  Webpack     npm-,       ,    <code>render()</code>   . <br><br>  ,   <code>import()</code>    Babel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dynamic-import</a> .  ,      Webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">import()</a>  ,           . <br><br>    ,   .    . <br><br><h3> <font color="#3AC1EF">▍    React,   </font> </h3><br>     . ,          ,      ,    . <br><br>       ,     npm-    .        ,   ,      100 . <br><br>       , ,    URL <code>/admin</code> ,  <code>&lt;AdminPage&gt;</code> . Webpack    ,      <code>import AdminPage from './AdminPage.js'</code>       . <br><br>     .           ,   ,  <code>import('./AdminPage.js')</code> ,   Webpack    ,      . <br><br> ,      . <br><br> ,  ,    <code>AdminPage</code> ,     ,        URL <code>/admin</code> . ,    : <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">React</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'reac</span></span>t'; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdminPageLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ constructor(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {     <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,   } } componentDidMount() {   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>('./<span class="hljs-type"><span class="hljs-type">AdminPage</span></span>').then(module =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>: module.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> });   }); } render() {   const { <span class="hljs-type"><span class="hljs-type">AdminPage</span></span> } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">AdminPage</span></span>     ? &lt;<span class="hljs-type"><span class="hljs-type">AdminPage</span></span> {...<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props} /&gt;     : &lt;div&gt;<span class="hljs-type"><span class="hljs-type">Loading</span></span>...&lt;/div&gt;; } } export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-type"><span class="hljs-type">AdminPageLoader</span></span>;</code> </pre> <br>        .     (,     URL <code>/admin</code> ),    <code>./AdminPage.js</code> ,          . <br><br>   <code>render()</code>   ,   <code>&lt;AdminPage&gt;</code> ,  <code>&lt;div&gt;Loading...&lt;/div&gt;</code> ,   <code>&lt;AdminPage&gt;</code>  ,         . <br><br>        ,       <code>react-loadable</code> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> React   . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br> ,   ,   (,  ,      CSS).   : <br><br><ul><li>          —      . </li><li>       ,      —    . </li></ul><br>  <b>Chers lecteurs!</b>           ? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423483/">https://habr.com/ru/post/fr423483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423469/index.html">Numéros à virgule flottante Far West les plus rapides</a></li>
<li><a href="../fr423475/index.html">Pirater le code du vieillissement: une nouvelle science sur le vieillissement et ce que signifie rester jeune</a></li>
<li><a href="../fr423477/index.html">Soyez un ninja de la sécurité: commencez votre chemin vers les hauteurs de l'IB</a></li>
<li><a href="../fr423479/index.html">"First": s'il faut voler vers Mars</a></li>
<li><a href="../fr423481/index.html">Je dois augmenter le cluster Kubernetes, mais je ne suis qu'un programmeur de code. Il y a un moyen de sortir</a></li>
<li><a href="../fr423485/index.html">Chargement d'images paresseuses à l'aide d'IntersectionObserver</a></li>
<li><a href="../fr423487/index.html">Node.js sans node_modules</a></li>
<li><a href="../fr423489/index.html">Je suis médecin urgentiste et je veux parler du nouvel électrocardiogramme Apple Watch</a></li>
<li><a href="../fr423491/index.html">PHP Digest n ° 139 (du 3 au 17 septembre 2018)</a></li>
<li><a href="../fr423493/index.html">Android Go est le futur milliard d'appareils et une limite de 50 Mo. Conférence Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>