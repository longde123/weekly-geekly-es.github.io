<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíπ üë®üèª‚Äçüç≥ üòä Proyecto WideNES: vaya m√°s all√° de los l√≠mites de la pantalla NES üé™ üìò ü§ú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A mediados de la d√©cada de 1980, el Nintendo Entertainment System (NES) era una consola imprescindible. El mejor sonido, los mejores gr√°ficos y los me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proyecto WideNES: vaya m√°s all√° de los l√≠mites de la pantalla NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421555/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif" alt="imagen"></div><br>  A mediados de la d√©cada de 1980, el Nintendo Entertainment System (NES) era una consola imprescindible.  El mejor sonido, los mejores gr√°ficos y los mejores juegos entre todas las consolas de la √©poca: la consola ampli√≥ los l√≠mites de lo posible.  Hasta ahora, proyectos como <em>Super Mario Bros.</em>  , <em>The Legend of Zelda</em> y <em>Metroid</em> son considerados algunos de los mejores juegos de todos los tiempos. <br><br>  M√°s de 30 a√±os despu√©s del lanzamiento de NES, los juegos cl√°sicos se sienten geniales, lo que no se puede decir sobre el hardware en el que trabajaron.  Con una resoluci√≥n de solo 256x240, la consola NES no pod√≠a proporcionar juegos con suficiente espacio.  Sin embargo, los intr√©pidos desarrolladores lograron encajar en los juegos de NES mundos incre√≠bles e inolvidables: las mazmorras tipo laberinto de <em>The Legend of Zelda</em> , vastos espacios del planeta en <em>Metroid</em> , niveles brillantes de <em>Super Mario Bros.</em>  .  Sin embargo, debido a las limitaciones de hardware de NES, los jugadores nunca podr√≠an ir m√°s all√° de 256x240 ... <br><br>  Hasta hace poco <br><br>  Te presento el proyecto <strong>wideNES</strong> : ¬°una nueva forma de jugar a los cl√°sicos de NES! <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/157/9b0/9211579b0ba7322cf563254fcd26c9cc.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/433/ea0/dcd433ea06a9dec672c3457d76ee2181.gif"></div><br>  <strong>wideNES</strong> es una nueva tecnolog√≠a para marcar juegos NES de forma <em>autom√°tica</em> e <em>interactiva</em> <em>en tiempo real</em> . <br><br>  Cuando los jugadores se mueven por el nivel, wideNES graba la pantalla, construyendo gradualmente un mapa de la parte explorada del mundo.  En los niveles posteriores, wideNES sincroniza la jugabilidad en la pantalla con el mapa generado, ¬°esencialmente permitiendo a los jugadores ver m√°s al "mirar" m√°s all√° de los l√≠mites de la pantalla NES!  Lo mejor de todo es que la forma en que marca los juegos wideNES es <em>completamente universal</em> , lo que permite que una amplia gama de juegos NES trabajen con wideNES sin ninguna configuraci√≥n. <br><br>  ¬øPero c√≥mo funciona todo? <br><br><hr><br>  Si desea comprobar c√≥mo funciona wideNES antes de leer el art√≠culo, ¬°por favor!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ANESE</a> es el emulador NES que escrib√≠, y actualmente es el √∫nico emulador que implementa wideNES.  Sin embargo, vale la pena advertir que ANESE <em>no</em> es <em>el</em> mejor emulador NES del mundo, tanto en t√©rminos de IU como de precisi√≥n de emulaci√≥n.  La mayor√≠a de las funciones (incluida la inclusi√≥n de wideNES) solo est√°n disponibles a trav√©s de la l√≠nea de comandos, y aunque muchos juegos populares funcionan bien, algunos otros pueden comportarse de manera inesperada. <br><br><hr><br><h2>  C√≥mo funciona wideNES </h2><br>  Antes de profundizar en los detalles, es importante explicar brevemente c√≥mo NES representa los gr√°ficos. <br><br><h3>  Transferencia de p√≠xeles usando PPU </h3><br>  El coraz√≥n de NES es el venerable procesador MOS 6502. A finales de los a√±os 70 y principios de los 80, 6502 se usaba en <em>todas partes</em> y funcionaba en m√°quinas legendarias como Commodore 64, Apple II y muchas otras.  Era barato, f√°cil de programar y lo <em>suficientemente</em> potente <em>como</em> para ser peligroso. <br><br>  Complementando 6502 en la consola NES hab√≠a un poderoso coprocesador de gr√°ficos llamado <em>Picture Processing Unit</em> (PPU).  En comparaci√≥n con los simples coprocesadores de video utilizados en sistemas m√°s antiguos, PPU es una gran mejora en t√©rminos de usabilidad.  Por ejemplo, cinco a√±os antes del lanzamiento de NES, el procesador Atari 2600 6502 se us√≥ para transmitir instrucciones gr√°ficas al coprocesador <em>para cada l√≠nea de trama</em> , lo que dej√≥ al procesador muy poco tiempo para ejecutar la l√≥gica del juego.  A modo de comparaci√≥n: PPU solo necesitaba un par de comandos <em>por cuadro</em> , y esto le dio a 6502 tiempo suficiente para crear un juego interesante e innovador. <br><br>  PPU es un chip incre√≠ble, su forma de renderizar gr√°ficos no se parece en nada al trabajo de las GPU modernas, y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se requerir√°</a> una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serie</a> completa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de art√≠culos</a> para explicar completamente sus funciones.  Como wideNES usa solo un peque√±o subconjunto de las funciones de PPU, es suficiente considerarlas brevemente: <br><br><ul><li>  Resoluci√≥n: 256x240 p√≠xeles, 60 Hz </li><li>  Funciona independientemente de la CPU. <br><ul><li>  Se comunica con la CPU mediante <em>E / S con asignaci√≥n de memoria</em> (rango de direcciones 0x2000 - 0x2007) </li></ul></li><li>  2 capas de representaci√≥n: capa de <strong>sprite</strong> y capa de <strong>fondo</strong> <ul><li>  <strong>Capa de sprite</strong> <br><ul><li>  Cada sprite individual se puede colocar en cualquier lugar de la pantalla. </li><li>  Ideal para mover objetos: jugador, enemigos, proyectiles. </li><li>  Hasta 64 sprites de 8x8 p√≠xeles </li></ul></li><li>  <strong>Capa de fondo</strong> <br><ul><li>  Atado a una cuadr√≠cula </li><li>  Ideal para elementos est√°ticos: plataformas, grandes obst√°culos, decoraciones. </li><li>  La memoria de video es suficiente para almacenar mosaicos de 64x30 de tama√±o 8x8 p√≠xeles <br><ul><li>  Resoluci√≥n <em>interna</em> verdadera de 512x240, con una vista de 256x240 </li><li>  Admite <strong><em>desplazamiento de hardware</em></strong> para cambiar la vista de 256x240 <br><ul><li>  El registro PPUSCROLL (direcci√≥n 0x2005) controla el desplazamiento de la ventana gr√°fica en X / Y </li></ul></li></ul></li></ul></li></ul></li></ul><br>  Despu√©s de haber tratado esta breve descripci√≥n, pasemos a lo m√°s interesante: ¬øc√≥mo funciona wideNES? <br><br><h3>  Idea principal </h3><br>  Al final de cada trama, la CPU env√≠a la informaci√≥n de cambio a la PPU.  Estos incluyen nuevas posiciones de sprites, nuevos datos de nivel y, lo cual es cr√≠tico para wideNES, <em>nuevas compensaciones de viewport</em> .  Como wideNES funciona en el emulador, es muy f√°cil para nosotros hacer un seguimiento de los valores escritos en el registro PPUSCROLL, lo que significa que es incre√≠blemente f√°cil calcular cu√°nto se ha movido la pantalla entre dos cuadros. <br><br>  Hmm, ¬øqu√© suceder√° si, en lugar de dibujar cada nuevo cuadro <em>directamente sobre el</em> cuadro anterior, los cuadros nuevos se dibujar√°n <em>superpuestos</em> en el cuadro anterior, pero se desplazar√°n al valor de desplazamiento actual?  Luego, con el tiempo, una parte cada vez m√°s grande del nivel permanecer√° en la pantalla, ¬°creando gradualmente una imagen completa del nivel! <br><br>  Para verificar si esta idea era de alg√∫n valor, esboc√© r√°pidamente la primera implementaci√≥n. <br><br>  Compilando ... <br>  Lanzando ... <br>  Descargar <em>Super Mario Bros.</em>  ... <br><br>  Voila! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/7cb/c7f/1ed7cbc7ff1998d1f5f19af6ca09bb54.gif"></div><br>  Funcion√≥! <br><br>  Parece ser ... <br><br><hr><br><h3>  Otro enfoque: ¬øpor qu√© no extraer niveles directamente de los archivos ROM? </h3><br>  Sin siquiera considerar los detalles de implementaci√≥n, resulta obvio que esta t√©cnica tiene una seria limitaci√≥n: un mapa completo del juego solo se puede recolectar cuando el jugador explora de forma independiente todo el juego. <br><br>  ¬øQu√© pasar√≠a si hubiera alguna forma de extraer niveles de <em>las</em> ROM de NES sin <em>procesar</em> ? <br><br>  ¬øPuede existir tal t√©cnica? <br><br>  Bueno, muy probablemente no. <br><br>  Si tomas dos juegos para NES, puedes garantizar que solo tienen una cosa en com√∫n: ambos funcionan para NES.  ¬°Todo lo dem√°s puede ser completamente diferente!  ¬°Tal desajuste es un verdadero desastre, porque los juegos de NES esencialmente tienen un n√∫mero infinito de opciones para almacenar datos de nivel! <br><br>  Algunas personas han extra√≠do niveles completos mediante ingenier√≠a inversa de la forma en que almacenan los datos de nivel de un <em>par de</em> juegos (¬°a veces con la creaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">editores de mapas</a> con todas las funciones!), Pero esta es una tarea dif√≠cil, que requiere mucho trabajo, perseverancia e inteligencia. <br><br>  Para extraer datos de nivel de ROM, es necesario determinar qu√© partes de ROM son c√≥digo (no datos), y esto es dif√≠cil de hacer, ¬°porque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar todo el c√≥digo en un archivo binario es equivalente a un problema de detenci√≥n</a> ! <br><br>  WideNES utiliza un enfoque mucho m√°s simple: en lugar de adivinar c√≥mo el juego empac√≥ los datos de nivel en ROM, wideNES simplemente inicia el juego y realiza un seguimiento de la salida. <br><br><hr><br><h3>  Desplazarse m√°s all√° de 255 </h3><br>  NES es un sistema de 8 bits, es decir, el registro PPUSCROLL solo puede recibir valores de 8 bits.  Esto limita el desplazamiento m√°ximo de desplazamiento a 255 p√≠xeles, es decir, el n√∫mero m√°ximo de 8 bits.  No es casualidad que la resoluci√≥n de pantalla NES sea de 240x256 p√≠xeles, es decir, un desplazamiento de 255 p√≠xeles <em>es suficiente</em> para desplazar toda la pantalla. <br><br>  Pero, ¬øqu√© sucede al desplazarse <em>m√°s all√° de</em> 255? <br><br>  En primer lugar, los juegos restablecen el registro PPUSCROLL a 0. Esto explica por qu√© <em>SMB se</em> lleva al principio cuando Mario se mueve demasiado a la derecha. <br><br>  Luego, para compensar las restricciones PPUSCROLL de 8 bits, los juegos actualizan otro registro PPU: PPUCTRL (direcci√≥n 0x2000).  Los 2 bits inferiores de PPUCTRL establecen el "punto de partida" de la escena actual en incrementos de pantalla completa.  Por ejemplo, escribir un valor de 1 desplaza la vista hacia la derecha 256 p√≠xeles; un valor de 2 desplaza la vista hacia abajo 240 p√≠xeles.  El desplazamiento PPUCTRL se inserta en la <em>pila</em> con el registro PPUSCROLL, que le permite desplazar la pantalla horizontalmente dentro de 512 p√≠xeles o verticalmente dentro de 480 p√≠xeles. <br><br>  Pero construir, ¬øhay suficiente memoria de video para pantallas de dos niveles?  ¬øQu√© sucede cuando la ventana gr√°fica se desplaza demasiado a la derecha y "va m√°s all√°" de la VRAM?  Para manejar este caso, PPU implementa la convoluci√≥n: todas las partes de la ventana de visualizaci√≥n fuera de la memoria de video seleccionada simplemente se colapsan en el borde opuesto de la memoria de video. <br><br>  ¬°Este plegado, combinado con la manipulaci√≥n inteligente de registros PPUSCROLL y PPUCTRL, permite a los juegos de NES crear la ilusi√≥n de mundos infinitamente altos / anchos!  Gracias a la carga perezosa de parte del nivel fuera de la ventana de visualizaci√≥n y al desplazamiento gradual hacia ella, ¬°los jugadores nunca se dan cuenta de que dentro de VRAM realmente "corren en c√≠rculos"! <br><br>  Una excelente ilustraci√≥n de la wiki de nesdev muestra c√≥mo <em>Super Mario Bros.</em>  usa estas propiedades para crear niveles m√°s largos que dos pantallas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif"></div><br>  Volvamos a la pregunta que estamos discutiendo: ¬øc√≥mo maneja wideNES el desplazamiento m√°s all√° de 256? <br><br>  Bueno, francamente, wideNES <em>ignora por completo el</em> registro PPUCTRL y solo realiza un seguimiento de la diferencia PPUSCROLL entre cuadros. <br><br>  Si PPUSCROLL salta inesperadamente a aproximadamente 256, lo que generalmente significa que el personaje del jugador se movi√≥ hacia la izquierda / arriba en la pantalla, y si inesperadamente salta a alrededor de 0, entonces esto generalmente significa que el jugador se movi√≥ hacia la derecha / abajo en la pantalla. <br><br>  Aunque esta heur√≠stica puede parecer simple, y lo es, de hecho, ¬°funciona muy bien! <br><br>  Despu√©s de implementar esta heur√≠stica, <em>Super Mario Bros.</em>  , <em>Metroid</em> y muchos otros juegos han funcionado casi a la perfecci√≥n. <br><br>  Estaba emocionado, as√≠ que segu√≠ adelante y sub√≠ otro cl√°sico de NES: <em>Super Mario Bros.</em>  <em>3</em> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a21/1ee/233/a211ee233bcdea56af5b983f9b8715cf.gif"></div><br>  Hmm ... No muy bonita. <br><br><h3>  Ignorando elementos de pantalla est√°ticos </h3><br>  Muchos juegos tienen elementos UI est√°ticos alrededor de los bordes de la pantalla.  En el caso de <em>SMB3,</em> esta es la columna de la izquierda y la barra de estado se encuentra en la parte inferior del estado. <br><br>  Por defecto, las muestras wideNES con incrementos de 16 p√≠xeles desde los bordes de la pantalla, es decir, se muestrean todos los elementos est√°ticos en los bordes.  No esta bien! <br><br>  Para solucionar este problema, wideNES implementa reglas y heur√≠sticas que intentan reconocer y enmascarar autom√°ticamente los elementos est√°ticos de la pantalla. <br><br>  En general, los juegos de NES usan tres tipos diferentes de elementos de pantalla est√°tica: HUD, m√°scaras y barras de estado. <br><br><h4>  HUD: no hay problema </h4><br>  Si un juego impone un HUD en la parte superior de un nivel, entonces es probable que el HUD consista en varios sprites.  Ejemplo: HUD en <em>Metroid</em> . <br><br>  Afortunadamente, tales HUD no causan problemas, porque wideNES actualmente simplemente ignora la capa de sprites.  Genial <br><br><h4>  M√°scaras: nada m√°s f√°cil </h4><br>  PPU tiene una funci√≥n que permite a los juegos enmascarar los 8 p√≠xeles m√°s a la izquierda de la capa de fondo.  Se activa configurando el segundo bit del registro (direcci√≥n 0x2001).  Muchos juegos usan esta funci√≥n, pero explicar <em>por qu√©</em> lo hacen est√° m√°s all√° del alcance de este art√≠culo. <br><br>  Reconocer la m√°scara incluida es incre√≠blemente simple: wideNES solo realiza un seguimiento del valor de PPUMASK e ignora los 8 p√≠xeles m√°s a la izquierda cuando se establece el segundo bit en el registro. <br><br>  Parece que la implementaci√≥n de esta simple regla <em>solucion√≥ el</em> problema con <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/6ce/6ce/8e56ce6ce6e3f59203422816794e21de.gif"></div><br>  ... bueno, o <em>casi</em> eliminado. <br><br><h4>  Las barras de estado son las m√°s dif√≠ciles. </h4><br>  Debido a las limitaciones de PPU en cualquier momento en la pantalla, no puede haber m√°s de 64 sprites;  Adem√°s, en cualquier momento en <em>cada l√≠nea de trama no</em> puede haber m√°s de 8 sprites.  Esta restricci√≥n evita que los desarrolladores creen HUD complejos a partir de sprites y los obliga a usar partes de la capa de fondo para mostrar informaci√≥n. <br><br>  Adem√°s de las m√°scaras, no hay una manera f√°cil en PPU para separar la capa de fondo en el √°rea de juego y el √°rea de estado.  Por lo tanto, los desarrolladores recurrieron a trucos, lo que condujo a un mont√≥n de formas <em>poco ortodoxas</em> de crear paneles de estado ... <br><br>  WideNES utiliza varias heur√≠sticas para reconocer diferentes tipos de paneles de estado, pero para ahorrar tiempo, considerar√© solo uno de los m√°s interesantes: el seguimiento de IR en el medio del cuadro (seguimiento de IRQ de cuadro medio). <br><br><h3>  Seguimiento de IRQ de cuadro medio </h3><br>  A diferencia de las GPU modernas con grandes b√∫feres de trama interna, las PPU <em>generalmente no tienen un b√∫fer de trama.</em>  Para ahorrar espacio, PPU almacena escenas como una cuadr√≠cula de mosaicos de 64x32 de 8x8 p√≠xeles.  En lugar de calcular previamente los datos de p√≠xeles, los mosaicos se almacenan como <em>punteros</em> a la memoria CHR (memoria de caracteres), que contiene todos los datos de p√≠xeles. <br><br>  Desde que NES se desarroll√≥ en los a√±os 80, PPU se cre√≥ sin tener en cuenta las tecnolog√≠as de visualizaci√≥n modernas.  En lugar de representar el cuadro completo al mismo tiempo, la PPU emite la se√±al de video NTSC, que debe mostrarse en una pantalla CRT que muestra video <em>p√≠xel por p√≠xel</em> , <em>l√≠nea por l√≠nea</em> , de arriba a abajo, de arriba a abajo, de izquierda a derecha. <br><br>  ¬øPor qu√© es todo esto importante? <br><br>  ¬°Dado que PPU procesa los cuadros de arriba a abajo, l√≠nea por l√≠nea, puede enviar instrucciones de PPU a <em>mitad de cuadro</em> para crear efectos de video que son imposibles con cualquier otro enfoque!  Estos efectos pueden ser simples (por ejemplo, cambiar la paleta) o bastante complejos (por ejemplo, ¬°lo has adivinado, creando barras de estado!). <br><br>  Para explicar c√≥mo una escritura PPU de mitad de cuadro puede crear barras de estado, grab√© un volcado de porci√≥n de video de memoria PPU y CHR sin procesar para un solo cuadro <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/565/049/cf6565049202c1a832222de6edb291c3.png"></div><br>  Todo se ve bien, nada especial ... ¬°pero solo mira la barra de estado!  Ella est√° completamente distorsionada! <br><br>  Ahora mire el mismo volcado en bruto, pero hecho despu√©s de la l√≠nea 196 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/8e4/be6/5df8e4be6a32dcefa00429da5fbb4755.png"></div><br>  S√≠, el nivel se ve horrible, ¬°pero la barra de estado se ve genial! <br><br>  ¬øQu√© est√° pasando aqu√≠? <br><br>  <em>SMB3</em> establece un temporizador para activar IRQ (interrupci√≥n) exactamente despu√©s de representar la l√≠nea de trama 195. Pasa las siguientes instrucciones al controlador IRQ: <br><br><ul><li>  Establezca PPUSCROLL en (0,0) (para que la barra de estado permanezca en su lugar) </li><li>  Reemplazamos la tarjeta de mosaico en la memoria CHR (ponemos en orden los gr√°ficos de la barra de estado) </li></ul><br>  Como el resto de la capa ya est√° renderizada, la PPU no "actualizar√°" el marco.  En cambio, continuar√° renderizando con estas opciones, ¬°mostrando una hermosa barra de estado sin distorsiones! <br><br>  Volvamos a wideNES: al observar todas las IRQ en el medio del cuadro y al recordar la l√≠nea r√°ster en la que ocurrieron, wideNES puede ignorar todas las l√≠neas r√°ster posteriores en el registro.  Si se produce IRQ en la l√≠nea r√°ster por encima de 240/2, todas <em>las</em> l√≠neas <em>anteriores</em> se ignoran, porque la interrupci√≥n temprana de la l√≠nea r√°ster significa que la barra de estado puede estar <em>en la parte superior de la</em> pantalla. <br><br>  Despu√©s de implementar esta heur√≠stica, <em>Super Mario Bros.</em>  <em>¬°3</em> ganados perfectos! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/44a/b08/14644ab0880d7a2827bcad22d028a0be.gif"></div><br><hr><br>  Brevemente consider√© la posibilidad de usar una biblioteca de visi√≥n por computadora, como OpenCV, para reconocer paneles de estado (u otras √°reas mayormente est√°ticas de la pantalla), pero como resultado decid√≠ abandonarla.  Usar una biblioteca de visi√≥n por computadora enorme, compleja y opaca es contrario a los ideales de wideNES, en el que trato de usar reglas y heur√≠sticas compactas, simples y transparentes para obtener resultados. <br><br><hr><br><h3>  Reconocimiento de escena </h3><br>  Con la excepci√≥n de algunos ejemplos destacados (por ejemplo, <em>Metroid</em> ), los juegos para NES generalmente <em>no</em> pasan dentro de un nivel enorme e inextricable.  Por el contrario, la mayor√≠a de los juegos de NES se dividen en muchas "escenas" peque√±as e independientes con puertas o pantallas de transici√≥n entre ellas. <br><br>  Como wideNES no tiene el concepto de "escenas", suceden cosas malas cuando se cambian las escenas ... <br><br>  Por ejemplo, aqu√≠ est√° la primera transici√≥n de la escena <em>Castlevania</em> , donde Simon Belmont entra en el castillo de Dr√°cula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/b5b/8e4/7f7b5b8e4edf5c31dd19682b333d75c9.gif"></div><br>  ¬°Guau, todo est√° mal!  ¬°wideNES reescribi√≥ completamente la √∫ltima parte del nivel con la primera pantalla de un nuevo nivel! <br><br>  Obviamente, wideNES necesita alguna forma de reconocer los cambios de escena.  Pero cual? <br><br>  <em>Hashing perceptual!</em> <br><br>  A diferencia de las <em>funciones</em> hash <em>criptogr√°ficas</em> , que tienden a distribuir de manera uniforme datos de entrada similares en el espacio de informaci√≥n de salida, <em>las</em> funciones hash <em>perceptuales</em> intentan mantener los datos de entrada similares "cerca" entre s√≠ en el espacio de datos de salida.  ¬°Por lo tanto, los hash perceptuales son ideales para reconocer im√°genes similares! <br><br>  Las funciones hash perceptivas pueden ser incre√≠blemente complejas, algunas de ellas pueden reconocer im√°genes similares si una de ellas fue rotada, escalada, estirada y los colores cambiaron.  Afortunadamente, wideNES no requiere funciones hash complejas porque se garantiza que cada cuadro tendr√° el mismo tama√±o.  Por lo tanto, wideNES utiliza el hash perceptual m√°s simple: ¬° <em>sumando todos los p√≠xeles en la pantalla!</em> <br><br>  ¬°Es simple, pero funciona bastante bien! <br><br>  Por ejemplo, vea c√≥mo se destacan las transiciones entre escenas si traza el hash perceptual a lo largo del tiempo en <em>The Legend of Zelda</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/799/5e3/f077995e3d509802139543805d7ae61b.png"></div><br>  Actualmente, wideNES usa un umbral fijo entre los valores hash perceptuales para completar la transici√≥n entre escenas, pero el resultado est√° lejos de ser ideal.  Diferentes juegos usan diferentes paletas, y hay muchos casos en los que wideNES cree que se ha producido una transici√≥n, pero en realidad no fue as√≠.  Idealmente, wideNES deber√≠a usar un valor de umbral din√°mico, pero hasta ahora el fijo lo har√°. <br><br>  Despu√©s de implementar esta nueva heur√≠stica, wideNES reconoce con √©xito la entrada de Simon desde <em>Castlevania</em> al castillo y, en consecuencia, crea un nuevo lienzo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/6da/e81/6446dae81018592433a99f4f50a8b4d0.gif"></div><br>  Y con esta decisi√≥n, ponemos en marcha la √∫ltima pieza importante del rompecabezas de wideNES. <br><br>  Habiendo implementado la serializaci√≥n m√°s simple, finalmente pude ejecutar el juego para NES, jugar en varios niveles y generar autom√°ticamente mapas de niveles. <br><br><h2>  ¬øQu√© le espera a wideNES en el futuro? </h2><br>  wideNES consta de dos partes separadas: <em>el kernel</em> wideNES, que son las reglas / heur√≠sticas subyacentes a la tecnolog√≠a, y la implementaci√≥n espec√≠fica de wideNES dentro del emulador ANESE. <br><br><h3>  Ampliaci√≥n del <em>n√∫cleo de</em> WideNES </h3><br>  En primer lugar, wideNES es propenso a un reconocimiento demasiado agresivo de las transiciones entre escenas.  El n√∫mero de falsos positivos se puede minimizar utilizando un algoritmo de hashing perceptual m√°s adecuado o cambiando a valores de umbral din√°mico entre hashes perceptuales. <br><br>  Tambi√©n se requiere trabajo adicional para reconocer elementos de pantalla est√°ticos.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Megaman IV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiene una IRQ en el medio del cuadro, pero no hay una barra de estado, por lo que wideNES ignora por error la parte s√≥lida del campo de juego. Aunque este caso particular puede corregirse mediante ajuste manual, es mejor usar heur√≠sticas m√°s inteligentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunos juegos de NES desplazan la pantalla de formas "√∫nicas". Uno de los ejemplos m√°s notables es </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que utiliza PPUSCROLL para desplazamiento horizontal, pero utiliza un registro completamente diferente para desplazamiento vertical: PPUADDR. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es un juego bastante popular, por lo que wideNES implementa heur√≠stica espec√≠ficamente para </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Hay otros juegos con modos de desplazamiento "√∫nicos" similares, que tambi√©n requieren heur√≠sticas individuales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√≠a √∫til encontrar alguna forma de "coser" escenas id√©nticas. Por ejemplo, si un usuario juega a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nivel 1, pero se arrastra hacia la tuber√≠a para ingresar a la cueva subterr√°nea con monedas, wideNES crear√° dos escenas separadas para el Nivel 1: escena A, nivel hasta que Mario ingrese a la zona con monedas, y la escena B, nivel, desde el momento cuando Mario sale de la tuber√≠a y sube al asta de la bandera. Si el juego se reinicia y el Nivel 1 se reproduce </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entrar en la tuber√≠a, wideNES simplemente actualizar√° la escena A, que contendr√° un mapa de nivel completo, pero la escena B se "interrumpir√°".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, wideNES debe seguir las transiciones entre escenas. </font><font style="vertical-align: inherit;">Sin estos datos, no ser√° posible construir un gr√°fico de transiciones entre escenas para generar mapas mundiales de juegos que </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consisten en un solo mundo grande.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mejorando la implementaci√≥n de wideNES en ANESE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualmente, wideNES se implementa solo en el emulador NES que escrib√≠ con el nombre ANESE. ANESE es un </font><font style="vertical-align: inherit;">emulador </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muy</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> espartano: la mayor√≠a de las opciones est√°n ocultas detr√°s de los indicadores de la CLI, y la √∫nica interfaz de usuario implementada es la superposici√≥n de selecci√≥n de archivos m√°s simple. Todav√≠a est√° </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muy</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lejos del nivel de "producci√≥n". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de la falta de UI, ANESE y wideNES, las mejoras en compatibilidad y velocidad no afectar√≠an. ¬°ANESE es el primer emulador que escrib√≠, y es notable! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay bastantes problemas de compatibilidad: muchos juegos no funcionan correctamente o no se inician en absoluto. Afortunadamente, la imperfecci√≥n de ANESE no significa que wideNES sea una mala tecnolog√≠a. ¬°wideNES se basa en principios probados que ser√°n f√°ciles de implementar en otros emuladores!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En t√©rminos de velocidad, ANESE y wideNES no son perfectos, e incluso en PC relativamente potentes, ¬°el rendimiento a veces puede caer por debajo de 60 fps! ANESE y wideNES necesitan implementar muchas optimizaciones. Adem√°s de la mejora general del n√∫cleo ANESE, existe la necesidad de mejorar la grabaci√≥n de marcos wideNES, la representaci√≥n de mapas y el muestreo hash.</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el art√≠culo, habl√© sobre los aspectos principales de wideNES, pero no pude describir muchas caracter√≠sticas peque√±as. Por ejemplo, wideNES almacena un mapa de los valores reales de hash y desplazamiento de cada cuadro, que se utilizan para habilitar escenas repetidas. Esta y muchas otras caracter√≠sticas se describen en el c√≥digo fuente ampliamente comentado para wideNES, publicado en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la p√°gina del proyecto wideNES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajar en wideNES fue una experiencia realmente sorprendente, pero con el enfoque del nuevo semestre acad√©mico en la Universidad de Waterloe, dudo que en el futuro cercano pueda continuar desarrollando wideNES. En este momento, las funciones principales de wideNES est√°n funcionando, ¬°y me alegra haber podido escribir esta publicaci√≥n describiendo algunas de sus tecnolog√≠as!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Intenta usar wideNES y comparte tus sentimientos! </font><font style="vertical-align: inherit;">Descarga </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANESE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lanza </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Super Mario Bros. </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Legend of Zelda</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metroid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ¬°y juega de una manera nueva!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421555/">https://habr.com/ru/post/es421555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421545/index.html">Revisi√≥n de PocketBook 616: la billetera 2018 m√°s econ√≥mica con funci√≥n de retroiluminaci√≥n</a></li>
<li><a href="../es421547/index.html">Aceptaci√≥n del centro de datos independiente</a></li>
<li><a href="../es421549/index.html">Estamos escribiendo documentaci√≥n t√©cnica: una gu√≠a para el profano</a></li>
<li><a href="../es421551/index.html">Dominando Vuex - De cero a h√©roe</a></li>
<li><a href="../es421553/index.html">Compartimos contenido tecnol√≥gico: hemos reunido todos nuestros materiales en un solo sitio</a></li>
<li><a href="../es421557/index.html">Lecci√≥n abierta "Programaci√≥n asincr√≥nica en Java"</a></li>
<li><a href="../es421559/index.html">Arquitectura de IU de componentes en la aplicaci√≥n iOS</a></li>
<li><a href="../es421563/index.html">Es posible que deba sentarse de manera diferente para deshacerse del dolor de espalda.</a></li>
<li><a href="../es421565/index.html">C√≥mo los robots humanoides groseros pueden enga√±arte</a></li>
<li><a href="../es421567/index.html">Discusi√≥n: ac√∫stica port√°til inusual: un auto deportivo, radio retro y ‚Äúbotas de audio‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>