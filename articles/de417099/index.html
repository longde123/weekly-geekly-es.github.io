<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏾 👃🏿 👩🏽‍🎤 Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 2 💶 🌜 🚠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zusammenfassung der vorherigen Teile 
 Aufgrund von Einschränkungen bei der Verwendung von C ++ 11-Compilern und mangelnder Alternativen wollte boost ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417099/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Ja - ja, mit diesem Motto streiz ich mich in der Schlacht." width="300" height="350" align="left"><h3>  Zusammenfassung der vorherigen Teile </h3><br>  Aufgrund von Einschränkungen bei der Verwendung von C ++ 11-Compilern und mangelnder Alternativen wollte boost seine eigene Implementierung der Standard-C ++ 11-Bibliothek über die mit dem Compiler gelieferte C ++ 98 / C ++ 03-Bibliothek schreiben. <br><br>  Zusätzlich zu den Standard-Header-Dateien <b>type_traits</b> wurden <b>thread</b> , <b>mutex</b> , <b>chrono</b> , <b>nullptr.h</b> hinzugefügt <b>,</b> die <i>std :: nullptr_t</i> und <b>core.h implementieren,</b> wobei Makros für compilerabhängige <b>Funktionen</b> hinzugefügt und die Standardbibliothek erweitert wurden. <br><br>  Link zu GitHub mit dem Ergebnis für heute für ungeduldige und Nichtleser: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Engagements und konstruktive Kritik sind willkommen</a></b> </blockquote><a name="habracut"></a><br><h4>  Inhaltsverzeichnis </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 1. Viam Supervadet Vadens</a> <br>  <b>Kapitel 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 3. Finden der perfekten nullptr-Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 4. C ++ Template Magic</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1 Wir fangen klein an</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.2 Über wie viele wundersame Fehler das Protokoll für uns kompiliert</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3 Zeiger und alles in allem</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4 Was wird sonst noch für die Vorlagenbibliothek benötigt?</a> <br>  Kapitel 5 <br>  ... <br><br><h3>  Kapitel 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif </h3><br>  Nachdem der gesamte Code ein wenig gekämmt und durch "Standard" <b>-Header</b> in einen separaten <b>Namespace stdex unterteilt worden war,</b> begann ich, <b>type_traits</b> , <b>nullptr.h</b> und zusammen mit <b>core.h auszufüllen</b> , das Makros enthielt, um die vom Compiler verwendete Version des Standards zu bestimmen und zu unterstützen <b>Native nullptr</b> , <b>char16_t</b> , <b>char32_t</b> und <b>static_assert</b> . <br><br>  Theoretisch ist alles einfach - gemäß dem C ++ - Standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(</a> <b>Abschnitt</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">14.8) muss das</a> <b>__cplusplus-</b> Makro vom Compiler definiert werden und der Version des unterstützten Standards entsprechen: <br><br><pre><code class="cpp hljs">C++ pre-C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 1 C++98: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L C++98 + TR1: #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ??? C++11: #define __cplusplus 201103L C++14: #define __cplusplus 201402L C++17: #define __cplusplus 201703L</span></span></span></span></code> </pre> <br>  Dementsprechend ist der Code zur Bestimmung der Verfügbarkeit von Support trivial: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (__cplusplus &gt;= 201103L) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  C++ 11   #define _STDEX_NATIVE_CPP11_SUPPORT //   11  (nullptr, static_assert) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT //    char16_t, char32_t #endif</span></span></span></span></code> </pre><br><img src="https://habrastorage.org/webt/oq/qj/y8/oqqjy8dy_l8fyahlkfb3m-6uv3u.jpeg" alt="Bild" width="300" height="250" align="left">  Tatsächlich ist nicht alles so einfach und jetzt beginnen interessante Krücken mit einem Rechen. <br><br>  Erstens implementieren nicht alle oder vielmehr keine der Compiler den nächsten Standard nicht vollständig und sofort.  In Visual Studio 2013 <b>fehlte constexpr</b> beispielsweise sehr lange, während behauptet wurde, dass es C ++ 11 unterstützt - mit der Einschränkung, dass die Implementierung nicht abgeschlossen ist.  Das heißt, <b>auto</b> - bitte <b>static_assert</b> - ist genauso einfach (auch von früheren MS VS), <b>constexpr</b> jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nicht</a> .  Zweitens stellen nicht alle Compiler (und das ist noch überraschender) diese Definition korrekt zur Verfügung und aktualisieren sie rechtzeitig.  Unerwarteterweise hat Visual Studio im selben Compiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Version von __cplusplus</a> <b>define nicht</b> von den ersten Versionen des Compilers an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geändert</a> , obwohl die vollständige Unterstützung für C ++ 11 seit langem deklariert wurde (was auch nicht zutrifft, für die es separate Strahlen der Unzufriedenheit gibt - sobald die Konversation zu der spezifischen Funktionalität des "neuen" kommt "11 Standardentwickler sagen sofort, dass es keinen C99-Präprozessor gibt, es gibt keine anderen" Funktionen ").  Und die Situation wird durch die Tatsache verschärft, dass Standard-Compiler diese Definition anders als die oben genannten Werte festlegen dürfen, wenn sie den deklarierten Standards nicht vollständig entsprechen.  Es wäre logisch, beispielsweise eine solche Entwicklung von Definitionen für ein bestimmtes Makro anzunehmen (mit der Einführung neuer Funktionen erhöhen Sie die Zahl, die hinter dieser Definition verborgen ist): <br><br><pre> <code class="cpp hljs">standart C++<span class="hljs-number"><span class="hljs-number">98</span></span>: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __cplusplus 199711L </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// C++98 standart C++98 + TR1: #define __cplusplus 200311L // C++03 nonstandart C++11: #define __cplusplus 200411L // C++03 + auto and dectype nonstandart C++11: #define __cplusplus 200511L // C++03 + auto, dectype and constexpr(partly) ... standart C++11: #define __cplusplus 201103L // C++11</span></span></span></span></code> </pre><br>  Gleichzeitig ist keiner der beliebtesten Compiler mit dieser Funktion "abgenutzt". <br><br>  Aus diesem Grund (ich habe keine Angst vor diesem Wort) müssen Sie jetzt für jeden nicht standardmäßigen Compiler Ihre eigenen spezifischen Prüfungen schreiben, um herauszufinden, welcher C ++ - Standard und in welchem ​​Umfang er unterstützt.  Die gute Nachricht ist, dass wir nur einige Compilerfunktionen kennenlernen müssen, um richtig zu funktionieren.  Zunächst fügen wir jetzt die Versionsprüfung für Visual Studio über das Makro <b>_MSC_VER hinzu</b> , das für diesen Compiler eindeutig ist.  Da es in meinem Arsenal an unterstützten Compilern auch C ++ Borland Builder 6.0 gibt, dessen Entwickler wiederum sehr darauf bedacht waren, die Kompatibilität mit Visual Studio (einschließlich seiner "Funktionen" und Fehler) aufrechtzuerhalten, gibt es plötzlich auch dieses Makro.  Für Clang-kompatible Compiler gibt es ein nicht standardmäßiges Makro <b>__has_feature (</b> feature_name <b>)</b> , mit dem Sie herausfinden können, ob der Compiler diese oder jene Funktionalität unterstützt.  Infolgedessen wird der Code aufgeblasen auf: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif</span></span></span></span></code> </pre><br>  Möchten Sie mehr Compiler erreichen?  Wir fügen Überprüfungen für Codegear C ++ Builder hinzu, der der Erbe von Borland ist (in seinen schlimmsten Erscheinungsformen, aber dazu später mehr): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Es ist auch erwähnenswert, dass Visual Studio die <b>Nullptr-</b> Unterstützung ab der Compiler-Version <b>_MSC_VER 1600</b> sowie die integrierten Typen <b>char16_t</b> und <b>char32_t</b> bereits implementiert hat und dies korrekt behandeln muss.  Ein paar weitere Schecks hinzugefügt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif</span></span></span></span></code> </pre><br>  Gleichzeitig werden wir prüfen, ob C ++ 98 unterstützt wird, da für Compiler ohne diese Unterstützung keine Header-Dateien der Standardbibliothek vorhanden sind und wir das Fehlen dieser Dateien nicht mithilfe des Compilers überprüfen können. <br><br><div class="spoiler">  <b class="spoiler_title">Volle Option</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __has_feature #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __has_feature(x) 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Compatibility with non-clang compilers. #endif // Any compiler claiming C++11 supports, Visual C++ 2015 and Clang version supporting constexpr #if ((__cplusplus &gt;= 201103L) || (_MSC_VER &gt;= 1900) || (__has_feature(cxx_constexpr))) // C++ 11 implementation #define _STDEX_NATIVE_CPP11_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #if !defined(_STDEX_NATIVE_CPP11_TYPES_SUPPORT) #if ((__cplusplus &gt; 199711L) || defined(__CODEGEARC__)) #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if ((!defined(_MSC_VER) || _MSC_VER &lt; 1600) &amp;&amp; !defined(_STDEX_NATIVE_CPP11_SUPPORT)) #define _STDEX_IMPLEMENTS_NULLPTR_SUPPORT #else #define _STDEX_NATIVE_NULLPTR_SUPPORT #endif #if (_MSC_VER &gt;= 1600) #ifndef _STDEX_NATIVE_CPP11_TYPES_SUPPORT #define _STDEX_NATIVE_CPP11_TYPES_SUPPORT #endif #endif #if _MSC_VER // Visual C++ fallback #define _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT #define _STDEX_CDECL __cdecl #if (__cplusplus &gt;= 199711L) #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif // C++ 98 check: #if ((__cplusplus &gt;= 199711L) &amp;&amp; ((defined(__INTEL_COMPILER) || defined(__clang__) || (defined(__GNUC__) &amp;&amp; ((__GNUC__ &gt; 4) || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 4)))))) #ifndef _STDEX_NATIVE_CPP_98_SUPPORT #define _STDEX_NATIVE_CPP_98_SUPPORT #endif #endif</span></span></span></span></code> </pre><br></div></div><br>  Und jetzt tauchen in meinem Gedächtnis umfangreiche Konfigurationen von Boost auf, in denen viele fleißige Entwickler all diese compilerabhängigen Makros geschrieben und eine Karte erstellt haben, was von einem bestimmten Compiler einer bestimmten Version unterstützt wird und was nicht, von der ich mich persönlich unwohl fühle. Ich möchte es nie mehr anschauen oder anfassen.  Aber die gute Nachricht ist, dass Sie dort aufhören können.  Zumindest reicht dies für mich aus, um die gängigsten Compiler zu unterstützen. Wenn Sie jedoch eine Ungenauigkeit feststellen oder einen weiteren Compiler hinzufügen möchten, nehme ich die Pull-Anfrage nur zu gerne an. <br><br>  Eine großartige Leistung im Vergleich zu Boost. Ich glaube, dass es möglich war, die Verbreitung von compilerabhängigen Makros über den Code hinweg aufrechtzuerhalten, wodurch der Code sauberer und verständlicher wird und nicht Dutzende von Konfigurationsdateien für jedes Betriebssystem und für jeden Compiler gestapelt werden.  Wir werden etwas später auf die Nachteile dieses Ansatzes eingehen. <br><br>  Zu diesem Zeitpunkt können wir bereits beginnen, die fehlenden Funktionen aus den 11 Standards zu verbinden, und als erstes führen wir <b>static_assert ein</b> . <br><br><h3>  static_assert </h3><br>  Wir definieren die <i>StaticAssertion-</i> Struktur, die einen Booleschen Wert als Vorlagenparameter verwendet. Wenn diese Bedingung nicht erfüllt ist (der Ausdruck ist <b>falsch</b> ), tritt beim Kompilieren einer nicht spezialisierten Vorlage ein Fehler auf.  Und eine weitere Dummy-Struktur zum Empfangen von <b>sizeof (</b> <i>StaticAssertion</i> <b>)</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> stdex { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticAssertion</span></span></span><span class="hljs-class">&lt;true&gt; {</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// StaticAssertion&lt;true&gt; template&lt;int i&gt; struct StaticAssertionTest { }; // StaticAssertionTest&lt;int&gt; } }</span></span></code> </pre><br>  und weitere Makromagie <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// no C++11 support #define CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #define CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #define CONCATENATE2(arg1, arg2) arg1##arg2 #define STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__) #ifndef _STDEX_NATIVE_NULLPTR_SUPPORT #define static_assert(expression, message) STATIC_ASSERT(expression, ERROR_MESSAGE_STRING) #endif #endif</span></span></span></span></code> </pre><br>  Verwendung: <br><br><pre> <code class="cpp hljs">STATIC_ASSERT(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) == <span class="hljs-number"><span class="hljs-number">4</span></span>, non_x32_platform_is_unsupported);</code> </pre><br><blockquote>  Ein wichtiger Unterschied zwischen meiner Implementierung und der <a href="">Standardimplementierung</a> besteht darin, dass dieses Schlüsselwort nicht überladen wird, <u>ohne dies</u> dem Benutzer mitzuteilen.  Dies liegt an der Tatsache, dass es in C ++ unmöglich ist, mehrere Definitionen mit unterschiedlicher Anzahl von Argumenten als einem Namen zu definieren, und eine Implementierung ohne Nachricht ist viel weniger nützlich als die ausgewählte Option.  Diese Funktion führt dazu, dass <b>STATIC_ASSERT</b> in meiner Implementierung im Wesentlichen die Version ist, die bereits in C ++ 11 hinzugefügt wurde. </blockquote>  Werfen wir einen Blick darauf, was passiert ist.  Aufgrund der Überprüfung der Versionen von <b>__cplusplus-</b> und nicht standardmäßigen Compilermakros verfügen wir über genügend Informationen zur C ++ 11-Unterstützung (und damit zum <b>static_assert</b> ), ausgedrückt durch die <b>Definition</b> _STDEX_NATIVE_CPP11_SUPPORT.  Wenn dieses Makro definiert ist, können wir einfach den Standard <b>static_assert verwenden</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message) static_assert((expression), #message)</span></span></code> </pre><br><blockquote>  Beachten Sie, dass der zweite Parameter des <b>STATIC_ASSERT-</b> Makros überhaupt kein <b>Zeichenfolgenliteral ist.</b> Daher konvertieren wir den <i>Nachrichtenparameter unter</i> Verwendung des Präprozessoroperators <b>#</b> in eine Zeichenfolge zur Übertragung an den Standard <b>static_assert</b> . </blockquote>  Wenn wir keine Unterstützung vom Compiler haben, fahren wir mit unserer Implementierung fort.  Zunächst deklarieren wir Hilfsmakros für das „Kleben“ von Strings (der Präprozessoroperator <b>##</b> ist nur dafür verantwortlich). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE(arg1, arg2) CONCATENATE1(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE1(arg1, arg2) CONCATENATE2(arg1, arg2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONCATENATE2(arg1, arg2) arg1##arg2</span></span></code> </pre><br><blockquote>  Ich habe speziell nicht einfach <b>#define CONCATENATE (</b> <i>arg1</i> , <i>arg2</i> <b>)</b> <i>arg1 ## arg2</i> verwendet, um das Ergebnis desselben <b>CONCATENATE-</b> Makros als Argument an <i>arg1</i> und <i>arg2 übergeben zu können</i> . </blockquote>  Als nächstes deklarieren wir eine Struktur mit dem schönen Namen __static_assertion_at_line_ {Zeilennummer} (das Makro <b>__LINE__</b> wird ebenfalls durch den Standard definiert und muss auf die Zeilennummer erweitert werden, in der es aufgerufen wurde) und fügen innerhalb dieser Struktur ein Feld unseres Typs <i>StaticAssertion</i> mit dem Namen STATIC_ASSERTION_FAILED_AT_LINE_ {Zeilennummer} _WITH hinzu Fehlermeldungen vom aufrufenden Makro}. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STATIC_ASSERT(expression, message)\ struct CONCATENATE(__static_assertion_at_line_, __LINE__)\ {\ stdex::detail::StaticAssertion</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;static_cast&lt;bool&gt;((expression))&gt; CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _WITH__), message);\ };\ typedef stdex::detail::StaticAssertionTest&lt;sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))&gt; CONCATENATE(__static_assertion_test_at_line_, __LINE__)</span></span></span></span></code> </pre><br>  <i>Mit dem</i> Template-Parameter in <i>StaticAssertion übergeben</i> wir einen Ausdruck, der in <b>STATIC_ASSERT</b> überprüft wird und zu <b>bool führt</b> .  Um zu vermeiden, dass lokale Variablen erstellt werden und die Benutzerbedingung nicht mit Overhead überprüft wird, wird ein Alias ​​für den Typ <i>StaticAssertionTest &lt;sizeof ({Name der oben deklarierten Struktur})</i> mit dem Namen __static_assertion_test_at_line_ {Zeilennummer} deklariert. <br><br>  Die ganze Schönheit der Benennung ist nur erforderlich, um aus einem Kompilierungsfehler klar zu machen, dass dies ein Assert-Ergebnis ist und nicht nur ein Fehler, sondern auch, um eine Fehlermeldung anzuzeigen, die für diesen Assert festgelegt wurde.  Der <b>sizeof-</b> Trick ist erforderlich, um den Compiler zu zwingen, die <i>StaticAssertion-</i> Vorlagenklasse, die sich in der gerade deklarierten Struktur befindet, zu instanziieren und somit die zu bestätigende Bedingung zu überprüfen. <br><br><div class="spoiler">  <b class="spoiler_title">STATIC_ASSERT Ergebnisse</b> <div class="spoiler_text"><blockquote>  GCC: <br>  30: 103: Fehler: Feld 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' hat einen unvollständigen Typ 'stdex :: detail :: StaticAssertion &lt;false&gt;' <br>  25:36: Anmerkung: In der Definition des Makros 'CONCATENATE2' <br>  23.36 Uhr: Hinweis: In Erweiterung des Makros 'CONCATENATE1' <br>  30:67: Hinweis: In Erweiterung des Makros 'CONCATENATE' <br>  24.36 Uhr: Hinweis: In Erweiterung des Makros 'CONCATENATE2' <br>  23.36 Uhr: Hinweis: In Erweiterung des Makros 'CONCATENATE1' <br>  30:79: Hinweis: In Erweiterung des Makros 'CONCATENATE' <br>  24.36 Uhr: Hinweis: In Erweiterung des Makros 'CONCATENATE2' <br>  23.36 Uhr: Hinweis: In Erweiterung des Makros 'CONCATENATE1' <br>  30:91: Hinweis: In Erweiterung des Makros 'CONCATENATE' <br>  36: 3: Hinweis: In Erweiterung des Makros 'STATIC_ASSERT' <br><br>  Borland C ++ Builder: <br>  [C ++ - Fehler] stdex_test.cpp (36): E2450 Undefinierte Struktur 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br>  [C ++ - Fehler] stdex_test.cpp (36): E2449 Größe von 'STATIC_ASSERTION_FAILED_AT_LINE_36_WITH__non_x32_platform_is_unsupported' ist unbekannt oder Null <br>  [C ++ - Fehler] stdex_test.cpp (36): E2450 Undefinierte Struktur 'stdex :: detail :: StaticAssertion &lt;0&gt;' <br><br>  Visual Studio: <br>  Fehler c2079 </blockquote><br></div></div><br>  Der zweite "Trick", den ich haben wollte, obwohl <u>er</u> im Standard <u>fehlt,</u> ist <b>countof</b> - das Zählen der Anzahl der Elemente im Array.  Sisher deklarieren dieses Makro sehr gern durch sizeof (arr) / sizeof (arr [0]), aber wir werden noch weiter gehen. <br><br><h3>  countof </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstddef&gt; namespace stdex { namespace detail { template &lt;class T, std::size_t N&gt; constexpr std::size_t _my_countof(T const (&amp;)[N]) noexcept { return N; } } // namespace detail } #define countof(arr) stdex::detail::_my_countof(arr) #else //no C++11 support #ifdef _STDEX_NATIVE_MICROSOFT_COMPILER_EXTENSIONS_SUPPORT // Visual C++ fallback #include &lt;stdlib.h&gt; #define countof(arr) _countof(arr) #elif defined(_STDEX_NATIVE_CPP_98_SUPPORT)// C++ 98 trick #include &lt;cstddef&gt; template &lt;typename T, std::size_t N&gt; char(&amp;COUNTOF_REQUIRES_ARRAY_ARGUMENT(T(&amp;)[N]))[N]; #define countof(x) sizeof(COUNTOF_REQUIRES_ARRAY_ARGUMENT(x)) #else #define countof(arr) sizeof(arr) / sizeof(arr[0]) #endif</span></span></span></span></code> </pre><br>  Für Compiler mit <b>constexpr-</b> Unterstützung deklarieren <b>wir</b> eine constexpr-Version dieser Vorlage (was für alle Standards absolut nicht erforderlich ist, die Implementierung über die <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT-</i> Vorlage ist <i>ausreichend</i> ), für den Rest führen wir die Version über die Vorlagenfunktion <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT ein</i> .  Visual Studio zeichnet sich hier wiederum durch das Vorhandensein einer eigenen Implementierung von <b>_countof</b> in der Header-Datei <b>stdlib.h aus</b> . <br><br>  Die Funktion <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> sieht einschüchternd aus und es ist ziemlich schwierig <i>herauszufinden</i> , was sie tut.  Wenn Sie genau hinschauen, können Sie verstehen, dass ein Array von Elementen des Vorlagentyps <i>T</i> und der Größe <i>N</i> das einzige Argument ist. Wenn Sie also andere Elementtypen (keine Arrays) übertragen, erhalten Sie einen Kompilierungsfehler, der zweifellos gefällt.  Bei näherer Betrachtung können Sie (mit Schwierigkeiten) feststellen, dass ein Array von <b>Zeichenelementen</b> der Größe <i>N zurückgegeben wird.</i>  Die Frage ist, warum brauchen wir das alles?  Hier kommt die <b>Größe des</b> Operators ins <b>Spiel</b> und seine einzigartige Fähigkeit, zur Kompilierungszeit zu arbeiten.  Die <b>Größe des</b> Aufrufs <b>(</b> <i>COUNTOF_REQUIRES_ARRAY_ARGUMENT</i> <b>)</b> bestimmt die Größe des von der Funktion zurückgegebenen Arrays von <i>Zeichenelementen.</i> Da die Standardgröße von <b>(char)</b> == 1 ist, ist dies die Anzahl von <i>N</i> Elementen im ursprünglichen Array.  Elegant, schön und völlig kostenlos. <br><br><h3>  für immer </h3><br>  Ein weiteres kleines Hilfsmakro, das ich überall dort verwende, wo eine Endlosschleife benötigt wird, ist <b>für immer</b> .  Es ist wie folgt definiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !defined(forever) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> forever for(;;) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER(x) #x #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STRINGIZE(x) STRINGIZE_HELPER(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARNING(desc) message(__FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"("</span></span></span><span class="hljs-meta"> STRINGIZE(__LINE__) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">") : warning: "</span></span></span><span class="hljs-meta"> desc) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> WARNING(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdex library - macro 'forever' was previously defined by user; ignoring stdex macro definition"</span></span></span><span class="hljs-meta">) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE_HELPER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> STRINGIZE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> WARNING #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Beispielsyntax zum Definieren einer expliziten Endlosschleife: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; forever { ++i; }</code> </pre><br>  Dieses Makro wird ausschließlich zum expliziten Definieren einer Endlosschleife verwendet und ist nur aus Gründen des „Hinzufügens von syntaktischem Zucker“ in der Bibliothek enthalten.  In Zukunft schlage ich vor, es durch optionales Definieren des <b>FOREVER-</b> Plug-In-Makros zu ersetzen.  Was im obigen Code-Snippet aus der Bibliothek bemerkenswert ist, ist dasselbe <b>WARNING-</b> Makro, das in allen Compilern eine Warnmeldung generiert, wenn das Makro für immer bereits vom Benutzer definiert wurde.  Es verwendet das bekannte Standardmakro <b>__LINE__</b> und das Standardmakro <b>__FILE__</b> , die in eine Zeichenfolge mit dem Namen der aktuellen Quelldatei konvertiert werden. <br><br><h3>  stdex_assert </h3><br>  Um <b>assert</b> in Runtime zu implementieren, wird das Makro <b>stdex_assert wie folgt</b> eingeführt: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(assert) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> NDEBUG #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #define stdex_assert(condition, message) \ do { \ if (! (condition)) { \ std::cerr &lt;&lt; "Assertion `" #condition "` failed in " &lt;&lt; __FILE__ \ &lt;&lt; " line " &lt;&lt; __LINE__ &lt;&lt; ": " &lt;&lt; message &lt;&lt; std::endl; \ std::terminate(); \ } \ } while (false) #else #define stdex_assert(condition, message) ((void)0) #endif #endif</span></span></span></span></code> </pre><br>  Ich werde nicht sagen, dass ich sehr stolz auf diese Implementierung bin (sie wird in Zukunft geändert werden), aber hier wurde eine interessante Technik verwendet, auf die ich aufmerksam machen möchte.  Um die Prüfungen vor dem Geltungsbereich des Anwendungscodes zu verbergen, wird das Konstrukt <b>do</b> <i>{}</i> <b>while (false)</b> verwendet, das ausgeführt wird. Dies ist einmal offensichtlich und führt gleichzeitig keinen "Service" -Code in den allgemeinen Anwendungscode ein.  Diese Technik ist sehr nützlich und wird an mehreren anderen Stellen in der Bibliothek verwendet. <br><br>  Andernfalls ist die Implementierung dem Standard- <b>Assert</b> sehr ähnlich. Mit einem bestimmten <b>NDEBUG-</b> Makro, das Compiler normalerweise in Release-Builds festlegen, führt assert nichts aus, andernfalls unterbricht es die Ausführung des Programms mit der Nachrichtenausgabe an den Standardfehlerstrom, wenn die Assert-Bedingung nicht erfüllt ist. <br><br><h3>  keine Ausnahme </h3><br>  Für Funktionen, die keine Ausnahmen <b>auslösen</b> , wurde das Schlüsselwort <b>noexcept</b> in den neuen Standard aufgenommen.  Es ist auch ganz einfach und schmerzlos möglich, über das Makro zu implementieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _STDEX_NATIVE_CPP11_SUPPORT #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept noexcept #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> stdex_noexcept throw() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Es ist jedoch zu verstehen, dass <b>noexcept</b> standardmäßig den Wert <b>bool</b> <b>annehmen</b> kann und auch verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden kann</a> , um zur Kompilierungszeit zu bestimmen, dass der an ihn übergebene Ausdruck keine Ausnahme <b>auslöst</b> .  Diese Funktionalität kann ohne Compiler-Unterstützung nicht implementiert werden. Daher gibt es in der Bibliothek nur ein "abgespecktes" <b>stdex_noexcept</b> . <br><br>  Das Ende des zweiten Kapitels.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dritte Kapitel befasst</a> sich mit den Feinheiten der nullptr-Implementierung, warum sie für verschiedene Compiler unterschiedlich ist, sowie mit der Entwicklung von type_traits und welchen anderen Fehlern in den Compilern, auf die ich während ihrer Entwicklung gestoßen bin. <br><br>  Danke für die Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417099/">https://habr.com/ru/post/de417099/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417087/index.html">HPE Digitalize 2018: Event und Live-Stream</a></li>
<li><a href="../de417089/index.html">Quantencomputer: Ein Photon, um alle zu regieren</a></li>
<li><a href="../de417091/index.html">Erstellen Sie einen Cartoon-Water-Shader für das Web. Teil 3</a></li>
<li><a href="../de417093/index.html">Touch-Schalter mit Modbus: Warum werden sie benötigt und wie werden sie in einer intelligenten Wohnung angewendet?</a></li>
<li><a href="../de417097/index.html">JavaScript-Metaprogrammierung</a></li>
<li><a href="../de417101/index.html">Definition von Ready - Was wir vergessen haben zu erzählen</a></li>
<li><a href="../de417103/index.html">Spark SQL. Ein bisschen über das Abfrageoptimierungsprogramm</a></li>
<li><a href="../de417105/index.html">Drucken auf einem 3D-Drucker. Die geheimen Erfahrungen von 3Dtool</a></li>
<li><a href="../de417107/index.html">Entwickler des Spiels während True: Erfahren Sie () mehr über Gamedev-Programmierung, VR-Probleme und ML-Simulationen</a></li>
<li><a href="../de417109/index.html">Richard Hamming: Kapitel 10. Codierungstheorie - I.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>