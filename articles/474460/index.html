<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèØ ü¶í üë®üèø‚Äçüåæ Descripci√≥n de arquitecturas de procesador en LLVM usando TableGen üê¨ üë®üèø‚Äçüè´ üèÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este momento, LLVM ya se ha convertido en un sistema muy popular, que muchas personas usan activamente para crear varios compiladores, analizadores...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Descripci√≥n de arquitecturas de procesador en LLVM usando TableGen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474460/"> En este momento, LLVM ya se ha convertido en un sistema muy popular, que muchas personas usan activamente para crear varios compiladores, analizadores, etc.  Ya se ha escrito una gran cantidad de materiales √∫tiles sobre este tema, incluso en ruso, lo cual es una buena noticia.  Sin embargo, en la mayor√≠a de los casos, el sesgo principal en los art√≠culos se realiza en el LLVM frontend y middleend.  Por supuesto, cuando se describe el esquema completo de la operaci√≥n LLVM, no se omite la generaci√≥n de c√≥digo de m√°quina, pero b√°sicamente este tema se trata de manera casual, especialmente en publicaciones en ruso.  Al mismo tiempo, LLVM tiene un mecanismo bastante flexible e interesante para describir arquitecturas de procesador.  Por lo tanto, este material se dedicar√° a la utilidad un tanto descuidada TableGen, que forma parte de LLVM. <br><br>  La raz√≥n por la que el compilador necesita tener informaci√≥n sobre la arquitectura de cada una de las plataformas de destino es bastante obvia.  Naturalmente, cada modelo de procesador tiene su propio conjunto de registros, sus propias instrucciones de m√°quina, etc.  Y el compilador necesita tener toda la informaci√≥n necesaria sobre ellos para poder generar un c√≥digo de m√°quina v√°lido y eficiente.  El compilador resuelve varias tareas espec√≠ficas de la plataforma: distribuye registros, etc.  Adem√°s, los backends de LLVM tambi√©n llevan a cabo optimizaciones en el IR de la m√°quina, que est√° m√°s cerca de las instrucciones reales o de las instrucciones del ensamblador.  En tales optimizaciones, las instrucciones deben reemplazarse y transformarse; en consecuencia, toda la informaci√≥n sobre ellas debe estar disponible. <br><a name="habracut"></a><br>  Para resolver el problema de describir la arquitectura del procesador, LLVM adopt√≥ un formato √∫nico para determinar las propiedades del procesador necesarias para el compilador.  Para cada arquitectura compatible, un <code>.td</code> contiene una descripci√≥n en un lenguaje formal especial.  Se convierte en archivos <code>.inc</code> cuando se compila el compilador utilizando la utilidad TableGen incluida con LLVM.  Los archivos resultantes, de hecho, son fuente C, pero tienen una extensi√≥n separada, muy probablemente, solo para que estos archivos generados autom√°ticamente puedan distinguirse y filtrarse f√°cilmente.  La documentaci√≥n oficial de TableGen est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y proporciona toda la informaci√≥n necesaria, tambi√©n hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descripci√≥n formal del idioma</a> y una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">introducci√≥n general</a> . <br><br>  Por supuesto, este es un tema muy extenso, donde hay muchos detalles sobre los cuales puede escribir art√≠culos individuales.  En este art√≠culo, simplemente consideramos los puntos b√°sicos de la descripci√≥n de los procesadores, incluso sin una descripci√≥n general de todas las caracter√≠sticas. <br><br><h2>  Descripci√≥n de la arquitectura en archivo .td </h2><br>  Entonces, el lenguaje de descripci√≥n formal utilizado en TableGen tiene caracter√≠sticas similares a los lenguajes de programaci√≥n ordinarios y le permite describir las caracter√≠sticas de la arquitectura en un estilo declarativo.  Y seg√∫n tengo entendido, este lenguaje tambi√©n se llama com√∫nmente TableGen.  Es decir  En este art√≠culo, TableGen usa tanto el nombre del lenguaje formal como la utilidad que genera los artefactos resultantes a partir de √©l. <br><br>  Los procesadores modernos son sistemas muy complejos, por lo que no es sorprendente que su descripci√≥n sea bastante voluminosa.  En consecuencia, para crear la estructura y simplificar el mantenimiento de los archivos <code>.td</code> pueden incluir entre s√≠ utilizando la directiva <code>#include</code> habitual para programadores en C.  Con la ayuda de esta directiva, el archivo <code>Target.td</code> siempre se incluye primero y contiene interfaces independientes de la plataforma que deben implementarse para proporcionar toda la informaci√≥n necesaria de TableGen.  Este archivo ya incluye un archivo <code>.td</code> con descripciones intr√≠nsecas de LLVM, pero por s√≠ mismo contiene principalmente clases base, como <code>Register</code> , <code>Instruction</code> , <code>Processor</code> , etc., de las cuales debe heredar para crear su propia arquitectura para el compilador basado en LLVM.  De la oraci√≥n anterior, est√° claro que TableGen tiene la noci√≥n de clases bien conocidas por todos los programadores. <br><br>  En general, TableGen tiene solo dos entidades b√°sicas: <b>clases</b> y <b>definiciones</b> . <br><br><h3>  Clases </h3><br>  Las clases TableGen tambi√©n son abstracciones, como en todos los lenguajes de programaci√≥n orientados a objetos, pero son entidades m√°s simples. <br><br>  Las clases pueden tener par√°metros y campos, y tambi√©n pueden heredar otras clases. <br>  Por ejemplo, una de las clases base se presenta a continuaci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A class representing the register size, spill size and spill alignment // in bits of a register. class RegInfo&lt;int RS, int SS, int SA&gt; { int RegSize = RS; // Register size in bits. int SpillSize = SS; // Spill slot size in bits. int SpillAlignment = SA; // Spill slot alignment in bits. }</span></span></code> </pre> <br>  Los corchetes angulares indican los par√°metros de entrada que se asignan a las propiedades de la clase.  A partir de este ejemplo, tambi√©n puede observar que el lenguaje TableGen est√° est√°ticamente escrito.  Los tipos que existen en TableGen: <code>bit</code> (un an√°logo del tipo booleano con valores 0 y 1), <code>int</code> , <code>string</code> , <code>code</code> (un fragmento de c√≥digo, este es un tipo, simplemente porque TableGen no tiene m√©todos y funciones en el sentido habitual, las l√≠neas de c√≥digo est√°n escritas en <code>[{ ... }]</code> ), bits &lt;n&gt;, lista &lt;tipo&gt; (los valores se establecen entre corchetes [...] como en Python y algunos otros lenguajes de programaci√≥n), <code>class type</code> , <code>dag</code> . <br><br>  La mayor√≠a de los tipos deben entenderse, pero si tienen preguntas, todos se describen en detalle en la especificaci√≥n del idioma, disponible en el enlace que se encuentra al principio del art√≠culo. <br><br>  La herencia tambi√©n se describe mediante una sintaxis bastante familiar con <code>:</code> <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemOperand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">printMethod</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsmOperandClass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parserMatchClass</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86MemAsmOperand</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Operand</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iPTR</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PrintMethod</span></span> = printMethod; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">MIOperandInfo</span></span> = (ops ptr_rc, i8imm, ptr_rc_nosp, i32imm, <span class="hljs-type"><span class="hljs-type">SEGMENT_REG</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">ParserMatchClass</span></span> = parserMatchClass; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">OperandType</span></span> = <span class="hljs-string"><span class="hljs-string">"OPERAND_MEMORY"</span></span>; }</code> </pre> <br>  En este caso, la clase creada, por supuesto, puede anular los valores de los campos especificados en la clase base usando la palabra clave <code>let</code> .  Y puede agregar sus propios campos similares a la descripci√≥n proporcionada en el ejemplo anterior, indicando el tipo de campo. <br><br><h3>  Definiciones </h3><br>  Las definiciones ya son entidades concretas, puede compararlas con lo familiar para todos los objetos.  Las definiciones se definen usando la palabra clave <code>def</code> y pueden implementar una clase, redefinir campos de clases base exactamente de la misma manera que se describi√≥ anteriormente, y tambi√©n tienen sus propios campos. <br><br><pre> <code class="swift hljs">def i8mem : <span class="hljs-type"><span class="hljs-type">X86MemOperand</span></span>&lt;<span class="hljs-string"><span class="hljs-string">"printbytemem"</span></span>, <span class="hljs-type"><span class="hljs-type">X86Mem8AsmOperand</span></span>&gt;; def <span class="hljs-type"><span class="hljs-type">X86AbsMemAsmOperand</span></span> : <span class="hljs-type"><span class="hljs-type">AsmOperandClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"AbsMem"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">SuperClasses</span></span> = [<span class="hljs-type"><span class="hljs-type">X86MemAsmOperand</span></span>]; }</code> </pre><br><h3>  Multiclases </h3><br>  Naturalmente, una gran cantidad de instrucciones en los procesadores tienen una sem√°ntica similar.  Por ejemplo, puede haber un conjunto de instrucciones de tres direcciones que toman las dos formas <code>‚Äúreg = reg op reg‚Äù</code> y <code>‚Äúreg = reg op imm‚Äù</code> .  En un caso, los valores se toman de los registros y el resultado tambi√©n se guarda en el registro, y en el otro caso, el segundo operando es un valor constante (imm - operando inmediato). <br><br>  Listar todas las combinaciones manualmente es bastante tedioso; aumenta el riesgo de cometer un error.  Por supuesto, pueden generarse autom√°ticamente escribiendo un script simple, pero esto no es necesario, porque existe un concepto como multiclases en el lenguaje TableGen. <br><br><pre> <code class="cpp hljs">multiclass ri_inst&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> opc, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> asmstr&gt; { def _rr : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;; def _ri : inst&lt;opc, !strconcat(asmstr, <span class="hljs-string"><span class="hljs-string">" $dst, $src1, $src2"</span></span>), (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;; }</code> </pre> <br>  Dentro de las multiclases, debe describir todas las formas posibles de instrucciones utilizando la palabra clave <code>def</code> .  Pero esta no es una forma completa de instrucciones que se generar√°n.  Al mismo tiempo, puede redefinir los campos en ellos y hacer todo lo posible en las definiciones habituales.  Para crear definiciones reales basadas en una multiclase, debe usar la palabra clave <code>defm</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Instantiations of the ri_inst multiclass. defm ADD : ri_inst&lt;0b111, "add"&gt;; defm SUB : ri_inst&lt;0b101, "sub"&gt;; defm MUL : ri_inst&lt;0b100, "mul"&gt;;</span></span></code> </pre> <br>  Y como resultado, para cada definici√≥n dada a trav√©s de <code>defm</code> de hecho, se construir√°n varias definiciones que son una combinaci√≥n de la instrucci√≥n principal y todas las formas posibles descritas en la multiclase.  Como resultado, se generar√°n las siguientes instrucciones en este ejemplo: <code>ADD_rr</code> , <code>ADD_ri</code> , <code>SUB_rr</code> , <code>SUB_ri</code> , <code>MUL_rr</code> , <code>MUL_ri</code> . <br><br>  Las multiclases pueden contener no solo definiciones con <code>def</code> , sino tambi√©n <code>defm</code> anidadas, lo que permite generar formas complejas de instrucciones.  Un ejemplo que ilustra la creaci√≥n de tales cadenas se puede encontrar en la documentaci√≥n oficial. <br><br><h3>  Metas secundarias </h3><br>  Otra cosa b√°sica y √∫til para los procesadores que tienen diferentes variaciones del conjunto de instrucciones es el soporte de subtarget en LLVM.  Un ejemplo de uso es la implementaci√≥n LLVM SPARC, que cubre tres versiones principales de la arquitectura de microprocesador SPARC a la vez: Versi√≥n 8 (V8, arquitectura de 32 bits), Versi√≥n 9 (V9, arquitectura de 64 bits) y arquitectura UltraSPARC.  La diferencia entre las arquitecturas es bastante grande, un n√∫mero diferente de registros de diferentes tipos, orden de bytes admitido, etc.  En tales casos, si hay varias configuraciones, vale la pena implementar la clase <code>XXXSubtarget</code> para la arquitectura.  El uso de esta clase en la descripci√≥n dar√° como resultado nuevas opciones de l√≠nea de comando <code>-mcpu=</code> y <code>-mattr=</code> . <br><br>  Adem√°s de la clase <code>Subtarget</code> s√≠, la clase <code>Subtarget</code> importante. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubtargetFeature</span></span></span><span class="hljs-class">&lt;string n, string a, string v, string d, list&lt;SubtargetFeature&gt; i = []&gt; {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Name = n; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Attribute = a; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Value = v; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Desc = d; <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;SubtargetFeature&gt; Implies = i; }</code> </pre> <br>  En el archivo <code>Sparc.td</code> , puede encontrar ejemplos de la implementaci√≥n de <code>SubtargetFeature</code> , que le permiten describir la disponibilidad de un conjunto de instrucciones para cada subtipo individual de la arquitectura. <br><br><pre> <code class="cpp hljs">def FeatureV9 : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsV9"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable SPARC-V9 instructions"</span></span>&gt;; def FeatureV8Deprecated : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"deprecated-v8"</span></span>, <span class="hljs-string"><span class="hljs-string">"V8DeprecatedInsts"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable deprecated V8 instructions in V9 mode"</span></span>&gt;; def FeatureVIS : SubtargetFeature&lt;<span class="hljs-string"><span class="hljs-string">"vis"</span></span>, <span class="hljs-string"><span class="hljs-string">"IsVIS"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"Enable UltraSPARC Visual Instruction Set extensions"</span></span>&gt;;</code> </pre><br>  En este caso, de todos modos, <code>Sparc.td</code> todav√≠a define la clase <code>Proc</code> , que se utiliza para describir subtipos espec√≠ficos de procesadores SPARC, que podr√≠an tener las propiedades descritas anteriormente, incluidos diferentes conjuntos de instrucciones. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Proc</span></span></span><span class="hljs-class">&lt;string Name, list&lt;SubtargetFeature&gt; Features&gt; :</span></span> Processor&lt;Name, NoItineraries, Features&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"generic"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v8"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"supersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"f934"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"hypersparc"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclite86x"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"sparclet"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"tsc701"</span></span>, []&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"v9"</span></span>, [FeatureV9]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3"</span></span>, [FeatureV9, FeatureV8Deprecated]&gt;; def : Proc&lt;<span class="hljs-string"><span class="hljs-string">"ultrasparc3-vis"</span></span>, [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</code> </pre> <br><h2>  Relaci√≥n entre las propiedades de las instrucciones en TableGen y el c√≥digo de fondo de LLVM </h2><br>  Las propiedades de las clases y definiciones le permiten generar y establecer correctamente las caracter√≠sticas arquitect√≥nicas, pero no hay acceso directo a ellas desde el c√≥digo fuente del back-end LLVM.  Sin embargo, a veces desea poder obtener algunas propiedades de instrucciones espec√≠ficas de la plataforma directamente en el c√≥digo del compilador. <br><br><h3>  TSFlags </h3><br>  Para hacer esto, la clase base <code>Instruction</code> tiene un campo <code>TSFlags</code> especial, de 64 bits de tama√±o, que TableGen convierte en un campo de objetos C ++ de la clase <code>MCInstrDesc</code> , generado sobre la base de los datos recibidos de la descripci√≥n de TableGen.  Puede especificar cualquier cantidad de bits que necesite para almacenar informaci√≥n.  Esto puede ser alg√∫n valor booleano, por ejemplo, para indicar que estamos usando una ALU escalar. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">TSFlags</span></span>{<span class="hljs-number"><span class="hljs-number">0</span></span>} = <span class="hljs-type"><span class="hljs-type">SALU</span></span>;</code> </pre> <br>  O podemos almacenar el tipo de instrucci√≥n.  Entonces necesitamos, por supuesto, m√°s de un bit. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Instruction type according to the ISA. IType Type = type; let TSFlags{7-1} = Type.Value;</span></span></code> </pre> <br>  Como resultado, es posible obtener estas propiedades de la instrucci√≥n en el c√≥digo de fondo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isSALU = MI.getDesc().TSFlags &amp; SIInstrFlags::SALU;</code> </pre> <br>  Si la propiedad es m√°s compleja, puede compararla con el valor descrito en TableGen, que se agregar√° a la enumeraci√≥n generada autom√°ticamente. <br><br><pre> <code class="cpp hljs">(Desc.TSFlags &amp; X86II::FormMask) == X86II::MRMSrcMem</code> </pre> <br><br><h3>  Predicados de funciones </h3><br>  Adem√°s, los predicados de funci√≥n se pueden usar para obtener la informaci√≥n necesaria sobre las instrucciones.  Con su ayuda, puede mostrar a TableGen que necesita generar una funci√≥n que estar√° disponible en el c√≥digo de fondo.  La clase base con la que puede crear dicha definici√≥n de funci√≥n se presenta a continuaci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Base class for function predicates. class FunctionPredicateBase&lt;string name, MCStatement body&gt; { string FunctionName = name; MCStatement Body = body; }</span></span></code> </pre> <br>  Puede encontrar f√°cilmente ejemplos de uso en el backend para X86.  Por lo tanto, existe su propia clase intermedia, con la ayuda de la cual ya se crean las definiciones necesarias de funciones. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Check that a call to method `Name` in class "XXXInstrInfo" (where XXX is // the name of a target) returns true. // // TIIPredicate definitions are used to model calls to the target-specific // InstrInfo. A TIIPredicate is treated specially by the InstrInfoEmitter // tablegen backend, which will use it to automatically generate a definition in // the target specific `InstrInfo` class. // // There cannot be multiple TIIPredicate definitions with the same name for the // same target class TIIPredicate&lt;string Name, MCStatement body&gt; : FunctionPredicateBase&lt;Name, body&gt;, MCInstPredicate; // This predicate evaluates to true only if the input machine instruction is a // 3-operands LEA. Tablegen automatically generates a new method for it in // X86GenInstrInfo. def IsThreeOperandsLEAFn : TIIPredicate&lt;"isThreeOperandsLEA", IsThreeOperandsLEABody&gt;; //   -    ,  -  ,       // Used to generate the body of a TII member function. def IsThreeOperandsLEABody : MCOpcodeSwitchStatement&lt;[LEACases], MCReturnStatement&lt;FalsePred&gt;&gt;;</span></span></code> </pre> <br>  Como resultado, puede usar el m√©todo <code>isThreeOperandsLEA</code> en c√≥digo C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(TII-&gt;isThreeOperandsLEA(MI) || hasInefficientLEABaseReg(Base, Index)) || !TII-&gt;isSafeToClobberEFLAGS(MBB, MI) || Segment.getReg() != X86::NoRegister) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br>  Aqu√≠ TII es la informaci√≥n de instrucci√≥n de destino, que se puede obtener utilizando el m√©todo <code>getInstrInfo()</code> del <code>MCSubtargetInfo</code> para la arquitectura deseada. <br><br><h2>  Transformaci√≥n de instrucciones durante optimizaciones.  Mapeo de instrucciones </h2><br>  Durante una gran cantidad de optimizaciones realizadas en las etapas posteriores de la compilaci√≥n, la tarea a menudo surge de convertir todas o solo una parte de las instrucciones de un formulario en instrucciones de otro formulario.  Dada la aplicaci√≥n de las multiclases descritas al principio, podemos tener una gran cantidad de instrucciones con sem√°nticas y propiedades similares.  En el c√≥digo, estas transformaciones, por supuesto, podr√≠an escribirse en forma de grandes construcciones de <code>switch-case</code> , que para cada instrucci√≥n aplastan la transformaci√≥n correspondiente.  Parcialmente, estas enormes construcciones se pueden reducir con la ayuda de macros, que formar√≠an el nombre necesario de la instrucci√≥n de acuerdo con reglas bien conocidas.  Pero a√∫n as√≠, este enfoque es muy inconveniente, es dif√≠cil de mantener debido al hecho de que todos los nombres de instrucciones se enumeran expl√≠citamente.  Agregar una nueva instrucci√≥n puede conducir f√°cilmente a un error, porque  debe recordar agregarlo a todas las conversiones relevantes.  Despu√©s de haber sido atormentado con este enfoque, LLVM cre√≥ un mecanismo especial para convertir eficientemente una forma de instrucci√≥n en otra <code>Instruction Mapping</code> . <br><br>  La idea es muy simple, es necesario describir posibles modelos para transformar instrucciones directamente en TableGen.  Por lo tanto, en LLVM TableGen hay una clase base para describir tales modelos. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InstrMapping</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Used to reduce search space only to the instructions using this // relation model. string FilterClass; // List of fields/attributes that should be same for all the instructions in // a row of the relation table. Think of this as a set of properties shared // by all the instructions related by this relationship. list&lt;string&gt; RowFields = []; // List of fields/attributes that are same for all the instructions // in a column of the relation table. list&lt;string&gt; ColFields = []; // Values for the fields/attributes listed in 'ColFields' corresponding to // the key instruction. This is the instruction that will be transformed // using this relation model. list&lt;string&gt; KeyCol = []; // List of values for the fields/attributes listed in 'ColFields', one for // each column in the relation table. These are the instructions a key // instruction will be transformed into. list&lt;list&lt;string&gt; &gt; ValueCols = []; }</span></span></code> </pre> <br>  Veamos un ejemplo que se da en la documentaci√≥n.  Los ejemplos que se pueden encontrar en el c√≥digo fuente ahora son a√∫n m√°s simples, ya que solo se obtienen dos columnas en la tabla final.  En el c√≥digo de back-end puede encontrar la conversi√≥n de formas antiguas a nuevas formas de instrucciones, instrucciones dsp en mmdsp, etc., descritas mediante el mapeo de instrucciones.  De hecho, este mecanismo no se usa tan ampliamente hasta ahora, simplemente porque la mayor√≠a de los backends comenzaron a crearse antes de que apareciera, y para que funcione, a√∫n necesita establecer las propiedades correctas para las instrucciones, por lo que cambiar a √©l no siempre es f√°cil, puede necesitar algunos refactorizaci√≥n. <br><br>  Entonces, por ejemplo.  Supongamos que tenemos formas de instrucciones sin predicados e instrucciones donde el predicado es respectivamente verdadero y falso.  Los describimos con la ayuda de una clase m√∫ltiple y una clase especial, que solo usaremos como filtro.  Una descripci√≥n simplificada sin par√°metros y muchas propiedades puede ser algo como esto. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PredRel</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">multiclass</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInstruction</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">BaseOpcode</span></span> = name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> { def : <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; } def _pt: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"true"</span></span>; } def _pf: <span class="hljs-type"><span class="hljs-type">PredRel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-type"><span class="hljs-type">PredSense</span></span> = <span class="hljs-string"><span class="hljs-string">"false"</span></span>; } } } defm <span class="hljs-type"><span class="hljs-type">ADD</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">ADD</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">SUB</span></span>: <span class="hljs-type"><span class="hljs-type">MyIntruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">SUB</span></span>‚Äù&gt;; defm <span class="hljs-type"><span class="hljs-type">MUL</span></span>: <span class="hljs-type"><span class="hljs-type">MyInstruction</span></span>&lt;‚Äù<span class="hljs-type"><span class="hljs-type">MUL</span></span>‚Äù&gt;; ‚Ä¶</code> </pre> <br>  En este ejemplo, por cierto, tambi√©n se muestra c√≥mo anular una propiedad para varias definiciones a la vez usando la construcci√≥n <code>let ‚Ä¶ in</code> .  Como resultado, tenemos muchas instrucciones que almacenan su nombre base y propiedad que describe de forma √∫nica su forma.  Entonces puedes crear un modelo de transformaci√≥n. <br><br><pre> <code class="swift hljs">def getPredOpcode : <span class="hljs-type"><span class="hljs-type">InstrMapping</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,       - PredRel  let FilterClass = "PredRel"; //         ,      let RowFields = ["BaseOpcode"]; //          PredSense. let ColFields = ["PredSense"]; //  ,  ,       ,     PredSense=‚Äù‚Äù let KeyCol = [""]; //   PredSense      let ValueCols = [["true"], ["false"]]; }</span></span></code> </pre> <br>  Como resultado, la siguiente tabla se generar√° a partir de esta descripci√≥n. <br><br><div class="scrollable-table"><table><tbody><tr><th>  PredSense = "" </th><th>  PredSense = "verdadero" </th><th>  PredSense = "falso" </th></tr><tr><td>  AGREGAR </td><td>  ADD_pt </td><td>  ADD_pf </td></tr><tr><td>  SUB </td><td>  SUB_pt </td><td>  SUB_pf </td></tr><tr><td>  Mul </td><td>  MUL_pt </td><td>  MUL_pf </td></tr></tbody></table></div><br>  Se generar√° una funci√≥n en el archivo <code>.inc</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPredOpcode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Opcode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PredSense inPredSense)</span></span></span></span></code> </pre> <br>  Que, en consecuencia, acepta un c√≥digo de instrucciones para la conversi√≥n y el valor de la enumeraci√≥n generada autom√°ticamente de PredSense, que contiene todos los valores posibles en las columnas.  La implementaci√≥n de esta funci√≥n es muy simple, porque  devuelve el elemento de matriz deseado para la instrucci√≥n que nos interesa. <br><br>  Y en el c√≥digo de back-end, en lugar de escribir un <code>switch-case</code> suficiente simplemente llamar a la funci√≥n generada, que devolver√° el c√≥digo de la instrucci√≥n convertida.  Una soluci√≥n simple, donde agregar nuevas instrucciones, no conducir√° a la necesidad de una acci√≥n adicional. <br><br><h2>  Artefactos generados autom√°ticamente (archivos <code>.inc</code> ) </h2><br>  Toda la interacci√≥n entre la descripci√≥n de TableGen y el c√≥digo de fondo de LLVM est√° asegurada por los archivos <code>.inc</code> generados que contienen el c√≥digo C.  Para obtener una imagen completa, veamos un poco qu√© son exactamente. <br><br>  Despu√©s de cada compilaci√≥n, para cada arquitectura, habr√° varios archivos <code>.inc</code> en el directorio de compilaci√≥n, cada uno de los cuales almacena informaci√≥n separada sobre la arquitectura.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que hay un archivo </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que contiene informaci√≥n sobre las instrucciones </font></font><code>&lt;TargetName&gt;GenRegisterInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectivamente, que contiene informaci√≥n sobre los registros, hay archivos para trabajar directamente con el ensamblador y su salida </font></font><code>&lt;TargetName&gt;GenAsmMatcher.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>&lt;TargetName&gt;GenAsmWriter.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, ¬øen qu√© consisten estos archivos? En general, contienen enumeraciones, matrices, estructuras y funciones simples. Por ejemplo, puede ver la informaci√≥n convertida en las instrucciones en </font></font><code>&lt;TargetName&gt;GenInstrInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la primera parte, en el espacio de nombres con el nombre del objetivo hay una enumeraci√≥n que contiene todas las instrucciones que se han descrito.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> X86 { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { PHI = <span class="hljs-number"><span class="hljs-number">0</span></span>, ‚Ä¶ ADD16i16 = <span class="hljs-number"><span class="hljs-number">287</span></span>, ADD16mi = <span class="hljs-number"><span class="hljs-number">288</span></span>, ADD16mi8 = <span class="hljs-number"><span class="hljs-number">289</span></span>, ADD16mr = <span class="hljs-number"><span class="hljs-number">290</span></span>, ADD16ri = <span class="hljs-number"><span class="hljs-number">291</span></span>, ADD16ri8 = <span class="hljs-number"><span class="hljs-number">292</span></span>, ADD16rm = <span class="hljs-number"><span class="hljs-number">293</span></span>, ADD16rr = <span class="hljs-number"><span class="hljs-number">294</span></span>, ADD16rr_REV = <span class="hljs-number"><span class="hljs-number">295</span></span>, ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente es un conjunto que describe las propiedades de las instrucciones </font></font><code>const MCInstrDesc X86Insts[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Las siguientes matrices contienen informaci√≥n sobre nombres de instrucciones, etc. </font><font style="vertical-align: inherit;">B√°sicamente, toda la informaci√≥n se almacena en transferencias y matrices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n hay funciones que se han descrito utilizando predicados. </font><font style="vertical-align: inherit;">Seg√∫n la definici√≥n del predicado de la funci√≥n discutida en la secci√≥n anterior, se generar√° la siguiente funci√≥n.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> X86InstrInfo::isThreeOperandsLEA(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MachineInstr &amp;MI) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(MI.getOpcode()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA64_32r: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> X86::LEA16r: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).isReg() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">3</span></span>).getReg() != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ( ( MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isImm() &amp;&amp; MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).getImm() != <span class="hljs-number"><span class="hljs-number">0</span></span> ) || (MI.getOperand(<span class="hljs-number"><span class="hljs-number">4</span></span>).isGlobal()) ) ); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// end of switch-stmt }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero hay datos en los archivos y estructuras generados. </font><font style="vertical-align: inherit;">En </font></font><code>X86GenSubtargetInfo.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usted puede encontrar un ejemplo de la estructura que debe usarse en el c√≥digo de back-end para obtener informaci√≥n sobre la arquitectura, a trav√©s de ella en la secci√≥n anterior obtuvimos TTI.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X86GenMCSubtargetInfo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MCSubtargetInfo { X86GenMCSubtargetInfo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Triple &amp;TT, StringRef CPU, StringRef FS, ArrayRef&lt;SubtargetFeatureKV&gt; PF, ArrayRef&lt;SubtargetSubTypeKV&gt; PD, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteProcResEntry *WPR, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCWriteLatencyEntry *WL, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MCReadAdvanceEntry *RA, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InstrStage *IS, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *OC, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> *FP) : MCSubtargetInfo(TT, CPU, FS, PF, PD, WPR, WL, RA, IS, OC, FP) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveVariantSchedClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SchedClass, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MCInst *MI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPUID)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X86_MC::resolveVariantSchedClassImpl(SchedClass, MI, CPUID); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se usa </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para describir varias configuraciones </font></font><code>XXXGenSubtarget.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se crear√° una enumeraci√≥n con las propiedades descritas usando </font></font><code>SubtargetFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matrices con valores constantes para indicar las caracter√≠sticas y subtipos de la CPU, y se generar√° una funci√≥n </font></font><code>ParseSubtargetFeatures</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que procesa la cadena con el conjunto de opciones </font></font><code>Subtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Adem√°s, la implementaci√≥n del m√©todo </font></font><code>XXXSubtarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el c√≥digo de fondo debe corresponder al siguiente pseudoc√≥digo, en el que es necesario usar esta funci√≥n:</font></font><br><br><pre> <code class="cpp hljs">XXXSubtarget::XXXSubtarget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Module &amp;M, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;FS) { <span class="hljs-comment"><span class="hljs-comment">// Set the default features // Determine default and user specified characteristics of the CPU // Call ParseSubtargetFeatures(FS, CPU) to parse the features string // Perform any additional operations }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de que los </font></font><code>.inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">archivos son muy voluminosos y contienen grandes matrices, esto nos permite optimizar el tiempo de acceso a la informaci√≥n, ya que el acceso a un elemento de matriz tiene un tiempo constante. </font><font style="vertical-align: inherit;">Las funciones de b√∫squeda generadas por instrucciones se implementan utilizando un algoritmo de b√∫squeda binario para minimizar el tiempo de funcionamiento. </font><font style="vertical-align: inherit;">Por lo tanto, el almacenamiento en esta forma est√° bastante justificado.</font></font><br><br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, gracias a TableGen en LLVM, tenemos descripciones de arquitectura legibles y f√°cilmente compatibles en un solo formato con varios mecanismos para interactuar y acceder a la informaci√≥n del c√≥digo fuente de back-end LLVM para optimizaciones y generaci√≥n de c√≥digo. </font><font style="vertical-align: inherit;">Al mismo tiempo, dicha descripci√≥n no afecta el rendimiento del compilador debido al c√≥digo autogenerado que utiliza soluciones eficientes y estructuras de datos.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474460/">https://habr.com/ru/post/474460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474444/index.html">5 proyectos de entrenamiento m√°s atrevidos para el desarrollador (Layer, Squoosh, Calculator, Website Crawler, Music Player)</a></li>
<li><a href="../474448/index.html">De lo que es capaz el cerebro de un estudiante en el mundo de la inform√°tica</a></li>
<li><a href="../474450/index.html">Deje de usar TTL rid√≠culamente peque√±o para DNS</a></li>
<li><a href="../474452/index.html">Informe de estado de oto√±o de Haxe</a></li>
<li><a href="../474458/index.html">Total acumulativo en SQL</a></li>
<li><a href="../474462/index.html">Enorme conjunto de datos abierto del discurso ruso versi√≥n 1.0</a></li>
<li><a href="../474466/index.html">Historia del primer diablo</a></li>
<li><a href="../474470/index.html">Ataque DDoS en servicios RDP: reconocer y superar. Experiencia exitosa de Tucha</a></li>
<li><a href="../474472/index.html">Lista de verificaci√≥n UX de 30 puntos para aplicaciones m√≥viles</a></li>
<li><a href="../474474/index.html">Puntos de referencia abiertos para pruebas de carga de servidores y aplicaciones web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>