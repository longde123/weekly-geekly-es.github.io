<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèΩ üîá üåÑ Otimiza√ß√£o de energia STM32: um guia pr√°tico üÄÑÔ∏è ‚úåüèΩ üñêÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Existem muitos artigos na rede sobre a opera√ß√£o de microcontroladores STM32 em dispositivos com efici√™ncia de energia - geralmente dispos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otimiza√ß√£o de energia STM32: um guia pr√°tico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430218/"> Ol√° Habr! <br><br>  Existem muitos artigos na rede sobre a opera√ß√£o de microcontroladores STM32 em dispositivos com efici√™ncia de energia - geralmente dispositivos com bateria - no entanto, dentre eles, √© lament√°vel que eles n√£o entendam esse t√≥pico fora da lista de modos de economia de energia e comandos SPL / HAL que os incluem (no entanto, a mesma reivindica√ß√£o se aplica para a grande maioria dos artigos sobre como trabalhar com o STM32). <br><br>  Enquanto isso, devido ao r√°pido desenvolvimento de resid√™ncias inteligentes e todos os tipos de IoT, o t√≥pico est√° se tornando cada vez mais relevante - nesses sistemas, muitos componentes s√£o alimentados por bateria e s√£o esperados anos de opera√ß√£o cont√≠nua a partir deles. <br><br>  Vamos preencher essa lacuna com o exemplo do STM32L1 - um controlador muito popular, bastante econ√¥mico e, ao mesmo tempo, com alguns problemas espec√≠ficos para esta s√©rie.  Quase todas as op√ß√µes acima tamb√©m se aplicam ao STM32L0 e STM32L4 e, em termos de problemas e abordagens comuns, a outros controladores baseados nos n√∫cleos Cortex-M. <br><br><img src="https://habrastorage.org/webt/-r/az/lt/-razltjud_qdbwtc74aaopi69la.jpeg"><br><br>  O resultado pr√°tico deve se parecer com a foto acima (e sim, tamb√©m falaremos sobre a aplicabilidade de mult√≠metros e outros instrumentos de medi√ß√£o para tarefas semelhantes). <br><a name="habracut"></a><br><h3>  Modos de economia de energia no STM32L1 </h3><br>  Os princ√≠pios b√°sicos da economia de bateria s√£o os principais modos de economia de energia do processador.  Cada fabricante e cada s√©rie de controladores t√™m seus pr√≥prios (um conjunto espec√≠fico √© uma extens√£o de fornecedor dos modos principais do Cortex-M padr√£o com v√°rias nuances em rela√ß√£o √† periferia, tens√µes de alimenta√ß√£o etc.). <br><br>  Especificamente, o STM32L1, que pertence √† s√©rie econ√¥mica de controladores e, em conex√£o com isso, entre outras coisas, recebeu um conjunto expandido de configura√ß√µes de energia, temos o seguinte: <br><br><ul><li>  <b>Executar</b> - modo normal.  Tudo inclu√≠do, todos os perif√©ricos dispon√≠veis, frequ√™ncia de at√© 32 MHz. </li><li>  <b>Low Power Run (LP Run)</b> - um modo especial com uma frequ√™ncia de opera√ß√£o dentro de 131 kHz e consumo m√°ximo, <i>considerando toda a periferia</i> , 200 ŒºA.  No modo LP Run, o regulador de energia do processador entra em um modo econ√¥mico especial, que economiza at√© cinquenta microamperes em compara√ß√£o com o trabalho com a mesma frequ√™ncia no modo Run. </li><li>  <b>Sono</b> - suspens√£o do n√∫cleo, mas com a preserva√ß√£o de todas as frequ√™ncias do rel√≥gio.  Os perif√©ricos do processador podem continuar funcionando se o kernel n√£o precisar, mas pode ser desligado automaticamente. </li><li>  <b>Low Power Sleep (LP Sleep)</b> - uma combina√ß√£o de Sleep com a transi√ß√£o do estabilizador para o modo econ√¥mico.  A frequ√™ncia do rel√≥gio n√£o √© superior a 131 kHz, o consumo total n√£o √© superior a 200 ŒºA. </li><li>  <b>Stop</b> - uma parada completa de todas as frequ√™ncias do rel√≥gio, exceto o gerador de "rel√≥gio" 32768 Hz, externo ou interno.  No caso do STM32L1, apenas o rel√≥gio em tempo real continua funcionando nesse modo, tudo o resto para completamente;  nos processadores mais recentes, alguns perif√©ricos podem ter freq√º√™ncia baixa.  <i>Quase</i> todas as pernas do processador mant√™m seu estado.  O conte√∫do da RAM √© salvo, as interrup√ß√µes externas continuam a funcionar. </li><li>  <b>Em espera</b> - um desligamento completo do n√∫cleo do processador, RAM e todos os perif√©ricos, exceto os rel√≥gios em tempo real.  A RAM n√£o √© salva (ou seja, do ponto de vista do software, sair no modo de espera √© quase o mesmo que distorcer a fonte de alimenta√ß√£o - comece do come√ßo), o RTC continua a funcionar.  Interrup√ß√µes externas n√£o funcionam, exceto por tr√™s pernas especiais do WKUPx, cuja altern√¢ncia de 0 para 1 desperta o processador. </li></ul><br>  A entrada de cada um dos modos √© bastante simples - voc√™ precisa definir os sinalizadores em tr√™s a cinco registros, ap√≥s o qual (para modos de suspens√£o) chama a instru√ß√£o WFI ou WFE, esta √© a instru√ß√£o Cortex-M padr√£o, significa "Wait For Interrupt" e "Wait For Event" .  Dependendo dos sinalizadores (eles s√£o descritos no Manual de Refer√™ncia do processador, para STM32L1 √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RM0038</a> ), o pr√≥prio processador entrar√° neste modo neste comando. <br><br>  Al√©m disso, seria bom proibir interrup√ß√µes (isso n√£o afetar√° a capacidade de eventos externos e internos de acordar o processador do modo de suspens√£o) e aguardar que os dados sejam salvos dos registros na mem√≥ria, caso ocorra repentinamente, usando o comando DSB. <br><br>  Por exemplo, √© assim que parece o modo de parada: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  PDDS    Stop  Standby,    */</span></span> PWR-&gt;CR &amp;= ~(PWR_CR_PDDS); <span class="hljs-comment"><span class="hljs-comment">/*  Wakeup   ,      */</span></span> PWR-&gt;CR |= PWR_CR_CWUF; <span class="hljs-comment"><span class="hljs-comment">/*    low-power ,    Stop -    */</span></span> PWR-&gt;CR |= PWR_CR_LPSDSR; <span class="hljs-comment"><span class="hljs-comment">/*    Vref   */</span></span> PWR-&gt;CR |= PWR_CR_ULP; <span class="hljs-comment"><span class="hljs-comment">/*     Cortex-M,  Stop,  Standby -   Deep Sleep */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      Deep Sleep */</span></span> SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk); <span class="hljs-comment"><span class="hljs-comment">/*  ;       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> state = irq_disable(); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> __DSB(); <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> __WFI(); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> init_clk(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> irq_restore(state);</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O WFI</a> √© uma instru√ß√£o de bloqueio; nele, o processador entra em sono profundo e n√£o sai at√© que ocorra algum tipo de interrup√ß√£o.  Sim, repito, apesar do fato de termos desativado explicitamente as interrup√ß√µes, o processador responder√° a elas e acordar√° - mas s√≥ iniciar√° o processamento depois que as ligarmos novamente.  E isso tem um significado profundo. <br><br>  No c√≥digo acima, ap√≥s o WFI, algum tipo de reinicializa√ß√£o das frequ√™ncias de opera√ß√£o n√£o est√° acontecendo apenas - o fato √© que L1 <i>sempre</i> deixa o sono profundo a uma frequ√™ncia de 4,2 MHz e com um gerador MSI interno como fonte dessa frequ√™ncia.  Em muitas situa√ß√µes, obviamente, voc√™ n√£o deseja que o manipulador de interrup√ß√£o que ativa o processador comece a funcionar nessa frequ√™ncia - por exemplo, porque as frequ√™ncias de todos os timers, UART e outros barramentos desaparecer√£o;  portanto, primeiro restauramos as frequ√™ncias operacionais (ou, se quisermos permanecer no MSI, recalculamos os barramentos necess√°rios em 4,2 MHz) e depois mergulhamos em interrup√ß√µes. <br><br>  Na pr√°tica, os dois modos mais usados ‚Äã‚Äãs√£o Run e Stop.  O fato √© que o LP Run √© extremamente lento e n√£o faz sentido se o processador precisar executar alguns c√°lculos e n√£o apenas esperar por eventos externos, e o Sleep e o LP Sleep n√£o s√£o muito econ√¥micos (consumo de at√© 2 mA) e s√£o necess√°rios se voc√™ precisar economize pelo menos um pouco, mas ao mesmo tempo deixe os perif√©ricos em funcionamento e / ou forne√ßa a rea√ß√£o mais r√°pida do processador aos eventos.  Tais requisitos existem, mas no geral n√£o com muita frequ√™ncia. <br><br>  O modo de espera geralmente n√£o √© usado, porque depois que √© imposs√≠vel continuar de onde voc√™ parou devido ao zeramento da RAM, tamb√©m existem alguns problemas com dispositivos externos, que discutiremos abaixo, que exigem solu√ß√µes de hardware.  No entanto, se o dispositivo foi projetado com isso em mente, o modo de espera pode ser usado como um modo "desligado", por exemplo, durante o armazenamento prolongado deste dispositivo. <br><br>  Na verdade, na apresenta√ß√£o disso, a maioria dos manuais geralmente se rompe triunfante. <br><br>  O problema √© que, seguindo-os, voc√™ ficar√° triste com 100-200 ŒºA de consumo real em vez dos prometidos 1,4 ŒºA em Stop com o hor√°rio de trabalho - mesmo na depura√ß√£o de refer√™ncia Nucleo, que n√£o possui chips, sensores externos etc. a que poderia ser atribu√≠do. <br><br>  E n√£o, seu processador est√° funcionando, n√£o h√° nada na errata e voc√™ fez tudo certo. <br><br>  S√≥ n√£o at√© o fim. <br><br><h3>  S√≠ndrome das pernas inquietas </h3><br>  O primeiro problema STM32L1, sobre o qual <i>alguns</i> artigos mencionam, mas geralmente s√£o lembrados apenas em f√≥runs, quando no terceiro dia de discuss√£o, de onde vieram os 100-200 ŒºA, algu√©m se lembra da exist√™ncia do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AN3430</a> e chega √† 19¬™ p√°gina nele - isso estado das pernas por padr√£o. <br><br>  Observo que at√© o pr√≥prio STMicro se refere ao problema pelas mangas, e na maioria dos documentos em que a otimiza√ß√£o do consumo de energia √© considerada, ela √© limitada a uma ou duas frases com o conselho de puxar as pernas n√£o usadas no ch√£o ou coloc√°-las no modo de entrada anal√≥gica, sem explicar os motivos. <br><br>  O triste √© que, por padr√£o, todas as pernas est√£o configuradas como entradas digitais (0x00 no registro GPIOx_MODER).  Um gatilho Schmitt est√° sempre na entrada digital, o que melhora a imunidade a ru√≠dos dessa entrada e √© completamente independente - √© um elemento l√≥gico simples, um buffer com histerese que n√£o requer rel√≥gio externo. <br><br>  No nosso caso, isso significa que desligamos o rel√≥gio no modo Stop e os gatilhos de Schmitt continuaram a funcionar como se nada tivesse acontecido - dependendo do n√≠vel do sinal de entrada, eles trocam suas sa√≠das para 0 e 1. <br><br>  Ao mesmo tempo, parte das pernas do processador em um circuito t√≠pico fica suspensa no ar - ou seja, n√£o h√° sinal intelig√≠vel nelas.  Seria errado pensar que a aus√™ncia de um sinal claro significa que nessas pernas 0 n√£o existe, nessas pernas devido √† sua alta imped√¢ncia de entrada, h√° algum ru√≠do aleat√≥rio de valor indeterminado, desde captadores e corrente que flui das faixas vizinhas at√© o primeiro canal de televis√£o, se o p√© for longo o suficiente para servir como antena (no entanto, as TVs anal√≥gicas na R√∫ssia ser√£o desligadas em breve, o que deve levar a uma redu√ß√£o no consumo de energia dos microcontroladores configurados incorretamente). <br><br>  De acordo com essas flutua√ß√µes, a perna, de alguma maneira aleat√≥ria, alterna entre 0 e 1. A l√≥gica do CMOS consome corrente ao alternar.  Ou seja, uma <i>perna do processador suspensa no ar, configurada no modo de entrada digital, consome uma corrente percept√≠vel em si mesma</i> . <br><br>  A sa√≠da disso √© simples - quando voc√™ inicia o programa, voc√™ precisa configurar todas as pernas para o estado da entrada anal√≥gica;  O STM32 possui formalmente todas as pernas, sem exce√ß√£o, independentemente de estarem ou n√£o conectadas ao ADC, e difere da entrada digital somente na aus√™ncia de um gatilho Schmitt na entrada. <br><br><img src="https://habrastorage.org/webt/nm/k2/py/nmk2py-r1zqa2rgltekzx69bmy8.png"><br><br>  Para fazer isso, basta escrever o valor 0xFF ... FF em todos os registros GPIOx_MODER; √© mais f√°cil fazer isso, como mencionado acima, logo no in√≠cio e, durante o decorrer da pe√ßa, voc√™ reconfigurar√° as pernas individuais, conforme necess√°rio neste dispositivo. <br><br>  Aqui, no entanto, surge um problema de segunda ordem - √© bom se o seu firmware funcionar em um controlador espec√≠fico e, portanto, voc√™ sempre sabe o que <i>x</i> existe no GPIOx.  Pior ainda se o firmware for universal - o STM32 pode ter <i>at√©</i> 8 portas, mas pode ser menor;  Quando voc√™ tenta gravar em uma porta que n√£o existe nesse modelo de controlador, voc√™ recebe Hard Fault, ou seja,  falha no kernel. <br><br>  No entanto, mesmo este caso pode ser contornado - o Cortex-M permite que voc√™ verifique os endere√ßos quanto √† sua validade; al√©m disso, no caso de M3 e M4, a verifica√ß√£o √© geralmente trivial e, no M0, requer alguma m√°gica, mas √© realiz√°vel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">detalhes podem ser lidos aqui</a> , n√£o vamos apreciar este artigo ) <br><br>  Ou seja, em geral, o processador foi iniciado, sintonizou as frequ√™ncias - e passou imediatamente por todas as portas GPIO dispon√≠veis, gravando-as em MODER (o c√≥digo abaixo foi escrito para o RIOT OS, mas, em geral, √© claro sem coment√°rios e pode ser transferido para tr√™s minutos qualquer outra plataforma). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(CPU_FAM_STM32L1) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* switch all GPIOs to AIN mode to minimize power consumption */</span></span></span><span class="hljs-meta"> GPIO_TypeDef *port; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* enable GPIO clock */</span></span></span><span class="hljs-meta"> uint32_t ahb_gpio_clocks = RCC-&gt;AHBENR &amp; 0xFF; periph_clk_en(AHB, 0xFF); for (uint8_t i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 8; i++) { port = (GPIO_TypeDef *)(GPIOA_BASE + i*(GPIOB_BASE - GPIOA_BASE)); if (cpu_check_address((char *)port)) { port-&gt;MODER = 0xffffffff; } else { break; } } /* restore GPIO clock */ uint32_t tmpreg = RCC-&gt;AHBENR; tmpreg &amp;= ~((uint32_t)0xFF); tmpreg |= ahb_gpio_clocks; periph_clk_en(AHB, tmpreg); #endif</span></span></span></span></code> </pre><br>  Observo que isso se aplica apenas √†s s√©ries L1, em L0 e L4 a experi√™ncia foi levada em considera√ß√£o e, por padr√£o, configuram todas as portas como entradas anal√≥gicas na inicializa√ß√£o. <br><br>  Depois de executar todos esses procedimentos com cuidado, voc√™ preenche o firmware no dispositivo finalizado ... e coloca 150 uA no modo Stop no processador e todos os chips externos desligados, apesar de suas estimativas serem as mais pessimistas, provenientes das folhas de dados de tudo o que voc√™ soldou na placa dar n√£o superior a 10 ŒºA. <br><br>  Al√©m disso, voc√™ tenta levar o processador para o modo de espera em vez de parar, ou seja,  basta deslig√°-lo quase completamente - e, em vez de cair, o consumo de energia aumenta em tr√™s vezes, chegando perto de meio miliampere! <br><br>  N√£o h√° necessidade de entrar em p√¢nico.  Como voc√™ deve ter adivinhado, voc√™ fez tudo certo.  Mas n√£o at√© o fim. <br><br><h3>  S√≠ndrome das Pernas Inquietas - 2 </h3><br>  O pr√≥ximo problema tem duas partes. <br><br>  O primeiro √© bastante √≥bvio: se o seu dispositivo n√£o consiste em um microcontrolador, √© importante n√£o esquecer que os chips externos tamb√©m t√™m sinais de entrada nos quais os gatilhos Schmitt ficam travados e que, al√©m disso, podem despertar a l√≥gica interna do chip.  Por exemplo, um chip que √© retirado e retirado do modo de suspens√£o pela equipe do UART tentar√° ler dados dele com qualquer movimento nesse barramento. <br><br>  Assim, se todas essas pernas estiverem penduradas no ar, n√£o teremos nada de bom. <br><br>  Sob quais condi√ß√µes eles acabam no ar? <br><br>  Primeiro, quando o controlador entra no modo de espera, todos os GPIOs s√£o transferidos para o estado High-Z, com alta resist√™ncia - ou seja, os chips externos conectados a eles est√£o no ar.  √â imposs√≠vel consertar isso programaticamente no STM32L1 (em outras s√©ries e outros controladores, isso acontece de maneiras diferentes); portanto, a √∫nica sa√≠da - em um sistema que usa o modo de espera, as entradas de chips externos devem ser puxadas para o terra ou alimentadas por resistores externos. <br><br>  Um n√≠vel espec√≠fico √© escolhido para que a linha fique inativa do ponto de vista do chip: <br><br><ul><li>  1 para UART TX </li><li>  0 para SPI MOSI </li><li>  0 para SPI CLK no modo SPI 0 ou 1 </li><li>  1 para SPI CLK com modo SPI 2 ou 3 </li><li>  1 para SPI CS </li></ul><br>  Em segundo lugar, no STM32 <i>ao usar o modo Stop</i> (sic!) <i>, O</i> estado dos GPIOs conectados aos blocos de hardware internos das interfaces pode ser ... diferente.  Ou seja, a mesma interface SPI, quando configurada, em Stop, de repente se torna uma entrada digital ou, em geral, High-Z - com as conseq√º√™ncias correspondentes para chips externos pendurados nela.  Enquanto a documenta√ß√£o declara que as pernas est√£o em boas condi√ß√µes, voc√™ pode confiar a priori somente se usar as pernas como GPIOs regulares. <br><br>  Voc√™ n√£o pode entend√™-lo e perdo√°-lo, mas pode-se lembrar e corrigi-lo: para interfaces que se comportam dessa maneira, voc√™ deve adicionar a troca for√ßada ao GPIO normal com n√≠veis correspondentes aos n√≠veis inativos dessa interface na fun√ß√£o de cuidados com o sono.  Depois de adormecer, as interfaces podem ser restauradas. <br><br>  Por exemplo, o mesmo SPI antes de dormir (por uma quest√£o de simplicidade, pego o c√≥digo do RIOT OS, fica claro que o mesmo √© f√°cil de implementar nos registros): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* specifically set GPIOs used for external SPI devices */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 0, MISO = AIN for SPI Mode 0 &amp; 1 (CPOL = 0) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* MOSI = 0, SCK = 1, MISO = AIN for SPI Mode 2 &amp; 3 (CPOL = 1) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SPI_NUMOF; i++) { <span class="hljs-comment"><span class="hljs-comment">/* check if SPI is in use */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_periph_clk(spi_config[i].apbbus, spi_config[i].rccmask) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* SPI CLK polarity */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spi_config[i].dev-&gt;CR1 &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>)) { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PU); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gpio_init(spi_config[i].sclk_pin, GPIO_IN_PD); } gpio_init(spi_config[i].mosi_pin, GPIO_IN_PD); gpio_init(spi_config[i].miso_pin, GPIO_AIN); } }</code> </pre><br>  Observe que as sa√≠das aqui s√£o configuradas n√£o como GPIO_OUT com n√≠vel 0 ou 1, mas como entradas com pull-up de 0 ou 1 - este n√£o √© um ponto fundamental, mas fornece seguran√ßa adicional se voc√™ cometer um erro e tentar executar pull-push com algum tipo de um chip externo puxando essa perna para o outro lado.  Com o GPIO_OUT, voc√™ pode organizar um curto-circuito, com o GPIO_IN com um pull-up - nunca. <br><br>  Al√©m disso, o sinal SPI CS n√£o √© afetado - nesse caso, √© gerado programaticamente, ou seja, por um GPIO normal e mant√©m seu estado em um sonho com confian√ßa. <br><br>  Para restaurar o estado da perna ao sair do sono, basta escrever os valores dos registros que ser√£o alterados (MODER, PUPDR, OTYPER, OSPEEDR - veja a situa√ß√£o em um caso particular) na entrada, em vari√°veis, e revert√™-los nos registros ao sair do sono . <br><br>  E agora ... ta daaam!  Imagem do t√≠tulo.  Um micro e meio. <br><br>  Mas √© muito cedo para comemorar.  Nisso conclu√≠mos a otimiza√ß√£o <i>est√°tica</i> do consumo de energia e, √† nossa frente, √© <i>din√¢mico</i> . <br><br><h3>  Achilles vs Turtle </h3><br>  O que √© melhor - coma mais e corra mais r√°pido ou coma menos, mas corra mais devagar?  No caso de microcontroladores, a resposta a essa pergunta √© duas vezes n√£o trivial. <br><br>  Primeiro, as frequ√™ncias de opera√ß√£o podem ser alteradas em uma faixa muito ampla - de 65 kHz (LP Run) a 32 MHz no modo normal.  Como qualquer chip CMOS, o STM32 possui dois componentes no consumo de energia - est√°tico e din√¢mico;  o segundo depende da frequ√™ncia, o primeiro √© constante.  Como resultado, o consumo de energia n√£o diminuir√° t√£o rapidamente quanto a frequ√™ncia e a produtividade operacionais e, dependendo da tarefa, a frequ√™ncia ideal do ponto de vista da efici√™ncia energ√©tica pode ser diferente - onde voc√™ precisa esperar por algum evento, mas, por algum motivo, n√£o consegue dormir, haver√° baixas frequ√™ncias s√£o eficazes, onde voc√™ s√≥ precisa trilhar n√∫meros - altos.  Em tarefas t√≠picas de "m√©dia hospitalar", geralmente n√£o faz sentido ficar abaixo de 2-4 MHz. <br><br>  Em segundo lugar, e este √© um momento menos trivial, a taxa de adormecer depende da frequ√™ncia de trabalho e da maneira como √© recebida. <br><br>  O pior caso √© adormecer a uma frequ√™ncia de 32 MHz a partir de um quartzo externo (lembre-se de que o STM32L1 acorda em um oscilador interno de 4 MHz), porque consiste em tr√™s est√°gios: <br><br><ul><li>  na verdade, o processador acorda do sono </li><li>  estabiliza√ß√£o de gera√ß√£o de quartzo (1-24 MHz) </li><li>  Estabiliza√ß√£o de gera√ß√£o de PLL (32 MHz) </li></ul><br>  Na verdade, tirar o processador do sono aqui √© o menor problema, com uma frequ√™ncia de 4,2 MHz e leva cerca de 10 Œºs.  Mas a estabiliza√ß√£o do quartzo pode levar at√© 1 ms (embora normalmente para ressonadores de alta velocidade ainda seja mais r√°pido, da ordem de v√°rias centenas de microssegundos), o acesso ao modo PLL √© de mais 160 Œºs. <br><br>  Esses atrasos podem n√£o ser significativos do ponto de vista do consumo de energia para um sistema que raramente acorda (n√£o mais que uma vez por segundo), mas onde o per√≠odo entre as ativa√ß√µes √© de dezenas de milissegundos e menos, e as ativa√ß√µes s√£o curtas, a sobrecarga come√ßa a fazer uma adi√ß√£o j√° mensur√°vel levando em considera√ß√£o que durante a ativa√ß√£o, o processador consome uma corrente relativamente pequena. <br><br>  O que pode ser feito com isso?  Em geral, a resposta √© √≥bvia: tente evitar o uso de quartzo externo.  Por exemplo, um programa no qual existem subtarefas pesadas raras que exigem rel√≥gio preciso (digamos, das triviais - troca de dados UART) e subtarefas simples e frequentes, podem decidir por si mesmo a cada despertar, se √© necess√°rio ir para quartzo externo, ou ser√° mais f√°cil (e mais r√°pido!) executar a tarefa atual no gerador MSI, no qual o processador j√° acordou sem gastar muito tempo inicializando as frequ√™ncias. <br><br>  Nesse caso, no entanto, pode ser necess√°rio ajustar as frequ√™ncias do rel√≥gio da periferia, bem como ajustar os modos de acesso √† mem√≥ria flash (o n√∫mero de ciclos de atraso), √† tens√£o do n√∫cleo do processador (no STM32L1 √© selecionado entre tr√™s valores poss√≠veis), etc.  No entanto, no que diz respeito aos modos de opera√ß√£o do kernel e da mem√≥ria, muitas vezes √© poss√≠vel ajust√°-los escolhendo os recomendados para a frequ√™ncia m√°xima usada, pois a opera√ß√£o n√£o ideal do n√∫cleo em frequ√™ncias mais baixas n√£o dar√° uma mudan√ßa significativa no desempenho pr√°tico e no consumo de energia devido ao pequeno volume de tarefas nessas frequ√™ncias. realizada. <br><br>  Embora todas essas medidas j√° se apliquem ao ajuste fino de modos (e, por exemplo, a maioria dos sistemas operacionais e bibliotecas nem sequer sabem nada pr√≥ximo da caixa), em alguns casos, elas podem levar a uma diminui√ß√£o no consumo m√©dio na escala de unidades de porcentagem, e √†s vezes at√© mais.  Imagine, por exemplo, um hidr√¥metro que examine os contatos de um comutador de palheta a cada 50 ms, enquanto a pesquisa real leva v√°rias dezenas de microssegundos - voc√™ deseja adicionar ~ 500 Œºs a essa altura para ativar o controlador? <br><br><h3>  Insuportavelmente longo segundo </h3><br>  Outro problema que n√£o est√° diretamente relacionado √† conserva√ß√£o de energia, mas inevitavelmente surge em conex√£o com ela - como contar intervalos de tempo inferiores a 1 segundo? <br><br>  O fato √© que no STM32L1 existe apenas um timer que funciona no modo Stop - este √© o RTC, a unidade de tempo padr√£o durante 1 segundo.  Ao mesmo tempo, nos programas, existem constantemente intervalos de tempo de unidades, dezenas e centenas de milissegundos, para levar pelo menos o mesmo medidor de √°gua. <br><br>  Como ser  Funciona em processadores com temporizadores LPTIM, com clock de 32768 Hz?  Uma boa op√ß√£o, de fato, mas nem sempre √© necess√°ria.  √â poss√≠vel sem ele. <br><br>  N√£o em todos os STM32L1, mas come√ßando com o gato.  2 (esses s√£o os processadores STM32L151CB-A, STM32L151CC e mais recentes), o bloco RTC foi complementado com um novo registro - SSR, SubSeconds Register.  Mais precisamente, n√£o foi t√£o complementado quanto tornado vis√≠vel para o usu√°rio, al√©m dos alarmes de segundo segundo ALRMASSR e ALRMBSSR foram adicionados. <br><br>  Este registro n√£o cont√©m nenhuma unidade de tempo compreens√≠vel; foi extra√≠do de um contador t√©cnico interno.  No STM32L1, um rel√≥gio que marca a 32768 Hz passa por dois contadores divisores, ass√≠ncrono e s√≠ncrono, que no total normalmente o dividem por 32768 para obter um tique de 1 segundo para o rel√≥gio.  Portanto, SSR √© apenas o valor atual do segundo contador. <br><br>  Embora o SSR conte n√£o em milissegundos, mas em suas unidades, a dimens√£o dessas unidades pode ser alterada alterando a propor√ß√£o dos divisores do contador s√≠ncrono e ass√≠ncrono, mantendo seu coeficiente total igual a 32768 para obter o padr√£o de 1 segundo na entrada do RTC.  Conhecendo esses coeficientes, podemos calcular o pre√ßo de uma divis√£o do SSR em milissegundos e, a partir daqui, podemos avan√ßar para a programa√ß√£o de alarmes de subsegundos. <br><br>  Deve-se notar que um pr√©-contador ass√≠ncrono √© mais econ√¥mico que um SSR s√≠ncrono e, portanto, defini-lo como 1, e j√° dividindo a frequ√™ncia de entrada no SSR por 32768, tendo recebido apenas 30 Œºs, √© energicamente desvantajoso.  Para n√≥s mesmos, determinamos o valor ideal para o divisor preliminar 7, para s√≠ncrono - 4095 ((7 + 1) * (4095 + 1) = 32768).  Com uma redu√ß√£o adicional no divisor preliminar, o consumo de energia do RTC come√ßa a crescer de forma mensur√°vel - por uma fra√ß√£o de um microampere, mas, como o comparamos com a "refer√™ncia" 1,4 ŒºA no modo Stop, at√© as fra√ß√µes s√£o importantes.  Por padr√£o, para STM32L1 esses valores s√£o 127 e 255, ou seja,  o pre√ßo de refer√™ncia √© de cerca de 4 ms, o que √© um pouco dif√≠cil. <br><br>  Se voc√™ quiser se aprofundar no c√≥digo, <a href="">finalizamos no</a> momento oportuno <a href="">o driver RTC padr√£o</a> do RIOT OS para oferecer suporte a intervalos RTC_SSR e milissegundos.  Desde ent√£o, o usamos literalmente em todas as etapas (e, como trabalhamos no sistema operacional, um servi√ßo tamb√©m fica em cima dele, o que permite que voc√™ pendure praticamente qualquer n√∫mero de tarefas com per√≠odos arbitr√°rios em um temporizador de hardware com um toque no pulso). <br><br>  A mesma abordagem √© transferida para os controladores STM32L0 e STM32L4, todos os modelos com o registro RTC_SSR;  isso elimina a necessidade de temporizadores LPTIM e unifica o c√≥digo para diferentes plataformas. <br><br><h3>  Como entender que um mult√≠metro est√° mentindo </h3><br>  Certamente, depois de todas as otimiza√ß√µes, surge a pergunta leg√≠tima: o que, de fato, conseguimos?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem saber a resposta, √© poss√≠vel limitar-se completamente a um WFE com sinalizadores configurados corretamente, dormir e obter seus 200-500 ŒºA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais tradicional de medir corrente √©, obviamente, um mult√≠metro. Entender que ele est√° deitado sobre uma carga como um microcontrolador com seu consumo din√¢mico √© muito simples - se estiver ligado, est√° mentindo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso, no entanto, n√£o significa que o mult√≠metro seja in√∫til nessa quest√£o. Voc√™ s√≥ precisa poder aplic√°-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiramente, um mult√≠metro √© uma coisa muito lenta, um tempo t√≠pico para uma contagem √© uma segunda escala, um tempo t√≠pico para alterar o estado de um microcontrolador √© uma escala de microssegundos. Em um sistema que altera seu consumo nesse ritmo, o mult√≠metro simplesmente mostra valores aleat√≥rios.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, uma das vari√°veis ‚Äã‚Äãn√£o aleat√≥rias de interesse para n√≥s √© o consumo do microcontrolador no modo de suspens√£o; se exceder significativamente o valor estimado em folhas de dados, ent√£o algo est√° claramente errado. Este √© o consumo de um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema est√°tico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou seja, pode ser medido com um mult√≠metro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo mais trivial mostrado na foto-t√≠tulo √© um mult√≠metro no modo microamper√≠metro, que agora est√° na maioria dos modelos de gama m√©dia e possui boa precis√£o e excelente resolu√ß√£o. O UT120C possui uma resolu√ß√£o de 0,1 ŒºA com uma precis√£o certificada de ¬± 1% ¬± 3 descargas, o que √© suficiente para n√≥s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe apenas um problema nesse modo - os mult√≠metros possuem uma resist√™ncia em s√©rie grande, uma escala de centenas de ohms; portanto, no modo normal, um microcontrolador com esse mult√≠metro no circuito de pot√™ncia simplesmente n√£o inicia. Felizmente, as posi√ß√µes de "mA" e "uA" em quase todos os instrumentos da balan√ßa est√£o pr√≥ximas, os soquetes para medi√ß√£o em ambos os intervalos s√£o os mesmos, para que voc√™ possa iniciar com seguran√ßa o controlador no limite de "mA" e, quando dormir, clique em "uA "- isso acontece r√°pido o suficiente para que o controlador n√£o tenha tempo para perder energia e reiniciar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que, se o controlador apresentar picos de atividade, esse m√©todo n√£o ser√° aplic√°vel. Por exemplo, o timer do watchdog √© redefinido a cada 15 segundos no firmware do dispositivo - nesses momentos, o mult√≠metro consegue mostrar algo na regi√£o de 27 ŒºA, o que, obviamente, n√£o tem nada a ver com o clima em Marte. Se algo arbitrariamente curto ocorrer no seu sistema com mais frequ√™ncia do que uma vez a cada 5 a 10 segundos, o mult√≠metro simplesmente estar√° mentindo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra maneira de medir a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est√°tica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Estou destacando diretamente essa palavra) o consumo de um mult√≠metro √© uma medida da queda em uma deriva√ß√£o externa. Se voc√™ deseja medir correntes ultra-pequenas na escala de algumas dezenas de microamperes, precisar√° colocar uma deriva√ß√£o grande (por exemplo, 1 kOhm) e paralelamente a ela - um diodo Schottky em conex√£o direta. Se o shunt cair mais de 0,3 V, o diodo abrir√° e limitar√° a queda de tens√£o, e at√© 0,3 V voc√™ poder√° medir com seguran√ßa a queda com um mult√≠metro na faixa de milivolts, 1 mV = 1 ŒºA. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, n√£o funcionar√° para medir uma queda em um desvio de baixa imped√¢ncia com um mult√≠metro t√≠pico - dispositivos de classe m√©dia, mesmo que mostrem algo abaixo de 100 ŒºV, s√£o infelizes nesta faixa. Se voc√™ possui um bom dispositivo de mesa que pode mostrar 1 uV, n√£o precisa mais do meu conselho.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, as est√°ticas s√£o boas, mas e a din√¢mica? </font><font style="vertical-align: inherit;">Como avaliar o mesmo efeito de diferentes frequ√™ncias no consumo m√©dio de energia? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tudo √© complicado aqui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos anotar os requisitos b√°sicos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> faixa de corrente de pelo menos 1 ŒºA - 100 mA (10 ^ 5) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> per√≠odo de medi√ß√£o n√£o superior a 10 Œºs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> queda de tens√£o n√£o superior a 100 mV </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dura√ß√£o da medi√ß√£o - ilimitada </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se simplesmente traduzirmos isso diretamente em n√∫meros, obteremos um ADC relativamente r√°pido e n√£o inferior a 18 bits com um vi√©s de entrada inferior a 30 ŒºV, um front end anal√≥gico capaz de medir tens√µes de 1 ŒºV e uma interface r√°pida para o computador que nos permitir√° transferir tudo isso e salve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E tudo isso para um √∫nico uso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ v√™, sim, por que essas coisas n√£o est√£o em cada canto de dez d√≥lares? O Keysight N6705C na primeira aproxima√ß√£o atende aos nossos requisitos, apenas custa US $ 7960.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nas solu√ß√µes de or√ßamento, por exemplo, o SiLabs integra a medi√ß√£o atual em seus depura√ß√µes - as caracter√≠sticas do sistema Advanced Energy Monitoring (AEM) dependem do modelo de depura√ß√£o espec√≠fico e t√™m o maior problema com a velocidade da medi√ß√£o. Nos antigos "kits de inicia√ß√£o", o STK3300 / 3400 √© de apenas 100 Hz, nos mais recentes debuga o STK3700 / 3800 (facilmente reconhec√≠vel pelo textolite preto) - 6,25 kHz, e em modelos mais antigos da s√©rie DK debuga, pode atingir at√© 10 kHz, mas tamb√©m custa eles j√° s√£o $ 300 +. Para tarefas s√©rias, a SiLabs recomenda oficialmente o mencionado Keysight.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em princ√≠pio, esse dispositivo pode ser projetado por voc√™ mesmo - primeiro, voc√™ precisa de amplificadores operacionais muito bons com vi√©s m√≠nimo de entrada, como o OPA2335. Esses amplificadores operacionais s√£o colocados no mesmo shunt de 2 a 3 pe√ßas com diferentes fatores de amplifica√ß√£o, todos eles s√£o enrolados em entradas ADC diferentes (com essa abordagem √© bem poss√≠vel usar o microcontrolador embutido), ent√£o, a cada aquisi√ß√£o de dados, √© determinado programaticamente qual dos amplificadores operacionais em um determinado o momento n√£o est√° sobrecarregado, as leituras s√£o contadas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema da velocidade de transfer√™ncia de dados para um computador √© resolvido de maneira simples - uma vez que, para fins pr√°ticos, estamos interessados ‚Äã‚Äãprincipalmente no consumo m√©dio do sistema na vida real, as leituras de microssegundos podem ser coletadas no microcontrolador integrado do medidor e a m√©dia aritm√©tica de uma escala razo√°vel de milissegundos pode ser enviada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, como mostra a pr√°tica, √© muito √∫til ter um medidor de registro, embora simples e pouco preciso, mas sempre √† m√£o - para n√£o ser surpreendido com algum tipo de altera√ß√£o de firmware interrompida pela economia de energia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, incorporamos um em nosso adaptador USB padr√£o UMDK-RF, que √© constantemente usado na depura√ß√£o de firmware - ele j√° possui um programador SWD com suporte para o protocolo DAPLink, uma ponte USB-UART e l√≥gica de gerenciamento de energia, respectivamente, e possui um medidor de consumo quase de gra√ßa. O medidor em si √© um shunt de 1 Ohm e um amplificador INA213 (ganho de 50 vezes, deslocamento de zero t√≠pico de 5 ŒºV): O </font></font><br><br><img src="https://habrastorage.org/webt/me/l_/dr/mel_drvu6rqzwr1bebtbtayfiiw.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amplificador √© conectado diretamente √† entrada do ADC do microcontrolador (STM32F042F6P6), o ADC processa com um per√≠odo de 10 Œºs usando um temporizador de hardware e via USB os dados m√©dios s√£o emitidos por um intervalo de 100 ms. Como resultado, alterando algo na l√≥gica do firmware, voc√™ pode simplesmente fumar ou tomar um caf√©, deixar o dispositivo em cima da mesa e, retornando, observe uma programa√ß√£o como esta:</font></font><br><br><img src="https://habrastorage.org/webt/qp/e2/h1/qpe2h1zrmci58iozay_rmag-lsm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, a precis√£o de um dispositivo "livre" n√£o √© alta - com um ADC de 12 bits e um amplificador, o quantum m√≠nimo √© de 16 ŒºA, mas √© extremamente √∫til para avaliar r√°pida e regularmente o comportamento de dispositivos depurados do ponto de vista do consumo de energia. No final, se voc√™ fizer algo errado no firmware ou no dispositivo, com uma garantia muito alta, poder√° sair de unidades de microamperes pelo menos centenas, e isso ser√° claramente vis√≠vel. </font></font><br><br><img src="https://habrastorage.org/webt/np/kb/ko/npkbkoxcwb3xsmoyshtkjtc3-jq.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro b√¥nus interessante √© que, como os dados s√£o enviados para a porta COM virtual em forma de texto (valores em microamperes), voc√™ pode posicionar a janela do terminal ao lado da janela que mostra o console do dispositivo e observar o consumo de energia ao mesmo tempo em que as mensagens de depura√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu me gabo disso por um motivo, mas para oferecer a todos que desejam usar esse programador de depurador m√≠nimo (e muito barato!) Em seus pr√≥prios projetos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desenhar o diagrama </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">aqui</font></a><font style="vertical-align: inherit;"> ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonte no DipTrace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), arrastar o firmware </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (brunch umdk-rf, ao criar o destino √© UMDK-RF, com base no projeto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dap42</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). O diagrama √© confuso, mas espero que os pontos principais sejam claros, o firmware seja escrito em C usando o libopencm3 e seja montado com o usual arm-none-eabi-gcc. Como fun√ß√µes adicionais, o firmware possui gerenciamento de energia, captando sinais de sobrecarga das teclas de controle e inserindo o controlador conectado ao seu carregador de inicializa√ß√£o nativo com um longo toque em um bot√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: se voc√™ deseja que o bot√£o de inicializa√ß√£o traga regularmente o controlador do programador para o carregador de inicializa√ß√£o, ele deve ter a polaridade da conex√£o alterada, a op√ß√£o de edi√ß√£o de bytes do controlador na primeira inicializa√ß√£o e a entrada do programa no carregador de inicializa√ß√£o removida e a polaridade de interrup√ß√£o para regular fun√ß√µes deste bot√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode ver como a corrente √© medida em um par de amplificadores operacionais com diferentes fatores de ganho (por exemplo, para melhorar o depurador descrito acima para suas tarefas), </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (p√°gina 9), uma op√ß√£o alternativa mais tradicional - com um amplificador operacional e um ADC de 24 bits caro - A </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TI possui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (EnergyTrace na p√°gina 5).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Observe que durante a depura√ß√£o com um UART ou JTAG / SWD conectado, uma pequena corrente tamb√©m pode vazar pelas pernas, o que n√£o acontecer√° durante a opera√ß√£o real do dispositivo. </font><font style="vertical-align: inherit;">Portanto, no UMDK-RF, cerca de 15 ŒºA vazam no SWD (e, portanto, na foto do cabe√ßalho, medi√ß√µes com um mult√≠metro s√£o feitas na vers√£o antiga da placa, sem SWD), e no STM32 Nucleo houve casos com fluxo esp√∫rio no SWD de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cerca de 200 ŒºA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">As placas de depura√ß√£o usadas para medi√ß√£o devem ser verificadas quanto a esses recursos - desconectando suas linhas de interface, se houver essa possibilidade, ou comparando os resultados com o consumo do dispositivo medido sem a instala√ß√£o para depura√ß√£o, por exemplo, com um mult√≠metro no modo est√°tico.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em vez de uma conclus√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Espero que voc√™ j√° tenha entendido o erro que cometeu ao escolher a programa√ß√£o de microcontroladores como sua principal especialidade. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430218/">https://habr.com/ru/post/pt430218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430206/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 18: Navega√ß√£o Privada na Internet, Parte 2</a></li>
<li><a href="../pt430208/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 18: ‚ÄúNavega√ß√£o Privada na Internet‚Äù, parte 3</a></li>
<li><a href="../pt430210/index.html">Teste minha paci√™ncia pela Academia de Seguran√ßa Check Point</a></li>
<li><a href="../pt430212/index.html">OpenSceneGraph: No√ß√µes b√°sicas de geometria de cena</a></li>
<li><a href="../pt430216/index.html">Pelo que entendi, como muitos doces ou a classifica√ß√£o de mercadorias, verificando o aplicativo</a></li>
<li><a href="../pt430220/index.html">Como transformar um hub USB ‚Äúcenten√°rio‚Äù em um gerenciado de forma inteligente e economizar US $ 300</a></li>
<li><a href="../pt430222/index.html">Engenheiro S√™nior em busca de trabalho. Como passei por 20 entrevistas com RH e o que penso sobre isso</a></li>
<li><a href="../pt430224/index.html">Transtorno esquizot√≠pico: um olhar por dentro</a></li>
<li><a href="../pt430226/index.html">Da var b √† entrevista</a></li>
<li><a href="../pt430228/index.html">Marcas em forma de X como m√©todo de identifica√ß√£o de radar usando an√°lise de dados abertos de dois sat√©lites cient√≠ficos SENTINEL-1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>