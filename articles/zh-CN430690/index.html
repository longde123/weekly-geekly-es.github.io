<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏼 👨🏽‍🎓 💩 “未来的C ++”中的确定性异常和错误处理 🥇 👌🏿 🕕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="奇怪的是，在Habrt上却没有提及C ++标准的一个叫“零开销确定性异常”的提议。 纠正这一烦人的遗漏。 


 如果您担心异常的开销，或者您不得不在没有异常支持的情况下编译代码，或者只是想知道C ++ 2b中的错误处理会发生什么（参考最近的一篇文章 ），我请猫。 您正在等待从该主题上现在可以找到的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>“未来的C ++”中的确定性异常和错误处理</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430690/"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> 奇怪的是，在Habrt上却没有提及C ++标准的一个叫“零开销确定性异常”的提议。 纠正这一烦人的遗漏。 </p><br><p> 如果您担心异常的开销，或者您不得不在没有异常支持的情况下编译代码，或者只是想知道C ++ 2b中的错误处理会发生什么（参考<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最近的</a>一篇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ），我请猫。 您正在等待从该主题上现在可以找到的所有内容以及几次民意测验中被挤出来。 </p><a name="habracut"></a><br><p> 下面的讨论不仅会涉及静态异常，还将讨论与标准有关的建议，以及有关处理错误的各种其他方式。 如果您去这里查看语法，那么这里是： </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p> 如果特定类型的错误不重要/未知，则可以简单地使用<code>throws</code> and <code>catch (std::error e)</code> 。 </p><br><h2 id="polezno-znat"> 很高兴知道 </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code>和<code>std::expected</code> </h3><br><p> 让我们确定该函数中可能发生的错误不够严重，无法对其引发异常。 传统上，使用out参数返回错误信息。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件系统TS</a>提供了许多类似的功能： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  （由于找不到该文件而不会引发异常吗？）但是，错误代码的处理很麻烦并且容易出错。 错误代码很容易忘记检查。 现代代码样式<a href="">禁止</a>使用输出参数；相反，建议返回包含整个结果的结构。 </p><br><p> 一段时间以来，Boost一直提供一种优雅的解决方案来处理此类“非致命”错误，在某些情况下，正确的程序中可能会发生数百种错误： </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  <code>expected</code>类型与<code>variant</code>类似，但是它提供了一个方便的界面来处理“结果”和“错误”。 默认情况下， <code>expected</code>结果存储在<code>expected</code> 。  <code>file_size</code>实现可能看起来像这样： </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p> 如果错误的原因对我们而言不重要，或者错误可能仅包含结果的“缺失”，则可以使用<code>optional</code> ： </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p> 在Boost的C ++ 17中，std是<code>optional&lt;T&amp;&gt;</code> （不支持<code>optional&lt;T&amp;&gt;</code> ）； 在C ++ 20中，它们可能会添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">预期的内容</a> （这只是建议，感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">RamzesXI</a>的更正）。 </p><br><h3 id="contracts"> 合约 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">契约</a> （不要与概念混淆）是在C ++ 20中添加的对函数参数施加限制的新方法。 添加了3个注释： </p><br><ul><li>  <strong>期望</strong>检查功能参数 </li><li>  <strong>确保</strong>检查函数的返回值（将其作为参数） </li><li>  <strong>断言</strong> -宏断言的文明替代 </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p> 您可以配置违约： </p><br><ul><li> 称为未定义行为，或 </li><li> 它检查并调用了用户出口，此后<code>std::terminate</code> </li></ul><br><p> 违反合同后就无法继续运行程序，因为编译器会使用合同保证来优化功能代码。 如果丝毫怀疑是否会履行合同，则值得增加一张额外支票。 </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  C ++ 11中添加的<code>&lt;system_error&gt;</code>库使您可以标准化程序中错误代码的处理。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">std :: error_code</a>由类型为<code>int</code>的错误代码和指向某些后代<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类std :: error_category</a>的对象的指针<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">组成</a> 。 实际上，此对象充当虚拟函数表的角色，并确定给定<code>std::error_code</code>的行为。 </p><br><p> 要创建<code>std::error_code</code> ，必须定义<code>std::error_category</code>子代<code>std::error_category</code>并实现虚拟方法，其中最重要的是： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p> 您还必须为<code>std::error_category</code>创建一个全局变量。 使用error_code +预期的错误处理看起来像这样： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p> 重要的是在<code>std::error_code</code>值0表示没有错误。 如果您的错误代码不是这种情况，那么在将系统错误代码转换为<code>std::error_code</code> ，必须将代码0替换为SUCCESS，反之亦然。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">errc</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">system_category</a>中描述了所有系统错误代码。 如果在某个阶段手动转发错误代码变得太乏味，那么您始终可以将错误代码包装在<code>std::system_error</code>并丢弃。 </p><br><h3 id="destructive-move--trivially-relocatable"> 破坏性举动/微不足道的可重定位 </h3><br><p> 让您需要创建拥有一些资源的另一类对象。 最有可能的是，您将使其不可复制但可移动，因为使用不可移动的对象很不方便（在C ++ 17之前它们无法从函数返回）。 </p><br><p> 但这是麻烦所在：无论如何，都需要删除移动的对象。 因此，“移出”的特殊状态是必需的，即，不删除任何内容的“空”对象。 事实证明，每个C ++类都必须具有一个空状态，也就是说，从构造函数到析构函数，不可能创建一个具有正确性（保证）正确性的类。 例如，不可能为整个生命周期中打开的文件创建正确的<code>open_file</code>类。 在积极使用RAII的几种语言中观察到这一点很奇怪。 </p><br><p> 另一个问题是移动时将旧对象归零会增加开销：填充<code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code>速度可能比<code>std::vector&lt;T*&gt;</code>慢2倍，因为移动时将旧指针归零，然后移除假人。 </p><br><p>  C ++开发人员长期以来一直对Rust情有独钟，Rust不会在重定位的对象上调用析构函数。 此功能称为破坏性移动。 不幸的是，提议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">琐碎可重定位</a>没有提供将其添加到C ++中的功能。 但是开销的问题将得到解决。 </p><br><p> 如果执行以下两项操作，则一个类被视为可重定位：移动和删除旧对象等效于从旧对象到新对象的memcpy。 旧对象并未删除，作者称其为“放在地板上”。 </p><br><p> 如果满足以下（递归）条件之一，则从编译器的角度来看，一个类型可重定位： </p><br><ol><li> 它可微动+可微毁（例如<code>int</code>或POD结构） </li><li> 这是标记有<code>[[trivially_relocatable]]</code>属性的类<code>[[trivially_relocatable]]</code> </li><li> 这是一个所有成员都可轻松重定位的类。 </li></ol><br><p> 您可以将此信息与<code>std::uninitialized_relocate</code> ，该命令以通常的方式执行move init + delete，或者在可能的情况下进行加速。 建议将标准库的大多数类型标记为<code>[[trivially_relocatable]]</code> ，包括<code>std::string</code> ， <code>std::vector</code> ， <code>std::unique_ptr</code> 。 考虑到这一点的开销<code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code>提案将消失。 </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas"> 现在异常有什么问题？ </h2><br><p>  C ++异常机制于1992年开发。 已经提出了各种实施方案。 其中，选择了一个例外表机制，以保证程序执行主路径没有开销。 因为从它们创建的那一刻起，就假定<em>应该很少抛出异常</em> 。 </p><br><p> 动态（即常规）异常的缺点： </p><br><ol><li> 在引发异常的情况下，开销平均约为10,000-100,000个CPU周期，在最坏的情况下，开销可以达到毫秒级 </li><li> 二进制文件大小增加15-38％ </li><li> 与C编程接口不兼容 </li><li> 隐式异常抛出支持除<code>noexcept</code>外的所有函数。 几乎可以在程序中的任何地方引发异常，即使函数作者不希望看到该异常 </li></ol><br><p> 由于这些缺点，例外的范围受到很大限制。 当例外无法适用时： </p><br><ol><li> 确定性很重要的地方，也就是说，有时“代码”的工作速度比平时慢10、100、1000倍是不可接受的 </li><li> 例如，当ABI不支持它们时 </li><li> 当大部分代码用C编写时 </li><li> 在拥有大量遗留代码的公司中（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google样式指南</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qt</a> ）。 如果代码中至少有一个非异常安全的函数，那么根据卑鄙的规律，迟早会在该异常中抛出一个异常并创建一个错误 </li><li> 在公司中聘请对异常安全一无所知的程序员 </li></ol><br><p> 根据调查，在52％（！）开发人员的工作场所中，公司规则禁止例外。 </p><br><p> 但是异常是C ++不可或缺的一部分！ 通过包含<code>-fno-exceptions</code>标志，开发人员将失去使用标准库很大一部分的能力。 这进一步刺激了公司建立自己的“标准库”，并且，是的，发明了自己的字符串类。 </p><br><p> 但这还不是终点。 异常是取消在构造函数中创建对象并引发错误的唯一标准方法。 当它们关闭时，会出现类似两阶段初始化的可憎行为。 操作员也不能使用错误代码，因此它们被诸如<code>assign</code>功能所取代。 </p><br><h2 id="proposal-isklyucheniya-buduschego"> 提案：未来的例外 </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy"> 新的异常转移机制 </h3><br><p>  P709中的Herb Sutter描述了一种新的异常传输机制。 原则上，该函数返回<code>std::expected</code> ，但是，不是单独的<code>bool</code>类型的标识符（与对齐方式一起使用，它将在堆栈中占用多达8个字节），而是以更快的方式将这部分信息传输给例如Carry Flag。 </p><br><p> 不涉及CF的函数（大多数函数）将有机会免费使用静态异常-在正常返回的情况下以及在引发异常的情况下！ 强制保存和恢复它的函数将获得最小的开销，并且仍然比<code>std::expected</code>和任何普通错误代码要快。 </p><br><p> 静态异常如下所示： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p> 在备用版本中，建议在与<code>throws</code>函数调用相同的表达式中使用<code>try</code>关键字： <code>try i + safe_divide(j, k)</code> 。 这样可以将在<code>throws</code>情况下不安全的代码中使用<code>throws</code>函数的情况减少到几乎为零。 无论如何，与动态异常不同，IDE能够以某种方式突出显示引发异常的表达式。 </p><br><p> 抛出的异常没有单独存储，而是直接放置在返回值的位置，这一事实对异常的类型施加了限制。 首先，它必须微不足道。 其次，其大小不应太大（但可以像<code>std::unique_ptr</code> ），否则所有函数将在堆栈上保留更多空间。 </p><br><h3 id="status_code">  status_code </h3><br><p> 由Niall Douglas开发的<code>&lt;system_error2&gt;</code>库将包含<code>status_code&lt;T&gt;</code> -“更好的新功能” <code>error_code</code> 。 与<code>error_code</code>的主要区别： </p><br><ol><li>  <code>status_code</code>一种模板类型，可用于存储几乎所有可能的错误代码（以及指向<code>status_code_category</code>的指针），而无需使用静态异常 </li><li>  <code>T</code>应该是可重定位和可复制的（后者，恕我直言，不应是强制性的）。 复制和删除时，从<code>status_code_category</code>调用虚拟函数 </li><li>  <code>status_code</code>不仅可以存储错误数据，还可以存储有关成功完成操作的其他信息 </li><li>  “虚拟”函数<code>code.message()</code>不返回<code>std::string</code> ，但<code>string_ref</code>是<code>std::string</code>一种相当繁重的类型，它是虚拟的“可能拥有” <code>std::string_view</code> 。 在那里，您可以<code>string_view</code>或<code>string</code> ，或<code>std::shared_ptr&lt;string&gt;</code> ，或其他拥有字符串的疯狂方式。  Niall声称<code>#include &lt;string&gt;</code>会使标头<code>&lt;system_error2&gt;</code>变得“沉重” </li></ol><br><p> 接下来，输入<code>errored_status_code&lt;T&gt;</code> -使用以下构造函数对<code>status_code&lt;T&gt;</code>进行包装： </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error"> 错误 </h3><br><p> 默认的异常类型（不带类型的<code>throws</code> ）以及所有其他类型的基本异常类型（例如<code>std::exception</code> ）为<code>error</code> 。 定义如下： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p> 也就是说， <code>error</code>就是这样的“错误” <code>status_code</code> ，其中值（ <code>value</code> ）放在1个指针中。 由于<code>status_code_category</code>机制可确保正确删除，移动和复制，因此从理论上讲，任何数据结构都可以<code>error</code>保存。 实际上，这将是以下选项之一： </p><br><ol><li> 整数（int） </li><li>  <code>std::exception_handle</code> ，即指向抛出动态异常的指针 </li><li>  <code>status_code_ptr</code> ，即对任意<code>status_code&lt;T&gt;</code> <code>unique_ptr</code> 。 </li></ol><br><p> 问题在于，案例3并未计划给将<code>error</code>带回到<code>status_code&lt;T&gt;</code>的机会。 您唯一可以做的就是获取打包的<code>status_code&lt;T&gt;</code> <code>message()</code> 。 为了能够将返回的值包装回<code>error</code> ，请将其作为动态异常（！）抛出，然后捕获并包装在<code>error</code> 。 通常，Niall认为，只有错误代码和字符串消息应该存储在<code>error</code> ，这对于任何程序来说都是足够的。 </p><br><p> 为了区分不同类型的错误，建议使用“虚拟”比较运算符： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p> 使用多个catch块或<code>dynamic_cast</code>选择异常类型将失败！ </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami"> 与动态异常的交互 </h3><br><p> 一个功能可能具有下列规格之一： </p><br><ul><li>  <code>noexcept</code> ：不抛出异常 </li><li>  <code>throws(E)</code> ：仅引发静态异常 </li><li>  （无）：仅引发动态异常 </li></ul><br><p>  <code>throws</code>意味着没有<code>noexcept</code> 。 如果从“静态”函数引发了动态异常，则将其包装在<code>error</code> 。 如果从“动态”函数引发了静态异常，则将其包装在<code>status_error</code>异常中。 一个例子： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  C中的异常？！ </h3><br><p> 该提议为将来的C标准之一提供了例外，并且这些例外将与C ++静态例外具有ABI兼容性。 尽管可以使用宏删除冗余，但用户必须独立声明类似于<code>std::expected&lt;T, U&gt;</code>的结构。 语法包括（为简单起见，我们假设）关键字fail，failure，catch。 </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p> 同时，在C ++中，也有可能从C调用<code>fails</code>函数，并在<code>extern C</code>块中声明它们。 因此，在C ++中，将有大量用于处理异常的关键字： </p><br><ul><li>  <code>throw()</code> -在C ++ 20中删除 </li><li>  <code>noexcept</code>函数说明符，该函数不会引发动态异常 </li><li>  <code>noexcept(expression)</code> -函数说明符，该函数不会抛出提供的动态异常 </li><li>  <code>noexcept(expression)</code> - <code>noexcept(expression)</code>是否引发动态异常？ </li><li>  <code>throws(E)</code> -函数说明符，该函数引发静态异常 </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> -从C导入的函数引发静态异常 </li></ul><br><p> 因此，在C ++中，他们引入（或更确切地说，交付了）大量用于错误处理的新工具。 接下来，出现一个逻辑问题： </p><br><h2 id="kogda-chto-ispolzovat"> 什么时候使用什么？ </h2><br><h3 id="napravlenie-v-celom"> 一般方向 </h3><br><p> 错误分为几个级别： </p><br><ul><li> 程序员错误。 使用合同进行处理。 它们导致了日志的收集并根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速失败</a>的概念终止了程序。 示例：空指针（当此无效时）； 除以零； 程序员未预见到的内存分配错误。 </li><li> 程序员提供的致命错误。 与正常的函数返回相比，抛出该异常的频率要少一百万倍，这使使用动态异常为它们辩解。 通常，在这种情况下，您需要重新启动程序的整个子系统或在执行操作时给出错误。 示例：突然失去与数据库的连接； 程序员提供的内存分配错误。 </li><li> 当<em>某些事情</em>阻止该函数完成其任务，但调用函数可能知道如何处理时<em>，将</em>导致可恢复的错误。 由静态异常处理。 示例：使用文件系统； 其他输入/输出（IO）错误； 用户数据不正确  <code>vector::at()</code> 。 </li><li> 该函数成功完成了任务，尽管结果出乎意料。  <code>std::optional</code> ， <code>std::expected</code> ， <code>std::variant</code> 。 示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>map::insert</code></a> 。 </li></ul><br><p> 在标准库中，完全放弃使用动态异常以使编译“无异常”合法是最可靠的。 </p><br><h3 id="errno"> 埃尔诺 </h3><br><p> 使用<code>errno</code>快速轻松地处理C和C ++错误代码的函数应分别替换为<code>throws(std::errc)</code> <code>fails(int)</code>和<code>throws(std::errc)</code> 。 在一段时间内，标准库功能的新旧版本将共存，然后旧版本将被宣布作废。 </p><br><h3 id="out-of-memory"> 内存不足 </h3><br><p> 内存分配错误由<code>new_handler</code>全局挂钩处理，该挂钩可以： </p><br><ol><li> 消除内存不足并继续执行 </li><li> 引发异常 </li><li> 崩溃程序 </li></ol><br><p> 现在默认情况下<code>std::bad_alloc</code>抛出<code>std::bad_alloc</code> 。 建议默认调用<code>std::terminate()</code> 。 如果您需要旧的行为，请将处理程序替换为<code>main()</code>开头所需的处理程序。 </p><br><p> 标准库的所有现有功能将变为<code>noexcept</code>并在<code>std::bad_alloc</code>时使程序崩溃。 同时，将添加新的API，例如<code>vector::try_push_back</code> ，这会导致内存分配错误。 </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p> 异常<code>std::logic_error</code> <code>std::domain_error</code> ， <code>std::logic_error</code> ， <code>std::domain_error</code> <code>std::invalid_argument</code> ， <code>std::length_error</code> ， <code>std::future_error</code> ， <code>std::future_error</code>报告违反了函数前提条件。 新的错误模型应改为使用合同。 列出的异常类型<strong>不会</strong>被弃用，但是在标准库中使用它们的几乎所有情况都将由<code>[[expects: …]]</code>代替。 </p><br><h2 id="tekuschee-sostoyanie-proposal"> 目前的提案状态 </h2><br><p> 提案现在处于草稿状态。 它已经发生了很大的变化，并且仍然可以发生很多变化。 某些开发没有成功发布，因此建议的API <code>&lt;system_error2&gt;</code>并不完全相关。 </p><br><p> 该提案在3个文档中进行了描述： </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P709-</a>萨特徽章的原始文件 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1095</a> -Niall Douglas Vision中确定的异常，已更改了一些时刻，增加了C语言兼容性 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1028-</a>来自<code>std::error</code>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">测试实现的</a> API </li></ol><br><p> 当前没有支持静态异常的编译器。 因此，尚无法确定其基准。 </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430690/">https://habr.com/ru/post/zh-CN430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430680/index.html">为此编写一个简单的处理器和环境</a></li>
<li><a href="../zh-CN430682/index.html">月球微卫星项目的三年：成长阶段</a></li>
<li><a href="../zh-CN430684/index.html">扫描实时以太坊合约以查看未检查的发送错误。 第二部分</a></li>
<li><a href="../zh-CN430686/index.html">概述：WAZER的第一台水刀切割机</a></li>
<li><a href="../zh-CN430688/index.html">通过动画QR将数据传输到Gomobile和GopherJS</a></li>
<li><a href="../zh-CN430692/index.html">通用Windows平台（APPX）软件进行的社会工程</a></li>
<li><a href="../zh-CN430694/index.html">学习C ++的简短指南：创建内容，时间和内容的方法</a></li>
<li><a href="../zh-CN430700/index.html">一个用于记录在线电影观看次数的统一系统将在俄罗斯开始工作</a></li>
<li><a href="../zh-CN430702/index.html">非常奇怪的训练</a></li>
<li><a href="../zh-CN430704/index.html">人工智能技术如何帮助Aviasales成长：七个例子</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>