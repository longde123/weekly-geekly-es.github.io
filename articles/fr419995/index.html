<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚕 🤷🏾 ☑️ Une étude d'Ivy, le nouveau compilateur angulaire 🆕 🧑‍🤝‍🧑 🍩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="« Je pense que les compilateurs sont très intéressants », explique Uri Shaked, l'auteur du document que nous publions aujourd'hui. L'année dernière, i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une étude d'Ivy, le nouveau compilateur angulaire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419995/">  « <i>Je pense que les compilateurs sont très intéressants</i> », explique Uri Shaked, l'auteur du document que nous publions aujourd'hui.  L'année dernière, il a écrit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article</a> qui parlait d'ingénierie inverse du compilateur angulaire et de simulation de certaines étapes du processus de compilation, ce qui aide à comprendre les caractéristiques de la structure interne de ce mécanisme.  Il convient de noter qu'en général, ce que l'auteur de ce document parle de «compilateur» est appelé «moteur de rendu». <br><br>  Quand Uri a appris qu'une nouvelle version du compilateur Angular, appelée Ivy, était sortie, il a immédiatement voulu regarder de plus près et découvrir ce qui avait changé en lui par rapport à l'ancienne version.  Ici, comme auparavant, le compilateur reçoit les modèles et les composants créés par Angular, qui sont convertis en code HTML et JavaScript standard compréhensible pour Chrome et d'autres navigateurs. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/6o/ha/fa/6ohafariunj4046cd6nokfypam0.jpeg"></a> <br><br>  Si vous comparez la nouvelle version du compilateur avec la précédente, il s'avère qu'Ivy utilise l'algorithme de tremblement d'arbre.  Cela signifie que le compilateur supprime automatiquement les fragments de code inutilisés (cela s'applique également au code angulaire), ce qui réduit la taille des ensembles de projets.  Une autre amélioration concerne le fait que désormais chaque fichier est compilé indépendamment, ce qui réduit le temps de recompilation.  En résumé, grâce au nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">compilateur,</a> nous obtenons des assemblages plus petits, une recompilation accélérée des projets, un code prêt à l'emploi plus simple. <br><br>  Comprendre le fonctionnement du compilateur est intéressant en soi (du moins l'auteur du matériel l'espère), mais il permet également de mieux comprendre les mécanismes internes d'Angular.  Cela conduit à l'amélioration des compétences de "pensée angulaire", ce qui, à son tour, vous permet d'utiliser plus efficacement ce cadre pour le développement Web. <br><br>  Au fait, savez-vous pourquoi le nouveau compilateur a été nommé Ivy?  Le fait est que ce mot ressemble à une combinaison de lettres «IV», lues à haute voix, qui représente le chiffre 4, écrit en chiffres romains.  «4» est la quatrième génération de compilateurs angulaires. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Application Ivy</font> </h2><br>  Le lierre est toujours en cours de développement intensif, ce processus peut être observé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Bien que le compilateur lui-même ne soit pas encore adapté à une utilisation en combat, l'abstraction de RendererV3, qu'il utilisera, est déjà assez fonctionnelle et est livrée avec Angular 6.x. <br><br>  Bien qu'Ivy ne soit pas encore tout à fait prêt, nous pouvons toujours jeter un coup d'œil aux résultats de son travail.  Comment faire  En créant un nouveau projet Angular: <br><br><pre><code class="hljs cs">ng <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ivy-internals</code> </pre> <br>  Après cela, vous devez activer Ivy en ajoutant les lignes suivantes au fichier <code>tsconfig.json</code> situé dans le nouveau dossier de projet: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"angularCompilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enableIvy"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  Et enfin, nous démarrons le compilateur en exécutant la commande <code>ngc</code> dans le dossier de projet nouvellement créé: <br><br><pre> <code class="hljs">node_modules/.bin/ngc</code> </pre> <br>  C’est tout.  Vous pouvez maintenant examiner le code généré situé dans le <code>dist/out-tsc</code> .  Par exemple, jetez un œil au fragment suivant du modèle <code>AppComponent</code> : <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"…"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Voici quelques liens pour vous aider à démarrer:</font> </h2><br>  Le code généré pour ce modèle peut être trouvé en consultant le <code>dist/out-tsc/src/app/app.component.js</code> : <br><br><pre> <code class="hljs smalltalk">i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">"div"</span></span>, _c0); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h1"</span></span>); i0.ɵ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); i0.ɵe(); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-comment"><span class="hljs-comment">"img"</span></span>, _c1); i0.ɵe(); i0.ɵe(); i0.ɵ<span class="hljs-type"><span class="hljs-type">E</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-comment"><span class="hljs-comment">"h2"</span></span>); i0.ɵ<span class="hljs-type"><span class="hljs-type">T</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-comment"><span class="hljs-comment">"Here are some links to help you start: "</span></span>); i0.ɵe();</code> </pre> <br>  C'est dans ce type de code JavaScript qu'Ivy transforme le modèle de composant.  Voici comment la même chose a été faite dans la version précédente du compilateur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/d3a/278/1f4d3a278708237e5558f313b316e780.png"></div><br>  <i><font color="#999999">Code produit par une version précédente du compilateur Angular</font></i> <br><br>  On a le sentiment que le code généré par Ivy est beaucoup plus simple.  Vous pouvez expérimenter avec le modèle de composant (il se trouve dans <code>src/app/app.component.html</code> ), le recompiler et voir comment les modifications qui y sont apportées affecteront le code généré. <br><br><h2>  <font color="#3AC1EF">Analyser le code généré</font> </h2><br>  Essayons d'analyser le code généré et de voir exactement quelles actions il effectue.  Par exemple, recherchons une réponse à une question sur la signification d'appels comme <code>i0.ɵE</code> et <code>i0.ɵT</code> <br><br>  Si vous regardez au début du fichier généré, nous trouverons l'expression suivante: <br><br><pre> <code class="hljs perl">var i<span class="hljs-number"><span class="hljs-number">0</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"@angular/core"</span></span>);</code> </pre> <br>  Donc <code>i0</code> n'est que le module de base Angular, et toutes ces fonctions sont exportées par Angular.  La lettre <code>ɵ</code> utilisée par l'équipe de développement Angular pour indiquer que certaines méthodes sont uniquement destinées à fournir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des mécanismes de</a> cadre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interne</a> , c'est-à-dire que les utilisateurs ne doivent pas les appeler directement, car l'invariance de l'API de ces méthodes n'est pas garantie lorsque de nouvelles versions d'Angular sont publiées (en fait, Je dirais que leurs API sont presque garanties de changer). <br><br>  Ainsi, toutes ces méthodes sont des API privées exportées par Angular.  Il est facile de comprendre leurs fonctionnalités en ouvrant le projet dans VS Code et en analysant les info-bulles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3df/800/ffb/3df800ffb5948fa113362e73f7d7b54c.png"></div><br>  <i><font color="#999999">Analyse de code dans VS Code</font></i> <br><br>  Même si un fichier JavaScript est analysé ici, VS Code utilise les informations de type de TypeScript pour identifier la signature d'appel et trouver la documentation d'une méthode particulière.  Si, après avoir sélectionné le nom de la méthode, utilisez la combinaison Ctrl + clic (Cmd + clic sur Mac), nous constatons que le vrai nom de cette méthode est <code>elementStart</code> . <br><br>  Cette technique a permis de découvrir que le nom de méthode <code>ɵT</code> est du <code>text</code> , le nom de méthode <code>ɵe</code> est <code>ɵe</code> .  Armés de ces connaissances, nous pouvons «traduire» le code généré, en le transformant en quelque chose qui sera plus pratique à lire.  Voici un petit fragment d'une telle "traduction": <br><br><pre> <code class="hljs ruby">var core = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">"angular/core"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... core.elementStart(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"div"</span></span>, _c<span class="hljs-number"><span class="hljs-number">0</span></span>); core.elementStart(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"h1"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">2</span></span>); core. (); core.elementStart(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"img"</span></span>, _c1); core.elementEnd(); core.elementEnd(); core.elementStart(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"h2"</span></span>); core.text(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"Here are some links to help you start: "</span></span>); core.elementEnd();</code> </pre> <br>  Et, comme déjà mentionné, ce code correspond au texte suivant du modèle HTML: <br><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text-align:center"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">   Welcome to </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ title }}</span></span><span class="xml"><span class="xml">! </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Angular Logo"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"…"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Voici quelques liens pour vous aider à démarrer:</font> </h2><br>  Après avoir analysé tout cela, il est facile de remarquer ce qui suit: <br><br><ul><li>  Chaque balise HTML d'ouverture a un appel à <code>core.elementStart()</code> . </li><li>  Les balises de fermeture correspondent aux appels à <code>core.elementEnd()</code> . </li><li>  Les nœuds de texte correspondent aux appels à <code>core.text()</code> . </li></ul><br>  Le premier argument des méthodes <code>elementStart</code> et <code>text</code> est un nombre dont la valeur augmente à chaque appel.  Il représente probablement un index dans un tableau dans lequel Angular stocke des liens vers des éléments créés. <br><br>  Le troisième argument est également transmis à la méthode <code>elementStart</code> .  Après avoir étudié les matériaux ci-dessus, nous pouvons conclure que l'argument est facultatif et contient une liste d'attributs pour le nœud DOM.  Vous pouvez le vérifier en regardant la valeur de <code>_c0</code> et en découvrant qu'il contient une liste d'attributs et leurs valeurs pour l'élément <code>div</code> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _c0 = [<span class="hljs-string"><span class="hljs-string">"style"</span></span>, <span class="hljs-string"><span class="hljs-string">"text-align:center"</span></span>];</code> </pre> <br><h2>  <font color="#3AC1EF">NgComponentDef Note</font> </h2><br>  Jusqu'à présent, nous avons analysé la partie du code généré qui est responsable du rendu du modèle pour le composant.  Ce code est en fait situé dans un morceau de code plus grand qui est affecté à <code>AppComponent.ngComponentDef</code> - une propriété statique qui contient toutes les métadonnées sur le composant, telles que les sélecteurs CSS, sa stratégie de détection des modifications (si une est spécifiée) et le modèle.  Si vous avez envie d'aventure - vous pouvez maintenant déterminer de façon indépendante comment cela fonctionne, bien que nous en parlerons ci-dessous. <br><br><h2>  <font color="#3AC1EF">Lierre fait maison</font> </h2><br>  Maintenant que nous, en termes généraux, comprenons à quoi ressemble le code généré, nous pouvons essayer de créer, à partir de zéro, notre propre composant en utilisant la même API RendererV3 qu'Ivy utilise. <br><br>  Le code que nous allons créer sera similaire au code produit par le compilateur, mais nous le rendrons plus facile à lire. <br><br>  Commençons par écrire un composant simple, puis traduisons-le manuellement en code similaire à celui obtenu par Ivy: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({ selector: <span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>, template: <span class="hljs-string"><span class="hljs-string">'&lt;h2&gt;&lt;font color="#3AC1EF"&gt;Hello, Component&lt;/font&gt;&lt;/h2&gt;'</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> { }</span></span></code> </pre> <br>  Le compilateur prend l'entrée du décorateur <code>@component</code> comme <code>@component</code> , crée des instructions, puis organise tout cela en tant que propriété statique de la classe de composants.  Par conséquent, afin de simuler l'activité d'Ivy, nous <code>@component</code> décorateur <code>@component</code> et le remplaçons par la propriété statique <code>ngComponent</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManualComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.ɵdefineComponent({   <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ManualComponent,   <span class="hljs-attr"><span class="hljs-attr">selectors</span></span>: [[<span class="hljs-string"><span class="hljs-string">'manual-component'</span></span>]],   <span class="hljs-attr"><span class="hljs-attr">factory</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ManualComponent(),   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">rf: core.ɵRenderFlags, ctx: ManualComponent</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-comment"><span class="hljs-comment">//       }, }); }</span></span></code> </pre> <br>  Nous définissons les métadonnées du composant compilé en appelant <code>ɵdefineComponent</code> .  Les métadonnées incluent le type de composant (utilisé précédemment pour implémenter la dépendance), le sélecteur CSS (ou les sélecteurs) qui appellera ce composant (dans notre cas, <code>manual-component</code> est le nom du composant dans le modèle HTML), la fabrique qui renvoie la nouvelle instance composant, puis la fonction qui définit le modèle du composant.  Ce modèle affiche une représentation visuelle du composant et le met à jour lorsque les propriétés du composant changent.  Afin de créer ce modèle, nous utiliserons les méthodes que nous avons trouvées ci-dessus: <code>ɵE</code> , <code>ɵe</code> et <code>ɵT</code> . <br><br><pre> <code class="hljs ruby">    <span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.ɵRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; {     core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);                 <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2     core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, Component'</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       core.ɵe();                        <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    h2   },</code> </pre> <br>  À ce stade, nous n'utilisons pas les paramètres <code>rf</code> ou <code>ctf</code> fournis par notre fonction de modèle.  Nous y reviendrons.  Mais d'abord, regardons comment afficher notre premier composant fait maison sur l'écran. <br><br><h2>  <font color="#3AC1EF">Première application</font> </h2><br>  Afin d'afficher les composants à l'écran, Angular exporte une méthode appelée <code>ɵrenderComponent</code> .  Tout ce que vous devez faire est de vérifier que le fichier <code>index.html</code> contient une balise HTML correspondant au sélecteur d'élément, <code>&lt;manual-component&gt;</code> , puis ajoutez ce qui suit à la fin du fichier: <br><br><pre> <code class="hljs">core.ɵrenderComponent(ManualComponent);</code> </pre> <br>  C’est tout.  Nous avons maintenant une application angulaire self-made minimale composée de seulement 16 lignes de code.  Vous pouvez expérimenter avec l'application terminée sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StackBlitz</a> . <br><br><h2>  <font color="#3AC1EF">Changer le mécanisme de détection</font> </h2><br>  Donc, nous avons un exemple de travail.  Pouvez-vous y ajouter de l'interactivité?  Dites, que diriez-vous de quelque chose d'intéressant, comme utiliser le système de détection de changement d'Angular ici? <br><br>  Modifiez le composant afin que l'utilisateur puisse personnaliser le texte de bienvenue.  Autrement dit, au lieu que le composant affiche toujours le texte <code>Hello, Component</code> , nous allons laisser l'utilisateur modifier la partie du texte qui vient après <code>Hello</code> . <br><br>  Nous commençons par ajouter la propriété <code>name</code> et une méthode pour mettre à jour la valeur de cette propriété dans la classe de composants: <br><br><pre> <code class="hljs cs">export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ManualComponent</span></span> { name = <span class="hljs-string"><span class="hljs-string">'Component'</span></span>; updateName(newName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Certes, tout cela ne semble pas particulièrement impressionnant, mais le plus intéressant est à venir. <br><br>  Ensuite, nous éditerons la fonction modèle afin qu'au lieu de texte immuable, elle affiche le contenu de la propriété <code>name</code> : <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">template:</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">rf:</span></span> core.ɵRenderFlags, <span class="hljs-symbol"><span class="hljs-symbol">ctx:</span></span> ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :        core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;--   name   core.ɵe(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :       core.ɵt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ctx -     } },</code> </pre> <br>  Vous avez peut-être remarqué que nous avons encapsulé les instructions du modèle dans les instructions <code>if</code> qui vérifient les valeurs <code>rf</code> .  Ce paramètre est utilisé par Angular pour indiquer si le composant est créé pour la première fois (le bit le moins significatif sera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">défini</a> ), ou nous avons juste besoin de mettre à jour le contenu dynamique dans le processus de détection des changements (c'est ce à quoi la seconde <code>if</code> est destinée). <br><br>  Ainsi, lorsque le composant est affiché pour la première fois, nous créons tous les éléments, puis, lorsque des modifications sont détectées, nous ne mettons à jour que ce qui pourrait changer.  La méthode interne <code>ɵt</code> est responsable (notez la lettre minuscule <code>t</code> ), ce qui correspond à la fonction <code>textBinding</code> exportée par Angular: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e48/347/c31/e48347c31b7532a1268509cf0825a031.png"></div><br>  <i><font color="#999999">Texte de fonction</font></i> <br><br>  Ainsi, le premier paramètre est l'indice de l'élément à mettre à jour, le second est la valeur.  Dans ce cas, nous créons un élément de texte vide avec l'index 2 avec la commande <code>core.ɵT(2);</code>  .  Il agit comme un espace réservé pour le <code>name</code> .  Nous le mettons à jour avec la commande <code>core.ɵt(2, ctx.name);</code>  lors de la détection d'un changement dans la variable correspondante. <br><br>  Pour le moment, la sortie de ce composant affichera toujours le texte <code>Hello, Component</code> , bien que nous puissions changer la valeur de la propriété <code>name</code> , ce qui entraînera une modification du texte à l'écran. <br><br>  Pour que l'application devienne vraiment interactive, nous ajouterons ici un champ de saisie de données avec un écouteur d'événement qui appelle la méthode du composant <code>updateName()</code> : <br><br><pre> <code class="hljs php">template: (rf: core.ɵRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'h2'</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello, '</span></span>);   core.ɵT(<span class="hljs-number"><span class="hljs-number">2</span></span>);   core.ɵe();   core.ɵT(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'Your name: '</span></span>);   core.ɵE(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'input'</span></span>);   core.ɵL(<span class="hljs-string"><span class="hljs-string">'input'</span></span>, $event =&gt; ctx.updateName($event.target.value));   core.ɵe(); } <span class="hljs-comment"><span class="hljs-comment">// ... },</span></span></code> </pre> <br>  La liaison d'événement est effectuée dans la ligne <code>core.ɵL('input', $event =&gt; ctx.updateName($event.target.value));</code>  .  À savoir, la méthode <code>ɵL</code> responsable de la définition de l'écouteur d'événements pour le plus récent des éléments déclarés.  Le premier argument est le nom de l'événement (dans ce cas, l' <code>input</code> est l'événement qui est déclenché lorsque le contenu de l'élément <code>&lt;input&gt;</code> change), le deuxième argument est un rappel.  Ce rappel accepte les données d'événement comme argument.  Ensuite, nous extrayons la valeur actuelle de l'élément cible de l'événement, c'est-à-dire de l'élément <code>&lt;input&gt;</code> , et la transmettons à la fonction dans le composant. <br><br>  Le code ci-dessus équivaut à écrire le code HTML suivant dans un modèle: <br><br><pre> <code class="hljs pgsql">Your <span class="hljs-type"><span class="hljs-type">name</span></span>: &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>)="updateName($event.target.value)" /&gt;</code> </pre> <br>  Vous pouvez maintenant modifier le contenu de l'élément <code>&lt;input&gt;</code> et observer comment le texte du composant change.  Cependant, le champ de saisie n'est pas rempli lorsque le composant est chargé.  Pour que tout fonctionne de cette façon, vous devez ajouter une instruction supplémentaire au code de fonction de modèle, exécutée lorsqu'une modification est détectée: <br><br><pre> <code class="hljs coffeescript">template: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) { ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   core.ɵt(<span class="hljs-number"><span class="hljs-number">2</span></span>, ctx.name);   core.ɵp(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>, ctx.name); } }</code> </pre> <br>  Ici, nous utilisons une autre méthode intégrée du système de rendu, <code>ɵp</code> , qui met à jour la propriété d'un élément avec un index donné.  Dans ce cas, l'index 4 est transmis à la méthode, qui est l'index affecté à l'élément d' <code>input</code> , et nous indiquons <code>ctx.name</code> méthode de placer la valeur <code>ctx.name</code> dans la propriété <code>value</code> de cet élément. <br><br>  Maintenant, notre exemple est enfin prêt.  Nous avons implémenté, à partir de zéro, une liaison de données bidirectionnelle à l'aide de l'API du système de rendu Ivy.  C'est tout simplement génial. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez expérimenter avec le code fini. <br><br>  Nous connaissons maintenant la plupart des éléments de base du nouveau compilateur Ivy.  Nous savons comment créer des éléments et des nœuds de texte, comment lier des propriétés et configurer des écouteurs d'événements et comment utiliser le système de détection des modifications. <br><br><h2>  <font color="#3AC1EF">À propos des blocs * ngIf et * ngFor</font> </h2><br>  Avant de terminer l'étude Ivy, regardons un autre sujet intéressant.  À savoir, parlons de la façon dont le compilateur fonctionne avec les sous-modèles.  Ce sont les modèles utilisés pour les <code>*ngIf</code> ou <code>*ngFor</code> .  Ils sont traités d'une manière spéciale.  Voyons comment utiliser <code>*ngIf</code> dans notre code de modèle maison. <br><br>  Vous devez d'abord installer le paquet npm <code>@angular/common</code> - c'est là que <code>*ngIf</code> .  Ensuite, vous devez importer la directive de ce package: <br><br><pre> <code class="hljs nginx"><span class="hljs-section"><span class="hljs-section">import</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">NgIf</span></span> } from <span class="hljs-string"><span class="hljs-string">'</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@angular</span></span></span><span class="hljs-string">/common'</span></span>;</code> </pre> <br>  Maintenant, afin de pouvoir utiliser <code>NgIf</code> dans le modèle, vous devez lui fournir des métadonnées, car le module <code>@angular/common</code> n'a pas été compilé avec Ivy (au moins lors de l'écriture du matériel, et à l'avenir, cela changera probablement de introduction de <a href="">ngcc</a> ). <br><br>  Nous allons utiliser la méthode <code>ɵdefineDirective</code> , qui est liée à la méthode familière <code>ɵdefineComponent</code> .  Il définit les métadonnées des directives: <br><br><pre> <code class="hljs coffeescript">(NgIf <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ngDirectiveDef = core.ɵdefineDirective({ type: NgIf, selectors: [[<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]], factory: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NgIf(core.ɵinjectViewContainerRef(), core.ɵinjectTemplateRef()), inputs: {ngIf: <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, ngIfThen: <span class="hljs-string"><span class="hljs-string">'ngIfThen'</span></span>, ngIfElse: <span class="hljs-string"><span class="hljs-string">'ngIfElse'</span></span>} });</code> </pre> <br>  J'ai trouvé cette définition dans <a href="">le code source angulaire</a> , avec la <code>ngFor</code> .  Maintenant que nous avons préparé <code>NgIf</code> pour une utilisation dans Ivy, nous pouvons ajouter ce qui suit à la liste des directives pour le composant: <br><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ngComponentDef = core.ɵdefineComponent({ directives: [<span class="hljs-type"><span class="hljs-type">NgIf</span></span>], // ... });</code> </pre> <br>  Ensuite, nous définissons le sous-modèle uniquement pour la partition délimitée par <code>*ngIf</code> . <br><br>  Supposons que vous deviez afficher une image.  Définissons une nouvelle fonction pour ce modèle à l'intérieur de la fonction de modèle: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   core.ɵE(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'div'</span></span>);   core.ɵE(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'img'</span></span>, [<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://pbs.twimg.com/tweet_video_thumb/C80o289UQAAKIqp.jpg'</span></span>]);   core.ɵe(); } }</code> </pre> <br>  Cette fonction de modèle n'est pas différente de celle que nous avons déjà écrite.  Il utilise les mêmes constructions pour créer un élément <code>img</code> intérieur d'un élément <code>div</code> . <br><br>  Et enfin, nous pouvons tout rassembler en ajoutant la directive <code>ngIf</code> au modèle de composant: <br><br><pre> <code class="hljs powershell">template: (rf: core.ɵRenderFlags, ctx: ManualComponent) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) {   // ...   core.ɵC(<span class="hljs-number"><span class="hljs-number">5</span></span>, ifTemplate, null, [<span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rf &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) {   // ...   core.ɵp(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'ngIf'</span></span>, (ctx.name === <span class="hljs-string"><span class="hljs-string">'Igor'</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ifTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rf: core.ɵRenderFlags, ctx: ManualComponent)</span></span></span></span> {   // ... } },</code> </pre> <br>  Notez l'appel à la nouvelle méthode au début du code ( <code>core.ɵC(5, ifTemplate, null, ['ngIf']);</code> ).  Il déclare un nouvel élément conteneur, c'est-à-dire un élément qui a un modèle.  Le premier argument est l'indice de l'élément, nous avons déjà vu de tels index.  Le deuxième argument est la fonction de sous-modèle que nous venons de définir.  Il sera utilisé comme modèle pour l'élément conteneur.  Le troisième paramètre est le nom de balise de l'élément, ce qui n'a pas de sens ici, et enfin, il y a une liste de directives et d'attributs associés à cet élément.  C'est là <code>ngIf</code> . <br><br>  Dans la ligne <code>core.ɵp(5, 'ngIf', (ctx.name === 'Igor'));</code>  l'état de l'élément est mis à jour en liant l'attribut <code>ngIf</code> à la valeur de l'expression logique <code>ctx.name === 'Igor'</code> .  Cela vérifie si la propriété <code>name</code> du composant est égale à <code>Igor</code> . <br><br>  Le code ci-dessus est équivalent au code HTML suivant: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> *</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ngIf</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name === 'Igor'"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">align</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"center"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"..."</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ici, on peut noter que le nouveau compilateur ne produit pas le code le plus compact, mais il n'est pas si mauvais par rapport à ce qu'il est maintenant. <br><br>  Vous pouvez expérimenter avec un nouvel exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Pour voir la section <code>NgIf</code> en action, entrez le nom <code>Igor</code> dans le champ <code>Your name</code> . <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Nous avons à peu près parcouru les capacités du compilateur Ivy.  J'espère que ce voyage a suscité votre intérêt pour une exploration plus approfondie d'Angular.  Si oui, alors vous avez maintenant tout ce dont vous avez besoin pour expérimenter avec Ivy.  Vous savez maintenant comment «traduire» des modèles en JavaScript, comment accéder aux mêmes mécanismes angulaires qu'Ivy utilise sans utiliser ce compilateur.  Je suppose que tout cela vous donnera l'occasion d'explorer les nouveaux mécanismes angulaires aussi profondément que vous le souhaitez. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="">ici</a> - trois matériaux dans lesquels vous pouvez trouver des informations utiles sur Ivy.  Et <a href="">voici</a> le code source de Render3. <br><br>  <b>Chers lecteurs!</b>  Que pensez-vous des nouvelles fonctionnalités d'Ivy? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419995/">https://habr.com/ru/post/fr419995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419985/index.html">Klats, klats: l'histoire de Cherry, qui est devenue célèbre pour les commutateurs à clavier</a></li>
<li><a href="../fr419987/index.html">Que diront les gouttes de sang: trigonométrie des crimes</a></li>
<li><a href="../fr419989/index.html">La Nouvelle-Zélande interdit les sacs en plastique</a></li>
<li><a href="../fr419991/index.html">Des drones autonomes conduiront des troupeaux d'oiseaux depuis les aéroports</a></li>
<li><a href="../fr419993/index.html">Entretien de TypeScript: 20 questions et réponses</a></li>
<li><a href="../fr419997/index.html">Analyser le modèle "Module" en JavaScript</a></li>
<li><a href="../fr419999/index.html">Partage d'authentification Yii1 / yii2</a></li>
<li><a href="../fr420001/index.html">Présentation de 3CX v15.5 Update 6 BETA et WebRTC Browser Softphone</a></li>
<li><a href="../fr420003/index.html">Fenêtre avec boutons sur JavaFX:</a></li>
<li><a href="../fr420005/index.html">La surveillance vidéo non professionnelle de l'appartement est divertissante et peu coûteuse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>