<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 👆 ⛏️ 熟悉Python测试。 第一部分 👨🏻‍🍳 🌯 👢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="祝大家有美好的一天！ 

 从我们的桌子到您的桌子。也就是说，从我们的课程“ Python Developer”开始，尽管新年快到了，但我们为您准备了有关Python中各种测试方法的有趣翻译。 

 本指南适用于那些已经编写了很酷的Python应用程序但尚未编写的应用程序。 
 他们测试。 

 使...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>熟悉Python测试。 第一部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/433358/">祝大家有美好的一天！ <br><br>  <s>从我们的桌子到您的桌子。</s>也就是说，从我们的课程“ Python Developer”开始，尽管新年快到了，但我们为您准备了有关Python中各种测试方法的有趣翻译。 <br><br> 本指南适用于那些已经编写了很酷的Python应用程序但尚未编写的应用程序。 <br> 他们测试。 <br><br> 使用Python进行测试是一个广泛的话题，包含很多细节，但是不必使事情复杂化。 通过几个简单的步骤，您可以为应用程序创建简单的测试，并根据这些测试逐渐增加复杂性。 <br><br> 在本指南中，您将学习如何创建基本测试，运行它并在用户进行操作之前查找所有错误！ 您将了解用于编写和运行测试，检查应用程序性能甚至查看安全问题的可用工具。 <br><br><img src="https://habrastorage.org/webt/kh/va/x5/khvax5ew8tluy6c9muhw-oei7cm.png"><br><a name="habracut"></a><br>  <b>代码测试</b> <br><br> 您可以通过多种方式测试代码。 在本指南中，您将学习从最简单到最高级的方法。 <br><br>  <i><b>自动化与</b></i>  <i><b>手动测试</b></i> <i><br></i> <br> 好消息！ 您很可能已经完成了测试，但尚未意识到这一点。 还记得您第一次启动该应用程序并使用它的方式吗？ 您是否测试过功能并进行了实验？ 此过程称为探索性测试，它是手动测试的一种形式。 <br><br> 研究测试-在没有计划的情况下完成的测试。 在研究测试期间，您将研究应用程序。 <br><br> 要创建完整的手动测试列表，只需列出应用程序的所有功能，所需的各种输入以及预期的结果即可。 现在，每次更改代码中的某些内容时，都需要重新检查此列表中的每个元素。 <br><br> 听起来很暗淡，对不对？ <br><br> 因此，需要自动测试。 自动测试-使用脚本而不是人工执行测试计划（应用程序中需要测试的部分，测试顺序和预期结果）。  Python已经有了一套工具和库来帮助您为应用程序创建自动化测试。 让我们在教程中查看这些工具和库。 <br><br>  <i><b>VS单元测试。</b></i>  <i><b>整合测试</b></i> <br><br> 测试的世界充满了术语，现在，了解手动测试和自动测试之间的区别，我们将更加深入。 <br><br> 想想如何测试汽车的前灯？ 您打开大灯（将其称为测试步骤），自己下车，或请朋友检查大灯是否点亮（这是一个测试建议）。 测试多个组件称为集成测试。 <br><br> 考虑所有应该正常工作的事物，以便简单的任务可以产生正确的结果。 这些组件类似于您的应用程序的各个部分：您编写的所有这些类，函数，模块。 <br><br> 当集成测试没有给出正确的结果时，就会出现集成测试的主要困难。 无法评估问题，无法隔离系统的损坏部分。 如果前灯未点亮，则灯泡可能会损坏。 还是电池电量不足？ 还是问题出在发电机上？ 甚至是机器计算机崩溃？ <br><br> 现代汽车本身会通知您灯泡损坏。 这是使用单元测试确定的。 <br><br> 单元测试（unit test）是一种小型测试，用于检查单个组件的正确操作。 单元测试有助于隔离故障并更快地进行修复。 <br><br> 我们讨论了两种类型的测试： <br><br><ol><li> 集成测试，用于检查系统组件及其相互之间的交互； </li><li> 单元测试，用于测试应用程序的单个组件。 </li><li> 您可以在Python中创建两个测试。 要为内置的sum（）函数编写测试，您需要将sum（）的输出与已知值进行比较。 </li></ol><br> 例如，通过这种方式，您可以检查数字（1、2、3）的总和是否为6： <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br> 值是正确的，因此什么也不会输出到REPL。 如果<code>sum()</code>的结果不正确，则会<code>AssertionError</code>并显示消息“应该为6”。 再次检查statement语句，但是现在使用无效值来获取<code>AssertionError</code> ： <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br> 在REPL中，由于<code>sum()</code>值不是6，因此您会看到<code>AssertionError</code> 。 <br><br> 代替REPL，将其放在一个名为<code>test_sum.py</code>的新Python文件中，然后再次运行它： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre> <br> 现在，您有一个书面的测试用例（测试用例），语句和入口点（命令行）。 现在可以在命令行上完成： <br><br><pre> <code class="python hljs">$ python test_sum.py Everything passed</code> </pre> <br> 您会看到成功的结果，“一切都过去了”。 <br><br>  Python中的<code>sum()</code>接受任何iterable作为第一个参数。 您已检查列表。 让我们尝试测试元组。 使用以下代码创建一个名为<code>test_sum_2.py</code>的新文件： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() test_sum_tuple() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre><br>  <code>test_sum_2.py</code> ，脚本将<code>test_sum_2.py</code>错误，因为s <code>um() (1, 2, 2)</code> <code>test_sum_2.py</code> <code>um() (1, 2, 2)</code>应该为5，而不是6。结果，脚本给出了一条错误消息，一行代码和一个回溯： <br><br><pre> <code class="python hljs">$ python test_sum_2.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; test_sum_tuple() File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br> 您可以看到代码中的错误如何导致控制台中的错误，并提供有关错误发生的位置以及预期结果的信息。 <br><br> 这样的测试适合于简单的验证，但是如果错误多于一次，该怎么办？ 测试选手来营救。  Test Executor是一个特殊的应用程序，旨在执行测试，验证输出数据并提供调试和诊断测试及应用程序的工具。 <br><br>  <i><b>选择测试执行器</b></i> <br><br> 有许多可用于Python的测试运行器。 例如，unittest内置在Python标准库中。 在本指南中，我们将使用测试用例和单元测试执行器。 单元测试的操作原理很容易适应其他框架。 我们列出了最受欢迎的测试执行者： <br><br><ul><li> 单元测试； </li><li> 鼻子或鼻子2; </li><li>  pytest。 </li></ul><br> 选择符合您要求和经验的测试承包商很重要。 <br><br>  <b>单元测试</b> <br><br> 自2.1版以来，unittest已集成到Python标准库中。 您可能会在商业Python应用程序和开源项目中遇到它。 <br>  Unittest有一个测试框架和测试运行程序。 在编写和运行测试时，您需要遵循一些重要的要求。 <br><br> 单元测试要求： <br><br><ul><li> 将测试作为方法放在类中； </li><li> 使用特殊的批准方法。  TestCase类，而不是通常的内置断言表达式 </li></ul><br><br> 要将先前编写的示例转换为单元测试用例，您必须： <br><br><ol><li> 从标准库导入单元测试； </li><li> 创建一个名为<code>TestSum</code>的类，它将继承<code>TestCase</code>类。 </li><li> 通过将<code>self</code>作为第一个参数，将测试函数转换为方法； </li><li> 通过在<code>TestCase</code>类中添加使用<code>self.assertEqual()</code>方法来修改语句； </li><li> 在命令行上更改入口点以调用<code>unittest.main()</code> 。 </li></ol><br> 按照以下步骤，使用以下代码创建一个新的test_sum_unittest.py文件： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br> 通过在命令行上执行此操作，您将获得一个成功的完成（由表示。）和一个不成功的（由F表示）： <br><br><pre> <code class="python hljs">$ python test_sum_unittest.py .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br> 因此，您使用unittest测试运行程序执行了两个测试。 <br><br>  <i>注意：如果要为Python 2和3编写测试用例，请小心。</i>  <i>在Python 2.7及更低版本中，unittest称为unittest2。从unittest导入时，您将在Python 2和Python 3中获得具有不同功能的不同版本。</i> <br><br> 要了解有关unittest的更多信息，请阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">unittest文档</a> 。 <br><br>  <b>鼻子</b> <br><br> 随着时间的流逝，在为一个应用程序编写了数百甚至数千个测试之后，理解和使用单元测试输出数据变得越来越困难。 <br><br> 鼻子与用unittest框架编写的所有测试兼容，并且可以替换其测试执行程序。 作为一个开放源代码应用程序，nose的开发开始放缓，并创建了nose2。 如果您是从头开始的，建议使用准确的nose2。 <br><br> 要开始使用nas2，您需要从PyPl安装它并在命令行上运行它。 如果在名称中包含<code>test*.py</code>以及从当前目录中继承自unittest.TestCase的所有测试用例，nas2将尝试查找所有带有<code>test*.py</code>测试脚本： <br><br><pre> <code class="python hljs">$ pip install nose2 $ python -m nose2 .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 这是从nas2测试<code>test_sum_unittest.py</code>在<code>test_sum_unittest.py</code>创建的测试的方式。  nase2提供了许多命令行标志来过滤可执行的测试。 有关更多信息，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">鼻子2文档</a> 。 <br><br>  <b>pytest</b> <br><br>  pytest支持unittest测试用例。 但是pytest的真正优势在于它的测试用例。  pytest测试用例是Python文件中一系列函数，名称开头为test_。 <br><br> 其中还有其他有用的功能： <br><br><ul><li> 支持内置的断言表达式，而不是使用特殊的self.assert *（）方法； </li><li> 支持过滤测试用例； </li><li> 从上次失败的测试中重新启动的能力； </li><li> 由数百个扩展功能的插件组成的生态系统。 </li></ul><br>  pytest的TestSum测试用例示例如下所示： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br> 使用类和命令行入口点摆脱了TestCase。 <br> 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pytest文档站点</a>上找到更多信息。 <br><br>  <b>编写第一个测试</b> <br><br> 结合我们已经学习的所有内容，而不是内置的<code>sum()</code>函数，我们测试具有相同要求的简单实现。 <br><br> 为项目创建一个新文件夹，在其中创建一个名为my_sum的新文件夹。 在my_sum内，创建一个名为<code>_init_.py</code>的空文件。 该文件的存在意味着my_sum文件夹可以作为模块从父目录中导入。 <br><br> 文件夹结构如下所示： <br><br> <code>project/ <br> │ <br> └── my_sum/ <br> └── __init__.py</code> <br> <br> 打开<code>my_sum/__init__.py</code>并创建一个名为<code>sum()</code>的新函数，该函数接受<code>my_sum/__init__.py</code>输入（列表，元组，集合）并添加值。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function">:</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arg: total += val <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total</code> </pre> <br> 本示例创建一个名为<code>total</code>的变量，对<code>arg</code>所有值进行迭代并添加到<code>total</code> 。 然后，在完成迭代后，将返回结果。 <br><br>  <b>在哪里编写测试</b> <br><br> 您可以通过创建一个包含第一个测试用例的<code>test.py</code>文件来开始编写测试。 为了进行测试，该文件应该能够导入您的应用程序，因此将<code>test.py</code>放在软件包上方的文件夹中。 目录树将如下所示： <br><br> <code>project/ <br> │ <br> ├── my_sum/ <br> │ └── __init__.py <br> | <br> └── test.py</code> <br> <br> 您会注意到，随着添加新测试，文件变得更加繁琐且难以维护，因此我们建议创建<code>tests/</code>文件夹并将测试拆分为多个文件。 确保所有文件的名称都以<code>test_</code> ，以便测试运行<code>test_</code>理解Python文件包含需要运行的测试。 在大型项目中，根据测试的目的或用途将测试分为几个目录。 <br><br>  <i>注意：什么是单个脚本？</i> <i><br></i>  <i>您可以使用内置的<code>__import__()</code>函数导入任何脚本属性：类，函数或变量。</i>  <i>而不是<code>from my_sum import sum</code>写入以下内容：</i> <br><br><pre> <code class="python hljs">target = __import__(<span class="hljs-string"><span class="hljs-string">"my_sum.py"</span></span>) sum = target.sum</code> </pre> <br>  <i>使用<code>__import__()</code>不必将项目文件夹转换为包，并且可以指定文件名。</i>  <i>如果文件名与标准软件包库的名称冲突，这将很有用。</i>  <i>例如，如果<code>math.py</code>与math模块冲突。</i> <br><br>  <b>如何构造一个简单的测试</b> <br><br> 在编写测试之前，您需要解决一些问题： <br><br><ol><li> 您要测试什么？ </li><li> 您正在编写单元测试还是集成测试？ </li></ol><br> 您目前正在测试<code>sum()</code> 。 您可以为此测试不同的行为，例如： <br><br><ul><li> 是否可以汇总整数列表？ </li><li> 是否可以汇总一个元组或集合？ </li><li> 我可以总结一下浮点数列表吗？ </li><li> 如果您给输入一个错误的值：单个整数或字符串，会发生什么？ </li><li> 如果其中一个值为负，会发生什么？ </li></ul><br> 测试的最简单方法是整数列表。 使用以下代码创建一个<code>test.py</code>文件： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br> 此示例中的代码： <br><br><ul><li> 从您创建的包<code>my_sum()</code>中导入<code>sum()</code> ； </li><li> 定义一个称为TestSum的新测试用例类，该类继承<code>unittest.TestCase</code> ; </li><li> 定义用于测试整数列表的test <code>.test_list_int()</code>方法。  <code>.test_list_int()</code>方法将执行以下操作 </li></ul>  ： <br><ol><li> 声明一个带有值列表<code>(1, 2, 3)</code>的<code>data</code>变量； </li><li>  <code>my_sum.sum(data)</code>值<code>my_sum.sum(data)</code>变量<code>result</code> ； </li><li> 使用<code>unittest.TestCase</code>类的<code>.assertEqual()</code>方法确定结果的值为6。 </li></ol><br><ul><li> 定义启动unittest <code>.main()</code>测试运行程序的命令行入口点。 </li></ul><br> 如果您不知道什么是self或如何定义<code>.assertEqual()</code> ，则可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Python 3 Object-Oriented Programming</a>刷新对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">面向对象编程的知识</a> 。 <br><br>  <b>如何写陈述</b> <br><br> 编写测试的最后一步是验证输出是否与已知值匹配。 这称为断言。 有一些用于编写语句的一般准则： <br><br><ul><li> 验证测试是否可重复，并运行几次以确保每次给出的结果相同； </li><li> 检查并确认适用于您输入的结果-确认结果确实是<code>sum()</code>示例中值的<code>sum()</code> 。 </li></ul><br> 单元测试有许多方法来确认变量的值，类型和存在。 以下是一些最常用的方法： <br><br><table><tbody><tr><th> 方法 </th><th> 当量 </th></tr><tr><td>  .assertEqual（a，b） </td><td>  a == b </td></tr><tr><td>  .assertTrue（x） </td><td> 布尔（x）为真 </td></tr><tr><td>  .assertFalse（x） </td><td>  bool（x）为False </td></tr><tr><td>  .assertIs（a，b） </td><td>  a是b </td></tr><tr><td>  .assertIsNone（x） </td><td>  x为无 </td></tr><tr><td>  .assertIn（a，b） </td><td>  a in b </td></tr><tr><td>  .assertIsInstance（a，b） </td><td> 实例（a，b） </td></tr></tbody></table><br><br>  <code>.assertIs()</code> <code>.assertIsNone()</code> <code>.assertIn()</code>和<code>.assertIsInstance()</code>具有相反的方法，称为<code>.assertIsNot()</code>等等。 <br><br>  <b>副作用</b> <br><br> 编写测试比仅查看函数的返回值难。 通常，代码执行会更改环境的其他部分：类属性，文件系统文件，数据库中的值。 这是测试的重要组成部分，称为副作用。 在将其包括在索赔清单中之前，请确定是否要测试副作用。 <br><br> 如果您发现要测试的代码块中有很多副作用，则您违反了“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">唯一责任原则”</a> 。 违反唯一责任原则意味着一段代码要做太多的事情，需要重构。 遵循唯一责任的原则是一种设计代码的好方法，为此，编写简单，可重复的单元测试并最终创建可靠的应用程序将不困难。 <br><br>  <b>首次测试启动</b> <br><br> 您创建了第一个测试，现在您需要尝试运行它。 很明显，它将通过，但是在创建更复杂的测试之前，您需要确保即使这样的测试也成功。 <br><br>  <b>运行测试执行器</b> <br><br> 测试执行程序-运行测试代码，验证断言并在控制台中显示测试结果的Python应用程序。 在test.py的末尾添加以下代码： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br> 这是命令行入口点。 如果通过在命令行上运行python <code>test.py</code>来运行此脚本，它将调用<code>unittest.main()</code> 。 这将<code>unittest.TestCase</code>检测此文件中所有继承自<code>unittest.TestCase</code>类来启动测试运行程序。 <br><br> 这是运行单元测试测试运行器的许多方法之一。 如果只有一个名为<code>test.py</code>测试文件，则调用python test.py是入门的好方法。 <br><br> 另一种方法是使用unittest命令行。 让我们尝试： <br><br><pre> <code class="python hljs">$ python -m unittest test</code> </pre> <br> 这将通过命令行执行相同的测试模块（称为<code>test</code> ）。 您可以添加其他参数来更改输出。 其中之一是-v表示详细。 让我们尝试以下方法： <br><br><pre> <code class="bash hljs">$ python -m unittest -v <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test_list_int (test.TestSum) ... ok ---------------------------------------------------------------------- Ran 1 tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.000s</code> </pre><br> 我们从test.py运行了一个测试，并将结果输出到控制台。 详细模式列出了执行的测试的名称以及每个测试的结果。 <br><br> 除了提供包含测试的模块的名称之外，您还可以使用以下方法请求自动发现： <br><br><pre> <code class="python hljs">$ python -m unittest discover</code> </pre> <br> 该命令将在当前目录中查找名称为test <code>test*.py</code>文件以进行测试。 <br><br> 如果您有多个测试文件，并且遵循<code>test*.py</code>命名模式，则可以使用-s标志和文件夹名称来传递目录名称。 <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests</code> </pre> <br>  unittest将在一个测试计划中运行所有测试并产生结果。 <br> 最后，如果源代码不在根目录中，而是在子目录中（例如，在名为src /的文件夹中），则可以使用-t标志告诉unittest在哪里运行测试以正确导入模块： <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests -t src</code> </pre> <br>  unittest将在<code>test*.py</code>内部的<code>src/</code>目录中找到所有<code>test*.py</code>文件，然后执行它们。 <br><br>  <b>了解测试结果</b> <b><br></b> <br> 这是一个非常简单的示例，说明一切正常，因此，让我们尝试了解失败的测试的输出。 <br><br>  <code>sum()</code>必须接受其他数字类型的列表，例如小数。 <br><br> 在<code>test.py</code>代码的开头<code>test.py</code>添加一个表达式以从标准库的<code>fractions</code>模块导入<code>Fraction</code>类型。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fractions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Fraction</code> </pre> <br> 现在添加一个带有语句的测试，期望值不正确。 在我们的例子中，我们期望¼，¼和the的总和等于1： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_fraction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of fractions """</span></span> data = [Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre><br> 如果使用python -m unittest test再次运行测试，请获取以下内容： <br><br><pre> <code class="python hljs">$ python -m unittest test F. ====================================================================== FAIL: test_list_fraction (test.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_list_fraction self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) AssertionError: Fraction(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br> 在此输出中，您将看到以下内容： <br><br><ul><li> 第一行显示所有测试的结果：一个失败（F），一个通过（。）； </li><li>  FAIL显示失败测试的一些详细信息： </li></ul><br><ol><li> 测试方法的名称（ <code>test_list_fraction</code> ）; </li><li> 测试模块（ <code>test</code> ）和测试用例（ <code>TestSum</code> ）； </li><li> 追溯字符串有错误； </li><li> 带有预期结果（1）和实际结果（分数（9，10））的语句的详细信息 </li></ol><br> 请记住，您可以使用<code>python -m unittest</code>的-v标志将其他信息添加到测试输出。 <br><br>  <b>从PyCharm运行测试</b> <br><br> 如果您使用的是PyCharm IDE，则可以按照以下步骤运行unittest或pytest： <br><br><ol><li> 在项目工具窗口中，选择测试目录。 </li><li> 在上下文菜单中，选择unittest run命令。 例如，“我的测试中的单元测试...”。 </li></ol><br> 这将在测试窗口中执行unittest并在PyCharm中返回结果： <br><br><img src="https://habrastorage.org/webt/i0/5e/xv/i05exvqd-ph8-jisw2a1ejgop_c.png"><br><br> 有关更多信息，请访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyCharm网站</a> 。 <br><br>  <b>从Visual Studio Code运行测试</b> <br><br> 如果您使用Microsoft Visual Studio Code IDE，则Python插件已经内置了对unittest，nose和pytest的支持。 <br><br> 如果已安装，则可以通过使用Ctrl + Shift + P打开“命令面板”并编写“ Python测试”来配置测试配置。 您将看到选项列表： <br><br><img src="https://habrastorage.org/webt/b1/zs/10/b1zs10n-ydybrqz62ywpknjp89q.png"><br><br> 选择“调试所有单元测试”，然后VSCode将发送请求以配置测试框架。 单击齿轮以选择测试运行器（unittest）和主目录（。）。 <br><br> 设置完成后，您将在屏幕底部看到测试状态，并且可以通过单击图标来快速访问测试日志并重新启动测试： <br><br><img src="https://habrastorage.org/webt/rk/k6/cm/rkk6cmqzjwmtc-4upzozzurcjh4.png"><br><br> 我们看到正在执行测试，但是其中一些失败了。 <br><br> 结束 <br><br> 在本文的下一部分中，我们将检查Django和Flask等框架的测试。 <br><br> 我们在这里等待您的问题和评论，并且与往常一样，您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开放日</a>前往斯坦尼斯拉夫。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433358/">https://habr.com/ru/post/zh-CN433358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433348/index.html">JSX使用TypeScript输入DSL</a></li>
<li><a href="../zh-CN433350/index.html">12月17日至12月23日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN433352/index.html">上周第343天（2018年12月10日至16日）的前端世界摘要</a></li>
<li><a href="../zh-CN433354/index.html">来自OpenStreetMap 438世界的新闻（12/04/2018-12/10/2018）</a></li>
<li><a href="../zh-CN433356/index.html">攻击者学会了绕过两因素身份验证Yahoo Mail和Gmail</a></li>
<li><a href="../zh-CN433360/index.html">科学家试图预测何时电动飞机将成为现实</a></li>
<li><a href="../zh-CN433362/index.html">UX中美观，简单和护理的9条原则</a></li>
<li><a href="../zh-CN433364/index.html">LDraw + Unity。 我如何产生乐高</a></li>
<li><a href="../zh-CN433366/index.html">在Unity3D中使用外部资源</a></li>
<li><a href="../zh-CN433368/index.html">如何将杂货店思维应用于世界：运动衫的一个例子</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>