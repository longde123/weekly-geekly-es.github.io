<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏻 ⚽️ 📮 Asynchrone Task Execution Layer-Architektur 🙆🏿 🧦 👨🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In mobilen Anwendungen von sozialen Netzwerken mag der Benutzer, schreibt einen Kommentar, blättert dann durch den Feed, startet das Video und setzt d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Task Execution Layer-Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437592/">  In mobilen Anwendungen von sozialen Netzwerken mag der Benutzer, schreibt einen Kommentar, blättert dann durch den Feed, startet das Video und setzt das Gleiche erneut.  All dies ist schnell und fast gleichzeitig.  Wenn die Implementierung der Geschäftslogik der Anwendung vollständig blockiert ist, kann der Benutzer erst dann zum Band gehen, wenn dergleichen zum Aufzeichnen mit Siegeln geladen ist.  Der Benutzer wird jedoch nicht warten, daher funktionieren in den meisten mobilen Anwendungen asynchrone Aufgaben, die unabhängig voneinander gestartet und ausgeführt werden.  Der Benutzer führt mehrere Aufgaben gleichzeitig aus und blockiert sich nicht gegenseitig.  Eine asynchrone Aufgabe wird gestartet und ausgeführt, während der Benutzer die nächste startet. <br><br><img src="https://habrastorage.org/webt/on/8u/ys/on8uys9oib69dbqrfu4xfnnq-0u.png"><br><br>  Bei der Entschlüsselung des Berichts von <b>Stepan Goncharov</b> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf werden</a> wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf die</a> Asynchronität <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehen</a> : Wir werden uns mit der Architektur mobiler Anwendungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befassen,</a> diskutieren, warum wir eine separate Schicht für die Ausführung asynchroner Aufgaben trennen müssen, wir werden die Anforderungen und vorhandenen Lösungen analysieren, wir werden die Vor- und Nachteile analysieren und eine der Implementierungen dieses Ansatzes betrachten.  Wir lernen auch, wie asynchrone Aufgaben verwaltet werden, warum jede Aufgabe ihre eigene ID hat, welche Ausführungsstrategien gelten und wie sie die Entwicklung der gesamten Anwendung vereinfachen und beschleunigen. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tBC5Zoxcgbk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Über den Sprecher: Stepan Goncharov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">stepango</a> ) arbeitet bei Grab - es ist wie bei Uber, aber in Südostasien.  Er ist seit mehr als 9 Jahren in der Android-Entwicklung tätig.  Interessiert an Kotlin seit 2014 und seit 2016 - verwendet es im Produkt.  Organisiert von der Kotlin User Group in Singapur.  Dies ist einer der Gründe, warum alle Codebeispiele auf Kotlin sein werden und nicht, weil es in Mode ist. <br><br>  Wir werden uns einen Ansatz zum Entwerfen der Komponenten Ihrer Anwendung ansehen.  Dies ist eine Handlungsanleitung für diejenigen, die der Anwendung neue Komponenten hinzufügen, diese bequem entwerfen und dann erweitern möchten.  iOS-Entwickler können den iOS-Ansatz verwenden.  Der Ansatz gilt auch für andere Plattformen.  Ich interessiere mich seit 2014 für Kotlin, daher werden alle Beispiele in dieser Sprache sein.  Aber keine Sorge - Sie können dasselbe in Swift, Objective-C und anderen Sprachen schreiben. <br><br>  Beginnen wir mit den Problemen und Nachteilen von <b>Reactive Extensions</b> .  Probleme sind typisch für andere asynchrone Grundelemente, daher sagen wir RX - denken Sie an die Zukunft und das Versprechen, und alles wird ähnlich funktionieren. <br><br><h2>  RX-Probleme </h2><br>  <b>Hohe Eintrittsschwelle</b> .  RX ist recht komplex und groß - es hat 270 Bediener und es ist nicht einfach, dem gesamten Team den richtigen Umgang damit beizubringen.  Wir werden dieses Problem nicht diskutieren - es geht über den Rahmen des Berichts hinaus. <br><br>  In RX müssen Sie <b>Ihre Abonnements manuell verwalten und den Lebenszyklus der Anwendung überwachen</b> .  Wenn Sie Single oder Observable bereits abonniert haben, können Sie <b>es nicht mit einem anderen SIngle vergleichen</b> , da Sie immer ein neues Objekt erhalten und es zur Laufzeit immer andere Abonnements gibt.  <b>In RX gibt es keine Möglichkeit, Abonnements und Streams zu vergleichen</b> . <br><br>  Wir werden versuchen, einige dieser Probleme zu lösen.  Wir werden jedes Problem einmal lösen und dann das Ergebnis wiederverwenden. <br><br><h2>  Problem Nummer 1: Eine Aufgabe mehrmals ausführen </h2><br>  Ein häufiges Problem bei der Entwicklung ist unnötiges Arbeiten und mehrmaliges Wiederholen derselben Aufgaben.  Stellen Sie sich vor, wir haben ein Formular zur Dateneingabe und eine Schaltfläche zum Speichern.  Wenn diese Taste gedrückt wird, wird eine Anfrage gesendet. Wenn Sie jedoch während des Speicherns des Formulars mehrmals auf klicken, werden mehrere identische Anfragen gesendet.  Wir haben den Knopf zum Testen der Qualitätssicherung gegeben, sie haben 40 Mal in einer Sekunde gedrückt - wir haben 40 Anfragen erhalten, weil zum Beispiel die Animation keine Zeit zum Arbeiten hatte. <br><br>  Wie löse ich das Problem?  Jeder Entwickler hat seinen eigenen bevorzugten Lösungsansatz: Einer hält eine <code>debounce</code> , der andere blockiert die Schaltfläche für alle Fälle durch <code>clickable = false</code> .  Es gibt keinen allgemeinen Ansatz, daher werden diese Fehler in unserer Anwendung entweder angezeigt oder verschwinden.  Wir lösen das Problem nur, wenn die Qualitätssicherung uns sagt: "Oh, ich habe hier geklickt und es ist kaputt gegangen"! <br><br><h3>  Eine skalierbare Lösung? </h3><br>  Um solche Situationen zu vermeiden, werden wir RX oder ein anderes asynchrones Framework umbrechen - <b>wir werden allen asynchronen Operationen IDs hinzufügen</b> .  Die Idee ist einfach - wir brauchen eine Möglichkeit, sie zu vergleichen, da diese Methode normalerweise nicht in den Frameworks enthalten ist.  Wir können die Aufgabe abschließen, wissen jedoch nicht, ob sie bereits abgeschlossen wurde oder nicht. <br><br>  Nennen wir unseren Wrapper "Act" - andere Namen sind bereits vergeben.  Erstellen Sie dazu kleine <code>typealias</code> und eine einfache <code>interface</code> in der es nur ein Feld gibt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Id = String <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id }</code> </pre> <br>  Dies ist praktisch und reduziert die Codemenge geringfügig.  Wenn es String später nicht gefällt, werden wir es durch etwas anderes ersetzen.  In diesem kleinen Code beobachten wir eine lustige Tatsache. <br><br><blockquote>  Schnittstellen können Eigenschaften enthalten. </blockquote><br>  Für Programmierer, die aus Java kommen, ist dies unerwartet.  Normalerweise fügen sie <code>getId()</code> -Methoden in die Schnittstelle ein, aber dies ist aus Sicht von Kotlin die falsche Lösung. <br><br><h3>  Wie werden wir gestalten? </h3><br>  Ein kleiner Exkurs.  Beim Entwerfen halte ich mich an zwei Prinzipien.  Die erste besteht darin <b>, die Komponentenanforderungen und die Implementierung in kleine Teile zu zerlegen</b> .  Dies ermöglicht eine detaillierte Kontrolle über das Schreiben von Code.  Wenn Sie eine große Komponente erstellen und versuchen, alles auf einmal zu erledigen, ist dies schlecht.  Normalerweise funktioniert diese Komponente nicht und Sie beginnen mit dem Einsetzen von Krücken. Ich fordere Sie daher dringend auf, in kleinen kontrollierten Schritten zu schreiben und sie zu genießen.  Das zweite Prinzip besteht <b>darin, die Funktionsfähigkeit</b> nach jedem Schritt <b>zu überprüfen</b> und <b>den Vorgang</b> erneut zu <b>wiederholen</b> . <br><br><h3>  Warum reicht der Ausweis nicht aus? </h3><br>  Kommen wir zurück zum Problem.  Wir haben den ersten Schritt gemacht - wir haben eine ID hinzugefügt und alles war einfach - die Schnittstelle und das Feld.  Dies hat uns nichts gebracht, da die Schnittstelle keine Implementierung enthält und nicht alleine funktioniert, aber Sie können Vorgänge vergleichen. <br><br>  Als nächstes werden wir Komponenten hinzufügen, die es uns ermöglichen, die Schnittstelle zu verwenden und zu verstehen, dass wir eine Art Anfrage ein zweites Mal ausführen möchten, wenn dies nicht erforderlich ist.  Als erstes werden wir <b>neue Abstraktionen einführen</b> . <br><br><h3>  Einführung neuer Abstraktionen: MapDisposable </h3><br>  Es ist wichtig, den richtigen Namen und die richtige Abstraktion zu wählen, die Entwicklern bekannt sind, die in Ihrer Codebasis arbeiten.  Da ich Beispiele für RX habe, werden wir das RX-Konzept und ähnliche Namen verwenden wie die Bibliotheksentwickler.  So können wir unseren Kollegen leicht erklären, was sie getan haben, warum und wie es funktionieren sollte.  Informationen zum Auswählen eines Namens finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompositeDiposable-Dokumentation</a> . <br><br>  Erstellen wir eine kleine MapDisposable-Oberfläche, <b>die Informationen</b> zu aktuellen Aufgaben enthält und <b>beim Löschen</b> dispose <b>() aufruft</b> .  Ich werde die Implementierung nicht geben, Sie können alle Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf meinem GitHub sehen</a> . <br><br>  Wir nennen MapDisposable auf diese Weise, da die Komponente wie eine Map funktioniert, jedoch CompositeDiposable-Eigenschaften aufweist. <br><br><h3>  Einführung neuer Abstraktionen: ActExecutor </h3><br>  Die nächste abstrakte Komponente ist <b>ActExecutor.</b>  Es startet oder startet keine neuen Aufgaben, hängt von MapDisposable ab und delegiert die Fehlerbehandlung.  So wählen Sie einen Namen aus - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Dokumentation</a> . <br><br>  Nehmen Sie die nächste Analogie aus dem JDK.  Es hat einen Executor, in dem Sie Thread übergeben und etwas tun können.  Es scheint mir, dass dies eine coole Komponente ist und gut gestaltet, also nehmen wir es als Grundlage. <br><br>  Wir erstellen ActExecutor und eine einfache Schnittstelle dafür, wobei wir dem Prinzip einfacher kleiner Schritte folgen.  Der Name selbst sagt, dass es eine Komponente ist, an die wir etwas übertragen, und es beginnt, etwas zu tun.  ActExecutor hat eine Methode, mit der wir <code>Act</code> und für alle Fälle Fehler behandeln, denn ohne sie gibt es keinen Weg. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = ::logError) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapDisposable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">, disposable: ()</span></span></span></span> -&gt; T) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br>  MapDisposable ist ebenfalls eingeschränkt: Nehmen Sie die Map-Oberfläche und kopieren Sie die <code>contains</code> Methoden, <code>add</code> und <code>remove</code> sie.  Die <code>add</code> Methode unterscheidet sich von Map: Das zweite Argument ist das Lambda für Schönheit und Bequemlichkeit.  Der Vorteil ist, dass wir das Lambda synchronisieren können, um unerwartete <b>Rennbedingungen</b> zu vermeiden.  Aber wir werden nicht darüber reden, wir werden weiter über Architektur sprechen. <br><br><h3>  Schnittstellenimplementierung </h3><br>  Wir haben alle Schnittstellen deklariert und werden versuchen, etwas Einfaches zu implementieren.  Nehmen Sie <b>CompletableAct</b> und <b>SingleAct</b> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableAct</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable ) : Act <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleAct</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : Any</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> single: Single&lt;T&gt; ) : Act</code> </pre> <br>  CompletableAct ist ein Wrapper über Completable.  In unserem Fall enthält es einfach eine ID - was wir brauchen.  SingleAct ist fast das gleiche.  Wir können Maybe und Flowable ebenfalls implementieren, bleiben aber bei den ersten beiden Implementierungen. <br><br>  Für Single haben wir den generischen Typ <code>&lt;T : Any&gt;</code> .  Als Kotlin-Entwickler bevorzuge ich einen solchen Ansatz. <br><br><blockquote>  Versuchen Sie, Nicht-Null-Generika zu verwenden. </blockquote><br>  Nachdem wir nun eine Reihe von Schnittstellen haben, implementieren wir eine Logik, um die Ausführung derselben Anforderungen zu verhindern. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> map: MapDisposable ): ActExecutor { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; { log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - in progress"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startExecution(act, e) log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Started"</span></span>) } }</code> </pre> <br>  Wir nehmen eine Karte und prüfen, ob eine Anfrage darin enthalten ist.  Wenn nicht, beginnen wir mit der Ausführung der Anforderung und fügen sie zur Laufzeit zur Map hinzu.  Löschen Sie nach der Ausführung mit einem Ergebnis: Fehler oder Erfolg die Anforderung aus Map. <br><br>  Für sehr aufmerksame - es gibt keine Synchronisation, aber die Synchronisation ist im Quellcode auf GitHub. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startExecution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> removeFromMap = { mapDisposable.remove(act.id) } mapDisposable.add(act.id) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> CompletableAct -&gt; act.completable .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SingleAct&lt;*&gt; -&gt; act.single .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException() } }</code> </pre> <br><blockquote>  Verwenden Sie Lambdas als letztes Argument, um die Lesbarkeit des Codes zu verbessern.  Es ist wunderschön und Ihre Kollegen werden es Ihnen danken. </blockquote><br>  Wir werden weitere Kotlin-Chips verwenden und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterungsfunktionen</a> für Completable und Single hinzufügen.  Mit ihnen müssen wir nicht nach einer Factory-Methode suchen, um einen CompletableAct und einen SingleAct zu erstellen - wir werden sie über Erweiterungsfunktionen erstellen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Completable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = CompletableAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T: Any&gt;</span></span></span><span class="hljs-function"> Single</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = SingleAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><blockquote>  Erweiterungsfunktionen können zu jeder Klasse hinzugefügt werden. </blockquote><br><h3>  Ergebnis </h3><br>  Wir haben mehrere Komponenten und eine sehr einfache Logik implementiert.  Nun ist die Hauptregel, die wir befolgen müssen, <b>kein Abonnement von Hand zu erzwingen</b> .  Wenn wir etwas ausführen möchten, geben wir es über Executor.  Ebenso wie mit Thread - niemand startet sie selbst. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) executor.apply { execute(act()) execute(act()) execute(act()) } Hello - Act Started Hello - Act Duplicate Hello - Act Duplicate Hello - Act Finished</code> </pre> <br>  Wir haben uns einmal im Team geeinigt, und jetzt gibt es immer eine Garantie dafür, dass die Ressourcen unserer Anwendung nicht für die Ausführung identischer und unnötiger Anforderungen verwendet werden. <br><br>  Das erste Problem wurde gelöst.  Erweitern wir nun die Lösung, um sie flexibel zu gestalten. <br><br><h2>  Problem Nummer 2: Welche Aufgabe muss abgebrochen werden? </h2><br>  Sowie in Fällen, in denen <b>eine nachfolgende Anfrage storniert werden muss</b> , müssen wir möglicherweise die vorherige stornieren.  Zum Beispiel haben wir die Informationen über unseren Benutzer zum ersten Mal bearbeitet und an den Server gesendet.  Aus irgendeinem Grund dauerte der Versand lange und wurde nicht abgeschlossen.  Wir haben das Benutzerprofil erneut bearbeitet und dieselbe Anfrage ein zweites Mal gesendet.  In diesem Fall ist es nicht sinnvoll, eine spezielle ID für die Anforderung zu generieren. Die Informationen aus dem zweiten Versuch sind relevanter und die <b>vorherige Anforderung wird abgebrochen</b> . <br><br>  Die aktuelle Lösung funktioniert nicht, da die Ausführung der Anforderung immer mit relevanten Informationen abgebrochen wird.  Wir müssen die Lösung irgendwie erweitern, um das Problem zu umgehen und mehr Flexibilität zu schaffen.  Verstehen Sie dazu, was wir alle wollen?  Aber wir wollen verstehen, welche Aufgabe abzubrechen ist, wie man sie nicht kopiert und einfügt und wie man sie nennt. <br><br><h3>  Komponenten hinzufügen </h3><br>  Wir nennen Strategien für das Abfrageverhalten und erstellen zwei Schnittstellen für diese: <b>StrategyHolder</b> und <b>Strategy</b> .  Wir erstellen auch 2 Objekte, die für die anzuwendende Strategie verantwortlich sind. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KillMe</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Strategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SaveMe : Strategy()</code> </pre> <br>  Ich benutze keine <b>Aufzählung</b> - ich mag die <b>versiegelte Klasse mehr</b> .  Sie sind leichter, verbrauchen weniger Speicher und lassen sich einfacher und bequemer erweitern. <br><br><blockquote>  Die versiegelte Klasse ist einfacher zu erweitern und kürzer zu schreiben. </blockquote><br><h3>  Bestehende Komponenten aktualisieren </h3><br>  An diesem Punkt ist alles einfach.  Wir hatten eine einfache Oberfläche, jetzt wird es der Erbe von StrategyHolder sein.  Da es sich um Schnittstellen handelt, gibt es kein Problem mit der Vererbung.  Bei der Implementierung von CompletableAct fügen wir eine weitere <code>override</code> und fügen dort den Standardwert hinzu, um sicherzustellen, dass die Änderungen mit dem vorhandenen Code kompatibel bleiben. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe ) : Act</code> </pre> <br><h3>  Strategien </h3><br>  Ich habe mich für die <b>SaveMe-</b> Strategie entschieden, die mir offensichtlich erscheint.  Diese Strategie storniert nur die folgenden Anforderungen - die erste Anforderung bleibt immer bestehen, bis sie abgeschlossen ist. <br><br>  Wir haben ein wenig an unserer Implementierung gearbeitet.  Wir hatten eine Ausführungsmethode und jetzt haben wir dort eine Strategieprüfung hinzugefügt. <br><br><ul><li>  Wenn die <b>SaveMe-</b> Strategie dieselbe ist wie zuvor, hat sich nichts geändert. <br></li><li>  Wenn die Strategie <b>KillMe</b> ist, <b>beenden Sie</b> die vorherige Anforderung und starten Sie eine neue. <br></li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { map.remove(act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) }</code> </pre> <br><h3>  Ergebnis </h3><br>  Wir konnten Strategien einfach verwalten, indem wir ein Minimum an Code geschrieben haben.  Gleichzeitig sind unsere Kollegen glücklich und wir können so etwas tun. <br><br><pre> <code class="kotlin hljs">executor.apply { execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello«, KillMe)) } Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Finished</span></span></code> </pre> <br>  Wir erstellen eine asynchrone Aufgabe, übergeben die Strategie und jedes Mal, wenn wir eine neue Aufgabe starten, werden alle vorherigen und nicht die nächsten Aufgaben abgebrochen. <br><br><h2>  Problem Nummer 3: Strategien reichen nicht aus </h2><br>  Kommen wir zu einem interessanten Problem, auf das ich bei einigen Projekten gestoßen bin.  Wir werden unsere Lösung erweitern, um kompliziertere Fälle zu behandeln.  Einer dieser Fälle, der insbesondere für soziale Netzwerke relevant ist, ist <b>„Gefällt mir / Gefällt mir nicht“</b> .  Es gibt einen Beitrag, den wir mögen möchten, aber als Entwickler möchten wir nicht die gesamte Benutzeroberfläche blockieren und den Dialog im Vollbildmodus mit Laden anzeigen, bis die Anforderung abgeschlossen ist.  Ja, und der Benutzer wird unglücklich sein.  Wir wollen den Benutzer täuschen: Er drückt den Knopf und als ob das schon passiert wäre - hat eine schöne Animation begonnen.  Aber tatsächlich gab es kein Vergleich - wir warten, bis die Täuschung wahr wird.  Um Betrug zu verhindern, müssen wir Abneigungen gegen den Benutzer transparent behandeln. <br><br>  Es wäre schön, dies richtig zu handhaben, damit der Benutzer das gewünschte Ergebnis erhält.  Für uns als Entwickler ist es jedoch schwierig, jedes Mal <b>unterschiedliche, sich gegenseitig ausschließende Anforderungen zu</b> bearbeiten. <br><br>  Es gibt zu viele Fragen.  Wie kann man verstehen, dass Abfragen zusammenhängen?  Wie speichere ich diese Verbindungen?  Wie gehe ich mit komplexen Skripten um und nicht mit Kopieren und Einfügen?  Wie benenne ich neue Komponenten?  Die Aufgaben sind komplex und das, was wir bereits implementiert haben, ist für die Lösung nicht geeignet. <br><br><h3>  Gruppen und Strategien für Gruppen </h3><br>  Erstellen Sie eine einfache Schnittstelle mit dem Namen <b>GroupStrategyHolder</b> .  Es ist etwas komplizierter - zwei Felder statt eines. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> KillGroup : GroupStrategy()</code> </pre> <br>  Zusätzlich zur Strategie für eine bestimmte Anfrage führen wir eine neue Entität ein - eine Gruppe von Anfragen.  Diese Gruppe wird auch Strategien haben.  Wir werden nur die einfachste Option mit zwei Strategien betrachten: <b>Standard</b> - die Standardstrategie, wenn wir nichts mit Abfragen tun, und <b>KillGroup</b> - beendet alle vorhandenen Abfragen aus der Gruppe und startet eine neue. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy = Default <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String = <span class="hljs-string"><span class="hljs-string">""</span></span> ) : Act</code> </pre><br>  Wir wiederholen die Schritte, über die ich zuvor gesprochen habe: Wir nehmen die Schnittstelle, erweitern sie und fügen CompletableAct und SingleAct zwei zusätzliche Felder hinzu. <br><br><h3>  Implementierung aktualisieren </h3><br>  Wir kehren zur Execute-Methode zurück.  Die dritte Aufgabe ist komplizierter, aber die Lösung ist recht einfach: Wir überprüfen die Gruppenstrategie auf eine bestimmte Anforderung und, wenn es sich um KillGroup handelt, beenden wir die gesamte Gruppe und führen die übliche Logik aus. <br><br><pre> <code class="kotlin hljs">MapDisposable -&gt; GroupDisposable ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (act.groupStrategy == KillGroup) groupDisposable.removeGroup(act.groupKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { groupDisposable.contains(act.groupKey, act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { stop(act.groupKey, act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) } }</code> </pre> <br>  Das Problem ist komplex, aber wir haben bereits eine ziemlich angemessene Infrastruktur - wir können es erweitern und das Problem lösen.  Was müssen wir jetzt tun, wenn Sie sich unser Ergebnis ansehen? <br><br><h3>  Ergebnis </h3><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>= Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct( id = id, groupStrategy = KillGroup, groupKey = <span class="hljs-string"><span class="hljs-string">"Like-Dislike-PostId-1234"</span></span> ) executor.apply { execute(act(“Like”)) execute(act(“Dislike”)) execute(act(“Like”)) } Like - Act Started Like - Act Canceled Dislike - Act Started Dislike - Act Canceled Like - Act Started Like - Act Finished</code> </pre> <br>  Wenn wir solch komplexe Abfragen benötigen, fügen wir zwei Felder hinzu: groupStrategy und group ID.  Die Gruppen-ID ist ein spezifischer Parameter, da Sie zur Unterstützung vieler paralleler Like / Dislike-Anforderungen eine Gruppe für jedes Anforderungspaar erstellen müssen, das zum selben Objekt gehört.  In diesem Fall können Sie die Gruppe Like-Dislike-PostId benennen und dort die Post-ID hinzufügen.  Jedes Mal, wenn wir die benachbarten Beiträge mögen, werden wir sicher sein, dass alles für den vorherigen und den nächsten Beitrag korrekt funktioniert. <br><br>  In unserem synthetischen Beispiel versuchen wir, eine Like-Dislike-Like-Sequenz auszuführen.  Wenn wir die erste und dann die zweite Aktion ausführen, wird die vorherige abgebrochen und die nächste wie die vorherige Abneigung.  Das wollte ich. <br><br>  Im letzten Beispiel haben wir benannte Parameter verwendet, um Acts zu erstellen.  Dies trägt zur besseren Lesbarkeit des Codes bei, insbesondere wenn viele Parameter vorhanden sind. <br><br><blockquote>  Verwenden Sie zum leichteren Lesen benannte Parameter. </blockquote><br><h2>  Architektur </h2><br>  Mal sehen, wie sich diese Entscheidung auf unsere Architektur auswirken kann.  Bei Projekten sehe ich oft, dass das Ansichtsmodell oder der Präsentator viel Verantwortung übernehmen, wie z. B. Hacks, um die Situation irgendwie mit "Gefällt mir" / "Gefällt mir nicht" zu behandeln.  Normalerweise all diese Logik im Ansichtsmodell: viel doppelter Code mit Tastensperre, LifeCycle-Handler, Abonnements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2c/a94/35b/d2ca9435bf58a6a261edbf1e7eb046ba.png"><br><br>  Alles, was unser Executor jetzt tut, war einmal in Presenter oder View Model.  Wenn die Architektur ausgereift ist, könnten die Entwickler diese Logik auf eine Art Interaktor oder Anwendungsfall übertragen, aber die Logik wurde an mehreren Stellen dupliziert. <br><br>  Nachdem wir Executor übernommen haben, wird das Ansichtsmodell einfacher und die gesamte Logik ist ihnen verborgen.  Wenn Sie dies einmal zu Presenter und dem Interaktor gebracht haben, wissen Sie, dass der Interaktor und der Presenter einfacher werden.  Im Allgemeinen war ich zufrieden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef8/215/4c3/ef82154c3a09b62d063ed02ff4d40267.png"><br><br><h2>  Was noch hinzuzufügen? </h2><br>  Ein weiteres Plus der aktuellen Lösung ist, dass sie erweiterbar ist.  Was möchten wir noch als Entwickler hinzufügen, die an einer mobilen Anwendung arbeiten und jeden Tag mit Fehlern und vielen gleichzeitigen Anfragen zu kämpfen haben? <br><br><h3>  Die Möglichkeiten </h3><br>  Die <b>Implementierung des Lebenszyklus</b> blieb hinter den Kulissen, aber als mobile Entwickler denken wir alle immer darüber nach und sorgen uns, dass nichts wegfließt.  Ich möchte Anwendungsneustartanforderungen <b>speichern und wiederherstellen</b> . <br><br>  <b>Anrufketten.</b>  Durch das Umschließen von RX-Ketten wird es möglich, diese zu serialisieren, da RX standardmäßig nicht serialisiert. <br><br>  Nur wenige Benutzer wissen, wie viele gleichzeitige Anforderungen zu einem bestimmten Zeitpunkt in ihren Anwendungen ausgeführt werden.  Ich würde nicht sagen, dass dies ein großes Problem für kleine und mittlere Anwendungen ist.  Für eine große Anwendung, die im Hintergrund viel Arbeit leistet, ist es jedoch hilfreich, die Ursachen für Abstürze und Benutzerbeschwerden zu verstehen.  Ohne zusätzliche Infrastruktur haben Entwickler einfach keine Informationen, um den Grund zu verstehen: Vielleicht liegt der Grund in der Benutzeroberfläche oder in einer großen Anzahl ständiger Anfragen im Hintergrund.  Wir können unsere Lösung erweitern und <b>Metriken</b> hinzufügen. <br><br>  Lassen Sie uns die Möglichkeiten genauer betrachten. <br><br><h3>  Lebenszyklusverarbeitung </h3><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span></span>( lifecycle: Lifecycle ) : ActExecutor { inir { lifecycle.doOnDestroy { cancelAll() } } ...</code> </pre> <br>  Dies ist ein Beispiel für eine Lebenszyklusimplementierung.  Im einfachsten Fall: <code>Destroy</code> Fragmente <code>Destroy</code> oder mit <code>Activity</code> abgebrochen werden, übergeben wir <b>den Lifecycle-Handler an unseren Executor</b> . Wenn <b>das Ereignis onDestroy auftritt, löschen wir alle Anforderungen</b> .  Dies ist eine einfache Lösung, bei der kein ähnlicher Code in Ansichtsmodelle kopiert und eingefügt werden muss.  LifeData macht ungefähr das Gleiche. <br><br><h3>  Speichern / Wiederherstellen </h3><br>  Da wir Wrapper haben, können wir <b>separate Klassen für Acts</b> erstellen, in denen Logik zum Erstellen asynchroner Aufgaben vorhanden ist.  Außerdem können wir diesen Namen in der Datenbank speichern und <b>beim Start</b> der <b>Anwendung</b> mit der Factory-Methode oder ähnlichem <b>aus der Datenbank wiederherstellen</b> . <br><br>  Gleichzeitig erhalten wir die Möglichkeit, offline zu arbeiten, und starten die Anforderungen neu, die mit Fehlern abgeschlossen wurden, wenn das Internet angezeigt wird.  In Abwesenheit des Internets oder bei Anforderungsfehlern speichern wir diese in der Datenbank und stellen sie dann wieder her und führen sie erneut aus.  Wenn Sie dies mit normalem RX ohne zusätzliche Wrapper tun können, schreiben Sie bitte in die Kommentare, es wäre interessant. <br><br><h3>  Ketten anrufen </h3><br>  Wir können auch <b>unsere Taten binden</b> .  Eine weitere Erweiterungsoption ist <b>das Ausführen von Abfrageketten</b> .  Sie haben beispielsweise eine Entität, die auf dem Server erstellt werden muss, und eine andere Entität, die von der ersten abhängt, muss genau zu dem Zeitpunkt erstellt werden, zu dem wir sicher sind, dass die erste Anforderung erfolgreich war.  Dies kann auch durchgeführt werden.  Dies ist natürlich nicht so trivial, aber eine Klasse, die den Start aller asynchronen Aufgaben steuert, ist möglich.  Die Verwendung von Bare RX ist schwieriger. <br><br><h3>  Metriken </h3><br>  Es ist interessant zu sehen, <b>wie viele parallele Abfragen durchschnittlich im Hintergrund ausgeführt werden</b> .  Mit Metriken können Sie die Ursache für Benutzerbeschwerden über Lethargie verstehen.  Zumindest können wir die Ausführung im Hintergrund dessen, was wir nicht erwartet hatten, aus der Liste der Gründe ausschließen. <br><br>          ,  , , <b>   </b>  ,   -    -    10%   .    ,    . <br><br><h2>  Fazit </h2><br> <b>  </b> —  ,    . «»      .       ,         ,  ,  ,    . <br><br>       ,      ,   .   —   - , ,  —   .    — .  ,           .       . <b>      </b> . <br><br> <b>     </b> .    Kotlin,              . , <b>    </b> . <br><br><blockquote>       AppsConf 2018,      <b> AppsConf 2019</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>  38 : ,  Android, UX, , - , , Kotlin. <br><br>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">youtube-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    <b>22–23 </b>    . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437592/">https://habr.com/ru/post/de437592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437582/index.html">Übersicht über Vue.js 2.6</a></li>
<li><a href="../de437584/index.html">Die mathematischen Grundlagen des automatischen Layouts</a></li>
<li><a href="../de437586/index.html">Wir erstellen eine Sprachanwendung am Beispiel von Google Assistant</a></li>
<li><a href="../de437588/index.html">Macht es mehr Spaß, für Mobiltelefone als für das Internet zu entwickeln?</a></li>
<li><a href="../de437590/index.html">Latenzzahlen auf dem iPhone</a></li>
<li><a href="../de437594/index.html">Wie ich die Ursache für Stottern und Frame-Skipping in allen Spielen beseitigt und versehentlich die Temperatur um 15 Grad gesenkt habe</a></li>
<li><a href="../de437596/index.html">OTRS: LDAP-Authentifizierung, Autorisierung und Synchronisation (FreeIPA, AD)</a></li>
<li><a href="../de437598/index.html">So speichern Sie das Spielsystem mithilfe der Virtualisierung vom Heim-PC</a></li>
<li><a href="../de437600/index.html">opencv4arts: Zeichne meine Stadt, Vincent</a></li>
<li><a href="../de437602/index.html">Profilieren Sie ein Unity-Projekt mit Android Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>