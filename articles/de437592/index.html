<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª ‚öΩÔ∏è üìÆ Asynchrone Task Execution Layer-Architektur üôÜüèø üß¶ üë®üèæ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In mobilen Anwendungen von sozialen Netzwerken mag der Benutzer, schreibt einen Kommentar, bl√§ttert dann durch den Feed, startet das Video und setzt d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchrone Task Execution Layer-Architektur</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437592/">  In mobilen Anwendungen von sozialen Netzwerken mag der Benutzer, schreibt einen Kommentar, bl√§ttert dann durch den Feed, startet das Video und setzt das Gleiche erneut.  All dies ist schnell und fast gleichzeitig.  Wenn die Implementierung der Gesch√§ftslogik der Anwendung vollst√§ndig blockiert ist, kann der Benutzer erst dann zum Band gehen, wenn dergleichen zum Aufzeichnen mit Siegeln geladen ist.  Der Benutzer wird jedoch nicht warten, daher funktionieren in den meisten mobilen Anwendungen asynchrone Aufgaben, die unabh√§ngig voneinander gestartet und ausgef√ºhrt werden.  Der Benutzer f√ºhrt mehrere Aufgaben gleichzeitig aus und blockiert sich nicht gegenseitig.  Eine asynchrone Aufgabe wird gestartet und ausgef√ºhrt, w√§hrend der Benutzer die n√§chste startet. <br><br><img src="https://habrastorage.org/webt/on/8u/ys/on8uys9oib69dbqrfu4xfnnq-0u.png"><br><br>  Bei der Entschl√ºsselung des Berichts von <b>Stepan Goncharov</b> auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf werden</a> wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf die</a> Asynchronit√§t <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eingehen</a> : Wir werden uns mit der Architektur mobiler Anwendungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">befassen,</a> diskutieren, warum wir eine separate Schicht f√ºr die Ausf√ºhrung asynchroner Aufgaben trennen m√ºssen, wir werden die Anforderungen und vorhandenen L√∂sungen analysieren, wir werden die Vor- und Nachteile analysieren und eine der Implementierungen dieses Ansatzes betrachten.  Wir lernen auch, wie asynchrone Aufgaben verwaltet werden, warum jede Aufgabe ihre eigene ID hat, welche Ausf√ºhrungsstrategien gelten und wie sie die Entwicklung der gesamten Anwendung vereinfachen und beschleunigen. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tBC5Zoxcgbk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>√úber den Sprecher: Stepan Goncharov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">stepango</a> ) arbeitet bei Grab - es ist wie bei Uber, aber in S√ºdostasien.  Er ist seit mehr als 9 Jahren in der Android-Entwicklung t√§tig.  Interessiert an Kotlin seit 2014 und seit 2016 - verwendet es im Produkt.  Organisiert von der Kotlin User Group in Singapur.  Dies ist einer der Gr√ºnde, warum alle Codebeispiele auf Kotlin sein werden und nicht, weil es in Mode ist. <br><br>  Wir werden uns einen Ansatz zum Entwerfen der Komponenten Ihrer Anwendung ansehen.  Dies ist eine Handlungsanleitung f√ºr diejenigen, die der Anwendung neue Komponenten hinzuf√ºgen, diese bequem entwerfen und dann erweitern m√∂chten.  iOS-Entwickler k√∂nnen den iOS-Ansatz verwenden.  Der Ansatz gilt auch f√ºr andere Plattformen.  Ich interessiere mich seit 2014 f√ºr Kotlin, daher werden alle Beispiele in dieser Sprache sein.  Aber keine Sorge - Sie k√∂nnen dasselbe in Swift, Objective-C und anderen Sprachen schreiben. <br><br>  Beginnen wir mit den Problemen und Nachteilen von <b>Reactive Extensions</b> .  Probleme sind typisch f√ºr andere asynchrone Grundelemente, daher sagen wir RX - denken Sie an die Zukunft und das Versprechen, und alles wird √§hnlich funktionieren. <br><br><h2>  RX-Probleme </h2><br>  <b>Hohe Eintrittsschwelle</b> .  RX ist recht komplex und gro√ü - es hat 270 Bediener und es ist nicht einfach, dem gesamten Team den richtigen Umgang damit beizubringen.  Wir werden dieses Problem nicht diskutieren - es geht √ºber den Rahmen des Berichts hinaus. <br><br>  In RX m√ºssen Sie <b>Ihre Abonnements manuell verwalten und den Lebenszyklus der Anwendung √ºberwachen</b> .  Wenn Sie Single oder Observable bereits abonniert haben, k√∂nnen Sie <b>es nicht mit einem anderen SIngle vergleichen</b> , da Sie immer ein neues Objekt erhalten und es zur Laufzeit immer andere Abonnements gibt.  <b>In RX gibt es keine M√∂glichkeit, Abonnements und Streams zu vergleichen</b> . <br><br>  Wir werden versuchen, einige dieser Probleme zu l√∂sen.  Wir werden jedes Problem einmal l√∂sen und dann das Ergebnis wiederverwenden. <br><br><h2>  Problem Nummer 1: Eine Aufgabe mehrmals ausf√ºhren </h2><br>  Ein h√§ufiges Problem bei der Entwicklung ist unn√∂tiges Arbeiten und mehrmaliges Wiederholen derselben Aufgaben.  Stellen Sie sich vor, wir haben ein Formular zur Dateneingabe und eine Schaltfl√§che zum Speichern.  Wenn diese Taste gedr√ºckt wird, wird eine Anfrage gesendet. Wenn Sie jedoch w√§hrend des Speicherns des Formulars mehrmals auf klicken, werden mehrere identische Anfragen gesendet.  Wir haben den Knopf zum Testen der Qualit√§tssicherung gegeben, sie haben 40 Mal in einer Sekunde gedr√ºckt - wir haben 40 Anfragen erhalten, weil zum Beispiel die Animation keine Zeit zum Arbeiten hatte. <br><br>  Wie l√∂se ich das Problem?  Jeder Entwickler hat seinen eigenen bevorzugten L√∂sungsansatz: Einer h√§lt eine <code>debounce</code> , der andere blockiert die Schaltfl√§che f√ºr alle F√§lle durch <code>clickable = false</code> .  Es gibt keinen allgemeinen Ansatz, daher werden diese Fehler in unserer Anwendung entweder angezeigt oder verschwinden.  Wir l√∂sen das Problem nur, wenn die Qualit√§tssicherung uns sagt: "Oh, ich habe hier geklickt und es ist kaputt gegangen"! <br><br><h3>  Eine skalierbare L√∂sung? </h3><br>  Um solche Situationen zu vermeiden, werden wir RX oder ein anderes asynchrones Framework umbrechen - <b>wir werden allen asynchronen Operationen IDs hinzuf√ºgen</b> .  Die Idee ist einfach - wir brauchen eine M√∂glichkeit, sie zu vergleichen, da diese Methode normalerweise nicht in den Frameworks enthalten ist.  Wir k√∂nnen die Aufgabe abschlie√üen, wissen jedoch nicht, ob sie bereits abgeschlossen wurde oder nicht. <br><br>  Nennen wir unseren Wrapper "Act" - andere Namen sind bereits vergeben.  Erstellen Sie dazu kleine <code>typealias</code> und eine einfache <code>interface</code> in der es nur ein Feld gibt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Id = String <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id }</code> </pre> <br>  Dies ist praktisch und reduziert die Codemenge geringf√ºgig.  Wenn es String sp√§ter nicht gef√§llt, werden wir es durch etwas anderes ersetzen.  In diesem kleinen Code beobachten wir eine lustige Tatsache. <br><br><blockquote>  Schnittstellen k√∂nnen Eigenschaften enthalten. </blockquote><br>  F√ºr Programmierer, die aus Java kommen, ist dies unerwartet.  Normalerweise f√ºgen sie <code>getId()</code> -Methoden in die Schnittstelle ein, aber dies ist aus Sicht von Kotlin die falsche L√∂sung. <br><br><h3>  Wie werden wir gestalten? </h3><br>  Ein kleiner Exkurs.  Beim Entwerfen halte ich mich an zwei Prinzipien.  Die erste besteht darin <b>, die Komponentenanforderungen und die Implementierung in kleine Teile zu zerlegen</b> .  Dies erm√∂glicht eine detaillierte Kontrolle √ºber das Schreiben von Code.  Wenn Sie eine gro√üe Komponente erstellen und versuchen, alles auf einmal zu erledigen, ist dies schlecht.  Normalerweise funktioniert diese Komponente nicht und Sie beginnen mit dem Einsetzen von Kr√ºcken. Ich fordere Sie daher dringend auf, in kleinen kontrollierten Schritten zu schreiben und sie zu genie√üen.  Das zweite Prinzip besteht <b>darin, die Funktionsf√§higkeit</b> nach jedem Schritt <b>zu √ºberpr√ºfen</b> und <b>den Vorgang</b> erneut zu <b>wiederholen</b> . <br><br><h3>  Warum reicht der Ausweis nicht aus? </h3><br>  Kommen wir zur√ºck zum Problem.  Wir haben den ersten Schritt gemacht - wir haben eine ID hinzugef√ºgt und alles war einfach - die Schnittstelle und das Feld.  Dies hat uns nichts gebracht, da die Schnittstelle keine Implementierung enth√§lt und nicht alleine funktioniert, aber Sie k√∂nnen Vorg√§nge vergleichen. <br><br>  Als n√§chstes werden wir Komponenten hinzuf√ºgen, die es uns erm√∂glichen, die Schnittstelle zu verwenden und zu verstehen, dass wir eine Art Anfrage ein zweites Mal ausf√ºhren m√∂chten, wenn dies nicht erforderlich ist.  Als erstes werden wir <b>neue Abstraktionen einf√ºhren</b> . <br><br><h3>  Einf√ºhrung neuer Abstraktionen: MapDisposable </h3><br>  Es ist wichtig, den richtigen Namen und die richtige Abstraktion zu w√§hlen, die Entwicklern bekannt sind, die in Ihrer Codebasis arbeiten.  Da ich Beispiele f√ºr RX habe, werden wir das RX-Konzept und √§hnliche Namen verwenden wie die Bibliotheksentwickler.  So k√∂nnen wir unseren Kollegen leicht erkl√§ren, was sie getan haben, warum und wie es funktionieren sollte.  Informationen zum Ausw√§hlen eines Namens finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompositeDiposable-Dokumentation</a> . <br><br>  Erstellen wir eine kleine MapDisposable-Oberfl√§che, <b>die Informationen</b> zu aktuellen Aufgaben enth√§lt und <b>beim L√∂schen</b> dispose <b>() aufruft</b> .  Ich werde die Implementierung nicht geben, Sie k√∂nnen alle Quellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf meinem GitHub sehen</a> . <br><br>  Wir nennen MapDisposable auf diese Weise, da die Komponente wie eine Map funktioniert, jedoch CompositeDiposable-Eigenschaften aufweist. <br><br><h3>  Einf√ºhrung neuer Abstraktionen: ActExecutor </h3><br>  Die n√§chste abstrakte Komponente ist <b>ActExecutor.</b>  Es startet oder startet keine neuen Aufgaben, h√§ngt von MapDisposable ab und delegiert die Fehlerbehandlung.  So w√§hlen Sie einen Namen aus - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe Dokumentation</a> . <br><br>  Nehmen Sie die n√§chste Analogie aus dem JDK.  Es hat einen Executor, in dem Sie Thread √ºbergeben und etwas tun k√∂nnen.  Es scheint mir, dass dies eine coole Komponente ist und gut gestaltet, also nehmen wir es als Grundlage. <br><br>  Wir erstellen ActExecutor und eine einfache Schnittstelle daf√ºr, wobei wir dem Prinzip einfacher kleiner Schritte folgen.  Der Name selbst sagt, dass es eine Komponente ist, an die wir etwas √ºbertragen, und es beginnt, etwas zu tun.  ActExecutor hat eine Methode, mit der wir <code>Act</code> und f√ºr alle F√§lle Fehler behandeln, denn ohne sie gibt es keinen Weg. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = ::logError) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapDisposable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">, disposable: ()</span></span></span></span> -&gt; T) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br>  MapDisposable ist ebenfalls eingeschr√§nkt: Nehmen Sie die Map-Oberfl√§che und kopieren Sie die <code>contains</code> Methoden, <code>add</code> und <code>remove</code> sie.  Die <code>add</code> Methode unterscheidet sich von Map: Das zweite Argument ist das Lambda f√ºr Sch√∂nheit und Bequemlichkeit.  Der Vorteil ist, dass wir das Lambda synchronisieren k√∂nnen, um unerwartete <b>Rennbedingungen</b> zu vermeiden.  Aber wir werden nicht dar√ºber reden, wir werden weiter √ºber Architektur sprechen. <br><br><h3>  Schnittstellenimplementierung </h3><br>  Wir haben alle Schnittstellen deklariert und werden versuchen, etwas Einfaches zu implementieren.  Nehmen Sie <b>CompletableAct</b> und <b>SingleAct</b> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableAct</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable ) : Act <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleAct</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : Any</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> single: Single&lt;T&gt; ) : Act</code> </pre> <br>  CompletableAct ist ein Wrapper √ºber Completable.  In unserem Fall enth√§lt es einfach eine ID - was wir brauchen.  SingleAct ist fast das gleiche.  Wir k√∂nnen Maybe und Flowable ebenfalls implementieren, bleiben aber bei den ersten beiden Implementierungen. <br><br>  F√ºr Single haben wir den generischen Typ <code>&lt;T : Any&gt;</code> .  Als Kotlin-Entwickler bevorzuge ich einen solchen Ansatz. <br><br><blockquote>  Versuchen Sie, Nicht-Null-Generika zu verwenden. </blockquote><br>  Nachdem wir nun eine Reihe von Schnittstellen haben, implementieren wir eine Logik, um die Ausf√ºhrung derselben Anforderungen zu verhindern. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> map: MapDisposable ): ActExecutor { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; { log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - in progress"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startExecution(act, e) log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Started"</span></span>) } }</code> </pre> <br>  Wir nehmen eine Karte und pr√ºfen, ob eine Anfrage darin enthalten ist.  Wenn nicht, beginnen wir mit der Ausf√ºhrung der Anforderung und f√ºgen sie zur Laufzeit zur Map hinzu.  L√∂schen Sie nach der Ausf√ºhrung mit einem Ergebnis: Fehler oder Erfolg die Anforderung aus Map. <br><br>  F√ºr sehr aufmerksame - es gibt keine Synchronisation, aber die Synchronisation ist im Quellcode auf GitHub. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startExecution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> removeFromMap = { mapDisposable.remove(act.id) } mapDisposable.add(act.id) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> CompletableAct -&gt; act.completable .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SingleAct&lt;*&gt; -&gt; act.single .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException() } }</code> </pre> <br><blockquote>  Verwenden Sie Lambdas als letztes Argument, um die Lesbarkeit des Codes zu verbessern.  Es ist wundersch√∂n und Ihre Kollegen werden es Ihnen danken. </blockquote><br>  Wir werden weitere Kotlin-Chips verwenden und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erweiterungsfunktionen</a> f√ºr Completable und Single hinzuf√ºgen.  Mit ihnen m√ºssen wir nicht nach einer Factory-Methode suchen, um einen CompletableAct und einen SingleAct zu erstellen - wir werden sie √ºber Erweiterungsfunktionen erstellen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Completable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = CompletableAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T: Any&gt;</span></span></span><span class="hljs-function"> Single</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = SingleAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><blockquote>  Erweiterungsfunktionen k√∂nnen zu jeder Klasse hinzugef√ºgt werden. </blockquote><br><h3>  Ergebnis </h3><br>  Wir haben mehrere Komponenten und eine sehr einfache Logik implementiert.  Nun ist die Hauptregel, die wir befolgen m√ºssen, <b>kein Abonnement von Hand zu erzwingen</b> .  Wenn wir etwas ausf√ºhren m√∂chten, geben wir es √ºber Executor.  Ebenso wie mit Thread - niemand startet sie selbst. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) executor.apply { execute(act()) execute(act()) execute(act()) } Hello - Act Started Hello - Act Duplicate Hello - Act Duplicate Hello - Act Finished</code> </pre> <br>  Wir haben uns einmal im Team geeinigt, und jetzt gibt es immer eine Garantie daf√ºr, dass die Ressourcen unserer Anwendung nicht f√ºr die Ausf√ºhrung identischer und unn√∂tiger Anforderungen verwendet werden. <br><br>  Das erste Problem wurde gel√∂st.  Erweitern wir nun die L√∂sung, um sie flexibel zu gestalten. <br><br><h2>  Problem Nummer 2: Welche Aufgabe muss abgebrochen werden? </h2><br>  Sowie in F√§llen, in denen <b>eine nachfolgende Anfrage storniert werden muss</b> , m√ºssen wir m√∂glicherweise die vorherige stornieren.  Zum Beispiel haben wir die Informationen √ºber unseren Benutzer zum ersten Mal bearbeitet und an den Server gesendet.  Aus irgendeinem Grund dauerte der Versand lange und wurde nicht abgeschlossen.  Wir haben das Benutzerprofil erneut bearbeitet und dieselbe Anfrage ein zweites Mal gesendet.  In diesem Fall ist es nicht sinnvoll, eine spezielle ID f√ºr die Anforderung zu generieren. Die Informationen aus dem zweiten Versuch sind relevanter und die <b>vorherige Anforderung wird abgebrochen</b> . <br><br>  Die aktuelle L√∂sung funktioniert nicht, da die Ausf√ºhrung der Anforderung immer mit relevanten Informationen abgebrochen wird.  Wir m√ºssen die L√∂sung irgendwie erweitern, um das Problem zu umgehen und mehr Flexibilit√§t zu schaffen.  Verstehen Sie dazu, was wir alle wollen?  Aber wir wollen verstehen, welche Aufgabe abzubrechen ist, wie man sie nicht kopiert und einf√ºgt und wie man sie nennt. <br><br><h3>  Komponenten hinzuf√ºgen </h3><br>  Wir nennen Strategien f√ºr das Abfrageverhalten und erstellen zwei Schnittstellen f√ºr diese: <b>StrategyHolder</b> und <b>Strategy</b> .  Wir erstellen auch 2 Objekte, die f√ºr die anzuwendende Strategie verantwortlich sind. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KillMe</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Strategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SaveMe : Strategy()</code> </pre> <br>  Ich benutze keine <b>Aufz√§hlung</b> - ich mag die <b>versiegelte Klasse mehr</b> .  Sie sind leichter, verbrauchen weniger Speicher und lassen sich einfacher und bequemer erweitern. <br><br><blockquote>  Die versiegelte Klasse ist einfacher zu erweitern und k√ºrzer zu schreiben. </blockquote><br><h3>  Bestehende Komponenten aktualisieren </h3><br>  An diesem Punkt ist alles einfach.  Wir hatten eine einfache Oberfl√§che, jetzt wird es der Erbe von StrategyHolder sein.  Da es sich um Schnittstellen handelt, gibt es kein Problem mit der Vererbung.  Bei der Implementierung von CompletableAct f√ºgen wir eine weitere <code>override</code> und f√ºgen dort den Standardwert hinzu, um sicherzustellen, dass die √Ñnderungen mit dem vorhandenen Code kompatibel bleiben. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe ) : Act</code> </pre> <br><h3>  Strategien </h3><br>  Ich habe mich f√ºr die <b>SaveMe-</b> Strategie entschieden, die mir offensichtlich erscheint.  Diese Strategie storniert nur die folgenden Anforderungen - die erste Anforderung bleibt immer bestehen, bis sie abgeschlossen ist. <br><br>  Wir haben ein wenig an unserer Implementierung gearbeitet.  Wir hatten eine Ausf√ºhrungsmethode und jetzt haben wir dort eine Strategiepr√ºfung hinzugef√ºgt. <br><br><ul><li>  Wenn die <b>SaveMe-</b> Strategie dieselbe ist wie zuvor, hat sich nichts ge√§ndert. <br></li><li>  Wenn die Strategie <b>KillMe</b> ist, <b>beenden Sie</b> die vorherige Anforderung und starten Sie eine neue. <br></li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { map.remove(act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) }</code> </pre> <br><h3>  Ergebnis </h3><br>  Wir konnten Strategien einfach verwalten, indem wir ein Minimum an Code geschrieben haben.  Gleichzeitig sind unsere Kollegen gl√ºcklich und wir k√∂nnen so etwas tun. <br><br><pre> <code class="kotlin hljs">executor.apply { execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello¬´, KillMe)) } Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Finished</span></span></code> </pre> <br>  Wir erstellen eine asynchrone Aufgabe, √ºbergeben die Strategie und jedes Mal, wenn wir eine neue Aufgabe starten, werden alle vorherigen und nicht die n√§chsten Aufgaben abgebrochen. <br><br><h2>  Problem Nummer 3: Strategien reichen nicht aus </h2><br>  Kommen wir zu einem interessanten Problem, auf das ich bei einigen Projekten gesto√üen bin.  Wir werden unsere L√∂sung erweitern, um kompliziertere F√§lle zu behandeln.  Einer dieser F√§lle, der insbesondere f√ºr soziale Netzwerke relevant ist, ist <b>‚ÄûGef√§llt mir / Gef√§llt mir nicht‚Äú</b> .  Es gibt einen Beitrag, den wir m√∂gen m√∂chten, aber als Entwickler m√∂chten wir nicht die gesamte Benutzeroberfl√§che blockieren und den Dialog im Vollbildmodus mit Laden anzeigen, bis die Anforderung abgeschlossen ist.  Ja, und der Benutzer wird ungl√ºcklich sein.  Wir wollen den Benutzer t√§uschen: Er dr√ºckt den Knopf und als ob das schon passiert w√§re - hat eine sch√∂ne Animation begonnen.  Aber tats√§chlich gab es kein Vergleich - wir warten, bis die T√§uschung wahr wird.  Um Betrug zu verhindern, m√ºssen wir Abneigungen gegen den Benutzer transparent behandeln. <br><br>  Es w√§re sch√∂n, dies richtig zu handhaben, damit der Benutzer das gew√ºnschte Ergebnis erh√§lt.  F√ºr uns als Entwickler ist es jedoch schwierig, jedes Mal <b>unterschiedliche, sich gegenseitig ausschlie√üende Anforderungen zu</b> bearbeiten. <br><br>  Es gibt zu viele Fragen.  Wie kann man verstehen, dass Abfragen zusammenh√§ngen?  Wie speichere ich diese Verbindungen?  Wie gehe ich mit komplexen Skripten um und nicht mit Kopieren und Einf√ºgen?  Wie benenne ich neue Komponenten?  Die Aufgaben sind komplex und das, was wir bereits implementiert haben, ist f√ºr die L√∂sung nicht geeignet. <br><br><h3>  Gruppen und Strategien f√ºr Gruppen </h3><br>  Erstellen Sie eine einfache Schnittstelle mit dem Namen <b>GroupStrategyHolder</b> .  Es ist etwas komplizierter - zwei Felder statt eines. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> KillGroup : GroupStrategy()</code> </pre> <br>  Zus√§tzlich zur Strategie f√ºr eine bestimmte Anfrage f√ºhren wir eine neue Entit√§t ein - eine Gruppe von Anfragen.  Diese Gruppe wird auch Strategien haben.  Wir werden nur die einfachste Option mit zwei Strategien betrachten: <b>Standard</b> - die Standardstrategie, wenn wir nichts mit Abfragen tun, und <b>KillGroup</b> - beendet alle vorhandenen Abfragen aus der Gruppe und startet eine neue. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy = Default <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String = <span class="hljs-string"><span class="hljs-string">""</span></span> ) : Act</code> </pre><br>  Wir wiederholen die Schritte, √ºber die ich zuvor gesprochen habe: Wir nehmen die Schnittstelle, erweitern sie und f√ºgen CompletableAct und SingleAct zwei zus√§tzliche Felder hinzu. <br><br><h3>  Implementierung aktualisieren </h3><br>  Wir kehren zur Execute-Methode zur√ºck.  Die dritte Aufgabe ist komplizierter, aber die L√∂sung ist recht einfach: Wir √ºberpr√ºfen die Gruppenstrategie auf eine bestimmte Anforderung und, wenn es sich um KillGroup handelt, beenden wir die gesamte Gruppe und f√ºhren die √ºbliche Logik aus. <br><br><pre> <code class="kotlin hljs">MapDisposable -&gt; GroupDisposable ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (act.groupStrategy == KillGroup) groupDisposable.removeGroup(act.groupKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { groupDisposable.contains(act.groupKey, act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { stop(act.groupKey, act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) } }</code> </pre> <br>  Das Problem ist komplex, aber wir haben bereits eine ziemlich angemessene Infrastruktur - wir k√∂nnen es erweitern und das Problem l√∂sen.  Was m√ºssen wir jetzt tun, wenn Sie sich unser Ergebnis ansehen? <br><br><h3>  Ergebnis </h3><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>= Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct( id = id, groupStrategy = KillGroup, groupKey = <span class="hljs-string"><span class="hljs-string">"Like-Dislike-PostId-1234"</span></span> ) executor.apply { execute(act(‚ÄúLike‚Äù)) execute(act(‚ÄúDislike‚Äù)) execute(act(‚ÄúLike‚Äù)) } Like - Act Started Like - Act Canceled Dislike - Act Started Dislike - Act Canceled Like - Act Started Like - Act Finished</code> </pre> <br>  Wenn wir solch komplexe Abfragen ben√∂tigen, f√ºgen wir zwei Felder hinzu: groupStrategy und group ID.  Die Gruppen-ID ist ein spezifischer Parameter, da Sie zur Unterst√ºtzung vieler paralleler Like / Dislike-Anforderungen eine Gruppe f√ºr jedes Anforderungspaar erstellen m√ºssen, das zum selben Objekt geh√∂rt.  In diesem Fall k√∂nnen Sie die Gruppe Like-Dislike-PostId benennen und dort die Post-ID hinzuf√ºgen.  Jedes Mal, wenn wir die benachbarten Beitr√§ge m√∂gen, werden wir sicher sein, dass alles f√ºr den vorherigen und den n√§chsten Beitrag korrekt funktioniert. <br><br>  In unserem synthetischen Beispiel versuchen wir, eine Like-Dislike-Like-Sequenz auszuf√ºhren.  Wenn wir die erste und dann die zweite Aktion ausf√ºhren, wird die vorherige abgebrochen und die n√§chste wie die vorherige Abneigung.  Das wollte ich. <br><br>  Im letzten Beispiel haben wir benannte Parameter verwendet, um Acts zu erstellen.  Dies tr√§gt zur besseren Lesbarkeit des Codes bei, insbesondere wenn viele Parameter vorhanden sind. <br><br><blockquote>  Verwenden Sie zum leichteren Lesen benannte Parameter. </blockquote><br><h2>  Architektur </h2><br>  Mal sehen, wie sich diese Entscheidung auf unsere Architektur auswirken kann.  Bei Projekten sehe ich oft, dass das Ansichtsmodell oder der Pr√§sentator viel Verantwortung √ºbernehmen, wie z. B. Hacks, um die Situation irgendwie mit "Gef√§llt mir" / "Gef√§llt mir nicht" zu behandeln.  Normalerweise all diese Logik im Ansichtsmodell: viel doppelter Code mit Tastensperre, LifeCycle-Handler, Abonnements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2c/a94/35b/d2ca9435bf58a6a261edbf1e7eb046ba.png"><br><br>  Alles, was unser Executor jetzt tut, war einmal in Presenter oder View Model.  Wenn die Architektur ausgereift ist, k√∂nnten die Entwickler diese Logik auf eine Art Interaktor oder Anwendungsfall √ºbertragen, aber die Logik wurde an mehreren Stellen dupliziert. <br><br>  Nachdem wir Executor √ºbernommen haben, wird das Ansichtsmodell einfacher und die gesamte Logik ist ihnen verborgen.  Wenn Sie dies einmal zu Presenter und dem Interaktor gebracht haben, wissen Sie, dass der Interaktor und der Presenter einfacher werden.  Im Allgemeinen war ich zufrieden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef8/215/4c3/ef82154c3a09b62d063ed02ff4d40267.png"><br><br><h2>  Was noch hinzuzuf√ºgen? </h2><br>  Ein weiteres Plus der aktuellen L√∂sung ist, dass sie erweiterbar ist.  Was m√∂chten wir noch als Entwickler hinzuf√ºgen, die an einer mobilen Anwendung arbeiten und jeden Tag mit Fehlern und vielen gleichzeitigen Anfragen zu k√§mpfen haben? <br><br><h3>  Die M√∂glichkeiten </h3><br>  Die <b>Implementierung des Lebenszyklus</b> blieb hinter den Kulissen, aber als mobile Entwickler denken wir alle immer dar√ºber nach und sorgen uns, dass nichts wegflie√üt.  Ich m√∂chte Anwendungsneustartanforderungen <b>speichern und wiederherstellen</b> . <br><br>  <b>Anrufketten.</b>  Durch das Umschlie√üen von RX-Ketten wird es m√∂glich, diese zu serialisieren, da RX standardm√§√üig nicht serialisiert. <br><br>  Nur wenige Benutzer wissen, wie viele gleichzeitige Anforderungen zu einem bestimmten Zeitpunkt in ihren Anwendungen ausgef√ºhrt werden.  Ich w√ºrde nicht sagen, dass dies ein gro√ües Problem f√ºr kleine und mittlere Anwendungen ist.  F√ºr eine gro√üe Anwendung, die im Hintergrund viel Arbeit leistet, ist es jedoch hilfreich, die Ursachen f√ºr Abst√ºrze und Benutzerbeschwerden zu verstehen.  Ohne zus√§tzliche Infrastruktur haben Entwickler einfach keine Informationen, um den Grund zu verstehen: Vielleicht liegt der Grund in der Benutzeroberfl√§che oder in einer gro√üen Anzahl st√§ndiger Anfragen im Hintergrund.  Wir k√∂nnen unsere L√∂sung erweitern und <b>Metriken</b> hinzuf√ºgen. <br><br>  Lassen Sie uns die M√∂glichkeiten genauer betrachten. <br><br><h3>  Lebenszyklusverarbeitung </h3><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span></span>( lifecycle: Lifecycle ) : ActExecutor { inir { lifecycle.doOnDestroy { cancelAll() } } ...</code> </pre> <br>  Dies ist ein Beispiel f√ºr eine Lebenszyklusimplementierung.  Im einfachsten Fall: <code>Destroy</code> Fragmente <code>Destroy</code> oder mit <code>Activity</code> abgebrochen werden, √ºbergeben wir <b>den Lifecycle-Handler an unseren Executor</b> . Wenn <b>das Ereignis onDestroy auftritt, l√∂schen wir alle Anforderungen</b> .  Dies ist eine einfache L√∂sung, bei der kein √§hnlicher Code in Ansichtsmodelle kopiert und eingef√ºgt werden muss.  LifeData macht ungef√§hr das Gleiche. <br><br><h3>  Speichern / Wiederherstellen </h3><br>  Da wir Wrapper haben, k√∂nnen wir <b>separate Klassen f√ºr Acts</b> erstellen, in denen Logik zum Erstellen asynchroner Aufgaben vorhanden ist.  Au√üerdem k√∂nnen wir diesen Namen in der Datenbank speichern und <b>beim Start</b> der <b>Anwendung</b> mit der Factory-Methode oder √§hnlichem <b>aus der Datenbank wiederherstellen</b> . <br><br>  Gleichzeitig erhalten wir die M√∂glichkeit, offline zu arbeiten, und starten die Anforderungen neu, die mit Fehlern abgeschlossen wurden, wenn das Internet angezeigt wird.  In Abwesenheit des Internets oder bei Anforderungsfehlern speichern wir diese in der Datenbank und stellen sie dann wieder her und f√ºhren sie erneut aus.  Wenn Sie dies mit normalem RX ohne zus√§tzliche Wrapper tun k√∂nnen, schreiben Sie bitte in die Kommentare, es w√§re interessant. <br><br><h3>  Ketten anrufen </h3><br>  Wir k√∂nnen auch <b>unsere Taten binden</b> .  Eine weitere Erweiterungsoption ist <b>das Ausf√ºhren von Abfrageketten</b> .  Sie haben beispielsweise eine Entit√§t, die auf dem Server erstellt werden muss, und eine andere Entit√§t, die von der ersten abh√§ngt, muss genau zu dem Zeitpunkt erstellt werden, zu dem wir sicher sind, dass die erste Anforderung erfolgreich war.  Dies kann auch durchgef√ºhrt werden.  Dies ist nat√ºrlich nicht so trivial, aber eine Klasse, die den Start aller asynchronen Aufgaben steuert, ist m√∂glich.  Die Verwendung von Bare RX ist schwieriger. <br><br><h3>  Metriken </h3><br>  Es ist interessant zu sehen, <b>wie viele parallele Abfragen durchschnittlich im Hintergrund ausgef√ºhrt werden</b> .  Mit Metriken k√∂nnen Sie die Ursache f√ºr Benutzerbeschwerden √ºber Lethargie verstehen.  Zumindest k√∂nnen wir die Ausf√ºhrung im Hintergrund dessen, was wir nicht erwartet hatten, aus der Liste der Gr√ºnde ausschlie√üen. <br><br>          ,  , , <b>   </b>  ,   -    -    10%   .    ,    . <br><br><h2>  Fazit </h2><br> <b>  </b> ‚Äî  ,    . ¬´¬ª      .       ,         ,  ,  ,    . <br><br>       ,      ,   .   ‚Äî   - , ,  ‚Äî   .    ‚Äî .  ,           .       . <b>      </b> . <br><br> <b>     </b> .    Kotlin,              . , <b>    </b> . <br><br><blockquote>       AppsConf 2018,      <b> AppsConf 2019</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a>  38 : ,  Android, UX, , - , , Kotlin. <br><br>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">youtube-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>    <b>22‚Äì23 </b>    . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437592/">https://habr.com/ru/post/de437592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437582/index.html">√úbersicht √ºber Vue.js 2.6</a></li>
<li><a href="../de437584/index.html">Die mathematischen Grundlagen des automatischen Layouts</a></li>
<li><a href="../de437586/index.html">Wir erstellen eine Sprachanwendung am Beispiel von Google Assistant</a></li>
<li><a href="../de437588/index.html">Macht es mehr Spa√ü, f√ºr Mobiltelefone als f√ºr das Internet zu entwickeln?</a></li>
<li><a href="../de437590/index.html">Latenzzahlen auf dem iPhone</a></li>
<li><a href="../de437594/index.html">Wie ich die Ursache f√ºr Stottern und Frame-Skipping in allen Spielen beseitigt und versehentlich die Temperatur um 15 Grad gesenkt habe</a></li>
<li><a href="../de437596/index.html">OTRS: LDAP-Authentifizierung, Autorisierung und Synchronisation (FreeIPA, AD)</a></li>
<li><a href="../de437598/index.html">So speichern Sie das Spielsystem mithilfe der Virtualisierung vom Heim-PC</a></li>
<li><a href="../de437600/index.html">opencv4arts: Zeichne meine Stadt, Vincent</a></li>
<li><a href="../de437602/index.html">Profilieren Sie ein Unity-Projekt mit Android Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>