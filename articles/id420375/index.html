<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸 💪🏽 🧑🏾 Pelajari OpenGL. Pelajaran 5.8 - Bloom 👩🏼 🎄 🕉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bloom 
 Karena kisaran kecerahan terbatas yang tersedia untuk monitor konvensional, tugas menampilkan sumber cahaya terang secara meyakinkan dan permu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelajari OpenGL. Pelajaran 5.8 - Bloom</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420375/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2>  Bloom </h2><br>  Karena kisaran kecerahan terbatas yang tersedia untuk monitor konvensional, tugas menampilkan sumber cahaya terang secara meyakinkan dan permukaan yang terang benderang sulit menurut definisi.  Salah satu metode umum untuk menyorot area terang pada monitor adalah teknik yang menambahkan lingkaran cahaya di sekitar objek terang, memberi kesan "penyebaran" cahaya di luar sumber cahaya.  Hasilnya, pengamat memberi kesan kecerahan tinggi pada area yang diterangi atau sumber cahaya tersebut. <br><br>  Efek yang dijelaskan dari halo dan keluarnya cahaya di luar sumber dicapai dengan teknik pasca-pemrosesan yang disebut <i>bloom</i> .  Menerapkan efek menambahkan lingkaran cahaya karakteristik ke semua area terang dari adegan yang ditampilkan, yang dapat dilihat pada contoh di bawah ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/qw/mj/oiqwmjiua0ogznqfllr0q9v53fc.png"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text">  Bagian 1. Memulai <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo segitiga</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transformasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem koordinat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kamera</a> </li></ol><br>  Bagian 2. Pencahayaan dasar <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-dasar pencahayaan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber cahaya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berbagai Sumber Penerangan</a> </li></ol><br>  Bagian 3. Unduh model 3D <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Polygon Mesh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Model 3D</a> </li></ol><br>  Bagian 4. Fitur OpenGL Lanjutan <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes kedalaman</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes stensil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencampuran warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memotong wajah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buffer bingkai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu kubik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan data tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLSL tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader geometris</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instancing</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghaluskan</a> </li></ol><br>  Bagian 5. Pencahayaan Lanjut <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencahayaan tingkat lanjut.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koreksi gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu bayangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta bayangan omnidirectional</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan paralaks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Render yang ditangguhkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSAO</a> </li></ol><br>  Bagian 6. PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber Cahaya Analitik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iradiasi difus.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paparan cermin.</a> </li></ol><br></div></div><br>  Bloom menambahkan petunjuk visual yang khas pada gambar tentang kecerahan signifikan dari objek yang ditutupi oleh lingkaran cahaya dari efek yang diterapkan.  Diterapkan secara selektif dan sampai batas tertentu (yang sayangnya tidak dapat ditanggulangi oleh banyak game), efeknya dapat secara signifikan meningkatkan ekspresif visual dari pencahayaan yang digunakan dalam adegan, serta menambah drama dalam situasi tertentu. <br><br>  Teknik ini bekerja bersama dengan rendering <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDR</a> hampir sebagai tambahan yang jelas.  Rupanya, karena ini, banyak orang secara keliru mencampurkan kedua istilah ini dengan pertukaran penuh.  Namun, teknik ini sepenuhnya independen dan digunakan untuk tujuan yang berbeda.  Dimungkinkan untuk menerapkan bloom menggunakan buffer bingkai default dengan kedalaman warna 8bit, seperti menerapkan rendering HDR tanpa menggunakan bloom.  Satu-satunya hal adalah bahwa rendering HDR memungkinkan Anda untuk menerapkan efek dengan cara yang lebih efisien (kita akan melihatnya nanti). <br><br>  Untuk menerapkan mekar, adegan yang diterangi pertama kali dibuat dengan cara biasa.  Selanjutnya, buffer warna HDR dan buffer warna yang hanya berisi bagian-bagian cerah dari adegan diekstraksi.  Gambar bagian terang yang diekstraksi ini kemudian buram dan dilapis di atas gambar HDR asli dari pemandangan itu. <br><br>  Untuk membuatnya lebih jelas, kami akan menganalisis langkah demi langkah proses.  Jadikan adegan yang mengandung 4 sumber cahaya terang yang ditampilkan sebagai kubus berwarna.  Semuanya memiliki nilai kecerahan dalam kisaran 1,5 hingga 15,0.  Jika buffer warna adalah output ke HDR, hasilnya adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/_h/wn/_2_hwnque0owtvpdcyh_vo_p9pg.png"></div><br>  Dari penyangga warna HDR ini, kami mengekstrak semua fragmen yang kecerahannya melebihi batas yang telah ditentukan.  Ternyata gambar hanya berisi area yang terang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q7/jb/uz/q7jbuz_9apwuc9cb2jzpe4a-4si.png"></div><br>  Selanjutnya, gambar area terang ini buram.  Tingkat keparahan efek pada dasarnya ditentukan oleh kekuatan dan jari-jari filter blur yang diterapkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5u/cv/b7/5ucvb73pzpcbvbrn2pcp5khu1_i.png"></div><br>  Gambar buram yang dihasilkan dari area terang adalah dasar dari efek akhir lingkaran cahaya di sekitar objek terang.  Tekstur ini hanya dicampur dengan gambar asli HDR dari adegan tersebut.  Karena area yang terang buram, ukurannya meningkat, yang akhirnya memberikan efek visual luminositas yang melampaui batas sumber cahaya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wq/pt/lx/wqptlxwywvag8dzh0dck64yzrbg.png"></div><br>  Seperti yang Anda lihat, bloom bukanlah teknik yang paling canggih, tetapi mencapai kualitas visual yang tinggi dan keandalan tidak selalu mudah.  Sebagian besar, efeknya tergantung pada kualitas dan jenis filter blur yang diterapkan.  Bahkan perubahan kecil dalam parameter filter dapat secara dramatis mengubah kualitas akhir peralatan. <br><br>  Jadi, tindakan di atas memberi kita algoritma langkah-demi-langkah dari efek post-processing untuk efek bloom.  Gambar di bawah ini merangkum tindakan yang diperlukan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t7/kt/pz/t7ktpzzm8bo_ccpmh70uu5x0rye.png"></div><br>  Pertama-tama, kita membutuhkan informasi tentang bagian-bagian terang dari pemandangan berdasarkan nilai ambang yang diberikan.  Ini yang akan kita lakukan. <br><br><h2>  Ekstrak highlight </h2><br>  Jadi, sebagai permulaan, kita perlu mendapatkan dua gambar berdasarkan adegan kita.  Akan naif untuk merender dua kali, tetapi gunakan metode <i>Multiple Render Target</i> ( <i>MRT</i> ) yang lebih canggih: kami menentukan lebih dari satu output dalam shader fragmen akhir, dan berkat ini, dua gambar dapat diekstraksi dalam satu pass!  Untuk menentukan di mana buffer warna yang akan dihasilkan oleh shader, penata <i>tata letak</i> digunakan: <br><br><pre><code class="cpp hljs">layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out vec4 FragColor; layout (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) out vec4 BrightColor;</code> </pre> <br>  Tentu saja, metode ini hanya akan berfungsi jika kita telah menyiapkan beberapa buffer untuk penulisan.  Dengan kata lain, untuk mengimplementasikan beberapa output dari fragmen shader, frame buffer yang digunakan saat ini harus mengandung cukup banyak buffer warna yang terhubung.  Jika kita beralih ke pelajaran tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">frame buffer</a> , maka dapat diingat bahwa ketika mengikat tekstur sebagai buffer warna, kita dapat menunjukkan <i>nomor lampiran warna</i> .  Sampai sekarang, kami tidak perlu menggunakan lampiran selain <i>GL_COLOR_ATTACHMENT0</i> , tetapi kali ini <i>GL_COLOR_ATTACHMENT1</i> akan berguna, karena kami membutuhkan dua tujuan untuk merekam sekaligus: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       unsigned int hdrFBO; glGenFramebuffers(1, &amp;hdrFBO); glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); unsigned int colorBuffers[2]; glGenTextures(2, colorBuffers); for (unsigned int i = 0; i &lt; 2; i++) { glBindTexture(GL_TEXTURE_2D, colorBuffers[i]); glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //     glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0 ); }</span></span></code> </pre> <br>  Juga, dengan memanggil <i>glDrawBuffers</i> , Anda perlu memberi tahu secara eksplisit kepada OpenGL bahwa kami akan menghasilkan beberapa buffer.  Jika tidak, perpustakaan masih akan hanya output ke lampiran pertama, mengabaikan operasi tulis ke lampiran lainnya.  Sebagai argumen ke fungsi, array pengidentifikasi lampiran yang digunakan dari enumerasi yang sesuai dilewatkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 }; glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments);</code> </pre> <br>  Untuk buffer bingkai ini, setiap shader fragmen yang menentukan specifier <i>lokasi</i> untuk outputnya akan menulis ke buffer warna yang sesuai.  Dan ini adalah berita bagus, karena dengan cara ini kami menghindari render pass yang tidak perlu untuk mengekstrak data tentang bagian-bagian terang dari adegan - Anda dapat melakukan semuanya sekaligus dalam satu shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 FragColor; layout (location = 1) out vec4 BrightColor; [...] void main() { [...] </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      FragColor = vec4(lighting, 1.0); //         //   -    ,    float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0) BrightColor = vec4(FragColor.rgb, 1.0); else BrightColor = vec4(0.0, 0.0, 0.0, 1.0); }</span></span></span></span></code> </pre> <br>  Dalam fragmen ini, bagian yang berisi kode khas untuk menghitung pencahayaan dihilangkan.  Hasilnya ditulis ke output pertama shader - variabel <i>FragColor</i> .  Selanjutnya, warna fragmen yang dihasilkan digunakan untuk menghitung nilai kecerahan.  Untuk ini, terjemahan tertimbang dalam skala abu-abu dilakukan (dengan perkalian skalar, kami mengalikan komponen vektor yang sesuai dan menambahkannya bersama-sama, yang mengarah ke nilai tunggal).  Kemudian, ketika kecerahan fragmen dari ambang tertentu terlampaui, kami merekam warnanya dalam output kedua shader.  Untuk kubus menggantikan sumber cahaya, shader ini juga dijalankan. <br><br>  Setelah menemukan algoritme, kita dapat memahami mengapa teknik ini bekerja sangat baik dengan rendering HDR.  Rendering dalam format HDR memungkinkan komponen warna melampaui batas atas 1.0, yang memungkinkan Anda untuk secara lebih fleksibel mengatur ambang kecerahan di luar interval standar [0., 1.], memberikan kemampuan untuk menyempurnakan bagian pemandangan mana yang dianggap cerah.  Tanpa menggunakan HDR, Anda harus puas dengan ambang kecerahan dalam interval [0., 1.], yang cukup dapat diterima, tetapi mengarah ke cutoff kecerahan yang lebih "tajam", yang sering membuat bunga mekar terlalu mengganggu dan mencolok (bayangkan diri Anda di lapangan salju yang tinggi di pegunungan) . <br><br>  Setelah shader dieksekusi, dua buffer target akan berisi gambar normal adegan, serta gambar yang hanya berisi area terang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/rf/pr/hprfprhsu9v4q6_gvhhg43leup4.png"></div><br>  Gambar area terang sekarang harus diproses menggunakan blur.  Anda dapat melakukannya dengan filter <i>kotak</i> ( <i>kotak</i> ) sederhana, yang digunakan di bagian postprocessing dari pelajaran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">frame buffer</a> .  Tetapi hasil yang jauh lebih baik diperoleh dengan <i>penyaringan Gauss</i> . <br><br><h2>  Gaussian Blur </h2><br>  Pelajaran postprocessing memberi kami ide kabur menggunakan rata-rata warna sederhana dari fragmen gambar yang berdekatan.  Metode blur ini sederhana, tetapi gambar yang dihasilkan mungkin terlihat lebih menarik.  Gaussian blur didasarkan pada kurva distribusi berbentuk lonceng dengan nama yang sama: nilai fungsi yang tinggi terletak lebih dekat ke pusat kurva dan jatuh ke kedua sisi.  Secara matematis, kurva Gaussian dapat diekspresikan dengan parameter yang berbeda, tetapi bentuk umum kurva tetap sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0o/xq/eq/0oxqeqhhsip9d0iai3eit6cpooo.png"></div><br>  Buram dengan bobot berdasarkan nilai-nilai kurva Gauss terlihat jauh lebih baik daripada filter persegi panjang: karena kenyataan bahwa kurva memiliki area yang lebih besar di sekitar pusatnya, yang sesuai dengan bobot yang lebih besar untuk fragmen di dekat pusat inti filter.  Sebagai contoh, dengan inti 32x32, kita akan menggunakan faktor pembobotan yang lebih kecil, semakin jauh fragmennya dari yang pusat.  Karakteristik filter inilah yang memberikan hasil Gaussian blur yang lebih memuaskan secara visual. <br><br>  Implementasi filter akan membutuhkan array dua dimensi dari koefisien pembobotan, yang dapat diisi berdasarkan ekspresi dua dimensi yang menggambarkan kurva Gaussian.  Namun, kami akan segera menghadapi masalah kinerja: bahkan inti blur yang relatif kecil dalam fragmen 32x32 akan membutuhkan 1024 sampel tekstur untuk setiap fragmen dari gambar yang diproses! <br><br>  Untungnya bagi kita, ekspresi kurva Gaussian memiliki karakteristik matematika yang sangat nyaman - keterpisahan, yang memungkinkan untuk membuat dua ekspresi satu dimensi dari satu ekspresi dua dimensi yang menggambarkan komponen horizontal dan vertikal.  Ini akan memungkinkan pengaburan pada gilirannya dalam dua pendekatan: secara horizontal, dan kemudian secara vertikal dengan set bobot yang sesuai dengan masing-masing arah.  Gambar yang dihasilkan akan sama dengan ketika memproses algoritma dua dimensi, tetapi akan membutuhkan daya pemrosesan prosesor video yang jauh lebih sedikit: alih-alih 1024 sampel dari tekstur, kita hanya perlu 32 + 32 = 64!  Ini adalah inti dari penyaringan Gaussian dua jalur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/my/aq/3gmyaqmqfsy1rk3hegbx_4s5rpc.png"></div><br>  Bagi kami, semua ini berarti satu hal: pengaburan satu gambar harus dilakukan dua kali, dan di sini penggunaan objek penyangga bingkai akan berguna.  Kami menerapkan apa yang disebut teknik ping-pong: ada beberapa objek penyangga bingkai dan isi buffer warna dari satu framebuffer dirender dengan beberapa pemrosesan ke dalam buffer warna dari framebuffer saat ini, kemudian sumber framebuffer dan penerima framebuffer-interchange dan proses ini diulang beberapa kali.  Bahkan, frame buffer saat ini untuk menampilkan gambar hanya diaktifkan, dan dengan itu, tekstur saat ini dari mana pengambilan sampel dilakukan untuk rendering.  Pendekatan ini memungkinkan Anda untuk mengaburkan gambar asli dengan menempatkannya di buffer frame pertama, lalu mengaburkan konten buffer frame pertama, menempatkannya di frame kedua, kemudian mengaburkan frame kedua, menempatkannya di frame pertama dan seterusnya. <br><br>  Sebelum beralih ke kode tuning penyangga bingkai, mari kita lihat kode Gaussian blur shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D image; uniform bool horizontal; uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216); void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     vec2 tex_offset = 1.0 / textureSize(image, 0); //    vec3 result = texture(image, TexCoords).rgb * weight[0]; if(horizontal) { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; } } else { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i]; result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Seperti yang Anda lihat, kami menggunakan sampel koefisien yang agak kecil dari kurva Gaussian, yang digunakan sebagai bobot untuk sampel secara horizontal atau vertikal relatif terhadap fragmen saat ini.  Kode memiliki dua cabang utama yang membagi algoritma menjadi lintasan vertikal dan horizontal berdasarkan nilai seragam <i>horizontal</i> .  Offset untuk setiap sampel diatur sama dengan ukuran texel, yang didefinisikan sebagai kebalikan dari ukuran tekstur (nilai tipe <i>vec2 yang</i> dikembalikan oleh fungsi <i>teksturSize</i> ()). <br><br>  Buat dua bingkai penyangga yang berisi satu penyangga warna berdasarkan tekstur: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongFBO[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongBuffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]); glBindTexture(GL_TEXTURE_2D, pingpongBuffer[i]); glTexImage2D( GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongBuffer[i], <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre> <br>  Setelah kami mendapatkan tekstur HDR adegan dan mengekstraksi tekstur area terang, kami mengisi buffer warna dari salah satu pasangan framebuffers yang disiapkan dengan tekstur kecerahan dan memulai proses ping-pong sepuluh kali (lima kali vertikal, lima horizontal): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> horizontal = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, first_iteration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">10</span></span>; shaderBlur.use(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; amount; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); shaderBlur.setInt(<span class="hljs-string"><span class="hljs-string">"horizontal"</span></span>, horizontal); glBindTexture( GL_TEXTURE_2D, first_iteration ? colorBuffers[<span class="hljs-number"><span class="hljs-number">1</span></span>] : pingpongBuffers[!horizontal] ); RenderQuad(); horizontal = !horizontal; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_iteration) first_iteration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Pada setiap iterasi, kami memilih dan memasang salah satu buffer bingkai berdasarkan pada apakah iterasi ini akan kabur secara horizontal atau vertikal, dan buffer warna framebuffer lain kemudian digunakan sebagai tekstur input untuk blur shader.  Pada iterasi pertama, kita harus secara eksplisit menggunakan gambar yang mengandung area terang ( <i>brightnessTexture</i> ) - jika tidak, kedua framebuffer ping-pong akan tetap kosong.  Setelah sepuluh lewat, gambar asli berbentuk lima kali dikaburkan oleh filter Gaussian penuh.  Pendekatan yang digunakan memungkinkan kita untuk dengan mudah mengubah tingkat blur: semakin banyak iterasi ping-pong, semakin kuat blur. <br><br>  Dalam kasus kami, hasil blur terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2j/du/ga/2jdugaud8hudvnsz8pkdjgaqvus.png"></div><br>  Untuk menyelesaikan efek, tetap hanya untuk menggabungkan gambar buram dengan gambar HDR asli dari pemandangan. <br><br><h2>  Pencampuran tekstur </h2><br>  Memiliki tekstur HDR dari adegan yang ditampilkan dan tekstur kabur dari area yang terlalu terang, yang Anda butuhkan untuk mewujudkan efek mekar atau cahaya yang terkenal adalah menggabungkan kedua gambar ini.  Shader fragmen terakhir (sangat mirip dengan yang disajikan dalam pelajaran tentang format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDR</a> ) melakukan hal itu - ia secara campuran menggabungkan dua tekstur: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D scene; uniform sampler2D bloomBlur; uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(scene, TexCoords).rgb; vec3 bloomColor = texture(bloomBlur, TexCoords).rgb; hdrColor += bloomColor; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// additive blending //   vec3 result = vec3(1.0) - exp(-hdrColor * exposure); //     - result = pow(result, vec3(1.0 / gamma)); FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br>  Apa yang harus dicari: pencampuran dilakukan sebelum menerapkan <i>pemetaan nada</i> .  Ini akan menerjemahkan dengan benar kecerahan tambahan dari efek ke dalam rentang LDR ( <i>Rentang Dinamis Rendah</i> ), sambil mempertahankan distribusi kecerahan relatif dalam adegan. <br><br>  Hasil pemrosesan - semua area terang menerima efek cahaya yang nyata: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/ga/s7/yegas7stvrwhww7-a_rzdu3g_lk.png"></div><br>  Kubus yang menggantikan sumber cahaya sekarang terlihat jauh lebih terang dan lebih baik menyampaikan kesan sumber cahaya.  Adegan ini cukup primitif, karena penerapan efek antusiasme khusus tidak akan menyebabkan, tetapi dalam adegan kompleks dengan pencahayaan yang bijaksana, mekar yang disadari secara kualitatif dapat menjadi elemen visual penting yang menambah drama. <br><br>  Kode sumber untuk contoh ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Saya perhatikan bahwa pelajaran menggunakan filter yang cukup sederhana dengan hanya lima sampel di setiap arah.  Dengan membuat lebih banyak sampel dalam radius yang lebih besar atau dengan melakukan beberapa iterasi filter, Anda dapat secara visual meningkatkan efeknya.  Juga, perlu dikatakan bahwa secara visual kualitas dari keseluruhan efek secara langsung tergantung pada kualitas dari algoritma blur yang digunakan.  Dengan meningkatkan filter, Anda dapat mencapai peningkatan signifikan dan seluruh efek.  Misalnya, hasil yang lebih mengesankan ditunjukkan oleh kombinasi beberapa filter dengan ukuran inti yang berbeda atau kurva Gaussian yang berbeda.  Berikut ini adalah sumber daya tambahan dari Kalogirou dan EpicGames yang membahas cara meningkatkan kualitas bloom dengan memodifikasi Gaussian blur. <br><br><h2>  Sumber Daya Tambahan </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efisien Gaussian Blur dengan pengambilan sampel linier</a> : deskripsi kualitatif tentang operasi filter Gaussian, ditambah dengan studi tentang peningkatan kinerja metode melalui penggunaan penyaringan bilinear pada sampel tekstur OpenGL. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloom Post Process Effect</a> : Artikel dari EpicGames tentang peningkatan kualitas efek dengan menggabungkan beberapa kurva Gauss. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara melakukan bloom yang baik untuk rendering HDR</a> : Artikel oleh Kalogirou menjelaskan peningkatan bloom dengan memodifikasi algoritma filter Gauss asli. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420375/">https://habr.com/ru/post/id420375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420363/index.html">Webinar HPE pada Agustus-Oktober: topik baru (+ SHD, praktik AI, penyimpanan turnkey petabyte)</a></li>
<li><a href="../id420367/index.html">Kiamat ber-AC: skenario smart grid blackout</a></li>
<li><a href="../id420369/index.html">Extreme Extended Edge, atau Switching IEEE 802.1BR</a></li>
<li><a href="../id420371/index.html">Pada masalah konstruksi sepeda di bidang penyimpanan surat listrik</a></li>
<li><a href="../id420373/index.html">Hampir OCR untuk mendapatkan kata sandi VPNBook. PHP + Mikrotik</a></li>
<li><a href="../id420377/index.html">Bagaimana kami memulai panggilan video</a></li>
<li><a href="../id420381/index.html">Mengapa cukup untuk menganggap jaringan saraf sebagai kotak hitam?</a></li>
<li><a href="../id420383/index.html">"Yandex.Money tidak menarik minat Anda untuk memasukkan aplikasi Anda."</a></li>
<li><a href="../id420385/index.html">Pengujian integrasi berbasis wadah</a></li>
<li><a href="../id420387/index.html">Tiga Rubik's Cube yang cerdas: Xiaomi, Roobo dan GoCube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>