<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈂️ 😷 👛 Posisi Kedua di Mini AI Cup 4: Paper IO 🍦 👨🏾‍🍳 🌕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Igor Volkov. Saya bekerja di perusahaan konsultan sebagai pengembang, arsitek, pemimpin tim, manajer teknis Java. Peran yang berbeda tergant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Posisi Kedua di Mini AI Cup 4: Paper IO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466597/"><p>  Nama saya Igor Volkov.  Saya bekerja di perusahaan konsultan sebagai pengembang, arsitek, pemimpin tim, manajer teknis Java.  Peran yang berbeda tergantung pada kebutuhan proyek saat ini.  Dia menarik perhatian untuk kontes dari mail.ru untuk waktu yang lama, tetapi ternyata berpartisipasi aktif hanya di Paper IO. </p><br><p><img width="120" height="120" align="left" src="https://habrastorage.org/webt/nd/gt/uf/ndgtufwihri2t-l1ehiq6pbr_ce.png"></p><p>  Kali ini, penyelenggara mengusulkan untuk menerapkan strategi manajemen bot berdasarkan permainan populer.  Baca lebih lanjut tentang aturan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Kode strategi saya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , dan contoh-contoh permainan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web kejuaraan</a> . <br></p><br><a name="habracut"></a><br><hr><br><p> Pada awal kompetisi, menurut saya, ide implementasi pop-up yang paling umum adalah penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MCTS</a> .  Karena itu, saya menghabiskan sedikit waktu untuk bereksperimen dengan algoritma ini.  Dan tanpa mengetahui bagaimana menggunakannya secara efektif untuk menyelesaikan masalah, saya memutuskan untuk memulai dengan menghasilkan banyak rute persegi panjang (dengan dua, dan kemudian dengan tiga putaran) dan evaluasi selanjutnya. </p><br><h2 id="algoritm-strategii">  Algoritma Strategi </h2><br><p>  Algoritme strategi tingkat tinggi dapat diwakili oleh 6 poin berikut: </p><br><ol><li>  Baca keadaan dunia </li><li>  Konversi objek pesan menjadi objek kerja </li><li>  Bentuk satu set rute persegi panjang </li><li>  Nilai setiap rute yang dihasilkan </li><li>  Pilih rute terbaik </li><li>  Kirim tim </li></ol><br><p>  Algoritma ini tidak berubah selama kompetisi.  Hanya metode pembentukan rute bot dan penilaiannya yang dimodifikasi. </p><br><p>  Kelas <a href="">SimpleStrategy</a> berisi versi awal dari strategi, dan kelas <a href="">BestStrategy adalah</a> versi yang ditingkatkan, yang menempati posisi ke-2 dalam kompetisi. </p><br><h3 id="chtenie-sostoyaniya-mira">  Membaca keadaan dunia </h3><br><p>  Keadaan dunia ditransmisikan sebagai objek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON</a> melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STDIN</a> .  Saya melihat di <a href="">pom.xml</a> bahwa Anda dapat menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gson</a> dan tugas membaca keadaan dunia telah sangat disederhanakan.  Menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gson,</a> deserialized string <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON</a> membaca dari aliran input standar menjadi turunan dari kelas <a href="">pesan</a> .  Kode ini ada di <a href="">Main.java (baris 44-49)</a> . </p><br><h3 id="sozdanie-rabochih-obektov">  Buat benda kerja </h3><br><p>  Menggunakan objek transportasi dalam kode program utama biasanya tidak terlalu nyaman dan secara arsitektur salah.  Misalnya, penyelenggara, karena satu dan lain hal, dapat mengubah format pesan.  Oleh karena itu, perlu untuk mengubah objek transportasi menjadi pekerja, yang akan digunakan dalam kode program utama.  Kelas <a href="">Player</a> dan <a href="">PlayerState</a> mempertahankan status bot, dan kelas utilitas <a href="">MessagePlayer2PlayerConverter</a> membantu untuk membuat kelas-kelas ini berdasarkan data dari pesan transport.  Kelas <a href="">Bonus</a> berisi informasi tentang bonus sel di lapangan bermain.  Kode untuk membuat objek kerja terletak di <a href="">Main.java (baris 61-74)</a> . </p><br><h3 id="formirovanie-marshrutov">  Formasi rute </h3><br><p>  Dalam versi pertama strategi ( <a href="">SimpleStrategy</a> ), jalur ditetapkan menggunakan kelas <a href="">MovePlanWithScore</a> dan <a href="">Move</a> .  <a href="">Move</a> menetapkan arah gerakan dan berapa banyak sel yang harus dipindahkan bot ke arah ini, dan <a href="">MovePlanWithScore</a> berisi rute yang ditentukan oleh array <a href="">Arahan</a> dan perkiraan rute ini.  Array dapat berisi dari satu hingga empat objek <a href="">Pindahkan</a> .  Terlepas dari kenyataan bahwa hanya rute persegi panjang dengan tidak lebih dari tiga belokan dipertimbangkan, pada kenyataannya rute bot diperoleh dalam bentuk garis putus-putus.  Ini dicapai dengan memilih rute empat persegi panjang terbaik di setiap belokan.  <a href="">Fungsi pembuatan rute</a> , diimplementasikan sebagai loop bersarang, membentuk daftar dari <a href="">MovePlanWithScore</a> untuk evaluasi lebih lanjut. </p><br><p>  Formasi lintasan bot seperti itu tidak terlalu efektif dalam hal kinerja penilaian berikutnya, karena itu perlu untuk menghitung lintasan yang sama beberapa kali, tetapi itu sangat berguna untuk memahami mekanisme permainan. </p><br><p>  Dalam versi strategi yang lebih baru, <a href="">BestStrategy</a> mulai menggunakan pohon rute.  Kelas <a href="">MoveNode</a> mencerminkan simpul pohon ini.  Pohon sepenuhnya terbentuk pada awal strategi.  Perhatikan metode <a href="">init dari kelas MoveNode</a> .  Ini sangat mirip dengan menghasilkan rute dari kelas <a href="">SimpleStrategy</a> .  Pada dasarnya, rute yang dimaksud tidak jauh berbeda dengan versi pertama. </p><br><p>  Pembentukan rute, saya pikir, bisa ditingkatkan sedikit lebih dengan menambahkan twist lain.  Tetapi tidak ada cukup waktu untuk optimasi. </p><br><h3 id="ocenka-marshruta">  Peringkat Rute </h3><br><p>  Di mana pun bot itu berada, rute terbaik yang berakhir di wilayahnya selalu dipilih untuknya.  Untuk mengevaluasi rute, saya memperkenalkan dua indikator: skor dan risiko.  Skor - kira-kira mencerminkan jumlah poin yang dicetak per kutu jalur, dan risiko - jumlah kutu yang tidak cukup untuk menyelesaikan jalur (misalnya, karena fakta bahwa lawan dapat meraih dengan ekor).  Risiko tidak segera muncul.  Dalam versi pertama, jika bot tiba-tiba menemukan di tengah jalan bahwa ia tidak punya waktu untuk menyelesaikan rute, itu "menjadi gila", karena semua jalur berbahaya sama buruknya untuk itu.  Dari semua rute yang dipertimbangkan, yang paling "aman" dipilih dengan jumlah maksimum poin per centang jalan. </p><br><p>  Untuk menilai keamanan rute, saya menghitung matriks reachability: untuk setiap sel lapangan bermain saya menemukan centang di mana bot lawan dapat muncul di dalamnya.  Pertama, hanya centang, dan kemudian menambahkan perhitungan panjang ekor.  Bonus yang dapat diambil sepanjang jalan juga tidak diperhitungkan dalam versi pertama strategi.  Kelas <a href="">TimeMatrixBuilder</a> menghitung matriks kutu dan panjang ekor bot lawan.  Matriks ini kemudian digunakan untuk menilai risiko.  Jika bot saya berada di wilayahnya pada saat menghitung langkah selanjutnya - tingkat risiko maksimum ditetapkan untuk rute berbahaya, jika bot sudah dalam perjalanan di wilayah asing atau netral, risiko dinilai sebagai perbedaan antara kutu penyelesaian jalur (bot datang ke wilayahnya) dan kutu saat dapat mengancam bahaya (misalnya, bot orang lain dapat menginjak ekor). </p><br><p>  Dalam versi pertama strategi, skor dianggap hanya berdasarkan wilayah yang ditangkap dan bonus sedikit diperhitungkan.  Untuk menemukan sel yang ditangkap, saya menggunakan <a href="">algoritma rekursif</a> .  Banyak kontestan mengeluh tentang keanehan dan kompleksitas komputasi yang berlebihan dari algoritma yang digunakan oleh penyelenggara di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Local Runner</a> .  Saya akan berasumsi bahwa ini dilakukan dengan sengaja agar tidak memberikan solusi siap pakai kepada para peserta kompetisi. </p><br><p>  Aneh, tetapi terlepas dari keutamaan versi pertama dari strategi, itu menunjukkan dirinya dengan cukup baik: tempat ke-10 di kotak pasir.  Benar, di babak prefinal ia mulai turun dengan cepat: peserta lain meningkatkan strategi mereka. </p><br><p>  Bot saya sering mati.  Pertama-tama, karena fakta bahwa rute sedang dibangun ke wilayah yang ditangkap oleh bot saingan.  Jalannya tiba-tiba memanjang dan bot saya tertangkap oleh ekor.  Sering mati karena prediksi yang salah tentang panjang ekor dan kecepatan bot lawan.  Misalnya, bot lawan yang mengalami pelambatan berbahaya, karena dalam perhitungan perkiraan, strategi tersebut berasumsi bahwa ia seharusnya sudah meninggalkan sel, dan ia masih ada di sana.  Untuk mengatasi masalah ini, saya mulai menghitung sejumlah besar indikator untuk setiap sel di lapangan bermain (kelas <a href="">AnalyticsBuilder</a> dan <a href="">CellDetails</a> ). </p><br><p>  <strong>Menghitung sel bidang bermain</strong> </p><br><ol><li>  Centang di mana bot lawan dapat menempati kandang (centang di bagian ekor) </li><li>  Centang di mana bot lawan bisa memasuki sel </li><li>  Panjang ekor saat memasuki kandang </li><li>  Centang di mana bot lawan dapat keluar dari kandang </li><li>  Panjang ekor saat meninggalkan kandang </li><li>  Centang di mana sel dapat ditangkap oleh bot lawan </li><li>  Centang di mana sel dapat menjadi target untuk menangkap wilayah </li><li>  Centang tempat sel dapat dipukul dengan gergaji </li></ol><br><p>  Kedalaman analitik terbatas pada 10 gerakan.  Saya pikir itu mungkin untuk mencapai kedalaman yang lebih besar dengan menolak untuk menghitung pesaing individu atau memperkenalkan kedalaman mengambang, tetapi tidak ada cukup waktu untuk optimasi.  Selain <a href="">AnalyticsBuilder,</a> ia mulai menggunakan <a href="">SimpleTickMatrixBuilder</a> jika tidak ada kedalaman render untuk <a href="">AnalyticsBuilder</a> .  Hasil analisis digunakan oleh <a href="">BestStrategy</a> . </p><br><p>  Fungsi peringkat juga sedikit meningkat: </p><br><ol><li>  Saya mulai memperhitungkan bonus akun: penalti untuk mengambil bonus deselerasi dan bonus untuk mengambil akselerasi dan melihat bonus.  Akibatnya, bot mulai berhasil menghindari bonus buruk dan mengambil yang baik di sepanjang jalan. </li><li>  Dia mulai memperhitungkan bentrokan kepala.  Menambahkan beberapa poin untuk pertandingan kemenangan.  Semakin jauh kemungkinan tabrakan, semakin sedikit poin. </li><li>  Untuk mengurangi kemungkinan lingkungan, ia menambahkan beberapa poin untuk mengambil sel batas lawan. </li><li>  Mengurangi nilai sel kosong di perbatasan: semakin jauh dari pusat, semakin rendah nilainya.  Menyaksikan perkelahian final, saya sampai pada kesimpulan bahwa untuk fakta menangkap sel kosong tidak perlu mengumpulkan poin sama sekali.  Nilai sel kosong harus bergantung pada kedekatan dengan kelompok besar sel musuh.  Sayangnya, di final tidak mungkin lagi untuk mengedit strategi. </li><li>  Menambahkan poin untuk mengelilingi kepala bot lawan.  Tidak yakin apakah ini membantu.  Mungkin dengan strategi paling sederhana. </li><li>  Dia menambahkan poin bahkan untuk meraih sia-sia oleh ekor (bot lawan berhasil menangkap wilayah dengan kutu yang sama di mana bot saya menginjak ekornya).  Saya benar-benar tidak yakin, tetapi saya pikir ini mencegah bot lawan dari menangkap wilayah orang lain dan mereka sering harus kembali ke wilayah mereka. </li><li>  Dalam hal deteksi kemungkinan kematian dari penangkapan sangat meningkatkan biaya sel-sel batas wilayah lawan. </li></ol><br><h2 id="otladka-strategii">  Strategi debugging </h2><br><p> Versi pertama dari strategi berisi sejumlah besar kesalahan ketik dan kesalahan: tampaknya, hasil dari pemrograman malam.  Misalnya, di kelas <a href="">Sel</a> , indeks dianggap salah: alih-alih <code>this.index = x * Game.sizeY + y</code> , <code>this.index = x * Game.width + y</code> .  Pada awalnya saya mencoba hanya mengandalkan tes, tetapi intuisi saya menyarankan bahwa tanpa visualisasi dan tanpa bermain pertandingan yang dimainkan sebelumnya, akan sulit untuk menemukan kesalahan dalam kode dan menganalisis alasan untuk membuat keputusan yang salah.  Akibatnya, visualisator <a href="">DebugWindow muncul</a> , di mana Anda dapat melihat game yang dimainkan sebelumnya langkah demi langkah, serta mulai men-debug pada centang yang diinginkan.  Kode ini tidak terlalu indah, ditulis dengan tergesa-gesa, tetapi banyak membantu saya ketika debugging.  Misalnya, kesalahan segera terdeteksi dengan perhitungan indeks sel yang salah.  Banyak kontestan yang menampilkan informasi debug di konsol, tetapi menurut saya itu tidak cukup. </p><br><img src="https://habrastorage.org/webt/rz/ys/k3/rzysk31_gefvqcgq4vjbyosotqe.png"><br><br><h2 id="optimizaciya">  Optimasi </h2><br><p>  Agar tidak membuang waktu membuat objek dan menjalankan GC, saya mencoba membuat beberapa objek terlebih dahulu.  Ini adalah sel-sel dari lapangan bermain (kelas <a href="">sel</a> ).  Selain itu untuk setiap sel tetangga diidentifikasi.  Membuat pohon kemungkinan jalur sebelumnya (kelas <a href="">MoveNode</a> ). </p><br><p>  Saya berasumsi bahwa banyak skenario harus disimulasikan, dan dalam proses keadaan saat ini akan memburuk dan harus dipulihkan setiap waktu.  Karena itu, untuk menjaga keadaan dunia, saya mencoba menggunakan sebanyak mungkin struktur yang dikemas.  Untuk menyimpan wilayah yang diduduki - BitSet (kelas <a href="">PlayerTerritory</a> ).  Setiap sel bidang bermain diberi nomor, dan nomor sel sesuai dengan nomor bit di BitSet.  Untuk menyimpan buntut, saya menggunakan BitSet bersama dengan ArrayDeque (kelas <a href="">PlayerTail</a> ). <br></p><p>  Benar, saya tidak sempat memainkan berbagai skenario karena kekurangan waktu.  Dan karena fungsi utama menghitung jalur menjadi rekursif dan seluruh negara dapat disimpan di tumpukan, optimisasi terbaru tidak terlalu berguna bagi saya. </p><br><h2 id="nerealizovannye-idei">  Ide yang belum direalisasi </h2><br><p>  Ketika menilai risiko rute bot saya, saya memperhitungkan setiap lawan secara independen.  Bahkan, masing-masing rival juga takut mati.  Karena itu, ada baiknya mempertimbangkan hal ini dalam penilaian risiko.  Setidaknya, ini pasti harus diperhitungkan di pertandingan final. </p><br><p>  Akuntansi kematian calon lawan.  Kadang-kadang terjadi bahwa bot menangkap wilayah lawan, dan lawan tiba-tiba mati.  Ini memalukan, karena sebagai hasilnya, Anda hanya menangkap sel kosong. </p><br><p>  Akuntansi sel kosong yang akan ditangkap dalam waktu dekat sebagai fungsi evaluasi. </p><br><h2 id="rekomendacii-i-blagodarnosti">  Rekomendasi dan terima kasih </h2><br><p>  Saya merekomendasikan bahwa semua pengembang berpartisipasi aktif dalam kontes Piala AI.  Ini mengembangkan pemikiran dan bantuan melalui permainan untuk mempelajari algoritma baru.  Dan seperti yang ditunjukkan oleh pengalaman saya, semangat kecil sudah cukup untuk menempati tempat hadiah dan bahkan kode yang sederhana dan tidak terlalu optimal dapat membawa hasil. </p><br><p>  Banyak terima kasih kepada panitia.  Meskipun ada beberapa masalah teknis, kompetisi ini ternyata menarik.  Saya menantikan yang berikutnya! </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466597/">https://habr.com/ru/post/id466597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466585/index.html">Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 3. Kafka</a></li>
<li><a href="../id466587/index.html">Variabel CSS dan tema warna untuk situs dalam beberapa baris</a></li>
<li><a href="../id466589/index.html">Cara menerima data dari Google Analytics menggunakan R di Microsoft SQL Server</a></li>
<li><a href="../id466591/index.html">MVC tanpa C: Apa yang akan mengubah SwiftUI dalam arsitektur aplikasi?</a></li>
<li><a href="../id466593/index.html">Situasi: Hybrid Cloud dan Perspektif IaaS</a></li>
<li><a href="../id466599/index.html">Cara mem-bypass captcha menggunakan pengenalan suara</a></li>
<li><a href="../id466601/index.html">Buku-buku psikologis swa-bantu: apakah itu masuk akal, dan jika demikian, mana yang harus dipilih?</a></li>
<li><a href="../id466603/index.html">Alat untuk membandingkan kerangka kerja CSS</a></li>
<li><a href="../id466605/index.html">Laboratorium radio Nizhny Novgorod dan komunikasi radio amatir di HF</a></li>
<li><a href="../id466607/index.html">"Semua yang Anda baca akan digunakan untuk melawan Anda": bagaimana musik rap masuk ke ruang sidang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>