<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîî üë®üèø‚Äçüç≥ üïí MVCC dans PostgreSQL-3. Versions en ligne üë®üèø‚Äçüîß ü§ò üë¶üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eh bien, nous avons d√©j√† discut√© de l' isolement et fait une digression concernant la structure des donn√©es de bas niveau . Et nous avons enfin attein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-3. Versions en ligne</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/477648/">  Eh bien, nous avons d√©j√† discut√© de l' <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolement</a> et fait une digression concernant <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la structure des donn√©es de bas niveau</a> .  Et nous avons enfin atteint la chose la plus fascinante, √† savoir les versions en ligne (tuples). <br><br><h1>  En-t√™te de tuple </h1><br>  Comme d√©j√† mentionn√©, plusieurs versions de chaque ligne peuvent √™tre disponibles simultan√©ment dans la base de donn√©es.  Et nous devons en quelque sorte distinguer une version d'une autre.  √Ä cette fin, chaque version est √©tiquet√©e avec son ¬´temps¬ª <code>xmin</code> ( <code>xmin</code> ) et son ¬´temps¬ª d'expiration ( <code>xmax</code> ).  Les guillemets indiquent qu'un compteur d'incr√©mentation sp√©cial est utilis√© plut√¥t que l'heure elle-m√™me.  Et ce compteur est <em>l'identifiant de transaction</em> . <br><br>  (Comme d'habitude, en r√©alit√©, cela est plus compliqu√©: l'ID de transaction ne peut pas toujours augmenter en raison d'une profondeur de bits limit√©e du compteur. Mais nous explorerons plus de d√©tails √† ce sujet lorsque notre discussion atteindra le gel.) <br><a name="habracut"></a><br>  Lorsqu'une ligne est cr√©√©e, la valeur de <code>xmin</code> est d√©finie √©gale √† l'ID de la transaction qui a ex√©cut√© la commande INSERT, tandis que <code>xmax</code> n'est pas renseign√©. <br><br>  Lorsqu'une ligne est supprim√©e, la valeur <code>xmax</code> de la version actuelle est √©tiquet√©e avec l'ID de la transaction qui a effectu√© DELETE. <br><br>  Une commande UPDATE effectue en fait deux op√©rations suivantes: DELETE et INSERT.  Dans la version actuelle de la ligne, <code>xmax</code> est d√©fini √©gal √† l'ID de la transaction qui a effectu√© UPDATE.  Ensuite, une nouvelle version de la m√™me ligne est cr√©√©e, dans laquelle la valeur de <code>xmin</code> est identique √† <code>xmax</code> de la version pr√©c√©dente. <br><br>  <code>xmin</code> champs <code>xmin</code> et <code>xmax</code> sont inclus dans l'en-t√™te d'une version de ligne.  En plus de ces champs, l'en-t√™te de tuple en contient d'autres, tels que: <br><br><ul><li>  <code>infomask</code> - plusieurs bits qui d√©terminent les propri√©t√©s d'un tuple donn√©.  Il y en a plusieurs, et nous en discuterons au fil du temps. </li><li>  <code>ctid</code> - une r√©f√©rence √† la prochaine version, plus r√©cente, de la m√™me ligne.  <code>ctid</code> de la <code>ctid</code> de ligne la plus r√©cente et la plus r√©cente fait r√©f√©rence √† cette m√™me version.  Le nombre est sous la forme <code>(x,y)</code> , o√π <code>x</code> est le num√©ro de la page et <code>y</code> est le num√©ro d'ordre du pointeur dans le tableau. </li><li>  Le bitmap NULL, qui marque les colonnes d'une version donn√©e qui contiennent un NULL.  NULL n'est pas une valeur r√©guli√®re des types de donn√©es, et par cons√©quent, nous devons stocker cette caract√©ristique s√©par√©ment. </li></ul><br>  Par cons√©quent, l'en-t√™te semble assez volumineux: 23 octets par chaque tuple au minimum, mais g√©n√©ralement plus grand en raison de la bitmap NULL.  Si une table est ¬´√©troite¬ª (c'est-√†-dire qu'elle contient peu de colonnes), les octets de surcharge peuvent occuper plus d'espace que les informations utiles. <br><br><h1>  Ins√©rer </h1><br>  Voyons plus en d√©tail comment les op√©rations sur les lignes sont effectu√©es √† un niveau bas, et commen√ßons par un insert. <br><br>  Pour exp√©rimenter, nous allons cr√©er une nouvelle table avec deux colonnes et un index sur l'une d'entre elles: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre><br>  Nous commen√ßons une transaction pour ins√©rer une ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Voici l'ID de notre transaction en cours: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Examinons le contenu de la page.  La fonction <code>heap_page_items</code> de l'extension "pageinspect" nous permet d'obtenir des informations sur les pointeurs et les versions des lignes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Notez que le mot "tas" dans PostgreSQL d√©signe des tables.  C'est une autre utilisation bizarre d'un terme: un tas est une <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">structure de donn√©es</a> connue, qui n'a rien √† voir avec une table.  Ce mot est utilis√© ici dans le sens o√π "tout est entass√©", contrairement aux index ordonn√©s. <br><br>  Cette fonction affiche les donn√©es "telles quelles", dans un format difficile √† comprendre.  Pour clarifier les choses, nous ne laissons qu'une partie des informations et les interpr√©tons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Nous avons fait ce qui suit: <br><br><ul><li>  Ajout d'un z√©ro au num√©ro de pointeur pour qu'il ressemble √† un <code>t_ctid</code> : (num√©ro de page, num√©ro de pointeur). </li><li>  Interpr√©t√© l'√©tat du pointeur <code>lp_flags</code> .  C'est "normal" ici, ce qui signifie que le pointeur fait r√©f√©rence √† une version de ligne.  Nous discuterons d'autres valeurs plus tard. </li><li>  Jusqu'√† pr√©sent, nous n'avons s√©lectionn√© que deux paires d'informations.  <code>xmin_committed</code> bits <code>xmin_committed</code> et <code>xmin_aborted</code> indiquent si la transaction avec l'ID <code>xmin</code> est <code>xmin</code> ( <code>xmin</code> ).  Une paire de bits similaires concerne la transaction avec l'ID <code>xmax</code> . </li></ul><br>  Qu'observons-nous?  Lorsqu'une ligne est ins√©r√©e, dans la page du tableau appara√Æt un pointeur qui a le num√©ro 1 et fait r√©f√©rence √† la premi√®re et la seule version de la ligne. <br><br>  Le champ <code>xmin</code> dans le tuple est rempli avec l'ID de la transaction en cours.  √âtant donn√© que la transaction est toujours active, les bits <code>xmin_committed</code> et <code>xmin_aborted</code> sont non <code>xmin_aborted</code> . <br><br>  Le champ <code>ctid</code> de la version de ligne fait r√©f√©rence √† la m√™me ligne.  Cela signifie qu'aucune version plus r√©cente n'est disponible. <br><br>  Le champ <code>xmax</code> est rempli avec le num√©ro conventionnel 0 puisque le tuple n'est pas supprim√©, c'est-√†-dire √† jour.  Les transactions <code>xmax_aborted</code> ce nombre en raison de l' <code>xmax_aborted</code> bits <code>xmax_aborted</code> . <br><br>  Passons √† l'√©tape suivante pour am√©liorer la lisibilit√© en ajoutant des bits d'information aux ID de transaction.  Et cr√©ons la fonction puisque nous aurons besoin de la requ√™te plus d'une fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Ce qui se passe dans l'en-t√™te de la version ligne est beaucoup plus clair sous cette forme: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Nous pouvons obtenir des informations similaires, mais beaucoup moins d√©taill√©es, √† partir du tableau lui-m√™me en utilisant des pseudo-colonnes <code>xmin</code> et <code>xmax</code> : <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Valider </h1><br>  Lorsqu'une transaction r√©ussit, son statut doit √™tre m√©moris√©, c'est-√†-dire que la transaction doit √™tre marqu√©e comme valid√©e.  √Ä cette fin, la structure XACT est utilis√©e.  (Avant la version 10, il s'appelait CLOG (journal de validation), et vous √™tes toujours susceptible de rencontrer ce nom.) <br><br>  XACT n'est pas une table du catalogue syst√®me, mais des fichiers dans le r√©pertoire PGDATA / pg_xact.  Deux bits sont allou√©s dans ces fichiers pour chaque transaction - "valid√©s" et "abandonn√©s" - exactement de la m√™me mani√®re que dans l'en-t√™te de tuple.  Ces informations sont r√©parties sur plusieurs fichiers uniquement pour des raisons de commodit√©;  nous y reviendrons lorsque nous discuterons du gel.  PostgreSQL fonctionne avec ces fichiers page par page, comme avec tous les autres. <br><br>  Ainsi, lorsqu'une transaction est valid√©e, le bit "valid√©" est d√©fini pour cette transaction dans XACT.  Et c'est tout ce qui se passe lorsque la transaction est valid√©e (bien que nous ne mentionnions pas encore le journal d'√©criture anticip√©e). <br><br>  Lorsqu'une autre transaction acc√®de √† la page du tableau que nous venons de voir, la premi√®re devra r√©pondre √† quelques questions. <br><br><ol><li>  La transaction <code>xmin</code> t-elle <code>xmin</code> effectu√©e?  Sinon, le tuple cr√©√© ne doit pas √™tre visible. <br>  Ceci est v√©rifi√© en regardant √† travers une autre structure, qui se trouve dans la m√©moire partag√©e de l'instance et appel√©e ProcArray.  Cette structure contient une liste de tous les processus actifs, ainsi que l'ID de la transaction (active) actuelle pour chacun. </li><li>  Si la transaction a √©t√© effectu√©e, a-t-elle √©t√© valid√©e ou annul√©e?  S'il a √©t√© annul√©, le tuple ne doit pas non plus √™tre visible. <br>  C'est exactement pour cela que XACT est n√©cessaire.  Mais il est co√ªteux de v√©rifier XACT √† chaque fois, bien que les derni√®res pages de XACT soient stock√©es dans des tampons dans la m√©moire partag√©e.  Par cons√©quent, une fois compris, l'√©tat de la transaction est √©crit sur les bits <code>xmin_committed</code> et <code>xmin_aborted</code> du tuple.  Si l'un de ces bits est d√©fini, l'√©tat de la transaction est trait√© comme connu et la prochaine transaction n'aura pas besoin de v√©rifier XACT. </li></ol><br>  Pourquoi la transaction qui effectue l'insertion ne d√©finit-elle pas ces bits?  Lorsqu'une insertion est en cours, la transaction ne sait pas encore si elle se terminera avec succ√®s.  Et au moment de la validation, il est d√©j√† difficile de savoir quelles lignes et dans quelles pages ont √©t√© modifi√©es.  Il peut y avoir beaucoup de ces pages, et il n'est pas pratique de les suivre.  En outre, certaines pages peuvent √™tre supprim√©es du disque du cache de tampon;  les relire afin de changer les bits signifierait un ralentissement significatif de la validation. <br><br>  Le revers de l'√©conomie est qu'apr√®s les mises √† jour, toute transaction (m√™me celle ex√©cutant SELECT) peut commencer √† changer les pages de donn√©es dans le cache de tampon. <br><br>  Nous engageons donc le changement. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Rien n'a chang√© dans la page (mais nous savons que l'√©tat des transactions est d√©j√† √©crit dans XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Maintenant, une transaction qui acc√®de d'abord √† la page devra d√©terminer le statut de la transaction <code>xmin</code> et l'√©crira dans les bits d'information: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Effacer </h1><br>  Lorsqu'une ligne est supprim√©e, l'ID de la transaction de suppression en cours est √©crit dans le champ <code>xmax</code> de la version √† jour et le bit <code>xmax_aborted</code> est r√©initialis√©. <br><br>  Notez que la valeur de <code>xmax</code> correspondant √† la transaction active fonctionne comme un verrou de ligne.  Si une autre transaction va mettre √† jour ou supprimer cette ligne, elle devra attendre la <code>xmax</code> transaction <code>xmax</code> .  Nous parlerons des verrous plus en d√©tail plus tard.  √Ä ce stade, notez seulement que le nombre de verrous de ligne n'est pas du tout limit√©.  Ils n'occupent pas de m√©moire et les performances du syst√®me ne sont pas affect√©es par ce nombre.  Cependant, les transactions de longue dur√©e pr√©sentent d'autres inconv√©nients, qui seront √©galement abord√©s plus loin. <br><br>  Supprimons une ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Nous voyons que l'ID de transaction est √©crit dans le champ <code>xmax</code> , mais les bits d'information ne sont pas d√©finis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Abandonner </h1><br>  L'abandon d'une transaction fonctionne de mani√®re similaire pour la validation, sauf que le bit "abandonn√©" est d√©fini dans XACT.  Un abandon se fait aussi rapidement qu'un commit.  Bien que la commande soit appel√©e ROLLBACK, les modifications ne sont pas annul√©es: tout ce que la transaction a d√©j√† chang√©, reste intact. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Lors de l'acc√®s √† la page, l'√©tat sera v√©rifi√© et le bit de conseil <code>xmax_aborted</code> sera d√©fini.  Bien que le nombre <code>xmax</code> lui-m√™me soit toujours dans la page, il ne sera pas examin√©. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Mettre √† jour </h1><br>  Une mise √† jour fonctionne comme si la version actuelle √©tait supprim√©e en premier, puis une nouvelle √©tait ins√©r√©e. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  La requ√™te renvoie une ligne (la nouvelle version): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Mais nous pouvons voir les deux versions sur la page: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  La version supprim√©e est √©tiquet√©e avec l'ID de la transaction en cours dans le champ <code>xmax</code> .  De plus, cette valeur a √©cras√© l'ancienne depuis l'annulation de la transaction pr√©c√©dente.  Et le bit <code>xmax_aborted</code> est r√©initialis√© car le statut de la transaction en cours est encore inconnu. <br><br>  La premi√®re version de la ligne fait d√©sormais r√©f√©rence √† la seconde, en tant que nouvelle. <br><br>  La page d'index contient d√©sormais le deuxi√®me pointeur et la deuxi√®me ligne, qui fait r√©f√©rence √† la deuxi√®me version dans la page du tableau. <br><br>  De la m√™me mani√®re que pour une suppression, la valeur de <code>xmax</code> dans la premi√®re version indique que la ligne est verrouill√©e. <br><br>  Enfin, nous validons la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Index </h1><br>  Jusqu'√† pr√©sent, nous ne parlions que de pages de table.  Mais que se passe-t-il √† l'int√©rieur des index? <br><br>  Les informations dans les pages d'index d√©pendent fortement du type d'index sp√©cifique.  De plus, m√™me un type d'index peut avoir diff√©rents types de pages.  Par exemple: un arbre B a la page de m√©tadonn√©es et les pages "normales". <br><br>  N√©anmoins, une page d'index a g√©n√©ralement un tableau de pointeurs vers les lignes et les lignes elles-m√™mes (tout comme les pages de table).  De plus, un espace √† la fin d'une page est allou√© aux donn√©es sp√©ciales. <br><br>  Les lignes dans les index peuvent √©galement avoir des structures diff√©rentes selon le type d'index.  Par exemple: dans un arbre B, les lignes pertinentes pour les pages feuilles contiennent la valeur de la cl√© d'indexation et une r√©f√©rence ( <code>ctid</code> ) √† la ligne de table appropri√©e.  En g√©n√©ral, un indice peut √™tre structur√© de mani√®re tr√®s diff√©rente. <br><br>  Le point principal est que dans les index de tout type, il n'y a pas de <em>versions de</em> lignes.  Ou nous pouvons consid√©rer que chaque ligne est repr√©sent√©e par une seule version.  En d'autres termes, l'en-t√™te de la ligne d'index ne contient pas les champs <code>xmin</code> et <code>xmax</code> .  Pour l'instant, nous pouvons supposer que les r√©f√©rences du point d'index √† toutes les versions des lignes de table.  Donc, pour savoir quelles versions de ligne sont visibles pour une transaction, PostgreSQL doit regarder dans le tableau.  (Comme d'habitude, ce n'est pas toute l'histoire. Parfois, la carte de visibilit√© permet d'optimiser le processus, mais nous en discuterons plus tard.) <br><br>  Ici, dans la page d'index, nous trouvons des pointeurs vers les deux versions: la mise √† jour et la pr√©c√©dente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transactions virtuelles </h1><br>  En pratique, PostgreSQL profite d'une optimisation qui permet de d√©penser "avec parcimonie" les ID de transaction. <br><br>  Si une transaction ne lit que des donn√©es, cela n'affecte en rien la visibilit√© du tuple.  Par cons√©quent, le processus backend attribue d'abord un ID virtuel (xid virtuel) √† la transaction.  Cet ID se compose de l'identifiant du processus et d'un num√©ro s√©quentiel. <br><br>  L'attribution de cet ID virtuel ne n√©cessite pas de synchronisation entre tous les processus et se fait donc tr√®s rapidement.  Nous d√©couvrirons une autre raison d'utiliser des identifiants virtuels lorsque nous discuterons du gel. <br><br>  Les instantan√©s de donn√©es ne prennent pas du tout en compte l'ID virtuel. <br><br>  √Ä diff√©rents moments, le syst√®me peut avoir des transactions virtuelles avec des identifiants d√©j√† utilis√©s, et c'est tr√®s bien.  Mais cet ID ne peut pas √™tre √©crit sur les pages de donn√©es car lorsque la page est acc√©d√©e la prochaine fois, l'ID peut devenir vide de sens. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Mais si une transaction commence √† modifier des donn√©es, elle re√ßoit un ID de transaction vrai et unique. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Sous-transactions </h1><br><h2>  Points de sauvegarde </h2><br>  En SQL, des <em>points de sauvegarde</em> sont d√©finis, ce qui permet d'annuler certaines op√©rations de la transaction sans son avortement complet.  Mais cela est incompatible avec le mod√®le ci-dessus car le statut de la transaction est un pour toutes les modifications et aucune donn√©e n'est physiquement annul√©e. <br><br>  Pour impl√©menter cette fonctionnalit√©, une transaction avec un point de sauvegarde est divis√©e en plusieurs sous- <em>transactions</em> distinctes dont les statuts peuvent √™tre g√©r√©s s√©par√©ment. <br><br>  Les sous-transactions ont leurs propres ID (sup√©rieurs √† l'ID de la transaction principale).  Les statuts des sous-transactions sont √©crits dans XACT de mani√®re habituelle, mais le statut final d√©pend du statut de la transaction principale: si elle est annul√©e, toutes les sous-transactions sont √©galement annul√©es. <br><br>  Les informations sur l'imbrication des sous-transactions sont stock√©es dans les fichiers du r√©pertoire PGDATA / pg_subtrans.  Ces fichiers sont accessibles via des tampons dans la m√©moire partag√©e de l'instance, qui sont structur√©s de la m√™me mani√®re que les tampons XACT. <br><br>  Ne confondez pas les sous-transactions avec les transactions autonomes.  Les transactions autonomes ne d√©pendent en aucun cas les unes des autres, tandis que les sous-transactions d√©pendent.  Il n'y a pas de transactions autonomes dans PostgreSQL ordinaire, ce qui est peut-√™tre pour le mieux: elles sont en fait extr√™mement rarement n√©cessaires, et leur disponibilit√© dans d'autres SGBD invite √† des abus, dont tout le monde souffre. <br><br>  Effa√ßons le tableau, d√©marrons une transaction et ins√©rons une ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Maintenant, nous √©tablissons un point de sauvegarde et ins√©rons une autre ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Notez que la fonction <code>txid_current</code> renvoie l'ID de la transaction principale plut√¥t que de la sous-transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Revenons au point de sauvegarde et ins√©rons la troisi√®me ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Dans la page, nous continuons de voir la ligne qui a √©t√© ajout√©e par la sous-transaction annul√©e. <br><br>  Validation des modifications. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  On voit clairement maintenant que chaque sous-transaction a son propre statut. <br><br>  Notez que SQL n'autorise pas l'utilisation explicite des sous-transactions, c'est-√†-dire que vous ne pouvez pas d√©marrer une nouvelle transaction avant d'avoir termin√© la transaction en cours.  Cette technique est implicitement impliqu√©e lorsque des points d'enregistrement sont utilis√©s et √©galement lors de la gestion des exceptions PL / pgSQL, ainsi que dans d'autres situations plus exotiques. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Erreurs et atomicit√© de fonctionnement </h2><br>  Que se passe-t-il si une erreur se produit pendant l'ex√©cution de l'op√©ration?  Par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Une erreur est survenue.  Maintenant, la transaction est trait√©e comme abandonn√©e et aucune op√©ration n'y est autoris√©e: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Et m√™me si nous essayons de valider les modifications, PostgreSQL signalera la restauration: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Pourquoi est-il impossible de poursuivre l'ex√©cution de la transaction apr√®s un √©chec?  Le fait est que l'erreur pourrait se produire afin que nous ayons acc√®s √† une partie des modifications, c'est-√†-dire que l'atomicit√© serait rompue non seulement pour la transaction, mais m√™me pour un seul op√©rateur.  Par exemple, dans notre exemple, l'op√©rateur aurait pu mettre √† jour une ligne avant que l'erreur ne se produise: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Il convient de noter que psql dispose d'un mode qui permet de poursuivre la transaction apr√®s l'√©chec, comme si les effets de l'op√©rateur erron√© √©taient annul√©s. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Il est facile de comprendre que dans ce mode, psql √©tablit en fait un point de sauvegarde implicite avant chaque commande et lance un retour en arri√®re en cas d'√©chec.  Ce mode n'est pas utilis√© par d√©faut, car l'√©tablissement de points de sauvegarde (m√™me sans retour en arri√®re) entra√Æne une surcharge importante. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477648/">https://habr.com/ru/post/fr477648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477634/index.html">Microservices et structure organisationnelle. Quels types d'√©quipes assureront le succ√®s?</a></li>
<li><a href="../fr477638/index.html">Achet√©! = Le v√¥tre: John Deere prive les agriculteurs du droit de r√©parer leurs propres tracteurs</a></li>
<li><a href="../fr477642/index.html">La vision (radio) de la machine voit √† travers les murs</a></li>
<li><a href="../fr477644/index.html">Restauration d'UNIX v0 sur PDP-7: D√©tails de l'arri√®re-boutique</a></li>
<li><a href="../fr477646/index.html">Les math√©maticiens coupent des formes √† la recherche de parties d'√©quations</a></li>
<li><a href="../fr477650/index.html">Cryptage du trafic TLS selon les algorithmes GOST-2012 avec Stunnel</a></li>
<li><a href="../fr477654/index.html">Essayer l'op√©rateur instanceof am√©lior√© dans Java 14</a></li>
<li><a href="../fr477656/index.html">Alors, pourquoi avez-vous besoin de faire?</a></li>
<li><a href="../fr477658/index.html">Active Restore: la reprise apr√®s sinistre peut-elle √™tre plus rapide? Beaucoup plus vite?</a></li>
<li><a href="../fr477662/index.html">Acc√®s aux pneus Redd sur les ponts FTDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>