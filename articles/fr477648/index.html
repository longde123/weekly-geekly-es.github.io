<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔔 👨🏿‍🍳 🕒 MVCC dans PostgreSQL-3. Versions en ligne 👨🏿‍🔧 🤘 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eh bien, nous avons déjà discuté de l' isolement et fait une digression concernant la structure des données de bas niveau . Et nous avons enfin attein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-3. Versions en ligne</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/477648/">  Eh bien, nous avons déjà discuté de l' <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolement</a> et fait une digression concernant <a href="https://habr.com/ru/company/postgrespro/blog/469087/">la structure des données de bas niveau</a> .  Et nous avons enfin atteint la chose la plus fascinante, à savoir les versions en ligne (tuples). <br><br><h1>  En-tête de tuple </h1><br>  Comme déjà mentionné, plusieurs versions de chaque ligne peuvent être disponibles simultanément dans la base de données.  Et nous devons en quelque sorte distinguer une version d'une autre.  À cette fin, chaque version est étiquetée avec son «temps» <code>xmin</code> ( <code>xmin</code> ) et son «temps» d'expiration ( <code>xmax</code> ).  Les guillemets indiquent qu'un compteur d'incrémentation spécial est utilisé plutôt que l'heure elle-même.  Et ce compteur est <em>l'identifiant de transaction</em> . <br><br>  (Comme d'habitude, en réalité, cela est plus compliqué: l'ID de transaction ne peut pas toujours augmenter en raison d'une profondeur de bits limitée du compteur. Mais nous explorerons plus de détails à ce sujet lorsque notre discussion atteindra le gel.) <br><a name="habracut"></a><br>  Lorsqu'une ligne est créée, la valeur de <code>xmin</code> est définie égale à l'ID de la transaction qui a exécuté la commande INSERT, tandis que <code>xmax</code> n'est pas renseigné. <br><br>  Lorsqu'une ligne est supprimée, la valeur <code>xmax</code> de la version actuelle est étiquetée avec l'ID de la transaction qui a effectué DELETE. <br><br>  Une commande UPDATE effectue en fait deux opérations suivantes: DELETE et INSERT.  Dans la version actuelle de la ligne, <code>xmax</code> est défini égal à l'ID de la transaction qui a effectué UPDATE.  Ensuite, une nouvelle version de la même ligne est créée, dans laquelle la valeur de <code>xmin</code> est identique à <code>xmax</code> de la version précédente. <br><br>  <code>xmin</code> champs <code>xmin</code> et <code>xmax</code> sont inclus dans l'en-tête d'une version de ligne.  En plus de ces champs, l'en-tête de tuple en contient d'autres, tels que: <br><br><ul><li>  <code>infomask</code> - plusieurs bits qui déterminent les propriétés d'un tuple donné.  Il y en a plusieurs, et nous en discuterons au fil du temps. </li><li>  <code>ctid</code> - une référence à la prochaine version, plus récente, de la même ligne.  <code>ctid</code> de la <code>ctid</code> de ligne la plus récente et la plus récente fait référence à cette même version.  Le nombre est sous la forme <code>(x,y)</code> , où <code>x</code> est le numéro de la page et <code>y</code> est le numéro d'ordre du pointeur dans le tableau. </li><li>  Le bitmap NULL, qui marque les colonnes d'une version donnée qui contiennent un NULL.  NULL n'est pas une valeur régulière des types de données, et par conséquent, nous devons stocker cette caractéristique séparément. </li></ul><br>  Par conséquent, l'en-tête semble assez volumineux: 23 octets par chaque tuple au minimum, mais généralement plus grand en raison de la bitmap NULL.  Si une table est «étroite» (c'est-à-dire qu'elle contient peu de colonnes), les octets de surcharge peuvent occuper plus d'espace que les informations utiles. <br><br><h1>  Insérer </h1><br>  Voyons plus en détail comment les opérations sur les lignes sont effectuées à un niveau bas, et commençons par un insert. <br><br>  Pour expérimenter, nous allons créer une nouvelle table avec deux colonnes et un index sur l'une d'entre elles: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre><br>  Nous commençons une transaction pour insérer une ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Voici l'ID de notre transaction en cours: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Examinons le contenu de la page.  La fonction <code>heap_page_items</code> de l'extension "pageinspect" nous permet d'obtenir des informations sur les pointeurs et les versions des lignes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Notez que le mot "tas" dans PostgreSQL désigne des tables.  C'est une autre utilisation bizarre d'un terme: un tas est une <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">structure de données</a> connue, qui n'a rien à voir avec une table.  Ce mot est utilisé ici dans le sens où "tout est entassé", contrairement aux index ordonnés. <br><br>  Cette fonction affiche les données "telles quelles", dans un format difficile à comprendre.  Pour clarifier les choses, nous ne laissons qu'une partie des informations et les interprétons: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Nous avons fait ce qui suit: <br><br><ul><li>  Ajout d'un zéro au numéro de pointeur pour qu'il ressemble à un <code>t_ctid</code> : (numéro de page, numéro de pointeur). </li><li>  Interprété l'état du pointeur <code>lp_flags</code> .  C'est "normal" ici, ce qui signifie que le pointeur fait référence à une version de ligne.  Nous discuterons d'autres valeurs plus tard. </li><li>  Jusqu'à présent, nous n'avons sélectionné que deux paires d'informations.  <code>xmin_committed</code> bits <code>xmin_committed</code> et <code>xmin_aborted</code> indiquent si la transaction avec l'ID <code>xmin</code> est <code>xmin</code> ( <code>xmin</code> ).  Une paire de bits similaires concerne la transaction avec l'ID <code>xmax</code> . </li></ul><br>  Qu'observons-nous?  Lorsqu'une ligne est insérée, dans la page du tableau apparaît un pointeur qui a le numéro 1 et fait référence à la première et la seule version de la ligne. <br><br>  Le champ <code>xmin</code> dans le tuple est rempli avec l'ID de la transaction en cours.  Étant donné que la transaction est toujours active, les bits <code>xmin_committed</code> et <code>xmin_aborted</code> sont non <code>xmin_aborted</code> . <br><br>  Le champ <code>ctid</code> de la version de ligne fait référence à la même ligne.  Cela signifie qu'aucune version plus récente n'est disponible. <br><br>  Le champ <code>xmax</code> est rempli avec le numéro conventionnel 0 puisque le tuple n'est pas supprimé, c'est-à-dire à jour.  Les transactions <code>xmax_aborted</code> ce nombre en raison de l' <code>xmax_aborted</code> bits <code>xmax_aborted</code> . <br><br>  Passons à l'étape suivante pour améliorer la lisibilité en ajoutant des bits d'information aux ID de transaction.  Et créons la fonction puisque nous aurons besoin de la requête plus d'une fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Ce qui se passe dans l'en-tête de la version ligne est beaucoup plus clair sous cette forme: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Nous pouvons obtenir des informations similaires, mais beaucoup moins détaillées, à partir du tableau lui-même en utilisant des pseudo-colonnes <code>xmin</code> et <code>xmax</code> : <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Valider </h1><br>  Lorsqu'une transaction réussit, son statut doit être mémorisé, c'est-à-dire que la transaction doit être marquée comme validée.  À cette fin, la structure XACT est utilisée.  (Avant la version 10, il s'appelait CLOG (journal de validation), et vous êtes toujours susceptible de rencontrer ce nom.) <br><br>  XACT n'est pas une table du catalogue système, mais des fichiers dans le répertoire PGDATA / pg_xact.  Deux bits sont alloués dans ces fichiers pour chaque transaction - "validés" et "abandonnés" - exactement de la même manière que dans l'en-tête de tuple.  Ces informations sont réparties sur plusieurs fichiers uniquement pour des raisons de commodité;  nous y reviendrons lorsque nous discuterons du gel.  PostgreSQL fonctionne avec ces fichiers page par page, comme avec tous les autres. <br><br>  Ainsi, lorsqu'une transaction est validée, le bit "validé" est défini pour cette transaction dans XACT.  Et c'est tout ce qui se passe lorsque la transaction est validée (bien que nous ne mentionnions pas encore le journal d'écriture anticipée). <br><br>  Lorsqu'une autre transaction accède à la page du tableau que nous venons de voir, la première devra répondre à quelques questions. <br><br><ol><li>  La transaction <code>xmin</code> t-elle <code>xmin</code> effectuée?  Sinon, le tuple créé ne doit pas être visible. <br>  Ceci est vérifié en regardant à travers une autre structure, qui se trouve dans la mémoire partagée de l'instance et appelée ProcArray.  Cette structure contient une liste de tous les processus actifs, ainsi que l'ID de la transaction (active) actuelle pour chacun. </li><li>  Si la transaction a été effectuée, a-t-elle été validée ou annulée?  S'il a été annulé, le tuple ne doit pas non plus être visible. <br>  C'est exactement pour cela que XACT est nécessaire.  Mais il est coûteux de vérifier XACT à chaque fois, bien que les dernières pages de XACT soient stockées dans des tampons dans la mémoire partagée.  Par conséquent, une fois compris, l'état de la transaction est écrit sur les bits <code>xmin_committed</code> et <code>xmin_aborted</code> du tuple.  Si l'un de ces bits est défini, l'état de la transaction est traité comme connu et la prochaine transaction n'aura pas besoin de vérifier XACT. </li></ol><br>  Pourquoi la transaction qui effectue l'insertion ne définit-elle pas ces bits?  Lorsqu'une insertion est en cours, la transaction ne sait pas encore si elle se terminera avec succès.  Et au moment de la validation, il est déjà difficile de savoir quelles lignes et dans quelles pages ont été modifiées.  Il peut y avoir beaucoup de ces pages, et il n'est pas pratique de les suivre.  En outre, certaines pages peuvent être supprimées du disque du cache de tampon;  les relire afin de changer les bits signifierait un ralentissement significatif de la validation. <br><br>  Le revers de l'économie est qu'après les mises à jour, toute transaction (même celle exécutant SELECT) peut commencer à changer les pages de données dans le cache de tampon. <br><br>  Nous engageons donc le changement. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Rien n'a changé dans la page (mais nous savons que l'état des transactions est déjà écrit dans XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Maintenant, une transaction qui accède d'abord à la page devra déterminer le statut de la transaction <code>xmin</code> et l'écrira dans les bits d'information: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Effacer </h1><br>  Lorsqu'une ligne est supprimée, l'ID de la transaction de suppression en cours est écrit dans le champ <code>xmax</code> de la version à jour et le bit <code>xmax_aborted</code> est réinitialisé. <br><br>  Notez que la valeur de <code>xmax</code> correspondant à la transaction active fonctionne comme un verrou de ligne.  Si une autre transaction va mettre à jour ou supprimer cette ligne, elle devra attendre la <code>xmax</code> transaction <code>xmax</code> .  Nous parlerons des verrous plus en détail plus tard.  À ce stade, notez seulement que le nombre de verrous de ligne n'est pas du tout limité.  Ils n'occupent pas de mémoire et les performances du système ne sont pas affectées par ce nombre.  Cependant, les transactions de longue durée présentent d'autres inconvénients, qui seront également abordés plus loin. <br><br>  Supprimons une ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Nous voyons que l'ID de transaction est écrit dans le champ <code>xmax</code> , mais les bits d'information ne sont pas définis: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Abandonner </h1><br>  L'abandon d'une transaction fonctionne de manière similaire pour la validation, sauf que le bit "abandonné" est défini dans XACT.  Un abandon se fait aussi rapidement qu'un commit.  Bien que la commande soit appelée ROLLBACK, les modifications ne sont pas annulées: tout ce que la transaction a déjà changé, reste intact. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Lors de l'accès à la page, l'état sera vérifié et le bit de conseil <code>xmax_aborted</code> sera défini.  Bien que le nombre <code>xmax</code> lui-même soit toujours dans la page, il ne sera pas examiné. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Mettre à jour </h1><br>  Une mise à jour fonctionne comme si la version actuelle était supprimée en premier, puis une nouvelle était insérée. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  La requête renvoie une ligne (la nouvelle version): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Mais nous pouvons voir les deux versions sur la page: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  La version supprimée est étiquetée avec l'ID de la transaction en cours dans le champ <code>xmax</code> .  De plus, cette valeur a écrasé l'ancienne depuis l'annulation de la transaction précédente.  Et le bit <code>xmax_aborted</code> est réinitialisé car le statut de la transaction en cours est encore inconnu. <br><br>  La première version de la ligne fait désormais référence à la seconde, en tant que nouvelle. <br><br>  La page d'index contient désormais le deuxième pointeur et la deuxième ligne, qui fait référence à la deuxième version dans la page du tableau. <br><br>  De la même manière que pour une suppression, la valeur de <code>xmax</code> dans la première version indique que la ligne est verrouillée. <br><br>  Enfin, nous validons la transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Index </h1><br>  Jusqu'à présent, nous ne parlions que de pages de table.  Mais que se passe-t-il à l'intérieur des index? <br><br>  Les informations dans les pages d'index dépendent fortement du type d'index spécifique.  De plus, même un type d'index peut avoir différents types de pages.  Par exemple: un arbre B a la page de métadonnées et les pages "normales". <br><br>  Néanmoins, une page d'index a généralement un tableau de pointeurs vers les lignes et les lignes elles-mêmes (tout comme les pages de table).  De plus, un espace à la fin d'une page est alloué aux données spéciales. <br><br>  Les lignes dans les index peuvent également avoir des structures différentes selon le type d'index.  Par exemple: dans un arbre B, les lignes pertinentes pour les pages feuilles contiennent la valeur de la clé d'indexation et une référence ( <code>ctid</code> ) à la ligne de table appropriée.  En général, un indice peut être structuré de manière très différente. <br><br>  Le point principal est que dans les index de tout type, il n'y a pas de <em>versions de</em> lignes.  Ou nous pouvons considérer que chaque ligne est représentée par une seule version.  En d'autres termes, l'en-tête de la ligne d'index ne contient pas les champs <code>xmin</code> et <code>xmax</code> .  Pour l'instant, nous pouvons supposer que les références du point d'index à toutes les versions des lignes de table.  Donc, pour savoir quelles versions de ligne sont visibles pour une transaction, PostgreSQL doit regarder dans le tableau.  (Comme d'habitude, ce n'est pas toute l'histoire. Parfois, la carte de visibilité permet d'optimiser le processus, mais nous en discuterons plus tard.) <br><br>  Ici, dans la page d'index, nous trouvons des pointeurs vers les deux versions: la mise à jour et la précédente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transactions virtuelles </h1><br>  En pratique, PostgreSQL profite d'une optimisation qui permet de dépenser "avec parcimonie" les ID de transaction. <br><br>  Si une transaction ne lit que des données, cela n'affecte en rien la visibilité du tuple.  Par conséquent, le processus backend attribue d'abord un ID virtuel (xid virtuel) à la transaction.  Cet ID se compose de l'identifiant du processus et d'un numéro séquentiel. <br><br>  L'attribution de cet ID virtuel ne nécessite pas de synchronisation entre tous les processus et se fait donc très rapidement.  Nous découvrirons une autre raison d'utiliser des identifiants virtuels lorsque nous discuterons du gel. <br><br>  Les instantanés de données ne prennent pas du tout en compte l'ID virtuel. <br><br>  À différents moments, le système peut avoir des transactions virtuelles avec des identifiants déjà utilisés, et c'est très bien.  Mais cet ID ne peut pas être écrit sur les pages de données car lorsque la page est accédée la prochaine fois, l'ID peut devenir vide de sens. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Mais si une transaction commence à modifier des données, elle reçoit un ID de transaction vrai et unique. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Sous-transactions </h1><br><h2>  Points de sauvegarde </h2><br>  En SQL, des <em>points de sauvegarde</em> sont définis, ce qui permet d'annuler certaines opérations de la transaction sans son avortement complet.  Mais cela est incompatible avec le modèle ci-dessus car le statut de la transaction est un pour toutes les modifications et aucune donnée n'est physiquement annulée. <br><br>  Pour implémenter cette fonctionnalité, une transaction avec un point de sauvegarde est divisée en plusieurs sous- <em>transactions</em> distinctes dont les statuts peuvent être gérés séparément. <br><br>  Les sous-transactions ont leurs propres ID (supérieurs à l'ID de la transaction principale).  Les statuts des sous-transactions sont écrits dans XACT de manière habituelle, mais le statut final dépend du statut de la transaction principale: si elle est annulée, toutes les sous-transactions sont également annulées. <br><br>  Les informations sur l'imbrication des sous-transactions sont stockées dans les fichiers du répertoire PGDATA / pg_subtrans.  Ces fichiers sont accessibles via des tampons dans la mémoire partagée de l'instance, qui sont structurés de la même manière que les tampons XACT. <br><br>  Ne confondez pas les sous-transactions avec les transactions autonomes.  Les transactions autonomes ne dépendent en aucun cas les unes des autres, tandis que les sous-transactions dépendent.  Il n'y a pas de transactions autonomes dans PostgreSQL ordinaire, ce qui est peut-être pour le mieux: elles sont en fait extrêmement rarement nécessaires, et leur disponibilité dans d'autres SGBD invite à des abus, dont tout le monde souffre. <br><br>  Effaçons le tableau, démarrons une transaction et insérons une ligne: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Maintenant, nous établissons un point de sauvegarde et insérons une autre ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Notez que la fonction <code>txid_current</code> renvoie l'ID de la transaction principale plutôt que de la sous-transaction. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Revenons au point de sauvegarde et insérons la troisième ligne. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Dans la page, nous continuons de voir la ligne qui a été ajoutée par la sous-transaction annulée. <br><br>  Validation des modifications. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  On voit clairement maintenant que chaque sous-transaction a son propre statut. <br><br>  Notez que SQL n'autorise pas l'utilisation explicite des sous-transactions, c'est-à-dire que vous ne pouvez pas démarrer une nouvelle transaction avant d'avoir terminé la transaction en cours.  Cette technique est implicitement impliquée lorsque des points d'enregistrement sont utilisés et également lors de la gestion des exceptions PL / pgSQL, ainsi que dans d'autres situations plus exotiques. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Erreurs et atomicité de fonctionnement </h2><br>  Que se passe-t-il si une erreur se produit pendant l'exécution de l'opération?  Par exemple, comme ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Une erreur est survenue.  Maintenant, la transaction est traitée comme abandonnée et aucune opération n'y est autorisée: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Et même si nous essayons de valider les modifications, PostgreSQL signalera la restauration: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Pourquoi est-il impossible de poursuivre l'exécution de la transaction après un échec?  Le fait est que l'erreur pourrait se produire afin que nous ayons accès à une partie des modifications, c'est-à-dire que l'atomicité serait rompue non seulement pour la transaction, mais même pour un seul opérateur.  Par exemple, dans notre exemple, l'opérateur aurait pu mettre à jour une ligne avant que l'erreur ne se produise: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Il convient de noter que psql dispose d'un mode qui permet de poursuivre la transaction après l'échec, comme si les effets de l'opérateur erroné étaient annulés. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Il est facile de comprendre que dans ce mode, psql établit en fait un point de sauvegarde implicite avant chaque commande et lance un retour en arrière en cas d'échec.  Ce mode n'est pas utilisé par défaut, car l'établissement de points de sauvegarde (même sans retour en arrière) entraîne une surcharge importante. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Continuez à lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr477648/">https://habr.com/ru/post/fr477648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr477634/index.html">Microservices et structure organisationnelle. Quels types d'équipes assureront le succès?</a></li>
<li><a href="../fr477638/index.html">Acheté! = Le vôtre: John Deere prive les agriculteurs du droit de réparer leurs propres tracteurs</a></li>
<li><a href="../fr477642/index.html">La vision (radio) de la machine voit à travers les murs</a></li>
<li><a href="../fr477644/index.html">Restauration d'UNIX v0 sur PDP-7: Détails de l'arrière-boutique</a></li>
<li><a href="../fr477646/index.html">Les mathématiciens coupent des formes à la recherche de parties d'équations</a></li>
<li><a href="../fr477650/index.html">Cryptage du trafic TLS selon les algorithmes GOST-2012 avec Stunnel</a></li>
<li><a href="../fr477654/index.html">Essayer l'opérateur instanceof amélioré dans Java 14</a></li>
<li><a href="../fr477656/index.html">Alors, pourquoi avez-vous besoin de faire?</a></li>
<li><a href="../fr477658/index.html">Active Restore: la reprise après sinistre peut-elle être plus rapide? Beaucoup plus vite?</a></li>
<li><a href="../fr477662/index.html">Accès aux pneus Redd sur les ponts FTDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>