<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçæ üìÄ üéñÔ∏è Escalade d'Elbrus - Reconnaissance au combat. Partie technique 2. Interruptions, exceptions, minuterie syst√®me üíù üë©üèª‚ÄçüöÄ üë£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons d'explorer Elbrus en y portant Embox . 

 Cet article est la deuxi√®me partie d'un article technique sur l'architecture Elbrus. La prem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escalade d'Elbrus - Reconnaissance au combat. Partie technique 2. Interruptions, exceptions, minuterie syst√®me</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447744/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  Nous continuons d'explorer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elbrus</a> en y portant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embox</a> . <br><br>  Cet article est la deuxi√®me partie d'un article technique sur l'architecture Elbrus.  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie</a> portait sur les piles, les registres, etc.  Avant de lire cette partie, nous vous recommandons d'√©tudier la premi√®re, car elle traite des √©l√©ments de base de l'architecture Elbrus.  Cette section se concentrera sur les temporisateurs, les interruptions et les exceptions.  Encore une fois, ce n'est pas une documentation officielle.  Pour cela, vous devez contacter les d√©veloppeurs d'Elbrus √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ICST</a> . <a name="habracut"></a><br>  Pour en venir √† l'√©tude d'Elbrus, nous voulions d√©marrer rapidement le chronom√®tre, car, comme vous le savez, le multit√¢che pr√©emptif ne fonctionne pas sans lui.  Pour ce faire, il semblait suffisant d'impl√©menter le contr√¥leur d'interruption et le temporisateur lui-m√™me, mais nous avons rencontr√© <s>des</s> difficult√©s <s>inattendues</s> , o√π irions-nous sans eux.  Ils ont commenc√© √† rechercher des capacit√©s de d√©bogage et ont d√©couvert que les d√©veloppeurs s'en sont occup√©s en introduisant plusieurs commandes qui vous permettent de d√©clencher diverses situations exceptionnelles.  Par exemple, vous pouvez g√©n√©rer une exception d'un type sp√©cial via les registres PSR (registre d'√©tat du processeur) et UPSR (registre d'√©tat du processeur utilisateur).  Pour PSR, le bit exc_last_wish est l'indicateur d'exception exc_last_wish lors du retour de la proc√©dure, et pour UPSR, exc_d_interrupt est l'indicateur d'interruption retard√©e g√©n√©r√©e par l'op√©ration VFDI (V√©rifier l'indicateur d'interruption retard√©e). <br><br>  Le code est le suivant: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UPSR_DI (1 &lt;&lt; 3) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   .h  */</span></span></span><span class="hljs-meta"> rrs %upsr, %r1 ors %r1, UPSR_DI, %r1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* upsr |= UPSR_DI; */</span></span></span><span class="hljs-meta"> rws %r1, %upsr vfdi </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span></span></code> </pre> <br>  Lanc√©.  Mais rien ne s'est produit, le syst√®me s'est bloqu√© quelque part, rien n'a √©t√© √©mis vers la console.  En fait, nous l'avons vu lorsque nous avons essay√© de d√©marrer l'interruption √† partir de la minuterie, mais il y avait alors de nombreux composants, et ici, il √©tait clair que quelque chose interrompait la progression s√©quentielle de notre programme, et le contr√¥le a √©t√© transf√©r√© vers la table des exceptions (en termes d'architecture Elbrus, il est plus correct de ne pas parler de la table interruptions et sur le tableau des exceptions).  Nous avons suppos√© que le processeur avait n√©anmoins lev√© une exception, mais il y avait des ¬´d√©chets¬ª o√π il a transf√©r√© le contr√¥le.  En fait, il transf√®re le contr√¥le √† l'endroit m√™me o√π nous avons mis l'image Embox, ce qui signifie qu'il y avait un point d'entr√©e - la fonction d'entr√©e. <br><br>  Pour v√©rification, nous avons fait ce qui suit.  D√©marr√© un compteur d'entr√©es dans l'entr√©e ().  Initialement, tous les processeurs commencent par des interruptions d√©sactiv√©es, entrent dans entry (), apr√®s quoi nous ne laissons qu'un seul c≈ìur actif, tous les autres entrent dans une boucle sans fin.  Une fois que le compteur est √©gal au nombre de CPU, nous consid√©rons que tous les hits suivants en entr√©e sont des exceptions.  Je vous rappelle qu'avant c'√©tait comme d√©crit dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre tout premier article sur Elbrus</a> <br><br><pre> <code class="cpp hljs"> cpuid = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;last_cpuid); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpuid &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* copy of trap table */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)<span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;_t_entry, <span class="hljs-number"><span class="hljs-number">0x1800</span></span>); kernel_start();</code> </pre> <br>  L'a fait <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Since we enable exceptions only when all CPUs except the main one * reached the idle state (cpu_idle), we can rely that order and can * guarantee exceptions happen strictly after all CPUS entries. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt;= CPU_COUNT) { <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); ... } <span class="hljs-comment"><span class="hljs-comment">/* It wasn't exception, so we decide this usual program execution, * that is, Embox started on CPU0 or CPU1 */</span></span> e2k_wait_all(); entries_count = __e2k_atomic32_add(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;entries_count); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entries_count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* XXX currently we support only single core */</span></span> cpu_idle(); } e2k_kernel_start(); }</code> </pre> <br>  Et enfin, nous avons vu la r√©action √† l'entr√©e de l'interruption (juste avec l'aide de printf, nous avons imprim√© une ligne). <br><br>  Ici, il convient d'expliquer qu'au d√©part, dans la premi√®re version, nous nous attendions √† copier le tableau des exceptions, mais d'une part, il s'est av√©r√© que c'√©tait √† notre adresse, et d'autre part, nous n'avons pas pu faire la copie correcte.  J'ai d√ª r√©√©crire les scripts de l'√©diteur de liens, le point d'entr√©e dans le syst√®me et le gestionnaire d'interruption, c'est-√†-dire que j'avais besoin de la partie assembleur, √† ce sujet un peu plus tard. <br><br>  Voici √† quoi ressemble maintenant la partie de la partie modifi√©e de l'√©diteur de liens de script: <br><br><pre> <code class="cpp hljs">.text : { _start = .; _t_entry = .; <span class="hljs-comment"><span class="hljs-comment">/* Interrupt handler */</span></span> *(.ttable_entry0) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Syscall handler */</span></span> *(.ttable_entry1) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* longjmp handler */</span></span> *(.ttable_entry2) . = _t_entry + <span class="hljs-number"><span class="hljs-number">0x1800</span></span>; _t_entry_end = .; *(.e2k_entry) *(.cpu_idle) <span class="hljs-comment"><span class="hljs-comment">/* text */</span></span> }</code> </pre><br>  c'est-√†-dire que nous avons supprim√© la section d'entr√©e de la table des exceptions.  La section cpu_idle s'y trouve √©galement pour les CPU qui ne sont pas utilis√©s. <br><br>  Voici √† quoi ressemble la fonction d'entr√©e pour notre noyau actif, sur lequel Embox s'ex√©cutera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e2k_kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernel_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> psr; <span class="hljs-comment"><span class="hljs-comment">/*    CPU ‚Äú‚Äù */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (idled_cpus_count &lt; CPU_COUNT - <span class="hljs-number"><span class="hljs-number">1</span></span>) ; ... <span class="hljs-comment"><span class="hljs-comment">/*     ,     */</span></span> e2k_upsr_write(e2k_upsr_read() &amp; ~UPSR_FE); kernel_start(); <span class="hljs-comment"><span class="hljs-comment">/*   Embox */</span></span> }</code> </pre> <br>  Eh bien, selon l'instruction VFDI, une exception a √©t√© lev√©e.  Vous devez maintenant obtenir son num√©ro pour vous assurer qu'il s'agit de la bonne exception.  Pour cela, Elbrus dispose de registres d'informations d'interruption TIR (Trap Info registers).  Ils contiennent des informations sur les derni√®res commandes, c'est-√†-dire la derni√®re partie de la trace.  Trace se rassemble pendant l'ex√©cution du programme et ¬´se bloque¬ª lors de la saisie d'une interruption.  TIR comprend les parties basse (64 bits) et haute (64 bits).  Le mot bas contient les drapeaux d'exception et le mot haut contient un pointeur vers l'instruction qui a conduit √† l'exception et le num√©ro TIR actuel.  Par cons√©quent, dans notre cas, exc_d_interrupt est le 4e bit. <br><br>  Remarque Nous avons encore quelques malentendus concernant la profondeur (nombre) des TIR.  La documentation fournit: <br><blockquote>  "La profondeur de la m√©moire TIR, c'est-√†-dire le nombre de registres d'informations sur les pi√®ges, est d√©termin√©e <br>  Macro TIR_NUM √©gale au nombre d'√©tages de pipeline de processeur requis pour <br>  √©mettre toutes les situations sp√©ciales possibles.  TIR_NUM = 19; " </blockquote>  En pratique, nous voyons la profondeur = 1, et donc nous utilisons uniquement le registre TIR0. <br><br>  Les sp√©cialistes du MCST nous ont expliqu√© que tout est correct, et il n'y aura de TIR0 que pour les interruptions ¬´pr√©cises¬ª, mais pour d'autres situations, il peut y avoir autre chose.  Mais comme nous ne parlons que d'interruptions de temporisation, cela ne nous d√©range pas. <br><br>  Ok, regardons maintenant ce qui est n√©cessaire pour entrer / quitter correctement le gestionnaire d'exceptions.  En fait, il est n√©cessaire de sauvegarder en entr√©e et de restaurer les 5 registres suivants en sortie.  Trois registres de pr√©paration de transfert de contr√¥le sont ctpr [1,2,3], et deux registres de contr√¥le de cycle sont ILCR (registre des valeurs initiales du compteur de cycles) et LSR (registre de l'√©tat du cycle). <br><br><pre> <code class="cpp hljs">.type ttable_entry0,@function ttable_entry0: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">1</span></span>; rrd %ctpr1, %dr1 rrd %ctpr2, %dr2 rrd %ctpr3, %dr3 rrd %ilcr, %dr4 rrd %lsr, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* sizeof pt_regs */</span></span> getsp -(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">8</span></span>), %dr0 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + PT_CTRP1] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr1 = ctpr1 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + PT_CTRP2] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr2 = ctpr2 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + PT_CTRP3] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ctpr3 = ctpr3 */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + PT_ILCR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;ilcr = ilcr */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + PT_LSR] <span class="hljs-comment"><span class="hljs-comment">/* regs-&gt;lsr = lsr */</span></span> disp %ctpr1, e2k_entry ct %ctpr1</code> </pre> <br>  En fait, c'est tout, apr√®s avoir quitt√© le gestionnaire d'exceptions, vous devez restaurer ces 5 registres. <br><br>  Nous le faisons avec une macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESTORE_COMMON_REGS(regs) \ ({ \ uint64_t ctpr1 = regs-&gt;ctpr1, ctpr2 = regs-&gt;ctpr2, \ ctpr3 = regs-&gt;ctpr3, lsr = regs-&gt;lsr, \ ilcr = regs-&gt;ilcr; \ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ctpr2 is restored first because of tight time constraints \ * on restoring ctpr2 and aaldv. */</span></span></span><span class="hljs-meta"> \ E2K_SET_DSREG(ctpr1, ctpr1); \ E2K_SET_DSREG(ctpr2, ctpr2); \ E2K_SET_DSREG(ctpr3, ctpr3); \ E2K_SET_DSREG(lsr, lsr); \ E2K_SET_DSREG(ilcr, ilcr); \ })</span></span></code> </pre> <br>  Il est √©galement important de ne pas oublier apr√®s la restauration des registres d'appeler l'op√©ration DONE (Return from the hardware interrupt handler).  Cette op√©ration est notamment n√©cessaire pour traiter correctement les op√©rations de transfert de commande interrompues.  Nous le faisons avec une macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_DONE \ do { \ asm volatile (</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"{nop 3} {done}"</span></span></span><span class="hljs-meta"> ::: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ctpr3"</span></span></span><span class="hljs-meta">); \ } while (0)</span></span></code> </pre> <br>  En fait, nous faisons le retour de l'interruption directement en code C en utilisant ces deux macros. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* Entering here because of expection or interrupt */</span></span> e2k_trap_handler(regs); RESTORE_COMMON_REGS(regs); E2K_DONE;</code> </pre> <br><h3>  Interruptions externes </h3><br>  Commen√ßons par la fa√ßon d'activer les interruptions externes.  Dans Elbrus, APIC (ou plut√¥t son analogue) est utilis√© comme contr√¥leur d'interruption; Embox avait d√©j√† ce pilote.  Par cons√©quent, il √©tait possible de prendre un minuteur syst√®me pour cela.  Il y a deux minuteries, l'une qui est tr√®s similaire √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PIT</a> , l'autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LAPIC Timer</a> , est √©galement assez standard, donc cela n'a aucun sens d'en parler.  Cela et cela semblaient simples, et cela et cela existaient d√©j√† dans Embox, mais le pilote du temporisateur LAPIC semblait plus en perspective, en plus de la mise en ≈ìuvre du temporisateur PIT nous semblait plus non standard.  Par cons√©quent, cela semblait plus facile √† r√©aliser.  De plus, la documentation officielle d√©crivait les registres APIC et LAPIC, qui √©taient l√©g√®rement diff√©rents des originaux.  Les apporter n'a aucun sens, comme vous pouvez le voir dans l'original. <br><br>  En plus d'autoriser les interruptions dans APIC, vous devez activer la gestion des interruptions via les registres PSR / UPSR.  Les deux registres ont des drapeaux pour activer les interruptions externes et les interruptions non masquables.  <i>MAIS</i> ici, il est tr√®s important de noter que le registre PSR est <i>local</i> √† la fonction (cela a √©t√© discut√© dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie technique</a> ).  Et cela signifie que si vous la placez dans une fonction, alors lorsque vous appelez toutes les fonctions suivantes, elle sera h√©rit√©e, mais lorsque vous reviendrez de la fonction, elle reviendra √† son √©tat d'origine.  D'o√π la question, mais comment g√©rer les interruptions? <br><br>  Nous utilisons la solution suivante.  Le registre PSR vous permet d'activer la gestion via UPSR, qui est d√©j√† mondial (dont nous avons besoin).  Par cons√©quent, nous activons le contr√¥le via UPSR directement (important!) Avant la fonction de connexion de base Embox: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PSR is local register and makes sense only within a function, * so we set it here before kernel start. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rrs %%psr, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr) :)</span></span></span></span>; psr |= (PSR_IE | PSR_NMIE | PSR_UIE); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"rws %0, %%psr"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ri"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(psr))</span></span></span></span>; kernel_start();</code> </pre> <br>  D'une certaine mani√®re, par hasard, apr√®s refactoring, j'ai pris et mis ces lignes dans une fonction distincte ... Et le registre est local √† la fonction.  Il est clair que tout est cass√© :) <br><br>  Donc, tout semble √™tre activ√© dans le processeur, allez au contr√¥leur d'interruption. <br><br>  Comme nous l'avons vu ci-dessus, les informations sur le num√©ro d'exception figurent dans le registre TIR.  En outre, le 32e bit de ce registre signale qu'une interruption externe s'est produite. <br><br>  Apr√®s avoir allum√© la minuterie, quelques jours de tourments ont suivi, car aucune interruption n'a pu √™tre obtenue.  La raison √©tait assez amusante.  Il y a des pointeurs 64 bits dans Elbrus, et l'adresse de registre dans APIC est entr√©e dans uint32_t, c'est pourquoi nous les avons utilis√©s.  Mais il s'est av√©r√© que si vous avez besoin, par exemple, de convertir 0xF0000000 en un pointeur, vous n'obtiendrez pas 0xF0000000, mais 0xFFFFFFFFF0000000.  Autrement dit, le compilateur √©tendra votre signe int non sign√©. <br><br>  Ici, bien s√ªr, il √©tait n√©cessaire d'utiliser uintptr_t, car, comme il s'est av√©r√©, dans la norme C99, ce type de distribution est d√©fini par l'impl√©mentation. <br><br>  Apr√®s avoir finalement vu le 32√®me bit relev√© dans TIR, nous avons commenc√© √† chercher comment obtenir le num√©ro d'interruption.  Cela s'est av√©r√© assez simple, bien que pas du tout comme sur x86, c'est l'une des diff√©rences entre les impl√©mentations LAPIC.  Pour Elbrus, pour obtenir le num√©ro d'interruption, vous devez entrer dans le registre sp√©cial LAPIC: <br><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APIC_VECT (0xFEE00000 + 0xFF0)</span></span></code> </pre> <br>  o√π 0xFEE00000 est l'adresse de base des registres LAPIC. <br><br>  C'est tout, il s'est av√©r√© prendre √† la fois le minuteur du syst√®me et le minuteur LAPIC. <br><br><h3>  Conclusion </h3><br>  Les informations fournies dans les deux premi√®res parties techniques de l'article sur l'architecture Elbrus sont suffisantes pour impl√©menter les interruptions mat√©rielles et le multit√¢che pr√©emptif dans n'importe quel syst√®me d'exploitation.  En fait, les captures d'√©cran donn√©es en t√©moignent. <br><br><img src="https://habrastorage.org/webt/qm/qz/3p/qmqz3pbvuvohscm_qon1edf5jno.png"><br><br>  Ce n'est pas la derni√®re partie technique de l'architecture Elbrus.  Maintenant que nous ma√Ætrisons la gestion de la m√©moire (MMU) √† Elbrus, nous esp√©rons en parler bient√¥t.  Nous en avons besoin non seulement pour la mise en ≈ìuvre des espaces d'adressage virtuels, mais aussi pour le travail normal avec les p√©riph√©riques, car gr√¢ce √† ce m√©canisme, vous pouvez d√©sactiver ou activer la mise en cache d'une zone sp√©cifique de l'espace d'adressage. <br><br>  Tout ce qui est √©crit dans l'article se trouve dans le r√©f√©rentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embox</a> .  Vous pouvez √©galement cr√©er et ex√©cuter, s'il existe bien s√ªr une plate-forme mat√©rielle.  Certes, un compilateur est n√©cessaire pour cela, et il ne peut √™tre obtenu qu'au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MCST</a> .  La documentation officielle peut y √™tre demand√©e. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr447744/">https://habr.com/ru/post/fr447744/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr447732/index.html">Identifiant de race de chien: d√©veloppement de cycle complet du programme Keras √† l'application Android. sur le march√© du jeu</a></li>
<li><a href="../fr447734/index.html">Pourquoi le front-end devrait comprendre les principes de l'interface utilisateur</a></li>
<li><a href="../fr447736/index.html">Vid√©o drone - une nouvelle tendance dans les r√©seaux sociaux</a></li>
<li><a href="../fr447738/index.html">Julian Assange arr√™t√© par la police britannique</a></li>
<li><a href="../fr447742/index.html">Quelle est la m√©thodologie DevOps et qui en a besoin</a></li>
<li><a href="../fr447748/index.html">Syst√®mes de fichiers virtuels Linux: pourquoi sont-ils n√©cessaires et comment fonctionnent-ils? 2e partie</a></li>
<li><a href="../fr447754/index.html">Application de barre de menus pour macOS</a></li>
<li><a href="../fr447756/index.html">Nouveau quadrant Gartner pour les solutions de surveillance des applications (APM)</a></li>
<li><a href="../fr447784/index.html">Musique le jour de la cosmonautique</a></li>
<li><a href="../fr447786/index.html">Contexte: Robot Fedor, qu'√™tes-vous?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>