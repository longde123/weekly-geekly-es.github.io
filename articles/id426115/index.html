<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 🤴🏾 👇🏿 Praktek menggunakan model aktor di platform backend dari Quake Champions 🧓🏻 🚠 🙎🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya terus mengunggah laporan dengan Pixonic DevGAMM Talks, pertemuan September kami untuk para pengembang sistem yang sarat muatan. Mereka berbagi ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Praktek menggunakan model aktor di platform backend dari Quake Champions</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/426115/">  Saya terus mengunggah laporan dengan Pixonic DevGAMM Talks, pertemuan September kami untuk para pengembang sistem yang sarat muatan.  Mereka berbagi banyak pengalaman dan kasus, dan hari ini saya menerbitkan transkrip pidato pengembang backend dari Sabre Interactive Roman Rogozin.  Dia berbicara tentang praktik penerapan model aktor menggunakan contoh mengelola pemain dan negara mereka (laporan lain dapat ditemukan di akhir artikel, daftar dilengkapi). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dDYQpvtEEfo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  Tim kami sedang mengerjakan backend untuk game Quake Champions, dan saya akan berbicara tentang apa model aktor dan bagaimana digunakan dalam proyek. <br><br>  Sedikit tentang tumpukan teknologi.  Kami menulis kode dalam C #, masing-masing, semua teknologi terikat padanya.  Saya ingin mencatat bahwa akan ada beberapa hal spesifik yang akan saya perlihatkan pada contoh bahasa ini, tetapi prinsip-prinsip umum akan tetap tidak berubah. <br><br><img src="https://habrastorage.org/webt/h-/st/yl/h-styljhwr1ci0hqzjnibcbgx2q.png"><br><br>  Saat ini, kami menyelenggarakan layanan kami di Azure.  Ada beberapa primitif yang sangat menarik yang kami tidak ingin menyerah, seperti Table Storage dan Cosmos DB (tetapi kami berusaha untuk tidak terlalu ketat pada mereka demi proyek lintas platform). <br><br>  Sekarang saya ingin memberi tahu sedikit tentang apa model aktor.  Dan untuk memulainya, itu, sebagai prinsip, muncul lebih dari 40 tahun yang lalu. <br><br><img src="https://habrastorage.org/webt/ps/wh/o5/pswho5g6goopdvjqgdzbbrudros.png"><br><br>  Seorang aktor adalah model komputasi paralel yang menyatakan bahwa ada objek terisolasi tertentu yang memiliki keadaan internal sendiri dan akses eksklusif untuk mengubah keadaan ini.  Seorang aktor dapat membaca pesan, dan terlebih lagi, secara berurutan, menjalankan semacam logika bisnis, jika ia ingin mengubah keadaan internalnya, dan mengirim pesan ke layanan eksternal, termasuk aktor lain.  Dan dia tahu cara membuat aktor lain. <br><br>  Aktor berkomunikasi satu sama lain secara tidak sinkron, yang memungkinkan Anda membuat sistem cloud terdistribusi tinggi.  Dalam hal ini, model aktor telah banyak digunakan baru-baru ini. <br><br>  Ringkasnya, mari kita bayangkan bahwa kita memiliki cloud di mana ada beberapa jenis server cluster, dan para aktor kita berputar pada cluster ini. <br><br><img src="https://habrastorage.org/webt/k7/le/o8/k7leo8f4_bksrkrxepnw7vlp_xk.png"><br><br>  Aktor diisolasi dari satu sama lain, berkomunikasi melalui panggilan asinkron, dan di dalam diri mereka, para aktor aman. <br><br>  Seperti apa bentuknya.  Misalkan kita memiliki beberapa pengguna (bukan beban yang sangat besar), dan pada titik tertentu kita mengerti bahwa ada masuknya pemain, dan kami sangat perlu melakukan peningkatan. <br><br><img src="https://habrastorage.org/webt/m5/v7/8k/m5v78k2trbiawxv2obnxtcpbhd0.png"><br><br>  Kami dapat menambahkan server ke cloud kami dan, menggunakan model aktor, mendorong pengguna individual - menetapkan setiap aktor individual dan mengalokasikan ruang untuk memori dan waktu prosesor untuk aktor ini di cloud. <br><br>  Dengan demikian, aktor, pertama, memainkan peran cache, dan kedua, itu adalah "cache pintar", yang dapat memproses beberapa pesan dan menjalankan logika bisnis.  Sekali lagi, jika Anda perlu membuat downscale (misalnya, para pemain telah pergi) - juga tidak ada masalah menghapus aktor-aktor ini dari sistem. <br><br>  Kami di backend tidak menggunakan model aktor klasik, tetapi berdasarkan kerangka kerja Orleans.  Apa bedanya - Saya akan mencoba memberi tahu Anda sekarang. <br><br><img src="https://habrastorage.org/webt/bg/bi/iu/bgbiiudonlat560_soge7gyv0-a.png"><br><br>  Pertama, Orleans memperkenalkan konsep aktor virtual atau, sebagaimana juga disebut, grain.  Berbeda dengan model aktor klasik, di mana sebuah layanan bertanggung jawab untuk menciptakan aktor ini dan menempatkannya di beberapa server, Orleans mengambil alih pekerjaan.  Yaitu  jika layanan pengguna tertentu meminta nilai tertentu, maka Orleans akan memahami server mana yang sekarang kurang dimuat, itu akan menempatkan aktor di sana dan mengembalikan hasilnya ke layanan pengguna. <br><br>  Sebuah contoh  Untuk biji-bijian, penting untuk hanya mengetahui jenis aktor, misalnya, status pengguna, dan ID.  Misalkan ID pengguna 777, kami mendapatkan graine dari pengguna ini dan tidak memikirkan bagaimana cara menyimpan graine ini, kami tidak mengontrol siklus hidup graine.  Orleans, bagaimanapun, dalam dirinya sendiri menyimpan jalur semua aktor dengan cara yang sangat licik.  Jika tidak ada aktor, ia menciptakan mereka, jika aktor itu hidup, ia mengembalikannya, dan untuk layanan pengguna semuanya terlihat sehingga semua aktor selalu hidup. <br><br><img src="https://habrastorage.org/webt/ud/5s/id/ud5sidxydmqbafgbhfjzcowwjgs.png"><br><br>  Apa manfaatnya bagi kita?  Pertama, load balancing transparan karena fakta bahwa programmer tidak perlu mengatur lokasi aktor sendiri.  Dia hanya mengatakan Orleans, yang digunakan pada beberapa server: beri saya aktor seperti itu dari server Anda. <br><br><img src="https://habrastorage.org/webt/r8/wn/dp/r8wndpcexsiwuw9qn_x5znxwkhc.png"><br><br>  Jika diinginkan, Anda dapat menurunkan skala jika beban pada prosesor dan memori kecil.  Sekali lagi, Anda dapat melakukan kelas atas di arah yang berlawanan.  Tetapi layanan tidak tahu apa-apa tentang ini, dia meminta graine, dan Orleans memberinya graine itu.  Dengan demikian, Orleans mengambil perawatan infrastruktur untuk siklus hidup biji-bijian. <br><br>  Kedua, Orleans menangani crash server. <br><br><img src="https://habrastorage.org/webt/u8/cl/2c/u8cl2cjbxptjng5vy6sqg0f3pkw.png"><br><br>  Ini berarti bahwa jika dalam model klasik, programmer bertanggung jawab untuk menangani kasus seperti itu sendiri (mereka menempatkan aktor di beberapa server, dan server ini macet, dan kita sendiri harus menaikkan aktor ini di salah satu server langsung), yang menambahkan lebih banyak mekanik atau kerja jaringan yang rumit untuk seorang programmer, maka di Orleans terlihat transparan.  Kami meminta graine, Orleans melihat bahwa itu tidak tersedia, mengambilnya (menempatkannya di beberapa server langsung) dan mengembalikannya ke layanan. <br><br>  Untuk membuatnya lebih jelas, mari kita analisis contoh kecil tentang bagaimana pengguna membaca sebagian dari keadaannya. <br><br><img src="https://habrastorage.org/webt/je/_4/iw/je_4iwdh8tk1q5wtveptzzhf33e.png"><br><br>  Suatu negara mungkin adalah kondisi ekonominya, yang menyimpan baju besi, senjata, mata uang, atau juara pengguna itu.  Untuk mendapatkan status ini, ia memanggil PublicUserService, yang beralih ke Orleans untuk negara bagian.  Apa yang terjadi: Orleans melihat bahwa belum ada aktor seperti itu (mis., Biji-bijian), ia membuatnya di server gratis, dan biji-bijian membaca kondisinya dari beberapa toko Persistence. <br><br>  Jadi, lain kali Anda membaca sumber daya dari cloud, seperti yang ditunjukkan dalam slide, semua bacaan akan berasal dari cache cache.  Jika pengguna meninggalkan permainan, sumber daya bacaan tidak terjadi, jadi Orleans memahami bahwa bulir tidak lagi digunakan oleh siapa pun dan dapat dinonaktifkan. <br><br>  Jika kami memiliki beberapa klien (klien game, server game), mereka dapat meminta status pengguna, dan salah satunya akan meningkatkan jumlah ini.  Lebih tepatnya, itu akan membuat Orleans mengambilnya, dan kemudian semua panggilan, seperti yang sudah kita ketahui, terjadi di dalamnya thread-safe, secara berurutan.  Pertama, klien akan menerima status, dan kemudian server game. <br><br><img src="https://habrastorage.org/webt/ih/og/2i/ihog2i9tqxlitxio9djssspgavy.png"><br><br>  Aliran yang sama pada pembaruan.  Ketika klien ingin memperbarui keadaan, ia akan mentransfer tanggung jawab ini ke butir, yaitu  akan memberitahunya: "beri pengguna ini 10 emas", dan gandum naik, ia memproses keadaan ini dengan semacam logika bisnis di dalam gandum.  Dan kemudian datang pembaruan cache cache dan, jika diinginkan, kegigihan dalam Kegigihan. <br><br><img src="https://habrastorage.org/webt/ym/2i/3v/ym2i3viyvuzcowtmkdqwat8mb2s.png"><br><br>  Mengapa Ketekunan diperlukan di sini?  Ini adalah topik yang terpisah dan terletak pada fakta bahwa kadang-kadang itu tidak terlalu penting bagi kita bahwa Butir terus-menerus mempertahankan statusnya dalam Persistence.  Jika ini keadaan pemain online, kami siap mengambil risiko kehilangan demi produktivitas, jika itu menyangkut ekonomi, maka kita harus yakin bahwa keadaannya dilestarikan. <br><br>  Kasus paling sederhana: untuk setiap panggilan save state, tulis pembaruan ini untuk Persistence.  Dengan demikian, jika grey tiba-tiba jatuh secara tidak terduga, peningkatan graine berikutnya pada beberapa server lain akan menyebabkan pembaruan cache dengan data saat ini. <br><br>  Contoh kecil bagaimana tampilannya. <br><br><img src="https://habrastorage.org/webt/gi/vp/bj/givpbj4gdy2lyshx4hblowzqncw.png"><br><br>  Seperti yang sudah saya katakan, sebutir terdiri dari tipe dan beberapa kunci (dalam hal ini, jenisnya adalah IPlayerState, kuncinya adalah IGrainWithGuidKey, yang artinya adalah Guid).  Dan kami memiliki antarmuka yang kami implementasikan, mis.  GetStates mengembalikan beberapa daftar status dan ApplyState, yang berlaku beberapa negara.  Metode Orleans mengembalikan Tugas.  Apa artinya ini: Tugas adalah janji yang memberi tahu kita bahwa ketika negara kembali, janji akan berada dalam keadaan terselesaikan.  Kami juga memiliki beberapa PlayerState yang kami dapatkan dengan GrainFactory.  Yaitu  di sini kami mendapatkan tautan, dan kami tidak tahu apa-apa tentang lokasi fisik gandum ini.  Saat memanggil GetStates, Orleans akan menaikkan graine kami, membaca status dari toko Persistence ke dalam ingatannya, dan ketika ApplyState akan menerapkan status baru, ia juga akan memperbarui status ini baik dalam memorinya maupun dalam Persistence. <br><br>  Saya ingin membuat contoh yang sedikit lebih kompleks pada arsitektur tingkat tinggi dari layanan UserStates kami. <br><br><img src="https://habrastorage.org/webt/4d/1s/r5/4d1sr5q9chg2qkm1-nj-qeldqtw.png"><br><br>  Kami memiliki semacam klien game yang mendapatkan statusnya melalui OfferSevice.  Kami memiliki GameConfigurationService, yang bertanggung jawab atas model ekonomi sekelompok pengguna, dalam hal ini, pengguna kami.  Dan kami memiliki operator yang mengubah model ekonomi ini.  Sesuai dengan itu, pengguna meminta OfferSevice untuk menerima status mereka.  Dan OfferSevice sudah mengakses layanan UserOrleans, yang terdiri dari biji-bijian ini, ia meningkatkan status pengguna dalam memorinya, mungkin menjalankan semacam logika bisnis, dan mengembalikan data kembali ke pengguna melalui OfferService. <br><br>  Secara umum, saya ingin menarik perhatian pada fakta bahwa Orleans baik untuk kemampuan paralelismenya yang tinggi karena fakta bahwa biji-bijian tidak saling tergantung satu sama lain.  Dan di sisi lain, di dalam graine, kita tidak perlu menggunakan primitif sinkronisasi, karena kita tahu bahwa setiap panggilan ke graine ini entah bagaimana akan konsisten. <br><br>  Di sini saya ingin melihat beberapa jebakan dari model ini. <br><br><img src="https://habrastorage.org/webt/bi/nr/vt/binrvttwhrlmxqonc74qchyjzdc.png"><br><br>  Yang pertama terlalu banyak butiran.  Karena semua panggilan dalam greine aman, satu demi satu, dan jika kita memiliki logika berminyak pada greine, kita harus menunggu terlalu lama.  Sekali lagi, terlalu banyak memori yang dialokasikan untuk satu butir tersebut.  Tidak ada algoritma yang tepat untuk ukuran butir, karena butir yang terlalu kecil juga buruk.  Di sini perlu untuk melanjutkan dari nilai optimal.  Saya tidak akan mengatakan yang mana, terserah programmer untuk memutuskan. <br><br>  Masalah kedua tidak begitu jelas - inilah yang disebut reaksi berantai.  Ketika seorang pengguna menaikkan beberapa butir, dan dia, pada gilirannya, secara implisit dapat meningkatkan butir lain dalam sistem.  Bagaimana ini terjadi: pengguna menerima statusnya, dan pengguna memiliki teman dan dia menerima status teman-temannya.  Jadi, seluruh sistem menyimpan semua butirannya dalam memori, dan jika kita memiliki 1000 pengguna, dan masing-masing memiliki 100 teman, maka 100.000 butir dapat aktif begitu saja.  Kasus ini juga perlu dihindari - entah bagaimana menyimpan status teman dalam semacam memori bersama. <br><br><img src="https://habrastorage.org/webt/iu/ep/0z/iuep0z7a5vgw_qak3i-j8hx6hkc.png"><br><br>  Nah, teknologi apa yang ada untuk mengimplementasikan model aktor.  Mungkin yang paling terkenal adalah Akka, yang datang kepada kami dengan Jawa.  Ada garpu yang disebut Akka.NET untuk .NET.  Ada Orleans, yang merupakan open-source dan dalam bahasa lain, sebagai implementasi.  Ada primitif Azure seperti Service Fabric Actor - ada banyak teknologi. <br><br><h2>  Pertanyaan dari audiens </h2><br>  <b>- Bagaimana Anda memecahkan masalah klasik seperti CICD, memperbarui aktor-aktor ini, apakah Anda menggunakan Docker dan apakah diperlukan sama sekali?</b> <br><br>  - Kami belum menggunakan buruh pelabuhan.  Secara umum, DevOps terlibat dalam penyebaran, mereka menggunakan layanan kami di layanan cloud Azure. <br><br>  <b>- Pembaruan berkelanjutan, tanpa waktu henti, bagaimana itu terjadi?</b>  <b>Orleans sendiri memutuskan ke server mana server akan pergi, ke server mana permintaan akan pergi, dan cara memperbarui layanan ini.</b>  <b>Yaitu</b>  <b>logika bisnis baru telah muncul, pembaruan dari aktor yang sama telah muncul - bagaimana pembaruan ini dilakukan?</b> <br><br>  - Jika kita berbicara tentang memperbarui seluruh layanan, dan jika kita telah memperbarui beberapa logika bisnis aktor, kita dapat meluncurkan layanan Orleans baru untuk itu.  Biasanya ini diselesaikan dengan primitif kita yang disebut topologi.  Kami meluncurkan beberapa layanan Orleans baru, yang untuk saat ini, misalkan, kosong, dan tanpa aktor, menampilkan layanan lama dan menggantinya dengan yang baru.  Tidak akan ada aktor dalam sistem sama sekali, tetapi pada permintaan pengguna berikutnya, aktor-aktor ini sudah akan dibuat.  Mungkin akan ada semacam lonjakan di awal.  Dalam kasus seperti itu, pembaruan biasanya terjadi di pagi hari, karena di pagi hari kami memiliki jumlah pemain terkecil. <br><br>  <b>"Bagaimana Orleans memahami bahwa servernya crash?"</b>  <b>Anda mengatakan bahwa dia dengan cepat melemparkan aktor ke server lain ...</b> <br><br>  - Dia memiliki pingator yang secara berkala memahami server mana yang masih hidup. <br><br>  <b>- Apakah dia ping aktor atau server secara khusus?</b> <br><br>  - Khususnya, server. <br><br>  <b>- Pertanyaan seperti itu: kesalahan terjadi di dalam aktor, Anda mengatakan dia pergi langkah demi langkah, setiap instruksi.</b>  <b>Tetapi kesalahan terjadi dan apa yang terjadi pada aktor?</b>  <b>Misalkan ada kesalahan yang tidak diproses.</b>  <b>Apakah aktor itu sekarat?</b> <br><br>  - Tidak, Orleans melempar pengecualian dalam skema .NET standar. <br><br>  <b>- Dengar, kami tidak menangani pengecualian, aktor itu ternyata meninggal.</b>  <b>Pemain saya tidak tahu bagaimana penampilannya, tetapi kemudian apa yang terjadi?</b>  <b>Apakah Anda mencoba me-restart aktor ini atau melakukan hal lain seperti itu?</b> <br><br>  - Itu tergantung pada case yang tergantung pada case yang mana.  Misalnya retriable atau tidak retriable. <br><br>  <b>- Yaitu</b>  <b>Apakah ini semua dapat dikonfigurasi?</b> <br><br>  - Sebaliknya, diprogram.  Kami sedang menangani beberapa pengecualian.  Yaitu  kita melihat dengan jelas bahwa kode kesalahan seperti itu, dan beberapa, seperti pengecualian yang tidak ditangani, sudah didorong lebih jauh. <br><br>  <b>- Apakah Anda memiliki beberapa Ketekunan - apakah itu seperti database?</b> <br><br>  - Kegigihan, ya, database dengan penyimpanan persisten. <br><br>  <b>- Katakanlah sebuah basis data meletakkan di mana (syarat) uang game.</b>  <b>Apa yang terjadi jika seorang aktor tidak dapat menghubunginya?</b>  <b>Bagaimana Anda menanganinya?</b> <br><br>  - Pertama-tama, ini Storage.  Saat ini, kami menggunakan Azure Table Storage, dan masalah seperti itu benar-benar terjadi - Storage macet.  Biasanya dalam hal ini Anda harus mengkonfigurasi ulang. <br><br>  <b>- Jika aktor tidak bisa mendapatkan sesuatu di Storage, seperti apa pemain itu?</b>  <b>Dia benar-benar tidak punya uang ini atau dia segera menutup permainan?</b> <br><br>  - Ini adalah perubahan penting bagi pengguna.  Karena setiap layanan memiliki tingkat keparahannya sendiri, dalam hal ini, layanan pengguna adalah keadaan terminal, dan klien hanya macet. <br><br>  <b>- Tampak bagi saya bahwa pesan-pesan para aktor terjadi melalui antrian asinkron.</b>  <b>Bagaimana solusi yang dioptimalkan ini?</b>  <b>Tidak membengkak, bukankah itu membuat pemain menutup telepon?</b>  <b>Bukankah lebih baik menggunakan pendekatan reaktif?</b> <br><br>  - Masalah antrian aktor cukup terkenal, karena kami jelas tidak dapat mengontrol ukuran antrian, Anda benar.  Tapi Orleans, pertama, mengambil beberapa jenis pekerjaan manajemen dan, kedua, saya pikir hanya dengan akses timeout ke aktor akan jatuh, yaitu  kita tidak bisa menjangkau aktor, misalnya. <br><br>  <b>- Dan bagaimana ini akan mempengaruhi pemain?</b> <br><br>  - Karena layanan pengguna menghubungi aktor, mereka akan membuang pengecualian batas waktu pengecualian dan, jika itu adalah layanan "kritis", klien akan melempar kesalahan dan menutup.  Dan jika itu kurang kritis, maka itu akan menunggu. <br><br>  <b>- Yaitu</b>  <b>Apakah Anda memiliki ancaman DDoS?</b>  <b>Sejumlah besar tindakan kecil dapat menempatkan pemain?</b>  <b>Katakanlah seseorang dengan cepat mulai mengundang teman, dll.</b> <br><br>  - Tidak, ada pembatas permintaan yang tidak akan memungkinkan Anda untuk mengakses layanan terlalu sering. <br><br>  <b>- Bagaimana Anda menangani konsistensi data?</b>  <b>Misalkan kita memiliki dua pengguna, kita perlu mengambil sesuatu dari satu, dan menagih sesuatu ke yang lain, sehingga bersifat transaksional.</b> <br><br>  - Pertanyaan bagus.  Pertama, Orleans 2.0 mendukung Transaksi Aktor Terdistribusi - ini adalah rilis pertama.  Lebih tepatnya, sudah perlu berbicara tentang ekonomi.  Dan sebagai cara termudah - di Orleans terakhir, transaksi antar aktor dilaksanakan tanpa masalah. <br><br>  <b>- Yaitu</b>  <b>Apakah sudah tahu cara menjamin bahwa data akan tetap ada dalam integritas?</b> <br><br>  - Ya. <br><br><h3>  Lebih banyak pembicaraan dengan Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan Konsul untuk meningkatkan layanan yang</a> sah (Ivan Bubnov, DevOps di BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CICD: penyebaran mulus ke sistem cluster terdistribusi tanpa downtime</a> (Egor Panov, administrator sistem Pixonic); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur server meta penembak online seluler Tacticool</a> (Pavel Platto, Insinyur Perangkat Lunak Utama di PanzerDog); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana ECS, Sistem Pekerjaan C # dan SRP mengubah pendekatan arsitektur</a> (Valentin Simonov, Insinyur Lapangan di Unity); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip KISS dalam pengembangan</a> (Konstantin Gladyshev, Lead Game Programmer di 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Logika permainan umum pada klien dan server</a> (Anton Grigoriev, Wakil Petugas Teknis di Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mentimun di Awan: Menggunakan Skrip BDD untuk Pengujian Stres Produk</a> (Anton Kosyakin, Manajer Produk Teknis pada Platform ALICE). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426115/">https://habr.com/ru/post/id426115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426101/index.html">Integritas Data dalam Arsitektur Layanan Mikro - Cara Memastikannya Tanpa Transaksi Terdistribusi dan Konektivitas yang Kuat</a></li>
<li><a href="../id426103/index.html">Webinar "Apakah Anda Membutuhkan Kubernetes" 15 Oktober pukul 19:00</a></li>
<li><a href="../id426105/index.html">Tangkapan saya dalam seminggu</a></li>
<li><a href="../id426111/index.html">Google masih akan meluncurkan layanan pencarian yang disensor di Cina</a></li>
<li><a href="../id426113/index.html">Google News dan Leo Tolstoy: Visualisasi Representasi Vektor Kata-kata dengan t-SNE</a></li>
<li><a href="../id426117/index.html">Ombudsman mengusulkan untuk memblokir iklan dengan produk bayi yang berpotensi berbahaya</a></li>
<li><a href="../id426119/index.html">Barang Antik: Cryptonomicon Iron</a></li>
<li><a href="../id426121/index.html">MC.exe (Kompiler pesan), rc.exe, link.exe untuk menghasilkan .dll untuk EventMessageFile</a></li>
<li><a href="../id426123/index.html">Pelajari OpenGL. Pelajaran 6.1. PBR atau Rendering yang Tepat Secara Fisik. Teori</a></li>
<li><a href="../id426125/index.html">Steroid karier. Elevator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>