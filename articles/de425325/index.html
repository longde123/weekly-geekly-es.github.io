<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☂️ 👩‍💼 🧑🏿‍🤝‍🧑🏻 DIY Bytecode Interpreter 🧖🏽 👜 🎭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Virtuelle Maschinen von Programmiersprachen sind in den letzten Jahrzehnten sehr verbreitet geworden. Seit der Präsentation von Java Virtual Machine i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY Bytecode Interpreter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/425325/"><p><img src="https://habrastorage.org/webt/aa/zv/cl/aazvcl84q5xly1zkqhtxelkemju.png"></p><br><p>  Virtuelle Maschinen von Programmiersprachen sind in den letzten Jahrzehnten sehr verbreitet geworden.  Seit der Präsentation von Java Virtual Machine in der zweiten Hälfte der 90er Jahre ist ziemlich viel Zeit vergangen, und man kann mit Sicherheit sagen, dass Bytecode-Interpreter nicht die Zukunft, sondern die Gegenwart sind. </p><br><p>  Aber diese Technik ist meiner Meinung nach fast universell und das Verständnis der Grundprinzipien der Dolmetscherentwicklung ist nicht nur für den Schöpfer des nächsten Herausforderers für den Titel "Sprache des Jahres" nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TIOBE</a> nützlich, sondern für jeden Programmierer im Allgemeinen. </p><br><p>  Mit einem Wort, wenn Sie erfahren möchten, wie unsere bevorzugten Programmiersprachen Zahlen addieren, worüber Entwickler virtueller Maschinen immer noch streiten und wie Zeichenfolgen und reguläre Ausdrücke schmerzlos abgeglichen werden können, frage ich nach cat. </p><a name="habracut"></a><br><p>  Teil eins, Einführung (aktuell) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil, Optimierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil, Angewandt</a> </p><br><h1 id="predystoriya">  Hintergrund </h1><br><p>  Eines der selbstgeschriebenen Systeme der Business Intelligence-Abteilung unseres Unternehmens verfügt über eine Schnittstelle in Form einer einfachen Abfragesprache.  In der ersten Version des Systems wurde diese Sprache im laufenden Betrieb ohne Kompilierung direkt aus der Eingabezeile mit der Anforderung interpretiert.  Die zweite Version des Parsers funktioniert bereits mit Zwischenbytecode, wodurch Sie die Abfragesprache von ihrer Ausführung trennen und den Code erheblich vereinfachen können. </p><br><p> Während ich an der zweiten Version des Systems arbeitete, hatte ich einen Urlaub, in dem ich jeden Tag ein oder zwei Stunden lang von Familienangelegenheiten abgelenkt wurde, um Materialien über die Architektur und Leistung von Bytecode-Dolmetschern zu studieren.  Ich beschloss, die daraus resultierenden Notizen und Beispiele von Dolmetschern als eine Reihe von Artikeln mit Habrs Lesern zu teilen. </p><br><p>  Die erste von ihnen präsentiert fünf kleine (bis zu Hunderte Zeilen einfachen C-Code) virtuelle Maschinen, von denen jede einen bestimmten Aspekt der Entwicklung solcher Interpreter enthüllt. </p><br><h1 id="otkuda-est-poshli-bayt-kody-v-yazykah-programmirovaniya">  Wohin gingen die Bytecodes in Programmiersprachen? </h1><br><p>  Es wurden sehr viele virtuelle Maschinen erfunden, die verschiedensten virtuellen Befehlssätze der letzten Jahrzehnte.  Wikipedia behauptet, dass die ersten Programmiersprachen bereits in den 60er Jahren des letzten Jahrhunderts zu verschiedenen vereinfachten Zwischendarstellungen kompiliert wurden.  Einige dieser ersten Bytecodes wurden in Maschinencodes konvertiert und von realen Prozessoren ausgeführt, während andere von virtuellen Prozessoren im laufenden Betrieb interpretiert wurden. </p><br><p>  Die Popularität virtueller Befehlssätze als Zwischendarstellung von Code hat drei Gründe: </p><br><ol><li>  Bytecode-Programme können problemlos auf neue Plattformen portiert werden. </li><li>  Bytecode-Interpreter sind schneller als Interpreter des Syntaxbaums des Codes. </li><li>  Sie können eine einfache virtuelle Maschine in nur wenigen Stunden entwickeln. </li></ol><br><p>  Lassen Sie uns einige einfache virtuelle C-Maschinen erstellen und anhand dieser Beispiele die wichtigsten technischen Aspekte der Implementierung virtueller Maschinen hervorheben. </p><br><p>  Vollständige Beispielcodes sind auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar.  Beispiele können mit jedem relativ frischen GCC zusammengestellt werden: </p><br><pre><code class="plaintext hljs">gcc interpreter-basic-switch.c -o interpreter ./interpreter</code> </pre> <br><p>  Alle Beispiele haben die gleiche Struktur: Zuerst kommt der Code der virtuellen Maschine selbst, dann die Hauptfunktion mit Zusicherungen, die die Funktionsweise des Codes überprüfen.  Ich habe versucht, die Opcodes und Schlüsselstellen der Dolmetscher klar zu kommentieren.  Ich hoffe, dass dieser Artikel auch für Leute verständlich ist, die nicht täglich in C schreiben. </p><br><h1 id="samyy-prostoy-v-mire-interpretator-bayt-koda">  Der weltweit einfachste Bytecode-Interpreter </h1><br><p>  Wie gesagt, der einfachste Dolmetscher ist sehr einfach zu erstellen.  Kommentare befinden sich direkt hinter der Auflistung, aber beginnen wir direkt mit dem Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Es gibt weniger als hundert Zeilen, aber alle charakteristischen Attribute einer virtuellen Maschine werden dargestellt.  Die Maschine hat ein einzelnes Register ( <code>vm.accumulator</code> ), drei Operationen (Registerinkrement, Registerdekrement und Abschluss der Programmausführung) und einen Zeiger auf den aktuellen Befehl ( <code>vm.ip</code> ). </p><br><p>  Jede Operation (dt. <em>Operationscode</em> oder <em>Opcode</em> ) wird mit einem Byte codiert, und die Planung wird unter Verwendung des üblichen <code>switch</code> in der Funktion <code>vm_interpret</code> .  Die Zweige im <code>switch</code> enthalten die Logik der Operationen, dh sie ändern den Status des Registers oder beenden die Ausführung des Programms. </p><br><p>  Die Operationen werden als Array von Bytes - ein Bytecode (englischer <em>Bytecode</em> ) - an die Funktion <code>vm_interpret</code> übertragen und nacheinander ausgeführt, bis die Operation zum <code>OP_DONE</code> virtuellen Maschine ( <code>OP_DONE</code> ) <code>OP_DONE</code> . </p><br><p>  Ein Schlüsselaspekt einer virtuellen Maschine ist die Semantik, dh die Menge der Operationen, die auf ihr möglich sind.  In diesem Fall gibt es nur zwei Operationen, die den Wert eines einzelnen Registers ändern. </p><br><p>  Einige Forscher ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abstraktions- und Optimierungstechniken für</a> virtuelle Maschinen, 2009) schlagen vor, virtuelle Maschinen entsprechend der Nähe der Semantik der virtuellen Maschine zur Semantik der physischen Maschine, auf der der Bytecode ausgeführt wird, in übergeordnete und <em>untergeordnete Ebenen zu unterteilen</em> . </p><br><p>  Im Extremfall kann der Bytecode von virtuellen Maschinen auf niedriger Ebene den Maschinencode der physischen Maschine mit simuliertem RAM, einem vollständigen Satz von Registern, Anweisungen zum Arbeiten mit dem Stapel usw. vollständig wiederholen.  Die virtuelle Maschine von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bochs</a> wiederholt beispielsweise den Befehlssatz der x86-Architektur. </p><br><p>  Und umgekehrt: Der Betrieb von virtuellen Maschinen auf hoher Ebene spiegelt die Semantik einer speziellen Programmiersprache wider, die in Bytecode kompiliert wurde.  Arbeiten Sie beispielsweise mit SQLite, Gawk und zahlreichen Versionen von Prolog. </p><br><p>  Zwischenpositionen werden von Dolmetschern für allgemeine Programmiersprachen mit Elementen sowohl auf hohem als auch auf niedrigem Niveau besetzt.  Die beliebteste Java Virtual Machine verfügt sowohl über einfache Anweisungen zum Arbeiten mit dem Stack als auch über eine integrierte Unterstützung für die objektorientierte Programmierung mit automatischer Speicherzuweisung. </p><br><p>  Der obige Code ist eher die primitivste virtuelle Maschine auf niedriger Ebene: Jeder virtuelle Befehl ist ein Wrapper über einen oder zwei physische Befehle, das virtuelle Register stimmt vollständig mit einem Register des "Eisen" -Prozessors überein. </p><br><h1 id="argumenty-instrukciy-v-bayt-kode">  Bytecode-Anweisungsargumente </h1><br><p>  Wir können sagen, dass das einzige Register in unserem Beispiel für eine virtuelle Maschine sowohl ein Argument als auch der Rückgabewert aller ausgeführten Anweisungen ist.  Es kann jedoch nützlich sein, Argumente in Anweisungen zu übergeben.  Eine Möglichkeit besteht darin, sie direkt in den Bytecode einzufügen. </p><br><p>  Wir werden das Beispiel erweitern, indem wir Anweisungen (OP_ADDI, OP_SUBI) einführen, die ein Argument in Form eines Bytes unmittelbar nach dem Opcode annehmen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* add the immediate argument to the register */</span></span> OP_ADDI, <span class="hljs-comment"><span class="hljs-comment">/* subtract the immediate argument from the register */</span></span> OP_SUBI, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator += arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_SUBI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator -= arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Neue Anweisungen (siehe die Funktion <code>vm_interpret</code> ) lesen ihr Argument aus dem Bytecode und fügen es dem Register hinzu / subtrahieren es vom Register. </p><br><p>  Ein solches Argument wird als <em>sofortiges Argument bezeichnet</em> , da es sich direkt im Opcode-Array befindet.  Die Hauptbeschränkung in unserer Implementierung besteht darin, dass das Argument ein einzelnes Byte ist und nur 256 Werte annehmen kann. </p><br><p>  In unserer virtuellen Maschine spielt der Bereich möglicher Befehlsargumentwerte keine große Rolle.  Wenn die virtuelle Maschine jedoch als Interpreter der realen Sprache verwendet wird, ist es sinnvoll, den Bytecode zu komplizieren, indem eine vom Array der Opcodes und Anweisungen getrennte Konstantentabelle mit einem direkten Argument hinzugefügt wird, das der Adresse des realen Arguments in der Konstantentabelle entspricht. </p><br><h1 id="stekovaya-mashina">  Stapelmaschine </h1><br><p>  Anweisungen in unserer einfachen virtuellen Maschine arbeiten immer mit einem Register und können in keiner Weise Daten untereinander übertragen.  Außerdem kann das Argument für die Anweisung nur unmittelbar sein, und die Additions- oder Multiplikationsoperation benötigt beispielsweise zwei Argumente. </p><br><p>  Einfach ausgedrückt, wir haben keine Möglichkeit, komplexe Ausdrücke zu bewerten.  Um dieses Problem zu lösen, wird eine gestapelte Maschine benötigt, dh eine virtuelle Maschine mit einem integrierten Stapel: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STACK_MAX 256 struct { uint8_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fixed-size stack */</span></span></span><span class="hljs-meta"> uint64_t stack[STACK_MAX]; uint64_t *stack_top; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* push the immediate argument onto the stack */</span></span></span><span class="hljs-meta"> OP_PUSHI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, add and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, subtract and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, divide and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, multiply and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop the top of the stack and set it as execution result */</span></span></span><span class="hljs-meta"> OP_POP_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; vm.stack_top = vm.stack; } void vm_stack_push(uint64_t value) { *vm.stack_top = value; vm.stack_top++; } uint64_t vm_stack_pop(void) { vm.stack_top--; return *vm.stack_top; } interpret_result vm_interpret(uint8_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; for (;;) { uint8_t instruction = *vm.ip++; switch (instruction) { case OP_PUSHI: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span></span><span class="hljs-meta"> uint8_t arg = *vm.ip++; vm_stack_push(arg); break; } case OP_ADD: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left + arg_right; vm_stack_push(res); break; } case OP_SUB: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, subtract 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left - arg_right; vm_stack_push(res); break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, divide 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg_right == 0) return ERROR_DIVISION_BY_ZERO; uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left / arg_right; vm_stack_push(res); break; } case OP_MUL: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, multiply 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left * arg_right; vm_stack_push(res); break; } case OP_POP_RES: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop the top of the stack, set it as a result value */</span></span></span><span class="hljs-meta"> uint64_t res = vm_stack_pop(); vm.result = res; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  In diesem Beispiel gibt es mehr Operationen, und fast alle funktionieren nur mit dem Stapel.  OP_PUSHI schiebt sein unmittelbares Argument auf den Stapel.  Die Anweisungen OP_ADD, OP_SUB, OP_DIV, OP_MUL werden aus einem Wertestapel entfernt, das Ergebnis berechnet und auf den Stapel zurückgeschoben.  OP_POP_RES entfernt den Wert aus dem Stapel und legt ihn im Ergebnisregister ab, das für die Ergebnisse der virtuellen Maschine vorgesehen ist. </p><br><p>  Für die Divisionsoperation (OP_DIV) wird ein Fehler durch Division durch Null abgefangen, der die virtuelle Maschine stoppt. </p><br><p>  Die Fähigkeiten einer solchen Maschine sind viel breiter als die der vorherigen mit einem einzigen Register und ermöglichen beispielsweise die Berechnung komplexer arithmetischer Ausdrücke.  Ein weiterer (und wichtiger!) Vorteil ist die einfache Kompilierung von Programmiersprachen in den Bytecode der Stapelmaschine. </p><br><h1 id="registrovaya-mashina">  Maschine registrieren </h1><br><p>  Aufgrund ihrer Einfachheit werden gestapelte virtuelle Maschinen unter Entwicklern von Programmiersprachen am häufigsten verwendet.  Dieselben JVMs und Python-VMs verwenden genau diese. </p><br><p>  Solche Maschinen haben jedoch Nachteile: Sie müssen spezielle Anweisungen für die Arbeit mit dem Stapel hinzufügen. Bei der Berechnung von Ausdrücken durchlaufen alle Argumente wiederholt eine einzelne Datenstruktur. Im Stapelcode werden unweigerlich viele zusätzliche Anweisungen angezeigt. </p><br><p>  In der Zwischenzeit verursacht die Ausführung jedes zusätzlichen Befehls die Kosten für die Planung, dh das Decodieren des Opcodes und das Umschalten auf den Hauptteil der Befehle. </p><br><p>  Eine Alternative zu gestapelten Maschinen ist das Registrieren virtueller Maschinen.  Sie haben einen komplexeren Bytecode: Die Anzahl der Registerargumente und die Nummer des Registerergebnisses werden in jedem Befehl explizit codiert.  Dementsprechend wird anstelle eines Stapels ein erweiterter Satz von Registern als Speicher für Zwischenwerte verwendet. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_NUM 16 struct { uint16_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Register array */</span></span></span><span class="hljs-meta"> uint64_t reg[REGISTER_NUM]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load an immediate value into r0 */</span></span></span><span class="hljs-meta"> OP_LOADI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Subtract values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Divide values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiply values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Move a value from r0 register into the result register */</span></span></span><span class="hljs-meta"> OP_MOV_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; } void decode(uint16_t instruction, uint8_t *op, uint8_t *reg0, uint8_t *reg1, uint8_t *reg2, uint8_t *imm) { *op = (instruction &amp; 0xF000) &gt;&gt; 12; *reg0 = (instruction &amp; 0x0F00) &gt;&gt; 8; *reg1 = (instruction &amp; 0x00F0) &gt;&gt; 4; *reg2 = (instruction &amp; 0x000F); *imm = (instruction &amp; 0x00FF); } interpret_result vm_interpret(uint16_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; uint8_t op, r0, r1, r2, immediate; for (;;) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* fetch the instruction */</span></span></span><span class="hljs-meta"> uint16_t instruction = *vm.ip++; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* decode it */</span></span></span><span class="hljs-meta"> decode(instruction, &amp;op, &amp;r0, &amp;r1, &amp;r2, &amp;immediate); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dispatch */</span></span></span><span class="hljs-meta"> switch (op) { case OP_LOADI: { vm.reg[r0] = immediate; break; } case OP_ADD: { vm.reg[r2] = vm.reg[r0] + vm.reg[r1]; break; } case OP_SUB: { vm.reg[r2] = vm.reg[r0] - vm.reg[r1]; break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vm.reg[r1] == 0) return ERROR_DIVISION_BY_ZERO; vm.reg[r2] = vm.reg[r0] / vm.reg[r1]; break; } case OP_MUL: { vm.reg[r2] = vm.reg[r0] * vm.reg[r1]; break; } case OP_MOV_RES: { vm.result = vm.reg[r0]; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  Das Beispiel zeigt eine Registermaschine mit 16 Registern.  Anweisungen belegen jeweils 16 Bit und werden auf drei Arten codiert: </p><br><ol><li>  4 Bit pro Opcode + 4 Bit pro Registername + 8 Bit pro Argument. </li><li>  4 Bits pro Opcode + dreimal 4 Bits pro Registernamen. </li><li>  4 Bits pro Opcode + 4 Bits pro Einzelregistername + 8 nicht verwendete Bits. </li></ol><br><p>  Unsere kleine virtuelle Maschine hat nur sehr wenige Operationen, sodass vier Bits (oder 16 mögliche Operationen) pro Opcode völlig ausreichen.  Die Operation bestimmt, was genau die verbleibenden Bits des Befehls darstellen. </p><br><p>  Die erste Art der Codierung (4 + 4 + 8) wird benötigt, um Daten mit der Operation OP_LOADI in Register zu laden.  Der zweite Typ (4 + 4 + 4 + 4) wird für arithmetische Operationen verwendet, die wissen sollten, wo ein Argumentpaar verwendet und wo das Berechnungsergebnis hinzugefügt werden muss.  Und schließlich wird die letzte Form (4 + 4 + 8 unnötige Bits) für Anweisungen mit einem einzelnen Register als Argument verwendet, in unserem Fall OP_MOV_RES. </p><br><p>  Zum Codieren und Decodieren von Anweisungen benötigen wir jetzt eine spezielle Logik ( <code>decode</code> ).  Andererseits wird die Logik von Anweisungen dank der expliziten Angabe der Position der Argumente einfacher - Operationen mit dem Stapel verschwinden. </p><br><p>  Hauptmerkmale: Im Bytecode von Registermaschinen gibt es weniger Anweisungen, einzelne Anweisungen sind breiter, das Kompilieren in einen solchen Bytecode ist schwieriger - der Compiler muss entscheiden, wie die verfügbaren Register verwendet werden sollen. </p><br><p>  Es ist zu beachten, dass es in der Praxis in virtuellen Registermaschinen normalerweise einen Stapel gibt, in dem beispielsweise Funktionsargumente platziert werden.  Register werden verwendet, um einzelne Ausdrücke zu berechnen.  Selbst wenn es keinen expliziten Stapel gibt, wird ein Array zum Erstellen des Stapels verwendet, das dieselbe Rolle spielt wie RAM in physischen Maschinen. </p><br><h1 id="stekovye-i-registrovye-mashiny-sravnenie">  Maschinen stapeln und registrieren, Vergleich </h1><br><p>  Es gibt eine interessante Studie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Showdown</a> für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">virtuelle Maschinen: Stapel versus Register</a> , 2008), die einen großen Einfluss auf alle nachfolgenden Entwicklungen auf dem Gebiet der virtuellen Maschinen für Programmiersprachen hatte.  Die Autoren haben eine Methode zur direkten Übersetzung vom Stapelcode einer Standard-JVM in einen Registercode vorgeschlagen und die Leistung verglichen. </p><br><p>  Die Methode ist nicht trivial: Der Code wird zuerst übersetzt und dann auf ziemlich komplizierte Weise optimiert.  Ein anschließender Vergleich der Leistung desselben Programms zeigte jedoch, dass die zusätzlichen Prozessorzyklen, die für das Decodieren von Befehlen aufgewendet werden, durch eine Verringerung der Gesamtzahl von Befehlen vollständig kompensiert werden.  Kurz gesagt, im Allgemeinen war die Registermaschine effizienter als die Stapelmaschine. </p><br><p>  Wie bereits oben erwähnt, hat diese Effizienz einen durchaus greifbaren Preis: Der Compiler muss die Register selbst zuordnen, und ein erweiterter Optimierer ist zusätzlich wünschenswert. </p><br><p>  Die Debatte darüber, welche Architektur besser ist, ist noch nicht vorbei.  Wenn wir über Java-Compiler sprechen, wurde der Dalvik VM-Bytecode registriert, der bis vor kurzem auf jedem Android-Gerät funktioniert hat.  Der Titel JVM hat jedoch einen Stapel von Anweisungen beibehalten.  Die virtuelle Lua-Maschine verwendet eine Registermaschine, die Python-VM ist jedoch weiterhin stapelbar.  Usw. </p><br><h1 id="bayt-kod-v-interpretatorah-regulyarnyh-vyrazheniy">  Bytecode in Interpreten für reguläre Ausdrücke </h1><br><p>  Um uns von virtuellen Maschinen auf niedriger Ebene abzulenken, schauen wir uns einen speziellen Interpreter an, der Zeichenfolgen auf Übereinstimmung mit regulären Ausdrücken überprüft: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* match a single char to an immediate argument from the string and advance ip and cp, or * abort*/</span></span> OP_CHAR, <span class="hljs-comment"><span class="hljs-comment">/* jump to and match either left expression or the right one, abort if nothing matches*/</span></span> OP_OR, <span class="hljs-comment"><span class="hljs-comment">/* do an absolute jump to an offset in the immediate argument */</span></span> OP_JUMP, <span class="hljs-comment"><span class="hljs-comment">/* stop execution and report a successful match */</span></span> OP_MATCH, } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { MATCH_OK, MATCH_FAIL, MATCH_ERROR, } match_result; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match_recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_CHAR:{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cur_c = *sp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> arg_c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*ip ; <span class="hljs-comment"><span class="hljs-comment">/* no match? FAILed to match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg_c != cur_c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_FAIL; <span class="hljs-comment"><span class="hljs-comment">/* advance both current instruction and character pointers */</span></span> ip++; sp++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JUMP:{ <span class="hljs-comment"><span class="hljs-comment">/* read the offset and jump to the instruction */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offset = *ip; ip = bytecode + offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_OR:{ <span class="hljs-comment"><span class="hljs-comment">/* get both branch offsets */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> left_offset = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> right_offset = *ip; <span class="hljs-comment"><span class="hljs-comment">/* check if following the first offset get a match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *left_ip = bytecode + left_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm_match_recur(bytecode, left_ip, sp) == MATCH_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; <span class="hljs-comment"><span class="hljs-comment">/* no match? Check the second branch */</span></span> ip = bytecode + right_offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_MATCH:{ <span class="hljs-comment"><span class="hljs-comment">/* success */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_ERROR; } } <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Start matching a string: %s\n"</span></span>, str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vm_match_recur(bytecode, bytecode, str); }</code> </pre><br><p>  Die Hauptanweisung ist OP_CHAR.  Sie nimmt ihr unmittelbares Argument und vergleicht es mit dem aktuellen Zeichen in der Zeichenfolge ( <code>char *sp</code> ).  Bei Übereinstimmung der erwarteten und aktuellen Zeichen in der Zeile erfolgt der Übergang zum nächsten Befehl und zum nächsten Zeichen. </p><br><p>  Die Maschine versteht auch die Sprungoperation (OP_JUMP), die ein einzelnes sofortiges Argument akzeptiert.  Das Argument bedeutet den absoluten Versatz im Bytecode, von dem aus die Berechnung fortgesetzt werden soll. </p><br><p>  Die letzte wichtige Operation ist OP_OR.  Sie nimmt zwei Offsets und versucht, den Code zuerst auf den ersten und im Fehlerfall auf den zweiten anzuwenden.  Sie tut dies mit einem rekursiven Aufruf, dh die Anweisung macht einen Spaziergang in die Tiefe des Baumes aller möglichen Varianten des regulären Ausdrucks. </p><br><p>  Überraschenderweise reichen vier Opcodes und siebzig Codezeilen aus, um reguläre Ausdrücke wie "abc", "a? Bc", "(ab | bc) d", "a * bc" auszudrücken.  Diese virtuelle Maschine hat nicht einmal einen expliziten Status, da alles, was Sie benötigen - Zeiger auf den Anfang des Befehlsstroms, den aktuellen Befehl und das aktuelle Zeichen - als Argumente an die rekursive Funktion übergeben wird. </p><br><p>  Wenn Sie an den Details der Arbeit von Engines-Engines interessiert sind, können Sie zunächst eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln von</a> Russ Cox lesen, dem Autor der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reglement-</a> Engines von Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RE2</a> . </p><br><h1 id="itogi">  Zusammenfassung </h1><br><p>  Fassen wir zusammen. </p><br><p>  Für allgemeine Programmiersprachen werden in der Regel zwei Architekturen verwendet: Stack und Register. </p><br><p>  Im Stapelmodell ist der Stapel die Hauptdatenstruktur und Methode zum Übergeben von Argumenten zwischen Anweisungen.  Im Registermodell wird ein Satz von Registern zum Berechnen von Ausdrücken verwendet, aber ein expliziter oder impliziter Stapel wird weiterhin zum Speichern von Funktionsargumenten verwendet. </p><br><p>  Das Vorhandensein eines expliziten Stapels und eines Satzes von Registern bringt solche Maschinen näher an niedrige und sogar physische.  Die Fülle von Anweisungen auf niedriger Ebene in einem solchen Bytecode bedeutet, dass ein erheblicher Ressourcenaufwand des physischen Prozessors auf die Decodierung und Planung virtueller Anweisungen entfällt. </p><br><p>  Auf der anderen Seite spielen Anweisungen auf hoher Ebene in beliebten virtuellen Maschinen eine große Rolle.  In Java sind dies beispielsweise Anweisungen für polymorphe Funktionsaufrufe, Objektzuweisung und Speicherbereinigung. </p><br><p>  Rein übergeordnete virtuelle Maschinen - zum Beispiel Sprachbytecode-Interpreter mit entwickelter Semantik und weit entfernt von Eisen - verbringen die meiste Zeit nicht im Dispatcher oder Decoder, sondern in den Anweisungen und sind dementsprechend relativ effizient. </p><br><p>  Praktische Empfehlungen: </p><br><ol><li>  Wenn Sie einen Bytecode ausführen müssen und dies in angemessener Zeit tun müssen, versuchen Sie, mit Anweisungen zu arbeiten, die Ihrer Aufgabe am nächsten kommen.  Je höher die semantische Ebene, desto besser.  Dies reduziert die Planungskosten und vereinfacht die Codegenerierung. </li><li>  Wenn Sie mehr Flexibilität und heterogene Semantik benötigen, sollten Sie zumindest versuchen, den gemeinsamen Nenner im Bytecode hervorzuheben, damit die resultierenden Anweisungen auf einem bedingt durchschnittlichen Niveau liegen. </li><li>  Wenn es in Zukunft erforderlich sein kann, Ausdrücke zu berechnen und eine gestapelte Maschine zu erstellen, verringert dies die Kopfschmerzen beim Kompilieren von Bytecode. </li><li>  Wenn keine Ausdrücke erwartet werden, erstellen Sie eine einfache Registermaschine, die die Kosten des Stapels vermeidet und die Anweisungen selbst vereinfacht. </li></ol><br><p>  In den folgenden Artikeln werde ich praktische Implementierungen von virtuellen Maschinen in gängigen Programmiersprachen diskutieren und erklären, warum die Business Intelligence Badoo-Abteilung einen Bytecode benötigte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425325/">https://habr.com/ru/post/de425325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425313/index.html">Die 10 besten VS Code-Erweiterungen von 2018 für Front-End-Entwickler</a></li>
<li><a href="../de425315/index.html">Anordnen der Codespeicherung in GitLab und Integrieren der Codeüberprüfung in GitFlow</a></li>
<li><a href="../de425317/index.html">Wie es gemacht wird: Wir schreiben "Minesweeper" in 4 Minuten</a></li>
<li><a href="../de425321/index.html">Programmierung ist die Materialisierung von Ideen.</a></li>
<li><a href="../de425323/index.html">"Kaninchenbau." UX Designer im Produktteam</a></li>
<li><a href="../de425327/index.html">Funktionsprogrammierung: Siebenmal messen, einmal schneiden</a></li>
<li><a href="../de425329/index.html">Einige Ratschläge an die Millennials von den "Oldies". Wie man in unserer digitalen Welt erfolgreich ist</a></li>
<li><a href="../de425331/index.html">Alice hilft Entwicklern, Objekte in Benutzeranforderungen zu finden. NER in Dialogen</a></li>
<li><a href="../de425333/index.html">Boot dich selbst, der Frühling kommt (Teil 2)</a></li>
<li><a href="../de425335/index.html">Unbesiegte Armada Garmin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>