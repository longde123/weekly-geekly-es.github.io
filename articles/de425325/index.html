<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÇÔ∏è üë©‚Äçüíº üßëüèø‚Äçü§ù‚Äçüßëüèª DIY Bytecode Interpreter üßñüèΩ üëú üé≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Virtuelle Maschinen von Programmiersprachen sind in den letzten Jahrzehnten sehr verbreitet geworden. Seit der Pr√§sentation von Java Virtual Machine i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DIY Bytecode Interpreter</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/425325/"><p><img src="https://habrastorage.org/webt/aa/zv/cl/aazvcl84q5xly1zkqhtxelkemju.png"></p><br><p>  Virtuelle Maschinen von Programmiersprachen sind in den letzten Jahrzehnten sehr verbreitet geworden.  Seit der Pr√§sentation von Java Virtual Machine in der zweiten H√§lfte der 90er Jahre ist ziemlich viel Zeit vergangen, und man kann mit Sicherheit sagen, dass Bytecode-Interpreter nicht die Zukunft, sondern die Gegenwart sind. </p><br><p>  Aber diese Technik ist meiner Meinung nach fast universell und das Verst√§ndnis der Grundprinzipien der Dolmetscherentwicklung ist nicht nur f√ºr den Sch√∂pfer des n√§chsten Herausforderers f√ºr den Titel "Sprache des Jahres" nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TIOBE</a> n√ºtzlich, sondern f√ºr jeden Programmierer im Allgemeinen. </p><br><p>  Mit einem Wort, wenn Sie erfahren m√∂chten, wie unsere bevorzugten Programmiersprachen Zahlen addieren, wor√ºber Entwickler virtueller Maschinen immer noch streiten und wie Zeichenfolgen und regul√§re Ausdr√ºcke schmerzlos abgeglichen werden k√∂nnen, frage ich nach cat. </p><a name="habracut"></a><br><p>  Teil eins, Einf√ºhrung (aktuell) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil, Optimierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil, Angewandt</a> </p><br><h1 id="predystoriya">  Hintergrund </h1><br><p>  Eines der selbstgeschriebenen Systeme der Business Intelligence-Abteilung unseres Unternehmens verf√ºgt √ºber eine Schnittstelle in Form einer einfachen Abfragesprache.  In der ersten Version des Systems wurde diese Sprache im laufenden Betrieb ohne Kompilierung direkt aus der Eingabezeile mit der Anforderung interpretiert.  Die zweite Version des Parsers funktioniert bereits mit Zwischenbytecode, wodurch Sie die Abfragesprache von ihrer Ausf√ºhrung trennen und den Code erheblich vereinfachen k√∂nnen. </p><br><p> W√§hrend ich an der zweiten Version des Systems arbeitete, hatte ich einen Urlaub, in dem ich jeden Tag ein oder zwei Stunden lang von Familienangelegenheiten abgelenkt wurde, um Materialien √ºber die Architektur und Leistung von Bytecode-Dolmetschern zu studieren.  Ich beschloss, die daraus resultierenden Notizen und Beispiele von Dolmetschern als eine Reihe von Artikeln mit Habrs Lesern zu teilen. </p><br><p>  Die erste von ihnen pr√§sentiert f√ºnf kleine (bis zu Hunderte Zeilen einfachen C-Code) virtuelle Maschinen, von denen jede einen bestimmten Aspekt der Entwicklung solcher Interpreter enth√ºllt. </p><br><h1 id="otkuda-est-poshli-bayt-kody-v-yazykah-programmirovaniya">  Wohin gingen die Bytecodes in Programmiersprachen? </h1><br><p>  Es wurden sehr viele virtuelle Maschinen erfunden, die verschiedensten virtuellen Befehlss√§tze der letzten Jahrzehnte.  Wikipedia behauptet, dass die ersten Programmiersprachen bereits in den 60er Jahren des letzten Jahrhunderts zu verschiedenen vereinfachten Zwischendarstellungen kompiliert wurden.  Einige dieser ersten Bytecodes wurden in Maschinencodes konvertiert und von realen Prozessoren ausgef√ºhrt, w√§hrend andere von virtuellen Prozessoren im laufenden Betrieb interpretiert wurden. </p><br><p>  Die Popularit√§t virtueller Befehlss√§tze als Zwischendarstellung von Code hat drei Gr√ºnde: </p><br><ol><li>  Bytecode-Programme k√∂nnen problemlos auf neue Plattformen portiert werden. </li><li>  Bytecode-Interpreter sind schneller als Interpreter des Syntaxbaums des Codes. </li><li>  Sie k√∂nnen eine einfache virtuelle Maschine in nur wenigen Stunden entwickeln. </li></ol><br><p>  Lassen Sie uns einige einfache virtuelle C-Maschinen erstellen und anhand dieser Beispiele die wichtigsten technischen Aspekte der Implementierung virtueller Maschinen hervorheben. </p><br><p>  Vollst√§ndige Beispielcodes sind auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verf√ºgbar.  Beispiele k√∂nnen mit jedem relativ frischen GCC zusammengestellt werden: </p><br><pre><code class="plaintext hljs">gcc interpreter-basic-switch.c -o interpreter ./interpreter</code> </pre> <br><p>  Alle Beispiele haben die gleiche Struktur: Zuerst kommt der Code der virtuellen Maschine selbst, dann die Hauptfunktion mit Zusicherungen, die die Funktionsweise des Codes √ºberpr√ºfen.  Ich habe versucht, die Opcodes und Schl√ºsselstellen der Dolmetscher klar zu kommentieren.  Ich hoffe, dass dieser Artikel auch f√ºr Leute verst√§ndlich ist, die nicht t√§glich in C schreiben. </p><br><h1 id="samyy-prostoy-v-mire-interpretator-bayt-koda">  Der weltweit einfachste Bytecode-Interpreter </h1><br><p>  Wie gesagt, der einfachste Dolmetscher ist sehr einfach zu erstellen.  Kommentare befinden sich direkt hinter der Auflistung, aber beginnen wir direkt mit dem Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Es gibt weniger als hundert Zeilen, aber alle charakteristischen Attribute einer virtuellen Maschine werden dargestellt.  Die Maschine hat ein einzelnes Register ( <code>vm.accumulator</code> ), drei Operationen (Registerinkrement, Registerdekrement und Abschluss der Programmausf√ºhrung) und einen Zeiger auf den aktuellen Befehl ( <code>vm.ip</code> ). </p><br><p>  Jede Operation (dt. <em>Operationscode</em> oder <em>Opcode</em> ) wird mit einem Byte codiert, und die Planung wird unter Verwendung des √ºblichen <code>switch</code> in der Funktion <code>vm_interpret</code> .  Die Zweige im <code>switch</code> enthalten die Logik der Operationen, dh sie √§ndern den Status des Registers oder beenden die Ausf√ºhrung des Programms. </p><br><p>  Die Operationen werden als Array von Bytes - ein Bytecode (englischer <em>Bytecode</em> ) - an die Funktion <code>vm_interpret</code> √ºbertragen und nacheinander ausgef√ºhrt, bis die Operation zum <code>OP_DONE</code> virtuellen Maschine ( <code>OP_DONE</code> ) <code>OP_DONE</code> . </p><br><p>  Ein Schl√ºsselaspekt einer virtuellen Maschine ist die Semantik, dh die Menge der Operationen, die auf ihr m√∂glich sind.  In diesem Fall gibt es nur zwei Operationen, die den Wert eines einzelnen Registers √§ndern. </p><br><p>  Einige Forscher ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abstraktions- und Optimierungstechniken f√ºr</a> virtuelle Maschinen, 2009) schlagen vor, virtuelle Maschinen entsprechend der N√§he der Semantik der virtuellen Maschine zur Semantik der physischen Maschine, auf der der Bytecode ausgef√ºhrt wird, in √ºbergeordnete und <em>untergeordnete Ebenen zu unterteilen</em> . </p><br><p>  Im Extremfall kann der Bytecode von virtuellen Maschinen auf niedriger Ebene den Maschinencode der physischen Maschine mit simuliertem RAM, einem vollst√§ndigen Satz von Registern, Anweisungen zum Arbeiten mit dem Stapel usw. vollst√§ndig wiederholen.  Die virtuelle Maschine von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bochs</a> wiederholt beispielsweise den Befehlssatz der x86-Architektur. </p><br><p>  Und umgekehrt: Der Betrieb von virtuellen Maschinen auf hoher Ebene spiegelt die Semantik einer speziellen Programmiersprache wider, die in Bytecode kompiliert wurde.  Arbeiten Sie beispielsweise mit SQLite, Gawk und zahlreichen Versionen von Prolog. </p><br><p>  Zwischenpositionen werden von Dolmetschern f√ºr allgemeine Programmiersprachen mit Elementen sowohl auf hohem als auch auf niedrigem Niveau besetzt.  Die beliebteste Java Virtual Machine verf√ºgt sowohl √ºber einfache Anweisungen zum Arbeiten mit dem Stack als auch √ºber eine integrierte Unterst√ºtzung f√ºr die objektorientierte Programmierung mit automatischer Speicherzuweisung. </p><br><p>  Der obige Code ist eher die primitivste virtuelle Maschine auf niedriger Ebene: Jeder virtuelle Befehl ist ein Wrapper √ºber einen oder zwei physische Befehle, das virtuelle Register stimmt vollst√§ndig mit einem Register des "Eisen" -Prozessors √ºberein. </p><br><h1 id="argumenty-instrukciy-v-bayt-kode">  Bytecode-Anweisungsargumente </h1><br><p>  Wir k√∂nnen sagen, dass das einzige Register in unserem Beispiel f√ºr eine virtuelle Maschine sowohl ein Argument als auch der R√ºckgabewert aller ausgef√ºhrten Anweisungen ist.  Es kann jedoch n√ºtzlich sein, Argumente in Anweisungen zu √ºbergeben.  Eine M√∂glichkeit besteht darin, sie direkt in den Bytecode einzuf√ºgen. </p><br><p>  Wir werden das Beispiel erweitern, indem wir Anweisungen (OP_ADDI, OP_SUBI) einf√ºhren, die ein Argument in Form eines Bytes unmittelbar nach dem Opcode annehmen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> accumulator; } vm; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* increment the register */</span></span> OP_INC, <span class="hljs-comment"><span class="hljs-comment">/* decrement the register */</span></span> OP_DEC, <span class="hljs-comment"><span class="hljs-comment">/* add the immediate argument to the register */</span></span> OP_ADDI, <span class="hljs-comment"><span class="hljs-comment">/* subtract the immediate argument from the register */</span></span> OP_SUBI, <span class="hljs-comment"><span class="hljs-comment">/* stop execution */</span></span> OP_DONE } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> interpret_result { SUCCESS, ERROR_UNKNOWN_OPCODE, } interpret_result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Reset vm state"</span></span>); vm = (typeof(vm)) { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }; } <span class="hljs-function"><span class="hljs-function">interpret_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_interpret</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span><span class="hljs-function"> </span></span>{ vm_reset(); <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"Start interpreting"</span></span>); vm.ip = bytecode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *vm.ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_INC: { vm.accumulator++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DEC: { vm.accumulator--; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_ADDI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator += arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_SUBI: { <span class="hljs-comment"><span class="hljs-comment">/* get the argument */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> arg = *vm.ip++; vm.accumulator -= arg; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_DONE: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ERROR_UNKNOWN_OPCODE; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SUCCESS; }</code> </pre><br><p>  Neue Anweisungen (siehe die Funktion <code>vm_interpret</code> ) lesen ihr Argument aus dem Bytecode und f√ºgen es dem Register hinzu / subtrahieren es vom Register. </p><br><p>  Ein solches Argument wird als <em>sofortiges Argument bezeichnet</em> , da es sich direkt im Opcode-Array befindet.  Die Hauptbeschr√§nkung in unserer Implementierung besteht darin, dass das Argument ein einzelnes Byte ist und nur 256 Werte annehmen kann. </p><br><p>  In unserer virtuellen Maschine spielt der Bereich m√∂glicher Befehlsargumentwerte keine gro√üe Rolle.  Wenn die virtuelle Maschine jedoch als Interpreter der realen Sprache verwendet wird, ist es sinnvoll, den Bytecode zu komplizieren, indem eine vom Array der Opcodes und Anweisungen getrennte Konstantentabelle mit einem direkten Argument hinzugef√ºgt wird, das der Adresse des realen Arguments in der Konstantentabelle entspricht. </p><br><h1 id="stekovaya-mashina">  Stapelmaschine </h1><br><p>  Anweisungen in unserer einfachen virtuellen Maschine arbeiten immer mit einem Register und k√∂nnen in keiner Weise Daten untereinander √ºbertragen.  Au√üerdem kann das Argument f√ºr die Anweisung nur unmittelbar sein, und die Additions- oder Multiplikationsoperation ben√∂tigt beispielsweise zwei Argumente. </p><br><p>  Einfach ausgedr√ºckt, wir haben keine M√∂glichkeit, komplexe Ausdr√ºcke zu bewerten.  Um dieses Problem zu l√∂sen, wird eine gestapelte Maschine ben√∂tigt, dh eine virtuelle Maschine mit einem integrierten Stapel: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STACK_MAX 256 struct { uint8_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Fixed-size stack */</span></span></span><span class="hljs-meta"> uint64_t stack[STACK_MAX]; uint64_t *stack_top; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* push the immediate argument onto the stack */</span></span></span><span class="hljs-meta"> OP_PUSHI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, add and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, subtract and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, divide and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop 2 values from the stack, multiply and push the result onto the stack */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pop the top of the stack and set it as execution result */</span></span></span><span class="hljs-meta"> OP_POP_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; vm.stack_top = vm.stack; } void vm_stack_push(uint64_t value) { *vm.stack_top = value; vm.stack_top++; } uint64_t vm_stack_pop(void) { vm.stack_top--; return *vm.stack_top; } interpret_result vm_interpret(uint8_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; for (;;) { uint8_t instruction = *vm.ip++; switch (instruction) { case OP_PUSHI: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* get the argument, push it onto stack */</span></span></span><span class="hljs-meta"> uint8_t arg = *vm.ip++; vm_stack_push(arg); break; } case OP_ADD: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, add 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left + arg_right; vm_stack_push(res); break; } case OP_SUB: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, subtract 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left - arg_right; vm_stack_push(res); break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, divide 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (arg_right == 0) return ERROR_DIVISION_BY_ZERO; uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left / arg_right; vm_stack_push(res); break; } case OP_MUL: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop 2 values, multiply 'em, push the result back to the stack */</span></span></span><span class="hljs-meta"> uint64_t arg_right = vm_stack_pop(); uint64_t arg_left = vm_stack_pop(); uint64_t res = arg_left * arg_right; vm_stack_push(res); break; } case OP_POP_RES: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Pop the top of the stack, set it as a result value */</span></span></span><span class="hljs-meta"> uint64_t res = vm_stack_pop(); vm.result = res; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  In diesem Beispiel gibt es mehr Operationen, und fast alle funktionieren nur mit dem Stapel.  OP_PUSHI schiebt sein unmittelbares Argument auf den Stapel.  Die Anweisungen OP_ADD, OP_SUB, OP_DIV, OP_MUL werden aus einem Wertestapel entfernt, das Ergebnis berechnet und auf den Stapel zur√ºckgeschoben.  OP_POP_RES entfernt den Wert aus dem Stapel und legt ihn im Ergebnisregister ab, das f√ºr die Ergebnisse der virtuellen Maschine vorgesehen ist. </p><br><p>  F√ºr die Divisionsoperation (OP_DIV) wird ein Fehler durch Division durch Null abgefangen, der die virtuelle Maschine stoppt. </p><br><p>  Die F√§higkeiten einer solchen Maschine sind viel breiter als die der vorherigen mit einem einzigen Register und erm√∂glichen beispielsweise die Berechnung komplexer arithmetischer Ausdr√ºcke.  Ein weiterer (und wichtiger!) Vorteil ist die einfache Kompilierung von Programmiersprachen in den Bytecode der Stapelmaschine. </p><br><h1 id="registrovaya-mashina">  Maschine registrieren </h1><br><p>  Aufgrund ihrer Einfachheit werden gestapelte virtuelle Maschinen unter Entwicklern von Programmiersprachen am h√§ufigsten verwendet.  Dieselben JVMs und Python-VMs verwenden genau diese. </p><br><p>  Solche Maschinen haben jedoch Nachteile: Sie m√ºssen spezielle Anweisungen f√ºr die Arbeit mit dem Stapel hinzuf√ºgen. Bei der Berechnung von Ausdr√ºcken durchlaufen alle Argumente wiederholt eine einzelne Datenstruktur. Im Stapelcode werden unweigerlich viele zus√§tzliche Anweisungen angezeigt. </p><br><p>  In der Zwischenzeit verursacht die Ausf√ºhrung jedes zus√§tzlichen Befehls die Kosten f√ºr die Planung, dh das Decodieren des Opcodes und das Umschalten auf den Hauptteil der Befehle. </p><br><p>  Eine Alternative zu gestapelten Maschinen ist das Registrieren virtueller Maschinen.  Sie haben einen komplexeren Bytecode: Die Anzahl der Registerargumente und die Nummer des Registerergebnisses werden in jedem Befehl explizit codiert.  Dementsprechend wird anstelle eines Stapels ein erweiterter Satz von Registern als Speicher f√ºr Zwischenwerte verwendet. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_NUM 16 struct { uint16_t *ip; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Register array */</span></span></span><span class="hljs-meta"> uint64_t reg[REGISTER_NUM]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* A single register containing the result */</span></span></span><span class="hljs-meta"> uint64_t result; } vm; typedef enum { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Load an immediate value into r0 */</span></span></span><span class="hljs-meta"> OP_LOADI, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Add values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_ADD, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Subtract values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_SUB, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Divide values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_DIV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Multiply values in r0,r1 registers and put them into r2 */</span></span></span><span class="hljs-meta"> OP_MUL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Move a value from r0 register into the result register */</span></span></span><span class="hljs-meta"> OP_MOV_RES, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* stop execution */</span></span></span><span class="hljs-meta"> OP_DONE, } opcode; typedef enum interpret_result { SUCCESS, ERROR_DIVISION_BY_ZERO, ERROR_UNKNOWN_OPCODE, } interpret_result; void vm_reset(void) { puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Reset vm state"</span></span></span><span class="hljs-meta">); vm = (typeof(vm)) { NULL }; } void decode(uint16_t instruction, uint8_t *op, uint8_t *reg0, uint8_t *reg1, uint8_t *reg2, uint8_t *imm) { *op = (instruction &amp; 0xF000) &gt;&gt; 12; *reg0 = (instruction &amp; 0x0F00) &gt;&gt; 8; *reg1 = (instruction &amp; 0x00F0) &gt;&gt; 4; *reg2 = (instruction &amp; 0x000F); *imm = (instruction &amp; 0x00FF); } interpret_result vm_interpret(uint16_t *bytecode) { vm_reset(); puts(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Start interpreting"</span></span></span><span class="hljs-meta">); vm.ip = bytecode; uint8_t op, r0, r1, r2, immediate; for (;;) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* fetch the instruction */</span></span></span><span class="hljs-meta"> uint16_t instruction = *vm.ip++; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* decode it */</span></span></span><span class="hljs-meta"> decode(instruction, &amp;op, &amp;r0, &amp;r1, &amp;r2, &amp;immediate); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* dispatch */</span></span></span><span class="hljs-meta"> switch (op) { case OP_LOADI: { vm.reg[r0] = immediate; break; } case OP_ADD: { vm.reg[r2] = vm.reg[r0] + vm.reg[r1]; break; } case OP_SUB: { vm.reg[r2] = vm.reg[r0] - vm.reg[r1]; break; } case OP_DIV: { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't forget to handle the div by zero error */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (vm.reg[r1] == 0) return ERROR_DIVISION_BY_ZERO; vm.reg[r2] = vm.reg[r0] / vm.reg[r1]; break; } case OP_MUL: { vm.reg[r2] = vm.reg[r0] * vm.reg[r1]; break; } case OP_MOV_RES: { vm.result = vm.reg[r0]; break; } case OP_DONE: { return SUCCESS; } default: return ERROR_UNKNOWN_OPCODE; } } return SUCCESS; }</span></span></code> </pre><br><p>  Das Beispiel zeigt eine Registermaschine mit 16 Registern.  Anweisungen belegen jeweils 16 Bit und werden auf drei Arten codiert: </p><br><ol><li>  4 Bit pro Opcode + 4 Bit pro Registername + 8 Bit pro Argument. </li><li>  4 Bits pro Opcode + dreimal 4 Bits pro Registernamen. </li><li>  4 Bits pro Opcode + 4 Bits pro Einzelregistername + 8 nicht verwendete Bits. </li></ol><br><p>  Unsere kleine virtuelle Maschine hat nur sehr wenige Operationen, sodass vier Bits (oder 16 m√∂gliche Operationen) pro Opcode v√∂llig ausreichen.  Die Operation bestimmt, was genau die verbleibenden Bits des Befehls darstellen. </p><br><p>  Die erste Art der Codierung (4 + 4 + 8) wird ben√∂tigt, um Daten mit der Operation OP_LOADI in Register zu laden.  Der zweite Typ (4 + 4 + 4 + 4) wird f√ºr arithmetische Operationen verwendet, die wissen sollten, wo ein Argumentpaar verwendet und wo das Berechnungsergebnis hinzugef√ºgt werden muss.  Und schlie√ülich wird die letzte Form (4 + 4 + 8 unn√∂tige Bits) f√ºr Anweisungen mit einem einzelnen Register als Argument verwendet, in unserem Fall OP_MOV_RES. </p><br><p>  Zum Codieren und Decodieren von Anweisungen ben√∂tigen wir jetzt eine spezielle Logik ( <code>decode</code> ).  Andererseits wird die Logik von Anweisungen dank der expliziten Angabe der Position der Argumente einfacher - Operationen mit dem Stapel verschwinden. </p><br><p>  Hauptmerkmale: Im Bytecode von Registermaschinen gibt es weniger Anweisungen, einzelne Anweisungen sind breiter, das Kompilieren in einen solchen Bytecode ist schwieriger - der Compiler muss entscheiden, wie die verf√ºgbaren Register verwendet werden sollen. </p><br><p>  Es ist zu beachten, dass es in der Praxis in virtuellen Registermaschinen normalerweise einen Stapel gibt, in dem beispielsweise Funktionsargumente platziert werden.  Register werden verwendet, um einzelne Ausdr√ºcke zu berechnen.  Selbst wenn es keinen expliziten Stapel gibt, wird ein Array zum Erstellen des Stapels verwendet, das dieselbe Rolle spielt wie RAM in physischen Maschinen. </p><br><h1 id="stekovye-i-registrovye-mashiny-sravnenie">  Maschinen stapeln und registrieren, Vergleich </h1><br><p>  Es gibt eine interessante Studie ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Showdown</a> f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">virtuelle Maschinen: Stapel versus Register</a> , 2008), die einen gro√üen Einfluss auf alle nachfolgenden Entwicklungen auf dem Gebiet der virtuellen Maschinen f√ºr Programmiersprachen hatte.  Die Autoren haben eine Methode zur direkten √úbersetzung vom Stapelcode einer Standard-JVM in einen Registercode vorgeschlagen und die Leistung verglichen. </p><br><p>  Die Methode ist nicht trivial: Der Code wird zuerst √ºbersetzt und dann auf ziemlich komplizierte Weise optimiert.  Ein anschlie√üender Vergleich der Leistung desselben Programms zeigte jedoch, dass die zus√§tzlichen Prozessorzyklen, die f√ºr das Decodieren von Befehlen aufgewendet werden, durch eine Verringerung der Gesamtzahl von Befehlen vollst√§ndig kompensiert werden.  Kurz gesagt, im Allgemeinen war die Registermaschine effizienter als die Stapelmaschine. </p><br><p>  Wie bereits oben erw√§hnt, hat diese Effizienz einen durchaus greifbaren Preis: Der Compiler muss die Register selbst zuordnen, und ein erweiterter Optimierer ist zus√§tzlich w√ºnschenswert. </p><br><p>  Die Debatte dar√ºber, welche Architektur besser ist, ist noch nicht vorbei.  Wenn wir √ºber Java-Compiler sprechen, wurde der Dalvik VM-Bytecode registriert, der bis vor kurzem auf jedem Android-Ger√§t funktioniert hat.  Der Titel JVM hat jedoch einen Stapel von Anweisungen beibehalten.  Die virtuelle Lua-Maschine verwendet eine Registermaschine, die Python-VM ist jedoch weiterhin stapelbar.  Usw. </p><br><h1 id="bayt-kod-v-interpretatorah-regulyarnyh-vyrazheniy">  Bytecode in Interpreten f√ºr regul√§re Ausdr√ºcke </h1><br><p>  Um uns von virtuellen Maschinen auf niedriger Ebene abzulenken, schauen wir uns einen speziellen Interpreter an, der Zeichenfolgen auf √úbereinstimmung mit regul√§ren Ausdr√ºcken √ºberpr√ºft: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* match a single char to an immediate argument from the string and advance ip and cp, or * abort*/</span></span> OP_CHAR, <span class="hljs-comment"><span class="hljs-comment">/* jump to and match either left expression or the right one, abort if nothing matches*/</span></span> OP_OR, <span class="hljs-comment"><span class="hljs-comment">/* do an absolute jump to an offset in the immediate argument */</span></span> OP_JUMP, <span class="hljs-comment"><span class="hljs-comment">/* stop execution and report a successful match */</span></span> OP_MATCH, } opcode; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { MATCH_OK, MATCH_FAIL, MATCH_ERROR, } match_result; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match_recur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ip, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *sp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> instruction = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (instruction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_CHAR:{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cur_c = *sp; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> arg_c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)*ip ; <span class="hljs-comment"><span class="hljs-comment">/* no match? FAILed to match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg_c != cur_c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_FAIL; <span class="hljs-comment"><span class="hljs-comment">/* advance both current instruction and character pointers */</span></span> ip++; sp++; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_JUMP:{ <span class="hljs-comment"><span class="hljs-comment">/* read the offset and jump to the instruction */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> offset = *ip; ip = bytecode + offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_OR:{ <span class="hljs-comment"><span class="hljs-comment">/* get both branch offsets */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> left_offset = *ip++; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> right_offset = *ip; <span class="hljs-comment"><span class="hljs-comment">/* check if following the first offset get a match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *left_ip = bytecode + left_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vm_match_recur(bytecode, left_ip, sp) == MATCH_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; <span class="hljs-comment"><span class="hljs-comment">/* no match? Check the second branch */</span></span> ip = bytecode + right_offset; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OP_MATCH:{ <span class="hljs-comment"><span class="hljs-comment">/* success */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_OK; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MATCH_ERROR; } } <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_match</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Start matching a string: %s\n"</span></span>, str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vm_match_recur(bytecode, bytecode, str); }</code> </pre><br><p>  Die Hauptanweisung ist OP_CHAR.  Sie nimmt ihr unmittelbares Argument und vergleicht es mit dem aktuellen Zeichen in der Zeichenfolge ( <code>char *sp</code> ).  Bei √úbereinstimmung der erwarteten und aktuellen Zeichen in der Zeile erfolgt der √úbergang zum n√§chsten Befehl und zum n√§chsten Zeichen. </p><br><p>  Die Maschine versteht auch die Sprungoperation (OP_JUMP), die ein einzelnes sofortiges Argument akzeptiert.  Das Argument bedeutet den absoluten Versatz im Bytecode, von dem aus die Berechnung fortgesetzt werden soll. </p><br><p>  Die letzte wichtige Operation ist OP_OR.  Sie nimmt zwei Offsets und versucht, den Code zuerst auf den ersten und im Fehlerfall auf den zweiten anzuwenden.  Sie tut dies mit einem rekursiven Aufruf, dh die Anweisung macht einen Spaziergang in die Tiefe des Baumes aller m√∂glichen Varianten des regul√§ren Ausdrucks. </p><br><p>  √úberraschenderweise reichen vier Opcodes und siebzig Codezeilen aus, um regul√§re Ausdr√ºcke wie "abc", "a? Bc", "(ab | bc) d", "a * bc" auszudr√ºcken.  Diese virtuelle Maschine hat nicht einmal einen expliziten Status, da alles, was Sie ben√∂tigen - Zeiger auf den Anfang des Befehlsstroms, den aktuellen Befehl und das aktuelle Zeichen - als Argumente an die rekursive Funktion √ºbergeben wird. </p><br><p>  Wenn Sie an den Details der Arbeit von Engines-Engines interessiert sind, k√∂nnen Sie zun√§chst eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln von</a> Russ Cox lesen, dem Autor der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reglement-</a> Engines von Google <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RE2</a> . </p><br><h1 id="itogi">  Zusammenfassung </h1><br><p>  Fassen wir zusammen. </p><br><p>  F√ºr allgemeine Programmiersprachen werden in der Regel zwei Architekturen verwendet: Stack und Register. </p><br><p>  Im Stapelmodell ist der Stapel die Hauptdatenstruktur und Methode zum √úbergeben von Argumenten zwischen Anweisungen.  Im Registermodell wird ein Satz von Registern zum Berechnen von Ausdr√ºcken verwendet, aber ein expliziter oder impliziter Stapel wird weiterhin zum Speichern von Funktionsargumenten verwendet. </p><br><p>  Das Vorhandensein eines expliziten Stapels und eines Satzes von Registern bringt solche Maschinen n√§her an niedrige und sogar physische.  Die F√ºlle von Anweisungen auf niedriger Ebene in einem solchen Bytecode bedeutet, dass ein erheblicher Ressourcenaufwand des physischen Prozessors auf die Decodierung und Planung virtueller Anweisungen entf√§llt. </p><br><p>  Auf der anderen Seite spielen Anweisungen auf hoher Ebene in beliebten virtuellen Maschinen eine gro√üe Rolle.  In Java sind dies beispielsweise Anweisungen f√ºr polymorphe Funktionsaufrufe, Objektzuweisung und Speicherbereinigung. </p><br><p>  Rein √ºbergeordnete virtuelle Maschinen - zum Beispiel Sprachbytecode-Interpreter mit entwickelter Semantik und weit entfernt von Eisen - verbringen die meiste Zeit nicht im Dispatcher oder Decoder, sondern in den Anweisungen und sind dementsprechend relativ effizient. </p><br><p>  Praktische Empfehlungen: </p><br><ol><li>  Wenn Sie einen Bytecode ausf√ºhren m√ºssen und dies in angemessener Zeit tun m√ºssen, versuchen Sie, mit Anweisungen zu arbeiten, die Ihrer Aufgabe am n√§chsten kommen.  Je h√∂her die semantische Ebene, desto besser.  Dies reduziert die Planungskosten und vereinfacht die Codegenerierung. </li><li>  Wenn Sie mehr Flexibilit√§t und heterogene Semantik ben√∂tigen, sollten Sie zumindest versuchen, den gemeinsamen Nenner im Bytecode hervorzuheben, damit die resultierenden Anweisungen auf einem bedingt durchschnittlichen Niveau liegen. </li><li>  Wenn es in Zukunft erforderlich sein kann, Ausdr√ºcke zu berechnen und eine gestapelte Maschine zu erstellen, verringert dies die Kopfschmerzen beim Kompilieren von Bytecode. </li><li>  Wenn keine Ausdr√ºcke erwartet werden, erstellen Sie eine einfache Registermaschine, die die Kosten des Stapels vermeidet und die Anweisungen selbst vereinfacht. </li></ol><br><p>  In den folgenden Artikeln werde ich praktische Implementierungen von virtuellen Maschinen in g√§ngigen Programmiersprachen diskutieren und erkl√§ren, warum die Business Intelligence Badoo-Abteilung einen Bytecode ben√∂tigte. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425325/">https://habr.com/ru/post/de425325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425313/index.html">Die 10 besten VS Code-Erweiterungen von 2018 f√ºr Front-End-Entwickler</a></li>
<li><a href="../de425315/index.html">Anordnen der Codespeicherung in GitLab und Integrieren der Code√ºberpr√ºfung in GitFlow</a></li>
<li><a href="../de425317/index.html">Wie es gemacht wird: Wir schreiben "Minesweeper" in 4 Minuten</a></li>
<li><a href="../de425321/index.html">Programmierung ist die Materialisierung von Ideen.</a></li>
<li><a href="../de425323/index.html">"Kaninchenbau." UX Designer im Produktteam</a></li>
<li><a href="../de425327/index.html">Funktionsprogrammierung: Siebenmal messen, einmal schneiden</a></li>
<li><a href="../de425329/index.html">Einige Ratschl√§ge an die Millennials von den "Oldies". Wie man in unserer digitalen Welt erfolgreich ist</a></li>
<li><a href="../de425331/index.html">Alice hilft Entwicklern, Objekte in Benutzeranforderungen zu finden. NER in Dialogen</a></li>
<li><a href="../de425333/index.html">Boot dich selbst, der Fr√ºhling kommt (Teil 2)</a></li>
<li><a href="../de425335/index.html">Unbesiegte Armada Garmin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>