<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèª ‚ÜîÔ∏è üï• Escribiendo sombreadores en Unity. GrabPass, PerRendererData üò™ üßëüèª‚Äçü§ù‚Äçüßëüèª üò°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Me gustar√≠a compartir mi experiencia escribiendo sombreadores en Unity. Comencemos con el sombreador de desplazamiento / refracci√≥n en 2D, consid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribiendo sombreadores en Unity. GrabPass, PerRendererData</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427357/">  Hola  Me gustar√≠a compartir mi experiencia escribiendo sombreadores en Unity.  Comencemos con el sombreador de desplazamiento / refracci√≥n en 2D, considere la funcionalidad utilizada para escribirlo (GrabPass, PerRendererData) y tambi√©n preste atenci√≥n a los problemas que necesariamente surgir√°n. <br><br>  La informaci√≥n es √∫til para aquellos que tienen una idea general de los sombreadores y trataron de crearlos, pero no est√°n familiarizados con las capacidades que proporciona Unity y no saben qu√© lado abordar.  Echa un vistazo, tal vez mi experiencia te ayudar√° a resolverlo. <br><br><img src="https://habrastorage.org/webt/7p/cy/pr/7pcyprnckvacvecylqvlu-8g68m.gif"><br><a name="habracut"></a><br>  Este es el resultado que queremos lograr. <br><br><img src="https://habrastorage.org/webt/u5/wo/ll/u5woll2fo6nibjmd0lrgvszxvxk.gif" alt="imagen"><br><br><h2>  Preparaci√≥n </h2><br>  Primero, crea un sombreador que simplemente dibuje el sprite especificado.  √âl ser√° nuestra base para futuras manipulaciones.  Algo se le agregar√°, algo por el contrario se eliminar√°.  Ser√° diferente del est√°ndar "Sprites-Default" por la ausencia de algunas etiquetas y acciones que no afectar√°n el resultado. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de sombreador para renderizar sprite</b> <div class="spoiler_text"><pre><code class="hljs pgsql">Shader "Displacement/Displacement_Wave" { Properties { [PerRendererData] _MainTex ("Main Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Color ("Color" , Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) } SubShader { Tags { "RenderType" = "Transparent" "Queue" = "Transparent" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend SrcAlpha OneMinusSrcAlpha Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnityCG.cginc" struct appdata { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : POSITION; float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; struct v2f { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; float2 uv : TEXCOORD0; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; fixed4 _Color; sampler2D _MainTex; v2f vert (appdata v) { v2f o; o.uv = v.uv; o.color = v.color; o.vertex = UnityObjectToClipPos(v.vertex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; } fixed4 frag (v2f i) : SV_Target { fixed4 texColor = tex2D(_MainTex, i.uv)*i.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texColor; } ENDCG } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Sprite para mostrar</b> <div class="spoiler_text">  El fondo es realmente transparente, intencionalmente oscurecido. <br><br><img src="https://habrastorage.org/webt/7l/yu/in/7lyuingedtk8frmquebh2m0kgdy.jpeg" alt="imagen"><br></div></div><br>  La pieza de trabajo resultante. <br><br><img src="https://habrastorage.org/webt/yl/ir/9i/ylir9i7bz4ibkkbhag61q8v95ak.jpeg" alt="imagen"><br><br><h2>  Grabpass </h2><br>  Ahora nuestra tarea es hacer cambios a la imagen actual en la pantalla, y para esto necesitamos obtener una imagen.  Y el pasaje <i>GrabPass</i> nos ayudar√° con esto.  Este pasaje capturar√° la imagen de la pantalla en textura <i>_GrabTexture</i> .  La textura contendr√° solo lo que se dibuj√≥ antes de que nuestro objeto con este sombreador se renderizara. <br><br>  Adem√°s de la textura en s√≠, necesitamos las coordenadas del escaneo para obtener el color del p√≠xel.  Para hacer esto, agregue coordenadas de textura adicionales a los datos del sombreador de fragmentos.  Estas coordenadas no est√°n normalizadas (los valores no est√°n en el rango de 0 a 1) y describen la posici√≥n de un punto en el espacio de la c√°mara (proyecci√≥n). <br><br><pre> <code class="hljs pgsql">struct v2f { <span class="hljs-type"><span class="hljs-type">float4</span></span> vertex : SV_POSITION; float2 uv : <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; <span class="hljs-type"><span class="hljs-type">float4</span></span> grabPos : TEXCOORD1; };</code> </pre> <br>  Y en el sombreador de v√©rtices, ll√©nalos. <br><br><pre> <code class="hljs">o.grabPos = ComputeGrabScreenPos (o.vertex);</code> </pre> <br>  Para obtener el color de <i>_GrabTexture</i> , podemos usar el siguiente m√©todo si usamos coordenadas no normalizadas <br><br><pre> <code class="hljs lisp">tex2Dproj(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos)</code> </pre> <br>  Pero usaremos un m√©todo diferente y normalizaremos las coordenadas nosotros mismos, usando la divisi√≥n en perspectiva, es decir.  dividiendo a todos los dem√°s en el componente w. <br><br><pre> <code class="hljs lisp">tex2D(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos.xy/i.grabPos.w)</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">w componente</b> <div class="spoiler_text">  La divisi√≥n en un componente w es necesaria solo cuando se usa la perspectiva, en la proyecci√≥n ortogr√°fica siempre ser√° 1. De hecho, <b>w</b> almacena el valor de la distancia, apunta a la c√°mara.  Pero no es profundidad: <b>z</b> , cuyo valor debe estar en el rango de 0 a 1. Trabajar con profundidad es digno de un tema separado, por lo que volveremos a nuestro sombreador. </div></div><br>  La divisi√≥n en perspectiva tambi√©n se puede realizar en el sombreador de v√©rtices, y los datos ya preparados se pueden transferir al sombreador de fragmentos. <br><br><pre> <code class="hljs mel">v2f vert (appdata v) { v2f o; o.uv = v.uv; o.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = v.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; o.vertex = UnityObjectToClipPos(v.vertex); o.grabPos = ComputeScreenPos (o.vertex); o.grabPos /= o.grabPos.w; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; }</code> </pre> <br>  Agregue un sombreador de fragmentos, respectivamente. <br><br><pre> <code class="hljs matlab">fixed4 frag (v2f <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) : SV_Target { fixed4 = grabColor = tex2d(_GrabTexture, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.grabPos.xy); fixed4 texColor = tex2D(_MainTex, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.uv)*<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>.color; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> grabColor; }</code> </pre> <br>  Desactiva el modo de mezcla especificado, porque  ahora estamos implementando nuestro modo de fusi√≥n dentro del sombreador de fragmentos. <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//Blend SrcAlpha OneMinusSrcAlpha Blend Off</span></span></code> </pre><br>  Y mira el resultado de <i>GrabPass</i> . <br><br><img src="https://habrastorage.org/webt/mh/ex/b_/mhexb_lek_zyrgsto6p0ki4rmoi.jpeg" alt="imagen"><br><br>  Nada parece haber sucedido, pero no es as√≠.  Para mayor claridad, introducimos un ligero cambio, para esto agregaremos el valor de la variable a las coordenadas de textura.  Para que podamos modificar la variable, agregue una nueva propiedad <i>_DisplacementPower</i> . <br><br><pre> <code class="hljs powershell">Properties { <span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Main Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Color (<span class="hljs-string"><span class="hljs-string">"Color"</span></span> , Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _DisplacementPower (<span class="hljs-string"><span class="hljs-string">"Displacement Power"</span></span> , Float) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Pass { ... float _DisplacementPower; ... } }</code> </pre> <br>  Y de nuevo, realice cambios en el sombreador de fragmentos. <br><br><pre> <code class="hljs lisp">fixed4 grabColor = tex2d(<span class="hljs-name"><span class="hljs-name">_GrabTexture</span></span>, i.grabPos.xy + _DisplaccementPower)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  ¬°Op hop y resultado!  Imagen con turno. <br><br><img src="https://habrastorage.org/webt/ky/yl/9w/kyyl9w51dqeap4_wvxws1nod4fg.jpeg"><br><br>  Despu√©s de un cambio exitoso, puede proceder a una distorsi√≥n m√°s compleja.  Utilizamos texturas preparadas previamente que almacenar√°n la fuerza de desplazamiento en el punto especificado.  Color rojo para el valor de desplazamiento en el eje x, y verde en el eje y. <br><br><div class="spoiler">  <b class="spoiler_title">Texturas utilizadas para distorsi√≥n</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/0f/fu/-e/0ffu-ezmyhr9lb3qofn9d99ese8.png"><br><img src="https://habrastorage.org/webt/ld/mf/no/ldmfnoicn2b7e7cmsbpeml716hs.png"><br></div></div><br>  Empecemos  Agregue una nueva propiedad para almacenar la textura. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">_DisplacementTex</span></span> (<span class="hljs-string"><span class="hljs-string">"Displacement Texture"</span></span>, 2D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {}</code> </pre> <br>  Y una variable. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _DisplacementTex;</code> </pre> <br>  En el sombreador de fragmentos obtenemos los valores de desplazamiento de la textura y los agregamos a las coordenadas de textura. <br><br><pre> <code class="hljs lisp">fixed4 displPos = tex2D(<span class="hljs-name"><span class="hljs-name">_DisplacementTex</span></span>, i.uv)<span class="hljs-comment"><span class="hljs-comment">; float2 offset = (displPos.xy*2 - 1) * _DisplacementPower * displPos.a; fixed4 grabColor = tex2D (_GrabTexture, i.grabPos.xy + offset);</span></span></code> </pre><br>  Ahora, al cambiar los valores del par√°metro <i>_DisplacementPower</i> , no solo cambiamos la imagen original, sino que la distorsionamos. <br><br><img src="https://habrastorage.org/webt/tu/pu/w3/tupuw3jqxaztn2jl19mdyhtvzwi.gif"><br><br><h3>  Superposici√≥n </h3><br>  Ahora en la pantalla solo hay una distorsi√≥n del espacio, y el sprite, que mostramos al principio, est√° ausente.  Lo devolveremos a su lugar.  Para hacer esto, utilizaremos una mezcla dif√≠cil de colores.  Tome algo m√°s, como el modo de fusi√≥n de superposici√≥n.  Su f√≥rmula es la siguiente: <br><br><img src="https://habrastorage.org/webt/wd/qr/z7/wdqrz7rv0skaotpofwwu4owvyxy.jpeg"><br><br>  donde S es la imagen original, C es correctivo, es decir, nuestro sprite, R es el resultado. <br><br>  Transfiere esta f√≥rmula a nuestro sombreador. <br><br><pre> <code class="hljs mel">fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>*texColor : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span>*(<span class="hljs-number"><span class="hljs-number">1</span></span>-texColor)*(<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>);</code> </pre><br>  El uso de operadores condicionales en un sombreador es un tema bastante confuso.  Mucho depende de la plataforma y la API de gr√°ficos utilizada.  En algunos casos, las declaraciones condicionales no afectar√°n el rendimiento.  Pero siempre vale la pena tener una reserva.  El operador condicional se puede reemplazar utilizando las matem√°ticas y los m√©todos disponibles.  Usamos la siguiente construcci√≥n <br><br><pre> <code class="hljs swift"><span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = step ( y, x); r = <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> * a + (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) * b;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Funci√≥n de paso</b> <div class="spoiler_text">  La funci√≥n de paso devolver√° 1 si <b>x es</b> mayor o igual que <b>y</b> .  Y 0 si <b>x es</b> menor que <b>y</b> . <br><br>  Por ejemplo, si <b>x</b> = 1 <b>ey</b> = 0.5, entonces el resultado de <b>c</b> ser√° 1. Y la siguiente expresi√≥n se ver√° como <br>  r = 1 * a + 0 * b <br>  Porque  multiplicando por 0 da 0, entonces el resultado ser√° solo el valor de <b>a</b> . <br>  De lo contrario, si <b>c</b> es 0, <br>  r = 0 * a + 1 * b <br>  Y el resultado final ser√° <b>b</b> . <br></div></div><br>  Reescribe el color para el modo de <i>superposici√≥n</i> . <br><br><pre> <code class="hljs mel">fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>));</code> </pre> <br>  Aseg√∫rese de considerar la transparencia del sprite.  Para hacer esto, utilizaremos la interpolaci√≥n lineal entre los dos colores. <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a);</code> </pre> <br>  C√≥digo de sombreador de fragmento completo. <br><br><pre> <code class="hljs mel">fixed4 frag (v2f i) : SV_Target { fixed4 displPos = tex2D(_DisplacementTex, i.uv); float2 offset = (displPos.xy*<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; fixed4 texColor = tex2D(_MainTex, i.uv + offset)*i.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = tex2D (_GrabTexture, i.grabPos.xy + offset); fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * (<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor) + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre> <br>  Y el resultado de nuestro trabajo. <br><br><img src="https://habrastorage.org/webt/ea/au/xy/eaauxypqmxxrbcjrkl4swnctjeg.gif"><br><br><h3>  Caracter√≠stica GrabPass </h3><br>  Se mencion√≥ anteriormente que el pase <i>GrabPass {}</i> captura el contenido de la pantalla en una textura <i>_GrabTexture</i> .  Al mismo tiempo, cada vez que se llama a este pasaje, se actualizar√° el contenido de la textura. <br>  La actualizaci√≥n constante se puede evitar especificando el nombre de la textura en la que se capturar√° el contenido de la pantalla. <br><pre> <code class="hljs objectivec">GrabPass{<span class="hljs-string"><span class="hljs-string">"_DisplacementGrabTexture"</span></span>}</code> </pre> <br>  Ahora el contenido de la textura se actualizar√° solo en la primera llamada del pase GrabPass por fotograma.  Esto ahorra recursos si hay <i>muchos</i> objetos usando <i>GrabPass {}</i> .  Pero si dos objetos se superponen, los artefactos ser√°n notables, ya que ambos objetos usar√°n la misma imagen. <br><br>  Usando GrabPass {"_ DisplacementGrabTexture"}. <br><br><img src="https://habrastorage.org/webt/9n/uv/n9/9nuvn9st0v_t9l7rwxspbmy8iww.jpeg"><br><br>  Usando GrabPass {}. <br><br><img src="https://habrastorage.org/webt/sl/ai/4a/slai4akjk0suyfp43gptuyp3pfw.jpeg"><br><br><h2>  Animaci√≥n </h2><br>  Ahora es tiempo de animar nuestro efecto.  Queremos reducir suavemente la fuerza de distorsi√≥n a medida que crece la onda expansiva, simulando su extinci√≥n.  Para hacer esto, necesitamos cambiar las propiedades del material. <br><br><div class="spoiler">  <b class="spoiler_title">Gui√≥n para animaci√≥n</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wave</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _elapsedTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SpriteRenderer _renderer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Duration; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve ScaleProgress; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 ScalePower; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve PropertyProgress; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PropertyPower; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AnimationCurve AlphaProgress; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _renderer = GetComponent&lt;SpriteRenderer&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _elapsedTime = <span class="hljs-number"><span class="hljs-number">0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_elapsedTime &lt; Duration) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> progress = _elapsedTime / Duration; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scale = ScaleProgress.Evaluate(progress) * ScalePower; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property = PropertyProgress.Evaluate(progress) * PropertyPower; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> alpha = AlphaProgress.Evaluate(progress); transform.localScale = scale; _renderer.material.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = _renderer.color; color.a = alpha; _renderer.color = color; _elapsedTime += Time.deltaTime; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _elapsedTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Y su configuraci√≥n</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/cs/sm/9f/cssm9fqvoequsovfl8wlff72rxu.jpeg"><br></div></div><br>  El resultado de la animaci√≥n. <br><br><img src="https://habrastorage.org/webt/5j/sm/ic/5jsmicvf7jepmp-adecch-jlwb8.gif"><br><br><h2>  Perrendererdata </h2><br>  Presta atenci√≥n a la l√≠nea de abajo. <br><br><pre> <code class="cs hljs">_renderer.material.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property);</code> </pre> <br>  Aqu√≠ no solo estamos cambiando una de las propiedades del material, sino que estamos creando una copia del material fuente (solo en la primera llamada de este m√©todo) y ya estamos trabajando con √©l.  Es una opci√≥n bastante funcional, pero si hay m√°s de un objeto en el escenario, por ejemplo, mil, entonces crear tantas copias no conducir√° a nada bueno.  Hay una mejor opci√≥n: utilizar el atributo <i>[PerRendererData]</i> en el sombreador y el objeto <i>MaterialPropertyBlock</i> en el script. <br><br>  Para hacer esto, agregue un atributo a la propiedad <i>_DisplacementPower</i> en el sombreador. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplacementPower</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Displacement Power"</span></span> , Range(-.<span class="hljs-number"><span class="hljs-number">1</span></span>,.<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Despu√©s de eso, la propiedad ya no se mostrar√° en el inspector, porque  Ahora es individual para cada objeto, que establecer√° los valores. <br><br><img src="https://habrastorage.org/webt/ni/g4/zu/nig4zujdlflr1xjm_ry-cwulane.jpeg"><br><br>  Volvemos al gui√≥n y le hacemos cambios. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MaterialPropertyBlock _propertyBlock; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _renderer = GetComponent&lt;SpriteRenderer&gt;(); _propertyBlock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialPropertyBlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//_renderer.material.SetFloat("_DisplacementPower", property); _renderer.GetPropertyBlock(_propertyBlock); _propertyBlock.SetFloat("_DisplacementPower", property); _renderer.SetPropertyBlock(_propertyBlock); ... }</span></span></code> </pre> <br>  Ahora, para cambiar la propiedad, actualizaremos el <i>MaterialPropertyBlock</i> de nuestro objeto sin crear copias del material. <br><br><div class="spoiler">  <b class="spoiler_title">Sobre SpriteRenderer</b> <div class="spoiler_text">  Veamos esta l√≠nea en el sombreador. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-function">[</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">PerRendererData</span></span></span><span class="hljs-function">] _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainTex</span></span></span></span> (<span class="hljs-string"><span class="hljs-string">"Main Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {}</code> </pre> <br>  <i>SpriteRenderer funciona de</i> manera similar con los sprites.  Establece la propiedad <i>_MainTex</i> en <i>su</i> valor utilizando <i>MaterialPropertyBlock</i> .  Por lo tanto, en el inspector, la propiedad <i>_MainTex</i> no se muestra para el material, y en el componente <i>SpriteRenderer</i> especificamos la textura que necesitamos.  Al mismo tiempo, puede haber muchos sprites diferentes en el escenario, pero solo se usar√° un material para su representaci√≥n (si no lo cambia usted mismo). <br></div></div><br><h3>  PerRendererData Feature </h3><br>  Puede obtener <i>MaterialPropertyBlock</i> de casi todos los componentes relacionados con el render.  Por ejemplo, <i>SpriteRenderer</i> , <i>ParticleRenderer</i> , <i>MeshRenderer</i> y otros componentes de <i>Renderer</i> .  Pero siempre hay una excepci√≥n, este es un <i>CanvasRenderer</i> .  Es imposible obtener y cambiar propiedades usando este m√©todo.  Por lo tanto, si escribe un juego en 2D utilizando componentes de la interfaz de usuario, encontrar√° este problema al escribir sombreadores. <br><br><h2>  Rotaci√≥n </h2><br>  Se produce un efecto desagradable cuando se gira la imagen.  En el ejemplo de una ola redonda, esto es especialmente notable. <br><br>  La onda derecha al girar (90 grados) produce otra distorsi√≥n. <br><br><img src="https://habrastorage.org/webt/ns/gy/2e/nsgy2effgwcv8d0kavaltwd2ofi.jpeg"><br><br>  El rojo indica los vectores obtenidos del mismo punto en la textura, pero con una rotaci√≥n diferente de esta textura.  El valor de compensaci√≥n sigue siendo el mismo y no tiene en cuenta la rotaci√≥n. <br><br>  Para resolver este problema, utilizaremos la <i>matriz de</i> transformaci√≥n <i>unity_ObjectToWorld</i> .  Ayudar√° a contar nuestro vector desde coordenadas locales a coordenadas mundiales. <br><br><pre> <code class="hljs pgsql">float2 <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = (displPos.xy*<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> = mul( unity_ObjectToWorld, <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>);</code> </pre> <br>  Pero la matriz tambi√©n contiene datos sobre la escala del objeto, por lo que al especificar la fuerza de la distorsi√≥n, debemos tener en cuenta la escala del objeto en s√≠. <br><br><pre> <code class="cs hljs">_propertyBlock.SetFloat(<span class="hljs-string"><span class="hljs-string">"_DisplacementPower"</span></span>, property/transform.localScale.x);</code> </pre> <br>  La onda derecha tambi√©n gira 90 grados, pero la distorsi√≥n ahora se calcula correctamente. <br><br><img src="https://habrastorage.org/webt/g4/hc/gu/g4hcguat4nxvgm0b2jyylrqvlze.jpeg"><br><br><h2>  Clip </h2><br>  Nuestra textura tiene suficientes p√≠xeles transparentes (especialmente si usamos el tipo de malla <i>Rect</i> ).  El sombreador los procesa, lo que en este caso no tiene sentido.  Por lo tanto, intentaremos reducir la cantidad de c√°lculos innecesarios.  Podemos interrumpir el procesamiento de p√≠xeles transparentes utilizando el m√©todo <i>clip (x)</i> .  Si el par√°metro que se le pasa es menor que cero, el sombreador finalizar√°.  Pero como el valor alfa no puede ser menor que 0, restaremos un valor peque√±o de √©l.  Tambi√©n se puede poner en propiedades ( <i>Recorte</i> ) y usar para cortar las partes transparentes de la imagen.  En este caso, no necesitamos un par√°metro separado, por lo que solo usaremos el n√∫mero <b>0.01</b> . <br><br>  C√≥digo de sombreador de fragmento completo. <br><br><pre> <code class="hljs mel">fixed4 frag (v2f i) : SV_Target { fixed4 displPos = tex2D(_DisplacementTex, i.uv); float2 offset = (displPos.xy * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * _DisplacementPower * displPos.a; offset = mul( unity_ObjectToWorld,offset); fixed4 texColor = tex2D(_MainTex, i.uv + offset)*i.<span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">clip</span></span>(texColor.a - <span class="hljs-number"><span class="hljs-number">0.01</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> = tex2D (_GrabTexture, i.grabPos.xy + offset); fixed s = step(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); fixed4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = s * <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span> * texColor + (<span class="hljs-number"><span class="hljs-number">1</span></span> - s) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> - texColor) * (<span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = lerp(<span class="hljs-keyword"><span class="hljs-keyword">grabColor</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> ,texColor.a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre> <br>  PD: El c√≥digo fuente para el sombreador y el script es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace a git</a> .  El proyecto tambi√©n tiene un peque√±o generador de textura para distorsi√≥n.  El cristal con el pedestal fue tomado del activo - Kit de juego 2D. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427357/">https://habr.com/ru/post/es427357/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427347/index.html">Migraci√≥n a Google Cloud Platform (Google Cloud Platform - GCP)</a></li>
<li><a href="../es427349/index.html">Programador para la nueva familia tinyAVR basada en el convertidor chino CH340 barato</a></li>
<li><a href="../es427351/index.html">Semana de la seguridad 40: Vulnerabilidades en CMS Drupal y m√°s</a></li>
<li><a href="../es427353/index.html">Show de drones: c√≥mo coordinamos un enjambre de helic√≥pteros bailando</a></li>
<li><a href="../es427355/index.html">Compilaci√≥n de CJM, habilidades clave de director de arte y comprensi√≥n del usuario</a></li>
<li><a href="../es427359/index.html">C√≥mo ECS, C # Job System y SRP cambian la arquitectura</a></li>
<li><a href="../es427361/index.html">Caracter√≠sticas del filtrado de ventanas en FPGA</a></li>
<li><a href="../es427363/index.html">Implementaci√≥n de LoRaWAN en una empresa agr√≠cola. Todo sobre construcci√≥n, lanzamiento y soluciones.</a></li>
<li><a href="../es427365/index.html">Informe de RedSlerm sobre monitoreo (Monit, Zabbix)</a></li>
<li><a href="../es427367/index.html">SOMBRERO NEGRO Conferencia de Estados Unidos. C√≥mo un hacker de Hollywood usa c√°maras de vigilancia. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>