<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèæ ü§¢ üë©üèº‚Äçüåæ Faire de Tower Defense un jeu d'unit√© - Partie 2 üö£ üà∏ üíáüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit de la deuxi√®me partie du didacticiel ¬´Cr√©ation d'un jeu Tower Defense dans Unity¬ª . Nous cr√©ons un jeu de genre de tower defense dans Unity,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faire de Tower Defense un jeu d'unit√© - Partie 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413915/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png" alt="image"></div><br>  Il s'agit de la deuxi√®me partie du didacticiel <i>¬´Cr√©ation d'un jeu Tower Defense dans Unity¬ª</i> .  Nous cr√©ons un jeu de genre de tower defense dans Unity, et √† la fin de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie</a> , nous avons appris comment placer et am√©liorer des monstres.  Nous avons √©galement un ennemi qui attaque les cookies. <br><br>  Cependant, l'ennemi ne sait pas encore o√π chercher!  De plus, une attaque √† elle seule semble √©trange.  Dans cette partie du tutoriel, nous ajouterons des vagues d'ennemis et des monstres arm√©s afin qu'ils puissent d√©fendre un pr√©cieux cookie. <br><a name="habracut"></a><br><h2>  Se rendre au travail </h2><br>  Ouvrez le projet dans Unity, que nous avons arr√™t√© dans la derni√®re partie.  Si vous venez de nous rejoindre, t√©l√©chargez le <a href="">projet de projet</a> et ouvrez <em>TowerDefense-Part2-Starter</em> . <br><br>  Ouvrez <em>GameScene √†</em> partir du dossier <em>Scenes</em> . <br><br><h2>  Transformez vos ennemis </h2><br>  √Ä la fin du didacticiel pr√©c√©dent, l'ennemi a appris √† se d√©placer le long de la route, mais il semble qu'il ne sache pas o√π chercher. <br><br>  Ouvrez le script <em>MoveEnemy.cs</em> dans l'EDI et ajoutez-y la m√©thode suivante pour corriger la situation. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateIntoMoveDirection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 newStartPosition = waypoints [currentWaypoint].transform.position; Vector3 newEndPosition = waypoints [currentWaypoint + 1].transform.position; Vector3 newDirection = (newEndPosition - newStartPosition); //2 float x = newDirection.x; float y = newDirection.y; float rotationAngle = Mathf.Atan2 (y, x) * 180 / Mathf.PI; //3 GameObject sprite = gameObject.transform.Find("Sprite").gameObject; sprite.transform.rotation = Quaternion.AngleAxis(rotationAngle, Vector3.forward); }</span></span></code> </pre> <br>  <code>RotateIntoMoveDirection</code> fait tourner l'ennemi afin qu'il <code>RotateIntoMoveDirection</code> toujours vers l'avant.  Il le fait comme suit: <br><br><ol><li>  Calcule la direction actuelle du bug, en soustrayant la position du waypoint actuel de la position du point suivant. </li><li>  Utilise <code>Mathf.Atan2</code> pour d√©terminer l'angle en radians vers lequel <code>newDirection</code> dirig√© (le point z√©ro est √† droite).  Multiplie le r√©sultat par <code>180 / Mathf.PI</code> , convertissant l'angle en degr√©s. </li><li>  Enfin, il obtient l'enfant <em>Sprite</em> et fait pivoter les degr√©s d'axe <code>rotationAngle</code> .  Notez que nous faisons pivoter l' <i>enfant</i> , pas le parent, de sorte que la bande d'√©nergie que nous ajoutons plus tard reste horizontale. </li></ol><br>  Dans <code>Update()</code> , remplacez le commentaire <code>// TODO:    </code> prochain appel √† <code>RotateIntoMoveDirection</code> : <br><br><pre> <code class="cs hljs">RotateIntoMoveDirection();</code> </pre> <br>  Enregistrez le fichier et revenez √† Unity.  Ex√©cutez la sc√®ne;  maintenant l'ennemi sait o√π il va. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/7f4/9e5/73d7f49e5fec3785e2ac3376c3774f27.gif"></div><br>  Maintenant, le bug sait o√π il va. <br><br>  Le seul et unique ennemi n'a pas l'air tr√®s impressionnant.  Nous avons besoin de hordes!  Et comme dans tout jeu de tower defense, les hordes courent par vagues! <br><br><h2>  Informer le joueur </h2><br>  Avant de commencer √† d√©placer les hordes, nous devons avertir le joueur de la bataille imminente.  De plus, il vaut la peine d'afficher le num√©ro d'onde actuel en haut de l'√©cran. <br><br>  <em>Les</em> informations sur les <em>vagues</em> sont requises par plusieurs GameObjects, nous allons donc les ajouter au composant <em>GameManagerBehavior</em> du <em>GameManager</em> . <br><br>  Ouvrez <em>GameManagerBehavior.cs</em> dans l'EDI et ajoutez les deux variables suivantes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text waveLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] nextWaveLabels;</code> </pre> <br>  <code>waveLabel</code> stocke un lien vers l'√©tiquette de sortie du num√©ro d'onde dans le coin sup√©rieur droit de l'√©cran.  <code>nextWaveLabels</code> stocke deux GameObjects qui cr√©ent une combinaison d'animation que nous montrerons au d√©but d'une nouvelle vague: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/650/8f0/e7c6508f018c4382e490a4f6bee31e1f.gif"></div><br>  Enregistrez le fichier et revenez √† Unity.  S√©lectionnez <em>GameManager</em> dans la <em>hi√©rarchie</em> .  Cliquez sur le cercle √† droite de l' <em>√©tiquette Wave</em> et dans la bo√Æte de dialogue <em>Select Text</em> , s√©lectionnez <em>WaveLabel</em> dans l'onglet <em>Scene</em> . <br><br>  Maintenant, d√©finissez la <em>taille</em> des <em>√©tiquettes de vague suivante</em> sur <em>2</em> .  Maintenant, d√©finissez l' <em>√©l√©ment 0</em> sur <em>NextWaveBottomLabel</em> , et pour l' <em>√©l√©ment 1</em> <em>NextWaveTopLabel</em> est le m√™me que nous l'avons fait avec Wave Label. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/725/1f8/d197251f821c7262c638df487fb752cd.png"></div><br>  <i>Voici √† quoi devrait ressembler le comportement de Game Manager</i> <br><br>  Si le joueur perd, il ne devrait pas voir de message sur la prochaine vague.  Pour g√©rer cette situation, revenez √† <em>GameManagerBehavior.cs</em> et ajoutez une autre variable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> gameOver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Dans <code>gameOver</code> nous enregistrerons la valeur de la perte ou non du joueur. <br><br>  Ici, nous utilisons √† nouveau la propri√©t√© pour synchroniser les √©l√©ments du jeu avec la vague actuelle.  Ajoutez le code suivant √† <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wave; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Wave { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wave; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { wave = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gameOver) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nextWaveLabels.Length; i++) { nextWaveLabels[i].GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string"><span class="hljs-string">"nextWave"</span></span>); } } waveLabel.text = <span class="hljs-string"><span class="hljs-string">"WAVE: "</span></span> + (wave + <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br>  La cr√©ation d'une variable, d'une propri√©t√© et d'un getter priv√©s devrait d√©j√† vous √™tre famili√®re.  Mais avec le setter, encore une fois, tout est un peu plus int√©ressant. <br><br>  Nous attribuons √† <code>wave</code> nouvelle <code>value</code> . <br><br>  Ensuite, nous v√©rifions si le jeu est termin√©.  Sinon, parcourez toutes les √©tiquettes <em>nextWaveLabels</em> - ces √©tiquettes ont un composant <em>Animator</em> .  Pour activer l'animation <em>Animator</em> , nous <em>d√©finissons</em> un d√©clencheur <em>nextWave</em> . <br><br>  Enfin, nous d√©finissons le <code>text</code> de <code>waveLabel</code> sur <code>wave + 1</code> .  Pourquoi <code>+1</code> ?  Les gens ordinaires ne commencent pas √† compter √† partir de z√©ro (oui, c'est √©trange). <br><br>  Dans <code>Start()</code> d√©finissons la valeur de cette propri√©t√©: <br><br><pre> <code class="cs hljs">Wave = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Nous commen√ßons le compte avec le nombre <em>0</em> <code>Wave</code> . <br><br>  Enregistrez le fichier et ex√©cutez la sc√®ne dans Unity.  L'√©tiquette Wave affichera correctement 1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0d/edf/546/b0dedf546c1b6ad9b0d0b91c5021212d.png"></div><br>  <i>Pour un joueur, tout commence par la vague 1.</i> <br><br><h2>  Vagues: cr√©ez des tas d'ennemis </h2><br>  Cela peut sembler √©vident, mais pour attaquer avec une horde, il est n√©cessaire de cr√©er plus d'ennemis - alors que nous ne savons pas comment faire.  De plus, nous ne devons pas cr√©er la prochaine vague tant que la vague actuelle n'est pas d√©truite. <br><br>  Autrement dit, le jeu devrait √™tre capable de reconna√Ætre la pr√©sence d'ennemis dans la sc√®ne, et les <em>balises</em> sont un bon moyen d'identifier les objets du jeu ici. <br><br><h3>  Marquage des ennemis </h3><br>  S√©lectionnez le pr√©fabriqu√© <em>ennemi</em> dans l'arborescence du projet.  En haut de l' <em>inspecteur,</em> cliquez sur la liste d√©roulante <em>Tag</em> et s√©lectionnez <em>Ajouter un tag</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be0/7ea/b29/be07eab29a25c69751add67ce4faa283.png"></div><br>  Cr√©ez une <em>balise</em> appel√©e <em>Enemy</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/c66/d02/df1c66d02e0c29a7a6ec0b615dbbd2fc.png"></div><br>  S√©lectionnez l' <em>ennemi</em> pr√©fabriqu√©.  Dans l' <em>inspecteur,</em> d√©finissez-lui <em>la balise</em> <em>Enemy</em> . <br><br><h3>  D√©finir des vagues d'ennemis </h3><br>  Maintenant, nous devons d√©finir la vague d'ennemis.  Ouvrez <em>SpawnEnemy.cs</em> dans l'IDE et ajoutez l'impl√©mentation de classe suivante avant <code>SpawnEnemy</code> : <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wave</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject enemyPrefab; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnInterval = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxEnemies = <span class="hljs-number"><span class="hljs-number">20</span></span>; }</code> </pre> <br>  <em>La vague</em> contient le <code>enemyPrefab</code> - la base pour cr√©er des instances de tous les ennemis dans cette vague, <code>spawnInterval</code> - le temps entre les ennemis dans la vague en secondes et <code>maxEnemies</code> - le nombre d'ennemis cr√©√©s dans cette vague. <br><br>  La classe est <em>s√©rialisable</em> , c'est-√†-dire que nous pouvons modifier ses valeurs dans l'inspecteur. <br><br>  Ajoutez les variables suivantes √† la classe <code>SpawnEnemy</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Wave[] waves; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timeBetweenWaves = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastSpawnTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemiesSpawned = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Ici, nous d√©finissons les variables pour le frai des ennemis, ce qui est tr√®s similaire √† la fa√ßon dont nous avons d√©plac√© les ennemis entre les points sur la route. <br><br>  Nous d√©finissons les vagues d'ennemis individuels par <code>waves</code> et suivons le nombre d'ennemis cr√©√©s et l'heure √† laquelle ils ont √©t√© cr√©√©s dans <code>enemiesSpawned</code> et <code>lastSpawnTime</code> . <br><br>  Apr√®s toutes ces attaques, les joueurs ont besoin de temps pour respirer, alors r√©glez <code>timeBetweenWaves</code> sur 5 secondes. <br><br>  Remplacez le contenu de <code>Start()</code> code suivant. <br><br><pre> <code class="cs hljs">lastSpawnTime = Time.time; gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Ici, nous <code>lastSpawnTime</code> valeur de l'heure actuelle, c'est-√†-dire l'heure √† laquelle le script a d√©marr√© apr√®s le chargement de la sc√®ne.  Ensuite, nous obtenons le <code>GameManagerBehavior</code> d√©j√† familier. <br><br>  Ajoutez le code suivant √† <code>Update()</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 int currentWave = gameManager.Wave; if (currentWave &lt; waves.Length) { // 2 float timeInterval = Time.time - lastSpawnTime; float spawnInterval = waves[currentWave].spawnInterval; if (((enemiesSpawned == 0 &amp;&amp; timeInterval &gt; timeBetweenWaves) || timeInterval &gt; spawnInterval) &amp;&amp; enemiesSpawned &lt; waves[currentWave].maxEnemies) { // 3 lastSpawnTime = Time.time; GameObject newEnemy = (GameObject) Instantiate(waves[currentWave].enemyPrefab); newEnemy.GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints; enemiesSpawned++; } // 4 if (enemiesSpawned == waves[currentWave].maxEnemies &amp;&amp; GameObject.FindGameObjectWithTag("Enemy") == null) { gameManager.Wave++; gameManager.Gold = Mathf.RoundToInt(gameManager.Gold * 1.1f); enemiesSpawned = 0; lastSpawnTime = Time.time; } // 5 } else { gameManager.gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag ("GameWon"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); }</span></span></code> </pre> <br>  Analysons-le √©tape par √©tape: <br><br><ol><li>  Nous obtenons l'indice de la vague courante et v√©rifions si c'est la derni√®re. </li><li>  Si c'est le cas, nous calculons le temps √©coul√© apr√®s l'apparition pr√©c√©dente de l'ennemi et v√©rifions s'il est temps de cr√©er un ennemi.  Nous prenons ici en compte deux cas.  S'il s'agit du premier ennemi de la vague, nous v√©rifions si <code>timeInterval</code> est <code>timeInterval</code> √† <code>timeBetweenWaves</code> .  Sinon, nous v√©rifions si <code>timeInterval</code> est <code>timeInterval</code> aux vagues de <code>spawnInterval</code> .  En tout cas, on v√©rifie que nous n'avons pas cr√©√© tous les ennemis dans cette vague. </li><li>  Si n√©cessaire, <code>enemyPrefab</code> l'ennemi, cr√©ant ainsi une instance d' <code>enemyPrefab</code> .  Augmentez √©galement la valeur des <code>enemiesSpawned</code> . </li><li>  V√©rifiez le nombre d'ennemis √† l'√©cran.  S'ils ne sont pas l√† et que c'√©tait le dernier ennemi de la vague, alors nous cr√©ons la vague suivante.  Toujours √† la fin de la vague, nous donnons au joueur 10 pour cent de tout l'or restant. </li><li>  Apr√®s avoir vaincu la derni√®re vague, une animation de victoire dans le jeu est jou√©e ici. </li></ol><br><h3>  D√©finition des intervalles d'apparition </h3><br>  Enregistrez le fichier et revenez √† Unity.  S√©lectionnez l'objet <em>Route</em> dans la <em>hi√©rarchie</em> .  Dans l' <em>inspecteur,</em> d√©finissez la <em>taille</em> de l'objet <em>Waves</em> sur <em>4</em> . <br><br>  Pour l'instant, s√©lectionnez un objet <em>ennemi</em> pour les quatre √©l√©ments comme <em>pr√©fabriqu√© ennemi</em> .  Configurez les champs <em>Spawn Interval</em> et <em>Max Enemies</em> comme suit: <br><br><ul><li>  <em>√âl√©ment 0</em> : Intervalle d'apparition: <em>2,5</em> , nombre maximum d'ennemis: <em>5</em> </li><li>  <em>√âl√©ment 1</em> : Intervalle d'apparition: <em>2</em> , nombre maximum d'ennemis: <em>10</em> </li><li>  <em>√âl√©ment 2</em> : Intervalle d'apparition: <em>2</em> , nombre maximum d'ennemis: <em>15</em> </li><li>  <em>√âl√©ment 3</em> : Intervalle d'apparition: <em>1</em> , nombre maximum d'ennemis: <em>5</em> </li></ul><br>  Le sch√©ma fini devrait ressembler √† ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff7/0fa/954/ff70fa95476112b51dfb83505f9a785b.png"></div><br>  Bien s√ªr, vous pouvez exp√©rimenter ces valeurs pour augmenter ou diminuer la complexit√©. <br><br>  Lancez le jeu.  Ouais!  Les col√©opt√®res ont commenc√© le voyage vers votre cookie! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/097/4d3/a7f0974d36a188b5575a3e70a8488a4a.gif" alt="bugs"></div><br><h3>  T√¢che suppl√©mentaire: ajouter diff√©rents types d'ennemis </h3><br>  Aucun jeu de tower defense ne peut √™tre consid√©r√© comme complet avec un seul type d'ennemi.  Heureusement, il y a aussi <em>Enemy2</em> dans le dossier <em>Prefabs</em> . <br><br>  Dans l' <em>inspecteur,</em> s√©lectionnez <em>Prefabs \ Enemy2</em> et ajoutez-y le script <em>MoveEnemy</em> .  R√©glez la <em>vitesse</em> sur <em>3</em> et d√©finissez <em>la balise</em> <em>ennemie</em> .  Vous pouvez maintenant utiliser cet ennemi rapide pour que le joueur ne se d√©tende pas! <br><br><h2>  Mise √† jour de la vie du joueur </h2><br>  M√™me si des hordes d'ennemis attaquent le cookie, le joueur ne subit aucun d√©g√¢t.  Mais nous allons bient√¥t le r√©parer.  Le joueur doit souffrir s'il permet √† l'ennemi de se faufiler. <br><br>  Ouvrez <em>GameManagerBehavior.cs</em> dans l'EDI et ajoutez les deux variables suivantes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text healthLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] healthIndicator;</code> </pre> <br>  Nous utilisons <code>healthLabel</code> pour acc√©der √† la valeur vitale du joueur et <code>healthIndicator</code> pour acc√©der aux cinq petits monstres verts √† m√¢cher des biscuits - ils symbolisent simplement la sant√© du joueur;  c'est plus dr√¥le qu'un indicateur de sant√© standard. <br><br><h3>  Gestion de la sant√© </h3><br>  Ajoutez maintenant une propri√©t√© qui stocke la sant√© du joueur dans <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> health; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> health; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (value &lt; health) { Camera.main.GetComponent&lt;CameraShake&gt;().Shake(); } // 2 health = value; healthLabel.text = "HEALTH: " + health; // 3 if (health &lt;= 0 &amp;&amp; !gameOver) { gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag("GameOver"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); } // 4 for (int i = 0; i &lt; healthIndicator.Length; i++) { if (i &lt; Health) { healthIndicator[i].SetActive(true); } else { healthIndicator[i].SetActive(false); } } } }</span></span></code> </pre> <br>  C‚Äôest ainsi que nous g√©rons la sant√© du joueur.  Et encore une fois, la partie principale du code est situ√©e dans le setter: <br><br><ol><li>  Si nous r√©duisons la sant√© du joueur, nous utilisons le composant <code>CameraShake</code> pour cr√©er un bel effet de tremblement.  Ce script est inclus dans le projet t√©l√©chargeable et nous ne le consid√©rerons pas ici. </li><li>  Nous mettons √† jour la variable priv√©e et l'√©tiquette de sant√© dans le coin sup√©rieur gauche de l'√©cran. </li><li>  Si la sant√© est tomb√©e √† 0 et que la fin du jeu n'est pas encore arriv√©e, <code>gameOver</code> sur <code>true</code> et d√©marrez l'animation <code>gameOver</code> . </li><li>  Nous supprimons l'un des monstres des cookies.  Si nous les d√©sactivons, cette partie peut √™tre √©crite plus facilement, mais ici, nous soutenons la r√©insertion au cas o√π la sant√© serait ajout√©e. </li></ol><br>  Nous initialisons <code>Health</code> in <code>Start()</code> : <br><br><pre> <code class="cs hljs">Health = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br>  Nous avons r√©gl√© la <code>Health</code> √† <code>5</code> lorsque la sc√®ne commence √† jouer. <br><br>  Apr√®s avoir fait tout cela, nous pouvons maintenant mettre √† jour la sant√© du joueur lorsque le bug arrive dans le cookie.  Enregistrez le fichier et acc√©dez √† l'EDI dans le script <em>MoveEnemy.cs</em> . <br><br><h3>  Changement de sant√© </h3><br>  Pour changer votre sant√©, recherchez le commentaire dans <code>Update()</code> avec les mots <code>// TODO:  </code> et remplacez-le par ce code: <br><br><pre> <code class="cs hljs">GameManagerBehavior gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;(); gameManager.Health -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Nous obtenons donc le <code>GameManagerBehavior</code> et soustrayons l'unit√© de sa <code>Health</code> . <br><br>  Enregistrez le fichier et revenez √† Unity. <br><br>  S√©lectionnez un <em>GameManager</em> dans la <em>hi√©rarchie</em> et s√©lectionnez <em>HealthLabel</em> pour son <em>Health Label</em> . <br><br>  D√©veloppez l'objet <em>Cookie</em> dans la <em>hi√©rarchie</em> et faites glisser ses cinq enfants <em>HealthIndicators</em> dans le <em>tableau des indicateurs de sant√© de GameManager</em> - les indicateurs de sant√© seront de petits monstres verts mangeant des cookies. <br><br>  Ex√©cutez la sc√®ne et attendez que les bogues atteignent le cookie.  Ne faites rien jusqu'√† ce que vous perdiez. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/f4a/ea4/8d8f4aea4cec500c3894d233f402b7ba.gif" alt="attaque de cookie"></div><br><h2>  Monster Revenge </h2><br>  Des monstres en place?  Oui  Les ennemis attaquent-ils?  Oui, et ils ont l'air mena√ßant!  Il est temps de r√©pondre √† ces animaux! <br><br>  Pour ce faire, nous avons besoin des √©l√©ments suivants: <br><br><ul><li>  Ligne de sant√© pour que le joueur sache quels ennemis sont forts et lesquels sont faibles </li><li>  D√©tecter les ennemis √† port√©e d'un monstre </li><li>  Prendre une d√©cision - sur quel ennemi tirer </li><li>  Un tas de coquillages </li></ul><br><h3>  Barre de sant√© ennemie </h3><br>  Pour impl√©menter la bande de sant√©, nous utilisons deux images - une pour le fond sombre, et la seconde (la barre verte est l√©g√®rement plus petite) que nous mettrons √† l'√©chelle en fonction de la sant√© de l'ennemi. <br><br>  Faites glisser depuis l' <em>arborescence</em> du <em>projet</em> vers la sc√®ne <em>Prefabs \ Enemy</em> . <br><br>  Ensuite, dans la <em>hi√©rarchie,</em> faites glisser et d√©posez <em>Images \ Objects \ HealthBarBackground</em> sur <em>Enemy</em> pour l'ajouter en tant qu'enfant. <br><br>  Dans l' <em>inspecteur,</em> d√©finissez la <em>position du</em> <em>HealthBarBackground</em> sur <em>(0, 1, -4)</em> . <br><br>  Ensuite, dans l' <em>arborescence</em> du <em>projet,</em> s√©lectionnez <em>Images \ Objects \ HealthBar</em> et assurez-vous que son <em>pivot</em> est √† <em>gauche</em> .  Ajoutez-le ensuite en tant qu'enfant de l' <em>ennemi</em> dans la <em>hi√©rarchie</em> et d√©finissez sa valeur de <em>position</em> <em>(-0,63, 1, -5)</em> .  Pour l' <em>√©chelle</em> <em>X</em> <em>,</em> d√©finissez la valeur sur <em>125</em> . <br><br>  Ajoutez un nouveau script <em>C #</em> appel√© <em>HealthBar √† l'</em> objet de jeu <em>HealthBar</em> .  Plus tard, nous allons le changer pour qu'il change la longueur de la barre de sant√©. <br><br>  Apr√®s avoir s√©lectionn√© un objet <em>ennemi</em> dans la <em>hi√©rarchie</em> , assurez-vous que sa position est <em>(20, 0, 0)</em> . <br><br>  Cliquez sur <em>Appliquer</em> en haut de l' <em>inspecteur</em> pour enregistrer toutes les modifications dans le pr√©fabriqu√©.  Enfin, supprimez l'objet <em>ennemi</em> dans la <em>hi√©rarchie</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b84/7d2/9e7b847d22d2fda1e146dbf9149f912e.png"></div><br>  R√©p√©tez maintenant toutes ces √©tapes pour ajouter une barre de sant√© pour <em>Prefabs \ Enemy2</em> . <br><br><h3>  Modifier la longueur de la barre de vie </h3><br>  Ouvrez l'IDE <em>HealthBar.cs</em> et ajoutez les variables suivantes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> currentHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originalScale;</code> </pre> <br>  Dans <code>maxHealth</code> la sant√© maximale de l'ennemi est stock√©e, et dans <code>currentHealth</code> - la sant√© restante.  Enfin, dans <code>originalScale</code> est la taille initiale de la barre de sant√©. <br><br>  Enregistrez l'objet <code>originalScale</code> dans <code>Start()</code> : <br><br><pre> <code class="cs hljs">originalScale = gameObject.transform.localScale.x;</code> </pre> <br>  Nous stockons la valeur <code>x</code> de la propri√©t√© <code>localScale</code> . <br><br>  D√©finissez l'√©chelle de la barre d'int√©grit√© en ajoutant le code suivant √† <code>Update()</code> : <br><br><pre> <code class="cs hljs">Vector3 tmpScale = gameObject.transform.localScale; tmpScale.x = currentHealth / maxHealth * originalScale; gameObject.transform.localScale = tmpScale;</code> </pre> <br>  Nous pouvons copier <code>localScale</code> dans une variable temporaire car nous ne pouvons pas changer sa valeur <i>x</i> s√©par√©ment.  Ensuite, nous calculons la nouvelle √©chelle <i>x en</i> fonction de la sant√© actuelle du scarab√©e et <code>localScale</code> nouveau la valeur <code>localScale</code> √† une variable temporaire. <br><br>  Enregistrez le fichier et lancez le jeu dans Unity.  Au-dessus des ennemis, vous verrez des stries de sant√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png"></div><br>  Pendant le jeu, d√©veloppez l'un des objets <em>ennemis (clone)</em> dans la <em>hi√©rarchie</em> et s√©lectionnez son <em>HealthBar</em> enfant.  Modifiez sa valeur de <em>sant√© actuelle</em> et voyez comment sa barre de sant√© change. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ee/af7/22c/5eeaf722c2e6a6ee1d2799380cdcfead.gif"></div><br><h3>  D√©tection des ennemis √† port√©e </h3><br>  Maintenant, nos monstres doivent savoir quels ennemis viser.  Mais avant de r√©aliser cette opportunit√©, vous devez pr√©parer Monster et Enemy. <br><br>  S√©lectionnez Project Browser <em>Prefabs \ Monster</em> et ajoutez-y le composant <em>Circle Collider 2D</em> dans l' <em>inspecteur</em> . <br><br>  R√©glez le param√®tre <em>Rayon</em> du collisionneur sur <em>2,5</em> - cela indiquera le rayon d'attaque des monstres. <br><br>  Cochez la case <em>Est un d√©clencheur</em> pour que les objets passent √† travers cette zone plut√¥t que d'entrer en collision avec elle. <br><br>  Enfin, en haut de l' <em>inspecteur</em> , d√©finissez la <em>couche</em> du monstre sur <em>Ignorer Raycast</em> .  Dans la bo√Æte de dialogue, cliquez sur <em>Oui, modifiez les enfants</em> .  Si Ignorer Raycast n'est pas s√©lectionn√©, le collisionneur r√©pondra aux √©v√©nements de clic de souris.  Ce sera un probl√®me car les monstres bloquent les √©v√©nements destin√©s aux objets Openspot en dessous d'eux. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/302/cf2/e3e302cf21adee1433fe2183120c2ba1.png"></div><br>  Pour garantir que l'ennemi est d√©tect√© dans la zone de d√©clenchement, nous devons lui ajouter un collisionneur et un corps rigide, car Unity envoie uniquement des √©v√©nements de d√©clenchement lorsqu'un corps rigide est attach√© √† l'un des collisionneurs. <br><br>  Dans l' <em>arborescence du projet,</em> s√©lectionnez <em>Prefabs \ Enemy</em> .  Ajoutez le composant <em>Rigidbody 2D</em> et s√©lectionnez <em>Cin√©matique</em> pour le <em>type de corps</em> .  Cela signifie que le corps ne sera pas affect√© par la physique. <br><br>  Ajoutez <em>Circle Collider 2D</em> avec un <em>rayon</em> de <em>1</em> .  R√©p√©tez ces √©tapes pour <em>Prefabs \ Enemy 2</em> . <br><br>  Les d√©clencheurs sont configur√©s, de sorte que les monstres comprendront que les ennemis sont dans leur rayon d'action. <br><br>  Nous devons pr√©parer une derni√®re chose: un script indiquant aux monstres quand l'ennemi est d√©truit afin qu'ils ne l√®vent pas d'exception tout en continuant √† tirer. <br><br>  Cr√©ez un nouveau script <em>C #</em> appel√© <em>EnemyDestructionDelegate</em> et ajoutez-le aux <em>pr√©fabriqu√©s</em> <em>Enemy</em> et <em>Enemy2</em> . <br><br>  Ouvrez <em>EnemyDestructionDelegate.cs</em> dans l'IDE et ajoutez la d√©claration de d√©l√©gation suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject enemy</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyDelegate enemyDelegate;</code> </pre> <br>  Ici, nous cr√©ons un <code>delegate</code> , c'est-√†-dire un conteneur pour une fonction qui peut √™tre pass√©e en tant que variable. <br><br><blockquote>  <em>Remarque</em> : les d√©l√©gu√©s sont utilis√©s lorsqu'un objet de jeu doit notifier activement les autres objets de jeu des modifications.  En savoir plus sur les d√©l√©gu√©s dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="√† partir de la documentation Unity">documentation Unity</a> . </blockquote><br>  Ajoutez la m√©thode suivante: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enemyDelegate != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { enemyDelegate(gameObject); } }</code> </pre> <br>  Lorsqu'un objet de jeu est d√©truit, Unity appelle automatiquement cette m√©thode et v√©rifie que le d√©l√©gu√© <code>null</code> in√©galit√© <code>null</code> .  Dans notre cas, nous l'appelons avec <code>gameObject</code> comme param√®tre.  Cela permet √† tous les r√©pondants enregistr√©s comme d√©l√©gu√©s de savoir que l'ennemi est d√©truit. <br><br>  Enregistrez le fichier et revenez √† Unity. <br><br><h3>  Nous donnons aux monstres une licence pour tuer </h3><br>  Et maintenant, les monstres peuvent d√©tecter les ennemis dans le rayon de leur action.  Ajoutez un nouveau script <em>C #</em> au pr√©fabriqu√© <em>Monster</em> et nommez-le <em>ShootEnemies</em> . <br><br>  Ouvrez <em>ShootEnemies.cs</em> dans l'EDI et ajoutez-y la construction suivante pour acc√©der aux <code>Generics</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  Ajoutez une variable pour suivre tous les ennemis √† port√©e: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;GameObject&gt; enemiesInRange;</code> </pre> <br>  Dans <code>enemiesInRange</code> nous stockons tous les ennemis √† port√©e. <br><br>  Initialisez le champ dans <code>Start()</code> . <br><br><pre> <code class="cs hljs">enemiesInRange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameObject&gt;();</code> </pre> <br>  Au tout d√©but, il n'y a pas d'ennemis dans le rayon d'action, nous cr√©ons donc une liste vide. <br><br>  Remplissez la liste d' <code>enemiesInRange</code> !  Ajoutez le code suivant au script: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 void OnEnemyDestroy(GameObject enemy) { enemiesInRange.Remove (enemy); } void OnTriggerEnter2D (Collider2D other) { // 2 if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Add(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate += OnEnemyDestroy; } } // 3 void OnTriggerExit2D (Collider2D other) { if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Remove(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate -= OnEnemyDestroy; } }</span></span></code> </pre> <br><ol><li>  Dans <code>OnEnemyDestroy</code> nous <code>OnEnemyDestroy</code> l'ennemi de <code>enemiesInRange</code> .  Lorsqu'un ennemi marche sur un d√©clencheur autour d'un monstre, <code>OnTriggerEnter2D</code> est <code>OnTriggerEnter2D</code> . </li><li>  Ensuite, nous ajoutons l'ennemi √† la liste <code>enemiesInRange</code> et ajoutons l'√©v√©nement <code>OnEnemyDestroy</code> .  Nous garantissons donc que lors de la destruction de l'ennemi, <code>OnEnemyDestroy</code> sera appel√©.  Nous ne voulons pas que les monstres d√©pensent des munitions contre des ennemis morts, non? </li><li>  Dans <code>OnTriggerExit2D</code> nous <code>OnTriggerExit2D</code> l'ennemi de la liste et d√©senregistrons le d√©l√©gu√©.  Nous savons maintenant quels ennemis sont √† port√©e. </li></ol><br>  Enregistrez le fichier et lancez le jeu dans Unity.  Pour vous assurer que tout fonctionne, positionnez le monstre, s√©lectionnez-le et suivez les modifications dans la liste <code>enemiesInRange</code> dans l' <code>enemiesInRange</code> . <br><br><h3>  S√©lection cible </h3><br>  Les monstres savent d√©sormais quel ennemi est √† port√©e.  Mais que feront-ils quand il y aura plusieurs ennemis dans le rayon? <br><br>  Bien s√ªr, ils attaqueront celui le plus proche du foie! <br><br>  Ouvrez le <em>script</em> IDE <em>MoveEnemy.cs</em> et ajoutez une nouvelle m√©thode qui calcule ce monstre: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceToGoal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; distance += Vector2.Distance( gameObject.transform.position, waypoints [currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; waypoints.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { Vector3 startPosition = waypoints [i].transform.position; Vector3 endPosition = waypoints [i + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position; distance += Vector2.Distance(startPosition, endPosition); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; }</code> </pre> <br>  Le code calcule la longueur de chemin non encore parcourue par l'ennemi.  Pour ce faire, il utilise <code>Distance</code> , qui est calcul√©e comme la distance entre deux instances de <code>Vector3</code> . <br><br>  Nous utiliserons cette m√©thode plus tard pour d√©couvrir quelle cible attaquer.  Cependant, bien que nos monstres ne soient pas arm√©s et impuissants, nous le ferons d'abord. <br><br>  Enregistrez le fichier et revenez √† Unity pour commencer √† configurer vos shells. <br><br><h3>  Donnons des coquilles aux monstres.  Beaucoup de coquillages! </h3><br>  Faites glisser depuis l'arborescence du projet vers la sc√®ne <em>Images / Objets / Bullet1</em> .  R√©glez la position sur <em>z</em> √† <em>-2</em> - les positions sur x et y ne sont pas importantes, car nous les d√©finissons chaque fois que nous cr√©ons une nouvelle instance du projectile pendant l'ex√©cution du programme. <br><br>  Ajoutez un nouveau script <em>C #</em> appel√© <em>BulletBehavior</em> , puis dans l'EDI, ajoutez-y les variables suivantes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> damage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject target; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 startPosition; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 targetPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  <code>speed</code> d√©termine la vitesse des projectiles;  la <code>damage</code> claire d'apr√®s le nom. <br><br>  <code>target</code> , <code>startPosition</code> et <code>targetPosition</code> d√©terminent la direction du projectile. <br><br>  <code>distance</code> et <code>startTime</code> suivent la position actuelle du projectile.  <code>gameManager</code> r√©compense le joueur lorsqu'il tue l'ennemi. <br><br>  Attribuez les valeurs de ces variables dans <code>Start()</code> : <br><br><pre> <code class="cs hljs">startTime = Time.time; distance = Vector2.Distance (startPosition, targetPosition); GameObject gm = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>); gameManager = gm.GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br> <code>startTime</code>             . ,  ,  <code>GameManagerBehavior</code> . <br><br>       <code>Update()</code>  : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 float timeInterval = Time.time - startTime; gameObject.transform.position = Vector3.Lerp(startPosition, targetPosition, timeInterval * speed / distance); // 2 if (gameObject.transform.position.Equals(targetPosition)) { if (target != null) { // 3 Transform healthBarTransform = target.transform.Find("HealthBar"); HealthBar healthBar = healthBarTransform.gameObject.GetComponent&lt;HealthBar&gt;(); healthBar.currentHealth -= Mathf.Max(damage, 0); // 4 if (healthBar.currentHealth &lt;= 0) { Destroy(target); AudioSource audioSource = target.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); gameManager.Gold += 50; } } Destroy(gameObject); }</span></span></code> </pre> <br><ol><li>     ,  <code>Vector3.Lerp</code>       . </li><li>    <code>targetPosition</code> ,   ,    <code>target</code> . </li><li>    <code>HealthBar</code>        <code>damage</code> . </li><li>      ,    ,        . </li></ol><br>      Unity. <br><br><h3>    </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne serait-il pas formidable que le monstre commence √† tirer plus d'obus √† des niveaux √©lev√©s? Heureusement, cela est facile √† mettre en ≈ìuvre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faites glisser l'objet </font><font style="vertical-align: inherit;">de </font><font style="vertical-align: inherit;">jeu </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hi√©rarchie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vers l'onglet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour cr√©er un pr√©fabriqu√© de projectile. Retirez l'objet d'origine de la sc√®ne - nous n'en aurons plus besoin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dupliquez le pr√©fabriqu√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1 deux fois</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nommez les copies de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√©lectionnez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dans l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inspecteur,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©finissez le champ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite du</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> composant </font><em><font style="vertical-align: inherit;">Sprite </font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images / Objects / Bullet2</font></font></em> .    Bullet2  ,  Bullet1. <br><br>  ,     <em>Bullet3</em>  <em>Images/Objects/Bullet3</em> . <br><br>   <em>Bullet Behavior</em>    ,  . <br><br>    <em>Project</em>  <em>Bullet1</em> .  <em>Inspector</em>   <em>Bullet Behavior (Script)</em> ,     <em>Damage</em>  <em>10</em>  <em>Bullet1</em> , <em>15</em>  <em>Bullet2</em>  <em>20</em>  <em>Bullet3</em> ‚Äî    ,   . <br><br><blockquote> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : j'ai modifi√© les valeurs de sorte qu'√† des niveaux plus √©lev√©s, le prix des dommages augmente. </font><font style="vertical-align: inherit;">Cela emp√™che la mise √† niveau de permettre au joueur d'am√©liorer les monstres aux meilleurs points.</font></font></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/e2d/da2/c0ae2dda288d44bc380864dd1e85f3b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coques pr√©fabriqu√©es - la taille augmente avec le niveau</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer le niveau des obus </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez diff√©rents obus √† diff√©rents niveaux de monstres, afin que les monstres plus forts d√©truisent les ennemis plus rapidement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ouvrez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MonsterData.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans l'IDE </font><font style="vertical-align: inherit;">et ajoutez aux </font></font><code>MonsterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables suivantes:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject bullet; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fireRate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc r√©gl√© le pr√©fabriqu√© du projectile et la fr√©quence de tir pour chaque niveau de monstres. </font><font style="vertical-align: inherit;">Enregistrez le fichier et revenez √† Unity pour terminer la configuration du monstre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√©lectionnez le pr√©fabriqu√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monster</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans Project Browser </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans l' </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inspecteur,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©veloppez </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Niveaux</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le composant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monster Data (Script)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">R√©glez la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cadence de tir de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque √©l√©ment sur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">D√©finissez</font></em><font style="vertical-align: inherit;"> ensuite le param√®tre </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des √©l√©ments 0, 1 et 2 sur </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les niveaux des monstres doivent √™tre d√©finis comme suit:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c0/7d0/fd9/8c07d0fd96492f9e0e6c6e1737791c11.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les obus tuent les ennemis? </font><font style="vertical-align: inherit;">Oui! </font><font style="vertical-align: inherit;">Ouvrons le feu!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feu ouvert </font></font></h3><br>   IDE <em>ShootEnemies.cs</em>    : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastShotTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterData monsterData;</code> </pre> <br>    ,       ,    <code>MonsterData</code> ,       ,     . <br><br>      <code>Start()</code> : <br><br><pre> <code class="cs hljs">lastShotTime = Time.time; monsterData = gameObject.GetComponentInChildren&lt;MonsterData&gt;();</code> </pre> <br>    <code>lastShotTime</code>         <code>MonsterData</code>  . <br><br>   ,   : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D target</span></span></span><span class="hljs-function">)</span></span> { GameObject bulletPrefab = monsterData.CurrentLevel.bullet; <span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = gameObject.transform.position; Vector3 targetPosition = target.transform.position; startPosition.z = bulletPrefab.transform.position.z; targetPosition.z = bulletPrefab.transform.position.z; // 2 GameObject newBullet = (GameObject)Instantiate (bulletPrefab); newBullet.transform.position = startPosition; BulletBehavior bulletComp = newBullet.GetComponent&lt;BulletBehavior&gt;(); bulletComp.target = target.gameObject; bulletComp.startPosition = startPosition; bulletComp.targetPosition = targetPosition; // 3 Animator animator = monsterData.CurrentLevel.visualization.GetComponent&lt;Animator&gt;(); animator.SetTrigger("fireShot"); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); }</span></span></code> </pre> <br><ol><li>      .   z  z <code>bulletPrefab</code> .        z  ,      ,   . </li><li>       <code>bulletPrefab</code>  <code>MonsterLevel</code> .  <code>startPosition</code>  <code>targetPosition</code> . </li><li>   :   ,       . </li></ol><br><h3>    </h3><br>    .     ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c5/934/9a7/3c59349a719669c9508c38f155bf25dc.png"></div><br>   <em>ShootEnemies.cs</em>   <code>Update()</code>  : <br><br><pre> <code class="cs hljs">GameObject target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 float minimalEnemyDistance = float.MaxValue; foreach (GameObject enemy in enemiesInRange) { float distanceToGoal = enemy.GetComponent&lt;MoveEnemy&gt;().DistanceToGoal(); if (distanceToGoal &lt; minimalEnemyDistance) { target = enemy; minimalEnemyDistance = distanceToGoal; } } // 2 if (target != null) { if (Time.time - lastShotTime &gt; monsterData.CurrentLevel.fireRate) { Shoot(target.GetComponent&lt;Collider2D&gt;()); lastShotTime = Time.time; } // 3 Vector3 direction = gameObject.transform.position - target.transform.position; gameObject.transform.rotation = Quaternion.AngleAxis( Mathf.Atan2 (direction.y, direction.x) * 180 / Mathf.PI, new Vector3 (0, 0, 1)); }</span></span></code> </pre> <br>      . <br><br><ol><li>   .       <code>minimalEnemyDistance</code> .             ,        . </li><li>  <code>Shoot</code> ,          <code>lastShotTime</code>   . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous calculons l'angle de rotation entre le monstre et sa cible. </font><font style="vertical-align: inherit;">Nous faisons tourner le monstre √† cet angle. </font><font style="vertical-align: inherit;">Maintenant, il regardera toujours la cible.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrez le fichier et lancez le jeu dans Unity. </font><font style="vertical-align: inherit;">Les monstres commenceront d√©sesp√©r√©ment √† prot√©ger les cookies. </font><font style="vertical-align: inherit;">Nous avons enfin termin√©!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O√π aller ensuite </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le projet termin√© peut √™tre t√©l√©charg√© </font></font><a href="" title="here"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons fait un excellent travail dans ce tutoriel et maintenant nous avons un excellent jeu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici quelques id√©es pour poursuivre le d√©veloppement du projet:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus de types d'ennemis et de monstres </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diff√©rentes routes d'ennemis </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diff√©rents niveaux de jeu </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chacun de ces aspects n√©cessitera des modifications minimes et peut rendre le jeu plus amusant. </font><font style="vertical-align: inherit;">Si vous cr√©ez un nouveau jeu bas√© sur ce didacticiel, je serai heureux de le jouer, veuillez donc partager un lien vers celui-ci. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des pens√©es int√©ressantes sur la cr√©ation d'un jeu √† succ√®s de tower defense peuvent √™tre trouv√©es dans cette </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Making a Hit Tower Defense Game: A Top App Dev Interview"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interview</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413915/">https://habr.com/ru/post/fr413915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413901/index.html">Contr√¥le du robot auto-√©quilibr√© EduMip √† l'aide du joystick PS4 Dualshock 4 via ROS</a></li>
<li><a href="../fr413903/index.html">Comment Cambridge Analytica transforme les clics en voix</a></li>
<li><a href="../fr413907/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 256 (4 juin - 12 juin)</a></li>
<li><a href="../fr413909/index.html">C'est l√† que tes souvenirs d'enfance sont all√©s</a></li>
<li><a href="../fr413913/index.html">Connaissance des expositions d'√©quipements audio et vid√©o: bref sur les plus grands √©v√©nements - premi√®re partie</a></li>
<li><a href="../fr413917/index.html">Les titulaires de droits d'auteur croient que Yandex contribue √† la croissance du piratage dans le pays</a></li>
<li><a href="../fr413921/index.html">Comment sauver le projet de livres suppl√©mentaires</a></li>
<li><a href="../fr413923/index.html">Peut-√™tre que l'atmosph√®re peut encore √™tre nettoy√©e du dioxyde de carbone</a></li>
<li><a href="../fr413925/index.html">CVT pour Moskvich</a></li>
<li><a href="../fr413927/index.html">Digispark sur Attiny85 - Connexion sous Windows 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>