<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏾 ✌🏼 ✋🏿 Funktionales Denken. Teil 3 🖱️ 🎋 👩🏾‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der dritte Teil einer Reihe von Artikeln zur funktionalen Programmierung ist erschienen. Heute werden wir über alle Arten dieses Paradigmas sprechen u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales Denken. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/422115/"><p>  Der dritte Teil einer Reihe von Artikeln zur funktionalen Programmierung ist erschienen.  Heute werden wir über alle Arten dieses Paradigmas sprechen und Beispiele für ihre Verwendung zeigen.  Weitere Informationen zu primitiven Typen, verallgemeinerten Typen und vielem mehr unter dem Schnitt! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Teil</a></strong> </li></ul><br><p>  Nachdem wir die Funktionen verstanden haben, werden wir sehen, wie Typen mit Funktionen wie Domäne und Bereich interagieren.  Dieser Artikel ist nur eine Überprüfung.  Für ein tieferes Eintauchen in Typen gibt es eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"F # -Typen verstehen"</a> . </p><br><p> Zu Beginn benötigen wir ein etwas besseres Verständnis der Typennotation.  Wir haben die Pfeilnotation " <code>-&gt;</code> " gesehen, die Domäne und Bereich trennt.  Die Funktionssignatur sieht also immer so aus: </p><br><pre> <code class="plaintext hljs">val functionName : domain -&gt; range</code> </pre> <br><p>  Einige weitere Beispiele für Funktionen: </p><br><pre> <code class="plaintext hljs">let intToString x = sprintf "x is %i" x //  int  string let stringToInt x = System.Int32.Parse(x)</code> </pre> <br><p>  Wenn Sie diesen Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem interaktiven Fenster</a> ausführen, werden die folgenden Signaturen angezeigt: </p><br><pre> <code class="plaintext hljs">val intToString : int -&gt; string val stringToInt : string -&gt; int</code> </pre> <br><p>  Sie bedeuten: </p><br><ul><li>  <code>intToString</code> hat eine Domäne vom Typ <code>int</code> , die dem Bereich der <code>intToString</code> ist. </li><li>  <code>stringToInt</code> verfügt über eine Domäne vom Typ <code>string</code> , die einem Bereich vom Typ <code>int</code> . </li></ul><br><h2>  Primitive Typen </h2><br><p>  Es werden erwartete primitive Typen erwartet: Zeichenfolge, int, float, bool, char, byte usw. sowie viele andere Ableitungen des .NET-Typsystems. </p><br><p>  Einige weitere Beispiele für Funktionen mit primitiven Typen: </p><br><pre> <code class="plaintext hljs">let intToFloat x = float x // "float" -  int  float let intToBool x = (x = 2) // true  x  2 let stringToString x = x + " world"</code> </pre> <br><p>  und ihre Unterschriften: </p><br><pre> <code class="plaintext hljs">val intToFloat : int -&gt; float val intToBool : int -&gt; bool val stringToString : string -&gt; string</code> </pre> <br><h2>  Geben Sie Annotation ein </h2><br><p>  In den vorherigen Beispielen hat der F # -Compiler die Arten von Parametern und Ergebnissen korrekt definiert.  Dies ist jedoch nicht immer der Fall.  Wenn Sie versuchen, den folgenden Code auszuführen, wird ein Kompilierungsfehler angezeigt: </p><br><pre> <code class="plaintext hljs">let stringLength x = x.Length =&gt; error FS0072: Lookup on object of indeterminate type</code> </pre> <br><p>  Der Compiler kennt den Typ des Arguments "x" nicht und weiß daher nicht, ob die "Länge" eine gültige Methode ist.  In den meisten Fällen kann dies behoben werden, indem die "Typanmerkung" an den F # -Compiler übergeben wird.  Dann wird er wissen, welchen Typ er verwenden soll.  In der festen Version geben wir an, dass der Typ "x" eine Zeichenfolge ist. </p><br><pre> <code class="plaintext hljs">let stringLength (x:string) = x.Length</code> </pre> <br><p>  Die geschweiften Klammern um den Parameter <code>x:string</code> sind wichtig.  Wenn sie übersprungen werden, entscheidet der Compiler, dass die Zeichenfolge der Rückgabewert ist!  Das heißt, ein offener Doppelpunkt wird verwendet, um den Typ des Rückgabewerts anzugeben, wie im folgenden Beispiel gezeigt. </p><br><pre> <code class="plaintext hljs">let stringLengthAsInt (x:string) :int = x.Length</code> </pre> <br><p>  Wir geben an, dass der Parameter <code>x</code> eine Zeichenfolge und der Rückgabewert eine Ganzzahl ist. </p><br><h2>  Funktionstypen als Parameter </h2><br><p>  Eine Funktion, die andere Funktionen als Parameter verwendet oder eine Funktion zurückgibt, wird als Funktion <strong>höherer Ordnung bezeichnet</strong> ( <strong>Funktion höherer Ordnung wird</strong> manchmal auf HOF verkürzt).  Sie werden als Abstraktion verwendet, um ein möglichst allgemeines Verhalten festzulegen.  Diese Art von Funktion ist in F # sehr verbreitet, die meisten Standardbibliotheken verwenden sie. </p><br><p>  Betrachten Sie die Funktion <code>evalWith5ThenAdd2</code> , die eine Funktion als Parameter verwendet, diese Funktion dann aus 5 berechnet und dem Ergebnis 2 hinzufügt: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 + 2 //   ,   fn(5) + 2</code> </pre> <br><p>  Die Signatur dieser Funktion sieht folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  Sie können sehen, dass die Domäne <code>(int-&gt;int)</code> und der Bereich <code>int</code> .  Was bedeutet das?  Dies bedeutet, dass der Eingabeparameter kein einfacher Wert ist, sondern eine Funktion aus vielen Funktionen von <code>int</code> bis <code>int</code> .  Der Ausgabewert ist keine Funktion, sondern nur ein <code>int</code> . </p><br><p>  Versuchen wir mal: </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 //  -  (int -&gt; int) evalWith5ThenAdd2 add1 //  </code> </pre> <br><p>  und bekommen: </p><br><pre> <code class="plaintext hljs">val add1 : int -&gt; int val it : int = 8</code> </pre> <br><p>  " <code>add1</code> " ist eine Funktion, die <code>int</code> auf <code>int</code> abbildet, wie wir aus der Signatur sehen.  Es ist ein gültiger Parameter für <code>evalWith5ThenAdd2</code> und das Ergebnis ist 8. </p><br><p>  Das spezielle Wort " <code>it</code> " bezeichnet übrigens den zuletzt berechneten Wert. In diesem Fall ist es das Ergebnis, auf das wir gewartet haben.  Dies ist kein Schlüsselwort, sondern nur eine Namenskonvention. </p><br><p>  Ein anderer Fall: </p><br><pre> <code class="plaintext hljs">let times3 x = x * 3 // -  (int -&gt; int) evalWith5ThenAdd2 times3 //  </code> </pre> <br><p>  gibt: </p><br><pre> <code class="plaintext hljs">val times3 : int -&gt; int val it : int = 17</code> </pre> <br><p>  " <code>times3</code> " ist auch eine Funktion, die <code>int</code> auf <code>int</code> abbildet, wie aus der Signatur ersichtlich ist.  Es ist auch ein gültiger Parameter für <code>evalWith5ThenAdd2</code> .  Das Ergebnis der Berechnungen ist 17. </p><br><p>  Bitte beachten Sie, dass die Eingabedaten typabhängig sind.  Wenn die übergebene Funktion ein <code>float</code> und kein <code>int</code> , funktioniert nichts.  Zum Beispiel, wenn wir haben: </p><br><pre> <code class="plaintext hljs">let times3float x = x * 3.0 // -  (float-&gt;float) evalWith5ThenAdd2 times3float</code> </pre> <br><p>  Der Compiler gibt beim Kompilieren einen Fehler zurück: </p><br><pre> <code class="plaintext hljs">error FS0001: Type mismatch. Expecting a int -&gt; int but given a float -&gt; float</code> </pre> <br><p>  Meldung, dass die Eingabefunktion eine Funktion vom Typ <code>int-&gt;int</code> . </p><br><h3>  Funktioniert als Ausgabe </h3><br><p>  Wertfunktionen können auch das Ergebnis von Funktionen sein.  Die folgende Funktion generiert beispielsweise eine "Addierer" -Funktion, die einen Eingabewert hinzufügt. </p><br><pre> <code class="plaintext hljs">let adderGenerator numberToAdd = (+) numberToAdd</code> </pre> <br><p>  Ihre Unterschrift: </p><br><pre> <code class="plaintext hljs">val adderGenerator : int -&gt; (int -&gt; int)</code> </pre> <br><p>  bedeutet, dass der Generator ein <code>int</code> und eine Funktion ("Addierer") erstellt, die <code>ints</code> <code>ints</code> .  Mal sehen, wie es funktioniert: </p><br><pre> <code class="plaintext hljs">let add1 = adderGenerator 1 let add2 = adderGenerator 2</code> </pre> <br><p>  Es werden zwei Addiererfunktionen erstellt.  Die erste erstellt eine Funktion, die der Eingabe 1 hinzufügt, die zweite fügt 2 hinzu. Beachten Sie, dass die Signaturen genau den Erwartungen entsprechen. </p><br><pre> <code class="plaintext hljs">val add1 : (int -&gt; int) val add2 : (int -&gt; int)</code> </pre> <br><p>  Jetzt können Sie die generierten Funktionen wie gewohnt verwenden, sie unterscheiden sich nicht von den explizit definierten Funktionen: </p><br><pre> <code class="plaintext hljs">add1 5 // val it : int = 6 add2 5 // val it : int = 7</code> </pre> <br><h3>  Verwenden von Typanmerkungen zum Einschränken von Funktionstypen </h3><br><p>  Im ersten Beispiel haben wir uns eine Funktion angesehen: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 +2 &gt; val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  In diesem Beispiel kann F # schließen, dass " <code>fn</code> " <code>int</code> in <code>int</code> konvertiert, sodass seine Signatur <code>int-&gt;int</code> . </p><br><p>  Aber wie lautet die Signatur von "fn" im folgenden Fall? </p><br><pre> <code class="plaintext hljs">let evalWith5 fn = fn 5</code> </pre> <br><p>  Es ist klar, dass " <code>fn</code> " eine Art Funktion ist, die ein <code>int</code> , aber was gibt es zurück?  Der Compiler kann diese Frage nicht beantworten.  In solchen Fällen können Sie, wenn der Funktionstyp angegeben werden muss, einen Anmerkungstyp für Funktionsparameter sowie für primitive Typen hinzufügen. </p><br><pre> <code class="plaintext hljs">let evalWith5AsInt (fn:int-&gt;int) = fn 5 let evalWith5AsFloat (fn:int-&gt;float) = fn 5</code> </pre> <br><p>  Darüber hinaus können Sie den Rückgabetyp bestimmen. </p><br><pre> <code class="plaintext hljs">let evalWith5AsString fn :string = fn 5</code> </pre> <br><p>  Weil  Die Hauptfunktion gibt einen <code>string</code> , die Funktion " <code>fn</code> " muss ebenfalls einen <code>string</code> .  Daher ist es nicht erforderlich, den Typ " <code>fn</code> " explizit anzugeben. </p><br><h2>  Geben Sie "Einheit" ein </h2><br><p>  Während des Programmierprozesses möchten wir manchmal, dass eine Funktion etwas tut, ohne etwas zurückzugeben.  Betrachten Sie die Funktion " <code>printInt</code> ".  Die Funktion gibt wirklich nichts zurück.  Es druckt einfach die Zeichenfolge als Nebeneffekt der Ausführung auf die Konsole. </p><br><pre> <code class="plaintext hljs">let printInt x = printf "x is %i" x //   </code> </pre> <br><p>  Was ist ihre Unterschrift? </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  Was ist eine " <code>unit</code> "? </p><br><p>  Auch wenn die Funktion keine Werte zurückgibt, benötigt sie dennoch einen Bereich.  In der Welt der Mathematik gibt es keine "leeren" Funktionen.  Jede Funktion muss etwas zurückgeben, da die Funktion ein Mapping ist und das Mapping etwas anzeigen muss! </p><br><p><img src="https://habrastorage.org/webt/3_/vt/vz/3_vtvz11kud3aikskqhciwc_q1a.png"></p><br><p>  In F # geben Funktionen wie diese einen speziellen Ergebnistyp namens " <code>unit</code> " zurück.  Es enthält nur einen Wert, der mit " <code>()</code> " gekennzeichnet ist.  Sie könnten denken, dass <code>unit</code> und <code>()</code> so etwas wie "void" bzw. "null" von C # sind.  Aber im Gegensatz zu ihnen ist <code>unit</code> der reale Typ und <code>()</code> reale Wert.  Um dies zu überprüfen, gehen Sie einfach wie folgt vor: </p><br><pre> <code class="plaintext hljs">let whatIsThis = ()</code> </pre> <br><p>  Die folgende Unterschrift wird erhalten: </p><br><pre> <code class="plaintext hljs">val whatIsThis : unit = ()</code> </pre> <br><p>  <code>whatIsThis</code> zeigt an, dass die Bezeichnung " <code>whatIsThis</code> " vom Typ <code>unit</code> und einem Wert <code>()</code> . </p><br><p>  <code>printInt</code> wir nun zur " <code>printInt</code> " <code>printInt</code> zurückkehren, können wir die Bedeutung dieses Eintrags verstehen: </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  Diese Signatur besagt, dass <code>printInt</code> eine Domäne von <code>int</code> , was sich in etwas übersetzt, das uns nicht interessiert. </p><br><h3>  Funktionen ohne Parameter </h3><br><p>  Können wir, <code>unit</code> wir die <code>unit</code> , ihr Auftreten in einem anderen Kontext vorhersagen?  Versuchen Sie beispielsweise, eine wiederverwendbare Funktion "Hallo Welt" zu erstellen.  Da es keine Eingabe oder Ausgabe gibt, können wir die Signatureinheit <code>unit -&gt; unit</code> erwarten.  Mal sehen: </p><br><pre> <code class="plaintext hljs">let printHello = printf "hello world" //   </code> </pre> <br><p>  Ergebnis: </p><br><pre> <code class="plaintext hljs">hello world val printHello : unit = ()</code> </pre> <br><p>  <em>Nicht ganz das,</em> was wir erwartet hatten.  "Hallo Welt" wurde sofort ausgegeben und das Ergebnis war keine Funktion, sondern ein einfacher Wert vom Typ Einheit.  Wir können sagen, dass dies ein einfacher Wert ist, da er, wie wir zuvor gesehen haben, eine Signatur des Formulars hat: </p><br><pre> <code class="plaintext hljs">val aName: type = constant</code> </pre> <br><p>  In diesem Beispiel sehen wir, dass <code>printHello</code> wirklich ein <em>einfacher Wert ist</em> <code>()</code> .  Dies ist keine Funktion, die wir später aufrufen können. </p><br><p>  Was ist der Unterschied zwischen <code>printInt</code> und <code>printHello</code> ?  Im Fall von <code>printInt</code> Wert erst bestimmt werden, wenn wir den Wert des Parameters <code>x</code> . Die Definition war also eine Funktion.  Im Fall von <code>printHello</code> gibt es keine Parameter, so dass die rechte Seite an Ort und Stelle definiert werden kann.  Und es war gleich <code>()</code> mit einem Nebeneffekt in Form der Ausgabe an die Konsole. </p><br><p>  Sie können eine echte wiederverwendbare Funktion ohne Parameter erstellen und die Definition dazu zwingen, ein <code>unit</code> zu haben: </p><br><pre> <code class="plaintext hljs">let printHelloFn () = printf "hello world" //   </code> </pre> <br><p>  Jetzt ist ihre Unterschrift gleich: </p><br><pre> <code class="plaintext hljs">val printHelloFn : unit -&gt; unit</code> </pre> <br><p>  und um es aufzurufen, müssen wir <code>()</code> als Parameter übergeben: </p><br><pre> <code class="plaintext hljs">printHelloFn ()</code> </pre> <br><h3>  Verstärkung von Einheitentypen mit der Ignorierfunktion </h3><br><p>  In einigen Fällen benötigt der Compiler einen <code>unit</code> und beschwert sich.  Beispielsweise verursachen beide der folgenden Fälle einen Compilerfehler: </p><br><pre> <code class="plaintext hljs">do 1+1 // =&gt; FS0020: This expression should have type 'unit' let something = 2+2 // =&gt; FS0020: This expression should have type 'unit' "hello"</code> </pre> <br><p>  Um in diesen Situationen zu helfen, gibt es eine spezielle <code>ignore</code> , die alles übernimmt und die <code>unit</code> zurückgibt.  Die richtige Version dieses Codes könnte folgende sein: </p><br><pre> <code class="plaintext hljs">do (1+1 |&gt; ignore) // ok let something = 2+2 |&gt; ignore // ok "hello"</code> </pre> <br><h2>  Generische Typen </h2><br><p>  In den meisten Fällen müssen wir etwas dazu sagen, wenn der Typ eines Funktionsparameters ein beliebiger Typ sein kann.  F # verwendet für solche Situationen .NET-Generika. </p><br><p>  Die folgende Funktion konvertiert beispielsweise einen Parameter durch Hinzufügen von Text in eine Zeichenfolge: </p><br><pre> <code class="plaintext hljs">let onAStick x = x.ToString() + " on a stick"</code> </pre> <br><p>  <code>ToString()</code> von der Art des Parameters können alle Objekte in <code>ToString()</code> . </p><br><p>  Unterschrift: </p><br><pre> <code class="plaintext hljs">val onAStick : 'a -&gt; string</code> </pre> <br><p>  Welcher Typ <code>'a</code> ?  In F # ist dies eine Möglichkeit, einen generischen Typ anzugeben, der zur Kompilierungszeit unbekannt ist.  Ein Apostroph vor "a" bedeutet, dass der Typ generisch ist.  Entspricht dieser Signatur in C #: </p><br><pre> <code class="plaintext hljs">string onAStick&lt;a&gt;(); //   string OnAStick&lt;TObject&gt;(); // F#-   'a    // C#'-   "TObject"  </code> </pre> <br><p>  Es versteht sich, dass diese F # -Funktion auch bei generischen Typen eine starke Typisierung aufweist.  Es <em>wird kein</em> Parameter vom Typ <code>Object</code> akzeptiert.  Starkes Tippen ist gut, da Sie damit die Typensicherheit beim Erstellen von Funktionen beibehalten können. </p><br><p>  Die gleiche Funktion wird für <code>int</code> , <code>float</code> und <code>string</code> . </p><br><pre> <code class="plaintext hljs">onAStick 22 onAStick 3.14159 onAStick "hello"</code> </pre> <br><p>  Wenn es zwei verallgemeinerte Parameter gibt, gibt der Compiler ihnen zwei verschiedene Namen: <code>'a</code> für den ersten <code>'b</code> für den zweiten usw.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">let concatString xy = x.ToString() + y.ToString()</code> </pre> <br><p>  Diese Signatur enthält zwei generische Typen: <code>'a</code> und <code>'b</code> : </p><br><pre> <code class="plaintext hljs">val concatString : 'a -&gt; 'b -&gt; string</code> </pre> <br><p>  Andererseits erkennt der Compiler, wenn nur ein generischer Typ erforderlich ist.  Im folgenden Beispiel müssen <code>x</code> und <code>y</code> vom gleichen Typ sein: </p><br><pre> <code class="plaintext hljs">let isEqual xy = (x=y)</code> </pre> <br><p>  Eine Funktionssignatur hat also für beide Parameter denselben generischen Typ: </p><br><pre> <code class="plaintext hljs">val isEqual : 'a -&gt; 'a -&gt; bool</code> </pre> <br><p>  Verallgemeinerte Parameter sind auch sehr wichtig, wenn es um Listen und andere abstrakte Strukturen geht, und wir werden viele davon in den folgenden Beispielen sehen. </p><br><h2>  Andere Arten </h2><br><p>  Bisher wurden nur Grundtypen diskutiert.  Diese Typen können auf verschiedene Weise zu komplexeren Typen kombiniert werden.  Ihre vollständige Analyse wird später in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anderen Reihe erfolgen</a> , aber in der Zwischenzeit werden wir sie hier kurz analysieren, damit Sie sie in den Signaturen von Funktionen erkennen können. </p><br><ul><li>  <strong>Tupel</strong>  Dies ist ein Paar, ein Tripel usw., das aus anderen Typen besteht.  Zum Beispiel ist <code>("hello", 1)</code> ein Tupel, das auf <code>string</code> und <code>int</code> basiert.  Ein Komma ist ein Kennzeichen von Tupeln. Wenn irgendwo in F # ein Komma angezeigt wird, ist dies fast garantiert Teil des Tupels. <br>  In Funktionssignaturen werden Tupel als „Produkte“ der beiden beteiligten Typen geschrieben.  In diesem Fall ist das Tupel vom Typ: </li></ul><br><pre> <code class="plaintext hljs">string * int // ("hello", 1)</code> </pre> <br><ul><li>  <strong>Sammlungen</strong> .  Die häufigsten sind list (list), seq (sequence) und array.  Listen und Arrays haben eine feste Größe, während Sequenzen möglicherweise unendlich sind (hinter den Kulissen sind Sequenzen dieselbe <code>IEnumrable</code> ).  In Funktionssignaturen haben sie ihre eigenen Schlüsselwörter: " <code>list</code> ", " <code>seq</code> " und " <code>[]</code> " für Arrays. </li></ul><br><pre> <code class="plaintext hljs">int list // List type  [1;2;3] string list // List type  ["a";"b";"c"] seq&lt;int&gt; // Seq type  seq{1..10} int [] // Array type  [|1;2;3|]</code> </pre> <br><ul><li>  <strong>Option (optionaler Typ)</strong> .  Dies ist ein einfacher Wrapper über Objekte, die möglicherweise fehlen.  Es gibt zwei Optionen: <code>Some</code> (wenn der Wert vorhanden ist) und <code>None</code> (wenn der Wert nicht vorhanden ist).  In Funktionssignaturen haben sie ein eigenes Schlüsselwort " <code>option</code> ": </li></ul><br><pre> <code class="plaintext hljs">int option // Some 1</code> </pre> <br><ul><li>  <strong>Die markierte Assoziation (diskriminierte Gewerkschaft)</strong> .  Sie bestehen aus vielen Variationen anderer Typen.  Wir haben einige Beispiele in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Warum F # verwenden?"</a>  .  In Funktionssignaturen werden sie nach Typnamen referenziert, sie haben kein spezielles Schlüsselwort. </li><li>  <strong>Datensatztyp (Datensätze)</strong> .  Typen wie Datenbankstrukturen oder Zeilen, eine Reihe benannter Werte.  Wir haben auch einige Beispiele in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Warum F # verwenden?"</a>  .  In Funktionssignaturen werden sie nach Typnamen aufgerufen und haben auch kein eigenes Schlüsselwort. </li></ul><br><h2>  Testen Sie Ihr Verständnis von Typen </h2><br><p>  Hier sind einige Ausdrücke, um Ihr Verständnis von Funktionssignaturen zu testen.  Um dies zu überprüfen, führen Sie sie einfach in einem interaktiven Fenster aus! </p><br><pre> <code class="plaintext hljs">let testA = float 2 let testB x = float 2 let testC x = float 2 + x let testD x = x.ToString().Length let testE (x:float) = x.ToString().Length let testF x = printfn "%s" x let testG x = printfn "%f" x let testH = 2 * 2 |&gt; ignore let testI x = 2 * 2 |&gt; ignore let testJ (x:int) = 2 * 2 |&gt; ignore let testK = "hello" let testL() = "hello" let testM x = x=x let testN x = x 1 // :     x? let testO x:string = x 1 // :    :string ?</code> </pre> <br><h1>  Zusätzliche Ressourcen </h1><br><p>  Es gibt viele Tutorials für F #, einschließlich Materialien für diejenigen, die mit C # oder Java-Erfahrung kommen.  Die folgenden Links können hilfreich sein, wenn Sie tiefer in F # einsteigen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Anleitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # für Spaß und Profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne X in Y Minuten: F #</a> </li></ul><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> auch verschiedene andere Möglichkeiten beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um mit dem Lernen von F # zu beginnen</a> . </p><br><p>  Schließlich ist die F # Community sehr anfängerfreundlich.  Bei Slack gibt es einen sehr aktiven Chat, der von der F # Software Foundation unterstützt wird, mit Anfängerräumen, an denen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei teilnehmen können</a> .  Wir empfehlen Ihnen dringend, dies zu tun! </p><br><p>  Vergessen Sie nicht, die Seite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community F #</a> zu besuchen!  Wenn Sie Fragen zum Erlernen einer Sprache haben, diskutieren wir diese gerne in Chatrooms: </p><br><ul><li>  Raum <code>#ru_general</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Telegramm chatten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatte in gitter</a> </li></ul><br><h2>  Über Übersetzungsautoren </h2><br><p>  Übersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Übersetzungs- und redaktionelle Änderungen wurden durch die Bemühungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community von F # -Entwicklern vorgenommen</a> .  Wir danken auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@schvepsss</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@shwars</em></a> für die Vorbereitung dieses Artikels zur Veröffentlichung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422115/">https://habr.com/ru/post/de422115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422099/index.html">Große Betreiber verdienen das "Frühlingsgesetz", indem sie kleinen Betreibern Hosting-Dienste anbieten</a></li>
<li><a href="../de422103/index.html">Warum ein Programmierer gut schreiben kann</a></li>
<li><a href="../de422107/index.html">Skalierung der Entwicklung: vom Start bis zu Hunderten von Ingenieuren</a></li>
<li><a href="../de422109/index.html">Firefox blockiert standardmäßig die Benutzerverfolgung</a></li>
<li><a href="../de422113/index.html">Fintech Digest: Die Zentralbank wird die Opfer von Hackern im Auge behalten, die Russen erhalten eine Bonität, Yahoo Finance und Krypto-Handel</a></li>
<li><a href="../de422119/index.html">Indie Game Developer Toolkit</a></li>
<li><a href="../de422121/index.html">Wie man nach Deutschland geht, um am Beispiel meiner Auswanderung zu studieren und zu arbeiten</a></li>
<li><a href="../de422123/index.html">So stoppen Sie den Ausfall und führen normale Rückblenden durch</a></li>
<li><a href="../de422125/index.html">SENS-Diagnose. Proteinaggregat-Biomarker</a></li>
<li><a href="../de422127/index.html">Zum Teufel mit der Vernunft. Manchmal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>