<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèæ ‚úåüèº ‚úãüèø Funktionales Denken. Teil 3 üñ±Ô∏è üéã üë©üèæ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der dritte Teil einer Reihe von Artikeln zur funktionalen Programmierung ist erschienen. Heute werden wir √ºber alle Arten dieses Paradigmas sprechen u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionales Denken. Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/422115/"><p>  Der dritte Teil einer Reihe von Artikeln zur funktionalen Programmierung ist erschienen.  Heute werden wir √ºber alle Arten dieses Paradigmas sprechen und Beispiele f√ºr ihre Verwendung zeigen.  Weitere Informationen zu primitiven Typen, verallgemeinerten Typen und vielem mehr unter dem Schnitt! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dritter Teil</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vierter Teil</a></strong> </li></ul><br><p>  Nachdem wir die Funktionen verstanden haben, werden wir sehen, wie Typen mit Funktionen wie Dom√§ne und Bereich interagieren.  Dieser Artikel ist nur eine √úberpr√ºfung.  F√ºr ein tieferes Eintauchen in Typen gibt es eine Reihe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"F # -Typen verstehen"</a> . </p><br><p> Zu Beginn ben√∂tigen wir ein etwas besseres Verst√§ndnis der Typennotation.  Wir haben die Pfeilnotation " <code>-&gt;</code> " gesehen, die Dom√§ne und Bereich trennt.  Die Funktionssignatur sieht also immer so aus: </p><br><pre> <code class="plaintext hljs">val functionName : domain -&gt; range</code> </pre> <br><p>  Einige weitere Beispiele f√ºr Funktionen: </p><br><pre> <code class="plaintext hljs">let intToString x = sprintf "x is %i" x //  int  string let stringToInt x = System.Int32.Parse(x)</code> </pre> <br><p>  Wenn Sie diesen Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem interaktiven Fenster</a> ausf√ºhren, werden die folgenden Signaturen angezeigt: </p><br><pre> <code class="plaintext hljs">val intToString : int -&gt; string val stringToInt : string -&gt; int</code> </pre> <br><p>  Sie bedeuten: </p><br><ul><li>  <code>intToString</code> hat eine Dom√§ne vom Typ <code>int</code> , die dem Bereich der <code>intToString</code> ist. </li><li>  <code>stringToInt</code> verf√ºgt √ºber eine Dom√§ne vom Typ <code>string</code> , die einem Bereich vom Typ <code>int</code> . </li></ul><br><h2>  Primitive Typen </h2><br><p>  Es werden erwartete primitive Typen erwartet: Zeichenfolge, int, float, bool, char, byte usw. sowie viele andere Ableitungen des .NET-Typsystems. </p><br><p>  Einige weitere Beispiele f√ºr Funktionen mit primitiven Typen: </p><br><pre> <code class="plaintext hljs">let intToFloat x = float x // "float" -  int  float let intToBool x = (x = 2) // true  x  2 let stringToString x = x + " world"</code> </pre> <br><p>  und ihre Unterschriften: </p><br><pre> <code class="plaintext hljs">val intToFloat : int -&gt; float val intToBool : int -&gt; bool val stringToString : string -&gt; string</code> </pre> <br><h2>  Geben Sie Annotation ein </h2><br><p>  In den vorherigen Beispielen hat der F # -Compiler die Arten von Parametern und Ergebnissen korrekt definiert.  Dies ist jedoch nicht immer der Fall.  Wenn Sie versuchen, den folgenden Code auszuf√ºhren, wird ein Kompilierungsfehler angezeigt: </p><br><pre> <code class="plaintext hljs">let stringLength x = x.Length =&gt; error FS0072: Lookup on object of indeterminate type</code> </pre> <br><p>  Der Compiler kennt den Typ des Arguments "x" nicht und wei√ü daher nicht, ob die "L√§nge" eine g√ºltige Methode ist.  In den meisten F√§llen kann dies behoben werden, indem die "Typanmerkung" an den F # -Compiler √ºbergeben wird.  Dann wird er wissen, welchen Typ er verwenden soll.  In der festen Version geben wir an, dass der Typ "x" eine Zeichenfolge ist. </p><br><pre> <code class="plaintext hljs">let stringLength (x:string) = x.Length</code> </pre> <br><p>  Die geschweiften Klammern um den Parameter <code>x:string</code> sind wichtig.  Wenn sie √ºbersprungen werden, entscheidet der Compiler, dass die Zeichenfolge der R√ºckgabewert ist!  Das hei√üt, ein offener Doppelpunkt wird verwendet, um den Typ des R√ºckgabewerts anzugeben, wie im folgenden Beispiel gezeigt. </p><br><pre> <code class="plaintext hljs">let stringLengthAsInt (x:string) :int = x.Length</code> </pre> <br><p>  Wir geben an, dass der Parameter <code>x</code> eine Zeichenfolge und der R√ºckgabewert eine Ganzzahl ist. </p><br><h2>  Funktionstypen als Parameter </h2><br><p>  Eine Funktion, die andere Funktionen als Parameter verwendet oder eine Funktion zur√ºckgibt, wird als Funktion <strong>h√∂herer Ordnung bezeichnet</strong> ( <strong>Funktion h√∂herer Ordnung wird</strong> manchmal auf HOF verk√ºrzt).  Sie werden als Abstraktion verwendet, um ein m√∂glichst allgemeines Verhalten festzulegen.  Diese Art von Funktion ist in F # sehr verbreitet, die meisten Standardbibliotheken verwenden sie. </p><br><p>  Betrachten Sie die Funktion <code>evalWith5ThenAdd2</code> , die eine Funktion als Parameter verwendet, diese Funktion dann aus 5 berechnet und dem Ergebnis 2 hinzuf√ºgt: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 + 2 //   ,   fn(5) + 2</code> </pre> <br><p>  Die Signatur dieser Funktion sieht folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs">val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  Sie k√∂nnen sehen, dass die Dom√§ne <code>(int-&gt;int)</code> und der Bereich <code>int</code> .  Was bedeutet das?  Dies bedeutet, dass der Eingabeparameter kein einfacher Wert ist, sondern eine Funktion aus vielen Funktionen von <code>int</code> bis <code>int</code> .  Der Ausgabewert ist keine Funktion, sondern nur ein <code>int</code> . </p><br><p>  Versuchen wir mal: </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 //  -  (int -&gt; int) evalWith5ThenAdd2 add1 //  </code> </pre> <br><p>  und bekommen: </p><br><pre> <code class="plaintext hljs">val add1 : int -&gt; int val it : int = 8</code> </pre> <br><p>  " <code>add1</code> " ist eine Funktion, die <code>int</code> auf <code>int</code> abbildet, wie wir aus der Signatur sehen.  Es ist ein g√ºltiger Parameter f√ºr <code>evalWith5ThenAdd2</code> und das Ergebnis ist 8. </p><br><p>  Das spezielle Wort " <code>it</code> " bezeichnet √ºbrigens den zuletzt berechneten Wert. In diesem Fall ist es das Ergebnis, auf das wir gewartet haben.  Dies ist kein Schl√ºsselwort, sondern nur eine Namenskonvention. </p><br><p>  Ein anderer Fall: </p><br><pre> <code class="plaintext hljs">let times3 x = x * 3 // -  (int -&gt; int) evalWith5ThenAdd2 times3 //  </code> </pre> <br><p>  gibt: </p><br><pre> <code class="plaintext hljs">val times3 : int -&gt; int val it : int = 17</code> </pre> <br><p>  " <code>times3</code> " ist auch eine Funktion, die <code>int</code> auf <code>int</code> abbildet, wie aus der Signatur ersichtlich ist.  Es ist auch ein g√ºltiger Parameter f√ºr <code>evalWith5ThenAdd2</code> .  Das Ergebnis der Berechnungen ist 17. </p><br><p>  Bitte beachten Sie, dass die Eingabedaten typabh√§ngig sind.  Wenn die √ºbergebene Funktion ein <code>float</code> und kein <code>int</code> , funktioniert nichts.  Zum Beispiel, wenn wir haben: </p><br><pre> <code class="plaintext hljs">let times3float x = x * 3.0 // -  (float-&gt;float) evalWith5ThenAdd2 times3float</code> </pre> <br><p>  Der Compiler gibt beim Kompilieren einen Fehler zur√ºck: </p><br><pre> <code class="plaintext hljs">error FS0001: Type mismatch. Expecting a int -&gt; int but given a float -&gt; float</code> </pre> <br><p>  Meldung, dass die Eingabefunktion eine Funktion vom Typ <code>int-&gt;int</code> . </p><br><h3>  Funktioniert als Ausgabe </h3><br><p>  Wertfunktionen k√∂nnen auch das Ergebnis von Funktionen sein.  Die folgende Funktion generiert beispielsweise eine "Addierer" -Funktion, die einen Eingabewert hinzuf√ºgt. </p><br><pre> <code class="plaintext hljs">let adderGenerator numberToAdd = (+) numberToAdd</code> </pre> <br><p>  Ihre Unterschrift: </p><br><pre> <code class="plaintext hljs">val adderGenerator : int -&gt; (int -&gt; int)</code> </pre> <br><p>  bedeutet, dass der Generator ein <code>int</code> und eine Funktion ("Addierer") erstellt, die <code>ints</code> <code>ints</code> .  Mal sehen, wie es funktioniert: </p><br><pre> <code class="plaintext hljs">let add1 = adderGenerator 1 let add2 = adderGenerator 2</code> </pre> <br><p>  Es werden zwei Addiererfunktionen erstellt.  Die erste erstellt eine Funktion, die der Eingabe 1 hinzuf√ºgt, die zweite f√ºgt 2 hinzu. Beachten Sie, dass die Signaturen genau den Erwartungen entsprechen. </p><br><pre> <code class="plaintext hljs">val add1 : (int -&gt; int) val add2 : (int -&gt; int)</code> </pre> <br><p>  Jetzt k√∂nnen Sie die generierten Funktionen wie gewohnt verwenden, sie unterscheiden sich nicht von den explizit definierten Funktionen: </p><br><pre> <code class="plaintext hljs">add1 5 // val it : int = 6 add2 5 // val it : int = 7</code> </pre> <br><h3>  Verwenden von Typanmerkungen zum Einschr√§nken von Funktionstypen </h3><br><p>  Im ersten Beispiel haben wir uns eine Funktion angesehen: </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 +2 &gt; val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p>  In diesem Beispiel kann F # schlie√üen, dass " <code>fn</code> " <code>int</code> in <code>int</code> konvertiert, sodass seine Signatur <code>int-&gt;int</code> . </p><br><p>  Aber wie lautet die Signatur von "fn" im folgenden Fall? </p><br><pre> <code class="plaintext hljs">let evalWith5 fn = fn 5</code> </pre> <br><p>  Es ist klar, dass " <code>fn</code> " eine Art Funktion ist, die ein <code>int</code> , aber was gibt es zur√ºck?  Der Compiler kann diese Frage nicht beantworten.  In solchen F√§llen k√∂nnen Sie, wenn der Funktionstyp angegeben werden muss, einen Anmerkungstyp f√ºr Funktionsparameter sowie f√ºr primitive Typen hinzuf√ºgen. </p><br><pre> <code class="plaintext hljs">let evalWith5AsInt (fn:int-&gt;int) = fn 5 let evalWith5AsFloat (fn:int-&gt;float) = fn 5</code> </pre> <br><p>  Dar√ºber hinaus k√∂nnen Sie den R√ºckgabetyp bestimmen. </p><br><pre> <code class="plaintext hljs">let evalWith5AsString fn :string = fn 5</code> </pre> <br><p>  Weil  Die Hauptfunktion gibt einen <code>string</code> , die Funktion " <code>fn</code> " muss ebenfalls einen <code>string</code> .  Daher ist es nicht erforderlich, den Typ " <code>fn</code> " explizit anzugeben. </p><br><h2>  Geben Sie "Einheit" ein </h2><br><p>  W√§hrend des Programmierprozesses m√∂chten wir manchmal, dass eine Funktion etwas tut, ohne etwas zur√ºckzugeben.  Betrachten Sie die Funktion " <code>printInt</code> ".  Die Funktion gibt wirklich nichts zur√ºck.  Es druckt einfach die Zeichenfolge als Nebeneffekt der Ausf√ºhrung auf die Konsole. </p><br><pre> <code class="plaintext hljs">let printInt x = printf "x is %i" x //   </code> </pre> <br><p>  Was ist ihre Unterschrift? </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  Was ist eine " <code>unit</code> "? </p><br><p>  Auch wenn die Funktion keine Werte zur√ºckgibt, ben√∂tigt sie dennoch einen Bereich.  In der Welt der Mathematik gibt es keine "leeren" Funktionen.  Jede Funktion muss etwas zur√ºckgeben, da die Funktion ein Mapping ist und das Mapping etwas anzeigen muss! </p><br><p><img src="https://habrastorage.org/webt/3_/vt/vz/3_vtvz11kud3aikskqhciwc_q1a.png"></p><br><p>  In F # geben Funktionen wie diese einen speziellen Ergebnistyp namens " <code>unit</code> " zur√ºck.  Es enth√§lt nur einen Wert, der mit " <code>()</code> " gekennzeichnet ist.  Sie k√∂nnten denken, dass <code>unit</code> und <code>()</code> so etwas wie "void" bzw. "null" von C # sind.  Aber im Gegensatz zu ihnen ist <code>unit</code> der reale Typ und <code>()</code> reale Wert.  Um dies zu √ºberpr√ºfen, gehen Sie einfach wie folgt vor: </p><br><pre> <code class="plaintext hljs">let whatIsThis = ()</code> </pre> <br><p>  Die folgende Unterschrift wird erhalten: </p><br><pre> <code class="plaintext hljs">val whatIsThis : unit = ()</code> </pre> <br><p>  <code>whatIsThis</code> zeigt an, dass die Bezeichnung " <code>whatIsThis</code> " vom Typ <code>unit</code> und einem Wert <code>()</code> . </p><br><p>  <code>printInt</code> wir nun zur " <code>printInt</code> " <code>printInt</code> zur√ºckkehren, k√∂nnen wir die Bedeutung dieses Eintrags verstehen: </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p>  Diese Signatur besagt, dass <code>printInt</code> eine Dom√§ne von <code>int</code> , was sich in etwas √ºbersetzt, das uns nicht interessiert. </p><br><h3>  Funktionen ohne Parameter </h3><br><p>  K√∂nnen wir, <code>unit</code> wir die <code>unit</code> , ihr Auftreten in einem anderen Kontext vorhersagen?  Versuchen Sie beispielsweise, eine wiederverwendbare Funktion "Hallo Welt" zu erstellen.  Da es keine Eingabe oder Ausgabe gibt, k√∂nnen wir die Signatureinheit <code>unit -&gt; unit</code> erwarten.  Mal sehen: </p><br><pre> <code class="plaintext hljs">let printHello = printf "hello world" //   </code> </pre> <br><p>  Ergebnis: </p><br><pre> <code class="plaintext hljs">hello world val printHello : unit = ()</code> </pre> <br><p>  <em>Nicht ganz das,</em> was wir erwartet hatten.  "Hallo Welt" wurde sofort ausgegeben und das Ergebnis war keine Funktion, sondern ein einfacher Wert vom Typ Einheit.  Wir k√∂nnen sagen, dass dies ein einfacher Wert ist, da er, wie wir zuvor gesehen haben, eine Signatur des Formulars hat: </p><br><pre> <code class="plaintext hljs">val aName: type = constant</code> </pre> <br><p>  In diesem Beispiel sehen wir, dass <code>printHello</code> wirklich ein <em>einfacher Wert ist</em> <code>()</code> .  Dies ist keine Funktion, die wir sp√§ter aufrufen k√∂nnen. </p><br><p>  Was ist der Unterschied zwischen <code>printInt</code> und <code>printHello</code> ?  Im Fall von <code>printInt</code> Wert erst bestimmt werden, wenn wir den Wert des Parameters <code>x</code> . Die Definition war also eine Funktion.  Im Fall von <code>printHello</code> gibt es keine Parameter, so dass die rechte Seite an Ort und Stelle definiert werden kann.  Und es war gleich <code>()</code> mit einem Nebeneffekt in Form der Ausgabe an die Konsole. </p><br><p>  Sie k√∂nnen eine echte wiederverwendbare Funktion ohne Parameter erstellen und die Definition dazu zwingen, ein <code>unit</code> zu haben: </p><br><pre> <code class="plaintext hljs">let printHelloFn () = printf "hello world" //   </code> </pre> <br><p>  Jetzt ist ihre Unterschrift gleich: </p><br><pre> <code class="plaintext hljs">val printHelloFn : unit -&gt; unit</code> </pre> <br><p>  und um es aufzurufen, m√ºssen wir <code>()</code> als Parameter √ºbergeben: </p><br><pre> <code class="plaintext hljs">printHelloFn ()</code> </pre> <br><h3>  Verst√§rkung von Einheitentypen mit der Ignorierfunktion </h3><br><p>  In einigen F√§llen ben√∂tigt der Compiler einen <code>unit</code> und beschwert sich.  Beispielsweise verursachen beide der folgenden F√§lle einen Compilerfehler: </p><br><pre> <code class="plaintext hljs">do 1+1 // =&gt; FS0020: This expression should have type 'unit' let something = 2+2 // =&gt; FS0020: This expression should have type 'unit' "hello"</code> </pre> <br><p>  Um in diesen Situationen zu helfen, gibt es eine spezielle <code>ignore</code> , die alles √ºbernimmt und die <code>unit</code> zur√ºckgibt.  Die richtige Version dieses Codes k√∂nnte folgende sein: </p><br><pre> <code class="plaintext hljs">do (1+1 |&gt; ignore) // ok let something = 2+2 |&gt; ignore // ok "hello"</code> </pre> <br><h2>  Generische Typen </h2><br><p>  In den meisten F√§llen m√ºssen wir etwas dazu sagen, wenn der Typ eines Funktionsparameters ein beliebiger Typ sein kann.  F # verwendet f√ºr solche Situationen .NET-Generika. </p><br><p>  Die folgende Funktion konvertiert beispielsweise einen Parameter durch Hinzuf√ºgen von Text in eine Zeichenfolge: </p><br><pre> <code class="plaintext hljs">let onAStick x = x.ToString() + " on a stick"</code> </pre> <br><p>  <code>ToString()</code> von der Art des Parameters k√∂nnen alle Objekte in <code>ToString()</code> . </p><br><p>  Unterschrift: </p><br><pre> <code class="plaintext hljs">val onAStick : 'a -&gt; string</code> </pre> <br><p>  Welcher Typ <code>'a</code> ?  In F # ist dies eine M√∂glichkeit, einen generischen Typ anzugeben, der zur Kompilierungszeit unbekannt ist.  Ein Apostroph vor "a" bedeutet, dass der Typ generisch ist.  Entspricht dieser Signatur in C #: </p><br><pre> <code class="plaintext hljs">string onAStick&lt;a&gt;(); //   string OnAStick&lt;TObject&gt;(); // F#-   'a    // C#'-   "TObject"  </code> </pre> <br><p>  Es versteht sich, dass diese F # -Funktion auch bei generischen Typen eine starke Typisierung aufweist.  Es <em>wird kein</em> Parameter vom Typ <code>Object</code> akzeptiert.  Starkes Tippen ist gut, da Sie damit die Typensicherheit beim Erstellen von Funktionen beibehalten k√∂nnen. </p><br><p>  Die gleiche Funktion wird f√ºr <code>int</code> , <code>float</code> und <code>string</code> . </p><br><pre> <code class="plaintext hljs">onAStick 22 onAStick 3.14159 onAStick "hello"</code> </pre> <br><p>  Wenn es zwei verallgemeinerte Parameter gibt, gibt der Compiler ihnen zwei verschiedene Namen: <code>'a</code> f√ºr den ersten <code>'b</code> f√ºr den zweiten usw.  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">let concatString xy = x.ToString() + y.ToString()</code> </pre> <br><p>  Diese Signatur enth√§lt zwei generische Typen: <code>'a</code> und <code>'b</code> : </p><br><pre> <code class="plaintext hljs">val concatString : 'a -&gt; 'b -&gt; string</code> </pre> <br><p>  Andererseits erkennt der Compiler, wenn nur ein generischer Typ erforderlich ist.  Im folgenden Beispiel m√ºssen <code>x</code> und <code>y</code> vom gleichen Typ sein: </p><br><pre> <code class="plaintext hljs">let isEqual xy = (x=y)</code> </pre> <br><p>  Eine Funktionssignatur hat also f√ºr beide Parameter denselben generischen Typ: </p><br><pre> <code class="plaintext hljs">val isEqual : 'a -&gt; 'a -&gt; bool</code> </pre> <br><p>  Verallgemeinerte Parameter sind auch sehr wichtig, wenn es um Listen und andere abstrakte Strukturen geht, und wir werden viele davon in den folgenden Beispielen sehen. </p><br><h2>  Andere Arten </h2><br><p>  Bisher wurden nur Grundtypen diskutiert.  Diese Typen k√∂nnen auf verschiedene Weise zu komplexeren Typen kombiniert werden.  Ihre vollst√§ndige Analyse wird sp√§ter in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anderen Reihe erfolgen</a> , aber in der Zwischenzeit werden wir sie hier kurz analysieren, damit Sie sie in den Signaturen von Funktionen erkennen k√∂nnen. </p><br><ul><li>  <strong>Tupel</strong>  Dies ist ein Paar, ein Tripel usw., das aus anderen Typen besteht.  Zum Beispiel ist <code>("hello", 1)</code> ein Tupel, das auf <code>string</code> und <code>int</code> basiert.  Ein Komma ist ein Kennzeichen von Tupeln. Wenn irgendwo in F # ein Komma angezeigt wird, ist dies fast garantiert Teil des Tupels. <br>  In Funktionssignaturen werden Tupel als ‚ÄûProdukte‚Äú der beiden beteiligten Typen geschrieben.  In diesem Fall ist das Tupel vom Typ: </li></ul><br><pre> <code class="plaintext hljs">string * int // ("hello", 1)</code> </pre> <br><ul><li>  <strong>Sammlungen</strong> .  Die h√§ufigsten sind list (list), seq (sequence) und array.  Listen und Arrays haben eine feste Gr√∂√üe, w√§hrend Sequenzen m√∂glicherweise unendlich sind (hinter den Kulissen sind Sequenzen dieselbe <code>IEnumrable</code> ).  In Funktionssignaturen haben sie ihre eigenen Schl√ºsselw√∂rter: " <code>list</code> ", " <code>seq</code> " und " <code>[]</code> " f√ºr Arrays. </li></ul><br><pre> <code class="plaintext hljs">int list // List type  [1;2;3] string list // List type  ["a";"b";"c"] seq&lt;int&gt; // Seq type  seq{1..10} int [] // Array type  [|1;2;3|]</code> </pre> <br><ul><li>  <strong>Option (optionaler Typ)</strong> .  Dies ist ein einfacher Wrapper √ºber Objekte, die m√∂glicherweise fehlen.  Es gibt zwei Optionen: <code>Some</code> (wenn der Wert vorhanden ist) und <code>None</code> (wenn der Wert nicht vorhanden ist).  In Funktionssignaturen haben sie ein eigenes Schl√ºsselwort " <code>option</code> ": </li></ul><br><pre> <code class="plaintext hljs">int option // Some 1</code> </pre> <br><ul><li>  <strong>Die markierte Assoziation (diskriminierte Gewerkschaft)</strong> .  Sie bestehen aus vielen Variationen anderer Typen.  Wir haben einige Beispiele in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Warum F # verwenden?"</a>  .  In Funktionssignaturen werden sie nach Typnamen referenziert, sie haben kein spezielles Schl√ºsselwort. </li><li>  <strong>Datensatztyp (Datens√§tze)</strong> .  Typen wie Datenbankstrukturen oder Zeilen, eine Reihe benannter Werte.  Wir haben auch einige Beispiele in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Warum F # verwenden?"</a>  .  In Funktionssignaturen werden sie nach Typnamen aufgerufen und haben auch kein eigenes Schl√ºsselwort. </li></ul><br><h2>  Testen Sie Ihr Verst√§ndnis von Typen </h2><br><p>  Hier sind einige Ausdr√ºcke, um Ihr Verst√§ndnis von Funktionssignaturen zu testen.  Um dies zu √ºberpr√ºfen, f√ºhren Sie sie einfach in einem interaktiven Fenster aus! </p><br><pre> <code class="plaintext hljs">let testA = float 2 let testB x = float 2 let testC x = float 2 + x let testD x = x.ToString().Length let testE (x:float) = x.ToString().Length let testF x = printfn "%s" x let testG x = printfn "%f" x let testH = 2 * 2 |&gt; ignore let testI x = 2 * 2 |&gt; ignore let testJ (x:int) = 2 * 2 |&gt; ignore let testK = "hello" let testL() = "hello" let testM x = x=x let testN x = x 1 // :     x? let testO x:string = x 1 // :    :string ?</code> </pre> <br><h1>  Zus√§tzliche Ressourcen </h1><br><p>  Es gibt viele Tutorials f√ºr F #, einschlie√ülich Materialien f√ºr diejenigen, die mit C # oder Java-Erfahrung kommen.  Die folgenden Links k√∂nnen hilfreich sein, wenn Sie tiefer in F # einsteigen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Anleitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # f√ºr Spa√ü und Profit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne X in Y Minuten: F #</a> </li></ul><br><p>  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> auch verschiedene andere M√∂glichkeiten beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, um mit dem Lernen von F # zu beginnen</a> . </p><br><p>  Schlie√ülich ist die F # Community sehr anf√§ngerfreundlich.  Bei Slack gibt es einen sehr aktiven Chat, der von der F # Software Foundation unterst√ºtzt wird, mit Anf√§ngerr√§umen, an denen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">frei teilnehmen k√∂nnen</a> .  Wir empfehlen Ihnen dringend, dies zu tun! </p><br><p>  Vergessen Sie nicht, die Seite der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community F #</a> zu besuchen!  Wenn Sie Fragen zum Erlernen einer Sprache haben, diskutieren wir diese gerne in Chatrooms: </p><br><ul><li>  Raum <code>#ru_general</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack Chat</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Telegramm chatten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">chatte in gitter</a> </li></ul><br><h2>  √úber √úbersetzungsautoren </h2><br><p>  √úbersetzt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  √úbersetzungs- und redaktionelle √Ñnderungen wurden durch die Bem√ºhungen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">russischsprachigen Community von F # -Entwicklern vorgenommen</a> .  Wir danken auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@schvepsss</em></a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>@shwars</em></a> f√ºr die Vorbereitung dieses Artikels zur Ver√∂ffentlichung. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422115/">https://habr.com/ru/post/de422115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422099/index.html">Gro√üe Betreiber verdienen das "Fr√ºhlingsgesetz", indem sie kleinen Betreibern Hosting-Dienste anbieten</a></li>
<li><a href="../de422103/index.html">Warum ein Programmierer gut schreiben kann</a></li>
<li><a href="../de422107/index.html">Skalierung der Entwicklung: vom Start bis zu Hunderten von Ingenieuren</a></li>
<li><a href="../de422109/index.html">Firefox blockiert standardm√§√üig die Benutzerverfolgung</a></li>
<li><a href="../de422113/index.html">Fintech Digest: Die Zentralbank wird die Opfer von Hackern im Auge behalten, die Russen erhalten eine Bonit√§t, Yahoo Finance und Krypto-Handel</a></li>
<li><a href="../de422119/index.html">Indie Game Developer Toolkit</a></li>
<li><a href="../de422121/index.html">Wie man nach Deutschland geht, um am Beispiel meiner Auswanderung zu studieren und zu arbeiten</a></li>
<li><a href="../de422123/index.html">So stoppen Sie den Ausfall und f√ºhren normale R√ºckblenden durch</a></li>
<li><a href="../de422125/index.html">SENS-Diagnose. Proteinaggregat-Biomarker</a></li>
<li><a href="../de422127/index.html">Zum Teufel mit der Vernunft. Manchmal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>