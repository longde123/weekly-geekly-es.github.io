<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶î ü§° ‚èØÔ∏è MVCC no PostgreSQL-1. Isolamento üë©‚Äçüë¶‚Äçüë¶ üëèüèº üë¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Com este artigo, inicio um conjunto de s√©ries (ou uma s√©rie de conjuntos? - Em uma palavra, a ideia √© grandiosa) sobre a estrutura interna d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC no PostgreSQL-1. Isolamento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/">  Ol√° Habr!  Com este artigo, inicio um conjunto de s√©ries (ou uma s√©rie de conjuntos? - Em uma palavra, a ideia √© grandiosa) sobre a estrutura interna do PostgreSQL. <br><br>  O material ser√° baseado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cursos de treinamento</a> (em russo) sobre administra√ß√£o que Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">pluzanov</a> e eu estamos criando.  Nem todo mundo gosta de assistir a v√≠deos (eu definitivamente n√£o), e ler slides, mesmo com coment√°rios, n√£o √© bom. <br><br><blockquote>  Infelizmente, o √∫nico curso dispon√≠vel em ingl√™s no momento √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdu√ß√£o ao PostgreSQL 11 por 2 dias</a> . <br></blockquote><br>  Obviamente, os artigos n√£o ser√£o exatamente iguais ao conte√∫do dos cursos.  Vou falar apenas sobre como tudo est√° organizado, omitindo a pr√≥pria administra√ß√£o, mas tentarei faz√™-lo com mais detalhes e com mais profundidade.  E acredito que esse conhecimento √© t√£o √∫til para um desenvolvedor de aplicativos quanto para um administrador. <br><br>  Vou direcionar aqueles que j√° t√™m alguma experi√™ncia no uso do PostgreSQL e, pelo menos em geral, entendem o que √© o qu√™.  O texto ser√° muito dif√≠cil para iniciantes.  Por exemplo, n√£o direi uma palavra sobre como instalar o PostgreSQL e executar o psql. <br><br>  O material em quest√£o n√£o varia muito de vers√£o para vers√£o, mas usarei o atual, o 11¬∫ PostgreSQL de baunilha. <br><br>  A primeira s√©rie lida com quest√µes relacionadas ao isolamento e simultaneidade multivers√£o, e o plano da s√©rie √© o seguinte: <br><br><ol><li>  Isolamento conforme entendido pelo padr√£o e pelo PostgreSQL (este artigo). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Garfos, arquivos, p√°ginas</a> - o que est√° acontecendo no n√≠vel f√≠sico. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vers√µes de linha</a> , transa√ß√µes virtuais e subtransa√ß√µes. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Instant√¢neos de dados</a> e a visibilidade das vers√µes de linha;  o horizonte de eventos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aspira√ß√£o na p√°gina e atualiza√ß√µes QUENTES</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V√°cuo normal</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Autovacuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Identifica√ß√£o da transa√ß√£o envolvente e congelada</a> . </li></ol><br>  L√° vamos n√≥s! <br><br><blockquote>  Antes de come√ßar, gostaria de agradecer a Elena Indrupskaya por traduzir os artigos para o ingl√™s. <br></blockquote><br><a name="habracut"></a><br><h1>  O que √© isolamento e por que √© importante? </h1><br>  Provavelmente, todos est√£o pelo menos conscientes da exist√™ncia de transa√ß√µes, encontraram a abreviatura ACID e ouviram falar sobre n√≠veis de isolamento.  Mas ainda enfrentamos a opini√£o de que isso se refere √† teoria, o que n√£o √© necess√°rio na pr√°tica.  Portanto, passarei algum tempo tentando explicar por que isso √© realmente importante. <br><br>  √â improv√°vel que voc√™ fique satisfeito se um aplicativo obtiver dados incorretos do banco de dados ou se o aplicativo gravar dados incorretos no banco de dados. <br><br>  Mas o que s√£o dados "corretos"?  Sabe-se que <em>restri√ß√µes de integridade</em> , como NOT NULL ou UNIQUE, podem ser criadas no n√≠vel do banco de dados.  Se os dados sempre atenderem √†s restri√ß√µes de integridade (e √© assim que o DBMS garante isso), eles ser√£o integrais. <br><br>  <em>Corretas</em> e <em>integrais s√£o</em> as mesmas coisas?  N√£o exatamente.  Nem todas as restri√ß√µes podem ser especificadas no n√≠vel do banco de dados.  Algumas das restri√ß√µes s√£o muito complicadas, por exemplo, que abrangem v√°rias tabelas ao mesmo tempo.  E mesmo que uma restri√ß√£o em geral possa ter sido definida no banco de dados, mas por alguma raz√£o n√£o foi, isso n√£o significa que a restri√ß√£o possa ser violada. <br><br>  Portanto, a <em>corre√ß√£o</em> √© mais forte que a <em>integridade</em> , mas n√£o sabemos exatamente o que isso significa.  N√£o temos nada al√©m de admitir que o "padr√£o ouro" de corre√ß√£o √© um aplicativo que, como gostar√≠amos de acreditar, foi escrito <em>corretamente</em> e nunca corre errado.  De qualquer forma, se um aplicativo n√£o violar a integridade, mas violar a corre√ß√£o, o DBMS n√£o o saber√° e n√£o pegar√° o aplicativo em flagrante. <br><br>  Al√©m disso, usaremos o termo <em>consist√™ncia</em> para nos referirmos √† corre√ß√£o. <br><br>  Suponhamos, no entanto, que um aplicativo execute apenas sequ√™ncias corretas de operadores.  Qual √© o papel do DBMS se o aplicativo estiver correto como est√°? <br><br>  Primeiro, verifica-se que uma sequ√™ncia correta de operadores pode interromper temporariamente a consist√™ncia dos dados e, curiosamente, isso √© normal.  Um exemplo banal, mas claro, √© uma transfer√™ncia de fundos de uma conta para outra.  A regra de consist√™ncia pode parecer assim: <em>uma transfer√™ncia nunca altera a quantidade total de dinheiro nas contas</em> (√© muito dif√≠cil especificar no SQL uma restri√ß√£o de integridade, portanto, existe no n√≠vel do aplicativo e √© invis√≠vel para o DBMS).  Uma transfer√™ncia consiste em duas opera√ß√µes: a primeira reduz os fundos em uma conta e a segunda - aumenta na outra.  A primeira opera√ß√£o quebra a consist√™ncia dos dados, enquanto a segunda a restaura. <br><br><blockquote>  Um bom exerc√≠cio √© implementar a regra acima no n√≠vel de restri√ß√µes de integridade. <br></blockquote><br>  E se a primeira opera√ß√£o for realizada e a segunda n√£o?  De fato, sem muito barulho: durante a segunda opera√ß√£o, pode ocorrer uma falha de eletricidade, uma pane no servidor, uma divis√£o por zero - qualquer que seja.  √â claro que a consist√™ncia ser√° quebrada, e isso n√£o pode ser permitido.  Em geral, √© poss√≠vel resolver esses problemas no n√≠vel do aplicativo, mas √† custa de enormes esfor√ßos;  no entanto, felizmente, n√£o √© necess√°rio: isso √© feito pelo DBMS.  Mas, para fazer isso, o DBMS deve saber que as duas opera√ß√µes s√£o um todo indivis√≠vel.  Ou seja, <em>uma transa√ß√£o</em> . <br><br>  Parece interessante: como o DBMS sabe que as opera√ß√µes comp√µem uma transa√ß√£o, ajuda a manter a consist√™ncia, garantindo que as transa√ß√µes sejam at√¥micas, e faz isso sem saber nada sobre regras espec√≠ficas de consist√™ncia. <br><br>  Mas h√° um segundo ponto, mais sutil.  Assim que v√°rias transa√ß√µes simult√¢neas aparecem no sistema, que s√£o absolutamente corretas separadamente, elas podem n√£o funcionar corretamente juntas.  Isso ocorre porque a ordem das opera√ß√µes √© confusa: voc√™ n√£o pode assumir que todas as opera√ß√µes de uma transa√ß√£o s√£o executadas primeiro e depois todas as opera√ß√µes da outra. <br><br>  Uma observa√ß√£o sobre simultaneidade.  De fato, as transa√ß√µes podem ser executadas simultaneamente em um sistema com um processador multin√∫cleo, matriz de disco etc.  Mas o mesmo racioc√≠nio se aplica a um servidor que executa comandos sequencialmente, em um modo de compartilhamento de tempo: durante certos ciclos de rel√≥gio, uma transa√ß√£o √© executada e, durante os pr√≥ximos ciclos, a outra.  √Äs vezes, o termo execu√ß√£o <em>simult√¢nea</em> √© usado para uma generaliza√ß√£o. <br><br>  Situa√ß√µes em que transa√ß√µes corretas trabalham juntas incorretamente s√£o chamadas de <em>anomalias</em> de execu√ß√£o simult√¢nea. <br><br>  Para um exemplo simples: se um aplicativo deseja obter dados corretos do banco de dados, ele n√£o deve, pelo menos, ver altera√ß√µes de outras transa√ß√µes n√£o confirmadas.  Caso contr√°rio, voc√™ poder√° n√£o apenas obter dados inconsistentes, mas tamb√©m ver algo que nunca esteve no banco de dados (se a transa√ß√£o for cancelada).  Essa anomalia √© chamada de <em>leitura suja</em> . <br><br>  Existem outras anomalias mais complexas, com as quais trataremos um pouco mais tarde. <br><br>  Certamente √© imposs√≠vel evitar a execu√ß√£o simult√¢nea: caso contr√°rio, de que tipo de desempenho podemos falar?  Mas voc√™ tamb√©m n√£o pode trabalhar com dados incorretos. <br><br>  E novamente o DBMS vem em socorro.  Voc√™ pode fazer transa√ß√µes executadas <em>como se</em> sequencialmente, <em>como se</em> uma ap√≥s a outra.  Em outras palavras - <em>isoladas</em> uma da outra.  Na realidade, o DBMS pode executar opera√ß√µes combinadas, mas garantir que o resultado de uma execu√ß√£o simult√¢nea seja o mesmo que o resultado de algumas das poss√≠veis execu√ß√µes seq√ºenciais.  E isso elimina quaisquer poss√≠veis anomalias. <br><br>  Ent√£o chegamos √† defini√ß√£o: <br><br><blockquote>  Uma transa√ß√£o √© um conjunto de opera√ß√µes executadas por um aplicativo que transfere um banco de dados de um estado correto para outro estado correto (consist√™ncia), desde que a transa√ß√£o seja conclu√≠da (atomicidade) e sem interfer√™ncia de outras transa√ß√µes (isolamento). <br></blockquote><br>  Essa defini√ß√£o une as tr√™s primeiras letras do acr√¥nimo ACID.  Eles est√£o t√£o intimamente relacionados um com o outro que n√£o faz sentido considerar um sem os outros.  De fato, tamb√©m √© dif√≠cil destacar a letra D (durabilidade).  De fato, quando um sistema falha, ele ainda possui altera√ß√µes de transa√ß√µes n√£o confirmadas, com as quais voc√™ precisa fazer algo para restaurar a consist√™ncia dos dados. <br><br>  Tudo ficaria bem, mas a implementa√ß√£o do isolamento completo √© uma tarefa tecnicamente dif√≠cil que implica uma redu√ß√£o na taxa de transfer√™ncia do sistema.  Portanto, na pr√°tica com muita frequ√™ncia (nem sempre, mas quase sempre), o isolamento enfraquecido √© usado, o que evita algumas, mas nem todas as anomalias.  Isso significa que parte do trabalho para garantir a corre√ß√£o dos dados recai sobre o aplicativo.  Por esse motivo, √© muito importante entender qual n√≠vel de isolamento √© usado no sistema, quais garantias ele oferece e o que n√£o fornece, e como escrever o c√≥digo correto nessas condi√ß√µes. <br><br><h1>  N√≠veis de isolamento e anomalias no padr√£o SQL </h1><br>  O padr√£o SQL h√° muito descreveu quatro n√≠veis de isolamento.  Esses n√≠veis s√£o definidos listando anomalias que s√£o permitidas ou n√£o quando transa√ß√µes s√£o executadas simultaneamente nesse n√≠vel.  Portanto, para falar sobre esses n√≠veis, √© necess√°rio conhecer as anomalias. <br><br>  Enfatizo que nesta parte estamos falando sobre o padr√£o, isto √©, sobre uma teoria, na qual a pr√°tica se baseia significativamente, mas da qual ao mesmo tempo diverge significativamente.  Portanto, todos os exemplos aqui s√£o especulativos.  Eles usar√£o as mesmas opera√ß√µes nas contas dos clientes: isso √© bastante demonstrativo, embora, reconhecidamente, nada tenha a ver com a forma como as opera√ß√µes banc√°rias s√£o organizadas na realidade. <br><br><h2>  Atualiza√ß√£o de perda </h2><br>  Vamos come√ßar com a <em>atualiza√ß√£o perdida</em> .  Essa anomalia ocorre quando duas transa√ß√µes l√™em a mesma linha da tabela, uma transa√ß√£o atualiza essa linha e a segunda transa√ß√£o tamb√©m atualiza a mesma linha sem levar em considera√ß√£o as altera√ß√µes feitas pela primeira transa√ß√£o. <br><br>  Por exemplo, duas transa√ß√µes aumentar√£o o valor na mesma conta em ‚ÇΩ100 (‚ÇΩ √© o sinal de moeda do rublo russo).  A primeira transa√ß√£o l√™ o valor atual (¬± 1000) e a segunda transa√ß√£o l√™ o mesmo valor.  A primeira transa√ß√£o aumenta a quantidade (isso d√° ‚ÇΩ1100) e grava esse valor.  A segunda transa√ß√£o age da mesma maneira: obt√©m o mesmo ‚ÇΩ1100 e grava esse valor.  Como resultado, o cliente perdeu ¬£ 100. <br><br>  O padr√£o n√£o permite atualiza√ß√µes perdidas em nenhum n√≠vel de isolamento. <br><br><h2>  Leitura e leitura sujas n√£o confirmadas </h2><br>  Uma <em>leitura suja</em> √© o que j√° conhecemos.  Essa anomalia ocorre quando uma transa√ß√£o l√™ altera√ß√µes que ainda n√£o foram confirmadas por outra transa√ß√£o. <br><br>  Por exemplo, a primeira transa√ß√£o transfere todo o dinheiro da conta do cliente para outra conta, mas n√£o confirma a altera√ß√£o.  Outra transa√ß√£o l√™ o saldo da conta, para obter ‚ÇΩ0, e se recusa a sacar dinheiro para o cliente, embora a primeira transa√ß√£o aborte e reverta suas altera√ß√µes, portanto o valor 0 nunca existiu no banco de dados. <br><br>  O padr√£o permite leituras sujas no n√≠vel Read Uncommitted. <br><br><h2>  Leitura n√£o repet√≠vel e leitura confirmada </h2><br>  Uma anomalia de <em>leitura n√£o repet√≠vel</em> ocorre quando uma transa√ß√£o l√™ a mesma linha duas vezes e, entre as leituras, a segunda transa√ß√£o modifica (ou exclui) essa linha e confirma as altera√ß√µes.  Em seguida, a primeira transa√ß√£o obter√° resultados diferentes. <br><br>  Por exemplo, permita que uma regra de consist√™ncia <em>pro√≠ba valores negativos nas contas dos clientes</em> .  A primeira transa√ß√£o reduzir√° o valor da conta em ‚ÇΩ100.  Ele verifica o valor atual, obt√©m ‚ÇΩ1000 e decide que a diminui√ß√£o √© poss√≠vel.  Ao mesmo tempo, a segunda transa√ß√£o reduz o valor da conta para zero e confirma as altera√ß√µes.  Se a primeira transa√ß√£o agora verificar novamente o valor, ela receber√° get0 (mas j√° decidiu reduzir o valor e a conta "ficar√° no vermelho"). <br><br>  O padr√£o permite leituras n√£o repet√≠veis nos n√≠veis Read Uncommitted e Read Committed.  Mas a leitura confirmada n√£o permite leituras sujas. <br><br><h2>  Leitura fantasma e leitura repetida </h2><br>  Uma <em>leitura fantasma</em> ocorre quando uma transa√ß√£o l√™ um conjunto de linhas pela mesma condi√ß√£o duas vezes e, entre as leituras, a segunda transa√ß√£o adiciona linhas que atendem a essa condi√ß√£o (e confirma as altera√ß√µes).  Em seguida, a primeira transa√ß√£o ter√° um conjunto diferente de linhas. <br><br>  Por exemplo, permita que uma regra de consist√™ncia <em>impe√ßa que um cliente tenha mais de 3 contas</em> .  A primeira transa√ß√£o abrir√° uma nova conta, verificar√° o n√∫mero atual de contas (por exemplo, 2) e decide que a abertura √© poss√≠vel.  Ao mesmo tempo, a segunda transa√ß√£o tamb√©m abre uma nova conta para o cliente e confirma as altera√ß√µes.  Agora, se a primeira transa√ß√£o verificar novamente o n√∫mero, obter√° 3 (mas j√° est√° abrindo outra conta e o cliente parece ter 4). <br><br>  O padr√£o permite leituras fantasmas nos n√≠veis de leitura n√£o confirmada, leitura confirmada e leitura repetida.  No entanto, a leitura n√£o repet√≠vel n√£o √© permitida no n√≠vel de leitura repetida. <br><br><h2>  A aus√™ncia de anomalias e serializ√°veis </h2><br>  O padr√£o define mais um n√≠vel - serializ√°vel - que n√£o permite nenhuma anomalia.  E isso n√£o √© o mesmo que proibir atualiza√ß√µes perdidas e leituras sujas, n√£o repet√≠veis ou fantasmas. <br><br>  O fato √© que existem anomalias muito mais conhecidas do que as listadas no padr√£o e tamb√©m um n√∫mero desconhecido de outras ainda desconhecidas. <br><br>  O n√≠vel serializ√°vel deve evitar <em>absolutamente todas as</em> anomalias.  Isso significa que, nesse n√≠vel, um desenvolvedor de aplicativos n√£o precisa pensar em execu√ß√£o simult√¢nea.  Se as transa√ß√µes executarem uma sequ√™ncia correta de operadores trabalhando separadamente, os dados tamb√©m ser√£o consistentes quando essas transa√ß√µes forem executadas simultaneamente. <br><br><h2>  Tabela Resumo </h2><br>  Agora podemos fornecer uma tabela conhecida.  Mas aqui a √∫ltima coluna, que est√° faltando no padr√£o, √© adicionada para maior clareza. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Mudan√ßas perdidas </th><th>  Leitura suja </th><th>  Leitura n√£o repet√≠vel </th><th>  Leitura fantasma </th><th>  Outras anomalias </th></tr><tr><th>  Leitura n√£o confirmada </th><th>  - </th><th>  Sim </th><th>  Sim </th><th>  Sim </th><th>  Sim </th></tr><tr><th>  Leitura confirmada </th><th>  - </th><th>  - </th><th>  Sim </th><th>  Sim </th><th>  Sim </th></tr><tr><th>  Leitura Repet√≠vel </th><th>  - </th><th>  - </th><th>  - </th><th>  Sim </th><th>  Sim </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  Por que exatamente essas anomalias? </h2><br>  Por que o padr√£o lista apenas algumas das muitas anomalias poss√≠veis e por que elas s√£o exatamente essas? <br><br>  Ningu√©m parece saber com certeza.  Mas aqui a pr√°tica est√° evidentemente √† frente da teoria, portanto √© poss√≠vel que naquele momento (do padr√£o SQL: 92) outras anomalias n√£o fossem apenas pensadas. <br><br>  Al√©m disso, assumiu-se que o isolamento deve ser constru√≠do em bloqueios.  A id√©ia por tr√°s do amplamente utilizado <em>protocolo de bloqueio de</em> duas fases (2PL) √© que, durante a execu√ß√£o, uma transa√ß√£o bloqueia as linhas com as quais est√° trabalhando e libera os bloqueios ap√≥s a conclus√£o.  Simplificando consideravelmente, quanto mais bloqueios uma transa√ß√£o adquire, melhor ela √© isolada de outras transa√ß√µes.  Mas o desempenho do sistema tamb√©m sofre mais, porque, em vez de trabalharem juntas, as transa√ß√µes come√ßam a ficar na fila para as mesmas linhas. <br><br>  Meu sentimento √© que √© apenas o n√∫mero de bloqueios necess√°rios, o que explica a diferen√ßa entre os n√≠veis de isolamento do padr√£o. <br><br>  Se uma transa√ß√£o bloquear as linhas a serem modificadas da atualiza√ß√£o, mas n√£o da leitura, obtemos o n√≠vel Read Uncommitted: altera√ß√µes perdidas n√£o s√£o permitidas, mas dados n√£o confirmados podem ser lidos. <br><br>  Se uma transa√ß√£o bloquear as linhas a serem modificadas tanto na leitura quanto na atualiza√ß√£o, obteremos o n√≠vel Read Committed: voc√™ n√£o poder√° ler dados n√£o confirmados, mas poder√° obter um valor diferente (leitura n√£o repet√≠vel) ao acessar a linha novamente. <br><br>  Se uma transa√ß√£o bloqueia as linhas para serem lidas e modificadas, tanto para a leitura quanto para a atualiza√ß√£o, obtemos o n√≠vel de leitura repetida: reler a linha retornar√° o mesmo valor. <br><br>  Mas h√° um problema com o Serializable: voc√™ n√£o pode bloquear uma linha que ainda n√£o existe.  Portanto, uma leitura fantasma ainda √© poss√≠vel: outra transa√ß√£o pode adicionar (mas n√£o excluir) uma linha que atenda √†s condi√ß√µes de uma consulta executada anteriormente e essa linha ser√° inclu√≠da na re-sele√ß√£o. <br><br>  Portanto, para implementar o n√≠vel Serializable, os bloqueios normais n√£o s√£o suficientes - voc√™ precisa bloquear condi√ß√µes (predicados) em vez de linhas.  Portanto, esses bloqueios foram chamados de <em>predicado</em> .  Eles foram propostos em 1976, mas sua aplicabilidade pr√°tica √© limitada por condi√ß√µes bastante simples para as quais √© claro como unir dois predicados diferentes.  At√© onde eu sei, esses bloqueios nunca foram implementados em nenhum sistema at√© agora. <br><br><h1>  N√≠veis de isolamento no PostgreSQL </h1><br>  Com o tempo, os protocolos de gerenciamento de transa√ß√µes baseados em bloqueio foram substitu√≠dos pelo protocolo Snapshot Isolation (SI).  Sua id√©ia √© que cada transa√ß√£o funcione com uma captura instant√¢nea consistente dos dados em um determinado momento, e apenas essas altera√ß√µes entrem na captura instant√¢nea que foram confirmadas antes de serem criadas. <br><br>  Esse isolamento impede automaticamente leituras sujas.  Formalmente, voc√™ pode especificar o n√≠vel Read Uncommitted no PostgreSQL, mas ele funcionar√° exatamente da mesma maneira que o Read Committed.  Portanto, ainda n√£o falaremos sobre o n√≠vel Read Uncommitted. <br><br>  O PostgreSQL implementa uma variante <em>multivers√£o</em> deste protocolo.  A id√©ia da simultaneidade de v√°rias vers√µes √© que v√°rias vers√µes da mesma linha podem coexistir em um DBMS.  Isso permite criar uma captura instant√¢nea dos dados usando vers√µes existentes e usar um m√≠nimo de bloqueios.  Na verdade, apenas as altera√ß√µes subsequentes na mesma linha s√£o bloqueadas.  Todas as outras opera√ß√µes s√£o executadas simultaneamente: transa√ß√µes de grava√ß√£o nunca bloqueiam transa√ß√µes somente leitura e transa√ß√µes somente leitura nunca bloqueiam nada. <br><br>  Ao usar instant√¢neos de dados, o isolamento no PostgreSQL √© mais r√≠gido do que o exigido pelo padr√£o: o n√≠vel de Leitura Repet√≠vel n√£o permite n√£o apenas leituras n√£o repet√≠veis, mas tamb√©m leituras fantasmas (embora n√£o forne√ßa isolamento completo).  E isso √© alcan√ßado sem perda de efici√™ncia. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Mudan√ßas perdidas </th><th>  Leitura suja </th><th>  Leitura n√£o repet√≠vel </th><th>  Leitura fantasma </th><th>  Outras anomalias </th></tr><tr><th>  Leitura n√£o confirmada </th><th>  - </th><th>  - </th><th>  Sim </th><th>  Sim </th><th>  Sim </th></tr><tr><th>  Leitura confirmada </th><th>  - </th><th>  - </th><th>  Sim </th><th>  Sim </th><th>  Sim </th></tr><tr><th>  Leitura Repet√≠vel </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  Sim </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Falaremos nos pr√≥ximos artigos sobre como a simultaneidade multivers√£o √© implementada ‚Äúsob o cap√¥‚Äù e agora examinaremos detalhadamente cada um dos tr√™s n√≠veis com o olhar do usu√°rio (como voc√™ sabe, o mais interessante est√° oculto por tr√°s de ‚Äúoutras anomalias ‚Äù).  Para fazer isso, vamos criar um quadro de contas.  Alice e Bob t√™m 0001000 cada, mas Bob tem duas contas abertas: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Leitura confirmada </h2><br><h3>  A aus√™ncia de leitura suja </h3><br>  √â f√°cil garantir que dados sujos n√£o possam ser lidos.  Come√ßamos a transa√ß√£o.  Por padr√£o, ele usar√° o n√≠vel de isolamento Read Committed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Mais precisamente, o n√≠vel padr√£o √© definido pelo par√¢metro, que pode ser alterado se necess√°rio: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Portanto, em uma transa√ß√£o aberta, retiramos fundos da conta, mas n√£o confirmamos as altera√ß√µes.  A transa√ß√£o v√™ suas pr√≥prias altera√ß√µes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  Na segunda sess√£o, iniciaremos outra transa√ß√£o com o mesmo n√≠vel Read Committed.  Para distinguir entre as transa√ß√µes, os comandos da segunda transa√ß√£o ser√£o recuados e marcados com uma barra. <br><br>  Para repetir os comandos acima (o que √© √∫til), voc√™ precisa abrir dois terminais e executar o psql em cada um.  No primeiro terminal, voc√™ pode inserir os comandos de uma transa√ß√£o e no segundo - os da outra. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Como esperado, a outra transa√ß√£o n√£o v√™ altera√ß√µes n√£o confirmadas, pois leituras sujas n√£o s√£o permitidas. <br><br><h3>  Leitura n√£o repet√≠vel </h3><br>  Agora deixe a primeira transa√ß√£o confirmar as altera√ß√µes e a segunda execute novamente a mesma consulta. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  A consulta j√° obt√©m novos dados - e essa √© a anomalia de <em>leitura n√£o repet√≠vel</em> , permitida no n√≠vel Read Committed. <br><br>  <em>Conclus√£o pr√°tica</em> : em uma transa√ß√£o, voc√™ n√£o pode tomar decis√µes com base nos dados lidos por um operador anterior, porque as coisas podem mudar entre a execu√ß√£o dos operadores.  Aqui est√° um exemplo cujas varia√ß√µes ocorrem com tanta frequ√™ncia no c√≥digo do aplicativo que √© considerado um antipadr√£o cl√°ssico: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Durante o tempo decorrido entre a verifica√ß√£o e a atualiza√ß√£o, outras transa√ß√µes podem alterar o estado da conta de qualquer maneira, de modo que esse "cheque" se protege do nada.  √â conveniente imaginar que entre os operadores de uma transa√ß√£o quaisquer outros operadores de outras transa√ß√µes possam "cunhar", por exemplo, da seguinte maneira: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Se tudo puder ser estragado reorganizando os operadores, o c√≥digo ser√° gravado incorretamente.  E n√£o se engane que tal coincid√™ncia n√£o acontecer√° - com certeza. <br><br>  Mas como escrever c√≥digo corretamente?  As op√ß√µes tendem a ser as seguintes: <br><br><ul><li>  N√£o para escrever c√≥digo. <br>  Isso n√£o √© uma piada.  Por exemplo, nesse caso, a verifica√ß√£o se transforma facilmente em uma restri√ß√£o de integridade: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Nenhuma verifica√ß√£o √© necess√°ria agora: basta executar a opera√ß√£o e, se necess√°rio, lidar com a exce√ß√£o que ocorrer√° se uma viola√ß√£o de integridade for tentada. <br></li><li>  Para usar uma √∫nica instru√ß√£o SQL. <br>  Surgem problemas de consist√™ncia, pois no intervalo de tempo entre os operadores, outra transa√ß√£o pode ser conclu√≠da, o que alterar√° os dados vis√≠veis.  E se houver um operador, n√£o haver√° intervalos de tempo. <br>  O PostgreSQL possui t√©cnicas suficientes para resolver problemas complexos com uma instru√ß√£o SQL.  Vamos observar as express√µes de tabela comum (CTE), nas quais, entre o restante, voc√™ pode usar as instru√ß√µes INSERT / UPDATE / DELETE, bem como a instru√ß√£o INSERT ON CONFLICT, que implementa a l√≥gica de "insert, mas se a linha j√° existir, update ‚Äùem uma declara√ß√£o. <br></li><li>  Bloqueios personalizados. <br>  O √∫ltimo recurso √© definir manualmente um bloqueio exclusivo em todas as linhas necess√°rias (SELECT FOR UPDATE) ou mesmo em toda a tabela (LOCK TABLE).  Isso sempre funciona, mas anula os benef√≠cios da simultaneidade de v√°rias vers√µes: algumas opera√ß√µes ser√£o executadas seq√ºencialmente em vez da execu√ß√£o simult√¢nea. <br></li></ul><br><h3>  Leitura inconsistente </h3><br>  Antes de avan√ßar para o pr√≥ximo n√≠vel de isolamento, voc√™ deve admitir que n√£o √© t√£o simples quanto parece.  A implementa√ß√£o do PostgreSQL √© tal que permite outras anomalias, menos conhecidas, que n√£o s√£o regulamentadas pelo padr√£o. <br><br>  Vamos supor que a primeira transa√ß√£o iniciou a transfer√™ncia de fundos de uma conta de Bob para a outra: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Ao mesmo tempo, outra transa√ß√£o conta o saldo de Bob e o c√°lculo √© realizado em um loop em todas as contas de Bob.  De fato, a transa√ß√£o come√ßa com a primeira conta (e, obviamente, v√™ o estado anterior): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Neste momento, a primeira transa√ß√£o √© conclu√≠da com √™xito: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  E o outro l√™ o estado da segunda conta (e j√° v√™ o novo valor): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Portanto, a segunda transa√ß√£o obteve 1100 no total, ou seja, dados incorretos.  E esta √© uma anomalia de <em>leitura inconsistente</em> . <br><br>  Como evitar essa anomalia enquanto permanece no n√≠vel Read Committed?  Obviamente, use um operador.  Por exemplo: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  At√© aqui, afirmei que a visibilidade dos dados s√≥ poderia mudar entre os operadores, mas isso √© t√£o √≥bvio?  E se a consulta demorar, ela poder√° ver parte dos dados em um estado e parte em outro? <br><br>  Vamos verificar.  Uma maneira conveniente de fazer isso √© inserir um atraso for√ßado no operador chamando a fun√ß√£o pg_sleep.  Seu par√¢metro especifica o tempo de atraso em segundos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Enquanto esse operador √© executado, transferimos os fundos de volta em outra transa√ß√£o: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  O resultado mostra que o operador v√™ os dados no estado em que estavam no momento em que a execu√ß√£o do operador foi iniciada.  Isso √©, sem d√∫vida, correto. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Mas n√£o √© t√£o simples aqui tamb√©m.  O PostgreSQL permite definir fun√ß√µes, e as fun√ß√µes t√™m o conceito de uma <em>categoria de volatilidade</em> .  Se uma fun√ß√£o VOLATILE for chamada em uma consulta e outra consulta for executada nessa fun√ß√£o, a consulta dentro da fun√ß√£o ver√° dados que s√£o inconsistentes com os dados na consulta principal. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Nesse caso, obtemos dados incorretos - ‚ÇΩ100 s√£o perdidos: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Enfatizo que esse efeito √© poss√≠vel apenas no n√≠vel de isolamento Read Committed e somente com as fun√ß√µes VOLATILE.  O problema √© que, por padr√£o, exatamente esse n√≠vel de isolamento e essa categoria de volatilidade s√£o usados.  N√£o caia na armadilha! <br><br><h3>  Leitura inconsistente em troca de altera√ß√µes perdidas </h3><br>  Tamb√©m podemos obter uma leitura inconsistente dentro de um √∫nico operador durante uma atualiza√ß√£o, embora de uma maneira um tanto inesperada. <br><br>  Vamos ver o que acontece quando duas transa√ß√µes tentam modificar a mesma linha.  Agora, Bob tem 0001000 em duas contas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Iniciamos uma transa√ß√£o que reduz o saldo de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Ao mesmo tempo, em outra transa√ß√£o, os juros s√£o acumulados em todas as contas de clientes com o saldo total igual ou superior a 1.000: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  A execu√ß√£o do operador UPDATE consiste em duas partes.  Primeiro, realmente SELECT √© executado, o que seleciona as linhas a serem atualizadas que atendem √† condi√ß√£o apropriada.  Como a altera√ß√£o na primeira transa√ß√£o n√£o √© confirmada, a segunda transa√ß√£o n√£o pode v√™-la e a altera√ß√£o n√£o afeta a sele√ß√£o de linhas para acumula√ß√£o de juros.  Bem, ent√£o, as contas de Bob atendem √† condi√ß√£o e, uma vez executada a atualiza√ß√£o, seu saldo deve aumentar em ¬± 10. <br><br>  O segundo est√°gio da execu√ß√£o √© atualizar as linhas selecionadas uma a uma.  Aqui a segunda transa√ß√£o √© for√ßada a "travar" porque a linha com id = 3 j√° est√° bloqueada pela primeira transa√ß√£o. <br><br>  Enquanto isso, a primeira transa√ß√£o confirma as altera√ß√µes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Qual ser√° o resultado? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Bem, por um lado, o comando UPDATE n√£o deve ver as altera√ß√µes da segunda transa√ß√£o.  Mas, por outro lado, n√£o deve perder as altera√ß√µes confirmadas na segunda transa√ß√£o. <br><br>  Depois que o bloqueio √© liberado, UPDATE rel√™ a linha que est√° tentando atualizar (mas apenas esta).  Como resultado, Bob acumulou ‚ÇΩ9, com base no valor de 00900.  Mas se Bob tivesse 900 d√≥lares, suas contas n√£o deveriam estar na sele√ß√£o. <br><br>  Portanto, a transa√ß√£o obt√©m dados incorretos: algumas das linhas s√£o vis√≠veis em um ponto no tempo e outras em outra.  Em vez de uma atualiza√ß√£o perdida, novamente obtemos a anomalia de <em>leitura inconsistente</em> . <br><br><blockquote>  Os leitores atentos observam que, com alguma ajuda do aplicativo, voc√™ pode obter uma atualiza√ß√£o perdida, mesmo no n√≠vel de Leitura confirmada.  Por exemplo: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  O banco de dados n√£o √© o culpado: ele obt√©m duas instru√ß√µes SQL e n√£o sabe nada sobre o fato de que o valor de x + 100 est√° de alguma forma relacionado ao valor das contas.  Evite escrever c√≥digo dessa maneira. <br></blockquote><br><h2>  Leitura Repet√≠vel </h2><br><h3>  A aus√™ncia de leituras n√£o repet√≠veis e fantasmas </h3><br>  O pr√≥prio nome do n√≠vel de isolamento assume que a leitura √© repet√≠vel.  Vamos verificar e, ao mesmo tempo, garantir que n√£o haja leituras fantasmas.  Para fazer isso, na primeira transa√ß√£o, revertemos as contas de Bob para o estado anterior e criamos uma nova conta para Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Na segunda sess√£o, iniciamos a transa√ß√£o com o n√≠vel Leitura Repet√≠vel, especificando-a no comando BEGIN (o n√≠vel da primeira transa√ß√£o n√£o √© essencial). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Agora a primeira transa√ß√£o confirma as altera√ß√µes e a segunda executa novamente a mesma consulta. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  A segunda transa√ß√£o ainda v√™ exatamente os mesmos dados que no in√≠cio: nenhuma altera√ß√£o nas linhas existentes ou novas linhas s√£o vis√≠veis. <br><br>  Nesse n√≠vel, voc√™ pode evitar se preocupar com algo que pode mudar entre dois operadores. <br><br><h3>  Erro de serializa√ß√£o em troca de altera√ß√µes perdidas </h3><br>  Discutimos anteriormente que, quando duas transa√ß√µes atualizam a mesma linha no n√≠vel Read Committed, pode ocorrer uma anomalia de leitura inconsistente.  Isso ocorre porque a transa√ß√£o em espera rel√™ a linha bloqueada e, portanto, n√£o a v√™ no mesmo ponto no tempo que as outras linhas. <br><br>  No n√≠vel de Leitura Repet√≠vel, essa anomalia n√£o √© permitida, mas se ocorrer, nada poder√° ser feito - portanto, a transa√ß√£o termina com um erro de serializa√ß√£o.  Vamos verificar repetindo o mesmo cen√°rio com acumula√ß√£o de juros: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Os dados permaneceram consistentes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  O mesmo erro ocorrer√° no caso de qualquer outra mudan√ßa competitiva de uma linha, mesmo que as colunas de nossa preocupa√ß√£o n√£o tenham sido realmente alteradas. <br><br>  <em>Conclus√£o pr√°tica</em> : se o seu aplicativo usar o n√≠vel de isolamento Leitura Repet√≠vel para transa√ß√µes de grava√ß√£o, ele dever√° estar pronto para repetir as transa√ß√µes que foram finalizadas com um erro de serializa√ß√£o.  Para transa√ß√µes somente leitura, esse resultado n√£o √© poss√≠vel. <br><br><h3>  Grava√ß√£o inconsistente </h3><br>  Portanto, no PostgreSQL, no n√≠vel de isolamento de Leitura Repet√≠vel, todas as anomalias descritas no padr√£o s√£o evitadas.  Mas nem todas as anomalias em geral.  Acontece que existem <em>exatamente duas</em> anomalias que ainda s√£o poss√≠veis.  (Isso √© verdade n√£o apenas no PostgreSQL, mas tamb√©m em outras implementa√ß√µes do Snapshot Isolation.) <br><br>  A primeira dessas anomalias √© uma <em>grava√ß√£o inconsistente</em> . <br><br>  Deixe a seguinte regra de consist√™ncia se manter: <em>valores negativos nas contas do cliente ser√£o permitidos se o valor total em todas as contas desse cliente permanecer n√£o negativo</em> . <br><br>  A primeira transa√ß√£o obt√©m o valor nas contas de Bob: ‚ÇΩ900. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  A segunda transa√ß√£o recebe a mesma quantidade. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  A primeira transa√ß√£o acredita que o valor de uma das contas pode ser reduzido em ‚ÇΩ600. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  E a segunda transa√ß√£o chega √† mesma conclus√£o.  Mas reduz outra conta: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Conseguimos fazer com que o saldo de Bob ficasse vermelho, embora cada transa√ß√£o estivesse funcionando corretamente sozinha. <br><br><h3>  Anomalia de transa√ß√£o somente leitura </h3><br>  Esta √© a segunda e a √∫ltima das anomalias poss√≠veis no n√≠vel de leitura repet√≠vel.  Para demonstr√°-lo, voc√™ precisar√° de tr√™s transa√ß√µes, duas das quais alterar√£o os dados e a terceira somente os ler√°. <br><br>  Mas primeiro vamos restaurar o estado das contas de Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Na primeira transa√ß√£o, s√£o acumulados juros sobre o valor dispon√≠vel em todas as contas de Bob.  Os juros s√£o creditados em uma de suas contas: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Em seguida, outra transa√ß√£o retira dinheiro da conta de outro Bob e confirma suas altera√ß√µes: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Se a primeira transa√ß√£o for confirmada neste momento, nenhuma anomalia ocorrer√°: poder√≠amos assumir que a primeira transa√ß√£o foi executada primeiro e depois a segunda (mas n√£o vice-versa porque a primeira transa√ß√£o viu o estado da conta com id = 3 antes disso). conta foi alterada pela segunda transa√ß√£o). <br><br>  Mas imagine que, nesse ponto, a terceira transa√ß√£o (somente leitura) comece, que l√™ o estado de alguma conta que n√£o √© afetada pelas duas primeiras transa√ß√µes: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  E somente depois que a primeira transa√ß√£o for conclu√≠da: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Que estado a terceira transa√ß√£o deve ver agora? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Uma vez iniciada, a terceira transa√ß√£o podia ver as altera√ß√µes da segunda transa√ß√£o (que j√° havia sido confirmada), mas n√£o da primeira (que ainda n√£o havia sido confirmada).  Por outro lado, j√° verificamos acima que a segunda transa√ß√£o deve ser considerada iniciada ap√≥s a primeira.  Qualquer que seja o estado que a terceira transa√ß√£o veja ser√° inconsistente - essa √© apenas a anomalia de uma transa√ß√£o somente leitura.  Mas no n√≠vel de leitura repet√≠vel, √© permitido: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serializable </h2><br>  O n√≠vel serializ√°vel evita todas as anomalias poss√≠veis.  De fato, o Serializable √© constru√≠do sobre o Isolamento de Instant√¢neo.  As anomalias que n√£o ocorrem com a leitura repetida (como uma leitura suja, n√£o repet√≠vel ou fantasma) tamb√©m n√£o ocorrem no n√≠vel serializ√°vel.  E aquelas anomalias que ocorrem (uma grava√ß√£o inconsistente e uma anomalia de transa√ß√£o somente leitura) s√£o detectadas e a transa√ß√£o √© interrompida - ocorre um erro familiar de serializa√ß√£o: <em>n√£o foi poss√≠vel serializar o acesso</em> . <br><br><h3>  Grava√ß√£o inconsistente </h3><br>  Para ilustrar isso, vamos repetir o cen√°rio com uma anomalia de grava√ß√£o inconsistente: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Assim como no n√≠vel de leitura repetida, um aplicativo que usa o n√≠vel de isolamento serializ√°vel deve repetir transa√ß√µes que terminaram com um erro de serializa√ß√£o, conforme a mensagem de erro nos solicitar. <br><br>  Ganhamos simplicidade de programa√ß√£o, mas o pre√ßo disso √© o encerramento for√ßado de alguma fra√ß√£o das transa√ß√µes e a necessidade de repeti-las.  A quest√£o, √© claro, √© o tamanho dessa fra√ß√£o.  Se apenas as transa√ß√µes encerradas se sobrep√µem incompativelmente a outras transa√ß√µes, teria sido bom.  Por√©m, essa implementa√ß√£o inevitavelmente exigiria muitos recursos e seria ineficiente porque voc√™ precisaria rastrear as opera√ß√µes em cada linha. <br><br>  Na verdade, a implementa√ß√£o do PostgreSQL √© tal que permite falsos negativos: algumas transa√ß√µes absolutamente normais que s√£o apenas ‚Äúazaradas‚Äù tamb√©m ser√£o abortadas.  Como veremos mais adiante, isso depende de muitos fatores, como a disponibilidade de √≠ndices apropriados ou a quantidade de RAM dispon√≠vel.  Al√©m disso, existem outras restri√ß√µes de implementa√ß√£o (bastante severas), por exemplo, consultas no n√≠vel Serializable n√£o funcionar√£o em r√©plicas e n√£o usar√£o planos de execu√ß√£o paralelos.  Embora o trabalho para melhorar a implementa√ß√£o continue, as limita√ß√µes existentes tornam esse n√≠vel de isolamento menos atraente. <br><blockquote>  Planos paralelos aparecer√£o j√° no PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patch</a> ).  E consultas sobre r√©plicas podem come√ßar a funcionar no PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outro patch</a> ). <br></blockquote><br><h3>  Anomalia de transa√ß√£o somente leitura </h3><br>  Para que uma transa√ß√£o somente leitura n√£o resulte em uma anomalia e n√£o sofra com ela, o PostgreSQL oferece uma t√©cnica interessante: essa transa√ß√£o pode ser bloqueada at√© que sua execu√ß√£o seja segura.  Este √© o √∫nico caso em que um operador SELECT pode ser bloqueado por atualiza√ß√µes de linha.  √â assim que se parece: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  A terceira transa√ß√£o √© declarada explicitamente READ ONLY e DEFERRABLE: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Ao tentar executar a consulta, a transa√ß√£o √© bloqueada porque, caso contr√°rio, causaria uma anomalia. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  E somente depois que a primeira transa√ß√£o √© confirmada, a terceira continua a execu√ß√£o: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Outra observa√ß√£o importante: se o isolamento serializ√°vel for usado, todas as transa√ß√µes no aplicativo dever√£o usar esse n√≠vel.  Voc√™ n√£o pode misturar transa√ß√µes Confirmadas de Leitura (ou Leitura Repet√≠vel) com Serializable.  Ou seja, voc√™ <em>pode</em> misturar, mas o Serializable se comportar√° como Leitura Repet√≠vel sem nenhum aviso.  Discutiremos por que isso acontece mais tarde, quando falarmos sobre a implementa√ß√£o. <br><br>  Portanto, se voc√™ decidir usar o Serializble, √© melhor definir globalmente o n√≠vel padr√£o (embora isso, √© claro, n√£o impe√ßa a especifica√ß√£o expl√≠cita de um n√≠vel incorreto): <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>  Voc√™ pode encontrar uma apresenta√ß√£o mais rigorosa das quest√µes relacionadas √†s transa√ß√µes, consist√™ncia e anomalias no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livro</a> e na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aula</a> de Boris Novikov ‚ÄúFundamentos das tecnologias de banco de dados‚Äù (dispon√≠vel apenas em Russion). <br></blockquote><br><h1>  Qual n√≠vel de isolamento usar? </h1><br>  O n√≠vel de isolamento Read Committed √© usado por padr√£o no PostgreSQL, e √© prov√°vel que esse n√≠vel seja usado na grande maioria dos aplicativos.  Esse padr√£o √© conveniente porque, nesse n√≠vel, um cancelamento de transa√ß√£o √© poss√≠vel apenas em caso de falha, mas n√£o como um meio de evitar inconsist√™ncia.  Em outras palavras, um erro de serializa√ß√£o n√£o pode ocorrer. <br><br>  O outro lado da moeda √© um grande n√∫mero de poss√≠veis anomalias, que foram discutidas em detalhes acima.  O engenheiro de software sempre deve mant√™-los em mente e escrever c√≥digo para n√£o permitir que eles apare√ßam.  Se voc√™ n√£o puder codificar as a√ß√µes necess√°rias em uma √∫nica instru√ß√£o SQL, precisar√° recorrer ao bloqueio expl√≠cito.  O mais problem√°tico √© que o c√≥digo √© dif√≠cil de testar quanto a erros associados √† obten√ß√£o de dados inconsistentes, e os pr√≥prios erros podem ocorrer de maneiras imprevis√≠veis e n√£o reproduz√≠veis e, portanto, dif√≠ceis de corrigir. <br><br>  O n√≠vel de isolamento de leitura repetida elimina alguns dos problemas de inconsist√™ncia, mas, infelizmente, n√£o todos.  Portanto, voc√™ n√£o deve se lembrar apenas das anomalias restantes, mas tamb√©m modificar o aplicativo para que ele lide corretamente com erros de serializa√ß√£o.  Certamente √© inconveniente.  Mas para transa√ß√µes somente leitura, esse n√≠vel complementa perfeitamente o Read Committed e √© muito conveniente, por exemplo, para criar relat√≥rios que usam v√°rias consultas SQL. <br><br>  Finalmente, o n√≠vel serializ√°vel permite que voc√™ n√£o se preocupe com a inconsist√™ncia, o que facilita muito a codifica√ß√£o.  A √∫nica coisa necess√°ria ao aplicativo √© poder repetir qualquer transa√ß√£o ao obter um erro de serializa√ß√£o.  Mas a fra√ß√£o de transa√ß√µes interrompidas, a sobrecarga adicional e a incapacidade de paralelizar consultas podem reduzir significativamente a taxa de transfer√™ncia do sistema.  Observe tamb√©m que o n√≠vel serializ√°vel n√£o √© aplic√°vel em r√©plicas e que n√£o pode ser misturado com outros n√≠veis de isolamento. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467437/">https://habr.com/ru/post/pt467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467423/index.html">Xamarin.Forms - uso conveniente de fontes de √≠cone no aplicativo</a></li>
<li><a href="../pt467425/index.html">Abordagem intensiva de aprendizagem STEM</a></li>
<li><a href="../pt467427/index.html">BudgetTracker - outra ferramenta de c√≥digo aberto para contabilidade de finan√ßas pessoais</a></li>
<li><a href="../pt467429/index.html">Habrastatistics: explorando as se√ß√µes mais e menos visitadas do site</a></li>
<li><a href="../pt467435/index.html">Enviamos relat√≥rios do agente Veeam Linux para o correio ou no Telegram</a></li>
<li><a href="../pt467439/index.html">Por que o vinil voltou e como os servi√ßos de streaming est√£o relacionados a isso?</a></li>
<li><a href="../pt467443/index.html">Centro Multim√≠dia "Kodi" e Projeto Yocto</a></li>
<li><a href="../pt467445/index.html">Lista indescrit√≠vel de atualiza√ß√µes instaladas do Windows</a></li>
<li><a href="../pt467449/index.html">Detec√ß√£o de vulnerabilidades e avalia√ß√£o da resist√™ncia a ataques de hackers de cart√µes inteligentes e processadores de criptografia com prote√ß√£o integrada</a></li>
<li><a href="../pt467453/index.html">Resolvendo o problema do n√∫mero 42 usando um supercomputador planet√°rio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>