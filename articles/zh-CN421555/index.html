<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏾 🧢 👨🏾‍⚖️ WideNES项目-超越NES屏幕的边界 👨🏾‍💼 📖 🆖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在1980年代中期，任天堂娱乐系统（NES）是必不可少的控制台。 当时所有控制台中最好的声音，最好的图形和最好的游戏-控制台扩大了可能的界限。 到目前为止， Super Mario Bros等项目。 ， 《塞尔达传说》和《 银河战士》被认为是有史以来最好的游戏。 

 NES发布30多年后，经典游戏...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WideNES项目-超越NES屏幕的边界</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421555/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif" alt="图片"></div><br> 在1980年代中期，任天堂娱乐系统（NES）是必不可少的控制台。 当时所有控制台中最好的声音，最好的图形和最好的游戏-控制台扩大了可能的界限。 到目前为止， <em>Super Mario Bros</em>等项目<em>。</em>  ， <em>《塞尔达传说》</em>和《 <em>银河战士》</em>被认为是<em>有史以来</em>最好的游戏。 <br><br>  NES发布30多年后，经典游戏的感觉很棒，这不能说它们使用的硬件。 由于只有256x240的分辨率，NES控制台无法为游戏提供足够的空间。 尽管如此，无所畏惧的开发人员还是成功地融入了NES游戏中，令人难以忘怀的世界：《 <em>塞尔达传说</em> 》迷宫般的地牢， <em>《</em> <em>银河战士</em> 》中星球的广阔空间，《 <em>超级马里奥兄弟》的</em>明亮水准。  。 但是，由于NES硬件限制，播放器永远不能超过256x240 ... <br><br> 直到最近。 <br><br> 我向您介绍了<strong>wideNES</strong>项目-一种播放NES经典音乐的新方法！ <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/157/9b0/9211579b0ba7322cf563254fcd26c9cc.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/433/ea0/dcd433ea06a9dec672c3457d76ee2181.gif"></div><br>  <strong>wideNES</strong>是一项新技术， <em>可以</em> <em>实时</em> <em>自动地</em> <em>交互式</em>标记NES游戏。 <br><br> 当玩家在关卡中移动时，wideNES会记录屏幕，并逐步构建世界探索区域的地图。 在随后的级别中，wideNES将屏幕上的游戏玩法与生成的地图同步，从本质上允许玩家通过“超越” NES屏幕的边界来查看更多内容！ 最重要的是，您对wideNES游戏进行标记的方式是<em>完全通用的</em> ，这使各种NES游戏无需任何配置即可与wideNES一起使用！ <br><br> 但是，这一切如何运作？ <br><br><hr><br> 如果您想在阅读本文之前检查widthNES的工作原理，请！  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ANESE</a>是我编写的NES模拟器，目前是唯一实现wideNES的模拟器。 但是，值得警告的是，就UI和仿真准确性而言，ANESE <em>并不是世界上</em>最好的NES模拟器。 大多数功能（包括包含wideNES）只能通过命令行使用，尽管许多受欢迎的游戏都能正常工作，但其他一些游戏的行为却可能出乎意料。 <br><br><hr><br><h2>  NES的工作原理 </h2><br> 在深入研究细节之前，重要的是简要解释NES如何渲染图形。 <br><br><h3> 使用PPU进行像素传输 </h3><br>  NES的核心是古老的MOS 6502处理器，在70年代末和80年代初，6502 <em>随处可见</em> ，并在Commodore 64，Apple II等传奇机器中工作。 它便宜，易于编程且功能强大<em>到足以</em>引起危险。 <br><br> 在NES控制台中补充6502是一个功能强大的图形协处理器，称为<em>图像处理单元</em> （PPU）。 与旧系统上使用的简单视频协处理器相比，PPU在可用性方面有了巨大的改进。 例如，在发布NES的五年之前，Atari 2600处理器6502被用于将图形指令传输到<em>每个光栅行</em>的协处理器，这使处理器几乎没有时间执行游戏逻辑。 为了进行比较：PPU <em>每帧</em>只需要几个命令，这给6502提供了足够的时间来创建有趣和创新的游戏玩法。 <br><br>  PPU是一个了不起的芯片，其渲染图形的方式几乎与现代GPU的工作不同，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将需要一系列</a>完整<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文章</a>来全面说明其功能。 由于wideNES仅使用PPU功能的一小部分，因此只需简要考虑一下即可： <br><br><ul><li> 分辨率：256x240像素，60 Hz </li><li> 它独立于CPU工作 <br><ul><li> 使用<em>具有内存映射的I / O与</em> CPU进行通信（地址范围0x2000-0x2007） </li></ul></li><li>  2个渲染层： <strong>精灵</strong>层和<strong>背景</strong>层 <ul><li>  <strong>精灵层</strong> <br><ul><li> 每个精灵可以放置在屏幕上的任何位置。 </li><li> 非常适合移动物体：玩家，敌人，炮弹 </li><li> 多达64个8x8像素精灵 </li></ul></li><li>  <strong>背景层</strong> <br><ul><li> 绑在网格上 </li><li> 非常适合静态元素：平台，大障碍物，装饰品 </li><li> 视频内存足以存储大小为8x8像素的64x30瓦片 <br><ul><li> 真正的<em>内部</em>分辨率512x240，视口为256x240 </li><li> 支持<strong><em>硬件滚动</em></strong>以更改256x240视口 <br><ul><li>  PPUSCROLL寄存器（地址0x2005）控制X / Y中视口的移位 </li></ul></li></ul></li></ul></li></ul></li></ul><br> 在处理了这个<em>非常</em>简短的概述之后，让我们继续进行最有趣的事情：wideNES是如何工作的？ <br><br><h3> 主要思想 </h3><br> 在每个帧的末尾，CPU将更改信息发送到PPU。 其中包括新的精灵位置，新的关卡数据，以及对于newNES至关重要的<em>新视口偏移</em> 。 由于wideNES可以在仿真器中运行，因此我们很容易跟踪写入PPUSCROLL寄存器的值，这意味着计算屏幕在任意两帧之间移动了多少非常容易！ <br><br> 嗯，如果不是将每个新帧<em>直接</em>绘制<em>在</em>旧帧上，而是将新帧<em>叠加</em>在前一帧上绘制，而是移动到当前滚动值，将会发生什么情况？ 然后，随着时间的流逝，关卡中越来越大的部分将保留在屏幕上，逐渐构建关卡的完整图片！ <br><br> 为了检查这个想法是否有价值，我快速草绘了第一个实现。 <br><br> 编译... <br> 发射中... <br> 下载<em>超级马里奥兄弟。</em>  ... <br><br> 瞧！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/7cb/c7f/1ed7cbc7ff1998d1f5f19af6ca09bb54.gif"></div><br> 奏效了！ <br><br> 好像是... <br><br><hr><br><h3> 另一种方法：为什么不直接从ROM文件中提取级别？ </h3><br> 甚至无需考虑实现细节，很明显，该技术存在严重的局限性：只有当玩家独立探索整个游戏时，才能收集完整的游戏地图。 <br><br> 如果有某种方法可以从<em>原始</em> NES ROM中提取电平，该怎么办？ <br><br> 这样的技术还能存在吗？ <br><br> 好吧，很可能不会。 <br><br> 如果您为NES玩任何两款游戏，则可以保证它们只有一个共同点-它们都适用于NES。 其他一切都可以完全不同！ 这样的不匹配是一场真正的灾难，因为NES游戏本质上具有用于存储关卡数据的无限多个选项！ <br><br> 有些人通过逆向工程以存储<em>几个</em>游戏的关卡数据的方式提取了完整关卡（有时会创建全功能的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地图编辑器</a> ！），但这是一项艰巨的任务，需要大量的工作，毅力和智慧。 <br><br> 为了从ROM中提取级别数据，必须确定ROM的哪些部分是代码（不是数据），这很难做到，因为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在二进制文件中查找所有代码等同于停止问题</a> ！ <br><br>  WideNES使用更简单的方法：wideNES无需猜测游戏如何将关卡数据打包到ROM中，而是直接启动游戏并跟踪输出！ <br><br><hr><br><h3> 滚动到255以上 </h3><br>  NES是一个8位系统，即PPUSCROLL寄存器只能接收8位值。 这将最大滚动偏移量限制为255个像素，即最大8位数字。  NES屏幕分辨率为240x256像素，这不是巧合，即255像素的偏移<em>量足以</em>滚动整个屏幕。 <br><br> 但是，滚动<em>超过</em> 255会发生什么？ <br><br> 首先，游戏将PPUSCROLL寄存器重置为0。这解释了当Mario向右移得太远时，为什么将<em>SMB</em>传送到开头。 <br><br> 然后，为了补偿8位的PPUSCROLL限制，游戏将更新另一个PPU寄存器：PPUCTRL（地址0x2000）。  PPUCTRL的后2位以全屏增量设置当前场景的“起点”。 例如，写入值1将视口向右移动256像素；值2将视口向下移动240像素。 使用PPUSCROLL寄存器将PPUCTRL偏移量压入<em>堆栈</em> ，这使您可以在512像素内水平滚动屏幕或在480像素内垂直滚动屏幕。 <br><br> 但是构建时，是否只有足够的视频内存用于两级屏幕？ 当视口向右滚动太远并“超出” VRAM时会发生什么？ 为了处理这种情况，PPU进行了卷积：将所选视频存储器之外的所有视口部分简单地折叠到视频存储器的相对边缘。 <br><br> 这种折叠结合智能的PPUSCROLL和PPUCTRL寄存器操作，使NES游戏能够创造出无限高大世界的错觉！ 由于延迟将部分关卡延迟加载到查看窗口之外并逐步滚动到其中，因此玩家从未意识到在VRAM内部他们实际上是“绕圈运行”！ <br><br>  nesdev Wiki上的一个极好的插图显示了《 <em>超级马里奥兄弟》的制作过程。</em> 使用这些属性创建的级别超过两个屏幕： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif"></div><br> 让我们回到我们正在讨论的问题：wideNES如何处理超过256的滚动？ <br><br> 好吧，坦率地说，wideNES会<em>完全忽略</em> PPUCTRL寄存器，而只是跟踪帧之间的PPUSCROLL差异！ <br><br> 如果PPUSCROLL意外地跳到256，这通常意味着玩家的角色在屏幕上向左/向上移动，并且如果他意外地跳到了大约0，则通常意味着玩家在屏幕上向右/向下移动。 <br><br> 尽管这种启发式方法看起来很简单-的确如此-实际上，它很好用！ <br><br> 实施了这种启发式后， <em>超级马里奥兄弟。</em>  ，《 <em>银河战士》</em>和许多其他游戏几乎完美运行！ <br><br> 我很激动，所以我继续上传了另一个NES经典作品- <em>超级马里奥兄弟。</em>  <em>3</em> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a21/1ee/233/a211ee233bcdea56af5b983f9b8715cf.gif"></div><br> 嗯...不是很漂亮。 <br><br><h3> 忽略静态屏幕元素 </h3><br> 许多游戏在屏幕边缘都有静态UI元素。 对于<em>SMB3，</em>这是左侧的一列，状态的底部是状态栏。 <br><br> 默认情况下，从屏幕边缘以16像素为增量递增的widthNES采样，即，对边缘的所有静态元素进行采样！ 不好！ <br><br> 为了解决这个问题，wideNES实施了规则和试探法，试图自动识别和掩盖静态屏幕元素。 <br><br> 通常，NES游戏使用三种不同类型的静态屏幕元素：HUD，蒙版和状态栏。 <br><br><h4>  HUD-没问题 </h4><br> 如果游戏在某个关卡之上强加了HUD，则HUD可能包含多个子画面。 示例： <em>Metroid中的</em> HUD。 <br><br> 幸运的是，这样的HUD不会引起问题，因为wideNES当前只是忽略了子画面层。 太好了！ <br><br><h4> 口罩-轻松无比 </h4><br>  PPU具有允许游戏掩盖背景层最左边8个像素的功能。 通过设置寄存器的第二位（地址0x2001）将其激活。 许多游戏都使用此功能，但是解释<em>为什么</em>这样做超出了本文的范围。 <br><br> 识别包含的掩码非常简单：当寄存器中的第二个位置1时，wideNES只会跟踪PPUMASK值，而忽略最左边的8个像素！ <br><br> 似乎实现此简单规则可以解决<em>SMB3的</em>问题： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/6ce/6ce/8e56ce6ce6e3f59203422816794e21de.gif"></div><br>  ...很好，或<em>几乎被</em>淘汰。 <br><br><h4> 状态栏最难 </h4><br> 由于PPU在屏幕上任何给定时间的限制，最多只能有64个精灵。 而且，任何时候， <em>每条栅格线中</em>最多只能包含8个精灵。 此限制阻止开发人员根据子画面创建复杂的HUD，并迫使他们使用背景层的一部分来显示信息。 <br><br> 除了遮罩外，PPU中没有简单的方法将背景层分为游戏区域和状态区域。 因此，开发人员开始花样，导致产生了一系列<em>非常规的</em>方式来创建状态面板... <br><br>  WideNES使用各种启发式方法来识别不同类型的状态面板，但是为了节省时间，我将仅考虑最有趣的一种：中帧IRQ跟踪。 <br><br><h3> 中帧IRQ跟踪 </h3><br> 与具有大型内部帧缓冲区的现代GPU不同，PPU <em>通常没有帧缓冲区！</em> 为了节省空间，PPU将场景存储为8x8像素的64x32瓦片网格。 无需预先计算像素数据，而是将切片存储为<em>指向</em> CHR存储器（字符存储器）的<em>指针</em> ，该寄存器包含所有像素数据。 <br><br> 由于NES是在80年代开发的，因此PPU的创建没有考虑现代显示技术。  PPU而不是同时渲染整个帧，而是输出NTSC视频信号，该信号应显示在CRT屏幕上，该CRT屏幕<em>逐像素</em> ， <em>逐行</em> ，从上至下，从上至下，从左至右显示视频。 <br><br> 为什么这一切都很重要？ <br><br> 由于PPU逐行从上到下渲染帧，因此您可以将PPU指令发送到<em>中间帧</em>以创建其他任何方法都无法实现的视频效果！ 这些效果可以很简单（例如，更改调色板），也可以很复杂（例如，您猜到了，创建状态栏！）。 <br><br> 为了解释中帧PPU写入如何创建状态栏，我记录了单个<em>SMB3</em>帧的原始PPU和CHR内存视频切片转储： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/565/049/cf6565049202c1a832222de6edb291c3.png"></div><br> 一切看起来都很好，没什么特别的……只是看看状态栏！ 她完全扭曲了！ <br><br> 现在看相同的原始转储，但在第196行之后制作的... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/8e4/be6/5df8e4be6a32dcefa00429da5fbb4755.png"></div><br> 是的，等级看起来很糟糕，但是状态栏看起来很棒！ <br><br> 这是怎么回事 <br><br>  <em>SMB3</em>设置了一个计时器，恰好在渲染195栅格线之后触发IRQ（中断），并将以下指令传递给IRQ处理程序： <br><br><ul><li> 将PPUSCROLL设置为（0,0）（以便状态栏保持原位） </li><li> 我们将磁贴卡替换为CHR内存（按顺序排列了状态栏的图形） </li></ul><br> 由于层的其余部分已经渲染，因此PPU不会“重新更新”帧。 取而代之的是，它将继续使用这些选项进行渲染，显示出美丽的未变形状态栏！ <br><br> 让我们回到wideNES：通过观察帧中间的所有IRQ并记住发生它们的栅格线，wideNES可以忽略记录中的所有后续栅格线！ 如果IRQ出现在240/2以上的光栅行中，则所有<em>先前的</em>行都将被忽略，因为光栅线的早期中断意味着状态栏可能<em>位于</em>屏幕<em>顶部</em> 。 <br><br> 实施了这种启发式后， <em>超级马里奥兄弟。</em>  <em>3分</em>完美！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/44a/b08/14644ab0880d7a2827bcad22d028a0be.gif"></div><br><hr><br> 我简要考虑了使用计算机视觉库（例如OpenCV）来识别状态面板（或屏幕的其他大部分静态区域）的可能性，但结果我决定放弃它。 使用庞大，复杂且不透明的计算机视觉库违反了wideNES的理想，在这种情况下，我尝试使用紧凑，简单且透明的规则和启发式方法来获得结果。 <br><br><hr><br><h3> 场景识别 </h3><br> 除了一些著名的示例（例如<em>Metroid</em> ）以外，NES游戏通常<em>不会</em>在一个巨大的，密不可分的层次上通过。 相反，大多数NES游戏被分为许多小的独立“场景”，它们之间带有门或过渡屏幕。 <br><br> 由于wideNES没有“场景”的概念，因此在更改场景时会发生坏事... <br><br> 例如，这是<em>恶魔城</em>场景的第一个过渡，西蒙·贝尔蒙特进入了德古拉的城堡： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/b5b/8e4/7f7b5b8e4edf5c31dd19682b333d75c9.gif"></div><br> 哇，一切都不好！  wideNES用新关卡的第一个屏幕完全重写了关卡的最后部分！ <br><br> 显然，wideNES需要某种方式来识别场景变化。 但是哪一个呢？ <br><br>  <em>感知哈希！</em> <br><br> 不同于通常在输出信息空间中均匀分布相似输入数据的<em>密码</em>散列函数， <em>感知</em>散列函数试图使相似的输入数据在输出数据空间中彼此保持“接近”。 因此，感知哈希是识别相似图像的理想选择！ <br><br> 感知哈希函数可能非常复杂，如果其中之一被旋转，缩放，拉伸以及其中的颜色发生了变化，它们中的一些就能识别相似的图像。 幸运的是，wideNES不需要复杂的哈希函数，因为可以保证每个帧都具有相同的大小。 因此，wideNES使用现有感知哈希中最简单的哈希： <em>将屏幕上的所有像素相加！</em> <br><br> 很简单，但是效果很好！ <br><br> 例如，在<em>《塞尔达传说》中</em> ，查看绘制随时间变化的感<em>观</em>哈希值，看看场景之间的过渡效果如何： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/799/5e3/f077995e3d509802139543805d7ae61b.png"></div><br> 当前，wideNES使用感知哈希值之间的固定阈值来完成场景之间的转换，但是结果远非理想。 不同的游戏使用不同的调色板，并且在很多情况下，wideNES认为过渡已经发生，但实际上并非如此。 理想情况下，wideNES应该使用动态阈值，但到目前为止，固定阈值仍可以使用。 <br><br> 实施了这种新的启发式方法之后，wideNES成功地识别了西蒙从<em>恶魔城</em>到城堡的入口，并因此创建了新的画布。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/6da/e81/6446dae81018592433a99f4f50a8b4d0.gif"></div><br> 有了这个决定，我们就完成了WideNES难题的最后一个主要部分。 <br><br> 实现了最简单的序列化之后，我终于能够为NES运行游戏，可以在多个级别玩，并自动生成级别图！ <br><br><h2> 将来有什么等待广阔？ </h2><br>  wideNES由两个独立的部分组成：wideNES <em>内核</em> （这是该技术的基本规则/启发法），以及ANESE仿真器内部的wideNES的特定实现。 <br><br><h3>  WideNES <em>核心</em>增强 </h3><br> 首先，wideNES倾向于过于激进地识别场景之间的过渡。 可以通过使用更合适的感知哈希算法或在感知哈希之间切换到动态阈值来最大程度地减少误报的数量。 <br><br> 识别静态屏幕元素还需要进行其他工作。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如，《</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Megaman IV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">》在帧的中间有一个IRQ，但是没有状态栏，这就是为什么wideNES会错误地忽略比赛场地的坚实部分的原因。尽管可以通过手动调整来纠正这种特殊情况，但是最好使用更智能的启发式方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">某些NES游戏以“独特”方式滚动屏幕。最著名的例子之一是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《塞尔达传说》</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它使用PPUSCROLL进行水平滚动，但使用完全不同的寄存器进行垂直滚动-PPUADDR。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">塞尔达传说（Zelda）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一款相当受欢迎的游戏，因此WideNES专门针对</font><em><font style="vertical-align: inherit;">塞尔达传说</font></em><font style="vertical-align: inherit;">实施启发式</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。还有其他具有类似“独特”滚动模式的游戏，它们也需要单独的试探法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到某种方式来“缝合”相同的场景将很有用。例如，如果用户玩《</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超级马里奥兄弟》。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">级别1，但爬入管道中并带着硬币进入地下洞穴，wideNES将为级别1创建两个单独的场景：场景A，级别直到马里奥进入装有硬币的区域，场景B，即刻开始当马里奥（Mario）离开水管到达旗杆时。如果游戏随后重新启动并且在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进入管道的</font><em><font style="vertical-align: inherit;">情况下</font></em><font style="vertical-align: inherit;">重新播放了1级</font><font style="vertical-align: inherit;">，则wideNES将仅更新场景A，其中将包含完整级别的地图，而场景B将“中断”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，wideNES必须跟踪场景之间的过渡。</font><font style="vertical-align: inherit;">没有这些数据，就不可能构造场景之间的过渡图来生成</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含单个大世界</font><font style="vertical-align: inherit;">的游戏世界地图</font><font style="vertical-align: inherit;">。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 改善ANESE中wideNES的实施 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前，wideNES仅在我以ANESE名义编写的NES模拟器中实现。 ANESE是一款</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出色的</font><font style="vertical-align: inherit;">Spartan模拟器：大多数选项都隐藏在CLI标志后面，并且唯一实现的UI是最简单的文件选择覆盖！他仍然是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从“生产”的水平为止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了缺少UI，ANESE和wideNES外，兼容性和速度方面的改进也不会受到损害。 ANESE是我编写的第一个仿真器，非常引人注目！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其中存在很多兼容性问题-许多游戏无法正常运行或根本无法启动。幸运的是，ANESE的不完善并不意味着WideNES是一项不良技术。 wideNES是基于久经考验的原理构建的，在其他仿真器中将易于实现！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在速度方面，ANESE和wideNES并不完美，即使在功能相对强大的PC上，性能有时也可能低于60fps！ ANESE和wideNES需要实施许多优化。除了对ANESE内核的总体改进之外，还需要改进WideNES帧记录，地图渲染和哈希采样。</font></font><br><br><h2> 结论 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我讨论了wideNES的主要方面，但是无法描述许多小的功能。例如，wideNES存储每个帧的真实哈希值和滚动值的映射，用于启用重复场景。此功能和许多其他功能</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在WideNES项目页面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上发布的广泛评论的wideNES源代码中进行</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">了描述</font></a><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在wideNES上工作确实是一次了不起的经历，但是随着沃特洛大学新学期的到来，我怀疑在不久的将来我能否继续开发wideNES。目前，wideNES的主要功能正在运行，我很高兴能够撰写这篇介绍其某些技术的文章！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尝试使用wideNES并分享您的感受！</font><font style="vertical-align: inherit;">下载</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANESE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，启动</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超级马里奥兄弟。</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《塞尔达传说》</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或《</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">银河战士》</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后以新方式玩！</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421555/">https://habr.com/ru/post/zh-CN421555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421545/index.html">PocketBook 616的评论-具有背光功能的最经济实惠的2018袖珍本</a></li>
<li><a href="../zh-CN421547/index.html">独立数据中心验收</a></li>
<li><a href="../zh-CN421549/index.html">我们正在编写技术文档：外行指南</a></li>
<li><a href="../zh-CN421551/index.html">精通Vuex-从零到英雄</a></li>
<li><a href="../zh-CN421553/index.html">我们共享技术内容：我们在一个站点上收集了所有材料</a></li>
<li><a href="../zh-CN421557/index.html">公开课“ Java异步编程”</a></li>
<li><a href="../zh-CN421559/index.html">iOS应用程序中的组件UI架构</a></li>
<li><a href="../zh-CN421563/index.html">您可能需要改坐以摆脱背部疼痛。</a></li>
<li><a href="../zh-CN421565/index.html">粗鲁的类人机器人如何欺骗您</a></li>
<li><a href="../zh-CN421567/index.html">讨论：不寻常的便携式音响-跑车，复古收音机和“音响靴”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>