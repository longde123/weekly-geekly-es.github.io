<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍥 📷 👏🏾 Membuat aplikasi web modern dari awal 👚 👨🏻‍🚒 💠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi, Anda memutuskan untuk membuat proyek baru. Dan proyek ini adalah aplikasi web. Berapa banyak waktu yang diperlukan untuk membuat prototipe dasar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat aplikasi web modern dari awal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444446/"> Jadi, Anda memutuskan untuk membuat proyek baru.  Dan proyek ini adalah aplikasi web.  Berapa banyak waktu yang diperlukan untuk membuat prototipe dasar?  Seberapa sulit?  Apa yang harus dapat dilakukan oleh situs web modern sejak awal? <br><br>  Pada artikel ini, kami akan mencoba menguraikan boilerplate dari aplikasi web sederhana dengan arsitektur berikut: <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ul/ne/9v/ulne9vljujdrtxnf-qeqrrux7da.png"></a> </div><br>  Apa yang akan kita bahas: <br><br><ul><li>  mengatur lingkungan dev di docker-compose. </li><li>  pembuatan backend pada Flask. </li><li>  membuat tampilan depan pada Express. </li><li>  Bangun JS menggunakan Webpack. </li><li>  Bereaksi, Redux, dan rendering sisi server. </li><li>  tugas antrian dengan RQ. </li></ul><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Sebelum pengembangan, tentu saja, Anda harus terlebih dahulu memutuskan apa yang kami kembangkan!  Sebagai aplikasi model untuk artikel ini, saya memutuskan untuk membuat mesin wiki primitif.  Kami akan mengeluarkan kartu dalam penurunan harga;  mereka dapat ditonton dan (suatu saat nanti) menawarkan suntingan.  Semua ini akan kami atur sebagai aplikasi satu halaman dengan rendering sisi server (yang mutlak diperlukan untuk mengindeks terabyte konten kami di masa mendatang). <br><br>  Mari kita lihat lebih detail komponen yang kita butuhkan untuk ini: <br><br><ul><li>  <b>Pelanggan</b>  Kami akan membuat aplikasi satu halaman (mis. Dengan transisi halaman menggunakan AJAX) pada bundel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux</a> , yang sangat umum di dunia front-end. </li><li>  <b>Frontend</b> .  Mari kita membuat server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Express</a> sederhana yang akan membuat aplikasi Bereaksi kami (meminta semua data yang diperlukan di backend secara tidak sinkron) dan mengeluarkannya kepada pengguna. </li><li>  <b>Backend</b> .  Master logika bisnis, backend kami akan menjadi aplikasi Flask kecil.  Kami akan menyimpan data (kartu kami) di repositori dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MongoDB yang</a> populer, dan untuk antrian tugas dan, mungkin, di masa mendatang, caching, kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redis</a> . </li><li>  <b>PEKERJA</b> .  Wadah terpisah untuk tugas berat akan diluncurkan oleh perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RQ</a> . </li></ul><br><h2>  Infrastruktur: git </h2><br>  Mungkin, kita tidak bisa membicarakan hal ini, tetapi, tentu saja, kita akan melakukan pengembangan di repositori git. <br><br><pre><code class="bash hljs">git init git remote add origin git@github.com:Saluev/habr-app-demo.git git commit --allow-empty -m <span class="hljs-string"><span class="hljs-string">"Initial commit"</span></span> git push</code> </pre> <br>  (Di sini Anda harus segera mengisi <code>.gitignore</code> .) <br><br>  Draf akhir dapat dilihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Github</a> .  Setiap bagian dari artikel sesuai dengan satu komit (saya banyak rebazed untuk mencapai ini!). <br><br><h2>  Infrastruktur: komposisi buruh pelabuhan </h2><br>  Mari kita mulai dengan mengatur lingkungan.  Dengan banyaknya komponen yang kita miliki, solusi pengembangan yang sangat logis adalah menggunakan docker-compose. <br><br>  Tambahkan file <code>docker-compose.yml</code> ke repositori <code>docker-compose.yml</code> konten berikut: <br><br><pre> <code class="plaintext hljs">version: '3' services: mongo: image: "mongo:latest" redis: image: "redis:alpine" backend: build: context: . dockerfile: ./docker/backend/Dockerfile environment: - APP_ENV=dev depends_on: - mongo - redis ports: - "40001:40001" volumes: - .:/code frontend: build: context: . dockerfile: ./docker/frontend/Dockerfile environment: - APP_ENV=dev - APP_BACKEND_URL=backend:40001 - APP_FRONTEND_PORT=40002 depends_on: - backend ports: - "40002:40002" volumes: - ./frontend:/app/src worker: build: context: . dockerfile: ./docker/worker/Dockerfile environment: - APP_ENV=dev depends_on: - mongo - redis volumes: - .:/code</code> </pre><br>  Mari kita lihat apa yang terjadi di sini. <br><br><ul><li>  Wadah MongoDB dan wadah Redis dibuat. </li><li>  Sebuah wadah untuk backend kami dibuat (yang kami jelaskan di bawah).  Variabel lingkungan APP_ENV = dev diteruskan ke sana (kami akan melihatnya untuk memahami pengaturan Flask apa yang akan dimuat), dan porta 40001 akan terbuka di luar (melalui itu klien browser kami akan pergi ke API). </li><li>  Wadah dari frontend kami dibuat.  Berbagai variabel lingkungan juga dimasukkan ke dalamnya, yang akan berguna bagi kita nanti, dan port 40002 terbuka. Ini adalah port utama aplikasi web kita: di browser kita akan pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 40002</a> . </li><li>  Wadah pekerja kami dibuat.  Dia tidak membutuhkan port eksternal, dan hanya akses yang diperlukan di MongoDB dan Redis. </li></ul><br>  Sekarang mari kita buat file docker.  Saat ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hebat</a> tentang Docker akan hadir di Habré - Anda dapat dengan aman pergi ke sana untuk semua detailnya. <br><br>  Mari kita mulai dengan backend. <br><br><pre> <code class="plaintext hljs"># docker/backend/Dockerfile FROM python:stretch COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ADD . /code WORKDIR /code CMD gunicorn -w 1 -b 0.0.0.0:40001 --worker-class gevent backend.server:app</code> </pre><br>  Dapat dipahami bahwa kita menjalankan aplikasi flask gunicorn, bersembunyi di bawah nama <code>app</code> di modul <code>backend.server</code> . <br><br>  <code>docker/backend/.dockerignore</code> tidak kalah pentingnya: <br><br><pre> <code class="plaintext hljs">.git .idea .logs .pytest_cache frontend tests venv *.pyc *.pyo</code> </pre><br>  Pekerja itu umumnya mirip dengan backend, hanya saja bukannya gunicorn kita memiliki peluncuran modul pit yang biasa: <br><br><pre> <code class="plaintext hljs"># docker/worker/Dockerfile FROM python:stretch COPY requirements.txt /tmp/ RUN pip install -r /tmp/requirements.txt ADD . /code WORKDIR /code CMD python -m worker</code> </pre><br>  Kami akan melakukan semua pekerjaan di <code>worker/__main__.py</code> . <br><br>  Pekerja <code>.dockerignore</code> benar-benar mirip dengan backend <code>.dockerignore</code> . <br><br>  Akhirnya, frontend.  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seluruh artikel terpisah</a> tentang dia di Habré, tetapi menilai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi yang luas tentang StackOverflow</a> dan komentar dalam semangat "Guys, apakah sudah 2018, apakah masih ada solusi normal?"  semuanya tidak begitu sederhana di sana.  Saya menyelesaikan versi file buruh pelabuhan ini. <br><br><pre> <code class="plaintext hljs"># docker/frontend/Dockerfile FROM node:carbon WORKDIR /app #  package.json  package-lock.json   npm install,   . COPY frontend/package*.json ./ RUN npm install #       , #     PATH. ENV PATH /app/node_modules/.bin:$PATH #      . ADD frontend /app/src WORKDIR /app/src RUN npm run build CMD npm run start</code> </pre><br>  Pro: <br><br><ul><li>  semuanya di-cache seperti yang diharapkan (di lapisan bawah - dependensi, di atas - pembuatan aplikasi kita); </li><li>  <code>docker-compose exec frontend npm install --save newDependency</code> berfungsi sebagaimana mestinya dan memodifikasi <code>package.json</code> dalam repositori kami (yang tidak akan menjadi masalah jika kami menggunakan COPY, seperti yang disarankan banyak orang).  Akan tidak diinginkan untuk menjalankan <code>npm install --save newDependency</code> luar wadah, karena beberapa dependensi dari paket baru mungkin sudah ada dan dibangun di bawah platform yang berbeda (di bawah yang di dalam buruh pelabuhan, dan tidak di bawah macbook kami yang bekerja, misalnya ), namun kami umumnya tidak ingin memerlukan kehadiran Node pada mesin pengembangan.  Satu Docker untuk menguasai semuanya! </li></ul><br>  Baik dan tentu saja <code>docker/frontend/.dockerignore</code> : <br><br><pre> <code class="plaintext hljs">.git .idea .logs .pytest_cache backend worker tools node_modules npm-debug tests venv</code> </pre><br>  Jadi, kerangka kontainer kami sudah siap dan Anda dapat mengisinya dengan konten! <br><br><h2>  Backend: Kerangka kerja flask </h2><br>  Tambahkan <code>flask</code> , <code>flask-cors</code> <code>gevent</code> , <code>gevent</code> dan <code>gunicorn</code> ke <code>requirements.txt</code> dan buat aplikasi Flask sederhana di <code>backend/server.py</code> . <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/server.py import os.path import flask import flask_cors class HabrAppDemo(flask.Flask): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # CORS        #    ,      # (  Access-Control-Origin  ). #   - . flask_cors.CORS(self) app = HabrAppDemo("habr-app-demo") env = os.environ.get("APP_ENV", "dev") print(f"Starting application in {env} mode") app.config.from_object(f"backend.{env}_settings")</span></span></code> </pre><br>  Kami memberi tahu Flask untuk menarik pengaturan dari file <code>backend.{env}_settings</code> , yang berarti kami juga perlu membuat ( <code>backend/dev_settings.py</code> ) file <code>backend/dev_settings.py</code> agar semuanya lepas landas. <br><br>  Sekarang kita dapat secara resmi NAIK backend kami! <br><br><pre> <code class="plaintext hljs">habr-app-demo$ docker-compose up backend ... backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Starting gunicorn 19.9.0 backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Listening at: http://0.0.0.0:40001 (6) backend_1 | [2019-02-23 10:09:03 +0000] [6] [INFO] Using worker: gevent backend_1 | [2019-02-23 10:09:03 +0000] [9] [INFO] Booting worker with pid: 9</code> </pre><br>  Kami melanjutkan. <br><br><h2>  Frontend: Express framework </h2><br>  Mari kita mulai dengan membuat paket.  Setelah membuat folder frontend dan menjalankan <code>npm init</code> di dalamnya, setelah beberapa pertanyaan tidak canggih, kami mendapatkan paket jadi. <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"habr-app-demo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"This is an app demo for Habr article."</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"repository"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"git"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"git+https://github.com/Saluev/habr-app-demo.git"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tigran Saluev &lt;tigran@saluev.com&gt;"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bugs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/Saluev/habr-app-demo/issues"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"homepage"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://github.com/Saluev/habr-app-demo#readme"</span></span> }</code> </pre><br>  Di masa depan, kami sama sekali tidak membutuhkan Node.js di mesin pengembang (meskipun kami masih bisa mengelak dan memulai <code>npm init</code> melalui Docker, tapi oh well). <br><br>  Di <code>Dockerfile</code> kami menyebutkan <code>npm run build</code> dan <code>npm run start</code> - Anda perlu menambahkan perintah yang sesuai ke <code>package.json</code> : <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/package.json +++ b/frontend/package.json @@ -4,6 +4,8 @@ "description": "This is an app demo for Habr article.", "main": "index.js", "scripts": { + "build": "echo 'build'", + "start": "node index.js", "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" }, "repository": {</span></span></code> </pre><br>  Perintah <code>build</code> belum melakukan apa-apa, tetapi masih akan bermanfaat bagi kita. <br><br>  Tambahkan dependensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Express</a> dan buat aplikasi sederhana di <code>index.js</code> : <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/package.json +++ b/frontend/package.json @@ -17,5 +17,8 @@ "bugs": { "url": "https://github.com/Saluev/habr-app-demo/issues" }, - "homepage": "https://github.com/Saluev/habr-app-demo#readme" + "homepage": "https://github.com/Saluev/habr-app-demo#readme", + "dependencies": { + "express": "^4.16.3" + } }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js const express = require("express"); app = express(); app.listen(process.env.APP_FRONTEND_PORT); app.get("*", (req, res) =&gt; { res.send("Hello, world!") });</span></span></code> </pre><br>  Sekarang <code>docker-compose up frontend</code> memunculkan frontend kami!  Selain itu, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 40002</a> , klasik "Hello, world" seharusnya sudah pamer. <br><br><h2>  Frontend: build with webpack dan React application </h2><br>  Saatnya untuk menggambarkan sesuatu yang lebih dari sekadar teks dalam aplikasi kita.  Di bagian ini, kita akan menambahkan komponen Bereaksi paling sederhana dari <code>App</code> dan mengkonfigurasi perakitan. <br><br>  Ketika pemrograman dalam Bereaksi, sangat mudah untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSX</a> , dialek JavaScript yang diperpanjang oleh konstruksi sintaksis formulir <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyButton</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"blue"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{this.props.caption}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MyButton</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; }</code> </pre><br>  Namun, mesin JavaScript tidak memahaminya, jadi biasanya fase build ditambahkan ke frontend.  Kompiler JavaScript khusus (yeah-yeah) mengubah gula sintaksis menjadi JavaScript klasik yang <s>jelek</s> , menangani impor, mengecilkan, dan sebagainya. <br><br><img src="https://habrastorage.org/webt/f1/rl/0j/f1rl0jer0cxs_ll69yagvwm_0gc.jpeg"><br><br>  <i>Tahun 2014.</i>  <i>java pencarian apt-cache</i> <br><br>  Jadi, komponen Bereaksi paling sederhana terlihat sangat sederhana. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js import React, {Component} from 'react' class App extends Component { render() { return &lt;h1&gt;Hello, world!&lt;/h1&gt; } } export default App</span></span></code> </pre><br>  Dia hanya akan menampilkan salam kami dengan pin yang lebih meyakinkan. <br><br>  Tambahkan <code>frontend/src/template.js</code> file <code>frontend/src/template.js</code> berisi kerangka kerja HTML minimum aplikasi masa depan kita: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/template.js export default function template(title) { let page = ` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;${title}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script src="/dist/client.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; return page; }</span></span></code> </pre><br>  Tambahkan titik masuk klien: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import App from './components/app' render( &lt;App/&gt;, document.querySelector('#app') );</span></span></code> </pre><br>  Untuk membangun semua keindahan ini, kita perlu: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webpack</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembangun</a> pemuda modis untuk JS (meskipun saya belum membaca artikel di frontend selama tiga jam, jadi saya tidak yakin tentang fashion); <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">babel</a> adalah kompiler untuk semua jenis lotion seperti JSX, dan pada saat yang sama penyedia polyfill untuk semua case IE. <br><br>  Jika iterasi frontend sebelumnya masih berjalan, yang harus Anda lakukan adalah <br><br><pre> <code class="bash hljs">docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save \ react \ react-dom docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save-dev \ webpack \ webpack-cli \ babel-loader \ @babel/core \ @babel/polyfill \ @babel/preset-env \ @babel/preset-react</code> </pre><br>  untuk menginstal dependensi baru.  Sekarang konfigurasikan webpack: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/webpack.config.js const path = require("path"); //  . clientConfig = { mode: "development", entry: { client: ["./src/client.js", "@babel/polyfill"] }, output: { path: path.resolve(__dirname, "../dist"), filename: "[name].js" }, module: { rules: [ { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" } ] } }; //  .     : // 1. target: "node" -      import path. // 2.   ..,    ../dist --   //    ,   ! serverConfig = { mode: "development", target: "node", entry: { server: ["./index.js", "@babel/polyfill"] }, output: { path: path.resolve(__dirname, ".."), filename: "[name].js" }, module: { rules: [ { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" } ] } }; module.exports = [clientConfig, serverConfig];</span></span></code> </pre><br>  Untuk membuat babel berfungsi, Anda perlu mengonfigurasi <code>frontend/.babelrc</code> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"presets"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/env"</span></span>, <span class="hljs-string"><span class="hljs-string">"@babel/react"</span></span>] }</code> </pre><br>  Akhirnya, buat <code>npm run build</code> perintah kami bermakna: <br><br><pre> <code class="json hljs">// frontend/package.json ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node /app/server.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, ...</code> </pre><br>  Sekarang klien kami, bersama dengan bundel polyfill dan semua dependensinya, berjalan melalui babel, mengkompilasi dan melipat menjadi file minified monolitik <code>../dist/client.js</code> .  Tambahkan kemampuan untuk mengunggahnya sebagai file statis ke aplikasi Express kami, dan dalam rute default kami akan mulai mengembalikan HTML kami: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js // ,    , //  - . import express from 'express' import template from './src/template' let app = express(); app.use('/dist', express.static('../dist')); app.get("*", (req, res) =&gt; { res.send(template("Habr demo app")); }); app.listen(process.env.APP_FRONTEND_PORT);</span></span></code> </pre><br>  Sukses!  Sekarang, jika kita menjalankan <code>docker-compose up --build frontend</code> , kita akan melihat "Halo, dunia!"  di bungkus baru, mengkilap, dan jika Anda memiliki ekstensi Alat Pengembang Bereaksi diinstal ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Chrome</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Firefox</a> ), maka ada juga komponen komponen Bereaksi dalam alat pengembang: <br><br><img src="https://habrastorage.org/webt/q1/it/gu/q1itgukw2k0ko60pghlwwkfqfn0.png"><br><br><h2>  Backend: Data dalam MongoDB </h2><br>  Sebelum pindah dan menghidupkan kehidupan ke aplikasi kami, Anda harus terlebih dahulu menghirupnya ke backend.  Tampaknya kami akan menyimpan kartu yang ditandai di Markdown - saatnya untuk melakukannya. <br><br>  Meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada ORM untuk MongoDB dalam python</a> , saya menganggap penggunaan ORM sebagai setan dan saya meninggalkan studi tentang solusi yang tepat untuk Anda.  Sebagai gantinya, kami akan membuat kelas sederhana untuk kartu dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DAO yang</a> menyertainya: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/storage/card.py import abc from typing import Iterable class Card(object): def __init__(self, id: str = None, slug: str = None, name: str = None, markdown: str = None, html: str = None): self.id = id self.slug = slug #    self.name = name self.markdown = markdown self.html = html class CardDAO(object, metaclass=abc.ABCMeta): @abc.abstractmethod def create(self, card: Card) -&gt; Card: pass @abc.abstractmethod def update(self, card: Card) -&gt; Card: pass @abc.abstractmethod def get_all(self) -&gt; Iterable[Card]: pass @abc.abstractmethod def get_by_id(self, card_id: str) -&gt; Card: pass @abc.abstractmethod def get_by_slug(self, slug: str) -&gt; Card: pass class CardNotFound(Exception): pass</span></span></code> </pre><br>  (Jika Anda masih tidak menggunakan anotasi jenis dengan Python, pastikan untuk memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> !) <br><br>  Sekarang mari kita membuat implementasi antarmuka <code>CardDAO</code> yang mengambil objek <code>Database</code> dari <code>pymongo</code> (ya, waktu untuk menambahkan <code>pymongo</code> ke <code>requirements.txt</code> ): <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/storage/card_impl.py from typing import Iterable import bson import bson.errors from pymongo.collection import Collection from pymongo.database import Database from backend.storage.card import Card, CardDAO, CardNotFound class MongoCardDAO(CardDAO): def __init__(self, mongo_database: Database): self.mongo_database = mongo_database # , slug   . self.collection.create_index("slug", unique=True) @property def collection(self) -&gt; Collection: return self.mongo_database["cards"] @classmethod def to_bson(cls, card: Card): # MongoDB     BSON.  #       BSON- #  ,      . result = { k: v for k, v in card.__dict__.items() if v is not None } if "id" in result: result["_id"] = bson.ObjectId(result.pop("id")) return result @classmethod def from_bson(cls, document) -&gt; Card: #   ,     #     ,     #  .    id    # ,   -   . document["id"] = str(document.pop("_id")) return Card(**document) def create(self, card: Card) -&gt; Card: card.id = str(self.collection.insert_one(self.to_bson(card)).inserted_id) return card def update(self, card: Card) -&gt; Card: card_id = bson.ObjectId(card.id) self.collection.update_one({"_id": card_id}, {"$set": self.to_bson(card)}) return card def get_all(self) -&gt; Iterable[Card]: for document in self.collection.find(): yield self.from_bson(document) def get_by_id(self, card_id: str) -&gt; Card: return self._get_by_query({"_id": bson.ObjectId(card_id)}) def get_by_slug(self, slug: str) -&gt; Card: return self._get_by_query({"slug": slug}) def _get_by_query(self, query) -&gt; Card: document = self.collection.find_one(query) if document is None: raise CardNotFound() return self.from_bson(document)</span></span></code> </pre><br>  Saatnya mendaftarkan konfigurasi Monga di pengaturan backend.  Kami cukup memberi nama wadah kami dengan mongo <code>mongo</code> , jadi <code>MONGO_HOST = "mongo"</code> : <br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/backend/dev_settings.py +++ b/backend/dev_settings.py @@ -0,0 +1,3 @@ +MONGO_HOST = "mongo" +MONGO_PORT = 27017 +MONGO_DATABASE = "core"</span></span></code> </pre><br>  Sekarang kita perlu membuat <code>MongoCardDAO</code> dan memberikan akses aplikasi Flask padanya.  Meskipun sekarang kita memiliki hierarki objek yang sangat sederhana (pengaturan → klien pymongo → database pymongo → <code>MongoCardDAO</code> ), mari kita segera membuat komponen raja terpusat yang melakukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">injeksi ketergantungan</a> (itu akan berguna lagi ketika kita melakukan pekerja dan peralatan). <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/wiring.py import os from pymongo import MongoClient from pymongo.database import Database import backend.dev_settings from backend.storage.card import CardDAO from backend.storage.card_impl import MongoCardDAO class Wiring(object): def __init__(self, env=None): if env is None: env = os.environ.get("APP_ENV", "dev") self.settings = { "dev": backend.dev_settings, # (    # ,   !) }[env] #        . #        DI,  . self.mongo_client: MongoClient = MongoClient( host=self.settings.MONGO_HOST, port=self.settings.MONGO_PORT) self.mongo_database: Database = self.mongo_client[self.settings.MONGO_DATABASE] self.card_dao: CardDAO = MongoCardDAO(self.mongo_database)</span></span></code> </pre><br><br>  Saatnya menambahkan rute baru ke aplikasi Flask dan nikmati pemandangannya! <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/server.py import os.path import flask import flask_cors from backend.storage.card import CardNotFound from backend.wiring import Wiring env = os.environ.get("APP_ENV", "dev") print(f"Starting application in {env} mode") class HabrAppDemo(flask.Flask): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) flask_cors.CORS(self) self.wiring = Wiring(env) self.route("/api/v1/card/&lt;card_id_or_slug&gt;")(self.card) def card(self, card_id_or_slug): try: card = self.wiring.card_dao.get_by_slug(card_id_or_slug) except CardNotFound: try: card = self.wiring.card_dao.get_by_id(card_id_or_slug) except (CardNotFound, ValueError): return flask.abort(404) return flask.jsonify({ k: v for k, v in card.__dict__.items() if v is not None }) app = HabrAppDemo("habr-app-demo") app.config.from_object(f"backend.{env}_settings")</span></span></code> </pre><br>  Mulai ulang dengan <code>docker-compose up --build backend</code> : <br><br><img src="https://habrastorage.org/webt/ts/_a/1l/ts_a1ljldp9jztjvlupm4z6f29i.png"><br><br>  Ups ... oh, tepatnya.  Kami perlu menambahkan konten!  Kami akan membuka folder alat dan menambahkan skrip ke dalamnya yang menambahkan satu kartu tes: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py from backend.storage.card import Card from backend.wiring import Wiring wiring = Wiring() wiring.card_dao.create(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. """))</span></span></code> </pre><br>  Perintah <code>docker-compose exec backend python -m tools.add_test_content</code> mengisi monga kami dengan konten dari dalam wadah <code>docker-compose exec backend python -m tools.add_test_content</code> . <br><br><img src="https://habrastorage.org/webt/em/n2/la/emn2laspljezpnoc66oeccj42l4.png"><br><br>  Sukses!  Sekarang adalah waktu untuk mendukung ini di ujung depan. <br><br><h2>  Frontend: Redux </h2><br>  Sekarang kita ingin membuat rute <code>/card/:id_or_slug</code> , dimana aplikasi Bereaksi kita akan terbuka, memuat data kartu dari API dan menunjukkannya kepada kita entah bagaimana.  Dan di sini, mungkin, bagian yang paling sulit dimulai, karena kami ingin server segera memberi kami HTML dengan isi kartu, cocok untuk pengindeksan, tetapi pada saat yang sama, ketika aplikasi menavigasi antara kartu, ia menerima semua data dalam bentuk JSON dari API, dan halaman tidak kelebihan beban.  Dan agar semua ini - tanpa copy-paste! <br><br>  Mari kita mulai dengan menambahkan Redux.  Redux adalah pustaka JavaScript untuk menyimpan keadaan.  Idenya adalah bahwa alih-alih ribuan status tersirat bahwa komponen Anda berubah selama tindakan pengguna dan acara menarik lainnya, mereka memiliki satu status terpusat, dan melakukan perubahan melalui mekanisme tindakan terpusat.  Jadi, jika sebelumnya untuk navigasi, pertama-tama kita menghidupkan loading GIF, maka kita membuat permintaan melalui AJAX dan, akhirnya, dalam keberhasilan panggilan balik, kita memperbarui bagian-bagian halaman yang diperlukan, maka dalam paradigma Redux kita diundang untuk mengirim tindakan "mengubah konten menjadi gif dengan animasi", yang akan mengubah status global sehingga salah satu komponen Anda akan membuang konten sebelumnya dan memasukkan animasinya, kemudian membuat permintaan, dan mengirim tindakan lain dalam panggilan balik keberhasilannya, "ubah konten menjadi dimuat".  Secara umum, sekarang kita akan melihatnya sendiri. <br><br>  Mari kita mulai dengan menginstal dependensi baru di wadah kami. <br><br><pre> <code class="bash hljs">docker-compose <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> frontend npm install --save \ redux \ react-redux \ redux-thunk \ redux-devtools-extension</code> </pre><br>  Yang pertama adalah, pada kenyataannya, Redux, yang kedua adalah perpustakaan khusus untuk menyeberang React dan Redux (ditulis oleh para ahli kawin), yang ketiga adalah hal yang sangat diperlukan, kebutuhan yang dibuktikan dengan baik dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">README-nya</a> , dan, akhirnya, yang keempat adalah perpustakaan yang diperlukan agar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux DevTools</a> dapat berfungsi. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekstensi</a> . <br><br>  Mari kita mulai dengan kode Redux boilerplate: membuat peredam yang tidak melakukan apa-apa, dan menginisialisasi keadaan. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js export default function root(state = {}, action) { return state; }</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/configureStore.js import {createStore, applyMiddleware} from "redux"; import thunkMiddleware from "redux-thunk"; import {composeWithDevTools} from "redux-devtools-extension"; import rootReducer from "./reducers"; export default function configureStore(initialState) { return createStore( rootReducer, initialState, composeWithDevTools(applyMiddleware(thunkMiddleware)), ); }</span></span></code> </pre><br>  Klien kami sedikit berubah, secara mental bersiap untuk bekerja dengan Redux: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' //      ... const store = configureStore(); render( // ...      , //     &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br>  Sekarang kita dapat menjalankan docker-compose up --build frontend untuk memastikan tidak ada yang rusak, dan status primitif kita muncul di Redux DevTools: <br><br><img src="https://habrastorage.org/webt/x0/hr/_e/x0hr_empfso4poji4s8egshlcye.png"><br><br><h2>  Frontend: Halaman Kartu </h2><br>  Sebelum Anda dapat membuat halaman dengan SSR, Anda perlu membuat halaman tanpa SSR!  Akhirnya mari kita gunakan API kami yang cerdik untuk mengakses kartu dan membuat halaman kartu di ujung depan. <br><br>  Saatnya mengambil keuntungan dari intelijen dan mendesain ulang struktur negara kita.  Ada <a href="">banyak</a> materi tentang hal ini, jadi saya sarankan untuk tidak menyalahgunakan kecerdasan dan akan fokus pada yang sederhana.  Misalnya, seperti: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"page"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"card"</span></span>, //     //       type=card: <span class="hljs-string"><span class="hljs-string">"cardSlug"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span>, //     <span class="hljs-attr"><span class="hljs-attr">"isFetching"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, //      API <span class="hljs-attr"><span class="hljs-attr">"cardData"</span></span>: {...}, //   (  ) // ... }, // ... }</code> </pre><br>  Mari kita dapatkan komponen "kartu", yang mengambil konten cardData sebagai alat peraga (sebenarnya isi kartu kita di mongo): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/card.js import React, {Component} from 'react'; class Card extends Component { componentDidMount() { document.title = this.props.name } render() { const {name, html} = this.props; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;!---,  HTML  React  - !--&gt; &lt;div dangerouslySetInnerHTML={{__html: html}}/&gt; &lt;/div&gt; ); } } export default Card;</span></span></code> </pre><br>  Sekarang mari kita dapatkan komponen untuk seluruh halaman dengan kartu.  Dia akan bertanggung jawab untuk mendapatkan data yang diperlukan dari API dan mentransfernya ke Kartu.  Dan kami akan melakukan pengambilan data dengan cara React-Redux. <br><br>  Pertama, buat file <code>frontend/src/redux/actions.js</code> dan buat tindakan yang mengekstraksi isi kartu dari API, jika belum: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchCardIfNeeded</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = getState().page; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state.cardData === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || state.cardData.slug !== state.cardSlug) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch(fetchCard()); } }; }</code> </pre><br>  Tindakan <code>fetchCard</code> , yang sebenarnya membuat pengambilan, sedikit lebih rumit: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,    . //     , , //    . dispatch(startFetchingCard()); //    API. let url = apiPath() + "/card/" + getState().page.cardSlug; // , ,   ,  //    . , ,  //    . return fetch(url) .then(response =&gt; response.json()) .then(json =&gt; dispatch(finishFetchingCard(json))); }; // ,  redux-thunk   //     . } function startFetchingCard() { return { type: START_FETCHING_CARD }; } function finishFetchingCard(json) { return { type: FINISH_FETCHING_CARD, cardData: json }; } function apiPath() { //    .    server-side // rendering,   API     -  //         localhost, //   backend. return "http://localhost:40001/api/v1"; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oh, kami mendapat tindakan yang SESUATU! </font><font style="vertical-align: inherit;">Ini harus didukung di peredam:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js import { START_FETCHING_CARD, FINISH_FETCHING_CARD } from "./actions"; export default function root(state = {}, action) { switch (action.type) { case START_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: true } }; case FINISH_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: false, cardData: action.cardData } } } return state; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Perhatikan sintaksis yang trendi untuk mengkloning objek dengan mengubah bidang individual.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang semua logika dilakukan dalam tindakan Redux, komponen itu sendiri </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan terlihat relatif sederhana:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/cardPage.js import React, {Component} from 'react'; import {connect} from 'react-redux' import {fetchCardIfNeeded} from '../redux/actions' import Card from './card' class CardPage extends Component { componentWillMount() { //   ,  React  //   .      //   ,    " // "   ,    //  - .    -   //       HTML  // renderToString,      SSR. this.props.dispatch(fetchCardIfNeeded()) } render() { const {isFetching, cardData} = this.props; return ( &lt;div&gt; {isFetching &amp;&amp; &lt;h2&gt;Loading...&lt;/h2&gt;} {cardData &amp;&amp; &lt;Card {...cardData}/&gt;} &lt;/div&gt; ); } } //       ,   //  .        //  react-redux.   page    //  dispatch,   . function mapStateToProps(state) { const {page} = state; return page; } export default connect(mapStateToProps)(CardPage);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan pengolahan halaman.type sederhana ke komponen Aplikasi root kami: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js import React, {Component} from 'react' import {connect} from "react-redux"; import CardPage from "./cardPage" class App extends Component { render() { const {pageType} = this.props; return ( &lt;div&gt; {pageType === "card" &amp;&amp; &lt;CardPage/&gt;} &lt;/div&gt; ); } } function mapStateToProps(state) { const {page} = state; const {type} = page; return { pageType: type }; } export default connect(mapStateToProps)(App);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sekarang saat terakhir tetap - Anda perlu menginisialisasi </font></font><code>page.type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>page.cardSlug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tergantung pada URL halaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi masih ada banyak bagian dalam artikel ini, tetapi kami tidak dapat membuat solusi berkualitas tinggi saat ini. </font><font style="vertical-align: inherit;">Mari kita lakukan itu bodoh untuk saat ini. </font><font style="vertical-align: inherit;">Itu benar-benar bodoh. </font><font style="vertical-align: inherit;">Misalnya, biasa ketika menginisialisasi aplikasi!</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' let initialState = { page: { type: "home" } }; const m = /^\/card\/([^\/]+)$/.exec(location.pathname); if (m !== null) { initialState = { page: { type: "card", cardSlug: m[1] }, } } const store = configureStore(initialState); render( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat membangun kembali frontend dengan bantuan </font></font><code>docker-compose up --build frontend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menikmati kartu kita </font></font><code>helloworld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><br><br><img src="https://habrastorage.org/webt/vj/qi/iu/vjqiiu9iu3c0ieigltqbu35smfw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, tunggu sebentar ... dan di mana konten kita? </font><font style="vertical-align: inherit;">Oh, kami lupa menguraikan Markdown!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pekerja: RQ </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsing Markdown dan menghasilkan HTML untuk kartu dengan ukuran yang berpotensi tidak terbatas adalah tugas “berat” yang khas, yang, alih-alih diselesaikan langsung di backend sambil menyimpan perubahan, biasanya diantrekan dan dieksekusi pada mesin kerja yang terpisah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak implementasi open source dari antrian tugas; </font><font style="vertical-align: inherit;">kami akan mengambil Redis dan perpustakaan sederhana </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RQ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Redis Queue), yang mentransmisikan parameter tugas dalam format </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mengatur proses pemijahan kami untuk diproses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu untuk menambahkan lobak tergantung, pengaturan dan kabel!</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/requirements.txt +++ b/requirements.txt @@ -3,3 +3,5 @@ flask-cors gevent gunicorn pymongo +redis +rq --- a/backend/dev_settings.py +++ b/backend/dev_settings.py @@ -1,3 +1,7 @@ MONGO_HOST = "mongo" MONGO_PORT = 27017 MONGO_DATABASE = "core" +REDIS_HOST = "redis" +REDIS_PORT = 6379 +REDIS_DB = 0 +TASK_QUEUE_NAME = "tasks" --- a/backend/wiring.py +++ b/backend/wiring.py @@ -2,6 +2,8 @@ import os from pymongo import MongoClient from pymongo.database import Database +import redis +import rq import backend.dev_settings from backend.storage.card import CardDAO @@ -21,3 +23,11 @@ class Wiring(object): port=self.settings.MONGO_PORT) self.mongo_database: Database = self.mongo_client[self.settings.MONGO_DATABASE] self.card_dao: CardDAO = MongoCardDAO(self.mongo_database) + + self.redis: redis.Redis = redis.StrictRedis( + host=self.settings.REDIS_HOST, + port=self.settings.REDIS_PORT, + db=self.settings.REDIS_DB) + self.task_queue: rq.Queue = rq.Queue( + name=self.settings.TASK_QUEUE_NAME, + connection=self.redis)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sedikit kode boilerplate untuk pekerja. </font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># worker/__main__.py import argparse import uuid import rq import backend.wiring parser = argparse.ArgumentParser(description="Run worker.") #   ,      #  .  ,       rq. parser.add_argument( "--burst", action="store_const", const=True, default=False, help="enable burst mode") args = parser.parse_args() #       Redis. wiring = backend.wiring.Wiring() with rq.Connection(wiring.redis): w = rq.Worker( queues=[wiring.settings.TASK_QUEUE_NAME], #         # ,    . name=uuid.uuid4().hex) w.work(burst=args.burst)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk penguraian itu sendiri, hubungkan pustaka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kabut</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan tulis fungsi sederhana:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/tasks/parse.py import mistune from backend.storage.card import CardDAO def parse_card_markup(card_dao: CardDAO, card_id: str): card = card_dao.get_by_id(card_id) card.html = _parse_markdown(card.markdown) card_dao.update(card) _parse_markdown = mistune.Markdown(escape=True, hard_wrap=False)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Logikanya: kita perlu </font></font><code>CardDAO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendapatkan kode sumber kartu dan menyimpan hasilnya. </font><font style="vertical-align: inherit;">Tetapi objek yang berisi koneksi ke penyimpanan eksternal tidak dapat diserialkan melalui acar - yang berarti bahwa tugas ini tidak dapat segera diambil dan diantrekan untuk RQ. </font><font style="vertical-align: inherit;">Dengan cara yang baik, kita perlu menciptakan </font></font><code>Wiring</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pekerja di samping dan melemparkannya dalam segala macam ... Ayo lakukan:</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/worker/__main__.py +++ b/worker/__main__.py @@ -2,6 +2,7 @@ import argparse import uuid import rq +from rq.job import Job import backend.wiring @@ -16,8 +17,23 @@ args = parser.parse_args() wiring = backend.wiring.Wiring() + +class JobWithWiring(Job): + + @property + def kwargs(self): + result = dict(super().kwargs) + result["wiring"] = backend.wiring.Wiring() + return result + + @kwargs.setter + def kwargs(self, value): + super().kwargs = value + + with rq.Connection(wiring.redis): w = rq.Worker( queues=[wiring.settings.TASK_QUEUE_NAME], - name=uuid.uuid4().hex) + name=uuid.uuid4().hex, + job_class=JobWithWiring) w.work(burst=args.burst)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyatakan kelas pekerjaan kami, melemparkan kabel sebagai argumen kwarg tambahan dalam semua masalah. </font><font style="vertical-align: inherit;">(Harap perhatikan bahwa ia membuat kabel BARU setiap saat, karena beberapa klien tidak dapat dibuat sebelum garpu yang terjadi di dalam RQ sebelum tugas diproses.) Sehingga semua tugas kami tidak bergantung pada kabel - yaitu, pada SEMUA objek kami - mari Mari kita membuat dekorator yang hanya akan mendapatkan yang dibutuhkan dari pemasangan kabel:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># backend/tasks/task.py import functools from typing import Callable from backend.wiring import Wiring def task(func: Callable): #    : varnames = func.__code__.co_varnames @functools.wraps(func) def result(*args, **kwargs): #  .  .pop(),     # ,        . wiring: Wiring = kwargs.pop("wiring") wired_objects_by_name = wiring.__dict__ for arg_name in varnames: if arg_name in wired_objects_by_name: kwargs[arg_name] = wired_objects_by_name[arg_name] #          #   ,  -   . return func(*args, **kwargs) return result</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan dekorator ke tugas kami dan nikmati hidup: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mistune <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> backend.storage.card <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CardDAO <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> backend.tasks.task <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> task @task <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_card_markup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(card_dao: CardDAO, card_id: str)</span></span></span><span class="hljs-function">:</span></span> card = card_dao.get_by_id(card_id) card.html = _parse_markdown(card.markdown) card_dao.update(card) _parse_markdown = mistune.Markdown(escape=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hard_wrap=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nikmati hidup? </font><font style="vertical-align: inherit;">Ugh, saya ingin mengatakan, kami mulai pekerja:</font></font><br><br><pre> <code class="plaintext hljs">$ docker-compose up worker ... Creating habr-app-demo_worker_1 ... done Attaching to habr-app-demo_worker_1 worker_1 | 17:21:03 RQ worker 'rq:worker:49a25686acc34cdfa322feb88a780f00' started, version 0.13.0 worker_1 | 17:21:03 *** Listening on tasks... worker_1 | 17:21:03 Cleaning registries for queue: tasks</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">III ... dia tidak melakukan apa-apa! </font><font style="vertical-align: inherit;">Tentu saja, karena kami tidak menetapkan satu tugas! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita menulis ulang alat kita, yang membuat kartu uji, sehingga: a) tidak jatuh jika kartu sudah dibuat (seperti dalam kasus kami); </font><font style="vertical-align: inherit;">b) menempatkan tugas pada penguraian marqdown.</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py from backend.storage.card import Card, CardNotFound from backend.tasks.parse import parse_card_markup from backend.wiring import Wiring wiring = Wiring() try: card = wiring.card_dao.get_by_slug("helloworld") except CardNotFound: card = wiring.card_dao.create(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. """)) # ,   card_dao.get_or_create,  #      ! wiring.task_queue.enqueue_call( parse_card_markup, kwargs={"card_id": card.id})</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alat sekarang dapat dijalankan tidak hanya di backend, tetapi juga pada pekerja. </font><font style="vertical-align: inherit;">Pada prinsipnya, sekarang kita tidak peduli. </font><font style="vertical-align: inherit;">Kami meluncurkannya </font></font><code>docker-compose exec worker python -m tools.add_test_content</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan di tab tetangga terminal kami melihat keajaiban - pekerja itu SESUATU!</font></font><br><br><pre> <code class="plaintext hljs">worker_1 | 17:34:26 tasks: backend.tasks.parse.parse_card_markup(card_id='5c715dd1e201ce000c6a89fa') (613b53b1-726b-47a4-9c7b-97cad26da1a5) worker_1 | 17:34:27 tasks: Job OK (613b53b1-726b-47a4-9c7b-97cad26da1a5) worker_1 | 17:34:27 Result is kept for 500 seconds</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setelah membangun kembali wadah dengan backend, kita akhirnya dapat melihat isi kartu kita di browser: </font></font><br><br><img src="https://habrastorage.org/webt/ii/5f/zb/ii5fzb_nh2p4-hbv7obhjmxr5kk.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Navigasi Frontend </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita beralih ke SSR, kita perlu membuat semua keributan kita dengan Bereaksi setidaknya agak bermakna dan membuat aplikasi satu halaman kita benar-benar satu halaman. </font><font style="vertical-align: inherit;">Mari kita perbarui alat kami untuk membuat dua (TIDAK SATU, DAN DUA! IBU, SAYA SEKARANG PEMBANGUN TANGGAL BESAR!) Kartu yang saling bertautan, dan kemudian kita akan berurusan dengan navigasi di antara mereka.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teks tersembunyi</font></font></b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># tools/add_test_content.py def create_or_update(card): try: card.id = wiring.card_dao.get_by_slug(card.slug).id card = wiring.card_dao.update(card) except CardNotFound: card = wiring.card_dao.create(card) wiring.task_queue.enqueue_call( parse_card_markup, kwargs={"card_id": card.id}) create_or_update(Card( slug="helloworld", name="Hello, world!", markdown=""" This is a hello-world page. It can't really compete with the [demo page](demo). """)) create_or_update(Card( slug="demo", name="Demo Card!", markdown=""" Hi there, habrovchanin. You've probably got here from the awkward ["Hello, world" card](helloworld). Well, **good news**! Finally you are looking at a **really cool card**! """ ))</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat mengikuti tautan dan merenungkan bagaimana setiap kali aplikasi indah kita restart. </font><font style="vertical-align: inherit;">Hentikan itu! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, letakkan handler Anda pada klik pada tautan. </font><font style="vertical-align: inherit;">Karena HTML dengan tautan berasal dari backend, dan kami memiliki aplikasi pada Bereaksi, kami memerlukan sedikit fokus spesifik Bereaksi.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/card.js class Card extends Component { componentDidMount() { document.title = this.props.name } navigate(event) { //       .  //      ,    . if (event.target.tagName === 'A' &amp;&amp; event.target.hostname === window.location.hostname) { //     event.preventDefault(); //      this.props.dispatch(navigate(event.target)); } } render() { const {name, html} = this.props; return ( &lt;div&gt; &lt;h1&gt;{name}&lt;/h1&gt; &lt;div dangerouslySetInnerHTML={{__html: html}} onClick={event =&gt; this.navigate(event)} /&gt; &lt;/div&gt; ); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena semua logika dengan memuat kartu di komponen kami </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dalam aksi itu sendiri (luar biasa!), Tidak ada tindakan yang perlu diambil:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">link</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: NAVIGATE, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: link.pathname } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan peredam konyol untuk kasus ini: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js import { START_FETCHING_CARD, FINISH_FETCHING_CARD, NAVIGATE } from "./actions"; function navigate(state, path) { //     react-router,    ! // (       SSR.) let m = /^\/card\/([^/]+)$/.exec(path); if (m !== null) { return { ...state, page: { type: "card", cardSlug: m[1], isFetching: true } }; } return state } export default function root(state = {}, action) { switch (action.type) { case START_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: true } }; case FINISH_FETCHING_CARD: return { ...state, page: { ...state.page, isFetching: false, cardData: action.cardData } }; case NAVIGATE: return navigate(state, action.path) } return state; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena sekarang keadaan aplikasi kita dapat berubah, </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita perlu menambahkan metode yang </font></font><code>componentDidUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identik dengan yang sudah kita tambahkan </font></font><code>componentWillMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sekarang, setelah memperbarui properti </font></font><code>CardPage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(misalnya, properti </font></font><code>cardSlug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selama navigasi), konten kartu dari backend juga akan diminta (hanya </font></font><code>componentWillMount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melakukan ini ketika komponen diinisialisasi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baiklah, </font></font><code>docker-compose up --build frontend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan kami memiliki navigasi yang berfungsi! </font></font><br><br><img src="https://habrastorage.org/webt/4l/ov/b_/4lovb_vai0fxv0tjx6zfcmwb8y8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembaca yang penuh perhatian akan mencatat bahwa URL halaman tidak akan berubah ketika menavigasi antara kartu - bahkan dalam tangkapan layar kita melihat Halo, kartu dunia di alamat kartu demo. </font><font style="vertical-align: inherit;">Dengan demikian, navigasi maju-mundur juga jatuh. </font><font style="vertical-align: inherit;">Mari kita tambahkan beberapa ilmu hitam dengan sejarah segera untuk memperbaikinya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal paling sederhana yang dapat Anda lakukan adalah menambah aksi.</font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebuah tantangan </font></font><code>history.pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">link</span></span></span><span class="hljs-function">) </span></span>{ history.pushState(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, link.href); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: NAVIGATE, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: link.pathname } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, ketika mengklik tautan, URL di bilah alamat browser akan benar-benar berubah. </font><font style="vertical-align: inherit;">Namun, tombol kembali </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan rusak</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuatnya berfungsi, kita perlu mendengarkan acara </font></font><code>popstate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objek </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Selain itu, jika dalam acara ini kita ingin melakukan navigasi mundur serta maju (yaitu, melalui </font></font><code>dispatch(navigate(...))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), kita harus </font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menambahkan bendera "jangan" khusus </font><font style="vertical-align: inherit;">ke fungsi </font></font><code>pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(jika tidak semuanya akan pecah bahkan lebih!). </font><font style="vertical-align: inherit;">Selain itu, untuk membedakan antara status "kita", kita harus menggunakan kemampuan </font></font><code>pushState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menyimpan metadata. </font><font style="vertical-align: inherit;">Ada banyak keajaiban dan debug, jadi mari kita langsung ke kode! </font><font style="vertical-align: inherit;">Begini tampilan Aplikasi:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/components/app.js class App extends Component { componentDidMount() { //     --   //      "". history.replaceState({ pathname: location.pathname, href: location.href }, ""); //     . window.addEventListener("popstate", event =&gt; this.navigate(event)); } navigate(event) { //    "" ,   //        ,    //   (or is it a good thing?..) if (event.state &amp;&amp; event.state.pathname) { event.preventDefault(); event.stopPropagation(); //      "  pushState". this.props.dispatch(navigate(event.state, true)); } } render() { // ... } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan inilah tindakan navigasi: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js export function navigate(link, dontPushState) { if (!dontPushState) { history.pushState({ pathname: link.pathname, href: link.href }, "", link.href); } return { type: NAVIGATE, path: link.pathname } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang ceritanya akan berhasil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sentuhan terakhir: karena kita sekarang memiliki tindakan </font></font><code>navigate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mengapa kita tidak menyerahkan kode tambahan pada klien yang menghitung keadaan awal? </font><font style="vertical-align: inherit;">Kami dapat memanggil navigasi ke lokasi saat ini:</font></font><br><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/frontend/src/client.js +++ b/frontend/src/client.js @@ -3,23 +3,16 @@ import {render} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' +import {navigate} from "./redux/actions"; let initialState = { page: { type: "home" } }; -const m = /^\/card\/([^\/]+)$/.exec(location.pathname); -if (m !== null) { - initialState = { - page: { - type: "card", - cardSlug: m[1] - }, - } -} const store = configureStore(initialState); +store.dispatch(navigate(location));</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Copy-paste hancur! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frontend: rendering sisi server </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saatnya chip utama kami (menurut saya) - SEO-friendly. Agar mesin telusur dapat mengindeks konten kami, yang sepenuhnya dibuat secara dinamis di komponen-React, kami harus dapat memberi mereka hasil rendering React, dan juga belajar bagaimana membuat hasil ini interaktif lagi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema umum sederhana. Pertama: kita perlu memasukkan HTML yang dihasilkan oleh komponen Bereaksi kita ke dalam template HTML kita </font></font><code>App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. HTML ini akan dilihat oleh mesin pencari (dan browser dengan JS dimatikan, hehe). Kedua: tambahkan tag ke templat </font></font><code>&lt;script&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menyimpan suatu tempat (misalnya, suatu objek </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) suatu dump keadaan dari mana HTML ini dibuat. Kemudian kita dapat segera menginisialisasi aplikasi kita di sisi klien dengan keadaan ini dan menunjukkan apa yang diperlukan (kita bahkan dapat menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hidrat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke HTML yang dihasilkan, agar tidak membuat ulang pohon DOM aplikasi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan menulis fungsi yang mengembalikan HTML yang dirender dan status akhir.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/server.js import "@babel/polyfill" import React from 'react' import {renderToString} from 'react-dom/server' import {Provider} from 'react-redux' import App from './components/app' import {navigate} from "./redux/actions"; import configureStore from "./redux/configureStore"; export default function render(initialState, url) { //  store,    . const store = configureStore(initialState); store.dispatch(navigate(url)); let app = ( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt; ); // ,        ! // ,         ? let content = renderToString(app); let preloadedState = store.getState(); return {content, preloadedState}; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambahkan argumen dan logika baru ke template kita, yang kita bicarakan di atas: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/template.js function template(title, initialState, content) { let page = ` &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;${title}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;${content}&lt;/div&gt; &lt;script&gt; window.__STATE__ = ${JSON.stringify(initialState)} &lt;/script&gt; &lt;script src="/dist/client.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; `; return page; } module.exports = template;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Server Express kami menjadi sedikit lebih rumit: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js app.get("*", (req, res) =&gt; { const initialState = { page: { type: "home" } }; const {content, preloadedState} = render(initialState, {pathname: req.url}); res.send(template("Habr demo app", preloadedState, content)); });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetapi klien lebih mudah: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/client.js import React from 'react' import {hydrate} from 'react-dom' import {Provider} from 'react-redux' import App from './components/app' import configureStore from './redux/configureStore' import {navigate} from "./redux/actions"; //         ! const store = configureStore(window.__STATE__); // render   hydrate. hydrate    // DOM tree,       . hydrate( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt;, document.querySelector('#app') );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, Anda perlu membersihkan kesalahan lintas-platform seperti "histori tidak ditentukan". </font><font style="vertical-align: inherit;">Untuk melakukan ini, tambahkan fungsi sederhana (sejauh ini) di suatu tempat di </font></font><code>utility.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/utility.js export function isServerSide() { //   ,      process, //     -   . return process.env.APP_ENV !== undefined; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian akan ada sejumlah perubahan rutin yang saya tidak akan bawa ke sini (tetapi mereka dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komit yang sesuai</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Akibatnya, aplikasi Bereaksi kami akan dapat merender di browser dan di server.</font></font><br><br>  Itu berhasil!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi ada, seperti kata mereka, satu peringatan ... </font></font><br><br><img src="https://habrastorage.org/webt/gd/ac/ut/gdacut18knqjvzftjhkkuhnzxgk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEMUATAN? Semua yang dilihat Google di layanan fesyen super keren saya adalah LOADING?! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yah, tampaknya semua asinkronisme kita telah melawan kita. Sekarang kita perlu cara untuk membuat server mengerti bahwa respons dari backend dengan konten kartu perlu menunggu sebelum merender aplikasi Bereaksi menjadi string dan mengirimkannya ke klien. Dan diharapkan bahwa metode ini cukup umum. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin ada banyak solusi. Salah satu pendekatan adalah untuk menggambarkan dalam file terpisah yang jalur data apa yang harus diamankan, dan lakukan ini sebelum membuat aplikasi ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Solusi ini memiliki banyak keunggulan. Sederhana, eksplisit, dan berfungsi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai percobaan (konten asli harus ada di artikel setidaknya di suatu tempat!) Saya mengusulkan skema lain. </font><font style="vertical-align: inherit;">Mari kita setiap kali kita menjalankan sesuatu yang tidak sinkron, yang harus kita tunggu, tambahkan janji yang sesuai (misalnya, yang mengembalikan mengambil) di suatu tempat di negara kita. </font><font style="vertical-align: inherit;">Jadi kami akan memiliki tempat di mana Anda selalu dapat memeriksa apakah semuanya telah diunduh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan dua tindakan baru.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js function addPromise(promise) { return { type: ADD_PROMISE, promise: promise }; } function removePromise(promise) { return { type: REMOVE_PROMISE, promise: promise, }; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang pertama akan dipanggil saat pengambilan diluncurkan, yang kedua - di akhir itu </font></font><code>.then()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tambahkan pemrosesan mereka ke peredam:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/reducers.js export default function root(state = {}, action) { switch (action.type) { case ADD_PROMISE: return { ...state, promises: [...state.promises, action.promise] }; case REMOVE_PROMISE: return { ...state, promises: state.promises.filter(p =&gt; p !== action.promise) }; ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita akan meningkatkan tindakan </font></font><code>fetchCard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/redux/actions.js function fetchCard() { return (dispatch, getState) =&gt; { dispatch(startFetchingCard()); let url = apiPath() + "/card/" + getState().page.cardSlug; let promise = fetch(url) .then(response =&gt; response.json()) .then(json =&gt; { dispatch(finishFetchingCard(json)); // " ,  " dispatch(removePromise(promise)); }); // "  ,  " return dispatch(addPromise(promise)); }; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap menambahkan </font></font><code>initialState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">janji </font><font style="vertical-align: inherit;">ke </font><font style="vertical-align: inherit;">array kosong dan membuat server menunggu semuanya! </font><font style="vertical-align: inherit;">Fungsi render menjadi asinkron dan mengambil bentuk berikut:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/src/server.js function hasPromises(state) { return state.promises.length &gt; 0 } export default async function render(initialState, url) { const store = configureStore(initialState); store.dispatch(navigate(url)); let app = ( &lt;Provider store={store}&gt; &lt;App/&gt; &lt;/Provider&gt; ); //  renderToString     // (  ). CardPage     . renderToString(app); // ,   !    - //    (  // , ),     //    . let preloadedState = store.getState(); while (hasPromises(preloadedState)) { await preloadedState.promises[0]; preloadedState = store.getState() } //  renderToString.    HTML. let content = renderToString(app); return {content, preloadedState}; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asinkron yang </font><font style="vertical-align: inherit;">diperoleh </font><font style="vertical-align: inherit;">, penangan permintaan juga sedikit lebih rumit:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// frontend/index.js app.get("*", (req, res) =&gt; { const initialState = { page: { type: "home" }, promises: [] }; render(initialState, {pathname: req.url}).then(result =&gt; { const {content, preloadedState} = result; const response = template("Habr demo app", preloadedState, content); res.send(response); }, (reason) =&gt; { console.log(reason); res.status(500).send("Server side rendering failed!"); }); });</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan lagi! </font></font><br><br><img src="https://habrastorage.org/webt/vt/ed/uj/vteduj-6tnshnodaw0setd3b0wu.png"><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, membuat aplikasi berteknologi tinggi tidak sesederhana itu. </font><font style="vertical-align: inherit;">Tetapi tidak begitu sulit! </font><font style="vertical-align: inherit;">Aplikasi terakhir ada di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori di Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan, secara teoritis, Anda hanya perlu Docker untuk menjalankannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika artikel ini diminati, repositori ini bahkan tidak akan ditinggalkan! </font><font style="vertical-align: inherit;">Kami akan dapat melihatnya dengan sesuatu dari pengetahuan lain yang diperlukan:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> logging, pemantauan, pengujian beban. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pengujian, CI, CD. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fitur keren seperti otorisasi atau pencarian teks lengkap. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pengaturan dan pengembangan lingkungan produksi. </font></font></li></ul><br>  Terima kasih atas perhatian anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444446/">https://habr.com/ru/post/id444446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444434/index.html">Waktunya telah tiba untuk Java 12! Ulasan JEP panas</a></li>
<li><a href="../id444436/index.html">Apa itu botnet Mirai, dan bagaimana cara melindungi perangkat saya?</a></li>
<li><a href="../id444438/index.html">Sejarah singkat sumber terbuka - bagaimana perangkat lunak bebas berperang dengan hak milik</a></li>
<li><a href="../id444442/index.html">Jetson Nano: Nvidia Machine Learning Single Board</a></li>
<li><a href="../id444444/index.html">Kegagalan terbaik dari konferensi kami (Joker, JPoint, DotNext, Mobius, TechTrain dan sebagainya)</a></li>
<li><a href="../id444448/index.html">Mirai Clone Menambahkan Lusinan Eksploitasi Baru untuk Perangkat IoT Perusahaan Bertarget</a></li>
<li><a href="../id444456/index.html">Atari 65XE - Keyboard USB</a></li>
<li><a href="../id444460/index.html">Dari parser poster teater Python ke bot Telegram. Bagian 1</a></li>
<li><a href="../id444462/index.html">Menguji Samsung Galaxy S10 - Kapan smartphone akan menyusul kamera?</a></li>
<li><a href="../id444464/index.html">Cara lain untuk menembak kaki Anda menggunakan std :: thread</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>