<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüíª üöµüèæ üòè ENUM cepat üíáüèΩ ü•ù ‚¨áÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="tl; dr 
 github.com/QratorLabs/fastenum 


pip install fast-enum  
 Mengapa pencacahan dibutuhkan 
 (jika Anda tahu segalanya - buka bagian "Enumerasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ENUM cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/qrator/blog/480614/"><h4>  tl; dr </h4><br>  <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> <br><pre><code class="bash hljs">pip install fast-enum</code> </pre> <br><h3>  Mengapa pencacahan dibutuhkan </h3><br>  (jika Anda tahu segalanya - buka bagian "Enumerasi di perpustakaan standar") <br><br>  Bayangkan bahwa Anda perlu mendeskripsikan satu set semua status entitas yang mungkin dalam model database Anda sendiri.  Kemungkinan besar, Anda akan mengambil banyak konstanta yang didefinisikan langsung di namespace modul: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># /path/to/package/static.py: INITIAL = 0 PROCESSING = 1 PROCESSED = 2 DECLINED = 3 RETURNED = 4 ...</span></span></code> </pre> <br>  ... atau sebagai atribut kelas statis: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = <span class="hljs-number"><span class="hljs-number">0</span></span> PROCESSING = <span class="hljs-number"><span class="hljs-number">1</span></span> PROCESSED = <span class="hljs-number"><span class="hljs-number">2</span></span> DECLINED = <span class="hljs-number"><span class="hljs-number">3</span></span> RETURNED = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Pendekatan ini akan membantu merujuk negara-negara ini dengan nama mnemonik, sedangkan di repositori Anda, mereka akan menjadi bilangan bulat biasa.  Dengan demikian, Anda secara simultan menyingkirkan angka ajaib yang tersebar di berbagai bagian kode, sekaligus membuatnya lebih mudah dibaca dan informatif. <br><br>  Namun, baik konstanta modul dan kelas dengan atribut statis menderita dari sifat intrinsik objek Python: mereka semua bisa berubah (bisa berubah).  Anda dapat secara tidak sengaja memberikan nilai pada konstanta saat run time, dan debugging dan memutar kembali objek yang rusak adalah petualangan yang terpisah.  Jadi, Anda mungkin ingin membuat bundel konstanta tidak berubah dalam arti bahwa jumlah konstanta yang dideklarasikan dan nilai-nilai mereka yang dipetakan tidak akan berubah selama eksekusi program. <br><a name="habracut"></a><br>  Untuk melakukan ini, Anda dapat mencoba mengaturnya menjadi nama tupel menggunakan <code>namedtuple()</code> , seperti dalam contoh: <br><pre> <code class="python hljs">MyModelStates = namedtuple(<span class="hljs-string"><span class="hljs-string">'MyModelStates'</span></span>, (<span class="hljs-string"><span class="hljs-string">'INITIAL'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSING'</span></span>, <span class="hljs-string"><span class="hljs-string">'PROCESSED'</span></span>, <span class="hljs-string"><span class="hljs-string">'DECLINED'</span></span>, <span class="hljs-string"><span class="hljs-string">'RETURNED'</span></span>)) EntityStates = MyModelStates(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  Tapi ini tidak terlihat sangat rapi dan mudah dibaca, dan objek yang <code>namedtuple</code> , pada gilirannya, tidak terlalu dapat diperluas.  Misalkan Anda memiliki UI yang menampilkan semua status ini.  Anda dapat menggunakan konstanta dalam modul, kelas dengan atribut, atau menamai tuple untuk merendernya (dua yang terakhir lebih mudah di-render karena kita membicarakan ini).  Tetapi kode seperti itu tidak memungkinkan untuk memberikan kepada pengguna deskripsi yang memadai untuk setiap negara yang Anda tetapkan.  Selain itu, jika Anda berencana untuk menerapkan multibahasa dan dukungan i18n di UI Anda, Anda akan menyadari betapa cepatnya menyelesaikan semua terjemahan untuk deskripsi ini menjadi tugas yang sangat membosankan.  Mencocokkan nama negara tidak harus berarti mencocokkan deskripsi, yang berarti Anda tidak bisa hanya memetakan semua status <code>INITIAL</code> Anda ke deskripsi yang sama di <code>gettext</code> .  Alih-alih, konstanta Anda mengambil bentuk berikut: <br><pre> <code class="python hljs">INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'My_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Atau kelas Anda menjadi seperti ini: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModelStates</span></span></span><span class="hljs-class">:</span></span> INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>)</code> </pre> <br>  Akhirnya, tuple bernama berubah menjadi: <br><pre> <code class="python hljs">EntityStates = MyModelStates((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>), ...)</code> </pre><br>  Sudah tidak buruk - sekarang menjamin bahwa nilai status dan tulisan rintisan ditampilkan dalam bahasa yang didukung oleh UI.  Tetapi Anda mungkin memperhatikan bahwa kode yang menggunakan pemetaan ini telah menjadi berantakan.  Setiap kali, mencoba untuk menetapkan nilai entitas, Anda harus mengekstraksi nilai dengan indeks 0 dari tampilan yang Anda gunakan: <br><br><pre> <code class="python hljs">my_entity.state = INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  atau <pre> <code class="python hljs">my_entity.state = MyModelStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre>  atau <pre> <code class="python hljs">my_entity.state = EntityStates.INITIAL[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre> <br>  Dan sebagainya.  Ingat bahwa dua pendekatan pertama yang menggunakan atribut konstanta dan kelas, masing-masing, mengalami mutabilitas. <br><br><h4>  Dan transfer datang untuk membantu kami </h4><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEntityStates</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val, description)</span></span></span><span class="hljs-function">:</span></span> self.val = val self.description = description INITIAL = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_INITIAL_STATE'</span></span>) PROCESSING = (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_BEING_PROCESSED_STATE'</span></span>) PROCESSED = (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_PROCESSED_STATE'</span></span>) DECLINED = (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_DECLINED_STATE'</span></span>) RETURNED = (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'MY_MODEL_RETURNED_STATE'</span></span>)</code> </pre> <br>  Itu saja.  Sekarang Anda dapat dengan mudah beralih pada daftar di render Anda (sintaks Jinja2): <br><pre> <code class="python hljs">{% <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> MyEntityState %} &lt;option value=‚Äù{{ state.val }}‚Äù&gt;{{ _(state.description) }}&lt;/option&gt; {% endfor %}</code> </pre> <br>  Pencacahan tidak dapat diubah untuk sekumpulan elemen - Anda tidak dapat menentukan anggota baru pencacahan saat runtime dan Anda tidak dapat menghapus anggota yang sudah ditentukan, atau untuk nilai-nilai elemen yang disimpannya - Anda tidak dapat [kembali] menetapkan nilai atribut apa pun atau menghapus atribut. <br><br>  Dalam kode Anda, Anda cukup menetapkan nilai untuk entitas Anda, seperti ini: <br><pre> <code class="python hljs">my_entity.state = MyEntityStates.INITIAL.val</code> </pre> <br>  Semuanya cukup jelas, informatif, dan dapat diperluas.  Untuk inilah kami menggunakan enumerasi. <br><br><h3>  Bagaimana kita bisa membuatnya lebih cepat? </h3><br>  Enumerasi dari perpustakaan standar agak lambat, jadi kami bertanya pada diri sendiri - dapatkah kami mempercepatnya?  Ternyata, kita bisa, yaitu, pelaksanaan enumerasi kami: <br><br><ul><li>  Tiga kali lebih cepat pada akses ke pencacahan anggota; </li><li>  ~ 8,5 lebih cepat ketika mengakses atribut ( <code>name</code> , <code>value</code> ) anggota; </li><li>  3 kali lebih cepat ketika mengakses anggota berdasarkan nilai (panggil konstruktor enumerasi <code>MyEnum(value))</code> ; </li><li>  1,5 kali lebih cepat ketika mengakses anggota dengan nama (seperti dalam kamus <code>MyEnum[name]</code> ). </li></ul><br>  Jenis dan objek dalam Python bersifat dinamis.  Tetapi ada alat untuk membatasi sifat dinamis dari objek.  Anda bisa mendapatkan peningkatan kinerja yang signifikan dengan <code>__slots__</code> .  Ada juga potensi peningkatan kecepatan jika Anda menghindari penggunaan deskriptor data jika memungkinkan - tetapi Anda harus mempertimbangkan kemungkinan peningkatan signifikan dalam kompleksitas aplikasi. <br><br><h4>  Slot </h4><br>  Misalnya, Anda dapat menggunakan deklarasi kelas menggunakan <code>__slots__</code> - dalam kasus ini, semua instance kelas hanya akan memiliki seperangkat properti terbatas yang dideklarasikan dalam <code>__slots__</code> dan semua <code>__slots__</code> kelas induk. <br><br><h4>  Penjelas </h4><br>  Secara default, interpreter Python mengembalikan nilai atribut objek secara langsung (pada saat yang sama, kami menetapkan bahwa dalam hal ini nilai juga merupakan objek Python, dan tidak, misalnya, tidak ditandai lama dalam hal bahasa C): <br> <code>value = my_obj.attribute #        ,      .</code> <br> <br>  Menurut model data Python, jika nilai atribut adalah objek yang mengimplementasikan protokol deskriptor, maka ketika mencoba untuk mendapatkan nilai atribut ini, interpreter pertama-tama akan menemukan referensi ke objek yang dirujuk oleh properti dan kemudian memanggil metode <code>__get__</code> khusus untuk <code>__get__</code> , yang akan diteruskan ke objek asli kita sebagai, argumen: <br><pre> <code class="python hljs">obj_attribute = my_obj.attribute obj_attribute_value = obj_attribute.__get__(my_obj)</code> </pre> <br><h4>  Pencacahan di Perpustakaan Standar </h4><br>  Setidaknya properti <code>name</code> dan <code>value</code> anggota dari implementasi enumerasi standar dinyatakan sebagai <code>types.DynamicClassAttribute</code> .  Ini berarti bahwa ketika Anda mencoba untuk mendapatkan nilai <code>name</code> dan <code>value</code> , hal berikut akan terjadi: <br><br><pre> <code class="python hljs">one_value = StdEnum.ONE.value <span class="hljs-comment"><span class="hljs-comment">#        #   ,      one_value_attribute = StdEnum.ONE.value one_value = one_value_attribute.__get__(StdEnum.ONE)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,  __get__     (  python3.7): def __get__(self, instance, ownerclass=None): if instance is None: if self.__isabstractmethod__: return self raise AttributeError() elif self.fget is None: raise AttributeError("unreadable attribute") return self.fget(instance)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   DynamicClassAttribute     `name`  `value`   __get__()  : @DynamicClassAttribute def name(self): """The name of the Enum member.""" return self._name_ @DynamicClassAttribute def value(self): """The value of the Enum member.""" return self._value_</span></span></code> </pre> <br>  Dengan demikian, seluruh urutan panggilan dapat diwakili oleh pseudo-code berikut: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(enum_member, attrname)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#        __dict__,        -     return getattr(enum_member, f'_{attrnme}_') def get_name_value(enum_member): name_descriptor = get_descriptor(enum_member, 'name') if enum_member is None: if name_descriptor.__isabstractmethod__: return name_descriptor raise AttributeError() elif name_descriptor.fget is None: raise AttributeError("unreadable attribute") return get_func(enum_member, 'name')</span></span></code> </pre> <br>  Kami menulis skrip sederhana yang menunjukkan output yang dijelaskan di atas: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Enum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StdEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Enum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value, description)</span></span></span><span class="hljs-function">:</span></span> self.v = value self.description = description A = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'One'</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'Two'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StdEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'stdenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Dan setelah eksekusi, skrip memberi kami gambar berikut: <br><img src="https://habrastorage.org/webt/op/ff/m7/opffm7k3v2rgako7xufgkgqtcek.png"><br><br>  Ini menunjukkan bahwa setiap kali Anda mengakses atribut <code>name</code> dan <code>value</code> anggota enumerasi dari perpustakaan standar, sebuah pegangan dipanggil.  Deskriptor ini, pada gilirannya, berakhir dengan panggilan dari kelas <code>Enum</code> dari perpustakaan standar metode <code>def name(self)</code> , didekorasi dengan deskriptor. <br><br>  Bandingkan dengan FastEnum kami: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fast_enum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> FastEnum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyNewEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> A = <span class="hljs-number"><span class="hljs-number">1</span></span> B = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyNewEnum.A.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PyCallGraph <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pycallgraph.output <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GraphvizOutput graphviz = GraphvizOutput(output_file=<span class="hljs-string"><span class="hljs-string">'fastenum.png'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> PyCallGraph(output=graphviz): v = get_name()</code> </pre> <br>  Apa yang bisa dilihat pada gambar berikut: <br><img src="https://habrastorage.org/webt/le/ck/td/lecktd3dtx71oi3dmlyax7qyogu.png"><br><br>  Semua ini benar-benar terjadi di dalam implementasi enumerasi standar setiap kali Anda mengakses properti <code>name</code> dan <code>value</code> anggota mereka.  Ini juga alasan mengapa implementasi kami lebih cepat. <br><br>  <b>Menerapkan enumerasi di pustaka standar Python menggunakan banyak panggilan ke objek yang mengimplementasikan protokol deskriptor data.</b>  Ketika kami mencoba menggunakan implementasi enumerasi standar dalam proyek kami, kami segera memperhatikan berapa banyak deskriptor data yang dipanggil untuk <code>name</code> dan <code>value</code> . <br>  Dan karena enumerasi digunakan cukup luas di seluruh kode, kinerja yang dihasilkan rendah. <br><br>  Selain itu, kelas Enum standar berisi beberapa atribut "dilindungi" tambahan: <br><ul><li>  <code>_member_names_</code> - daftar yang berisi semua nama anggota enumerasi; </li><li>  <code>_member_map_</code> - <code>OrderedDict</code> , yang memetakan nama anggota enumerasi ke nilainya; </li><li>  <code>_value2member_map_</code> - kamus yang berisi kecocokan dalam arah yang berlawanan: nilai anggota enumerasi dengan anggota enumerasi yang sesuai. </li></ul><br>  Pencarian kamus lambat, karena setiap panggilan mengarah ke perhitungan fungsi hash (kecuali, tentu saja, hasilnya di-cache secara terpisah, yang tidak selalu memungkinkan untuk kode yang tidak dikelola) dan pencarian di tabel hash, yang menjadikan kamus ini bukan dasar yang optimal untuk enumerasi.  Bahkan pencarian anggota enumerasi (seperti dalam <code>StdEnum.MEMBER</code> ) itu sendiri adalah pencarian kamus. <br><br><h4>  Pendekatan kami </h4><br>  Kami menciptakan implementasi enumerasi kami dengan memperhatikan enumerasi elegan di C dan enumerasi yang dapat diperluas yang indah di Jawa.  Fungsi utama yang ingin kami terapkan di rumah adalah sebagai berikut: <br><br><ul><li>  pencacahan harus se-statis mungkin;  "Statis" di sini berarti yang berikut - jika sesuatu dapat dihitung hanya sekali dan selama pengumuman, maka itu harus dihitung pada saat ini (dan hanya pada saat ini); </li><li>  tidak mungkin untuk mewarisi dari enumerasi (harus menjadi kelas "final") jika kelas pewaris mendefinisikan anggota baru enumerasi - ini berlaku untuk implementasi di perpustakaan standar, dengan pengecualian bahwa pewarisan dilarang di sana, bahkan jika kelas pewaris tidak mendefinisikan anggota baru; </li><li>  enumerasi harus memiliki cakupan yang luas untuk ekspansi (atribut tambahan, metode, dll.) </li></ul><br>  Kami menggunakan pencarian kamus dalam satu-satunya kasus - ini adalah pemetaan terbalik dari nilai <code>value</code> ke anggota enumerasi.  Semua perhitungan lain dilakukan hanya sekali selama deklarasi kelas (di mana metaclasses digunakan untuk mengkonfigurasi pembuatan tipe). <br>  Tidak seperti perpustakaan standar, kami hanya memproses nilai pertama setelah tanda <code>=</code> dalam deklarasi kelas sebagai nilai anggota: <br>  <code>A = 1, 'One'</code> di perpustakaan standar, seluruh tuple <code>1, "One"</code> dianggap sebagai nilai <code>value</code> ; <br>  <code>A: 'MyEnum' = 1, 'One'</code> dalam implementasi kami, hanya <code>1</code> dianggap sebagai nilai <code>value</code> . <br><br>  Akselerasi lebih lanjut dicapai melalui penggunaan <code>__slots__</code> jika memungkinkan.  Dalam kelas Python dideklarasikan menggunakan <code>__slots__</code> , atribut <code>__dict__</code> tidak dibuat untuk <code>__dict__</code> , yang berisi pemetaan nama atribut dengan nilai-nilai mereka (karena itu, Anda tidak dapat mendeklarasikan properti dari instance yang tidak disebutkan dalam <code>__slots__</code> ).  Selain itu, nilai atribut yang didefinisikan dalam <code>__slots__</code> diakses pada offset konstan pada pointer instance objek.  Ini adalah akses berkecepatan tinggi ke properti karena menghindari perhitungan hash dan pemindaian tabel hash. <br><br><h3>  Apa chip tambahannya? </h3><br>  FastEnum tidak kompatibel dengan versi Python sebelum 3.6 karena ia secara universal menggunakan tipe anotasi yang diimplementasikan dalam Python 3.6.  Dapat diasumsikan bahwa menginstal modul <code>typing</code> dari PyPi akan membantu.  Jawaban singkatnya adalah tidak.  Implementasi menggunakan PEP-484 untuk argumen beberapa fungsi, metode, dan pointer ke tipe kembali, sehingga versi apa pun sebelum Python 3.5 tidak didukung karena ketidakcocokan sintaksis.  Tapi, sekali lagi, baris kode pertama dalam metaclass <code>__new__</code> menggunakan sintaks PEP-526 untuk menunjukkan jenis variabel.  Jadi Python 3.5 tidak akan berfungsi juga.  Anda dapat port implementasi ke versi yang lebih lama, meskipun kami di Qrator Labs cenderung menggunakan anotasi jenis bila memungkinkan, karena ini banyak membantu dalam mengembangkan proyek yang kompleks.  Nah, pada akhirnya!  Anda tidak ingin terjebak dalam Python sebelum versi 3.6, karena dalam versi yang lebih baru tidak ada ketidaksesuaian mundur dengan kode yang ada (asalkan Anda tidak menggunakan Python 2), dan banyak pekerjaan telah dilakukan dalam implementasi <code>asyncio</code> dibandingkan dengan 3,5, pada pandangan kami, layak pembaruan segera. <br><br>  Ini, pada gilirannya, membuat impor khusus <code>auto</code> tidak diperlukan, tidak seperti perpustakaan standar.  Anda cukup menunjukkan bahwa anggota enumerasi akan menjadi contoh enumerasi ini tanpa memberikan nilai sama sekali - dan nilai akan dihasilkan secara otomatis untuk Anda.  Meskipun Python 3.6 cukup untuk bekerja dengan FastEnum, perlu diingat bahwa menjaga urutan kunci dalam kamus hanya diperkenalkan di Python 3.7 (dan kami tidak menggunakan <code>OrderedDict</code> secara terpisah untuk kasus 3.6).  Kami tidak tahu contoh di mana urutan nilai yang dihasilkan secara otomatis adalah penting, karena kami menganggap bahwa jika pengembang menyediakan lingkungan dengan tugas menghasilkan dan menetapkan nilai kepada anggota enumerasi, maka nilai itu sendiri tidak begitu penting untuk itu.  Namun, jika Anda masih belum beralih ke Python 3.7, kami memperingatkan Anda. <br><br>  Mereka yang membutuhkan enumerasi mereka mulai dari 0 (nol) dan bukan nilai default (1) dapat melakukan ini menggunakan atribut khusus ketika mendeklarasikan enumerasi <code>_ZERO_VALUED</code> , yang tidak akan disimpan di kelas yang dihasilkan. <br><br>  Namun, ada beberapa batasan: semua nama anggota enumerasi harus ditulis dalam huruf MODAL, jika tidak mereka tidak akan diproses oleh metaclass. <br><br>  Akhirnya, Anda dapat mendeklarasikan kelas dasar untuk enumerasi Anda (perlu diingat bahwa kelas dasar dapat menggunakan metaclass itu sendiri, sehingga Anda tidak perlu memberikan metaclass ke semua subclass) - cukup tentukan logika umum (atribut dan metode) di kelas ini dan tidak mendefinisikan anggota enumerasi (sehingga kelas tidak akan "diselesaikan").  Setelah Anda dapat mendeklarasikan sebanyak mungkin kelas pewarisan dari kelas ini seperti yang Anda inginkan, dan pewarisnya sendiri akan memiliki logika yang sama. <br><br><h3>  Alias ‚Äã‚Äãdan bagaimana mereka bisa membantu </h3><br>  Misalkan Anda memiliki kode menggunakan: <br><pre> <code class="python hljs">package_a.some_lib_enum.MyEnum</code> </pre> <br>  Dan bahwa kelas MyEnum dinyatakan sebagai berikut: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(metaclass=FastEnum)</span></span></span><span class="hljs-class">:</span></span> ONE: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span> TWO: <span class="hljs-string"><span class="hljs-string">'MyEnum'</span></span></code> </pre> <br>  Sekarang, Anda telah memutuskan bahwa Anda ingin melakukan refactoring dan mentransfer daftar ke paket lain.  Anda membuat sesuatu seperti ini: <br><pre> <code class="python hljs">package_b.some_lib_enum.MyMovedEnum</code> </pre> <br>  Di mana MyMovedEnum dinyatakan seperti ini: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyMovedEnum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MyEnum)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre> <br>  Sekarang Anda siap untuk tahap di mana transfer yang terletak di alamat lama dianggap usang.  Anda menulis ulang impor dan panggilan enumerasi ini sehingga nama baru enumerasi ini (aliasnya) sekarang digunakan - Anda dapat yakin bahwa semua anggota enumerasi alias ini benar-benar dideklarasikan di kelas dengan nama lama.  Dalam dokumentasi proyek Anda, Anda menyatakan bahwa <code>MyEnum</code> usang dan akan dihapus dari kode di masa mendatang.  Misalnya, dalam rilis berikutnya.  Misalkan kode Anda menyimpan objek Anda dengan atribut yang berisi anggota enumerasi menggunakan <code>pickle</code> .  Pada titik ini, Anda menggunakan <code>MyMovedEnum</code> dalam kode Anda, tetapi secara internal, semua anggota enumerasi masih merupakan contoh dari <code>MyEnum</code> .  Langkah Anda selanjutnya adalah menukar deklarasi <code>MyEnum</code> dan <code>MyMovedEnum</code> sehingga <code>MyMovedEnum</code> bukan subkelas dari <code>MyEnum</code> dan <code>MyEnum</code> semua anggotanya sendiri;  <code>MyEnum</code> , di sisi lain, sekarang tidak mendeklarasikan anggota, tetapi menjadi hanya alias (subkelas) dari <code>MyMovedEnum</code> . <br><br>  Itu saja.  Saat Anda me-restart aplikasi Anda pada tahap <code>unpickle</code> semua anggota enumerasi akan dideklarasikan kembali sebagai instance dari <code>MyMovedEnum</code> dan menjadi terkait dengan kelas baru ini.  Saat Anda yakin bahwa semua objek Anda disimpan, misalnya, dalam database, telah deserialized (dan mungkin serial lagi dan disimpan dalam repositori) - Anda dapat merilis rilis baru, di mana sebelumnya ditandai sebagai kelas usang <code>MyEnum</code> dapat dinyatakan lebih tidak perlu dan dihapus dari basis kode. <br><br>  Cobalah sendiri: <a href="https://github.com/QratorLabs/fastenum">github.com/QratorLabs/fastenum</a> , <a href="https://pypi.org/project/fast-enum/">pypi.org/project/fast-enum</a> . <br>  Pro dalam karma pergi ke penulis FastEnum - <a href="https://habr.com/en/users/santjagocorkez/" class="user_link">santjagocorkez</a> . <br><br>  UPD: Dalam versi 1.3.0, menjadi mungkin untuk mewarisi dari kelas yang ada, misalnya, <code>int</code> , <code>float</code> , <code>str</code> .  Anggota enumerasi tersebut berhasil lulus ujian untuk kesetaraan ke objek bersih dengan nilai yang sama ( <code>IntEnum.MEMBER == int(value_given_to_member)</code> ) dan, tentu saja, itu adalah contoh dari kelas-kelas yang diwarisi ini.  Ini, pada gilirannya, memungkinkan anggota enum yang diwarisi dari <code>int</code> untuk menjadi argumen langsung ke <code>sys.exit()</code> sebagai kode pengembalian juru bahasa python. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480614/">https://habr.com/ru/post/id480614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480598/index.html">Dasar dari setiap pemrograman pada ... puzzle</a></li>
<li><a href="../id480600/index.html">Enum lebih cepat</a></li>
<li><a href="../id480606/index.html">Lima ide lagi tentang cara meningkatkan keterampilan Anda sebagai pengembang front-end (Desember 2019)</a></li>
<li><a href="../id480608/index.html">Rust Mengungguli C ++ dengan Hasil Game Benchmark</a></li>
<li><a href="../id480612/index.html">Buat perubahan ini untuk memenuhi standar aksesibilitas desain web.</a></li>
<li><a href="../id480618/index.html">Permainan elektronik Tic Tac Toe. Apa yang telah saya lakukan?</a></li>
<li><a href="../id480620/index.html">SD-WAN dan DNA untuk membantu administrator: fitur arsitektur dan praktik</a></li>
<li><a href="../id480622/index.html">Cara menggunakan kapasitas penyimpanan yang tersedia dengan benar</a></li>
<li><a href="../id480626/index.html">Warisan sistem dan proses warisan atau 90 hari pertama dalam peran CTO</a></li>
<li><a href="../id480642/index.html">Pengantar Linux ELF: Memahami dan Menganalisis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>