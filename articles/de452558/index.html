<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏿 🎅🏾 👉🏾 Wie habe ich Daten von einem BLE-Thermometer von Xiaomi genommen? 🏒 🚴🏾 👩🏾‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hintergrund: Als eines meiner Hobbys hatte ich ein „Smart Home“. Ich möchte schöne Geräte, aber ich möchte auch Freiheit und Privatsphäre. Deshalb bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie habe ich Daten von einem BLE-Thermometer von Xiaomi genommen?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452558/"> Hintergrund: Als eines meiner Hobbys hatte ich ein „Smart Home“.  Ich möchte schöne Geräte, aber ich möchte auch Freiheit und Privatsphäre.  Deshalb beschäftige ich mich mit der Kreuzung von Xiaomi uzhik mit dem Hedgehog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Home Assistant</a> . <br><br>  Um eine angenehme Umgebung zu erhalten, müssen wir wissen, was zu Hause los ist.  Kurz gesagt, Sensoren werden benötigt.  Xiaomi hat viele verschiedene, aber am meisten hat mir das quadratische Thermometer auf elektronischer Tinte gefallen.  Aber er ist überhaupt nicht schlau in dem Sinne, dass er überhaupt keine Schnittstellen außer der grafischen bereitstellt - weder WiFi noch BLE noch ZigBee.  CR2032-Batterien halten jedoch mehrere Jahre.  Es gibt auch eine Version mit Bluetooth, aber es ist etwas weniger elegant - eine Art dicker Pfannkuchen. <br><br>  Zu Frühlingsbeginn wurde ein neuer Temperatur- / Feuchtigkeitssensor für elektronische Tinte mit BLE und sogar mit einer Uhr angekündigt.  Ich brauche eigentlich keine Uhr, aber alles andere unterdrückte sofort alle rationalen Argumente und das Thermometer wurde auf Vorbestellung in einem der beliebten Online-Shops bestellt.  Es ritt, es ritt und kam schließlich an. <br><br><img src="https://habrastorage.org/webt/n2/62/pf/n262pfr57ulreqqa4i_vsvvacoa.jpeg"><br><br>  Der Sensor wurde der MiHome-Anwendung ohne Probleme hinzugefügt (ich habe überall eine englischsprachige Oberfläche, mit der russischen Version von MiHome gab es angeblich Übersetzungsschwierigkeiten).  Zeigt die aktuellen Werte und den Verlauf der Änderungen der Messwerte an. <br><br>  Aber mit der Integration in den Home Assistant sind Schwierigkeiten aufgetreten.  Die vorhandene Komponente für den Temperatursensor wollte in keiner Weise Daten vom Gerät übernehmen und beschwerte sich über das falsche Datenformat.  Nun, es gibt nichts zu tun, wir nehmen eine Schaufel heraus und beginnen zu graben. <br><br>  Der erste Gedanke war, sich mit dem BLE-Protokollgerät vertraut zu machen, aber nachdem die Größe der Dokumentation bewertet worden war, wurde beschlossen, auf die beliebte Poke-Methode umzusteigen. <br><a name="habracut"></a><br><h2>  Die erste Annäherung an die Shell </h2><br>  Öffnen Sie zum Starten das Terminal auf Ubuntu und führen Sie Bluetoothctl aus.  Wir sehen folgendes: <br><br><pre><code class="plaintext hljs">[NEW] Controller 00:1A:7D:DA:71:13 fett [default] [NEW] Device 3F:59:C8:80:70:BE LYWSD02 [NEW] Device 4C:65:A8:DC:0D:AF MJ_HT_V1</code> </pre> <br>  MJ_HT_V1 ist ein alter Temperatursensor, LYWSD02 ist ein neuer.  Der Unterschied im Modellbenennungsformat ist etwas alarmierend. <br><br>  Dann müssen Sie irgendwie lesen, und welche Art von Daten im Allgemeinen von uns erhalten werden können.  Er öffnete die Quellen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mitemp-</a> Bibliothek, die im Home Assistant zum Empfangen von Daten vom alten Sensor verwendet wird.  Dort fand ich heraus, dass die Blewrap-Bibliothek verwendet wird, die wiederum ein Wrapper für zwei Python-Bibliotheken für die Arbeit mit BLE ist.  Ich brauche nicht so viele Schichten, wir werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bluepy verwenden</a> .  Es gibt Dokumentation, es ist nicht viel und nicht wenig, wir lesen und schreiben ein Skript, das alle Datenfelder auf dem Gerät durchläuft. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bluepy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> btle mac = <span class="hljs-string"><span class="hljs-string">'3F:59:C8:80:70:BE'</span></span> p = btle.Peripheral(mac) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p.getServices(): print(<span class="hljs-string"><span class="hljs-string">'Service:'</span></span>, s.uuid) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s.getCharacteristics(): print(<span class="hljs-string"><span class="hljs-string">'\tCharacteristic:'</span></span>, c.uuid) print(<span class="hljs-string"><span class="hljs-string">'\t\t'</span></span>, c.propertiesToString()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.supportsRead(): print(<span class="hljs-string"><span class="hljs-string">'\t\t'</span></span>, c.read())</code> </pre> <br>  Im Allgemeinen ist alles einfach - ein BLE-Gerät bietet eine Reihe von Diensten, von denen jeder aus einer Reihe von Merkmalen besteht.  Jedes Merkmal kann einer von 8 Typen sein. Für ein Merkmal können Sie mehrere Typen gleichzeitig angeben.  Dienste und Funktionen werden auf zwei Arten identifiziert - eine Adresse in Form eines HEX-Werts und einer UUID.  Ich bin mit der Arbeit mit UUID besser vertraut. <br><br>  Also habe ich alle Spezifikationen für beide Sensoren berücksichtigt, sie angeschaut und festgestellt, dass wieder Geräte von völlig verschiedenen Herstellern unter der Marke Xiaomi verkauft werden.  Unter den Werten des alten Sensors wurde "Cleargrass Inc" und im neuen "miaomiaoce.com" gefunden.  Die Struktur der Dienste und Eigenschaften dieser beiden Sensoren ist ebenfalls völlig unterschiedlich, und die Liste der Eigenschaften des neuen Sensors ist doppelt so lang.  Dann wurde klar, dass Sie Ihre eigene Bibliothek für die Integration mit dem Sensor schreiben müssen (nein, natürlich habe ich zuerst gegoogelt, vielleicht gibt es auf Anfrage etwas Nützliches LYWSD02, aber ich habe nichts Sinnvolles google gegeben). <br><br><h2>  Wie erhalten Sie die Daten? </h2><br>  Unter den verfügbaren Arten von Merkmalen gibt es neben READ auch WRITE und NOTIFY.  SCHREIBEN - um Daten an das Gerät zu senden, und NOTIFY - um Daten zu empfangen.  Gleichzeitig gibt es auch WRITE NOTIFY - das Gerät sendet erst nach dem Abonnieren Daten, indem es das gewünschte Byte mit dem Befehl WRITE sendet. <br><br>  Versuche, etwas mit meinen Händen zu tun, brachten kein Ergebnis, die erste Linie der Verzweiflung war erreicht, aber in diesem Moment las ich Artikel über Kunsthandwerk auf Basis von Chips von Nordic Semiconductors und legte das Programm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nRF Connect</a> auf mein Smartphone.  Mit seiner Hilfe konnte ich alle vom Gerät bereitgestellten Dienste abonnieren, die Antwortprotokolle speichern und versuchen zu verstehen, was in ihnen steckt. <br><br> <a href=""><img src="https://habrastorage.org/webt/gy/xz/ak/gyxzakm5oinigfzudk_u7zvs6tw.png"></a> <br><br>  Diese dreifachen Pfeile aktivieren das Abonnement. <br><br>  Die Besonderheit des alten Sensors war, dass die Daten zu Temperatur und Luftfeuchtigkeit in Form eines UTF-Strings vorliegen, während der neue alles in binärer Form zurückgibt. <br><br><h2>  Benachrichtigungen abonnieren </h2><br>  Um Daten vom Sensor zu empfangen, müssen Sie eine Abonnementanfrage senden.  In der Mitemp-Bibliothek wurden dafür zwei Bytes für das Merkmal gesendet, aber es ist nicht klar, woher es stammt. Hier habe ich mir die Datenstruktur für den alten Sensor in nRF Connect angesehen und festgestellt, dass die gewünschte Adresse für das Merkmal mit Daten wie ein Deskriptor angegeben ist.  Dann fing ich wieder an, die Dokumentation für bluepy zu lesen und stellte fest, dass die Deskriptoradresse leicht aus dem Merkmalobjekt erhalten werden kann.  Es bleibt nur eine Klasse mit einer Rückrufmethode zu schreiben, die Daten von der Benachrichtigung empfängt. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDelegate</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(btle.DefaultDelegate)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cHandle, data)</span></span></span><span class="hljs-function">:</span></span> print(data) mac_addr = <span class="hljs-string"><span class="hljs-string">'3F:59:C8:80:70:BE'</span></span> p = btle.Peripheral(mac_addr) p.setDelegate(MyDelegate()) uuid = <span class="hljs-string"><span class="hljs-string">'EBE0CCC1-7A0A-4B0C-8A1A-6FF2997DA3A6'</span></span> <span class="hljs-comment"><span class="hljs-comment">#    ,        ch = p.getCharacteristics(uuid=uuid)[0] #     desc = ch.getDescriptors(forUUID=0x2902)[0] #  ,         desc.write(0x01.to_bytes(2, byteorder="little"), withResponse=True) while True: p.waitForNotifications(5.0)</span></span></code> </pre> <br><h2>  Wir trennen die Körner von der Spreu </h2><br>  Glücklicherweise wurden nur drei Merkmale als WRITE NOTIFY markiert, während die Daten unterschiedliche Frequenzen und visuelle Merkmale aufwiesen. <br><br>  Die erste Anfrage schickte sofort eine große Menge Daten und blieb dann hängen.  In diesem Fall war das erste Byte eine monoton ansteigende Zahl.  Dies scheint eine akkumulierte Geschichte von Durchschnittswerten zu sein. <br><br>  Der zweite und der dritte wurden regelmäßig gesendet, aber bei genauerem Hinsehen stellte ich fest, dass sich einer von ihnen nicht ändert und in den Daten des zweiten nur ein Byte geändert wird.  Nun, dann ist dies die aktuelle Zeit (ich erinnere Sie daran, dass dieses Thermometer eine Uhr hat. In jedem Gerät mit Selbstachtung sollte eine Uhr für ein Smart Home vorhanden sein). <br><br>  Angenommen, das dritte Merkmal sind nützliche Daten zu Temperatur und Luftfeuchtigkeit.  Um die Hypothese zu bestätigen, wurde ein physikalisches Experiment durchgeführt - er ging zum Sensor und atmete ihn grob ein.  Die Datenwerte stiegen auf dem Display stark an und die Bytes änderten sich im Terminal.  Hurra, die Daten sind irgendwo in der Nähe. <br><br><h2>  Datenanalyse </h2><br>  Normalerweise arbeite ich mit Textdaten (HTTP-Daten in Form von JSON / xml abrufen, in eine Datei oder in eine Datenbank einfügen), daher habe ich nicht wirklich verstanden, wie ich mit der Aufgabe umgehen soll.  Aus diesem Grund habe ich versucht, die Daten auf verschiedene Arten zu transformieren, die aus Python erstellt werden können.  Ich schrieb hier eine solche Konvertierungsfunktion und begann zu beobachten, wie dies mit den Daten auf dem Sensorbildschirm korreliert. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> print([x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v]) print(<span class="hljs-string"><span class="hljs-string">'{0:#x}'</span></span>.format(int.from_bytes(data, byteorder=<span class="hljs-string"><span class="hljs-string">'big'</span></span>))) print(<span class="hljs-string"><span class="hljs-string">'{0:#x}'</span></span>.format(int.from_bytes(data, byteorder=<span class="hljs-string"><span class="hljs-string">'little'</span></span>)))</code> </pre> <br>  In die Konsole strömten Linien mit unterschiedlichem Grad an Dunkelheit, aber das dritte Byte war immer eine Zahl, und diese Zahl stimmte mit dem Feuchtigkeitswert überein.  Aus Gründen der Wiedergabetreue habe ich den Sensor noch einmal eingeatmet - und die Feuchtigkeitswerte auf dem Bildschirm und im dritten Byte haben sich geändert! <br><br>  Dann schlug ich vor, dass die Temperatur in den ersten zwei Bytes gespeichert wird.  Damit sich die Daten ändern können, habe ich den Sensor auf einen beheizten Handtuchhalter im Badezimmer übertragen.  Aber egal wie ich versuchte, die Ergebnisse zu transformieren, die erforderlichen Zahlen funktionierten nicht. <br><br><h2>  Auf dem Weg zum Erfolg </h2><br>  In diesem Moment schaute ich noch einmal auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beschreibung des Sensors</a> und sah, dass sich darin ein Sensor von Swiss Sensirion befand.  Es lohnt sich wahrscheinlich, damit zu beginnen, aber dies ist nicht unsere Methode.  Auf der Swiss Sensirion-Website wurden eine Reihe von Sensoren und Datenblätter dafür gefunden.  Im Datenblatt wurde unter anderem eine Formel gefunden, um über den I2C-Bus übertragene Bytes in eine Zahl umzuwandeln. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">T</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-4"><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0em; margin-right: 0em;">°</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">C</span><span class="MJXp-mo" id="MJXp-Span-7" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-8" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-9" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-10">45</span><span class="MJXp-mo" id="MJXp-Span-11" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-12">175</span><span class="MJXp-mtext" id="MJXp-Span-13">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">t</span><span class="MJXp-mtext" id="MJXp-Span-18">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">c</span><span class="MJXp-mrow" id="MJXp-Span-23"><span class="MJXp-msubsup" id="MJXp-Span-24"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25" style="margin-right: 0.05em;">S</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-26" style="vertical-align: -0.4em;">T</span></span></span><span class="MJXp-mrow" id="MJXp-Span-27"><span class="MJXp-msubsup" id="MJXp-Span-28"><span class="MJXp-mn" id="MJXp-Span-29" style="margin-right: 0.05em;">2</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-30" style="vertical-align: 0.5em;">1</span></span><span class="MJXp-mn" id="MJXp-Span-31">6</span><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-33">1</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> T [° C] = -45 + 175 \ cdot \ frac {S_T} {2 ^ 16-1} </script></p><br><br>  Aber ... es stellte sich als sehr seltsame Werte heraus.  So etwas wie -34,66, aber ich war deutlich wärmer.  Aus Trauer und Trauer öffnete ich sogar den Sensor und überprüfte, ob der Sensor von Swiss Sensirion dort wahr war.  Es stellte sich heraus, dass es wahr war, aber mit dem SHTC3-Index, und es brauchte eine etwas andere Formel dafür. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">T</span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-37"><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0em; margin-right: 0em;">°</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">C</span><span class="MJXp-mo" id="MJXp-Span-40" style="margin-left: 0em; margin-right: 0em;">]</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-43">45</span><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-45">175</span><span class="MJXp-mtext" id="MJXp-Span-46">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">t</span><span class="MJXp-mtext" id="MJXp-Span-51">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">c</span><span class="MJXp-mrow" id="MJXp-Span-56"><span class="MJXp-msubsup" id="MJXp-Span-57"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58" style="margin-right: 0.05em;">S</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-59" style="vertical-align: -0.4em;">T</span></span></span><span class="MJXp-mrow" id="MJXp-Span-60"><span class="MJXp-msubsup" id="MJXp-Span-61"><span class="MJXp-mn" id="MJXp-Span-62" style="margin-right: 0.05em;">2</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-63" style="vertical-align: 0.5em;">1</span></span><span class="MJXp-mn" id="MJXp-Span-64">6</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> T [° C] = -45 + 175 \ cdot \ frac {S_T} {2 ^ 16} </script></p><br><br>  Trotzdem ähnelten die Daten nach der Konvertierung nicht einmal den tatsächlichen.  Hier war ich noch trauriger, öffnete den Quellcode der Bibliothek für Adfruits SHTC3 und begann zu versuchen, den Transformationscode von C ++ an Python anzupassen.  Ich habe alles auf das Tablet gebracht - Rohdaten, konvertierte Struktur und Ergebnis. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cHandle, data)</span></span></span><span class="hljs-function">:</span></span> temp = data[:<span class="hljs-number"><span class="hljs-number">2</span></span>] humid = data[<span class="hljs-number"><span class="hljs-number">2</span></span>] unpacked = struct.unpack(<span class="hljs-string"><span class="hljs-string">'H'</span></span>, temp)[<span class="hljs-number"><span class="hljs-number">0</span></span>] print(data, unpacked, <span class="hljs-number"><span class="hljs-number">-45</span></span> + <span class="hljs-number"><span class="hljs-number">175</span></span> * unpacked / <span class="hljs-number"><span class="hljs-number">2</span></span> ** <span class="hljs-number"><span class="hljs-number">19</span></span>, sep=<span class="hljs-string"><span class="hljs-string">'\t'</span></span>)</code> </pre> <br>  Habe so etwas: <br><br><pre> <code class="plaintext hljs">b',\n2' 2604 -44.130821228027344 b'-\n2' 2605 -44.1304874420166 b'+\n2' 2603 -44.131155014038086 b',\n2' 2604 -44.130821228027344</code> </pre> <br>  Ja ... es ist irgendwie kalt ... Aber warte, warte, was ist 2604?  Das ist es, 26,0 Grad auf dem Bildschirm!  Um die Hypothese zu bestätigen, brachte er den Sensor erneut zur Batterie und überprüfte, ob die Werte übereinstimmen. <br><br>  Als Ergebnis erhalten wir den folgenden Datenkonvertierungscode: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleNotification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cHandle, data)</span></span></span><span class="hljs-function">:</span></span> humid_bytes = data[<span class="hljs-number"><span class="hljs-number">2</span></span>] temp_bytes = data[:<span class="hljs-number"><span class="hljs-number">2</span></span>] humidity = humid_bytes temperature = struct.unpack(<span class="hljs-string"><span class="hljs-string">'H'</span></span>, temp_bytes)[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">100</span></span> print(temperature, humidity)</code> </pre><br><h2>  Nachwort </h2><br>  Die Verbindung zum Sensor und die Suche nach dem richtigen Transformationsalgorithmus dauerte einige Abende.  Mehrmals wollte ich alles fallen lassen, aber gleichzeitig kamen neue Ideen und ich versuchte es weiter. <br><br>  Jetzt werden die Daten an den Home Assistant übertragen. Anschließend müssen Sie den Integrationscode fertigstellen und möglicherweise von bluepy in düster umschreiben, da bleak async / await verwendet und besser für den von aiohttp geschriebenen Home Assistant geeignet ist. <br><br><img src="https://habrastorage.org/webt/jm/eb/ij/jmebijgiosb2hpbfup3agswpsgu.png"><br><br><h3>  Referenzen: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sensorseite auf mi.com</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bluepy Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SHTC3-Sensor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienste und Funktionen MJ_HT_V1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen und Funktionen LYWSD02</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository mit Entwurf der Home Assistant-Integration</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452558/">https://habr.com/ru/post/de452558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452546/index.html">AirSelfie 2 Power Edition - Valik Kamera. Oder nicht?</a></li>
<li><a href="../de452548/index.html">Und was bist du bereit für ein iPhone?</a></li>
<li><a href="../de452550/index.html">Frontend Weekly Digest (13. - 19. Mai 2019)</a></li>
<li><a href="../de452552/index.html">Cross-Kompilieren von Scala in einem Gradle-Projekt</a></li>
<li><a href="../de452556/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 365 (13. - 19. Mai 2019)</a></li>
<li><a href="../de452560/index.html">PHP Digest Nr. 156 (6. - 20. Mai 2019)</a></li>
<li><a href="../de452562/index.html">Schreiben von sauberem und skalierbarem JavaScript-Code: 12 Tipps</a></li>
<li><a href="../de452564/index.html">Python 3-Funktionen, die es wert sind, verwendet zu werden</a></li>
<li><a href="../de452566/index.html">Node.js für Anfänger: Grundlagen der Arbeit mit Dateien</a></li>
<li><a href="../de452568/index.html">Eine detaillierte Analyse der neuen Funktionen von React 16+, Teil 1: Allgemeine Informationen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>