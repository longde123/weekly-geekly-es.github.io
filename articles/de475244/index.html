<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍐 👩‍👧‍👧 🍜 Erwartete neue JavaScript-Funktionen, die Sie kennen sollten 🐨 ⛹🏼 🕺🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit der Veröffentlichung des ECMAScript 2015-Standards (auch ES6 genannt) hat sich JavaScript grundlegend geändert und verbessert. Dies sind sehr gut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erwartete neue JavaScript-Funktionen, die Sie kennen sollten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/475244/">  Seit der Veröffentlichung des ECMAScript 2015-Standards (auch ES6 genannt) hat sich JavaScript grundlegend geändert und verbessert.  Dies sind sehr gute Nachrichten für alle JS-Entwickler.  Außerdem wird jetzt jedes Jahr eine neue Version von ECMAScript veröffentlicht.  Vielleicht haben Sie der neuesten Version des Standards, die im Juni 2019 veröffentlicht wurde, nicht viel Aufmerksamkeit geschenkt.  Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, möchte kurz und bündig über die Neuerungen von JavaScript und darüber berichten, was in der nächsten Version des ECMAScript-Standards zu erwarten ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/fi/vc/hd/fivchddl8mlzwem95dlmcvypba4.png"></a> <br><br>  Chancen, deren Vorschläge sich in der dritten Genehmigungsstufe (Stufe 3) befinden, werden hier erwähnt.  Dies bedeutet, dass sie wahrscheinlich in der nächsten Version des ECMAScript-Standards erscheinen, dies kann jedoch nicht mit absoluter Sicherheit bestätigt werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In diesem</a> Repository finden Sie Informationen zu Vorschlägen, die sich in verschiedenen Genehmigungsphasen befinden. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Funktionen ECMAScript 2019 (ES10)</font> </h2><br>  Der ES10-Standard bietet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele</a> neue Funktionen.  Hier werden wir nur einige davon betrachten.  Nämlich ein paar neue Array-Methoden. <br><br><h3>  <font color="#3AC1EF">▍ Methode Array.prototype.flat</font> </h3><br>  Mit dieser Methode können Sie Arrays, die andere Arrays enthalten, "flacher" machen und sie auf eine bestimmte Tiefenebene "komprimieren". <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]]; array.flat(); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4];</span></span></code> </pre> <br>  Dies ist eine sehr nützliche Funktion, insbesondere in Fällen, in denen Sie mit verschachtelten Arrays arbeiten müssen.  Wenn die Verschachtelungstiefe von Arrays in der Datenstruktur 1 überschreitet, kann ein einzelner Aufruf der <code>flat</code> Methode das Array nicht vollständig "flach" machen.  Diese Methode akzeptiert eine optionale Parametertiefe, mit der Sie angeben können, um wie viele Verschachtelungsebenen die Dimension des verarbeiteten Arrays reduziert werden soll. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const crazyArray = [1, 2, [3, 4], [[5], [6, [7,8]]]]; crazyArray.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8]; // ,  flat,    </span></span></code> </pre> <br>  Je tiefer das Array ist, desto mehr Rechenressourcen werden für die Verarbeitung benötigt.  Bitte beachten Sie, dass IE und Edge diese Funktion nicht unterstützen. <br><br><h3>  <font color="#3AC1EF">▍ Array.prototype.flatMap-Methode</font> </h3><br>  Diese Methode verarbeitet zuerst die Elemente des Arrays mit der übergebenen Funktion und konvertiert dann das Array in eine flache Struktur. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"it's Sunny in"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"California"</span></span>]; arr.flatMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ["it's","Sunny","in", "", "California"]</span></span></code> </pre> <br>  Der Unterschied zwischen <code>flat</code> und <code>flatMap</code> besteht darin, dass Sie Ihre eigene Funktion an die <code>flatMap</code> Methode übergeben können, mit der die Elemente des ursprünglichen Arrays konvertiert werden.  Darüber hinaus „hebt“ <code>flatMap</code> im Gegensatz zu <code>flat</code> die Elemente von Arrays nur um eine Ebene an.  Diese Methode gibt ein neues Array zurück.  In solchen Fällen kann es hilfreich sein, wenn Sie die Elemente eines Arrays irgendwie verarbeiten müssen, bevor Sie es „flach“ machen. <br><br><h2>  <font color="#3AC1EF">Neue JS-Funktionen in Phase 3 der Genehmigung</font> </h2><br>  In der dritten Phase der Koordinierung gibt es viele interessante neue Vorschläge zur Erweiterung und Verbesserung der Sprache.  Betrachten wir einige davon. <br><br><h3>  <font color="#3AC1EF">▍ Zifferntrennzeichen</font> </h3><br>  Es ist Ihnen passiert: Schreiben Sie eine lange Zahl in eine Variable und zweifeln Sie an der korrekten Schreibweise?  Der betreffende Satz erlaubt es uns, die Bits von Zahlen durch Unterstriche zu trennen.  Dies erleichtert das Arbeiten mit Zahlen. <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>_000_000_000      <span class="hljs-comment"><span class="hljs-comment">// ,   101_475_938.38     //     -     let fee = 123_00;    // $123 (, , 12300 ) let fee = 12_300;    // $12,300 (  !) let amount = 12345_00; // 12,345 (,  , 1234500 ) let amount = 123_45.00; // 12345 (, -  ) let amount = 1_234_500; // 1,234,500 let budget = 1_000_000_000_000; //   `budget`?  - 1 ! // // : console.log(budget === 10 ** 12); // true</span></span></code> </pre> <br>  Nachdem jeder Entwickler diese Funktion akzeptiert hat, entscheidet er selbst, ob Entladungsabscheider verwendet werden sollen oder nicht.  Eines ist jedoch sicher: Diese Funktion kann die mit der Berechnung der Ziffern großer Zahlen verbundenen Unannehmlichkeiten verringern. <br><br><h3>  <font color="#3AC1EF">▍Verwenden Sie, um auf der obersten Codeebene zu warten</font> </h3><br>  Durch die Verwendung des Schlüsselworts <code>await</code> auf der obersten Codeebene können Module als große asynchrone Funktionen fungieren.  Aufgrund dieser Funktion können ECMAScript-Module das Erscheinen einiger Ressourcen erwarten.  Dies führt dazu, dass andere Module, die sie importieren, warten, bis der Hauptteil der importierten Module betriebsbereit ist. <br><br>  Der Grund für diese Funktion ist, dass beim Importieren eines Moduls, für das eine Funktion mit dem <code>async</code> , die Ausgabe dieser Funktion <code>undefined</code> . <br><br>  Das folgende Beispiel zeigt zwei Dateien.  Es kann <code>undefined</code> <code>output</code> wenn die Funktion aufgerufen wird, bevor die durch die Versprechungen dargestellten Aufgaben abgeschlossen sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// awaiting.mjs import { process } from "./some-module.mjs"; const dynamic = import(computedModuleSpecifier); const data = fetch(url); export const output = process((await dynamic).default, await data); // usage.mjs import { output } from "./awaiting.mjs"; export function outputPlusValue(value) { return output + value } console.log(outputPlusValue(100)); setTimeout(() =&gt; console.log(outputPlusValue(100), 1000);</span></span></code> </pre> <br>  Alles wird in der <code>awaiting.js</code> bis die <code>awaiting.js</code> in <code>awaiting.js</code> aufgelöst sind. <br><br><h3>  <font color="#3AC1EF">▍Betreiber ??</font>  <font color="#3AC1EF">und Überprüfung der Werte nur auf Null und undefiniert</font> </h3><br>  Vielleicht ist dies unter allen Stage 3-Angeboten das nützlichste.  Wir müssen oft so etwas schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {  <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'James'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = obj.name || <span class="hljs-string"><span class="hljs-string">'Jane'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// James</span></span></code> </pre> <br>  Wenn <code>obj.name</code> durch einen falschen Wert dargestellt wird, erhält die Zeichenfolge <code>Jane</code> <code>name</code> .  Infolgedessen ist der <code>name</code> nicht wie <code>undefined</code> .  Das Problem ist jedoch, dass eine leere Zeichenfolge in diesem Fall als falscher Wert wahrgenommen wird.  Wenn dies berücksichtigt wird, sollte dieser Code wie folgt umgeschrieben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name = (obj.name &amp;&amp; obj.name !== <span class="hljs-string"><span class="hljs-string">''</span></span>) || <span class="hljs-string"><span class="hljs-string">'Jane'</span></span>;</code> </pre> <br>  Es ist unpraktisch, die ganze Zeit so zu schreiben.  Betreiber <code>??</code>  (zwei Fragezeichen) erlaubt nur das Überprüfen von <code>null</code> und <code>undefined</code> Werten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = {  <span class="hljs-attr"><span class="hljs-attr">settings</span></span>: {    <span class="hljs-attr"><span class="hljs-attr">nullValue</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    <span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-number"><span class="hljs-number">400</span></span>,    <span class="hljs-attr"><span class="hljs-attr">animationDuration</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="hljs-attr"><span class="hljs-attr">headerText</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>,    <span class="hljs-attr"><span class="hljs-attr">showSplashScreen</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>  } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> undefinedValue = response.settings.undefinedValue ?? <span class="hljs-string"><span class="hljs-string">'some other default'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 'some other default' const nullValue = response.settings.nullValue ?? 'some other default'; // : 'some other default' const headerText = response.settings.headerText ?? 'Hello, world!'; // : '' const animationDuration = response.settings.animationDuration ?? 300; // : 0 const showSplashScreen = response.settings.showSplashScreen ?? true; // : false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Bediener ?.</font>  <font color="#3AC1EF">und optionale Ketten</font> </h3><br>  Dieser Vorschlag ähnelt dem gerade überprüften und kombiniert <code>null</code> und <code>undefined</code> Prüfungen.  Es ist bekannt, dass Benutzer von TypeScript <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">an</a> dieser Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interessiert sind</a> . <br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> city = country &amp;&amp; country.city; <span class="hljs-comment"><span class="hljs-comment">// undefined  city  </span></span></code> </pre> <br>  Um zum Stadteigentum eines Landobjekts zu gelangen, müssen Sie das Vorhandensein des Landobjekts und das Vorhandensein des Stadteigentums darin überprüfen. <br><br>  Mit dem Operator <code>?.</code>  (Fragezeichen und Punkt) Dieser Code kann folgendermaßen konvertiert werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> city = country?.city; <span class="hljs-comment"><span class="hljs-comment">// undefined  city  </span></span></code> </pre> <br>  Diese Funktion scheint in folgenden Situationen nützlich zu sein: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { fetch } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../yourFetch.js'</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetch();  <span class="hljs-comment"><span class="hljs-comment">// res &amp;&amp; res.data &amp;&amp; res.data.cities || undefined  const cities = res?.data?.cities; })();</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Methode Promise.any</font> </h3><br>  Die <code>Promise.any</code> Methode akzeptiert ein <code>Promise.any</code> Objekt, das Versprechungsobjekte enthält, und gibt eine Versprechung zurück, die erfolgreich aufgelöst wurde, wenn mindestens eines der an sie übergebenen Versprechungsobjekte erfolgreich aufgelöst wurde.  Wenn alle Versprechen-Objekte abgelehnt werden, wird ein Array mit Informationen zu den Gründen für ihre Ablehnung zurückgegeben. <br><br>  So sieht die Verwendung von <code>Promise.any</code> mit dem async / await-Konstrukt aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.any(promises);  <span class="hljs-comment"><span class="hljs-comment">//      . } catch (error) {  //    . }</span></span></code> </pre> <br>  Hier ist das Gleiche mit Versprechen umgesetzt: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.any(promises).then(  <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//      .  },  (error) =&gt; {    //    .  } );</span></span></code> </pre> <br>  JavaScript verfügt bereits über <code>Promise.all</code> , <code>.allSettled</code> und <code>.race</code> , jedoch über eine ähnliche Methode.  <code>any</code> war nicht.  Infolgedessen haben wir eine neue Möglichkeit, die die bestehenden ergänzt und sich in bestimmten Situationen als nützlich erweisen kann.  Obwohl sich dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorschlag</a> bereits in der dritten Genehmigungsphase befindet, wird er möglicherweise nicht in die nächste Ausgabe des ECMAScript-Standards aufgenommen, da zusätzliche Tests erforderlich sind. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es gibt viele interessante Vorschläge für die Entwicklung von JavaScript, die sich in der dritten Genehmigungsphase befinden.  Es wird interessant sein, sie in den ES11- und ES12-Standards zu sehen.  Natürlich ist es unwahrscheinlich, dass irgendjemand sie alle verwenden wird, aber einige von ihnen werden definitiv breite Anwendung finden und zur Steigerung der Qualität des JS-Codes beitragen. <br><br>  <b>Sehr geehrte Leser!</b>  Verwenden Sie bereits JavaScript-Funktionen, die fast für die nächste Version des Standards bereit sind? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de475244/">https://habr.com/ru/post/de475244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de475228/index.html">Payroll Gabel. Du bist ein Programmierer für Mama</a></li>
<li><a href="../de475236/index.html">Ignoriere niemals wieder das Verstärkungstraining.</a></li>
<li><a href="../de475238/index.html">Blade Runner Timeline - November 2019. Hat sich die Prognose erfüllt?</a></li>
<li><a href="../de475240/index.html">Verwendung strenger Module in großen Python-Projekten: Instagram-Erfahrung. Teil 1</a></li>
<li><a href="../de475242/index.html">Verwendung strenger Module in großen Python-Projekten: Instagram-Erfahrung. Teil 2</a></li>
<li><a href="../de475246/index.html">Asynchrone Python-Programmierung: Ein kurzer Überblick</a></li>
<li><a href="../de475248/index.html">Die Verwendung von Polyfills beim Schreiben browserübergreifender Anwendungen</a></li>
<li><a href="../de475250/index.html">Als Redash ein Problem bemerkte und behebte, das zu einer Verschlechterung der Python-Code-Leistung führte</a></li>
<li><a href="../de475254/index.html">AERODISK vAIR-Architektur oder Merkmale der nationalen Clusterbildung</a></li>
<li><a href="../de475260/index.html">Der Unterschied zwischen einer asynchronen Funktion und einer Funktion, die ein Versprechen zurückgibt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>