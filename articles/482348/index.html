<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè´ üèà üîá Topolog√≠a y an√°lisis exhaustivo para un desarrollador de juegos desprevenido: comprimir vectores 3D √∫nicos üë¶üèø üö≤ üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como ya puedes entender de mis art√≠culos anteriores, me gusta usar el desarrollo de juegos como una excusa para demostrar matem√°ticas complejas para l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Topolog√≠a y an√°lisis exhaustivo para un desarrollador de juegos desprevenido: comprimir vectores 3D √∫nicos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482348/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png" alt="imagen"></div><br>  Como ya puedes entender de mis art√≠culos anteriores, me gusta usar el desarrollo de juegos como una excusa para demostrar matem√°ticas complejas para las cuales, de lo contrario, la mayor√≠a de las personas no tendr√≠an ning√∫n uso.  ¬°Y este art√≠culo no es una excepci√≥n!  Quiero mostrar una t√©cnica muy interesante, correspondiente a puntos que me interesan: <br><br><ul><li>  el proceso es lo suficientemente claro </li><li>  es mucho m√°s r√°pido que la t√©cnica habitual que realiza la misma tarea </li><li>  utiliza una propiedad muy inusual de representar n√∫meros de punto flotante en formato de punto flotante, lo que implica que ... </li><li>  <strong>No funciona en el an√°lisis cl√°sico</strong> .  Para que este algoritmo funcione en teor√≠a, ¬°debes ingresar al maravilloso mundo de las matem√°ticas no cl√°sicas!  Y si esto no despert√≥ su curiosidad, entonces no s√© qu√© m√°s hacer. </li></ul><br>  Este art√≠culo es bastante largo y te√≥rico, porque requiere un estudio profundo de las explicaciones, as√≠ que t√≥mate tu tiempo y vuelve a leer las partes que cre√≠as que no eran tan obvias la primera vez. <br><br><h2>  Un poco sobre el contexto (GPU) </h2><br>  Uno de los aspectos importantes a los que debe prestar atenci√≥n en el desarrollo de juegos, y en un sentido m√°s amplio, en cualquier √°rea con el uso activo de gr√°ficos, es el ancho de banda de la GPU.  El procesador central y la GPU son dispositivos f√≠sicos separados, y necesitan sincronizaci√≥n para intercambiar datos.  Si ya ha realizado el procesamiento en paralelo, entonces sabe que cuando dos dispositivos necesitan sincronizarse, esto significa perder una cantidad significativa de tiempo.  La interacci√≥n de la CPU-GPU a este respecto no es diferente, por lo que nos esforzamos por minimizar la transferencia de datos, tanto en el n√∫mero de operaciones como en la cantidad de datos transferidos. <br><a name="habracut"></a><br>  La minimizaci√≥n de la cantidad de operaciones de transferencia de datos generalmente se realiza mediante almacenamiento en b√∫fer: nos esforzamos por ajustar todos los datos en el menor n√∫mero posible de matrices, y luego transferimos todo de una vez para que ya no tengamos que preocuparnos por ellos.  Minimizar la cantidad de datos en las operaciones de transferencia es un tema completamente diferente, y las soluciones a este problema son casi siempre individuales.  Como un ejemplo extremo de esto, puede ver <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">c√≥mo el motor de renderizado de Destiny se adapta a la posici√≥n, las normales de superficie, las banderas de material y los par√°metros BSDF anisotr√≥picos completos de 96 bits, es decir.</a>  <a href="http://advances.realtimerendering.com/s2013/Tatarchuk-Destiny-SIGGRAPH2013.pdf">tres n√∫meros de coma flotante</a> (p. 62 en adelante).  Sin embargo, se pueden lograr buenos resultados mediante m√©todos generales, a los que luego se agregan soluciones individuales para la optimizaci√≥n. <br><br>  Hoy discutiremos la <strong>compresi√≥n sin p√©rdida de vectores individuales en 3D</strong> .  Esta oraci√≥n contiene varias palabras clave: <br><br><ul><li>  <strong>Vectores 3D √∫nicos</strong> : <strong>vectores</strong> 3D que tienen una longitud de 1 </li><li>  <strong>Compresi√≥n sin p√©rdidas</strong> : reduzca el tama√±o de las descripciones de vectores 3D √∫nicos sin p√©rdida de precisi√≥n.  Esto es lo opuesto a la <em>compresi√≥n con p√©rdida.</em> </li><li>  <strong>Separado</strong> : la codificaci√≥n y decodificaci√≥n de vectores se realiza sin informaci√≥n sobre sus vecinos.  Si la situaci√≥n fuera lo contrario, entonces podr√≠a ser algo as√≠ como la compresi√≥n por <em>lotes</em> , en la que no se comprimen vectores individuales, sino sus matrices </li></ul><br>  Antes de continuar, debo mencionar el excelente art√≠culo <a href="http://jcgt.org/published/0003/02/01/" rel="noopener"><em>"Una encuesta de representaciones eficientes para</em> <em>vectores de</em> <em>unidades independientes</em> <em>"</em></a> de Cigolle, Donow, Evangelakos, Mara, McGuire y Meyer, del cual me inspir√© para mi publicaci√≥n.  Debo decir de <strong><em>inmediato</em></strong> que el <strong>algoritmo del que hablar√© es menos eficiente que el algoritmo <em>oct</em> presentado en el art√≠culo</strong> .  Si desea la m√°xima eficiencia, lea el art√≠culo y use <em>oct</em> .  El prop√≥sito de mi publicaci√≥n es mostrar la belleza del uso de matem√°ticas muy inusuales, al tiempo que crea, como veremos m√°s adelante, un algoritmo muy conveniente. <br><br><h2>  Topolog√≠a directamente en tu videojuego </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/a95/4bc/41ca954bca54597431a9a0ebb7a9fe97.png"></div><br>  <i>En el caso de la esfera de la unidad, solo Œ∏ y œÜ son importantes, porque œÅ es siempre 1 y, por lo tanto, redundante.</i> <br><br>  El punto de partida del algoritmo es la observaci√≥n de que los vectores unitarios 3D son equivalentes a los puntos en una esfera.  Como probablemente sepa, una esfera es una superficie bidimensional, es decir, para la identificaci√≥n √∫nica de puntos en una esfera, solo se requieren dos coordenadas.  Un ejemplo muy com√∫n de esto son las coordenadas esf√©ricas, en las cuales un punto en la esfera est√° definido por dos √°ngulos, Œ∏ y œÜ. <br><br>  Curiosamente, una propiedad bastante desagradable es que aunque la esfera y el cuadrado relleno (un posible espacio para coordenadas 2D) son objetos 2D, realmente no hay correspondencia entre ellos.  Esto significa que no hay forma de unir un punto √∫nico en la esfera a cada punto √∫nico del cuadrado (al menos de manera continua);  se dice que <em>no son homeom√≥rficos</em> (en otras palabras, uno tiene un l√≠mite y el otro no).  Un resultado desagradable de esto es que algunas coordenadas 2D se pierden en el sentido de que diferentes coordenadas corresponden a puntos id√©nticos en la esfera (por ejemplo, en el caso de coordenadas esf√©ricas, cuando œÜ es 0, el punto correspondiente ser√° el polo norte, independientemente de la coordenada Œ∏).  En t√©rminos de compresi√≥n, perdemos patrones de bits valiosos con los que podr√≠amos describir los puntos de una esfera. <br><br>  Si desea m√°s matem√°tica y quiere demostrar que el cuadrado y la esfera no son homeom√≥rficos, puede usar el hecho de que la esfera, en contraste con el cuadrado, no es contra√≠ble, y la contractibilidad es una propiedad topol√≥gica;  El teorema de Borsuk-Ulam tambi√©n se puede usar como prueba.  Tambi√©n me dijeron que los grupos de homotop√≠a pueden ayudar con la prueba, pero esto ya est√° fuera de mi √°rea de especializaci√≥n. <br><br>  Sin embargo, este problema surge no solo con las coordenadas esf√©ricas;  cualquier representaci√≥n continua en 2D de los puntos de la esfera sufrir√° de ella.  Sin embargo, recuerde esto para el futuro. <br><br>  Las coordenadas esf√©ricas tambi√©n tienen otras malas propiedades: <br><br><ul><li>  Tienen una distribuci√≥n pobre sobre la esfera.  Si se generan coordenadas esf√©ricas aleatorias y se vuelven a convertir en puntos 3D, forman grupos alrededor de los polos y se enrarecer√°n bastante cerca del ecuador.  Esto se debe al hecho de que los vectores 3D cerca del ecuador ser√°n menos distinguibles con precisi√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/e1d/15a/87ce1d15ad314b007f0093b83a738538.png"></div><br>  <i>Distribuci√≥n en una esfera de 10.000 coordenadas esf√©ricas uniformemente distribuidas.</i> </li><li>  Su embalaje y desembalaje son costosos.  Para el empaque (3D ‚Üí 2D), se requiere una operaci√≥n <em>acos</em> y una <em>atan2</em> , que son funciones trigonom√©tricas inversas bastante costosas, y para desempaquetar (2D ‚Üí 3D) se requieren dos operaciones <em>cos</em> y dos operaciones <em>sin</em> , que tambi√©n est√°n lejos de ser econ√≥micas. </li></ul><br>  Consulte el art√≠culo anterior para conocer otras comparaciones de coordenadas esf√©ricas y otros m√©todos de compresi√≥n. <br><br><h2>  La tarea de preservar patrones de bits ... y velocidad </h2><br>  El m√©todo que consideraremos tiene una gran ventaja: su c√°lculo es mucho m√°s r√°pido, m√°s del doble que el punto de referencia ingenuo no optimizado (probado en el empaquetado y desempaquetado de 10 millones de vectores aleatorios en C ++ en Visual Studio 19 en Intel Core i5 7th gen).  Adem√°s, el m√©todo no tiene una singularidad, es decir, cada punto empaquetado corresponde a un √∫nico punto desempaquetado, en contraste con las coordenadas esf√©ricas mencionadas anteriormente. <br><br>  Como se mencion√≥ anteriormente, no hay homeomorfismo entre la esfera de la unidad y el cuadrado de la unidad, es decir, no podemos unir adecuadamente cada punto √∫nico en el cuadrado a otro punto √∫nico en la esfera.  Pero consideremos las siguientes construcciones: hasta ahora solo nos interesar√° el hemisferio norte, en el que hay puntos con una coordenada Z positiva o cero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/b7a/709/8a0b7a709482f110e7936fc71187e70d.png"></div><br>  <i>"Aplanamos" el hemisferio norte en el disco, <strong>descartando la coordenada Z de cada punto</strong> (o asign√°ndole un valor de 0).</i> <br><br>  Encontramos una manera de conectar cada punto en el hemisferio norte a cada punto en un solo disco.  Algunos puntos notables: <br><br><ul><li>  el polo norte cae en (0, 0). </li><li>  cada punto en el l√≠mite del hemisferio permanece igual.  M√°s espec√≠ficamente, el hemisferio y el disco tienen el mismo l√≠mite.  Esto es l√≥gico, porque los puntos en el l√≠mite del hemisferio tienen Z = 0, es decir, descartando la coordenada Z, no cambiamos nada. </li></ul><br><h3>  Compresi√≥n de disco: una tarea simple y compleja </h3><br>  La siguiente construcci√≥n requiere una peque√±a introducci√≥n.  Por si acaso, dir√© que los n√∫meros complejos son una extensi√≥n del espacio de los n√∫meros reales (n√∫meros ordinarios como 0, 1, 129,43, pi, 335/117, ra√≠z cuadrada 2, etc.), que usa un n√∫mero especial que llam√© <em>imaginario unidad</em>  Los n√∫meros complejos tienen la forma <em>a + ib</em> , donde <em>a</em> y <em>b</em> son algunos n√∫meros reales (respectivamente, las partes real e imaginaria), y <em>tengo</em> la propiedad <em>i</em> ¬≤ = -1.  Esto nos permite unir n√∫meros complejos con puntos en un plano 2D.  Si tomamos para <em>z un</em> n√∫mero complejo de la forma <em>z = a + ib</em> , entonces podemos representar <em>z como un</em> punto con coordenadas ( <em>a</em> , <em>b</em> ) en el plano.  Las funciones de extracci√≥n de la "parte real" y la "parte imaginaria" del n√∫mero complejo <em>z se</em> denotan por <em>Re (z)</em> e <em>Im (z)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c7/3d5/9b2/3c73d59b25bb8db10409e8c763b90154.png"></div><br>  <i>El n√∫mero complejo <em>z</em> y sus valores.</i> <br><br>  Adem√°s de las partes reales e imaginarias del n√∫mero complejo, tambi√©n se puede tener en cuenta la longitud y el √°ngulo formado por √©l con el eje X. Esto se denomina <em>representaci√≥n polar</em> .  La longitud polar y el √°ngulo polar son la norma <em>| z |</em>  y argumento <em>Arg (z)</em> .  Una propiedad conveniente de ambas representaciones es que la <strong>adici√≥n de n√∫meros complejos se realiza sumando las partes reales e imaginarias</strong> , y la <strong>multiplicaci√≥n de n√∫meros complejos se realiza multiplicando las normas y sumando los argumentos</strong> . <br><br>  Aqu√≠ nos interesan dos operaciones: cuadrar y obtener la ra√≠z cuadrada de un n√∫mero complejo.  La cuadratura de un n√∫mero complejo es exactamente la misma que para los n√∫meros reales: simplemente lo multiplicamos por nosotros mismos, esencialmente <strong>cuadrando la norma y duplicando el argumento</strong> .  Tenga en cuenta que si la norma de un n√∫mero complejo es menor que 1, cuando lo cuadre, su longitud ser√° menor que uno;  Por lo tanto, si tomamos cada n√∫mero complejo en el disco que tiene una parte real positiva y los ponemos todos en un cuadrado, entonces esencialmente obtendremos el disco completo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/7f3/af0/0cf7f3af09328146ee38a26f4e72eddb.png"></div><br>  <i>A la izquierda hay varios n√∫meros complejos en la mitad del disco con la parte real positiva (coordenada X).</i>  <i>A la derecha est√° el resultado de cuadrar todos estos puntos.</i>  <i>¬°La mitad del disco ahora llena todo el disco!</i> <br><br>  Un truco est√° asociado con "duplicar un argumento": depende del lado del eje X en el que se encuentra el punto.  La regla se muestra a continuaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/ed7/ddd/8cced7ddd2e812dd5d4361131a500f95.png"></div><br>  <i>Un n√∫mero complejo con una parte imaginaria positiva (coordenada Y) gira hacia la izquierda, y un n√∫mero complejo con una parte imaginaria negativa (coordenada Y) gira hacia la derecha.</i> <br><br>  Como en el caso de los n√∫meros reales, la ra√≠z cuadrada es el inverso de la cuadratura: para un n√∫mero complejo dado <em>z</em> , las ra√≠ces cuadradas (dos de ellas) son los n√∫meros <em>c</em> , de modo que <em>c¬≤ = z</em> .  Como en el caso de los n√∫meros reales, si <em>c</em> es la ra√≠z cuadrada de <em>z</em> , entonces <em>-c</em> tambi√©n lo es.  El de los n√∫meros <em>c</em> y <em>-c</em> , cuyo argumento es igual a la mitad del argumento <em>z</em> , se llama el valor principal de la ra√≠z cuadrada (esto es similar a tomar la ra√≠z cuadrada positiva de un n√∫mero real en lugar de la ra√≠z cuadrada negativa). <br><br>  Si comprende que cuando un n√∫mero complejo es al cuadrado, su norma es al cuadrado y su argumento se duplica, entonces puede adivinar f√°cilmente que el valor principal de la ra√≠z cuadrada toma la ra√≠z cuadrada de la norma y reduce a la mitad el argumento (siguiendo la regla que se muestra arriba, pero con las flechas al rev√©s) .  Como en el caso de la cuadratura, cuando se saca la ra√≠z cuadrada de un n√∫mero complejo con una norma menor que 1, la norma permanece menor que 1;  por lo tanto, "comprime" el disco de la unidad en sus n√∫meros reales medio positivos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51f/7cc/5f0/51f7cc5f0b9616d7f82f09a29e3c14c7.png"></div><br>  <i>A la izquierda hay varios puntos en un solo disco.</i>  <i>El lado derecho muestra el resultado de sacar la ra√≠z cuadrada de todos estos puntos.</i>  <i>¬°Todo el disco ahora cabe en la mitad de s√≠ mismo!</i> <br><br>  Esta es la base del algoritmo: de hecho, comprimimos todo el disco de la unidad en la mitad con la parte real positiva.  Como recordar√°n, recientemente hemos aplanado la mitad superior de una esfera en un solo disco;  Ahora vale la pena ver qu√© haremos con √©l. <br><br><h3>  Poniendo todo junto </h3><br>  Resumamos lo que acabamos de hacer: aplanamos la mitad de la esfera en una unidad de disco, descartando la coordenada Z de todos sus puntos, y exprimimos la unidad de disco en su propia mitad con la parte real positiva usando el complejo valor de la ra√≠z cuadrada principal.  De hecho, ¬°aplanamos la mitad de la esfera en la mitad del disco!  Ahora con algunos cambios, podemos hacer lo mismo para comprimir la mitad restante de la esfera en la mitad restante del disco. <br><br>  La mitad inferior de la esfera (todos los puntos de la esfera con una coordenada Z negativa) tambi√©n se aplanan en un disco unitario al soltar repetidamente las coordenadas Z. Sin embargo, para todos los n√∫meros complejos <em>z</em> en el disco, tomamos el valor opuesto a la ra√≠z cuadrada principal de <em>z</em> (es decir, tomamos <em>-c en</em> lugar de <em>c</em> )  Como el valor principal de la ra√≠z cuadrada siempre tiene una parte real positiva, el valor opuesto siempre tendr√° una parte real negativa;  de hecho, aplanamos la mitad restante de la esfera en la mitad restante del disco, ¬°y la etapa de compresi√≥n ahora est√° completa! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/910/fcb/d9f/910fcbd9f721b1ceea2de3b3a56bcb2c.png"></div><br>  <i>Paso de compresi√≥n completa.</i>  <i>Tenga en cuenta que los hemisferios norte y sur (azul y naranja) se aplanan en dos copias de un solo disco y luego se comprimen en dos mitades de un solo disco.</i> <br><br>  El algoritmo de compresi√≥n es el siguiente: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unit)</span></span></span><span class="hljs-function"> disk </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Complex(unit.x, unit.y) packed = principalSquareRoot(disk) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit.z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? -packed : packed</code> </pre> <br>  Y as√≠, en solo tres l√≠neas de pseudoc√≥digo, aplicamos toda la teor√≠a que examinamos para crear un algoritmo efectivo.  Si su entorno no tiene una f√≥rmula para el valor principal de la ra√≠z cuadrada, puede encontrarla <a href="https://en.wikipedia.org/wiki/Square_root" rel="noopener">en Wikipedia</a> (se debe prestar especial atenci√≥n a elegir el signo de la parte imaginaria).  Aqu√≠ est√° la implementaci√≥n de referencia de C ++ que uso en mi c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Principal complex square root of 'x + iy' float2 csqrt(float x, float y) { float r = sqrt(x * x + y * y); return float2(sqrt((r + x) / 2), (y &lt; 0 ? -1 : 1) * sqrt((r - x) / 2)); }</span></span></code> </pre> <br><h3>  Regresa </h3><br>  Afrontamos la compresi√≥n, ahora procedemos a descomprimir. <br><br>  El desempaquetado consiste en el orden inverso de todos los pasos de compresi√≥n: <br><br><ul><li>  expandimos las mitades positivas y negativas de las partes materiales de un solo disco en dos discos completos </li><li>  unir cada disco completo con su hemisferio correspondiente </li></ul><br>  En resumen, comenzamos con el valor empaquetado de <em>p</em> , lo elevamos al cuadrado para volver al punto en el disco obtenido de uno de los hemisferios, y luego usamos el signo <em>Re (p)</em> para averiguar de qu√© hemisferio se toma el punto en el disco.  Usando la ecuaci√≥n <em>x¬≤ + y¬≤ + z¬≤ = 1</em> , que define los puntos en la esfera de la unidad, podemos recrear la coordenada Z faltante del punto empaquetado. <br><br>  Cabe se√±alar que calcular el cuadrado del valor empaquetado siempre nos dar√° el punto correcto del disco, independientemente de su hemisferio inicial (superior o inferior), porque <em>z¬≤ =</em> <em>(-z) ¬≤</em> . <br><br>  El algoritmo de descompresi√≥n es el siguiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Y entonces obtuvimos un algoritmo que crea de manera muy eficiente una representaci√≥n 2D de vectores 3D √∫nicos, que, a diferencia de las coordenadas esf√©ricas, no pierde ning√∫n patr√≥n de bits y no tiene singularidad.  Si no tiene en cuenta un par de trucos de optimizaci√≥n para acelerar los c√°lculos, esta es una versi√≥n casi lista para usar del algoritmo. <br><br>  ... o no?  Si observabas atentamente, te diste cuenta de que algo anda mal aqu√≠.  ¬øDije que la esfera y el cuadrado de la unidad no son homeom√≥rficos, y sin embargo, de alguna manera fue capaz de unir un punto √∫nico en el disco a cada punto √∫nico en la esfera?  Adem√°s, no hemos mencionado ninguna matem√°tica no cl√°sica, entonces, ¬øqu√© est√° pasando? <br><br>  De hecho, nuestro algoritmo tiene un serio inconveniente: funciona para todos los puntos en toda la esfera, excepto para los puntos en el hemisferio norte con Y = 0 y X &lt;= 0, que, al empacar y desempacar, se comparan err√≥neamente con el punto correspondiente en el hemisferio norte. <br><br>  La raz√≥n de esto es que cuando se descartan sus coordenadas Z, el n√∫mero complejo correspondiente es un n√∫mero real negativo, no tiene una parte imaginaria.  Cuando tomamos el valor principal de la ra√≠z cuadrada de un n√∫mero real negativo, a su vez obtenemos un n√∫mero complejo completamente imaginario que no tiene la parte real (esto es similar al hecho de que el valor principal de la ra√≠z cuadrada de -1 es igual a <em>i</em> ).  Luego tratamos de mantener el signo de la coordenada Z en lo que es esencialmente cero. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6bc/720/d08/6bc720d085469f478453dc4c961e2036.png"></div><br>  <i>Tira de problemas</i>  <i>Los puntos con Y = 0 y X &lt;= 0 se agrupan en una l√≠nea de n√∫meros puramente imaginarios con partes reales indefinibles.</i> <br><br>  Veamos qu√© sucede cuando empacamos dos de esos puntos (no olvide que x &lt;= 0). <br><br><blockquote><pre>  El |  Punto norte |  Punto sur
  unidad |  (x, 0, z) |  (x, 0, -z)
  disco |  x + 0i |  x + 0i
 embalado |  0 + ‚àö (-x) i |  -0 - ‚àö (-x) i </pre></blockquote><br>  Dado que la parte imaginaria de la proyecci√≥n en el disco de ambos puntos es igual a cero, no podemos almacenar el signo de la coordenada Z en el signo de la parte real del valor principal de la ra√≠z cuadrada, porque en s√≠ mismo es igual a cero.  Simplemente podemos detenernos en esto, aceptando el hecho de que el algoritmo no funciona para estos puntos, o podemos seguir adelante. <br><br><h2>  Olvida lo que aprendimos </h2><br>  En todas las √°reas y ramas de las matem√°ticas que conozco, se supone que 0 = -0.  Esto se deduce de la definici√≥n de <em>-a</em> , que es lo opuesto a <em>a</em> , indicando que <em>"-a es el √∫nico n√∫mero que da 0 cuando se suma con a"</em> .  Dado que 0 tambi√©n es un elemento cero con respecto a la suma ( <em>0 + a = a + 0 = a</em> ), lo √∫nico que necesita agregar a 0 para obtener 0 es 0 en s√≠ mismo. <br><br>  Sin embargo, en el desarrollo de software, todo es diferente.  En la mayor√≠a de las representaciones de n√∫meros de coma flotante, junto con el exponente y la mantisa, se utiliza un bit extra para almacenar el personaje.  Esto significa que cuando el exponente y la mantisa son 0, el bit de signo se puede usar para distinguir entre ceros positivos y negativos.  En la mayor√≠a de los lenguajes de programaci√≥n (si no todos), estos dos ceros se tratan como un solo cero (solo intente <em>0 == -0</em> ), pero hay una diferencia, y esto se puede ver si intenta enviar ‚Äú-0‚Äù y ‚Äú0 al terminal "- as√≠ es como se deducir√°n. <br><br>  Esto es extremadamente importante para nosotros: ¬°el valor de cero puede usarse para almacenar informaci√≥n sobre el signo!  De hecho, se almacena correctamente de todos modos;  en nuestro caso, el problema es que no se lee correctamente.  Si miramos la pen√∫ltima l√≠nea en el algoritmo de desempaquetado, veremos lo siguiente: <br><br><pre> <code class="cpp hljs">packed.real() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Esta operaci√≥n lee el signo de la parte real del valor empaquetado para determinar a qu√© hemisferio pertenece el punto: norte o sur.  Sin embargo, en el caso de <em>empaquetado.real ()</em> es 0 o -0, el operador de comparaci√≥n ignora el car√°cter y el operador ternario siempre devuelve 1. La forma correcta de leer el car√°cter es una solicitud <em>real</em> del estado del bit de signo, por ejemplo, usando <em>std :: signbit</em> de C ++ o <em>np .signbit</em> de Numpy a Python: la funci√≥n depende del idioma.  Recuerde que el bit de signo es 1 cuando el n√∫mero es negativo y 0 cuando el n√∫mero es positivo. <br><br>  Por lo tanto, obtenemos una funci√≥n corregida y cien por cien funcional: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unpackUnitVector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(packed)</span></span></span><span class="hljs-function">: disk </span></span>= packed * packed unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vec3() unit.x = disk.real() unit.y = disk.imag() unit.z = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> - unit.x * unit.x - unit.y * unit.y) * (signbit(packed.real()) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unit</code> </pre> <br>  Eso es todo!  Ahora el algoritmo est√° completo.  Las matem√°ticas no cl√°sicas se manifiestan en el hecho de que usamos el hecho de que 0 difiere de -0, lo cual es falso para todas las √°reas de matem√°ticas que conozco.  Sin embargo, hay una manera de hacer l√≥gica esta extra√±eza en un sentido te√≥rico, matem√°ticamente riguroso. <br><br><h2>  Espacios que no cumplen con las reglas: una l√≠nea recta con dos puntos de origen </h2><br>  Para comprender mejor lo siguiente, debe conocer los conceptos de clases de equivalencia y vecindarios.  Esto es opcional, pero ser√° m√°s claro. <br><br>  Podemos asegurar la consistencia de esta rareza con un "signo cero", comenzando con un espacio topol√≥gico interesante: una l√≠nea recta con dos puntos de origen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/bdc/b66/7dfbdcb665e09552d349b0fb6d606f52.png"></div><br>  <i>Una l√≠nea recta con dos puntos de origen es un eje num√©rico real ordinario, que de alguna manera creci√≥ un 0 extra por s√≠ mismo.</i> <br><br>  Se obtiene una l√≠nea recta con dos puntos de origen cuando tomamos dos ejes num√©ricos reales y pegamos cada n√∫mero con su opuesto, excepto 0. Formalmente, una l√≠nea recta con dos puntos de origen es un espacio cociente R¬≤ con una relaci√≥n de equivalencia que identifica dos n√∫meros si son iguales <em>y</em> no son 0. El resultado es una l√≠nea recta de n√∫meros reales con dos ceros diferentes equidistantes de cualquier punto, pero al mismo tiempo diferentes entre s√≠.  Formalmente, dos vecindarios de cada uno de los ceros siempre tienen una intersecci√≥n no vac√≠a. <br><br>  Podemos expandir esto e intentar definir el objeto "similar a un disco" que se utiliz√≥ en este art√≠culo.  Anteriormente, mantuvimos por la fuerza el signo de la coordenada Z del punto en la parte real de la ra√≠z cuadrada principal de su proyecci√≥n en el disco complejo, incluso si esta parte real es 0. Esto significa que no usamos n√∫meros complejos, sino otro concepto similar a ellos: un n√∫mero complejo, la parte imaginaria de la cual es un n√∫mero real, y la parte real de la cual es un punto en una l√≠nea con dos puntos de origen, por lo que podemos distinguir la parte real igual a +0 y -0.  De hecho, ¬°usamos <strong>n√∫meros complejos con dos puntos de origen!</strong> <br><br>  Y, de hecho, no encontramos una biyecci√≥n (mapeo uno a uno) entre una esfera y una unidad de disco, pero encontramos una biyecci√≥n entre una esfera y una unidad de disco con dos puntos de origen.  No verifiqu√© si esta biyecci√≥n es un homeomorfismo (un homeomorfismo es una biyecci√≥n continua en ambas direcciones), pero tal vez alg√∫n d√≠a lo haga. <br><br><h3>  Un poco de topolog√≠a al final </h3><br>  En conclusi√≥n, quiero enfatizar que aunque el plano complejo que utilizamos con dos puntos de origen no se sigue de la misma construcci√≥n que la l√≠nea recta con dos coordenadas, de hecho es el equivalente de otro plano complejo con dos puntos de origen coordinado, construido de manera similar a una l√≠nea recta con Dos origen. <br><br>  En el caso de una l√≠nea recta con dos puntos de origen, pegamos dos copias del eje del n√∫mero real en todos los lugares excepto 0. Podemos hacer lo mismo con dos copias del plano complejo pegando cada par de n√∫meros complejos iguales que no sean 0, y de manera similar se vuelven complejos Un avi√≥n con dos puntos de origen.  Esta construcci√≥n difiere de la construcci√≥n de un nuevo plano complejo a partir de una l√≠nea recta con dos puntos de origen y un eje num√©rico real ordinario: el primero es un espacio factorial y el segundo es un producto de espacios.  Sin embargo, la √∫nica diferencia entre los dos espacios resultantes es la forma de <em>escribir</em> diferentes ceros en cada espacio: en el primero se cuentan como ( <em>0 + 0i) a</em> y ( <em>0 + 0i) b</em> (dos ceros tomados de dos espacios diferentes no pegados), y en este √∫ltimo se leen como <em>(0a + 0i)</em> y <em>(0b +</em> <em>0i)</em> .  De hecho, ambos espacios son homeom√≥rficos, por lo que puede usar uno de manera segura donde se requiere el otro. <br><br><h2>  Conclusi√≥n </h2><br>  Espero que hayas disfrutado esta excursi√≥n al mundo de las matem√°ticas extra√±as y oscuras.  Insisto nuevamente en el hecho de que, estrictamente hablando, este algoritmo se comporta peor que el algoritmo <em>oct</em> del art√≠culo que mencion√© al principio.  Aunque es cercano o incluso m√°s r√°pido en tiempo de ejecuci√≥n, su distribuci√≥n de puntos en la esfera est√° lejos de ser tan buena.  Escrib√≠ este art√≠culo para mostrar c√≥mo las matem√°ticas aparentemente extra√±as, como las tonter√≠as abstractas, pueden tener aplicaciones muy interesantes en el mundo real;  Por otra parte, encuentro este sinsentido abstracto encantador.  Espero que hayas aprendido algo √∫til del art√≠culo, ¬°gracias por leer! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482348/">https://habr.com/ru/post/482348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482332/index.html">C√≥mo un entusiasta cre√≥ una red Wi-Fi en DOS</a></li>
<li><a href="../482336/index.html">Los comerciantes tienen acceso a conferencias de prensa del Banco Central de Inglaterra antes de su transmisi√≥n p√∫blica</a></li>
<li><a href="../482338/index.html">Visual Studio para Mac: controle su IDE con teclas</a></li>
<li><a href="../482340/index.html">De Junior'a a Middle'a: analizador</a></li>
<li><a href="../482344/index.html">Prep√°rese para la introducci√≥n de una calificaci√≥n social en Rusia</a></li>
<li><a href="../482354/index.html">ConfigureAwait: Preguntas frecuentes</a></li>
<li><a href="../482356/index.html">Usar Windows Server sin explorador desde el punto de vista de un usuario normal de Windows</a></li>
<li><a href="../482360/index.html">Detective Habra: son amigos de los ovnis</a></li>
<li><a href="../482362/index.html">Casi anarqu√≠a: una breve historia de Fidonet, un proyecto que no le importa ganar en Internet</a></li>
<li><a href="../482364/index.html">Cosas que [tal vez] no sab√≠as sobre Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>