<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚖️ 💥 👦🏽 Indizes in PostgreSQL - 7 (GIN) 🔛 🏜️ ⚔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns bereits mit der PostgreSQL- Indexierungs-Engine und der Schnittstelle von Zugriffsmethoden vertraut gemacht und Hash-Indizes , B-Bäume s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 7 (GIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448746/">  Wir haben uns bereits mit der PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexierungs-Engine</a> und der Schnittstelle von Zugriffsmethoden vertraut gemacht und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Bäume</a> sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-GiST-</a> Indizes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erörtert</a> .  Und dieser Artikel wird GIN-Index enthalten. <br><br><h1>  Gin </h1><br>  <em>"Gin? .. Gin ist anscheinend so ein amerikanischer Schnaps? .."</em> <em><br></em>  <em>"Ich bin kein Getränk, oh, neugieriger Junge!"</em>  <em>wieder flammte der alte Mann auf, wieder erkannte er sich und nahm sich wieder in die Hand.</em>  <em>"Ich bin kein Getränk, sondern ein mächtiger und unerschrockener Geist, und es gibt keine solche Magie auf der Welt, die ich nicht tun könnte."</em> <br>  - Lazar Lagin, "Old Khottabych". <br><br>  <em>Gin steht für Generalized Inverted Index und sollte als Geist betrachtet werden, nicht als Getränk.</em> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README</a> <br><a name="habracut"></a><br><h2>  Allgemeines Konzept </h2><br>  GIN ist der abgekürzte Generalized Inverted Index.  Dies ist ein sogenannter <em>invertierter Index</em> .  Es manipuliert Datentypen, deren Werte nicht atomar sind, sondern aus Elementen bestehen.  Wir werden diese Typen zusammengesetzt nennen.  Und dies sind nicht die Werte, die indiziert werden, sondern einzelne Elemente;  Jedes Element verweist auf die Werte, in denen es vorkommt. <br><br>  Eine gute Analogie zu dieser Methode ist der Index am Ende eines Buches, der für jeden Begriff eine Liste der Seiten enthält, auf denen dieser Begriff vorkommt.  Die Zugriffsmethode muss eine schnelle Suche nach indizierten Elementen gewährleisten, genau wie der Index in einem Buch.  Daher werden diese Elemente als vertrauter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Baum</a> gespeichert (eine andere, einfachere Implementierung wird dafür verwendet, spielt in diesem Fall jedoch keine Rolle).  Ein geordneter Satz von Verweisen auf Tabellenzeilen, die zusammengesetzte Werte mit dem Element enthalten, ist mit jedem Element verknüpft.  Die Ordnungsmäßigkeit ist für das Abrufen von Daten nicht erforderlich (die Sortierreihenfolge der TIDs bedeutet nicht viel), aber wichtig für die interne Struktur des Index. <br><br>  Elemente werden niemals aus dem GIN-Index gelöscht.  Es wird angenommen, dass Werte, die Elemente enthalten, verschwinden, entstehen oder variieren können, aber die Menge der Elemente, aus denen sie bestehen, ist mehr oder weniger stabil.  Diese Lösung vereinfacht Algorithmen für die gleichzeitige Arbeit mehrerer Prozesse mit dem Index erheblich. <br><br>  Wenn die Liste der TIDs ziemlich klein ist, kann sie auf dieselbe Seite wie das Element passen (und wird als "Buchungsliste" bezeichnet).  Wenn die Liste jedoch groß ist, ist eine effizientere Datenstruktur erforderlich, und wir sind uns dessen bereits bewusst - es ist wieder ein B-Baum.  Ein solcher Baum befindet sich auf separaten Datenseiten (und wird als "Buchungsbaum" bezeichnet). <br><br>  Der GIN-Index besteht also aus dem B-Baum der Elemente, und B-Bäume oder flache Listen von TIDs sind mit Blattzeilen dieses B-Baums verknüpft. <br><br>  Genau wie die zuvor beschriebenen GiST- und SP-GiST-Indizes bietet GIN einem Anwendungsentwickler die Schnittstelle zur Unterstützung verschiedener Operationen über zusammengesetzte Datentypen. <br><br><h2>  Volltextsuche </h2><br>  Der Hauptanwendungsbereich für die GIN-Methode ist die Beschleunigung der Volltextsuche. Daher ist es sinnvoll, sie als Beispiel für eine detailliertere Diskussion dieses Index zu verwenden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Artikel zu GiST</a> enthält bereits eine kleine Einführung in die Volltextsuche. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommen</a> wir also ohne Wiederholungen direkt zum Punkt.  Es ist klar, dass zusammengesetzte Werte in diesem Fall <em>Dokumente</em> sind und Elemente dieser Dokumente <em>Lexeme sind</em> . <br><br>  Betrachten wir das Beispiel aus einem GiST-Artikel: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv);</code> </pre> <br>  Eine mögliche Struktur dieses Index ist in der Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/lc/nh/m-/lcnhm-vqquxgvzpklv8kemu6z-a.png"><br><br>  Im Gegensatz zu allen vorherigen Abbildungen werden Verweise auf Tabellenzeilen (TIDs) nicht mit Pfeilen, sondern mit numerischen Werten auf dunklem Hintergrund (Seitenzahl und Position auf der Seite) gekennzeichnet. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  In diesem spekulativen Beispiel passt die Liste der TIDs in reguläre Seiten für alle Lexeme außer "Blatt", "Schlitz" und "Schlitz".  Diese Lexeme kamen in vielen Dokumenten vor, und die Listen der TIDs für sie wurden in einzelne B-Bäume eingefügt. <br><br>  Wie können wir übrigens herausfinden, wie viele Dokumente ein Lexem enthalten?  Für einen kleinen Tisch funktioniert eine „direkte“ Technik (siehe unten), aber wir werden weiter lernen, wie man mit größeren Tischen umgeht. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (unnest(doc_tsv)).lexeme, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> lexeme | count ----------+------- sheet | 9 slit | 8 slitter | 5 sit | 2 upon | 1 mani | 1 whoever | 1 sleekest | 1 good | 1 could | 1 ever | 1 (11 rows)</code> </pre><br>  Beachten Sie auch, dass Seiten des GIN-Index im Gegensatz zu einem normalen B-Baum eher durch eine unidirektionale als durch eine bidirektionale Liste verbunden sind.  Dies ist ausreichend, da eine Baumüberquerung nur in eine Richtung erfolgt. <br><br><h3>  Beispiel einer Abfrage </h3><br>  Wie wird die folgende Abfrage für unser Beispiel durchgeführt? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) (4 rows)</code> </pre><br>  Einzelne Lexeme (Suchschlüssel) werden zuerst aus der Abfrage extrahiert: "mani" und "slitter".  Dies erfolgt durch eine spezielle API-Funktion, die den von der Operatorklasse festgelegten Datentyp und die Strategie berücksichtigt: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'tsvector_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- @@(tsvector,tsquery) | 1 matching search query @@@(tsvector,tsquery) | 2 synonym for @@ (for backward compatibility) (2 rows)</code> </pre><br>  Im B-Baum der Lexeme finden wir als nächstes beide Schlüssel und gehen die fertigen Listen der TIDs durch.  Wir bekommen: <br><br>  für "mani" - (0,2). <br>  für "Slitter" - (0,1), (0,2), (1,2), (1,3), (2,2). <br><br><img src="https://habrastorage.org/webt/mg/qc/do/mgqcdou-xlhsztvkxii5qluc5rq.png"><br><br>  Schließlich wird für jede gefundene TID eine API-Konsistenzfunktion aufgerufen, die bestimmen muss, welche der gefundenen Zeilen mit der Suchabfrage übereinstimmen.  Da die Lexeme in unserer Abfrage durch Boolesche Werte "und" verknüpft sind, wird nur (0,2) zurückgegeben: <br><br><pre> <code class="plaintext hljs"> | | | consistency | | | function TID | mani | slitter | slit &amp; slitter -------+------+---------+---------------- (0,1) | f | T | f (0,2) | T | T | T (1,2) | f | T | f (1,3) | f | T | f (2,2) | f | T | f</code> </pre><br>  Und das Ergebnis ist: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc --------------------------------------------- How many sheets could a sheet slitter slit? (1 row)</code> </pre><br>  Wenn wir diesen Ansatz mit dem bereits für GiST diskutierten vergleichen, erscheint der Vorteil von GIN für die Volltextsuche offensichtlich.  Aber es steckt mehr dahinter als man denkt. <br><br><h3>  Das Problem eines langsamen Updates </h3><br>  Die Sache ist, dass das Einfügen oder Aktualisieren von Daten in den GIN-Index ziemlich langsam ist.  Jedes Dokument enthält normalerweise viele zu indizierende Lexeme.  Wenn daher nur ein Dokument hinzugefügt oder aktualisiert wird, müssen wir den Indexbaum massiv aktualisieren. <br><br>  Wenn andererseits mehrere Dokumente gleichzeitig aktualisiert werden, können einige ihrer Lexeme gleich sein, und der Gesamtaufwand ist geringer als bei der Aktualisierung von Dokumenten nacheinander. <br><br>  Der GIN-Index verfügt über den Speicherparameter "fastupdate", den wir bei der Indexerstellung angeben und später aktualisieren können: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (fastupdate = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  Wenn dieser Parameter aktiviert ist, werden Aktualisierungen in einer separaten ungeordneten Liste (auf einzelnen verbundenen Seiten) gesammelt.  Wenn diese Liste groß genug ist oder während des Staubsaugens, werden alle akkumulierten Aktualisierungen sofort am Index vorgenommen.  Welche Liste als "groß genug" zu betrachten ist, wird durch den Konfigurationsparameter "gin_pending_list_limit" oder durch den gleichnamigen Speicherparameter des Index bestimmt. <br><br>  Dieser Ansatz hat jedoch Nachteile: Erstens wird die Suche verlangsamt (da die ungeordnete Liste zusätzlich zum Baum durchsucht werden muss), und zweitens kann eine nächste Aktualisierung unerwartet viel Zeit in Anspruch nehmen, wenn die ungeordnete Liste übergelaufen ist. <br><br><h3>  Suche nach einer Teilübereinstimmung </h3><br>  Wir können Teilübereinstimmungen in der Volltextsuche verwenden.  Betrachten Sie beispielsweise die folgende Abfrage: <br><br><pre> <code class="pgsql hljs">gin=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc -------------------------------------------------------- Can a sheet slitter slit sheets? How many sheets could a sheet slitter slit? I slit a sheet, a sheet I slit. Upon a slitted sheet I sit. Whoever slit the sheets is a good sheet slitter. I am a sheet slitter. I slit sheets. I am the sleekest sheet slitter that ever slit sheets. She slits the sheet she sits on. (9 rows)</code> </pre><br>  Diese Abfrage findet Dokumente, die Lexeme enthalten, die mit "slit" beginnen.  In diesem Beispiel sind solche Lexeme "Schlitz" und "Schlitz". <br><br>  Eine Abfrage wird sicherlich auch ohne Indizes funktionieren, aber GIN ermöglicht es auch, die folgende Suche zu beschleunigen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) (4 rows)</code> </pre><br>  Hier werden alle Lexeme mit dem in der Suchabfrage angegebenen Präfix im Baum nachgeschlagen und durch ein boolesches "oder" verbunden. <br><br><h3>  Häufige und seltene Lexeme </h3><br>  Um zu sehen, wie die Indizierung für Live-Daten funktioniert, nehmen wir das Archiv der "pgsql-hackers" -E-Mails, die wir bereits bei der Erörterung von GiST verwendet haben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese Version des Archivs</a> enthält 356125 Nachrichten mit dem Versanddatum, dem Betreff, dem Autor und dem Text. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv);</code> </pre><br>  Betrachten wir ein Lexem, das in vielen Dokumenten vorkommt.  Die Abfrage mit "unnest" funktioniert bei einer so großen Datenmenge nicht. Die richtige Technik besteht darin, die Funktion "ts_stat" zu verwenden, die Informationen zu Lexemen, die Anzahl der Dokumente, in denen sie aufgetreten sind, und die Gesamtzahl der Vorkommen bereitstellt. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ndoc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc -------+-------- re | 322141 wrote | 231174 use | 176917 (3 rows)</code> </pre><br>  Wählen wir "geschrieben". <br><br>  Und wir werden ein Wort nehmen, das für Entwickler-E-Mails selten vorkommt, sagen wir "Tattoo": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> word = <span class="hljs-string"><span class="hljs-string">'tattoo'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc --------+------ tattoo | 2 (1 row)</code> </pre><br>  Gibt es Dokumente, in denen diese beiden Lexeme vorkommen?  Es scheint, dass es gibt: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row)</code> </pre><br>  Es stellt sich die Frage, wie diese Abfrage durchgeführt werden soll.  Wenn wir, wie oben beschrieben, Listen mit TIDs für beide Lexeme erhalten, ist die Suche offensichtlich ineffizient: Wir müssen mehr als 200.000 Werte durchlaufen, von denen nur einer übrig bleibt.  Glücklicherweise versteht der Algorithmus unter Verwendung der Planerstatistik, dass "geschriebenes" Lexem häufig vorkommt, während "Tätowierung" selten vorkommt.  Daher wird die Suche nach dem seltenen Lexem durchgeführt, und die beiden abgerufenen Dokumente werden dann auf das Auftreten eines "geschriebenen" Lexems überprüft.  Und das geht aus der Abfrage hervor, die schnell durchgeführt wird: <br><br><pre> <code class="pgsql hljs">fts=# \<span class="hljs-keyword"><span class="hljs-keyword">timing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row) Time: 0,959 ms</code> </pre><br>  Die Suche nach "geschrieben" allein dauert deutlich länger: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count -------- 231174 (1 row) Time: 2875,543 ms (00:02,876)</code> </pre><br>  Diese Optimierung funktioniert sicherlich nicht nur für zwei Lexeme, sondern auch in komplexeren Fällen. <br><br><h3>  Einschränkung des Abfrageergebnisses </h3><br>  Ein Merkmal der GIN-Zugriffsmethode ist, dass das Ergebnis immer als Bitmap zurückgegeben wird: Diese Methode kann das Ergebnis TID für TID nicht zurückgeben.  Aus diesem Grund verwenden alle Abfragepläne in diesem Artikel den Bitmap-Scan. <br><br>  Daher ist die Einschränkung des Index-Scan-Ergebnisses mithilfe der LIMIT-Klausel nicht sehr effizient.  Beachten Sie die vorhergesagten Kosten der Operation (Feld "Kosten" des Knotens "Limit"): <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------- Limit (cost=1283.61..1285.13 rows=1) -&gt; Bitmap Heap Scan on mail_messages (cost=1283.61..209975.49 rows=137207) Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) -&gt; Bitmap Index Scan on mail_messages_tsv_idx (cost=0.00..1249.30 rows=137207) Index Cond: (tsv @@ to_tsquery('wrote'::text)) (5 rows)</code> </pre><br>  Die Kosten werden auf 1285,13 geschätzt, was etwas höher ist als die Kosten für die Erstellung der gesamten Bitmap 1249.30 (Feld "Kosten" des Bitmap-Index-Scan-Knotens). <br><br>  Daher verfügt der Index über eine spezielle Funktion, um die Anzahl der Ergebnisse zu begrenzen.  Der Schwellenwert wird im Konfigurationsparameter "gin_fuzzy_search_limit" angegeben und ist standardmäßig gleich Null (es findet keine Einschränkung statt).  Aber wir können den Schwellenwert einstellen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5746 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">10000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 14726 (1 row)</code> </pre><br>  Wie wir sehen können, unterscheidet sich die Anzahl der von der Abfrage zurückgegebenen Zeilen für verschiedene Parameterwerte (wenn der Indexzugriff verwendet wird).  Die Einschränkung ist nicht streng: Es können mehr Zeilen als angegeben zurückgegeben werden, was einen "unscharfen" Teil des Parameternamens rechtfertigt. <br><br><h3>  Kompakte Darstellung </h3><br>  GIN-Indizes sind unter anderem dank ihrer Kompaktheit gut.  Erstens, wenn ein und dasselbe Lexem in mehreren Dokumenten vorkommt (und dies ist normalerweise der Fall), wird es nur einmal im Index gespeichert.  Zweitens werden TIDs in geordneter Weise im Index gespeichert, und dies ermöglicht es uns, eine einfache Komprimierung zu verwenden: Jede nächste TID in der Liste wird tatsächlich als Differenz zur vorherigen gespeichert.  Dies ist normalerweise eine kleine Zahl, die viel weniger Bits benötigt als eine vollständige Sechs-Byte-TID. <br><br>  Um eine Vorstellung von der Größe zu bekommen, erstellen wir einen B-Baum aus dem Text der Nachrichten.  Aber ein fairer Vergleich wird sicherlich nicht passieren: <br><br><ul><li>  GIN basiert auf einem anderen Datentyp ("tsvector" anstelle von "text"), der kleiner ist. </li><li>  Gleichzeitig muss die Größe der Nachrichten für den B-Baum auf ungefähr zwei Kilobyte verkürzt werden. </li></ul><br>  Trotzdem fahren wir fort: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages(substring(body_plain <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span>));</code> </pre><br>  Wir werden auch den GiST-Index erstellen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_gist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Die Größe der Indizes bei "Vakuum voll": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gin, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_gist'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gist, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_btree'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> btree;</code> </pre><pre> <code class="plaintext hljs"> gin | gist | btree --------+--------+-------- 179 MB | 125 MB | 546 MB (1 row)</code> </pre><br>  Aufgrund der Kompaktheit der Darstellung können wir versuchen, den GIN-Index während der Migration von Oracle als Ersatz für Bitmap-Indizes zu verwenden (ohne auf Details einzugehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verweise</a> ich für neugierige Köpfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Lewis 'Beitrag</a> ).  In der Regel werden Bitmap-Indizes für Felder mit wenigen eindeutigen Werten verwendet, was auch für GIN hervorragend ist.  Und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im ersten Artikel gezeigt</a> , kann PostgreSQL eine Bitmap basierend auf jedem Index, einschließlich GIN, im laufenden Betrieb erstellen. <br><br><h3>  GiST oder GIN? </h3><br>  Für viele Datentypen stehen Operatorklassen sowohl für GiST als auch für GIN zur Verfügung, was die Frage aufwirft, welcher Index verwendet werden soll.  Vielleicht können wir bereits einige Schlussfolgerungen ziehen. <br><br>  In der Regel übertrifft GIN GiST in Genauigkeit und Suchgeschwindigkeit.  Wenn die Daten nicht häufig aktualisiert werden und eine schnelle Suche erforderlich ist, ist GIN höchstwahrscheinlich eine Option. <br><br>  Wenn andererseits die Daten intensiv aktualisiert werden, scheinen die Gemeinkosten für die Aktualisierung von GIN zu hoch zu sein.  In diesem Fall müssen wir beide Optionen vergleichen und die auswählen, deren Eigenschaften besser ausgewogen sind. <br><br><h2>  Arrays </h2><br>  Ein weiteres Beispiel für die Verwendung von GIN ist die Indizierung von Arrays.  In diesem Fall werden Array-Elemente in den Index aufgenommen, wodurch eine Reihe von Operationen über Arrays beschleunigt werden können: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- &amp;&amp;(anyarray,anyarray) | 1 intersection @&gt;(anyarray,anyarray) | 2 contains array &lt;@(anyarray,anyarray) | 3 contained in array =(anyarray,anyarray) | 4 equality (4 rows)</code> </pre><br>  Unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Datenbank</a> bietet eine Routenansicht mit Informationen zu Flügen.  Diese Ansicht enthält unter anderem die Spalte "days_of_week" - eine Reihe von Wochentagen, an denen Flüge stattfinden.  Zum Beispiel startet ein Flug von Vnukovo nach Gelendzhik dienstags, donnerstags und sonntags: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0049'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> departure_airport_name | arrival_airport_name | days_of_week ------------------------+----------------------+-------------- Vnukovo | Gelendzhik | {2,4,7} (1 row)</code> </pre><br>  Um den Index zu erstellen, "materialisieren" wir die Ansicht in einer Tabelle: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week);</code> </pre><br><br>  Jetzt können wir den Index verwenden, um alle Flüge kennenzulernen, die dienstags, donnerstags und sonntags abfliegen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (4 rows)</code> </pre><br>  Es scheint, dass es sechs von ihnen gibt: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flight_no, departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> flight_no | departure_airport_name | arrival_airport_name | days_of_week -----------+------------------------+----------------------+-------------- PG0005 | Domodedovo | Pskov | {2,4,7} PG0049 | Vnukovo | Gelendzhik | {2,4,7} PG0113 | Naryan-Mar | Domodedovo | {2,4,7} PG0249 | Domodedovo | Gelendzhik | {2,4,7} PG0449 | Stavropol | Vnukovo | {2,4,7} PG0540 | Barnaul | Vnukovo | {2,4,7} (6 rows)</code> </pre><br>  Wie wird diese Abfrage durchgeführt?  Genau so wie oben beschrieben: <br><br><ol><li>  Aus dem Array {2,4,7}, das hier die Rolle der Suchabfrage spielt, werden Elemente (Suchschlüsselwörter) extrahiert.  Offensichtlich sind dies die Werte von "2", "4" und "7". <br></li><li>  Im Baum der Elemente werden die extrahierten Schlüssel gefunden, und für jeden von ihnen wird die Liste der TIDs ausgewählt. <br></li><li>  Von allen gefundenen TIDs wählt die Konsistenzfunktion diejenigen aus der Abfrage aus, die dem Operator entsprechen.  Für den Operator <code>=</code> stimmen nur die TIDs überein, die in allen drei Listen aufgetreten sind (mit anderen Worten, das ursprüngliche Array muss alle Elemente enthalten).  Dies reicht jedoch nicht aus: Es wird auch benötigt, damit das Array keine anderen Werte enthält, und wir können diese Bedingung nicht mit dem Index überprüfen.  In diesem Fall fordert die Zugriffsmethode die Indizierungs-Engine daher auf, alle mit der Tabelle zurückgegebenen TIDs erneut zu überprüfen. <br></li></ol><br>  Interessanterweise gibt es Strategien (z. B. "in Array enthalten"), die nichts überprüfen können und alle in der Tabelle gefundenen TIDs erneut überprüfen müssen. <br><br>  Aber was tun, wenn wir die Flüge kennen müssen, die dienstags, donnerstags und sonntags von Moskau abfliegen?  Der Index unterstützt die zusätzliche Bedingung nicht, die in die Spalte "Filter" gelangt. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) Filter: (departure_city = 'Moscow'::text) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (5 rows)</code> </pre><br>  Hier ist dies in Ordnung (der Index wählt sowieso nur sechs Zeilen aus), aber in Fällen, in denen die zusätzliche Bedingung die Selektionsfähigkeit erhöht, ist eine solche Unterstützung erwünscht.  Wir können jedoch nicht einfach den Index erstellen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type text has no default operator class for access method "gin" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Die Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">btree_gin</a> " hilft jedoch, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">indem</a> GIN-Operatorklassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugefügt</a> werden, die die Arbeit eines regulären B-Baums simulieren. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gin; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) -&gt; Bitmap Index Scan on routes_t_days_of_week_departure_city_idx Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) (4 rows)</code> </pre><br><h2>  Jsonb </h2><br>  Ein weiteres Beispiel für einen zusammengesetzten Datentyp mit integrierter GIN-Unterstützung ist JSON.  Um mit JSON-Werten arbeiten zu können, sind derzeit eine Reihe von Operatoren und Funktionen definiert, von denen einige mithilfe von Indizes beschleunigt werden können: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opc.opcname, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> str <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'jsonb_ops'</span></span>,<span class="hljs-string"><span class="hljs-string">'jsonb_path_ops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> opcname | amopopr | str ----------------+------------------+----- jsonb_ops | ?(jsonb,text) | 9 top-level key exists jsonb_ops | ?|(jsonb,text[]) | 10 some top-level key exists jsonb_ops | ?&amp;(jsonb,text[]) | 11 all top-level keys exist jsonb_ops | @&gt;(jsonb,jsonb) | 7 JSON value is at top level jsonb_path_ops | @&gt;(jsonb,jsonb) | 7 (5 rows)</code> </pre><br>  Wie wir sehen können, stehen zwei Operatorklassen zur Verfügung: "jsonb_ops" und "jsonb_path_ops". <br><br>  Die erste Operatorklasse "jsonb_ops" wird standardmäßig verwendet.  Alle Schlüssel, Werte und Array-Elemente werden als Elemente des anfänglichen JSON-Dokuments in den Index aufgenommen.  Jedem dieser Elemente wird ein Attribut hinzugefügt, das angibt, ob dieses Element ein Schlüssel ist (dies wird für "vorhandene" Strategien benötigt, die zwischen Schlüsseln und Werten unterscheiden). <br><br>  Stellen wir zum Beispiel einige Zeilen aus "Routen" als JSON wie folgt dar: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_jsonb(t) route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> flight_no <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ) t; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb;</code> </pre><pre> <code class="plaintext hljs"> ctid | jsonb_pretty -------+------------------------------------------------- (0,1) | { + | "days_of_week": [ + | 1 + | ], + | "arrival_airport_name": "Surgut", + | "departure_airport_name": "Ust-Ilimsk" + | } (0,2) | { + | "days_of_week": [ + | 2 + | ], + | "arrival_airport_name": "Ust-Ilimsk", + | "departure_airport_name": "Surgut" + | } (0,3) | { + | "days_of_week": [ + | 1, + | 4 + | ], + | "arrival_airport_name": "Sochi", + | "departure_airport_name": "Ivanovo-Yuzhnyi"+ | } (0,4) | { + | "days_of_week": [ + | 2, + | 5 + | ], + | "arrival_airport_name": "Ivanovo-Yuzhnyi", + | "departure_airport_name": "Sochi" + | } (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(route);</code> </pre><br><br>  Der Index kann wie folgt aussehen: <br><br><img src="https://habrastorage.org/webt/oo/yi/x3/ooyix34gx7mrpiwdcol3a3ewnwu.png"><br><br>  Eine Abfrage wie diese kann nun beispielsweise mithilfe des Index ausgeführt werden: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------- Bitmap Heap Scan on routes_jsonb Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) -&gt; Bitmap Index Scan on routes_jsonb_route_idx Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) (4 rows)</code> </pre><br>  Beginnend mit dem Stammverzeichnis des JSON-Dokuments prüft der Operator <code>@&gt;</code> , ob die angegebene Route ( <code>"days_of_week": [5]</code> ) auftritt.  Hier gibt die Abfrage eine Zeile zurück: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> jsonb_pretty ------------------------------------------------ { + "days_of_week": [ + 2, + 5 + ], + "arrival_airport_name": "Ivanovo-Yuzhnyi",+ "departure_airport_name": "Sochi" + } (1 row)</code> </pre><br>  Die Abfrage wird wie folgt durchgeführt: <br><br><ol><li>  In der Suchabfrage ( <code>"days_of_week": [5]</code> ) werden Elemente (Suchschlüssel) extrahiert: "days_of_week" und "5". <br></li><li>  Im Baum der Elemente werden die extrahierten Schlüssel gefunden, und für jeden von ihnen wird die Liste der TIDs ausgewählt: für "5" - (0,4) und für "Tage der Woche" - (0,1), (0,2) ), (0,3), (0,4). <br></li><li>  Von allen gefundenen TIDs wählt die Konsistenzfunktion diejenigen aus der Abfrage aus, die dem Operator entsprechen.  Für den Operator <code>@&gt;</code> sind Dokumente, die nicht alle Elemente aus der Suchabfrage enthalten, nicht sicher, sodass nur (0,4) übrig bleibt.  Wir müssen jedoch die mit der Tabelle verbleibende TID erneut überprüfen, da aus dem Index nicht ersichtlich ist, in welcher Reihenfolge die gefundenen Elemente im JSON-Dokument vorkommen. <br></li></ol><br>  Weitere Informationen zu anderen Operatoren finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Dokumentation</a> . <br><br>  Zusätzlich zu herkömmlichen Operationen für den Umgang mit JSON ist seit langem die Erweiterung "jsquery" verfügbar, die eine Abfragesprache mit umfangreicheren Funktionen (und sicherlich mit Unterstützung von GIN-Indizes) definiert.  Außerdem wurde 2016 ein neuer SQL-Standard herausgegeben, der seine eigenen Operationen und die Abfragesprache "SQL / JSON-Pfad" definiert.  Eine Implementierung dieses Standards wurde bereits durchgeführt, und wir glauben, dass er in PostgreSQL 11 erscheinen wird. <br><br><blockquote>  Der SQL / JSON-Pfad-Patch wurde schließlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für</a> PostgreSQL 12 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festgeschrieben</a> , während andere Teile noch unterwegs sind.  Hoffentlich sehen wir die vollständig implementierte Funktion in PostgreSQL 13. <br></blockquote><br><h2>  Interna </h2><br>  Wir können mit der Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pageinspect</a> " in den GIN-Index <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schauen</a> . <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Die Informationen auf der Metaseite zeigen allgemeine Statistiken: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+----------- pending_head | 4294967295 pending_tail | 4294967295 tail_free_size | 0 n_pending_pages | 0 n_pending_tuples | 0 n_total_pages | 22968 n_entry_pages | 13751 n_data_pages | 9216 n_entries | 1423598 version | 2</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Seitenstruktur</a> bietet einen speziellen Bereich, in dem Zugriffsmethoden ihre Informationen speichern.  Dieser Bereich ist für gewöhnliche Programme wie Vakuum "undurchsichtig".  Die Funktion "Gin_page_opaque_info" zeigt diese Daten für GIN an.  Zum Beispiel können wir die Indexseiten kennenlernen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flags, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">22967</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g(id), <span class="hljs-comment"><span class="hljs-comment">-- n_total_pages gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) group by flags;</span></span></code> </pre><pre> <code class="plaintext hljs"> flags | count ------------------------+------- {meta} | 1 meta page {} | 133 internal page of element B-tree {leaf} | 13618 leaf page of element B-tree {data} | 1497 internal page of TID B-tree {data,leaf,compressed} | 7719 leaf page of TID B-tree (5 rows)</code> </pre><br>  Die Funktion "Gin_leafpage_items" bietet Informationen zu TIDs, die auf Seiten {Daten, Blatt, komprimiert} gespeichert sind: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_leafpage_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">2672</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------------------------------------------------------------- first_tid | (239,44) nbytes | 248 tids | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... -[ RECORD 2 ]--------------------------------------------------------------------- first_tid | (247,40) nbytes | 248 tids | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... ...</code> </pre><br>  Beachten Sie hier, dass die verbleibenden Seiten des TID-Baums tatsächlich kleine komprimierte Listen von Zeigern auf Tabellenzeilen und nicht einzelne Zeiger enthalten. <br><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften der GIN-Zugriffsmethode an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden bereits bereitgestellt</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gin | can_order | f gin | can_unique | f gin | can_multi_col | t gin | can_exclude | f</code> </pre><br>  Interessanterweise unterstützt GIN die Erstellung von mehrspaltigen Indizes.  Im Gegensatz zu einem regulären B-Baum speichert ein mehrspaltiger Index anstelle von zusammengesetzten Schlüsseln jedoch weiterhin einzelne Elemente, und die Spaltennummer wird für jedes Element angegeben. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verfügbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Beachten Sie, dass die Rückgabe von Ergebnissen TID für TID (Index-Scan) nicht unterstützt wird.  Es ist nur ein Bitmap-Scan möglich. <br><br>  Der Rückwärtsscan wird ebenfalls nicht unterstützt: Diese Funktion ist nur für den Indexscan erforderlich, nicht jedoch für den Bitmap-Scan. <br><br>  Und die folgenden Eigenschaften sind Spaltenebenen: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Hier ist nichts verfügbar: keine Sortierung (was klar ist), keine Verwendung des Index als Deckung (da das Dokument selbst nicht im Index gespeichert ist), keine Manipulation von NULL-Werten (da dies für Elemente vom zusammengesetzten Typ nicht sinnvoll ist) . <br><br><h2>  Andere Datentypen </h2><br>  Es stehen einige weitere Erweiterungen zur Verfügung, die für einige Datentypen die Unterstützung von GIN hinzufügen. <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_trgm</a> " ermöglicht es uns, die "Ähnlichkeit" von Wörtern zu bestimmen, indem wir vergleichen, wie viele gleiche Drei-Buchstaben-Sequenzen (Trigramme) verfügbar sind.  Es werden zwei Operatorklassen hinzugefügt, "gist_trgm_ops" und "gin_trgm_ops", die verschiedene Operatoren unterstützen, einschließlich des Vergleichs mit LIKE und regulären Ausdrücken.  Wir können diese Erweiterung zusammen mit der Volltextsuche verwenden, um Wortoptionen zur Behebung von Tippfehlern vorzuschlagen. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hstore</a> " implementiert "Schlüsselwert" -Speicher.  Für diesen Datentyp stehen Operatorklassen für verschiedene Zugriffsmethoden zur Verfügung, einschließlich GIN.  Mit der Einführung des Datentyps "jsonb" gibt es jedoch keine besonderen Gründe für die Verwendung von "hstore". <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intarray</a> " erweitert die Funktionalität von Integer-Arrays.  Die Indexunterstützung umfasst sowohl GiST als auch GIN (Operatorklasse "gin__int_ops"). <br></li></ul><br>  Und diese beiden Erweiterungen wurden bereits oben erwähnt: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">btree_gin</a> " fügt GIN-Unterstützung für reguläre Datentypen hinzu, damit diese zusammen mit zusammengesetzten Typen in einem mehrspaltigen Index verwendet werden können. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsquery</a> " definiert eine Sprache für die JSON-Abfrage und eine Operatorklasse für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexunterstützung</a> dieser Sprache.  Diese Erweiterung ist in einer Standard-PostgreSQL-Lieferung nicht enthalten. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448746/">https://habr.com/ru/post/de448746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448734/index.html">Drohnen und Roboter helfen, die Kathedrale Notre Dame in Paris zu retten</a></li>
<li><a href="../de448738/index.html">Wer jagt Startups?</a></li>
<li><a href="../de448740/index.html">Wir hören SID-Musik (Commodore 64) über OPL3 auf modernen PCs</a></li>
<li><a href="../de448742/index.html">Büchse der Pandora: Wir analysieren die Ausnutzung der WinRAR-Sicherheitsanfälligkeit am Beispiel des Jobs NeoQUEST-2019</a></li>
<li><a href="../de448744/index.html">Wie übertrage ich eine Variable vom Fragment zur Aktivität in Android?</a></li>
<li><a href="../de448748/index.html">Überlegungen zu Schönheit und Code</a></li>
<li><a href="../de448750/index.html">Über eine Schwachstelle ist das nicht</a></li>
<li><a href="../de448754/index.html">Wer ist wer in Open Source: Geek-Biografien</a></li>
<li><a href="../de448756/index.html">Hintergrund: Warum Apple und Qualcomm sich stritten und sich dann versöhnten</a></li>
<li><a href="../de448758/index.html">Smartwatch mit BASIC auf physischem 6502</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>