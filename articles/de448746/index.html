<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öñÔ∏è üí• üë¶üèΩ Indizes in PostgreSQL - 7 (GIN) üîõ üèúÔ∏è ‚öîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns bereits mit der PostgreSQL- Indexierungs-Engine und der Schnittstelle von Zugriffsmethoden vertraut gemacht und Hash-Indizes , B-B√§ume s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 7 (GIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448746/">  Wir haben uns bereits mit der PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexierungs-Engine</a> und der Schnittstelle von Zugriffsmethoden vertraut gemacht und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-B√§ume</a> sowie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-GiST-</a> Indizes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">er√∂rtert</a> .  Und dieser Artikel wird GIN-Index enthalten. <br><br><h1>  Gin </h1><br>  <em>"Gin? .. Gin ist anscheinend so ein amerikanischer Schnaps? .."</em> <em><br></em>  <em>"Ich bin kein Getr√§nk, oh, neugieriger Junge!"</em>  <em>wieder flammte der alte Mann auf, wieder erkannte er sich und nahm sich wieder in die Hand.</em>  <em>"Ich bin kein Getr√§nk, sondern ein m√§chtiger und unerschrockener Geist, und es gibt keine solche Magie auf der Welt, die ich nicht tun k√∂nnte."</em> <br>  - Lazar Lagin, "Old Khottabych". <br><br>  <em>Gin steht f√ºr Generalized Inverted Index und sollte als Geist betrachtet werden, nicht als Getr√§nk.</em> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README</a> <br><a name="habracut"></a><br><h2>  Allgemeines Konzept </h2><br>  GIN ist der abgek√ºrzte Generalized Inverted Index.  Dies ist ein sogenannter <em>invertierter Index</em> .  Es manipuliert Datentypen, deren Werte nicht atomar sind, sondern aus Elementen bestehen.  Wir werden diese Typen zusammengesetzt nennen.  Und dies sind nicht die Werte, die indiziert werden, sondern einzelne Elemente;  Jedes Element verweist auf die Werte, in denen es vorkommt. <br><br>  Eine gute Analogie zu dieser Methode ist der Index am Ende eines Buches, der f√ºr jeden Begriff eine Liste der Seiten enth√§lt, auf denen dieser Begriff vorkommt.  Die Zugriffsmethode muss eine schnelle Suche nach indizierten Elementen gew√§hrleisten, genau wie der Index in einem Buch.  Daher werden diese Elemente als vertrauter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Baum</a> gespeichert (eine andere, einfachere Implementierung wird daf√ºr verwendet, spielt in diesem Fall jedoch keine Rolle).  Ein geordneter Satz von Verweisen auf Tabellenzeilen, die zusammengesetzte Werte mit dem Element enthalten, ist mit jedem Element verkn√ºpft.  Die Ordnungsm√§√üigkeit ist f√ºr das Abrufen von Daten nicht erforderlich (die Sortierreihenfolge der TIDs bedeutet nicht viel), aber wichtig f√ºr die interne Struktur des Index. <br><br>  Elemente werden niemals aus dem GIN-Index gel√∂scht.  Es wird angenommen, dass Werte, die Elemente enthalten, verschwinden, entstehen oder variieren k√∂nnen, aber die Menge der Elemente, aus denen sie bestehen, ist mehr oder weniger stabil.  Diese L√∂sung vereinfacht Algorithmen f√ºr die gleichzeitige Arbeit mehrerer Prozesse mit dem Index erheblich. <br><br>  Wenn die Liste der TIDs ziemlich klein ist, kann sie auf dieselbe Seite wie das Element passen (und wird als "Buchungsliste" bezeichnet).  Wenn die Liste jedoch gro√ü ist, ist eine effizientere Datenstruktur erforderlich, und wir sind uns dessen bereits bewusst - es ist wieder ein B-Baum.  Ein solcher Baum befindet sich auf separaten Datenseiten (und wird als "Buchungsbaum" bezeichnet). <br><br>  Der GIN-Index besteht also aus dem B-Baum der Elemente, und B-B√§ume oder flache Listen von TIDs sind mit Blattzeilen dieses B-Baums verkn√ºpft. <br><br>  Genau wie die zuvor beschriebenen GiST- und SP-GiST-Indizes bietet GIN einem Anwendungsentwickler die Schnittstelle zur Unterst√ºtzung verschiedener Operationen √ºber zusammengesetzte Datentypen. <br><br><h2>  Volltextsuche </h2><br>  Der Hauptanwendungsbereich f√ºr die GIN-Methode ist die Beschleunigung der Volltextsuche. Daher ist es sinnvoll, sie als Beispiel f√ºr eine detailliertere Diskussion dieses Index zu verwenden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Artikel zu GiST</a> enth√§lt bereits eine kleine Einf√ºhrung in die Volltextsuche. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommen</a> wir also ohne Wiederholungen direkt zum Punkt.  Es ist klar, dass zusammengesetzte Werte in diesem Fall <em>Dokumente</em> sind und Elemente dieser Dokumente <em>Lexeme sind</em> . <br><br>  Betrachten wir das Beispiel aus einem GiST-Artikel: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv);</code> </pre> <br>  Eine m√∂gliche Struktur dieses Index ist in der Abbildung dargestellt: <br><br><img src="https://habrastorage.org/webt/lc/nh/m-/lcnhm-vqquxgvzpklv8kemu6z-a.png"><br><br>  Im Gegensatz zu allen vorherigen Abbildungen werden Verweise auf Tabellenzeilen (TIDs) nicht mit Pfeilen, sondern mit numerischen Werten auf dunklem Hintergrund (Seitenzahl und Position auf der Seite) gekennzeichnet. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  In diesem spekulativen Beispiel passt die Liste der TIDs in regul√§re Seiten f√ºr alle Lexeme au√üer "Blatt", "Schlitz" und "Schlitz".  Diese Lexeme kamen in vielen Dokumenten vor, und die Listen der TIDs f√ºr sie wurden in einzelne B-B√§ume eingef√ºgt. <br><br>  Wie k√∂nnen wir √ºbrigens herausfinden, wie viele Dokumente ein Lexem enthalten?  F√ºr einen kleinen Tisch funktioniert eine ‚Äûdirekte‚Äú Technik (siehe unten), aber wir werden weiter lernen, wie man mit gr√∂√üeren Tischen umgeht. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (unnest(doc_tsv)).lexeme, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> lexeme | count ----------+------- sheet | 9 slit | 8 slitter | 5 sit | 2 upon | 1 mani | 1 whoever | 1 sleekest | 1 good | 1 could | 1 ever | 1 (11 rows)</code> </pre><br>  Beachten Sie auch, dass Seiten des GIN-Index im Gegensatz zu einem normalen B-Baum eher durch eine unidirektionale als durch eine bidirektionale Liste verbunden sind.  Dies ist ausreichend, da eine Baum√ºberquerung nur in eine Richtung erfolgt. <br><br><h3>  Beispiel einer Abfrage </h3><br>  Wie wird die folgende Abfrage f√ºr unser Beispiel durchgef√ºhrt? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) (4 rows)</code> </pre><br>  Einzelne Lexeme (Suchschl√ºssel) werden zuerst aus der Abfrage extrahiert: "mani" und "slitter".  Dies erfolgt durch eine spezielle API-Funktion, die den von der Operatorklasse festgelegten Datentyp und die Strategie ber√ºcksichtigt: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'tsvector_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- @@(tsvector,tsquery) | 1 matching search query @@@(tsvector,tsquery) | 2 synonym for @@ (for backward compatibility) (2 rows)</code> </pre><br>  Im B-Baum der Lexeme finden wir als n√§chstes beide Schl√ºssel und gehen die fertigen Listen der TIDs durch.  Wir bekommen: <br><br>  f√ºr "mani" - (0,2). <br>  f√ºr "Slitter" - (0,1), (0,2), (1,2), (1,3), (2,2). <br><br><img src="https://habrastorage.org/webt/mg/qc/do/mgqcdou-xlhsztvkxii5qluc5rq.png"><br><br>  Schlie√ülich wird f√ºr jede gefundene TID eine API-Konsistenzfunktion aufgerufen, die bestimmen muss, welche der gefundenen Zeilen mit der Suchabfrage √ºbereinstimmen.  Da die Lexeme in unserer Abfrage durch Boolesche Werte "und" verkn√ºpft sind, wird nur (0,2) zur√ºckgegeben: <br><br><pre> <code class="plaintext hljs"> | | | consistency | | | function TID | mani | slitter | slit &amp; slitter -------+------+---------+---------------- (0,1) | f | T | f (0,2) | T | T | T (1,2) | f | T | f (1,3) | f | T | f (2,2) | f | T | f</code> </pre><br>  Und das Ergebnis ist: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc --------------------------------------------- How many sheets could a sheet slitter slit? (1 row)</code> </pre><br>  Wenn wir diesen Ansatz mit dem bereits f√ºr GiST diskutierten vergleichen, erscheint der Vorteil von GIN f√ºr die Volltextsuche offensichtlich.  Aber es steckt mehr dahinter als man denkt. <br><br><h3>  Das Problem eines langsamen Updates </h3><br>  Die Sache ist, dass das Einf√ºgen oder Aktualisieren von Daten in den GIN-Index ziemlich langsam ist.  Jedes Dokument enth√§lt normalerweise viele zu indizierende Lexeme.  Wenn daher nur ein Dokument hinzugef√ºgt oder aktualisiert wird, m√ºssen wir den Indexbaum massiv aktualisieren. <br><br>  Wenn andererseits mehrere Dokumente gleichzeitig aktualisiert werden, k√∂nnen einige ihrer Lexeme gleich sein, und der Gesamtaufwand ist geringer als bei der Aktualisierung von Dokumenten nacheinander. <br><br>  Der GIN-Index verf√ºgt √ºber den Speicherparameter "fastupdate", den wir bei der Indexerstellung angeben und sp√§ter aktualisieren k√∂nnen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (fastupdate = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  Wenn dieser Parameter aktiviert ist, werden Aktualisierungen in einer separaten ungeordneten Liste (auf einzelnen verbundenen Seiten) gesammelt.  Wenn diese Liste gro√ü genug ist oder w√§hrend des Staubsaugens, werden alle akkumulierten Aktualisierungen sofort am Index vorgenommen.  Welche Liste als "gro√ü genug" zu betrachten ist, wird durch den Konfigurationsparameter "gin_pending_list_limit" oder durch den gleichnamigen Speicherparameter des Index bestimmt. <br><br>  Dieser Ansatz hat jedoch Nachteile: Erstens wird die Suche verlangsamt (da die ungeordnete Liste zus√§tzlich zum Baum durchsucht werden muss), und zweitens kann eine n√§chste Aktualisierung unerwartet viel Zeit in Anspruch nehmen, wenn die ungeordnete Liste √ºbergelaufen ist. <br><br><h3>  Suche nach einer Teil√ºbereinstimmung </h3><br>  Wir k√∂nnen Teil√ºbereinstimmungen in der Volltextsuche verwenden.  Betrachten Sie beispielsweise die folgende Abfrage: <br><br><pre> <code class="pgsql hljs">gin=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc -------------------------------------------------------- Can a sheet slitter slit sheets? How many sheets could a sheet slitter slit? I slit a sheet, a sheet I slit. Upon a slitted sheet I sit. Whoever slit the sheets is a good sheet slitter. I am a sheet slitter. I slit sheets. I am the sleekest sheet slitter that ever slit sheets. She slits the sheet she sits on. (9 rows)</code> </pre><br>  Diese Abfrage findet Dokumente, die Lexeme enthalten, die mit "slit" beginnen.  In diesem Beispiel sind solche Lexeme "Schlitz" und "Schlitz". <br><br>  Eine Abfrage wird sicherlich auch ohne Indizes funktionieren, aber GIN erm√∂glicht es auch, die folgende Suche zu beschleunigen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) (4 rows)</code> </pre><br>  Hier werden alle Lexeme mit dem in der Suchabfrage angegebenen Pr√§fix im Baum nachgeschlagen und durch ein boolesches "oder" verbunden. <br><br><h3>  H√§ufige und seltene Lexeme </h3><br>  Um zu sehen, wie die Indizierung f√ºr Live-Daten funktioniert, nehmen wir das Archiv der "pgsql-hackers" -E-Mails, die wir bereits bei der Er√∂rterung von GiST verwendet haben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diese Version des Archivs</a> enth√§lt 356125 Nachrichten mit dem Versanddatum, dem Betreff, dem Autor und dem Text. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv);</code> </pre><br>  Betrachten wir ein Lexem, das in vielen Dokumenten vorkommt.  Die Abfrage mit "unnest" funktioniert bei einer so gro√üen Datenmenge nicht. Die richtige Technik besteht darin, die Funktion "ts_stat" zu verwenden, die Informationen zu Lexemen, die Anzahl der Dokumente, in denen sie aufgetreten sind, und die Gesamtzahl der Vorkommen bereitstellt. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ndoc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc -------+-------- re | 322141 wrote | 231174 use | 176917 (3 rows)</code> </pre><br>  W√§hlen wir "geschrieben". <br><br>  Und wir werden ein Wort nehmen, das f√ºr Entwickler-E-Mails selten vorkommt, sagen wir "Tattoo": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> word = <span class="hljs-string"><span class="hljs-string">'tattoo'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc --------+------ tattoo | 2 (1 row)</code> </pre><br>  Gibt es Dokumente, in denen diese beiden Lexeme vorkommen?  Es scheint, dass es gibt: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row)</code> </pre><br>  Es stellt sich die Frage, wie diese Abfrage durchgef√ºhrt werden soll.  Wenn wir, wie oben beschrieben, Listen mit TIDs f√ºr beide Lexeme erhalten, ist die Suche offensichtlich ineffizient: Wir m√ºssen mehr als 200.000 Werte durchlaufen, von denen nur einer √ºbrig bleibt.  Gl√ºcklicherweise versteht der Algorithmus unter Verwendung der Planerstatistik, dass "geschriebenes" Lexem h√§ufig vorkommt, w√§hrend "T√§towierung" selten vorkommt.  Daher wird die Suche nach dem seltenen Lexem durchgef√ºhrt, und die beiden abgerufenen Dokumente werden dann auf das Auftreten eines "geschriebenen" Lexems √ºberpr√ºft.  Und das geht aus der Abfrage hervor, die schnell durchgef√ºhrt wird: <br><br><pre> <code class="pgsql hljs">fts=# \<span class="hljs-keyword"><span class="hljs-keyword">timing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row) Time: 0,959 ms</code> </pre><br>  Die Suche nach "geschrieben" allein dauert deutlich l√§nger: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count -------- 231174 (1 row) Time: 2875,543 ms (00:02,876)</code> </pre><br>  Diese Optimierung funktioniert sicherlich nicht nur f√ºr zwei Lexeme, sondern auch in komplexeren F√§llen. <br><br><h3>  Einschr√§nkung des Abfrageergebnisses </h3><br>  Ein Merkmal der GIN-Zugriffsmethode ist, dass das Ergebnis immer als Bitmap zur√ºckgegeben wird: Diese Methode kann das Ergebnis TID f√ºr TID nicht zur√ºckgeben.  Aus diesem Grund verwenden alle Abfragepl√§ne in diesem Artikel den Bitmap-Scan. <br><br>  Daher ist die Einschr√§nkung des Index-Scan-Ergebnisses mithilfe der LIMIT-Klausel nicht sehr effizient.  Beachten Sie die vorhergesagten Kosten der Operation (Feld "Kosten" des Knotens "Limit"): <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------- Limit (cost=1283.61..1285.13 rows=1) -&gt; Bitmap Heap Scan on mail_messages (cost=1283.61..209975.49 rows=137207) Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) -&gt; Bitmap Index Scan on mail_messages_tsv_idx (cost=0.00..1249.30 rows=137207) Index Cond: (tsv @@ to_tsquery('wrote'::text)) (5 rows)</code> </pre><br>  Die Kosten werden auf 1285,13 gesch√§tzt, was etwas h√∂her ist als die Kosten f√ºr die Erstellung der gesamten Bitmap 1249.30 (Feld "Kosten" des Bitmap-Index-Scan-Knotens). <br><br>  Daher verf√ºgt der Index √ºber eine spezielle Funktion, um die Anzahl der Ergebnisse zu begrenzen.  Der Schwellenwert wird im Konfigurationsparameter "gin_fuzzy_search_limit" angegeben und ist standardm√§√üig gleich Null (es findet keine Einschr√§nkung statt).  Aber wir k√∂nnen den Schwellenwert einstellen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5746 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">10000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 14726 (1 row)</code> </pre><br>  Wie wir sehen k√∂nnen, unterscheidet sich die Anzahl der von der Abfrage zur√ºckgegebenen Zeilen f√ºr verschiedene Parameterwerte (wenn der Indexzugriff verwendet wird).  Die Einschr√§nkung ist nicht streng: Es k√∂nnen mehr Zeilen als angegeben zur√ºckgegeben werden, was einen "unscharfen" Teil des Parameternamens rechtfertigt. <br><br><h3>  Kompakte Darstellung </h3><br>  GIN-Indizes sind unter anderem dank ihrer Kompaktheit gut.  Erstens, wenn ein und dasselbe Lexem in mehreren Dokumenten vorkommt (und dies ist normalerweise der Fall), wird es nur einmal im Index gespeichert.  Zweitens werden TIDs in geordneter Weise im Index gespeichert, und dies erm√∂glicht es uns, eine einfache Komprimierung zu verwenden: Jede n√§chste TID in der Liste wird tats√§chlich als Differenz zur vorherigen gespeichert.  Dies ist normalerweise eine kleine Zahl, die viel weniger Bits ben√∂tigt als eine vollst√§ndige Sechs-Byte-TID. <br><br>  Um eine Vorstellung von der Gr√∂√üe zu bekommen, erstellen wir einen B-Baum aus dem Text der Nachrichten.  Aber ein fairer Vergleich wird sicherlich nicht passieren: <br><br><ul><li>  GIN basiert auf einem anderen Datentyp ("tsvector" anstelle von "text"), der kleiner ist. </li><li>  Gleichzeitig muss die Gr√∂√üe der Nachrichten f√ºr den B-Baum auf ungef√§hr zwei Kilobyte verk√ºrzt werden. </li></ul><br>  Trotzdem fahren wir fort: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages(substring(body_plain <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span>));</code> </pre><br>  Wir werden auch den GiST-Index erstellen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_gist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Die Gr√∂√üe der Indizes bei "Vakuum voll": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gin, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_gist'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gist, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_btree'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> btree;</code> </pre><pre> <code class="plaintext hljs"> gin | gist | btree --------+--------+-------- 179 MB | 125 MB | 546 MB (1 row)</code> </pre><br>  Aufgrund der Kompaktheit der Darstellung k√∂nnen wir versuchen, den GIN-Index w√§hrend der Migration von Oracle als Ersatz f√ºr Bitmap-Indizes zu verwenden (ohne auf Details einzugehen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verweise</a> ich f√ºr neugierige K√∂pfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Lewis 'Beitrag</a> ).  In der Regel werden Bitmap-Indizes f√ºr Felder mit wenigen eindeutigen Werten verwendet, was auch f√ºr GIN hervorragend ist.  Und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im ersten Artikel gezeigt</a> , kann PostgreSQL eine Bitmap basierend auf jedem Index, einschlie√ülich GIN, im laufenden Betrieb erstellen. <br><br><h3>  GiST oder GIN? </h3><br>  F√ºr viele Datentypen stehen Operatorklassen sowohl f√ºr GiST als auch f√ºr GIN zur Verf√ºgung, was die Frage aufwirft, welcher Index verwendet werden soll.  Vielleicht k√∂nnen wir bereits einige Schlussfolgerungen ziehen. <br><br>  In der Regel √ºbertrifft GIN GiST in Genauigkeit und Suchgeschwindigkeit.  Wenn die Daten nicht h√§ufig aktualisiert werden und eine schnelle Suche erforderlich ist, ist GIN h√∂chstwahrscheinlich eine Option. <br><br>  Wenn andererseits die Daten intensiv aktualisiert werden, scheinen die Gemeinkosten f√ºr die Aktualisierung von GIN zu hoch zu sein.  In diesem Fall m√ºssen wir beide Optionen vergleichen und die ausw√§hlen, deren Eigenschaften besser ausgewogen sind. <br><br><h2>  Arrays </h2><br>  Ein weiteres Beispiel f√ºr die Verwendung von GIN ist die Indizierung von Arrays.  In diesem Fall werden Array-Elemente in den Index aufgenommen, wodurch eine Reihe von Operationen √ºber Arrays beschleunigt werden k√∂nnen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- &amp;&amp;(anyarray,anyarray) | 1 intersection @&gt;(anyarray,anyarray) | 2 contains array &lt;@(anyarray,anyarray) | 3 contained in array =(anyarray,anyarray) | 4 equality (4 rows)</code> </pre><br>  Unsere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Datenbank</a> bietet eine Routenansicht mit Informationen zu Fl√ºgen.  Diese Ansicht enth√§lt unter anderem die Spalte "days_of_week" - eine Reihe von Wochentagen, an denen Fl√ºge stattfinden.  Zum Beispiel startet ein Flug von Vnukovo nach Gelendzhik dienstags, donnerstags und sonntags: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0049'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> departure_airport_name | arrival_airport_name | days_of_week ------------------------+----------------------+-------------- Vnukovo | Gelendzhik | {2,4,7} (1 row)</code> </pre><br>  Um den Index zu erstellen, "materialisieren" wir die Ansicht in einer Tabelle: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week);</code> </pre><br><br>  Jetzt k√∂nnen wir den Index verwenden, um alle Fl√ºge kennenzulernen, die dienstags, donnerstags und sonntags abfliegen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (4 rows)</code> </pre><br>  Es scheint, dass es sechs von ihnen gibt: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flight_no, departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> flight_no | departure_airport_name | arrival_airport_name | days_of_week -----------+------------------------+----------------------+-------------- PG0005 | Domodedovo | Pskov | {2,4,7} PG0049 | Vnukovo | Gelendzhik | {2,4,7} PG0113 | Naryan-Mar | Domodedovo | {2,4,7} PG0249 | Domodedovo | Gelendzhik | {2,4,7} PG0449 | Stavropol | Vnukovo | {2,4,7} PG0540 | Barnaul | Vnukovo | {2,4,7} (6 rows)</code> </pre><br>  Wie wird diese Abfrage durchgef√ºhrt?  Genau so wie oben beschrieben: <br><br><ol><li>  Aus dem Array {2,4,7}, das hier die Rolle der Suchabfrage spielt, werden Elemente (Suchschl√ºsselw√∂rter) extrahiert.  Offensichtlich sind dies die Werte von "2", "4" und "7". <br></li><li>  Im Baum der Elemente werden die extrahierten Schl√ºssel gefunden, und f√ºr jeden von ihnen wird die Liste der TIDs ausgew√§hlt. <br></li><li>  Von allen gefundenen TIDs w√§hlt die Konsistenzfunktion diejenigen aus der Abfrage aus, die dem Operator entsprechen.  F√ºr den Operator <code>=</code> stimmen nur die TIDs √ºberein, die in allen drei Listen aufgetreten sind (mit anderen Worten, das urspr√ºngliche Array muss alle Elemente enthalten).  Dies reicht jedoch nicht aus: Es wird auch ben√∂tigt, damit das Array keine anderen Werte enth√§lt, und wir k√∂nnen diese Bedingung nicht mit dem Index √ºberpr√ºfen.  In diesem Fall fordert die Zugriffsmethode die Indizierungs-Engine daher auf, alle mit der Tabelle zur√ºckgegebenen TIDs erneut zu √ºberpr√ºfen. <br></li></ol><br>  Interessanterweise gibt es Strategien (z. B. "in Array enthalten"), die nichts √ºberpr√ºfen k√∂nnen und alle in der Tabelle gefundenen TIDs erneut √ºberpr√ºfen m√ºssen. <br><br>  Aber was tun, wenn wir die Fl√ºge kennen m√ºssen, die dienstags, donnerstags und sonntags von Moskau abfliegen?  Der Index unterst√ºtzt die zus√§tzliche Bedingung nicht, die in die Spalte "Filter" gelangt. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) Filter: (departure_city = 'Moscow'::text) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (5 rows)</code> </pre><br>  Hier ist dies in Ordnung (der Index w√§hlt sowieso nur sechs Zeilen aus), aber in F√§llen, in denen die zus√§tzliche Bedingung die Selektionsf√§higkeit erh√∂ht, ist eine solche Unterst√ºtzung erw√ºnscht.  Wir k√∂nnen jedoch nicht einfach den Index erstellen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type text has no default operator class for access method "gin" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Die Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">btree_gin</a> " hilft jedoch, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">indem</a> GIN-Operatorklassen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzugef√ºgt</a> werden, die die Arbeit eines regul√§ren B-Baums simulieren. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gin; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) -&gt; Bitmap Index Scan on routes_t_days_of_week_departure_city_idx Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) (4 rows)</code> </pre><br><h2>  Jsonb </h2><br>  Ein weiteres Beispiel f√ºr einen zusammengesetzten Datentyp mit integrierter GIN-Unterst√ºtzung ist JSON.  Um mit JSON-Werten arbeiten zu k√∂nnen, sind derzeit eine Reihe von Operatoren und Funktionen definiert, von denen einige mithilfe von Indizes beschleunigt werden k√∂nnen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opc.opcname, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> str <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'jsonb_ops'</span></span>,<span class="hljs-string"><span class="hljs-string">'jsonb_path_ops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> opcname | amopopr | str ----------------+------------------+----- jsonb_ops | ?(jsonb,text) | 9 top-level key exists jsonb_ops | ?|(jsonb,text[]) | 10 some top-level key exists jsonb_ops | ?&amp;(jsonb,text[]) | 11 all top-level keys exist jsonb_ops | @&gt;(jsonb,jsonb) | 7 JSON value is at top level jsonb_path_ops | @&gt;(jsonb,jsonb) | 7 (5 rows)</code> </pre><br>  Wie wir sehen k√∂nnen, stehen zwei Operatorklassen zur Verf√ºgung: "jsonb_ops" und "jsonb_path_ops". <br><br>  Die erste Operatorklasse "jsonb_ops" wird standardm√§√üig verwendet.  Alle Schl√ºssel, Werte und Array-Elemente werden als Elemente des anf√§nglichen JSON-Dokuments in den Index aufgenommen.  Jedem dieser Elemente wird ein Attribut hinzugef√ºgt, das angibt, ob dieses Element ein Schl√ºssel ist (dies wird f√ºr "vorhandene" Strategien ben√∂tigt, die zwischen Schl√ºsseln und Werten unterscheiden). <br><br>  Stellen wir zum Beispiel einige Zeilen aus "Routen" als JSON wie folgt dar: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_jsonb(t) route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> flight_no <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ) t; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb;</code> </pre><pre> <code class="plaintext hljs"> ctid | jsonb_pretty -------+------------------------------------------------- (0,1) | { + | "days_of_week": [ + | 1 + | ], + | "arrival_airport_name": "Surgut", + | "departure_airport_name": "Ust-Ilimsk" + | } (0,2) | { + | "days_of_week": [ + | 2 + | ], + | "arrival_airport_name": "Ust-Ilimsk", + | "departure_airport_name": "Surgut" + | } (0,3) | { + | "days_of_week": [ + | 1, + | 4 + | ], + | "arrival_airport_name": "Sochi", + | "departure_airport_name": "Ivanovo-Yuzhnyi"+ | } (0,4) | { + | "days_of_week": [ + | 2, + | 5 + | ], + | "arrival_airport_name": "Ivanovo-Yuzhnyi", + | "departure_airport_name": "Sochi" + | } (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(route);</code> </pre><br><br>  Der Index kann wie folgt aussehen: <br><br><img src="https://habrastorage.org/webt/oo/yi/x3/ooyix34gx7mrpiwdcol3a3ewnwu.png"><br><br>  Eine Abfrage wie diese kann nun beispielsweise mithilfe des Index ausgef√ºhrt werden: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------- Bitmap Heap Scan on routes_jsonb Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) -&gt; Bitmap Index Scan on routes_jsonb_route_idx Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) (4 rows)</code> </pre><br>  Beginnend mit dem Stammverzeichnis des JSON-Dokuments pr√ºft der Operator <code>@&gt;</code> , ob die angegebene Route ( <code>"days_of_week": [5]</code> ) auftritt.  Hier gibt die Abfrage eine Zeile zur√ºck: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> jsonb_pretty ------------------------------------------------ { + "days_of_week": [ + 2, + 5 + ], + "arrival_airport_name": "Ivanovo-Yuzhnyi",+ "departure_airport_name": "Sochi" + } (1 row)</code> </pre><br>  Die Abfrage wird wie folgt durchgef√ºhrt: <br><br><ol><li>  In der Suchabfrage ( <code>"days_of_week": [5]</code> ) werden Elemente (Suchschl√ºssel) extrahiert: "days_of_week" und "5". <br></li><li>  Im Baum der Elemente werden die extrahierten Schl√ºssel gefunden, und f√ºr jeden von ihnen wird die Liste der TIDs ausgew√§hlt: f√ºr "5" - (0,4) und f√ºr "Tage der Woche" - (0,1), (0,2) ), (0,3), (0,4). <br></li><li>  Von allen gefundenen TIDs w√§hlt die Konsistenzfunktion diejenigen aus der Abfrage aus, die dem Operator entsprechen.  F√ºr den Operator <code>@&gt;</code> sind Dokumente, die nicht alle Elemente aus der Suchabfrage enthalten, nicht sicher, sodass nur (0,4) √ºbrig bleibt.  Wir m√ºssen jedoch die mit der Tabelle verbleibende TID erneut √ºberpr√ºfen, da aus dem Index nicht ersichtlich ist, in welcher Reihenfolge die gefundenen Elemente im JSON-Dokument vorkommen. <br></li></ol><br>  Weitere Informationen zu anderen Operatoren finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Dokumentation</a> . <br><br>  Zus√§tzlich zu herk√∂mmlichen Operationen f√ºr den Umgang mit JSON ist seit langem die Erweiterung "jsquery" verf√ºgbar, die eine Abfragesprache mit umfangreicheren Funktionen (und sicherlich mit Unterst√ºtzung von GIN-Indizes) definiert.  Au√üerdem wurde 2016 ein neuer SQL-Standard herausgegeben, der seine eigenen Operationen und die Abfragesprache "SQL / JSON-Pfad" definiert.  Eine Implementierung dieses Standards wurde bereits durchgef√ºhrt, und wir glauben, dass er in PostgreSQL 11 erscheinen wird. <br><br><blockquote>  Der SQL / JSON-Pfad-Patch wurde schlie√ülich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr</a> PostgreSQL 12 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festgeschrieben</a> , w√§hrend andere Teile noch unterwegs sind.  Hoffentlich sehen wir die vollst√§ndig implementierte Funktion in PostgreSQL 13. <br></blockquote><br><h2>  Interna </h2><br>  Wir k√∂nnen mit der Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pageinspect</a> " in den GIN-Index <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schauen</a> . <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Die Informationen auf der Metaseite zeigen allgemeine Statistiken: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+----------- pending_head | 4294967295 pending_tail | 4294967295 tail_free_size | 0 n_pending_pages | 0 n_pending_tuples | 0 n_total_pages | 22968 n_entry_pages | 13751 n_data_pages | 9216 n_entries | 1423598 version | 2</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Seitenstruktur</a> bietet einen speziellen Bereich, in dem Zugriffsmethoden ihre Informationen speichern.  Dieser Bereich ist f√ºr gew√∂hnliche Programme wie Vakuum "undurchsichtig".  Die Funktion "Gin_page_opaque_info" zeigt diese Daten f√ºr GIN an.  Zum Beispiel k√∂nnen wir die Indexseiten kennenlernen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flags, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">22967</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g(id), <span class="hljs-comment"><span class="hljs-comment">-- n_total_pages gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) group by flags;</span></span></code> </pre><pre> <code class="plaintext hljs"> flags | count ------------------------+------- {meta} | 1 meta page {} | 133 internal page of element B-tree {leaf} | 13618 leaf page of element B-tree {data} | 1497 internal page of TID B-tree {data,leaf,compressed} | 7719 leaf page of TID B-tree (5 rows)</code> </pre><br>  Die Funktion "Gin_leafpage_items" bietet Informationen zu TIDs, die auf Seiten {Daten, Blatt, komprimiert} gespeichert sind: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_leafpage_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">2672</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------------------------------------------------------------- first_tid | (239,44) nbytes | 248 tids | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... -[ RECORD 2 ]--------------------------------------------------------------------- first_tid | (247,40) nbytes | 248 tids | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... ...</code> </pre><br>  Beachten Sie hier, dass die verbleibenden Seiten des TID-Baums tats√§chlich kleine komprimierte Listen von Zeigern auf Tabellenzeilen und nicht einzelne Zeiger enthalten. <br><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften der GIN-Zugriffsmethode an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden bereits bereitgestellt</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gin | can_order | f gin | can_unique | f gin | can_multi_col | t gin | can_exclude | f</code> </pre><br>  Interessanterweise unterst√ºtzt GIN die Erstellung von mehrspaltigen Indizes.  Im Gegensatz zu einem regul√§ren B-Baum speichert ein mehrspaltiger Index anstelle von zusammengesetzten Schl√ºsseln jedoch weiterhin einzelne Elemente, und die Spaltennummer wird f√ºr jedes Element angegeben. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verf√ºgbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Beachten Sie, dass die R√ºckgabe von Ergebnissen TID f√ºr TID (Index-Scan) nicht unterst√ºtzt wird.  Es ist nur ein Bitmap-Scan m√∂glich. <br><br>  Der R√ºckw√§rtsscan wird ebenfalls nicht unterst√ºtzt: Diese Funktion ist nur f√ºr den Indexscan erforderlich, nicht jedoch f√ºr den Bitmap-Scan. <br><br>  Und die folgenden Eigenschaften sind Spaltenebenen: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Hier ist nichts verf√ºgbar: keine Sortierung (was klar ist), keine Verwendung des Index als Deckung (da das Dokument selbst nicht im Index gespeichert ist), keine Manipulation von NULL-Werten (da dies f√ºr Elemente vom zusammengesetzten Typ nicht sinnvoll ist) . <br><br><h2>  Andere Datentypen </h2><br>  Es stehen einige weitere Erweiterungen zur Verf√ºgung, die f√ºr einige Datentypen die Unterst√ºtzung von GIN hinzuf√ºgen. <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_trgm</a> " erm√∂glicht es uns, die "√Ñhnlichkeit" von W√∂rtern zu bestimmen, indem wir vergleichen, wie viele gleiche Drei-Buchstaben-Sequenzen (Trigramme) verf√ºgbar sind.  Es werden zwei Operatorklassen hinzugef√ºgt, "gist_trgm_ops" und "gin_trgm_ops", die verschiedene Operatoren unterst√ºtzen, einschlie√ülich des Vergleichs mit LIKE und regul√§ren Ausdr√ºcken.  Wir k√∂nnen diese Erweiterung zusammen mit der Volltextsuche verwenden, um Wortoptionen zur Behebung von Tippfehlern vorzuschlagen. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hstore</a> " implementiert "Schl√ºsselwert" -Speicher.  F√ºr diesen Datentyp stehen Operatorklassen f√ºr verschiedene Zugriffsmethoden zur Verf√ºgung, einschlie√ülich GIN.  Mit der Einf√ºhrung des Datentyps "jsonb" gibt es jedoch keine besonderen Gr√ºnde f√ºr die Verwendung von "hstore". <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intarray</a> " erweitert die Funktionalit√§t von Integer-Arrays.  Die Indexunterst√ºtzung umfasst sowohl GiST als auch GIN (Operatorklasse "gin__int_ops"). <br></li></ul><br>  Und diese beiden Erweiterungen wurden bereits oben erw√§hnt: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">btree_gin</a> " f√ºgt GIN-Unterst√ºtzung f√ºr regul√§re Datentypen hinzu, damit diese zusammen mit zusammengesetzten Typen in einem mehrspaltigen Index verwendet werden k√∂nnen. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsquery</a> " definiert eine Sprache f√ºr die JSON-Abfrage und eine Operatorklasse f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexunterst√ºtzung</a> dieser Sprache.  Diese Erweiterung ist in einer Standard-PostgreSQL-Lieferung nicht enthalten. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448746/">https://habr.com/ru/post/de448746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448734/index.html">Drohnen und Roboter helfen, die Kathedrale Notre Dame in Paris zu retten</a></li>
<li><a href="../de448738/index.html">Wer jagt Startups?</a></li>
<li><a href="../de448740/index.html">Wir h√∂ren SID-Musik (Commodore 64) √ºber OPL3 auf modernen PCs</a></li>
<li><a href="../de448742/index.html">B√ºchse der Pandora: Wir analysieren die Ausnutzung der WinRAR-Sicherheitsanf√§lligkeit am Beispiel des Jobs NeoQUEST-2019</a></li>
<li><a href="../de448744/index.html">Wie √ºbertrage ich eine Variable vom Fragment zur Aktivit√§t in Android?</a></li>
<li><a href="../de448748/index.html">√úberlegungen zu Sch√∂nheit und Code</a></li>
<li><a href="../de448750/index.html">√úber eine Schwachstelle ist das nicht</a></li>
<li><a href="../de448754/index.html">Wer ist wer in Open Source: Geek-Biografien</a></li>
<li><a href="../de448756/index.html">Hintergrund: Warum Apple und Qualcomm sich stritten und sich dann vers√∂hnten</a></li>
<li><a href="../de448758/index.html">Smartwatch mit BASIC auf physischem 6502</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>