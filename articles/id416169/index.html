<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐢 ⚓️ 🐡 Kontainer Dewasa (Bagian 01): Panduan Praktis untuk Terminologi 👨🏾‍🍳 👚 ☮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anda mungkin bertanya, mengapa berurusan dengan terminologi jika konsep wadah terlihat cukup sederhana dan langsung? Namun, sering kali penggunaan ist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontainer Dewasa (Bagian 01): Panduan Praktis untuk Terminologi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416169/">  Anda mungkin bertanya, mengapa berurusan dengan terminologi jika konsep wadah terlihat cukup sederhana dan langsung?  Namun, sering kali penggunaan istilah yang salah menciptakan hambatan bagi pengembangan wadah.  Sebagai contoh, orang sering berpikir bahwa istilah "wadah" dan "gambar" digunakan secara bergantian, meskipun sebenarnya ada perbedaan konseptual yang penting di antara mereka.  Contoh lain: di dunia wadah, "repositori" tidak berarti apa yang Anda pikirkan.  Selain itu, teknologi wadah jauh lebih dari sekadar buruh pelabuhan. <br><br><img src="https://habrastorage.org/webt/ze/ev/2e/zeev2e5kfluh5uhoj-bpkgc6km8.png" width="100%"><br><br>  Jadi, tanpa mengetahui terminologinya, akan sulit untuk memahami bagaimana buruh pelabuhan berbeda dari CRI-O, rkt atau lxc / lxd;  atau mengevaluasi peran Open Container Initiative dalam menstandarisasi teknologi wadah. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  Memulai dengan wadah Linux sangat sederhana, tetapi segera ternyata kesederhanaan ini menyesatkan.  Ini biasanya terjadi seperti ini: setelah menghabiskan hanya beberapa menit memasang buruh pelabuhan atau mesin kontainer lainnya, Anda sudah memasukkan perintah pertama Anda.  Hanya beberapa menit - dan Anda sudah membuat gambar pertama wadah itu dan meletakkannya di domain publik.  Kemudian Anda terbiasa beralih ke arsitektur lingkungan produksi, dan kemudian tiba-tiba Anda menyadari bahwa untuk ini Anda harus terlebih dahulu berurusan dengan massa istilah dan teknologi yang ada di balik semua ini.  Lebih buruk lagi, banyak istilah yang tercantum di bawah ini digunakan secara bergantian, yang menciptakan banyak kebingungan bagi pemula. <br><br><ul><li>  Wadah </li><li>  Gambar </li><li>  Gambar Kontainer </li><li>  Lapisan Gambar </li><li>  Daftar </li><li>  Repositori </li><li>  Tag </li><li>  Gambar Dasar </li><li>  Gambar Platform </li><li>  Lapisan </li></ul><br>  Setelah menguasai terminologi yang ditetapkan dalam dokumen ini, Anda akan lebih memahami dasar teknologi wadah.  Selain itu, ini akan membantu Anda dan kolega Anda berbicara bahasa yang sama, serta secara sadar dan sengaja merancang arsitektur lingkungan wadah sesuai dengan spesifik tugas yang sedang diselesaikan.  Pada gilirannya, dari sudut pandang komunitas TI dan industri secara keseluruhan, peningkatan umum dalam pemahaman tentang teknologi kontainer berkontribusi pada munculnya arsitektur dan solusi baru.  Perhatikan bahwa artikel ini ditujukan untuk pembaca yang sudah memiliki gagasan tentang cara menjalankan wadah. <br><br><h3>  Wadah: Dasar-dasar </h3><br>  Sebelum melanjutkan ke terminologi wadah, kami akan menentukan apa sebenarnya wadah itu.  Istilah "wadah" berarti dua hal sekaligus.  Seperti program Linux biasa, sebuah wadah dapat berada di salah satu dari dua negara: bekerja dan tidak bekerja.  Dalam keadaan siaga, wadah adalah file atau satu set file yang disimpan di disk.  Ke kondisi inilah istilah yang merujuk pada Container Image and Repository Container.  Ketika Anda memasukkan perintah peluncuran kontainer, mesin wadah membuka paket file dan metadata yang diperlukan dan mentransfernya ke kernel Linux.  Memulai sebuah wadah sangat mirip dengan memulai proses Linux biasa dan membutuhkan panggilan API ke kernel Linux.  Panggilan API ini biasanya memulai isolasi tambahan dan memasang salinan file yang ada dalam gambar wadah.  Setelah wadah diluncurkan, itu hanya proses Linux.  Prosedur untuk meluncurkan wadah, serta format gambar wadah yang disimpan pada disk, ditentukan dan diatur oleh standar. <br><br>  Ada beberapa format untuk gambar kontainer ( <a href="">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Appc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LXD</a> ), tetapi industri ini secara bertahap bergerak menuju standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Open Container Initiative</a> tunggal, kadang-kadang disebut Open Containers atau hanya OCI.  Standar ini mendefinisikan <a href="">spesifikasi format gambar kontainer</a> , yang mendefinisikan format disk untuk menyimpan gambar kontainer, serta metadata, yang, pada gilirannya, mendefinisikan hal-hal seperti arsitektur perangkat keras dan sistem operasi (Linux, Windows, dll.).  Format gambar standar industri tunggal adalah kunci untuk menciptakan ekosistem perangkat lunak yang memungkinkan pengembang, proyek Open Source, dan vendor perangkat lunak untuk membuat gambar yang kompatibel dan berbagai alat, seperti tanda tangan elektronik, pemindaian, perakitan, peluncuran, pergerakan, dan pengelolaan gambar wadah. <br><br>  Selain itu, ada beberapa mesin kontainer, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRI-O</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Railcar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RKT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LXC</a> .  Mesin wadah mengambil gambar wadah dan mengubahnya menjadi wadah (mis., Proses yang berjalan).  Proses konversi juga ditentukan oleh standar OCI, yang mencakup spesifikasi runtime kontainer dan implementasi referensi runtime yang disebut RunC, yang merupakan model sumber terbuka yang diatur oleh komunitas pengembangan yang sesuai.  Banyak mesin penampung menggunakan model ini untuk berinteraksi dengan kernel host ketika membuat wadah. <br><br>  Alat yang mendukung spesifikasi <a href="">format gambar wadah</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lingkungan pelaksanaan wadah</a> standar OCI memberikan portabilitas dalam ekosistem berbagai platform wadah, mesin wadah, dan alat pendukung di berbagai platform cloud dan arsitektur lokal.  Memahami terminologi, standar, dan arsitektur sistem wadah akan memungkinkan Anda untuk berkomunikasi secara bermanfaat dengan spesialis lain dan merancang aplikasi dan lingkungan kontainer yang dapat diskalakan dan didukung yang memastikan penggunaan kontainer yang efisien untuk tahun-tahun mendatang. <br><br><h3>  Kosakata dasar </h3><br><h4>  Gambar kontainer </h4><br>  Dalam definisi yang paling sederhana, gambar kontainer adalah file yang diunduh dari server registri dan digunakan secara lokal sebagai titik pemasangan ketika wadah mulai.  Terlepas dari kenyataan bahwa istilah "gambar wadah" cukup sering digunakan, itu bisa berarti hal yang berbeda.  Faktanya adalah bahwa meskipun Docker, RKT dan bahkan LXD bekerja sesuai dengan prinsip yang baru saja dijelaskan - yaitu, mereka mengunduh file yang dihapus dan menjalankannya sebagai wadah - masing-masing teknologi ini mengartikan gambar wadah dengan caranya sendiri.  LXD beroperasi dengan gambar monolitik (lapisan tunggal), sedangkan buruh pelabuhan dan RKT menggunakan gambar OCI, yang dapat berisi beberapa lapisan. <br><br>  Sebenarnya, gambar kontainer pada server registri jauh dari satu file.  Ketika orang menggunakan istilah "gambar wadah", mereka sering berarti repositori dan berarti satu set beberapa lapisan gambar wadah, serta metadata yang berisi informasi tambahan tentang lapisan ini. <br><br>  Selain itu, konsep gambar wadah secara implisit menyiratkan keberadaan format untuk gambar seperti itu. <br><br><h4>  Format gambar kontainer </h4><br>  Awalnya, setiap mesin kontainer, termasuk LXD, RKT, dan Docker, memiliki format gambar sendiri.  Beberapa format ini hanya memungkinkan satu lapisan, sementara yang lain mendukung struktur pohon dari beberapa lapisan.  Saat ini, hampir semua alat dan mesin kontainer utama telah beralih ke format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OCI</a> , yang menentukan bagaimana lapisan dan metadata harus diatur dalam gambar wadah.  Intinya, format OCI mendefinisikan gambar kontainer yang terdiri dari file tar terpisah untuk setiap layer dan file manifest.json umum yang berisi metadata. <br><br>  Standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Open Container Initiative (OCI)</a> , yang awalnya didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format gambar Docker V2</a> , telah berhasil menggabungkan ekosistem besar dari mesin kontainer, platform cloud dan alat (pemindai keamanan, alat penandatanganan, pembuatan dan pemindahan wadah) dan memungkinkan Anda untuk melindungi investasi Anda dalam pengetahuan dan alat. <br><br><h4>  Mesin kontainer </h4><br>  Mesin penampung adalah bagian dari perangkat lunak yang menerima permintaan pengguna, termasuk parameter baris perintah, mengunduh gambar, dan, dari perspektif pengguna akhir, meluncurkan penampung.  Ada banyak mesin kontainer, termasuk buruh pelabuhan, RKT, CRI-O, dan LXD.  Selain itu, banyak platform cloud, layanan PaaS, dan platform container memiliki mesin mereka sendiri yang memahami gambar dalam format Docker atau OCI.  Memiliki standar industri untuk format gambar memastikan interoperabilitas semua platform ini. <br><br>  Turun tingkat, kita dapat mengatakan bahwa sebagian besar mesin kontainer tidak benar-benar memulai kontainer sendiri, tetapi melalui runtime yang kompatibel dengan OCI, seperti runc.  Biasanya, runtime wadah melakukan hal-hal berikut: <br><br><ul><li>  Menangani parameter, input pengguna </li><li>  Menangani parameter yang melewati API (paling sering sistem orkestrasi wadah) </li><li>  Unduh gambar wadah dari server registri </li><li>  Membongkar dan menyimpan gambar kontainer ke disk menggunakan Graph Driver (blok atau file, tergantung pada driver) </li><li>  Mempersiapkan titik mount untuk wadah, biasanya dalam penyimpanan copy-on-write (lagi, blok atau file, tergantung pada driver) </li><li>  Mempersiapkan metadata yang akan diteruskan ke runtime untuk menjalankan wadah dengan benar menggunakan: <br><ul><li>  Pengaturan default khusus yang tersirat untuk gambar wadah (misalnya, <a href="">ArchX86</a> ) </li><li>  Input pengguna untuk mengganti nilai default yang terkandung dalam gambar wadah (misalnya, CMD, ENTRYPOINT) </li><li>  Parameter default yang ditentukan oleh gambar wadah (misalnya, aturan <a href="">SECCOM</a> ) </li></ul></li><li>  Meminta runtime kontainer </li></ul><br><h4>  Wadah </h4><br>  Kontainer sudah ada dalam sistem operasi untuk beberapa waktu, karena sebenarnya ini hanya contoh berjalan dari gambar kontainer.  Wadah adalah proses Linux standar yang biasanya dibuat menggunakan panggilan sistem clone () alih-alih fork () atau exec ().  Selain itu, langkah-langkah isolasi tambahan sering diterapkan pada wadah menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cgroups</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SELinux,</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppArmor</a> . <br><br><h4>  Tuan rumah kontainer </h4><br>  Host kontainer adalah sistem di mana proses kemas dijalankan, yang sering disebut wadah untuk kesederhanaan.  Ini bisa berupa, misalnya, mesin virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RHEL Atomic Host yang</a> berlokasi di cloud publik atau berjalan pada logam kosong di pusat data perusahaan.  Ketika gambar kontainer (dengan kata lain, repositori) dari server registri diunduh ke host kontainer lokal, mereka mengatakan bahwa itu jatuh ke dalam cache lokal. <br><br>  Anda dapat menentukan repositori mana yang disinkronkan dengan cache lokal menggunakan perintah berikut: <br><br><pre>  [root @ rhel7 ~] # buruh pelabuhan gambar -a<font></font>
<font></font>
 ID GAMBAR TAG PENGUASAAN YANG DIBUAT DENGAN UKURAN VIRTUAL
 registry.access.redhat.com/rhel7 6883d5422f4e terbaru 3 minggu lalu 201,7 MB </pre><br><h4>  Server registri </h4><br>  Registri server pada dasarnya adalah server file yang digunakan untuk menyimpan repositori buruh pelabuhan.  Sebagai aturan, server registri ditentukan oleh nama DNS dan, secara opsional, nomor port.  Sebagian besar manfaat ekosistem buruh pelabuhan didorong oleh kemampuan untuk mengunduh dan mengunggah repositori ke server registri. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/mw/m4/rumwm4l9pkgmpglcy4xdu3rfb5q.png"></div><br>  Jika daemon docker tidak menemukan salinan repositori di cache lokal, daemon docker secara otomatis mengunduhnya dari server registri.  Pada sebagian besar distribusi Linux, daemon docker akan menggunakan situs docker.io untuk ini, tetapi pada beberapa distribusi ia dapat dikonfigurasi dengan caranya sendiri.  Sebagai contoh, Red Hat Enterprise Linux pertama kali mencoba mengunduh dari registry.access.redhat.com, dan baru kemudian dari docker.io (Docker Hub). <br><br>  Harus ditekankan di sini bahwa server registri secara implisit dianggap tepercaya.  Oleh karena itu, Anda harus memutuskan seberapa besar Anda mempercayai isi registri dan, masing-masing, mengizinkan atau menolaknya.  Selain keamanan, ada aspek lain yang harus ditangani terlebih dahulu, misalnya masalah lisensi perangkat lunak atau pemantauan kepatuhan.  Kesederhanaan yang memungkinkan pekerja mengunduh perangkat lunak membuat masalah kepercayaan sangat penting. <br><br>  Red Hat Enterprise Linux memungkinkan Anda untuk mengkonfigurasi registri buruh pelabuhan default.  Selain itu, RHEL7 dan RHEL7 Atomic memungkinkan Anda untuk menambah atau mengunci server registri melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file konfigurasi</a> : <br><br><pre>  vi / etc / sysconfig / docker
</pre><br>  RHEL7 dan RHEL 7 Atom secara default menggunakan server registri Red Hat: <br><br><pre>  ADD_REGISTRY = '- tambahkan-registry registry.access.redhat.com'
</pre><br>  Dalam beberapa kasus, untuk alasan keamanan, masuk akal untuk memblokir pendaftar dermaga umum, seperti DockerHub: <br><br><pre>  # BLOCK_REGISTRY = '- blok-registri'
</pre><br>  Red Hat juga menawarkan server registri terintegrasi sebagai bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Platform OpenShift Container</a> , serta server registri perusahaan yang berdiri sendiri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quay Enterprise</a> dan cloud, repositori swasta dan publik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quay.io.</a> <br><br><h4>  Orkestrasi wadah </h4><br>  Orang biasanya memulai dengan memasang host kontainer dan pertama-tama hanya mengunduh gambar kontainer yang mereka butuhkan.  Kemudian mereka melanjutkan untuk membuat gambar mereka sendiri dan mengunggahnya ke server registri untuk membuat tersedia untuk seluruh tim.  Setelah beberapa waktu, ada kebutuhan untuk menggabungkan beberapa kontainer sehingga dapat digunakan sebagai satu unit.  Dan akhirnya, pada titik tertentu, unit-unit ini harus menjadi bagian dari conveyor produksi (pengembangan-QA-produksi).  Beginilah biasanya orang menyadari bahwa mereka membutuhkan sistem orkestrasi. <br><br>  <b>Sistem orkestrasi wadah hanya mengimplementasikan dua hal:</b> <br><br><ol><li>  Mengirim muatan kontainer secara dinamis ke seluruh komputer cluster (ini sering disebut sebagai "komputasi terdistribusi") </li><li>  Menyediakan file deskripsi aplikasi standar (kube yaml, docker compose, dll.) </li></ol><br>  Dua hal ini sebenarnya memberikan berbagai manfaat: <br><br><ol><li>  Kemampuan untuk mengelola wadah yang menyusun aplikasi, secara terpisah satu sama lain, yang memungkinkan Anda untuk menyelesaikan tugas-tugas berikut secara efektif: <br><ul><li>  Pembuangan cluster host kontainer besar </li><li>  Kegagalan pada tingkat wadah individu (tidak lagi merespons proses, kehabisan memori) </li><li>  Gagal pada level host kontainer (drive, jaringan, reboot) </li><li>  Gagal di tingkat mesin wadah (kerusakan, restart) </li><li>  Penskalaan individu atas dan bawah kontainer </li></ul></li><li>  Mudah untuk menyebarkan contoh baru dari aplikasi yang sama di lingkungan baru, baik cloud dan tradisional, misalnya: <br><ul><li>  Pada mesin pengembang yang dikendalikan oleh sistem orkestrasi </li><li>  Dalam lingkungan pengembangan bersama di ruang nama pribadi </li><li>  Dalam lingkungan pengembangan yang sama di namespace publik internal untuk memastikan visibilitas dan menguji kinerja </li><li>  Di lingkungan internal QA </li><li>  Dalam lingkungan uji beban disediakan dan dicabut secara dinamis di cloud </li><li>  Dalam lingkungan referensi untuk memverifikasi kompatibilitas dengan lingkungan produksi </li><li>  Di lingkungan produksi </li><li>  Dalam lingkungan pemulihan bencana </li><li>  Dalam lingkungan produksi baru yang berisi host kontainer diperbarui, mesin kontainer atau alat orkestrasi </li><li>  Di lingkungan produksi baru, yang tidak berbeda dari yang utama, tetapi terletak di wilayah yang berbeda </li></ul></li></ol><br>  Komunitas Open Source dan vendor perangkat lunak menawarkan banyak alat orkestrasi yang berbeda.  Awalnya, tiga alat besar ini termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Swarm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesos</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kubernetes</a> , tetapi hari ini Kubernetes sebenarnya telah menjadi standar industri, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesosphere</a> telah mengumumkan dukungan mereka, belum lagi hampir semua penyedia layanan utama.  Namun, jika Anda mencari sistem orkestrasi perusahaan, kami sarankan Anda melihat lebih dekat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Red Hat OpenShift</a> . <br><br><h3>  Kamus Tingkat Lanjut </h3><br><h4>  Runtime kontainer </h4><br>  Runtime kontainer adalah komponen tingkat rendah yang biasanya digunakan sebagai bagian dari mesin wadah, tetapi juga dapat digunakan secara manual untuk menguji wadah.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Standar OCI</a> mendefinisikan implementasi referensi runtime yang dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runc</a> .  Ini adalah implementasi yang paling banyak digunakan, tetapi ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runtime yang</a> kompatibel dengan OCI lainnya seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">railcar,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">katacontainers</a> .  Docker, CRI-O, dan banyak mesin kontainer lainnya menggunakan runc. <br><br>  Runtime kontainer bertanggung jawab untuk hal-hal berikut: <br><br><ul><li>  Mendapat titik pemasangan wadah yang disediakan oleh mesin wadah (untuk pengujian, bisa saja berupa direktori) </li><li>  Mendapat metadata wadah yang disediakan oleh mesin wadah (selama pengujian, ini mungkin file config.json yang dirakit secara manual) </li><li>  Berkomunikasi dengan kernel OS untuk meluncurkan proses kemas (melalui panggilan sistem klon) </li><li>  Mengkonfigurasi cgroup </li><li>  Mengkonfigurasi Kebijakan SELinux </li><li>  Mengkonfigurasi Aturan Armor Aplikasi </li></ul><br>  Sedikit penyimpangan sejarah: ketika mesin Docker pertama kali muncul, ia menggunakan LXC sebagai lingkungan runtime.  Pengembang Docker kemudian menulis perpustakaan mereka sendiri untuk menjalankan kontainer yang disebut libcontainer.  Itu ditulis dalam bahasa Golang dan menjadi bagian dari mesin Docker.  Setelah pembentukan organisasi OCI, Docker memperkenalkan libcontainer kode sumber ke dalam proyek ini dan merilis perpustakaan ini sebagai utilitas terpisah yang disebut runc, yang kemudian menjadi implementasi referensi runtime kontainer dalam standar OCI dan digunakan dalam mesin kontainer lainnya, seperti CRI-O .  Runc adalah utilitas yang sangat sederhana yang hanya menunggu titik mount (direktori) dan metadata (config.json) diteruskan ke sana.  Informasi lebih lanjut tentang runc dapat ditemukan di <a href="">sini</a> . <br><br>  Untuk pemahaman yang lebih dalam, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Standar Kontainer</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Runtime Kontainer</a> . <br><br><h4>  Lapisan gambar </h4><br>  Repositori sering disebut sebagai gambar atau gambar wadah, meskipun sebenarnya repositori terdiri dari satu atau lebih lapisan.  Lapisan gambar dalam repositori saling berhubungan oleh hubungan orangtua-anak, dan setiap lapisan gambar berisi perbedaan dari lapisan induk. <br><br>  Mari kita lihat lapisan repositori pada host kontainer lokal.  Sejak dimulai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan versi 1.7, Docker tidak memiliki alat</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk melihat lapisan gambar</a> di repositori lokal (tetapi ada alat untuk pendaftaran online), kami akan menggunakan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dockviz</a> .  Perhatikan bahwa setiap lapisan memiliki tag dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengidentifikasi unik universal (UUID)</a> .  Untuk melihat UUID disingkat yang biasanya unik dalam mesin yang sama, kami menggunakan perintah berikut (jika Anda memerlukan UUID lengkap, gunakan perintah yang sama dengan opsi -no-trunc): <br><br>  run docker --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock gambar nate / dockviz -t <br><br><pre>  ├─2332d8973c93 Ukuran Virtual: 187,7 MB
  │ └─ea358092da77 Ukuran Virtual: 187,9 MB
  │ └─a467a7c6794f Ukuran Virtual: 187,9 MB
  │ └─ca4d7b1b9a51 Ukuran Virtual: 187,9 MB
  │ └─4084976dd96d Ukuran Virtual: 384.2 MB
  │ └─943128b20e28 Ukuran Virtual: 386.7 MB
  │ └─db20cc018f56 Ukuran Virtual: 386.7 MB
  │ └─45b3c59b9130 Ukuran Virtual: 398.2 MB
  │ └─91275de1a5d7 Ukuran Virtual: 422.8 MB
  │ └─e7a97058d51f Ukuran Virtual: 422.8 MB
  │ └─d5c963edfcb2 Ukuran Virtual: 422.8 MB
  │ └─5cfc0ce98e02 Ukuran Virtual: 422.8 MB
  │ └─7728f71a4bcd Ukuran Virtual: 422.8 MB
  │ └─0542f67da01b Ukuran Virtual: 422.8 MB Tag: docker.io/registry:latest
</pre><br>  Seperti yang Anda lihat, repositori docker.io/registry sebenarnya terdiri dari banyak lapisan.  Namun, yang lebih penting, pengguna dapat, pada prinsipnya, "memulai" wadah dari langkah apa pun di tangga langkah ini, misalnya, dengan memasukkan perintah di bawah ini (benar-benar benar, tetapi tidak ada yang dapat menjamin bahwa itu telah diuji atau akan bekerja dengan baik sama sekali).  Sebagai aturan, kolektor gambar memberi tag (membuat nama) lapisan-lapisan yang harus digunakan sebagai titik awal: <br><br><pre>  run docker -it 45b3c59b9130 bash
</pre><br>  Repositori diatur dengan cara yang sama karena setiap kali kolektor membuat gambar baru, perbedaan disimpan sebagai lapisan lain.  Ada dua cara utama untuk membuat layer baru di repositori.  Pertama, saat membuat gambar secara manual, setiap konfirmasi perubahan membuat lapisan baru.  Jika kolektor membuat gambar menggunakan file Docker, setiap arahan dalam file menciptakan lapisan baru.  Oleh karena itu, selalu berguna untuk dapat melihat apa yang telah berubah dalam repositori antar lapisan. <br><br><h4>  Tag </h4><br>  Meskipun pengguna sendiri dapat menentukan lapisan awal untuk pemasangan dan memulai wadah di repositori, ia tidak harus melakukan ini sama sekali.  Ketika pengumpul gambar membuat repositori baru, mereka biasanya menandai lapisan yang paling cocok untuk peran ini.  Marker ini disebut tag dan mewakili alat yang dengannya kolektor gambar dapat memberi tahu konsumen gambar lapisan mana yang paling baik digunakan.  Biasanya, tag digunakan untuk menunjukkan versi perangkat lunak dalam repositori.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, baik OCI, maupun standar lain tidak mengatur penggunaan tag, yang membuka ruang lingkup tanpa batas untuk kebingungan selama kolaborasi. </font><font style="vertical-align: inherit;">Oleh karena itu, kami merekomendasikan untuk secara hati-hati mendokumentasikan tag jika tag tidak hanya digunakan untuk menandai versi perangkat lunak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, ada satu tag khusus - terbaru, yang biasanya menunjuk ke lapisan yang berisi perangkat lunak terbaru dalam repositori. </font><font style="vertical-align: inherit;">Tag ini hanya menunjuk ke lapisan gambar, seperti tag lain, dan karenanya dapat juga digunakan secara tidak benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melihat tag yang tersedia di repositori dari jarak jauh, jalankan perintah berikut ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilitas jq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membuat output lebih mudah dibaca):</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">curl -s registry.access.redhat.com/v1/repository/rhel7/tags | </font><font style="vertical-align: inherit;">jq</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 {</font></font><font></font>
 "7.0-21": "e1f5733f050b2488a17b7630cb038bfbea8b7bdfa9bdfb99e63a33117e28d02f",<font></font>
 "7.0-23": "bef54b8f8a2fdd221734f1da404d4c0a7d07ee9169b1443a338ab54236c8c91a",<font></font>
 "7.0-27": "8e6704f39a3d4a0c82ec7262ad683a9d1d9a281e3c1ebbb64c045b9af39b3940",<font></font>
 "7.1-11": "d0a516b529ab1adda28429cae5985cab9db93bfd8d301b3a94d22299af72914b",<font></font>
 "7.1-12": "275be1d3d0709a06ff1ae38d0d5402bc8f0eeac44812e5ec1df4a9e99214eb9a",<font></font>
 "7.1-16": "82ad5fa11820c2889c60f7f748d67aab04400700c581843db0d1e68735327443",<font></font>
 "7.1-24": "c4f590bbcbe329a77c00fea33a3a960063072041489012061ec3a134baba50d6",<font></font>
 "7.1-4": "10acc31def5d6f249b548e01e8ffbaccfd61af0240c17315a7ad393d022c5ca2",<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 "7.1-6": "65de4a13fc7cf28b4376e65efa31c5c3805e18da4eb01ad0c8b8801f4a10bc16",</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 "7.1-9": "e3c92c6cff3543d19d0c9a24c72cd3840f8ba3ee00357f997b786e8939efef2f",</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 "7.2": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 "7.2-2": "58958c7fafb7e1a71650bc7bdbb9f5fd634f3545b00ec7d390b2075db511327d",</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 "7.2-35": "6883d5422f4ec2810e1312c0e3e5a902142e2a8185cd3a1124b459a7c38dc55b",</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 "7.2-38": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 "terbaru": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e"</font></font><font></font>
  }
</pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repositori </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat menggunakan perintah buruh pelabuhan, repositori, bukan gambar, ditentukan pada baris perintah. </font><font style="vertical-align: inherit;">Misalnya, dalam perintah rhel7 di bawah ini, ini adalah repositori.</font></font><br><br><pre> docker pull rhel7
</pre><br>         : <br><br><pre> docker pull registry.access.redhat.com/rhel7:latest
</pre><br>   ,      .    ,  ,      ,   docker images.        ,      ,            ,      «» (manifest.json): <br><br><pre> docker images<font></font>
<font></font>
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE<font></font>
 registry.access.redhat.com/rhel7 latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel6 latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 registry.access.redhat.com/rhel6/rhel terbaru 05c3d56ba777 4 minggu lalu 166.1 MB</font></font><font></font>
  ...
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan menentukan repositori pada baris perintah, kami sebenarnya meminta mesin kontainer untuk melakukan beberapa pekerjaan untuk kami. </font><font style="vertical-align: inherit;">Dalam contoh di atas, daemon buruh pelabuhan (yaitu, daemon, bukan alat klien) memiliki daftar server yang dikonfigurasi untuk mencari, dan karenanya akan mencari repositori rhel7 pada masing-masingnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh di atas, kami hanya menentukan nama repositori, tetapi di klien buruh pelabuhan Anda juga dapat menentukan URL lengkap. </font><font style="vertical-align: inherit;">Untuk memahami bagaimana melakukan ini, pisahkan URL lengkap menjadi bagian-bagian komponennya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/7s/lc/v27slcdbibwowtrbi7ebbv7dutw.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan kata lain, turun ke: </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> REGISTRI / NAMESPACE / REPOSITORY [: TAG]
</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URL lengkap terdiri dari nama server, namespace, dan tag opsional. </font><font style="vertical-align: inherit;">Bahkan, ada banyak nuansa saat menentukan URL, dan saat Anda menjelajahi ekosistem buruh pelabuhan, Anda akan melihat bahwa banyak hal bersifat opsional. </font><font style="vertical-align: inherit;">Secara khusus, lihat perintah di bawah ini: semuanya benar dan mengarah ke hasil yang sama:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buruh pelabuhan menarik registry.access.redhat.com/rhel7/rhel:latest</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 buruh pelabuhan menarik registry.access.redhat.com/rhel7/rhel</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 buruh pelabuhan menarik registry.access.redhat.com/rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 buruh pelabuhan tarik rhel7 / rhel: terbaru</font></font><font></font>
</pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ruang nama </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruang nama adalah alat untuk memisahkan repositori menjadi grup. </font><font style="vertical-align: inherit;">Di registri publik </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DockerHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">namespace biasanya adalah nama pengguna yang berbagi gambar, tetapi juga bisa berupa nama grup atau nama logis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red Hat menggunakan ruang nama untuk memisahkan grup repositori dengan produk yang terdaftar di server </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Red Hat Federated Registry</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Contoh jajak pendapat dari registry.access.redhat.com disediakan di bawah ini. </font><font style="vertical-align: inherit;">Perhatikan bahwa baris terakhir dalam contoh ini sebenarnya menunjuk ke server registri yang berbeda. </font><font style="vertical-align: inherit;">Ini karena fakta bahwa Red Hat bekerja untuk menampilkan repositori pada server registri mitra kami:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> registry.access.redhat.com/rhel7/rhel</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
registry.access.redhat.com/openshift3/mongodb-24-rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
registry.access.redhat.com/rhscl/mongodb-26-rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
registry.access.redhat.com/rhscl_beta/mongodb-26-rhel7</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
registry-mariadbcorp.rhcloud.com/rhel7/mariadb-enterprise-server:10.0</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harap perhatikan bahwa kadang-kadang URL lengkap mungkin tidak ditentukan. </font><font style="vertical-align: inherit;">Dalam contoh di atas, untuk setiap namespace ada repositori default. </font><font style="vertical-align: inherit;">Jika pengguna hanya menentukan namespace fedora, maka repositori dengan tag terbaru diunduh ke server lokal. </font><font style="vertical-align: inherit;">Oleh karena itu, perintah di bawah ini menghasilkan hasil yang sama:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buruh pelabuhan tarik fedora</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
buruh pelabuhan menarik docker.io/fedora</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
buruh pelabuhan menarik docker.io/library/fedora:latest</font></font><font></font>
</pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kernel Namespaces </font></font></h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a>     ,    ,       .       , ,    ,     ,   ,    .          ,  ,  ,    . . <br><br>       Bash   Enter, Bash     Linux-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">exec()</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kontainer berbeda karena ketika Anda mengirim permintaan ke mesin wadah, seperti buruh pelabuhan, daemon buruh pelabuhan meminta kernel untuk membuat proses kemas menggunakan menggunakan panggilan sistem lain yang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Panggilan sistem clone () istimewa karena dapat membuat proses dengan titik mount virtualnya sendiri, ID proses, ID pengguna, antarmuka jaringan, nama host, dll. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, meskipun Linux tidak memiliki struktur data satu untuk mewakili wadah, yang paling dekat dengan peran adalah ruang nama kernel dan panggilan sistem clone ().</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/mp/t7/5ompt7ole83_ucaorlj2fzj3nv4.png"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dilanjutkan ...</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416169/">https://habr.com/ru/post/id416169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416157/index.html">Di lengan Python (khusus wanita)</a></li>
<li><a href="../id416159/index.html">Bagaimana kami ditugaskan membandingkan landak dengan ular</a></li>
<li><a href="../id416161/index.html">10 alasan [tidak] menggunakan k8s</a></li>
<li><a href="../id416163/index.html">Pelajari OpenGL. Pelajaran 5.6 - Pemetaan Parallax</a></li>
<li><a href="../id416167/index.html">Peter Norwig: Belajar Pemrograman dalam ... 10 Tahun</a></li>
<li><a href="../id416171/index.html">Visual Studio Coded UI Tests: teori dan praktik aplikasi di perusahaan kami</a></li>
<li><a href="../id416175/index.html">Hasil kompetisi pengembang muda aplikasi AR Epson Moverio BT-300</a></li>
<li><a href="../id416177/index.html">Rumus Tupper dan implementasi algoritma dalam Python</a></li>
<li><a href="../id416179/index.html">Sebuah pintu yang menyapa kita dengan nama dan hanya terbuka untuk karyawan departemen</a></li>
<li><a href="../id416181/index.html">Modulasi Amplitudo pada Jari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>