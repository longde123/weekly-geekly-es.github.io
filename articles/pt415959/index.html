<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∞ üë®üèΩ‚Äçüè≠ üñ≤Ô∏è Como escrevemos o c√≥digo de rede do shooter PvP m√≥vel: sincroniza√ß√£o do jogador no cliente üôáüèΩ üèí ü•Ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em um dos artigos anteriores , analisamos as tecnologias usadas em nosso novo projeto - um jogo de tiro r√°pido para dispositivos m√≥veis. Agora, quero ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escrevemos o c√≥digo de rede do shooter PvP m√≥vel: sincroniza√ß√£o do jogador no cliente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/415959/">  Em um dos artigos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriores</a> , analisamos as tecnologias usadas em nosso novo projeto - um jogo de tiro r√°pido para dispositivos m√≥veis.  Agora, quero compartilhar como a parte do cliente do c√≥digo de rede do jogo futuro √© organizada, quais dificuldades encontramos e como resolv√™-las. <br><br><img src="https://habrastorage.org/webt/va/gz/nl/vagznl64ylol9qhxysj5ti1akpy.jpeg"><br><a name="habracut"></a><br><br>  Em geral, as abordagens para a cria√ß√£o de jogos multiplayer r√°pidos nos √∫ltimos 20 anos n√£o mudaram muito.  V√°rios m√©todos podem ser distinguidos na arquitetura do c√≥digo de rede: <br><br><ol><li>  Erro de c√°lculo do estado do mundo no servidor e exibi√ß√£o dos resultados no cliente sem previs√£o para o player local e com a possibilidade de perder a entrada do player (entrada).  A prop√≥sito, essa abordagem √© usada em outro projeto em desenvolvimento - voc√™ pode ler sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lockstep</a> </li><li>  Sincroniza√ß√£o do estado do mundo sem l√≥gica determin√≠stica com previs√£o para um player local. </li><li>  Sincroniza√ß√£o de entrada com l√≥gica totalmente determin√≠stica e previs√£o para um player local. </li></ol><br>  A peculiaridade reside no fato de que, nos atiradores, o mais importante √© a responsividade do controle - o jogador pressiona um bot√£o (ou move o joystick) e deseja ver imediatamente o resultado de sua a√ß√£o.  Primeiro de tudo, porque o estado do mundo em tais jogos muda muito rapidamente e √© necess√°rio responder imediatamente √† situa√ß√£o. <br><br>  Como resultado, abordagens sem o mecanismo de previs√£o das a√ß√µes do jogador local (previs√£o) n√£o eram adequadas para o projeto, e adotamos um m√©todo de sincroniza√ß√£o do estado do mundo, sem l√≥gica determin√≠stica. <br><br>  <b>Vantagem da abordagem:</b> menor complexidade na implementa√ß√£o em compara√ß√£o com o m√©todo de sincroniza√ß√£o ao trocar entrada. <br>  <b>Menos:</b> um aumento no tr√°fego ao enviar todo o estado do mundo para o cliente.  Tivemos que aplicar v√°rias t√©cnicas diferentes de otimiza√ß√£o de tr√°fego para fazer o jogo funcionar de maneira est√°vel em uma rede m√≥vel. <br><br>  No cora√ß√£o da arquitetura de jogo, temos o ECS, sobre o qual j√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">falamos</a> .  Essa arquitetura permite que voc√™ armazene convenientemente dados sobre o mundo do jogo, serialize, copie e transfira pela rede.  E tamb√©m para executar o mesmo c√≥digo no cliente e no servidor. <br><br>  A simula√ß√£o do mundo do jogo ocorre a uma frequ√™ncia fixa de 30 ticks por segundo.  Isso permite reduzir o atraso na entrada do player e quase n√£o usar interpola√ß√£o para exibir visualmente o estado do mundo.  Mas h√° uma desvantagem significativa que deve ser considerada ao desenvolver um sistema desse tipo: para que o sistema de previs√£o do jogador local funcione corretamente, o cliente deve simular o mundo com a mesma frequ√™ncia do servidor.  E gastamos muito tempo para otimizar a simula√ß√£o o suficiente para os dispositivos de destino. <br><br><h2>  Mecanismo de previs√£o de a√ß√£o do jogador local (previs√£o) </h2><br>  O mecanismo de previs√£o do cliente √© implementado com base no ECS devido √† execu√ß√£o dos mesmos sistemas no cliente e no servidor.  No entanto, nem todos os sistemas s√£o executados no cliente, mas apenas aqueles que s√£o respons√°veis ‚Äã‚Äãpelo player local e n√£o exigem dados relevantes sobre outros players. <br><br>  Exemplo de listas de sistemas em execu√ß√£o no cliente e servidor: <br><br><img src="https://habrastorage.org/webt/sm/jl/wc/smjlwcvyu5mv2omhgnggu9zbbnc.png"><br><br>  No momento, temos cerca de 30 sistemas em execu√ß√£o no cliente que fornecem a previs√£o do jogador e cerca de 80 sistemas em execu√ß√£o no servidor.  Mas n√£o previmos coisas como causar dano, usar habilidades ou curar aliados.  Existem dois problemas nessa mec√¢nica: <br><br><ol><li>  O cliente n√£o sabe nada sobre como entrar em outros jogadores e prever coisas como dano ou cura quase sempre diverge dos dados no servidor. </li><li>  Criar novas entidades localmente (tiros, proj√©teis, habilidades √∫nicas) geradas por um jogador carrega o problema de combinar com entidades criadas no servidor. </li></ol><br>  Para esse mec√¢nico, o atraso oculta o jogador de outras maneiras. <br><br>  <i>Exemplo: desenhamos o efeito de acertar o tiro imediatamente e atualizamos a vida do inimigo somente ap√≥s recebermos a confirma√ß√£o do golpe do servidor.</i> <br><br><h2>  O esquema geral do c√≥digo de rede no projeto </h2><br><br><img src="https://habrastorage.org/webt/so/vq/gw/sovqgwxy7gc2rxtsqedxdlkpdew.png"><br>  O cliente e o servidor sincronizam o tempo por n√∫meros de tick.  Devido ao fato de a transmiss√£o de dados pela rede levar algum tempo, o cliente est√° sempre √† frente do servidor pela metade do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTT</a> + o tamanho do buffer de entrada no servidor.  O diagrama acima mostra que o cliente envia uma entrada para o tick 20 (a).  Ao mesmo tempo, o tick 15 (b) √© processado no servidor.  Quando a entrada do cliente chegar ao servidor, o tick 20 ser√° processado no servidor. <br><br>  Todo o processo consiste nas seguintes etapas: o cliente envia a entrada do jogador para o servidor (a) ‚Üí essa entrada √© processada no servidor ap√≥s o tamanho do buffer de entrada HRTT + (b) ‚Üí o servidor envia o estado mundial resultante ao (s) cliente (s) ‚Üí o cliente aplica o estado mundial confirmado com tempo do servidor RTT + tamanho do buffer de entrada + tamanho do buffer de interpola√ß√£o do estado do jogo (d). <br><br>  Depois que o cliente recebe um novo estado confirmado do mundo do servidor (d), ele precisa concluir o processo de reconcilia√ß√£o.  O fato √© que o cliente realiza previs√µes mundiais com base apenas nas informa√ß√µes do jogador local.  As contribui√ß√µes de outros jogadores n√£o s√£o conhecidas por ele.  E, ao calcular o estado do mundo no servidor, o jogador pode estar em um estado diferente, diferente do que o cliente previu.  Isso pode acontecer quando um jogador √© atordoado ou morto. <br><br>  O processo de aprova√ß√£o consiste em duas partes: <br><br><ol><li>  Compara√ß√µes do estado previsto do mundo para o tick N recebido do servidor.  Somente os dados relacionados ao player local est√£o envolvidos na compara√ß√£o.  O restante dos dados do mundo √© sempre retirado do estado do servidor e n√£o participa da coordena√ß√£o. </li><li>  Durante a compara√ß√£o, dois casos podem ocorrer: </li></ol><br>  - se o estado previsto do mundo coincidir com o confirmado do servidor, o cliente, usando os dados previstos para o player local e novos dados para o resto do mundo, continuar√° simulando o mundo no modo normal; <br>  - se o estado previsto n√£o corresponder, o cliente usar√° todo o estado do servidor no mundo e o hist√≥rico de informa√ß√µes do cliente e recontar√° o novo estado previsto no mundo do jogador. <br><br><div class="spoiler">  <b class="spoiler_title">No c√≥digo, parece algo como isto:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">GameState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconcile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentTick, ServerGameStateData serverStateData, GameState currentState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverState = serverStateData.GameState; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverTick = serverState.Time; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> predictedState = _localStateHistory.Get(serverTick); <span class="hljs-comment"><span class="hljs-comment">//if predicted state matches server last state use server predicted state with predicted player if (_gameStateComparer.IsSame(predictedState, serverState, playerID)) { _tempState.Copy(serverState); _gameStateCopier.CopyPlayerEntities(currentState, _tempState, playerID); return _localStateHistory.Put(_tempState); // replace predicted state with correct server state } //if predicted state doesn't match server state, reapply local inputs to server state var last = _localStateHistory.Put(serverState); // replace wrong predicted state with correct server state for (var i = serverTick; i &lt; currentTick; i++) { last = _prediction.Predict(last); // resimulate all wrong states } return last; }</span></span></code> </pre> <br></div></div><br>  A compara√ß√£o de dois estados mundiais ocorre apenas para os dados que se relacionam com o player local e participam do sistema de previs√£o.  Os dados s√£o amostrados pelo ID do jogador. <br><br><div class="spoiler">  <b class="spoiler_title">M√©todo de compara√ß√£o:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState s1, GameState s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || s1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity1 = s1.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity2 = s2.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Time != s2.Time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Weapon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s1.WorldState.Weapon) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value.Owner.Id != avatarId) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Weapon = s2.WorldState.Weapon[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value != s2Weapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Ammo = s1.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Ammo = s2.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Ammo != s2Ammo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Reload = s1.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Reload = s2.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Reload != s2Reload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.Aiming != entity2.Aiming) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.ChangeWeapon != entity2.ChangeWeapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Operadores de compara√ß√£o para componentes espec√≠ficos s√£o gerados junto com toda a estrutura EC, especialmente escrita por um gerador de c√≥digo.  Por exemplo, fornecerei o c√≥digo gerado do operador de compara√ß√£o de componentes Transform: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Note-se que nossos valores de flutua√ß√£o s√£o comparados com um erro bastante alto.  Isso √© feito para reduzir a quantidade de dessincroniza√ß√£o entre o cliente e o servidor.  Para o jogador, esse erro ser√° invis√≠vel, mas isso economiza significativamente os recursos de computa√ß√£o do sistema. <br><br>  A complexidade do mecanismo de coordena√ß√£o √© que, no caso de uma sincroniza√ß√£o incorreta dos estados do cliente e do servidor (previs√£o incorreta), √© necess√°rio simular repetidamente todos os estados previstos do cliente sobre os quais n√£o h√° confirma√ß√£o do servidor, at√© o tick atual em um quadro.  Dependendo do ping do jogador, isso pode variar de 5 a 20 carrapatos de simula√ß√£o.  Tivemos que otimizar significativamente o c√≥digo de simula√ß√£o para ajustar-se ao prazo: 30 fps. <br><br>  Para concluir o processo de aprova√ß√£o, dois tipos de dados devem ser armazenados no cliente: <br><br><ol><li>  Uma hist√≥ria dos estados previstos do jogador. </li><li>  E a hist√≥ria da entrada. </li></ol><br>  Para esses fins, usamos um buffer circular.  O tamanho do buffer √© de 32 ticks.  Isso na frequ√™ncia de 30 HZ d√° cerca de 1 segundo em tempo real.  O cliente pode continuar trabalhando com seguran√ßa no mecanismo de previs√£o, sem receber novos dados do servidor, at√© preencher esse buffer.  Se a diferen√ßa entre a hora do cliente e o servidor come√ßar a ser superior a um segundo, o cliente ser√° for√ßado a se desconectar com uma tentativa de se reconectar.  Temos esse tamanho de buffer devido aos custos do processo de coordena√ß√£o em caso de discrep√¢ncia entre os estados do mundo.  Mas se a diferen√ßa entre o cliente e o servidor for superior a um segundo, √© mais barato executar uma reconex√£o completa com o servidor. <br><br><h2>  Redu√ß√£o do tempo de atraso </h2><br>  O diagrama acima mostra que no jogo existem dois buffers no esquema de transfer√™ncia de dados: <br><br><ul><li>  buffer de entrada no servidor; </li><li>  um buffer de estados mundiais no cliente. </li></ul><br>  O objetivo desses buffers √© o mesmo - para compensar os saltos de rede (tremula√ß√£o).  O fato √© que a transmiss√£o de pacotes pela rede √© desigual.  E como o mecanismo de rede opera com uma frequ√™ncia fixa de 30 HZ, os dados devem ser fornecidos ao mecanismo na mesma frequ√™ncia.  N√£o temos a oportunidade de "esperar" alguns ms at√© que o pr√≥ximo pacote chegue ao destinat√°rio.  Usamos buffers para dados de entrada e estados mundiais, a fim de ter uma margem de tempo para compensa√ß√£o de tremula√ß√£o.  Tamb√©m usamos o buffer gamestate para interpola√ß√£o se um dos pacotes for perdido. <br><br>  No in√≠cio do jogo, o cliente inicia a sincroniza√ß√£o com o servidor somente depois de receber v√°rios estados mundiais do servidor e o buffer do estado do jogo est√° cheio.  Normalmente, o tamanho desse buffer √© de 3 ticks (100 ms). <br><br>  Ao mesmo tempo, quando o cliente sincroniza com o servidor, ele "executa" antes do hor√°rio do servidor pelo valor do buffer de entrada no servidor.  I.e.  o pr√≥prio cliente controla a dist√¢ncia do servidor.  O tamanho inicial do buffer de entrada tamb√©m √© igual a 3 ticks (100 ms). <br><br>  Inicialmente, implementamos o tamanho desses buffers como constantes.  I.e.  independentemente de o jitter realmente existir na rede ou n√£o, houve um atraso fixo de 200 ms (tamanho do buffer de entrada + tamanho do buffer do estado do jogo) para atualizar os dados.  Se adicionarmos a isso o ping m√©dio estimado em dispositivos m√≥veis em torno de 200 ms, o atraso real entre o uso da entrada no cliente e a confirma√ß√£o do aplicativo no servidor foi de 400 ms! <br><br>  Isso n√£o nos convinha. <br><br>  O fato √© que alguns sistemas s√£o executados apenas no servidor - como, por exemplo, o c√°lculo do HP do player.  Com esse atraso, o jogador atira e somente ap√≥s 400 ms v√™ como ele mata o oponente.  Se isso acontecesse em movimento, geralmente o jogador conseguia correr atr√°s da parede ou se esconder e j√° estava morrendo l√°.  Os testes da equipe mostraram que esse atraso interrompe completamente a jogabilidade. <br><br>  A solu√ß√£o para esse problema foi a implementa√ß√£o de tamanhos din√¢micos de buffers de entrada e gamestates: <br><ul><li>  para um buffer de gamestate, o cliente sempre conhece o conte√∫do atual do buffer.  No momento do c√°lculo do pr√≥ximo tick, o cliente verifica quantos estados j√° est√£o no buffer; </li><li>  para o buffer de entrada - o servidor, al√©m do estado do jogo, come√ßou a enviar ao cliente o valor do preenchimento atual do buffer de entrada para um cliente espec√≠fico.  O cliente, por sua vez, analisa esses dois valores. </li></ul><br>  O algoritmo de redimensionamento do buffer de gamestate √© aproximadamente o seguinte: <br><br><ol><li>  O cliente considera o valor m√©dio do tamanho do buffer durante um per√≠odo de tempo e varia√ß√£o. </li><li>  Se a varia√ß√£o estiver dentro dos limites normais (ou seja, durante um determinado per√≠odo de tempo, n√£o houve grandes saltos no preenchimento e na leitura do buffer), o cliente verificar√° o valor do tamanho m√©dio do buffer para esse per√≠odo de tempo. </li><li>  Se o preenchimento m√©dio do buffer for maior que a condi√ß√£o do limite superior (ou seja, o buffer ser√° preenchido mais do que o necess√°rio), o cliente "reduzir√°" o tamanho do buffer executando uma escala de simula√ß√£o adicional. </li><li>  Se o preenchimento m√©dio do buffer for menor que a condi√ß√£o do limite inferior (ou seja, o buffer n√£o ter√° tempo para preencher antes que o cliente comece a l√™-lo) - nesse caso, o cliente "aumentar√°" o tamanho do buffer ignorando um tique da simula√ß√£o. </li><li>  No caso em que a varia√ß√£o estava acima do normal, n√£o podemos confiar nesses dados, porque  os surtos de rede por um determinado per√≠odo foram muito grandes.  Em seguida, o cliente descarta todos os dados atuais e come√ßa a coletar estat√≠sticas novamente. </li></ol><br><h2>  Compensa√ß√£o de atraso do servidor </h2><br>  Devido ao fato de o cliente receber atualiza√ß√µes mundiais do servidor com um atraso (atraso), o jogador v√™ o mundo um pouco diferente do que existe no servidor.  O jogador se v√™ no presente e no resto do mundo - no passado.  No servidor, o mundo inteiro existe ao mesmo tempo. <br><br><img src="https://habrastorage.org/webt/jo/ca/5d/joca5d_dhigvw1i9gjlpcd-tgqa.png"><br>  Por esse motivo, a situa√ß√£o √© que o jogador atira localmente em um alvo localizado no servidor em outro local. <br><br>  Para compensar o atraso, usamos o tempo de retrocesso no servidor.  O algoritmo de opera√ß√£o √© aproximadamente o seguinte: <br><br><ol><li>  O cliente com cada entrada envia adicionalmente ao servidor o tempo de verifica√ß√£o em que ele v√™ o resto do mundo. </li><li>  O servidor valida esse hor√°rio: √© a diferen√ßa entre o hor√°rio atual e o hor√°rio vis√≠vel do mundo do cliente no intervalo de confian√ßa. </li><li>  Se o tempo for v√°lido, o servidor deixa o jogador no hor√°rio atual e o resto do mundo volta ao estado que o jogador viu e calcula o resultado do arremesso. </li><li>  Se um jogador acertar, o dano ser√° causado no hor√°rio atual do servidor. </li></ol><br>  O tempo de rebobinagem em um servidor funciona da seguinte maneira: a hist√≥ria do mundo (no ECS) e a hist√≥ria da f√≠sica (suportada pelo mecanismo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F√≠sica Vol√°til</a> ) s√£o armazenadas no norte.  No momento em que o arremesso foi calculado, os dados do jogador s√£o retirados do estado atual do mundo e os demais jogadores do hist√≥rico. <br><br><div class="spoiler">  <b class="spoiler_title">O c√≥digo para o sistema de valida√ß√£o de tiro √© mais ou menos assim:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shotPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Shot) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shot = shotPair.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooter = gs.WorldState[shotPair.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooterTransform = shooter.Transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weaponStats = gs.WorldState.WeaponStats[shot.WeaponId]; <span class="hljs-comment"><span class="hljs-comment">// DeltaTime shouldn't exceed physics history size var shootDeltaTime = (int) (gs.Time - shot.ShotPlayerWorldTime); if (shootDeltaTime &gt; PhysicsWorld.HistoryLength) { continue; } // Get the world at the time of shooting. var oldState = _immutableHistory.Get(shot.ShotPlayerWorldTime); var potentialTarget = oldState.WorldState[shot.Target.Id]; var hitTargetId = _singleShotValidator.ValidateTargetAvailabilityInLine(oldState, potentialTarget, shooter, shootDeltaTime, weaponStats.ShotDistance, shooter.Transform.Angle.GetDirection()); if (hitTargetId != 0) { gs.WorldState.CreateEntity().AddDamage(gs.WorldState[hitTargetId], shooter, weaponStats.ShotDamage); } } }</span></span></code> </pre> <br></div></div><br>  Uma desvantagem significativa na abordagem √© que confiamos no cliente nos dados sobre o hor√°rio do tick que ele v√™.  Potencialmente, um jogador pode obter uma vantagem aumentando artificialmente o ping.  Porque  quanto mais ping um jogador tem, mais ele dispara no passado. <br><br><h2>  Alguns problemas que encontramos </h2><br>  Durante a implementa√ß√£o desse mecanismo de rede, encontramos muitos problemas, alguns dos quais merecem um artigo separado, mas aqui abordarei apenas alguns deles. <br><br><h4>  Simula√ß√£o do mundo inteiro em um sistema de previs√£o e c√≥pia </h4><br>  Inicialmente, todos os sistemas em nosso ECS tinham apenas um m√©todo: void Execute (GameState gs).  Nesse m√©todo, os componentes relacionados a todos os jogadores eram geralmente processados. <br><br><div class="spoiler">  <b class="spoiler_title">Um exemplo de um sistema de movimento na implementa√ß√£o inicial:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[movementPair.Key]; transform.Position += movementPair.Value.Velocity * GameState.TickDuration; } } }</code> </pre> <br></div></div><br>  Por√©m, no sistema local de previs√£o de jogadores, precisamos apenas processar os componentes relacionados a um jogador espec√≠fico.  Inicialmente, implementamos isso usando copy. <br><br>  O processo de previs√£o foi o seguinte: <br><br><ol><li>  Uma c√≥pia do estado do jogo foi criada. </li><li>  Uma c√≥pia foi fornecida √† entrada do ECS. </li><li>  Houve uma simula√ß√£o do mundo inteiro no ECS. </li><li>  Todos os dados relacionados ao player local foram copiados do gamestate rec√©m-recebido. </li></ol><br><div class="spoiler">  <b class="spoiler_title">O m√©todo de previs√£o ficou assim:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _tempGameState.Copy(state); _ecsExecutor.Execute(_tempGameState, input); _playerEntitiesCopier.Copy(_tempGameState, newState); }</code> </pre> <br></div></div><br>  Havia dois problemas nessa implementa√ß√£o: <br><br><ol><li>  Porque  usamos classes, n√£o estruturas - a c√≥pia √© uma opera√ß√£o bastante cara para n√≥s (aproximadamente 0,1-0,15 ms no iPhone 5S). </li><li>  A simula√ß√£o de todo o mundo tamb√©m leva muito tempo (cerca de 1,5 a 2 ms no iPhone 5S). </li></ol><br>  Se levarmos em conta que, durante o processo de coordena√ß√£o, √© necess√°rio recalcular de 5 a 15 estados mundiais em um quadro, ent√£o, com essa implementa√ß√£o, tudo ficou terrivelmente lento. <br><br>  A solu√ß√£o foi bastante simples: aprender a simular o mundo em partes, ou seja, simular apenas um jogador espec√≠fico.  Reescrevemos todos os sistemas para que voc√™ possa transferir o ID do jogador e simular apenas ele. <br><br><div class="spoiler">  <b class="spoiler_title">Um exemplo de um sistema de movimento ap√≥s uma altera√ß√£o:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { Move(gs.WorldState.Transform[movementPair.Key], movementPair.Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[playerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Move(gs.WorldState.Transform[playerId], movement); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform, Movement movement</span></span></span><span class="hljs-function">)</span></span> { transform.Position += movement.Velocity * GameState.TickDuration; } }</code> </pre> <br></div></div><br>  Ap√≥s as altera√ß√µes, conseguimos livrar-nos de c√≥pias desnecess√°rias no sistema de previs√£o e reduzir a carga no sistema correspondente. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _ecsExecutor.Execute(newState, input, playerId); }</code> </pre> <br></div></div><br><h4>  Criando e excluindo entidades em um sistema de previs√£o </h4><br>  Em nosso sistema, a correspond√™ncia de entidades no servidor e no cliente ocorre por um identificador inteiro (id).  Para todas as entidades, usamos numera√ß√£o de ponta a ponta de identificadores, cada nova entidade possui o valor id = oldID + 1. <br><br>  Essa abordagem √© muito conveniente de implementar, mas tem uma desvantagem significativa: a ordem de cria√ß√£o de novas entidades no cliente e no servidor pode ser diferente e, como resultado, os identificadores das entidades ser√£o diferentes. <br><br>  Esse problema se manifestou quando implementamos um sistema para prever as tacadas dos jogadores.  Cada tiro com a gente √© uma entidade separada com o componente tiro.  Para cada cliente, o ID das entidades de captura no sistema de previs√£o era seq√ºencial.  Mas se, no mesmo momento, outro jogador disparou, no servidor o ID de todos os disparos diferia do cliente. <br><br>  As fotos no servidor foram criadas em uma ordem diferente: <br><br><img src="https://habrastorage.org/webt/gl/dg/fy/gldgfykw7m30fuwspkra-xytgqe.png"><br><br>  Para tiros, contornamos essa limita√ß√£o, com base nos recursos de jogabilidade do jogo.  Tiros s√£o entidades de vida r√°pida que s√£o destru√≠das no sistema uma fra√ß√£o de segundo ap√≥s a cria√ß√£o.  No cliente, destacamos um intervalo separado de IDs que n√£o se cruzam com os IDs do servidor e n√£o levam mais em considera√ß√£o as capturas no sistema de coordena√ß√£o.  I.e.  as tacadas dos jogadores locais s√£o sempre sorteadas no jogo apenas de acordo com o sistema de previs√£o e n√£o levam em considera√ß√£o os dados do servidor. <br><br>  Com essa abordagem, o jogador n√£o v√™ artefatos na tela (exclus√£o, recria√ß√£o, retrocessos de tiros) e as discrep√¢ncias com o servidor s√£o pequenas e n√£o afetam a jogabilidade como um todo. <br><br>  Este m√©todo permitiu resolver o problema com disparos, mas n√£o o problema inteiro de criar entidades no cliente como um todo.  Ainda estamos trabalhando em m√©todos poss√≠veis para resolver a compara√ß√£o de objetos criados no cliente e no servidor. <br><br>  Deve-se notar tamb√©m que esse problema diz respeito apenas √† cria√ß√£o de novas entidades (com novos IDs).  A adi√ß√£o e remo√ß√£o de componentes em entidades j√° criadas √© realizada sem problemas: os componentes n√£o possuem identificadores e cada entidade pode ter apenas um componente de um tipo espec√≠fico.  Portanto, geralmente criamos entidades no servidor e, nos sistemas de previs√£o, apenas adicionamos / removemos componentes. <br><br>  Concluindo, quero dizer que a tarefa de implementar o multiplayer n√£o √© a mais f√°cil e a mais r√°pida, mas h√° muitas informa√ß√µes sobre como fazer isso. <br><br><h2>  O que ler </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Multijogador em jogos r√°pidos</a> - tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Multijogador em ritmo acelerado (parte I): Introdu√ß√£o</a> (na minha opini√£o, este √© o melhor artigo sobre Habr√© sobre intera√ß√£o em rede em jogos). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura de jogo e</a> c√≥digo de rede do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GDC Vault Overwatch</a> - uma palestra com o GDC 17, sobre ECS e c√≥digo de rede no Overwatch (infelizmente, o acesso √© pago). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GDC Vault: 8 quadros em 16ms: redes reversas em Mortal Kombat e Injustice 2</a> - como isso √© feito em jogos de luta. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rede multiplayer de origem</a> - Como o multiplayer funciona no Counter Strike. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gaffer on Games</a> geralmente √© sobre c√≥digo de rede em jogos. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UDP nos motores de jogo</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GDC Vault: I Shot you first networking</a> - como o multiplayer funciona em Halo: Reach. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415959/">https://habr.com/ru/post/pt415959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415947/index.html">Sistema de compensa√ß√£o de erro de instala√ß√£o de fibra √≥ptica durante o processamento por radia√ß√£o laser durante a rota√ß√£o</a></li>
<li><a href="../pt415949/index.html">Minera√ß√£o alta: a √∫ltima op√ß√£o para proteger o blockchain PoW de um "ataque de 51%"</a></li>
<li><a href="../pt415951/index.html">Mitap Sberbank e IBM no HyperLedger Fabric</a></li>
<li><a href="../pt415953/index.html">Como a empresa sangrenta vence o c√≥digo-fonte aberto: a batalha pelo BPMS</a></li>
<li><a href="../pt415957/index.html">Precisamos de mais mochilas: Bobby XL da XD Design</a></li>
<li><a href="../pt415961/index.html">Armazenamento distribu√≠do russo. Como funciona</a></li>
<li><a href="../pt415963/index.html">Naive Bayes, ou como a matem√°tica permite filtrar spam</a></li>
<li><a href="../pt415965/index.html">O que ler em julho: 19 novos livros para profissionais digitais</a></li>
<li><a href="../pt415967/index.html">SolidFire - Armazenamento para aqueles ** que odeiam armazenamento</a></li>
<li><a href="../pt415969/index.html">HyperX Pulsefire Surge RGB - um assassino natural</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>