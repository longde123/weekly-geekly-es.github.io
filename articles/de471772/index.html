<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏿 🤴🏻 📿 Tools zum Starten und Entwickeln von Java-Anwendungen, Kompilieren und Ausführen auf der JVM 🛋️ 🧝 👩🏾‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist kein Geheimnis, dass Java derzeit eine der beliebtesten Programmiersprachen der Welt ist. Das offizielle Erscheinungsdatum für Java ist der 23....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tools zum Starten und Entwickeln von Java-Anwendungen, Kompilieren und Ausführen auf der JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471772/"><p> Es ist kein Geheimnis, dass Java derzeit eine der beliebtesten Programmiersprachen der Welt ist.  Das offizielle Erscheinungsdatum für Java ist der 23. Mai 1995. <br><br>  Dieser Artikel widmet sich den Grundlagen der Grundlagen: Er beschreibt die Grundfunktionen der Sprache, die für Anfänger als "Javisten" nützlich sind, und erfahrene Java-Entwickler können ihr Wissen auffrischen. <br><br>  <i>* Der Artikel wurde auf der Grundlage eines Berichts von Eugene Freiman - Java-Entwickler von IntexSoft erstellt.</i> <i><br></i>  <i>Der Artikel enthält Links zu externen Materialien</i> . <br></p><br><br><img src="https://habrastorage.org/webt/sv/ru/1d/svru1d4lpapnwhjllxc2dfw5do4.png"><br><a name="habracut"></a><br><h3>  1. JDK, JRE, JVM </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Development Kit</a> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java</a> Application Development Kit.  Es enthält <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Development Tools</a> und die Java Runtime Environment ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JRE</a> ). <br><br>  <b>Zu den Java-Entwicklungstools</b> gehören etwa 40 verschiedene Tools: Javac (Compiler), Java (Application Launcher), Javap (Disassembler für Java-Klassendateien), JDB (Java-Debugger) usw. <br><br>  Die JRE-Laufzeit ist ein Paket mit allem, was zum Ausführen eines kompilierten Java-Programms erforderlich ist.  Enthält die virtuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JVM-</a> Maschine und die <b>Java-Klassenbibliothek</b> . <br><br>  <b>JVM</b> ist ein Programm zur Ausführung von Bytecode.  Der erste Vorteil der JVM ist das Prinzip <i>„Einmal schreiben, überall ausführen“</i> .  Dies bedeutet, dass eine in Java geschriebene Anwendung auf allen Plattformen gleich funktioniert.  Dies ist ein großer Vorteil der JVM und von Java selbst. <br><br>  Vor dem Aufkommen von Java wurden viele Computerprogramme für bestimmte Computersysteme geschrieben, und die manuelle Speicherverwaltung wurde als effizienter und vorhersehbarer bevorzugt.  Seit der zweiten Hälfte der neunziger Jahre, nach dem Aufkommen von Java, ist die automatische Speicherverwaltung eine gängige Praxis geworden. <br><br>  Es gibt viele kommerzielle und Open Source-JVM-Implementierungen.  Eines der Ziele bei der Erstellung neuer JVMs ist die Steigerung der Leistung für eine bestimmte Plattform.  Jede JVM wird separat für die Plattform geschrieben, während es möglich ist, sie so zu schreiben, dass sie auf einer bestimmten Plattform schneller funktioniert.  Die häufigste JVM-Implementierung ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenJDK</a> JVM-Hotspot.  Es gibt auch Implementierungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBM J9</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excelsior JET</a> . <br><br><h3>  2. JVM-Code-Ausführung </h3><br>  Gemäß <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Java SE-Spezifikation</a> müssen Sie drei Schritte ausführen, damit Code in der JVM ausgeführt wird: <br><br><ul><li>  Laden des Bytecodes und Instanziieren der Klassenklasse <br>  Grob gesagt muss die Klasse geladen werden, um in die JVM zu gelangen.  Hierfür gibt es separate Loader-Klassen, auf die wir etwas später zurückkommen werden. </li><li>  Verknüpfen oder Verknüpfen <br>  Nach dem Laden der Klasse beginnt der Verknüpfungsprozess, bei dem der Bytecode analysiert und überprüft wird.  Der Verknüpfungsprozess erfolgt wiederum in drei Schritten: <br><br>  - Überprüfung oder Überprüfung des Bytecodes: Die Richtigkeit der Anweisungen, die Möglichkeit eines Stapelüberlaufs in diesem Abschnitt des Codes und die Kompatibilität der Variablentypen werden überprüft.  Die Prüfung erfolgt einmal für jede Klasse. <br>  - Vorbereitung oder Vorbereitung: In diesem Stadium wird gemäß der Spezifikation Speicher für statische Felder zugewiesen und ihre Initialisierung erfolgt; <br>  - Auflösung oder Auflösung: Auflösung symbolischer Links (wenn wir im Bytecode Dateien mit der Erweiterung .class öffnen, sehen wir numerische Werte anstelle von symbolischen Links). </li><li>  Initialisieren des resultierenden Klassenobjekts <br>  In der letzten Phase wird die von uns erstellte Klasse initialisiert und von der JVM ausgeführt. </li></ul><br><h3>  3. Klassenlader und ihre Hierarchie </h3><br>  Zurück zu Klassenladern, dies sind spezielle Klassen, die Teil der JVM sind.  Sie laden Klassen in den Speicher und stellen sie zur Ausführung zur Verfügung.  Loader arbeiten mit allen Klassen: sowohl mit unseren als auch mit denen, die direkt für Java benötigt werden. <br><br>  Stellen Sie sich die Situation vor: Wir haben unsere Bewerbung geschrieben, und zusätzlich zu den Standardklassen gibt es unsere Klassen, und es gibt viele von ihnen.  Wie wird die JVM damit arbeiten?  Java implementiert das verzögerte Laden von Klassen, dh das verzögerte Laden.  Dies bedeutet, dass das Laden der Klassen erst ausgeführt wird, wenn in der Anwendung kein Aufruf der Klasse erfolgt. <br><br><h4>  Hierarchie der Klassenlader </h4><br><br><img src="https://habrastorage.org/webt/r3/em/cw/r3emcwi3knisqdoex6tgrwpgafs.png"><br><br>  Der First Class Loader ist der <b>Bootstrap Classloader</b> .  Es ist in C ++ geschrieben.  Dies ist der <i>Basislader</i> , der alle <i>Systemklassen</i> aus dem Archiv <i>rt.jar lädt</i> .  Gleichzeitig gibt es einen kleinen Unterschied zwischen dem Laden von Klassen aus <i>rt.jar</i> und unseren Klassen: Wenn die JVM Klassen aus <i>rt.jar</i> lädt, werden <i>seitdem</i> nicht alle Überprüfungsschritte ausgeführt, die beim Laden einer anderen Klassendatei ausgeführt werden  Der JVM ist zunächst bekannt, dass alle diese Klassen bereits validiert sind.  Daher sollten Sie keine Ihrer Dateien in dieses Archiv aufnehmen. <br><br>  Der nächste Bootloader ist der <b>Extension Classloader.</b>  Es lädt Erweiterungsklassen aus dem Ordner <i>jre / lib / ext</i> .  Angenommen, Sie möchten, dass eine Klasse bei jedem Start des Java-Computers geladen wird.  Dazu können Sie die Quellklassendatei in diesen Ordner kopieren und sie wird automatisch geladen. <br><br>  Ein weiterer Bootloader ist der <b>System Classloader</b> .  Es lädt die Klassen aus dem Klassenpfad, den wir beim Start der Anwendung angegeben haben. <br><br>  Das Laden von Klassen erfolgt in einer Hierarchie: <br><br><ul><li>  Zunächst fordern wir eine Suche im System Class Loader-Cache an (der System Loader-Cache enthält Klassen, die bereits von ihm geladen wurden). </li><li>  Wenn die Klasse nicht im Cache des Systemladeprogramms gefunden wurde, sehen wir uns den Klassenladeprogramm für die Cache-Erweiterung an. </li><li>  Wenn die Klasse nicht im Erweiterungslader-Cache gefunden wird, wird die Klasse vom Bootstrap-Lader angefordert. </li></ul><br>  Wenn die Klasse nicht im Bootstrap-Cache gefunden wird, wird versucht, diese Klasse zu laden.  Wenn Bootstrap die Klasse nicht laden konnte, delegiert es das Laden der Klasse an den Erweiterungslader.  Wenn zu diesem Zeitpunkt die Klasse geladen wird, verbleibt sie im Cache des Extension-Klassenladeprogramms, und das Laden der Klasse ist abgeschlossen. <br><br><h3>  4. Struktur der Klassendatei und Startvorgang </h3><br>  Wir gehen direkt zur Struktur der Klassendateien über. <br><br>  Eine in Java geschriebene Klasse wird mit der Erweiterung .class in eine einzelne Datei kompiliert.  Wenn unsere Java-Datei mehrere Klassen enthält, kann eine Java-Datei mit der Erweiterung .class - Bytecode-Dateien dieser Klassen in mehrere Dateien kompiliert werden. <br><br>  Alle Zahlen, Zeichenfolgen, Zeiger auf Klassen, Felder und Methoden werden im <i>Konstantenpool</i> gespeichert - dem <i>Meta-Space-</i> Speicherbereich.  Die Klassenbeschreibung wird an derselben Stelle gespeichert und enthält den Namen, die Modifikatoren, die Superklasse, die Superschnittstellen, Felder, Methoden und Attribute.  Attribute können wiederum zusätzliche Informationen enthalten. <br><br>  Also beim Laden von Klassen: <br><br><ul><li>  Lesen der Klassendatei, d. h. Formatvalidierung </li><li>  Die Klassendarstellung wird im konstanten Pool (Metaraum) erstellt. </li><li>  Superklassen und Superschnittstellen werden geladen;  Wenn sie nicht geladen sind, wird die Klasse selbst nicht geladen </li></ul><br><h3>  5. Bytecode-Ausführung auf der JVM </h3><br>  Um Bytecode auszuführen, kann die JVM ihn zunächst <i>interpretieren</i> .  Die Interpretation ist ein ziemlich langsamer Prozess.  Während des Interpretationsprozesses „läuft“ der Interpreter Zeile für Zeile durch die Klassendatei und übersetzt sie in Befehle, die für die JVM verständlich sind. <br><br>  Die JVM kann es auch <i>senden</i> , d.h.  Kompilieren Sie in Maschinencode, der direkt auf der CPU ausgeführt wird. <br><br>  Befehle, die häufig ausgeführt werden, werden nicht interpretiert, sondern sofort gesendet. <br><br><h3>  6. Zusammenstellung </h3><br>  <b>Ein Compiler</b> ist ein Programm, das die Quellteile von Programmen, die in einer höheren Programmiersprache geschrieben sind, in ein Maschinensprachenprogramm konvertiert, das für einen Computer „verständlich“ ist. <br><br>  Compiler sind unterteilt in: <br><br><ul><li>  <i>Nicht optimieren</i> </li><li>  <i>Einfache Optimierung</i> (Hotspot-Client): Arbeiten Sie schnell, generieren Sie jedoch nicht optimalen Code </li><li>  <i>Komplexe Optimierung</i> (Hotspot-Server): Führen Sie komplexe Optimierungstransformationen durch, bevor Sie Bytecode generieren </li></ul><br><br>  Compiler können auch nach Kompilierungszeit klassifiziert werden: <br><br><ul><li>  <i>Dynamische Compiler</i> <br>  Sie arbeiten gleichzeitig mit dem Programm, was sich auf die Leistung auswirkt.  Es ist wichtig, dass diese Compiler mit Code ausgeführt werden, der häufig ausgeführt wird.  Während der Ausführung des Programms weiß die JVM, welcher Code am häufigsten ausgeführt wird, und um ihn nicht ständig zu interpretieren, übersetzt die virtuelle Maschine ihn sofort in Befehle, die bereits direkt auf dem Prozessor ausgeführt werden. </li><li>  <i>Statische Compiler</i> <br>  Länger kompilieren, aber den optimalen Code für die Ausführung generieren.  Von den Profis: Sie benötigen während der Programmausführung keine Ressourcen, jede Methode wird mithilfe von Optimierungen kompiliert. </li></ul><br><h3>  7. Organisation des Speichers in Java </h3><br>  <b>Ein Stack</b> ist ein Speicherbereich in Java, der nach dem LIFO-Schema " <i>Last In - Fisrt Out</i> " oder " <i>Last In, First</i> <i>Out</i> " arbeitet. <br><br><img src="https://habrastorage.org/webt/iv/u-/aw/ivu-awjajuj-fiwyzv6kzgsp9cq.png"><br><br>  Es wird benötigt, um Methoden zu speichern.  Variablen auf dem Stapel sind vorhanden, solange die Methode ausgeführt wird, mit der sie erstellt wurden. <br><br>  Wenn eine Methode in Java aufgerufen wird, wird ein Frame oder Speicherbereich auf dem Stapel erstellt und die Methode wird oben platziert.  Wenn eine Methode die Ausführung abgeschlossen hat, wird sie aus dem Speicher entfernt, wodurch Speicher für die folgenden Methoden frei wird.  Wenn der Stapelspeicher voll ist, <i>löst</i> Java eine Ausnahme von <i>java.lang.StackOverFlowError aus</i> .  Dies kann beispielsweise passieren, wenn wir eine rekursive Funktion haben, die sich selbst aufruft und nicht genügend Speicher auf dem Stapel vorhanden ist. <br><br>  Hauptmerkmale des Stapels: <br><br><ul><li>  Der Stapel wird gefüllt und freigegeben, wenn neue Methoden aufgerufen und abgeschlossen werden. </li><li>  Der Zugriff auf diesen Speicherbereich ist schneller als der Heap. </li><li>  Die Stapelgröße wird vom Betriebssystem bestimmt. </li><li>  Es ist threadsicher, da jeder Stapel einen eigenen Stapel hat. </li></ul><br>  Ein weiterer Speicherbereich in Java ist <b>Heap</b> oder <b>Heap</b> .  Es wird zum Speichern von Objekten und Klassen verwendet.  Auf dem Heap werden immer neue Objekte erstellt und Verweise darauf auf dem Stapel gespeichert.  Alle Objekte auf dem Heap haben globalen Zugriff, dh sie können von überall in der Anwendung aus aufgerufen werden. <br><br>  Der Haufen ist in mehrere kleinere Teile unterteilt, die als Generationen bezeichnet werden: <br><br><ul><li>  <i>Junge Generation</i> - der Bereich, in dem sich kürzlich erstellte Objekte befinden </li><li>  <i>Alte (feste) Generation</i> - der Bereich, in dem „langlebige“ Objekte aufbewahrt werden </li><li>  Vor Java 8 gab es einen weiteren Bereich - die <i>permanente Generierung</i> -, der Metainformationen zu Klassen, Methoden und statischen Variablen enthält.  Nach dem Aufkommen von Java 8 wurde beschlossen, diese Informationen separat außerhalb des Heaps zu speichern, und zwar im Meta-Bereich </li></ul><br><br><img src="https://habrastorage.org/webt/po/zg/f5/pozgf5m8ortucbcb_fr10p76xji.png"><br><br>  Warum die ständige Generation verlassen?  Dies ist zunächst auf einen Fehler zurückzuführen, der mit dem Überlauf des Bereichs verbunden war: Da Perm eine konstante Größe hatte und nicht dynamisch erweitert werden konnte, wurde früher oder später der Speicher leer, ein Fehler wurde ausgelöst und die Anwendung stürzte ab. <br><br>  Der Meta-Space hat eine dynamische Größe und kann zur Laufzeit auf JVM-Speichergrößen erweitert werden. <br><br>  Wichtige Heap-Funktionen: <br><br><ul><li>  Wenn dieser Speicherbereich voll ist, <i>löst</i> Java <i>java.lang.OutOfMemoryError aus</i> </li><li>  Der Heap-Zugriff ist langsamer als der Stack-Zugriff </li><li>  Garbage Collector sammelt nicht verwendete Objekte </li><li>  Ein Heap ist im Gegensatz zu einem Stapel nicht threadsicher, da jeder Thread darauf zugreifen kann </li></ul><br><br>  Betrachten Sie anhand der obigen Informationen anhand eines einfachen Beispiels, wie die Speicherverwaltung durchgeführt wird: <br><br><pre><code class="coffeescript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">[] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> = 23; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> = "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jon</span></span></span><span class="hljs-class">"; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class">); } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pid</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructors</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getters</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setters</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><br>  Wir haben eine App-Klasse, in der die einzige Hauptmethode besteht aus: <br><br>  - primitive <b>ID-</b> Variable vom Typ <b>int</b> mit dem Wert <b>23</b> <br>  - <b>pName</b> Referenzvariable vom Typ <b>String</b> mit dem Wert <b>Jon</b> <br>  - Referenzvariable <b>p vom</b> Typ <b>Person</b> <br><br><img src="https://habrastorage.org/webt/ks/kr/yi/kskryittdimovhicuavhnx4z7se.png"><br><br>  Wie bereits erwähnt, wird beim Aufrufen einer Methode oben im Stapel ein Speicherbereich erstellt, in dem die für die Speicherung dieser Methode erforderlichen Daten gespeichert werden. <br>  In unserem Fall ist dies ein Verweis auf die <i>Personenklasse</i> : Das Objekt selbst wird auf dem Heap gespeichert, und der Link wird auf dem Stapel gespeichert.  Ein Link zur Zeichenfolge wird ebenfalls auf den Stapel verschoben, und die Zeichenfolge selbst wird auf dem Heap im Zeichenfolgenpool gespeichert.  Das Grundelement wird direkt auf dem Stapel gespeichert. <br><br>  Um den Konstruktor mit <i>Person (String)</i> -Parametern aus der <i>main ()</i> -Methode auf dem Stapel aufzurufen, wird zusätzlich zum vorherigen <i>main ()</i> -Aufruf ein separater Frame auf dem Stapel erstellt, in dem Folgendes gespeichert ist: <br><br>  - <b>this</b> - Link zum aktuellen Objekt <br>  - primitiver <b>ID-</b> Wert <br>  - die Referenzvariable <b>personName</b> , die auf eine Zeichenfolge im Zeichenfolgenpool verweist. <br><br>  Nachdem wir den Konstruktor aufgerufen haben, wird <i>setPersonName ()</i> aufgerufen. <i>Danach</i> wird erneut ein neuer Frame auf dem Stapel erstellt, in dem dieselben Daten gespeichert werden: Objektreferenz, <i>Zeilenreferenz</i> , Variablenwert. <br><br>  Wenn also die <i>Setter-</i> Methode ausgeführt wird, verschwindet der Rahmen, der Stapel wird gelöscht.  Als nächstes wird der Konstruktor ausgeführt, der für den Konstruktor erstellte Frame wird gelöscht. Danach beendet die <i>main ()</i> -Methode ihre Arbeit und wird ebenfalls vom Stapel entfernt. <br><br>  Wenn andere Methoden aufgerufen werden, werden für sie im Kontext dieser spezifischen Methoden auch neue Frames erstellt. <br><br><h3>  8. Müllsammler </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Garbage Collector</a> arbeitet am Heap - einem Programm, das auf der virtuellen Java-Maschine ausgeführt wird und Objekte entfernt, auf die nicht zugegriffen werden kann. <br><br>  Unterschiedliche JVMs können unterschiedliche Garbage Collection-Algorithmen haben, es gibt auch unterschiedliche Garbage Collectors. <br><br>  Wir werden über den einfachsten Collector <b>Serial GC</b> sprechen.  Wir fordern die <i>Speicherbereinigung</i> mit <i>System.gc () an</i> . <br><br><img src="https://habrastorage.org/webt/kh/pe/ku/khpekusa0miezejuxbdwkcc-mdc.png"><br><br>  Wie oben erwähnt, ist der Haufen in zwei Bereiche unterteilt: Neue Generation und Alte Generation. <br><br>  Die neue Generation (jüngere Generation) umfasst 3 Regionen: <i>Eden</i> , <i>Survivor 0</i> und <i>Survivor 1</i> . <br><br>  Die alte Generation umfasst die <i>Tenured-</i> Region. <br><br>  Was passiert, wenn wir ein Objekt in Java erstellen? <br><br>  Zunächst fällt das Objekt in <i>Eden</i> .  Wenn wir bereits viele Objekte erstellt haben und in <i>Eden</i> kein Platz mehr vorhanden ist, wird der Garbage Collector ausgelöst und Speicher freigegeben.  Dies ist die sogenannte <i>kleine Müllabfuhr</i> - beim ersten Durchgang wird der <i>Eden-</i> Bereich gesäubert und die „überlebenden“ Objekte in die <i>Survivor 0-</i> Region gebracht.  Damit ist die Region <i>Eden</i> vollständig befreit. <br><br>  Wenn der <i>Eden-</i> Bereich wieder voll ist, arbeitet der Garbage Collector mit dem <i>Eden-</i> Bereich und <i>Survivor 0</i> , der derzeit belegt ist.  Nach der Reinigung fallen die überlebenden Objekte in eine andere Region - <i>Überlebender 1</i> - und die anderen beiden bleiben sauber.  Bei der anschließenden Speicherbereinigung wird <i>Survivor 0</i> erneut als Zielregion ausgewählt.  Deshalb ist es wichtig, dass eine der <i>Überlebensregionen</i> immer leer ist. <br><br>  Die JVM überwacht Objekte, die ständig kopiert und von einer Region in eine andere verschoben werden.  Und um diesen Mechanismus zu optimieren, verschiebt der Garbage Collector nach einem bestimmten Schwellenwert solche Objekte in den <i>Tenured-</i> Bereich. <br><br>  Wenn in <i>Tenured</i> nicht genügend Platz für neue Objekte vorhanden ist, gibt es eine vollständige Speicherbereinigung - <b>Mark-Sweep-Compact</b> . <br><br><img src="https://habrastorage.org/webt/yt/a1/j1/yta1j1gobagrvcbehbifdtnq5ia.png"><br><br>  Während dieses Mechanismus wird bestimmt, welche Objekte nicht mehr verwendet werden, der Bereich wird von diesen Objekten gelöscht und der <i>Tenured-</i> Speicherbereich <i>wird</i> defragmentiert, d.h.  nacheinander mit den notwendigen Objekten gefüllt. <br><br><h4>  Fazit </h4><br>  In diesem Artikel haben wir die grundlegenden Tools der Java-Sprache untersucht: JVM, JRE, JDK, das Prinzip und die Phasen der Ausführung, Kompilierung, Speicherorganisation des JVM-Codes sowie das Prinzip des Garbage Collector. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471772/">https://habr.com/ru/post/de471772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471756/index.html">Wie der Server startet</a></li>
<li><a href="../de471758/index.html">Wie übersetze ich Text in eine andere Sprache?</a></li>
<li><a href="../de471760/index.html">Edward Snowden: Das Schlachtfeld - Verschlüsselung</a></li>
<li><a href="../de471766/index.html">Kotlin / Java-Fehlerbehandlung: Wie geht das richtig?</a></li>
<li><a href="../de471770/index.html">Lernen Sie Big Data Tools kennen: Spark- und Zeppelin-Notebook-Unterstützung in IntelliJ IDEA</a></li>
<li><a href="../de471774/index.html">Android Camera2 API aus der Teekanne, Teil 2, schreibt ein Video</a></li>
<li><a href="../de471776/index.html">Laravel: Erklären Sie die Grundkonzepte. Zweiter Teil: Üben</a></li>
<li><a href="../de471778/index.html">Breaking Micosoft Lunix bei HackQuest 2019</a></li>
<li><a href="../de471792/index.html">Woher kam der Zauberer von "Ordinary Miracle"?</a></li>
<li><a href="../de471794/index.html">Die Ära der Flachdeckenmikrofone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>