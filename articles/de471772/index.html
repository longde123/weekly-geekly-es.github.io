<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèø ü§¥üèª üìø Tools zum Starten und Entwickeln von Java-Anwendungen, Kompilieren und Ausf√ºhren auf der JVM üõãÔ∏è üßù üë©üèæ‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist kein Geheimnis, dass Java derzeit eine der beliebtesten Programmiersprachen der Welt ist. Das offizielle Erscheinungsdatum f√ºr Java ist der 23....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tools zum Starten und Entwickeln von Java-Anwendungen, Kompilieren und Ausf√ºhren auf der JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471772/"><p> Es ist kein Geheimnis, dass Java derzeit eine der beliebtesten Programmiersprachen der Welt ist.  Das offizielle Erscheinungsdatum f√ºr Java ist der 23. Mai 1995. <br><br>  Dieser Artikel widmet sich den Grundlagen der Grundlagen: Er beschreibt die Grundfunktionen der Sprache, die f√ºr Anf√§nger als "Javisten" n√ºtzlich sind, und erfahrene Java-Entwickler k√∂nnen ihr Wissen auffrischen. <br><br>  <i>* Der Artikel wurde auf der Grundlage eines Berichts von Eugene Freiman - Java-Entwickler von IntexSoft erstellt.</i> <i><br></i>  <i>Der Artikel enth√§lt Links zu externen Materialien</i> . <br></p><br><br><img src="https://habrastorage.org/webt/sv/ru/1d/svru1d4lpapnwhjllxc2dfw5do4.png"><br><a name="habracut"></a><br><h3>  1. JDK, JRE, JVM </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Development Kit</a> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java</a> Application Development Kit.  Es enth√§lt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Development Tools</a> und die Java Runtime Environment ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JRE</a> ). <br><br>  <b>Zu den Java-Entwicklungstools</b> geh√∂ren etwa 40 verschiedene Tools: Javac (Compiler), Java (Application Launcher), Javap (Disassembler f√ºr Java-Klassendateien), JDB (Java-Debugger) usw. <br><br>  Die JRE-Laufzeit ist ein Paket mit allem, was zum Ausf√ºhren eines kompilierten Java-Programms erforderlich ist.  Enth√§lt die virtuelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JVM-</a> Maschine und die <b>Java-Klassenbibliothek</b> . <br><br>  <b>JVM</b> ist ein Programm zur Ausf√ºhrung von Bytecode.  Der erste Vorteil der JVM ist das Prinzip <i>‚ÄûEinmal schreiben, √ºberall ausf√ºhren‚Äú</i> .  Dies bedeutet, dass eine in Java geschriebene Anwendung auf allen Plattformen gleich funktioniert.  Dies ist ein gro√üer Vorteil der JVM und von Java selbst. <br><br>  Vor dem Aufkommen von Java wurden viele Computerprogramme f√ºr bestimmte Computersysteme geschrieben, und die manuelle Speicherverwaltung wurde als effizienter und vorhersehbarer bevorzugt.  Seit der zweiten H√§lfte der neunziger Jahre, nach dem Aufkommen von Java, ist die automatische Speicherverwaltung eine g√§ngige Praxis geworden. <br><br>  Es gibt viele kommerzielle und Open Source-JVM-Implementierungen.  Eines der Ziele bei der Erstellung neuer JVMs ist die Steigerung der Leistung f√ºr eine bestimmte Plattform.  Jede JVM wird separat f√ºr die Plattform geschrieben, w√§hrend es m√∂glich ist, sie so zu schreiben, dass sie auf einer bestimmten Plattform schneller funktioniert.  Die h√§ufigste JVM-Implementierung ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenJDK</a> JVM-Hotspot.  Es gibt auch Implementierungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IBM J9</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Excelsior JET</a> . <br><br><h3>  2. JVM-Code-Ausf√ºhrung </h3><br>  Gem√§√ü <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Java SE-Spezifikation</a> m√ºssen Sie drei Schritte ausf√ºhren, damit Code in der JVM ausgef√ºhrt wird: <br><br><ul><li>  Laden des Bytecodes und Instanziieren der Klassenklasse <br>  Grob gesagt muss die Klasse geladen werden, um in die JVM zu gelangen.  Hierf√ºr gibt es separate Loader-Klassen, auf die wir etwas sp√§ter zur√ºckkommen werden. </li><li>  Verkn√ºpfen oder Verkn√ºpfen <br>  Nach dem Laden der Klasse beginnt der Verkn√ºpfungsprozess, bei dem der Bytecode analysiert und √ºberpr√ºft wird.  Der Verkn√ºpfungsprozess erfolgt wiederum in drei Schritten: <br><br>  - √úberpr√ºfung oder √úberpr√ºfung des Bytecodes: Die Richtigkeit der Anweisungen, die M√∂glichkeit eines Stapel√ºberlaufs in diesem Abschnitt des Codes und die Kompatibilit√§t der Variablentypen werden √ºberpr√ºft.  Die Pr√ºfung erfolgt einmal f√ºr jede Klasse. <br>  - Vorbereitung oder Vorbereitung: In diesem Stadium wird gem√§√ü der Spezifikation Speicher f√ºr statische Felder zugewiesen und ihre Initialisierung erfolgt; <br>  - Aufl√∂sung oder Aufl√∂sung: Aufl√∂sung symbolischer Links (wenn wir im Bytecode Dateien mit der Erweiterung .class √∂ffnen, sehen wir numerische Werte anstelle von symbolischen Links). </li><li>  Initialisieren des resultierenden Klassenobjekts <br>  In der letzten Phase wird die von uns erstellte Klasse initialisiert und von der JVM ausgef√ºhrt. </li></ul><br><h3>  3. Klassenlader und ihre Hierarchie </h3><br>  Zur√ºck zu Klassenladern, dies sind spezielle Klassen, die Teil der JVM sind.  Sie laden Klassen in den Speicher und stellen sie zur Ausf√ºhrung zur Verf√ºgung.  Loader arbeiten mit allen Klassen: sowohl mit unseren als auch mit denen, die direkt f√ºr Java ben√∂tigt werden. <br><br>  Stellen Sie sich die Situation vor: Wir haben unsere Bewerbung geschrieben, und zus√§tzlich zu den Standardklassen gibt es unsere Klassen, und es gibt viele von ihnen.  Wie wird die JVM damit arbeiten?  Java implementiert das verz√∂gerte Laden von Klassen, dh das verz√∂gerte Laden.  Dies bedeutet, dass das Laden der Klassen erst ausgef√ºhrt wird, wenn in der Anwendung kein Aufruf der Klasse erfolgt. <br><br><h4>  Hierarchie der Klassenlader </h4><br><br><img src="https://habrastorage.org/webt/r3/em/cw/r3emcwi3knisqdoex6tgrwpgafs.png"><br><br>  Der First Class Loader ist der <b>Bootstrap Classloader</b> .  Es ist in C ++ geschrieben.  Dies ist der <i>Basislader</i> , der alle <i>Systemklassen</i> aus dem Archiv <i>rt.jar l√§dt</i> .  Gleichzeitig gibt es einen kleinen Unterschied zwischen dem Laden von Klassen aus <i>rt.jar</i> und unseren Klassen: Wenn die JVM Klassen aus <i>rt.jar</i> l√§dt, werden <i>seitdem</i> nicht alle √úberpr√ºfungsschritte ausgef√ºhrt, die beim Laden einer anderen Klassendatei ausgef√ºhrt werden  Der JVM ist zun√§chst bekannt, dass alle diese Klassen bereits validiert sind.  Daher sollten Sie keine Ihrer Dateien in dieses Archiv aufnehmen. <br><br>  Der n√§chste Bootloader ist der <b>Extension Classloader.</b>  Es l√§dt Erweiterungsklassen aus dem Ordner <i>jre / lib / ext</i> .  Angenommen, Sie m√∂chten, dass eine Klasse bei jedem Start des Java-Computers geladen wird.  Dazu k√∂nnen Sie die Quellklassendatei in diesen Ordner kopieren und sie wird automatisch geladen. <br><br>  Ein weiterer Bootloader ist der <b>System Classloader</b> .  Es l√§dt die Klassen aus dem Klassenpfad, den wir beim Start der Anwendung angegeben haben. <br><br>  Das Laden von Klassen erfolgt in einer Hierarchie: <br><br><ul><li>  Zun√§chst fordern wir eine Suche im System Class Loader-Cache an (der System Loader-Cache enth√§lt Klassen, die bereits von ihm geladen wurden). </li><li>  Wenn die Klasse nicht im Cache des Systemladeprogramms gefunden wurde, sehen wir uns den Klassenladeprogramm f√ºr die Cache-Erweiterung an. </li><li>  Wenn die Klasse nicht im Erweiterungslader-Cache gefunden wird, wird die Klasse vom Bootstrap-Lader angefordert. </li></ul><br>  Wenn die Klasse nicht im Bootstrap-Cache gefunden wird, wird versucht, diese Klasse zu laden.  Wenn Bootstrap die Klasse nicht laden konnte, delegiert es das Laden der Klasse an den Erweiterungslader.  Wenn zu diesem Zeitpunkt die Klasse geladen wird, verbleibt sie im Cache des Extension-Klassenladeprogramms, und das Laden der Klasse ist abgeschlossen. <br><br><h3>  4. Struktur der Klassendatei und Startvorgang </h3><br>  Wir gehen direkt zur Struktur der Klassendateien √ºber. <br><br>  Eine in Java geschriebene Klasse wird mit der Erweiterung .class in eine einzelne Datei kompiliert.  Wenn unsere Java-Datei mehrere Klassen enth√§lt, kann eine Java-Datei mit der Erweiterung .class - Bytecode-Dateien dieser Klassen in mehrere Dateien kompiliert werden. <br><br>  Alle Zahlen, Zeichenfolgen, Zeiger auf Klassen, Felder und Methoden werden im <i>Konstantenpool</i> gespeichert - dem <i>Meta-Space-</i> Speicherbereich.  Die Klassenbeschreibung wird an derselben Stelle gespeichert und enth√§lt den Namen, die Modifikatoren, die Superklasse, die Superschnittstellen, Felder, Methoden und Attribute.  Attribute k√∂nnen wiederum zus√§tzliche Informationen enthalten. <br><br>  Also beim Laden von Klassen: <br><br><ul><li>  Lesen der Klassendatei, d. h. Formatvalidierung </li><li>  Die Klassendarstellung wird im konstanten Pool (Metaraum) erstellt. </li><li>  Superklassen und Superschnittstellen werden geladen;  Wenn sie nicht geladen sind, wird die Klasse selbst nicht geladen </li></ul><br><h3>  5. Bytecode-Ausf√ºhrung auf der JVM </h3><br>  Um Bytecode auszuf√ºhren, kann die JVM ihn zun√§chst <i>interpretieren</i> .  Die Interpretation ist ein ziemlich langsamer Prozess.  W√§hrend des Interpretationsprozesses ‚Äûl√§uft‚Äú der Interpreter Zeile f√ºr Zeile durch die Klassendatei und √ºbersetzt sie in Befehle, die f√ºr die JVM verst√§ndlich sind. <br><br>  Die JVM kann es auch <i>senden</i> , d.h.  Kompilieren Sie in Maschinencode, der direkt auf der CPU ausgef√ºhrt wird. <br><br>  Befehle, die h√§ufig ausgef√ºhrt werden, werden nicht interpretiert, sondern sofort gesendet. <br><br><h3>  6. Zusammenstellung </h3><br>  <b>Ein Compiler</b> ist ein Programm, das die Quellteile von Programmen, die in einer h√∂heren Programmiersprache geschrieben sind, in ein Maschinensprachenprogramm konvertiert, das f√ºr einen Computer ‚Äûverst√§ndlich‚Äú ist. <br><br>  Compiler sind unterteilt in: <br><br><ul><li>  <i>Nicht optimieren</i> </li><li>  <i>Einfache Optimierung</i> (Hotspot-Client): Arbeiten Sie schnell, generieren Sie jedoch nicht optimalen Code </li><li>  <i>Komplexe Optimierung</i> (Hotspot-Server): F√ºhren Sie komplexe Optimierungstransformationen durch, bevor Sie Bytecode generieren </li></ul><br><br>  Compiler k√∂nnen auch nach Kompilierungszeit klassifiziert werden: <br><br><ul><li>  <i>Dynamische Compiler</i> <br>  Sie arbeiten gleichzeitig mit dem Programm, was sich auf die Leistung auswirkt.  Es ist wichtig, dass diese Compiler mit Code ausgef√ºhrt werden, der h√§ufig ausgef√ºhrt wird.  W√§hrend der Ausf√ºhrung des Programms wei√ü die JVM, welcher Code am h√§ufigsten ausgef√ºhrt wird, und um ihn nicht st√§ndig zu interpretieren, √ºbersetzt die virtuelle Maschine ihn sofort in Befehle, die bereits direkt auf dem Prozessor ausgef√ºhrt werden. </li><li>  <i>Statische Compiler</i> <br>  L√§nger kompilieren, aber den optimalen Code f√ºr die Ausf√ºhrung generieren.  Von den Profis: Sie ben√∂tigen w√§hrend der Programmausf√ºhrung keine Ressourcen, jede Methode wird mithilfe von Optimierungen kompiliert. </li></ul><br><h3>  7. Organisation des Speichers in Java </h3><br>  <b>Ein Stack</b> ist ein Speicherbereich in Java, der nach dem LIFO-Schema " <i>Last In - Fisrt Out</i> " oder " <i>Last In, First</i> <i>Out</i> " arbeitet. <br><br><img src="https://habrastorage.org/webt/iv/u-/aw/ivu-awjajuj-fiwyzv6kzgsp9cq.png"><br><br>  Es wird ben√∂tigt, um Methoden zu speichern.  Variablen auf dem Stapel sind vorhanden, solange die Methode ausgef√ºhrt wird, mit der sie erstellt wurden. <br><br>  Wenn eine Methode in Java aufgerufen wird, wird ein Frame oder Speicherbereich auf dem Stapel erstellt und die Methode wird oben platziert.  Wenn eine Methode die Ausf√ºhrung abgeschlossen hat, wird sie aus dem Speicher entfernt, wodurch Speicher f√ºr die folgenden Methoden frei wird.  Wenn der Stapelspeicher voll ist, <i>l√∂st</i> Java eine Ausnahme von <i>java.lang.StackOverFlowError aus</i> .  Dies kann beispielsweise passieren, wenn wir eine rekursive Funktion haben, die sich selbst aufruft und nicht gen√ºgend Speicher auf dem Stapel vorhanden ist. <br><br>  Hauptmerkmale des Stapels: <br><br><ul><li>  Der Stapel wird gef√ºllt und freigegeben, wenn neue Methoden aufgerufen und abgeschlossen werden. </li><li>  Der Zugriff auf diesen Speicherbereich ist schneller als der Heap. </li><li>  Die Stapelgr√∂√üe wird vom Betriebssystem bestimmt. </li><li>  Es ist threadsicher, da jeder Stapel einen eigenen Stapel hat. </li></ul><br>  Ein weiterer Speicherbereich in Java ist <b>Heap</b> oder <b>Heap</b> .  Es wird zum Speichern von Objekten und Klassen verwendet.  Auf dem Heap werden immer neue Objekte erstellt und Verweise darauf auf dem Stapel gespeichert.  Alle Objekte auf dem Heap haben globalen Zugriff, dh sie k√∂nnen von √ºberall in der Anwendung aus aufgerufen werden. <br><br>  Der Haufen ist in mehrere kleinere Teile unterteilt, die als Generationen bezeichnet werden: <br><br><ul><li>  <i>Junge Generation</i> - der Bereich, in dem sich k√ºrzlich erstellte Objekte befinden </li><li>  <i>Alte (feste) Generation</i> - der Bereich, in dem ‚Äûlanglebige‚Äú Objekte aufbewahrt werden </li><li>  Vor Java 8 gab es einen weiteren Bereich - die <i>permanente Generierung</i> -, der Metainformationen zu Klassen, Methoden und statischen Variablen enth√§lt.  Nach dem Aufkommen von Java 8 wurde beschlossen, diese Informationen separat au√üerhalb des Heaps zu speichern, und zwar im Meta-Bereich </li></ul><br><br><img src="https://habrastorage.org/webt/po/zg/f5/pozgf5m8ortucbcb_fr10p76xji.png"><br><br>  Warum die st√§ndige Generation verlassen?  Dies ist zun√§chst auf einen Fehler zur√ºckzuf√ºhren, der mit dem √úberlauf des Bereichs verbunden war: Da Perm eine konstante Gr√∂√üe hatte und nicht dynamisch erweitert werden konnte, wurde fr√ºher oder sp√§ter der Speicher leer, ein Fehler wurde ausgel√∂st und die Anwendung st√ºrzte ab. <br><br>  Der Meta-Space hat eine dynamische Gr√∂√üe und kann zur Laufzeit auf JVM-Speichergr√∂√üen erweitert werden. <br><br>  Wichtige Heap-Funktionen: <br><br><ul><li>  Wenn dieser Speicherbereich voll ist, <i>l√∂st</i> Java <i>java.lang.OutOfMemoryError aus</i> </li><li>  Der Heap-Zugriff ist langsamer als der Stack-Zugriff </li><li>  Garbage Collector sammelt nicht verwendete Objekte </li><li>  Ein Heap ist im Gegensatz zu einem Stapel nicht threadsicher, da jeder Thread darauf zugreifen kann </li></ul><br><br>  Betrachten Sie anhand der obigen Informationen anhand eines einfachen Beispiels, wie die Speicherverwaltung durchgef√ºhrt wird: <br><br><pre><code class="coffeescript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">[] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> = 23; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class"> = "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Jon</span></span></span><span class="hljs-class">"; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pName</span></span></span><span class="hljs-class">); } } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pid</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructors</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getters</span></span></span><span class="hljs-class">/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setters</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><br>  Wir haben eine App-Klasse, in der die einzige Hauptmethode besteht aus: <br><br>  - primitive <b>ID-</b> Variable vom Typ <b>int</b> mit dem Wert <b>23</b> <br>  - <b>pName</b> Referenzvariable vom Typ <b>String</b> mit dem Wert <b>Jon</b> <br>  - Referenzvariable <b>p vom</b> Typ <b>Person</b> <br><br><img src="https://habrastorage.org/webt/ks/kr/yi/kskryittdimovhicuavhnx4z7se.png"><br><br>  Wie bereits erw√§hnt, wird beim Aufrufen einer Methode oben im Stapel ein Speicherbereich erstellt, in dem die f√ºr die Speicherung dieser Methode erforderlichen Daten gespeichert werden. <br>  In unserem Fall ist dies ein Verweis auf die <i>Personenklasse</i> : Das Objekt selbst wird auf dem Heap gespeichert, und der Link wird auf dem Stapel gespeichert.  Ein Link zur Zeichenfolge wird ebenfalls auf den Stapel verschoben, und die Zeichenfolge selbst wird auf dem Heap im Zeichenfolgenpool gespeichert.  Das Grundelement wird direkt auf dem Stapel gespeichert. <br><br>  Um den Konstruktor mit <i>Person (String)</i> -Parametern aus der <i>main ()</i> -Methode auf dem Stapel aufzurufen, wird zus√§tzlich zum vorherigen <i>main ()</i> -Aufruf ein separater Frame auf dem Stapel erstellt, in dem Folgendes gespeichert ist: <br><br>  - <b>this</b> - Link zum aktuellen Objekt <br>  - primitiver <b>ID-</b> Wert <br>  - die Referenzvariable <b>personName</b> , die auf eine Zeichenfolge im Zeichenfolgenpool verweist. <br><br>  Nachdem wir den Konstruktor aufgerufen haben, wird <i>setPersonName ()</i> aufgerufen. <i>Danach</i> wird erneut ein neuer Frame auf dem Stapel erstellt, in dem dieselben Daten gespeichert werden: Objektreferenz, <i>Zeilenreferenz</i> , Variablenwert. <br><br>  Wenn also die <i>Setter-</i> Methode ausgef√ºhrt wird, verschwindet der Rahmen, der Stapel wird gel√∂scht.  Als n√§chstes wird der Konstruktor ausgef√ºhrt, der f√ºr den Konstruktor erstellte Frame wird gel√∂scht. Danach beendet die <i>main ()</i> -Methode ihre Arbeit und wird ebenfalls vom Stapel entfernt. <br><br>  Wenn andere Methoden aufgerufen werden, werden f√ºr sie im Kontext dieser spezifischen Methoden auch neue Frames erstellt. <br><br><h3>  8. M√ºllsammler </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Garbage Collector</a> arbeitet am Heap - einem Programm, das auf der virtuellen Java-Maschine ausgef√ºhrt wird und Objekte entfernt, auf die nicht zugegriffen werden kann. <br><br>  Unterschiedliche JVMs k√∂nnen unterschiedliche Garbage Collection-Algorithmen haben, es gibt auch unterschiedliche Garbage Collectors. <br><br>  Wir werden √ºber den einfachsten Collector <b>Serial GC</b> sprechen.  Wir fordern die <i>Speicherbereinigung</i> mit <i>System.gc () an</i> . <br><br><img src="https://habrastorage.org/webt/kh/pe/ku/khpekusa0miezejuxbdwkcc-mdc.png"><br><br>  Wie oben erw√§hnt, ist der Haufen in zwei Bereiche unterteilt: Neue Generation und Alte Generation. <br><br>  Die neue Generation (j√ºngere Generation) umfasst 3 Regionen: <i>Eden</i> , <i>Survivor 0</i> und <i>Survivor 1</i> . <br><br>  Die alte Generation umfasst die <i>Tenured-</i> Region. <br><br>  Was passiert, wenn wir ein Objekt in Java erstellen? <br><br>  Zun√§chst f√§llt das Objekt in <i>Eden</i> .  Wenn wir bereits viele Objekte erstellt haben und in <i>Eden</i> kein Platz mehr vorhanden ist, wird der Garbage Collector ausgel√∂st und Speicher freigegeben.  Dies ist die sogenannte <i>kleine M√ºllabfuhr</i> - beim ersten Durchgang wird der <i>Eden-</i> Bereich ges√§ubert und die ‚Äû√ºberlebenden‚Äú Objekte in die <i>Survivor 0-</i> Region gebracht.  Damit ist die Region <i>Eden</i> vollst√§ndig befreit. <br><br>  Wenn der <i>Eden-</i> Bereich wieder voll ist, arbeitet der Garbage Collector mit dem <i>Eden-</i> Bereich und <i>Survivor 0</i> , der derzeit belegt ist.  Nach der Reinigung fallen die √ºberlebenden Objekte in eine andere Region - <i>√úberlebender 1</i> - und die anderen beiden bleiben sauber.  Bei der anschlie√üenden Speicherbereinigung wird <i>Survivor 0</i> erneut als Zielregion ausgew√§hlt.  Deshalb ist es wichtig, dass eine der <i>√úberlebensregionen</i> immer leer ist. <br><br>  Die JVM √ºberwacht Objekte, die st√§ndig kopiert und von einer Region in eine andere verschoben werden.  Und um diesen Mechanismus zu optimieren, verschiebt der Garbage Collector nach einem bestimmten Schwellenwert solche Objekte in den <i>Tenured-</i> Bereich. <br><br>  Wenn in <i>Tenured</i> nicht gen√ºgend Platz f√ºr neue Objekte vorhanden ist, gibt es eine vollst√§ndige Speicherbereinigung - <b>Mark-Sweep-Compact</b> . <br><br><img src="https://habrastorage.org/webt/yt/a1/j1/yta1j1gobagrvcbehbifdtnq5ia.png"><br><br>  W√§hrend dieses Mechanismus wird bestimmt, welche Objekte nicht mehr verwendet werden, der Bereich wird von diesen Objekten gel√∂scht und der <i>Tenured-</i> Speicherbereich <i>wird</i> defragmentiert, d.h.  nacheinander mit den notwendigen Objekten gef√ºllt. <br><br><h4>  Fazit </h4><br>  In diesem Artikel haben wir die grundlegenden Tools der Java-Sprache untersucht: JVM, JRE, JDK, das Prinzip und die Phasen der Ausf√ºhrung, Kompilierung, Speicherorganisation des JVM-Codes sowie das Prinzip des Garbage Collector. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471772/">https://habr.com/ru/post/de471772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471756/index.html">Wie der Server startet</a></li>
<li><a href="../de471758/index.html">Wie √ºbersetze ich Text in eine andere Sprache?</a></li>
<li><a href="../de471760/index.html">Edward Snowden: Das Schlachtfeld - Verschl√ºsselung</a></li>
<li><a href="../de471766/index.html">Kotlin / Java-Fehlerbehandlung: Wie geht das richtig?</a></li>
<li><a href="../de471770/index.html">Lernen Sie Big Data Tools kennen: Spark- und Zeppelin-Notebook-Unterst√ºtzung in IntelliJ IDEA</a></li>
<li><a href="../de471774/index.html">Android Camera2 API aus der Teekanne, Teil 2, schreibt ein Video</a></li>
<li><a href="../de471776/index.html">Laravel: Erkl√§ren Sie die Grundkonzepte. Zweiter Teil: √úben</a></li>
<li><a href="../de471778/index.html">Breaking Micosoft Lunix bei HackQuest 2019</a></li>
<li><a href="../de471792/index.html">Woher kam der Zauberer von "Ordinary Miracle"?</a></li>
<li><a href="../de471794/index.html">Die √Ñra der Flachdeckenmikrofone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>