<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙄 🛌🏿 👨🏾‍🤝‍👨🏻 Bagaimana cara menulis unit test untuk para aktor? Pendekatan SObjectizer 😅 💆🏽 🆕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aktor menyederhanakan pemrograman multi-utas dengan menghindari keadaan yang dapat dibagikan bersama. Setiap aktor memiliki data sendiri yang tidak te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara menulis unit test untuk para aktor? Pendekatan SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435606/">  Aktor menyederhanakan pemrograman multi-utas dengan menghindari keadaan yang dapat dibagikan bersama.  Setiap aktor memiliki data sendiri yang tidak terlihat oleh siapa pun.  Aktor hanya berinteraksi melalui pesan asinkron.  Oleh karena itu, kengerian multithreading yang paling menakutkan dalam bentuk ras dan kebuntuan ketika menggunakan aktor tidak mengerikan (meskipun aktor memiliki masalah mereka, tetapi ini bukan tentang itu sekarang). <br><br>  Secara umum, menulis aplikasi multi-utas menggunakan aktor mudah dan menyenangkan.  Termasuk karena aktornya sendiri ditulis dengan mudah dan alami.  Anda bahkan bisa mengatakan bahwa menulis kode aktor adalah bagian termudah dari pekerjaan itu.  Tetapi ketika aktor ditulis, pertanyaan yang sangat bagus muncul: "Bagaimana cara memeriksa kebenaran dari pekerjaannya?" <br><br>  Pertanyaannya sangat bagus.  Kami secara teratur ditanya ketika kami berbicara tentang aktor pada umumnya dan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> pada khususnya.  Dan hingga saat ini, kami hanya dapat menjawab pertanyaan ini secara umum. <br><br>  Tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi 5.5.24 keluar</a> , di mana ada dukungan eksperimental untuk kemungkinan pengujian unit aktor.  Dan pada artikel ini kita akan mencoba untuk membicarakan tentang apa itu, bagaimana menggunakannya dan dengan apa yang telah diterapkan. <br><a name="habracut"></a><br><h1>  Seperti apa tes aktor? </h1><br>  Kami akan mempertimbangkan fitur baru SObjectizer pada beberapa contoh, meneruskan apa.  Kode sumber untuk contoh-contoh yang dibahas dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di repositori ini</a> . <br><br>  Sepanjang cerita, istilah "aktor" dan "agen" akan digunakan secara bergantian.  Mereka menunjuk hal yang sama, tetapi dalam SObjectizer istilah "agen" secara historis digunakan, oleh karena itu "agen" lebih lanjut akan digunakan lebih sering. <br><br><h2>  Contoh paling sederhana dengan Pinger dan Ponger </h2><br>  Contoh aktor Pinger dan Ponger mungkin adalah contoh paling umum untuk kerangka aktor.  Bisa dikatakan klasik.  Nah, jika demikian, maka mari kita mulai dengan klasik. <br><br>  Jadi, kami memiliki agen Pinger, yang pada awal kerjanya mengirim pesan Ping ke agen Ponger.  Dan agen Ponger mengirim kembali pesan Pong.  Ini adalah tampilannya dalam kode C ++: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br>  Tugas kami adalah menulis tes yang akan memverifikasi bahwa setelah mendaftarkan agen-agen ini dengan SObjectizer, Ponger akan menerima pesan Ping, dan Pinger akan menerima pesan Pong sebagai tanggapan. <br><br>  Oke  Kami menulis tes seperti itu menggunakan kerangka kerja unit-tes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">doctest</a> dan mendapatkan: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br>  Tampaknya mudah.  Mari kita lihat apa yang terjadi di sini. <br><br>  Pertama-tama, kami mengunduh deskripsi alat dukungan pengujian agen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br>  Semua alat ini dijelaskan di so_5 :: experimental :: testing namespace, tetapi agar tidak mengulangi nama yang panjang, kami memperkenalkan alias yang lebih pendek dan lebih nyaman: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br>  Berikut ini adalah uraian satu kasus uji (dan kami tidak perlu lebih banyak di sini). <br><br>  Di dalam test case, ada beberapa poin kunci. <br><br>  Pertama, ini adalah pembuatan dan peluncuran lingkungan uji khusus untuk SObjectizer: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br>  Tanpa lingkungan ini, "uji coba" untuk agen tidak dapat diselesaikan, tetapi kami akan membicarakannya nanti. <br><br>  Kelas testing_env_t sangat mirip dengan kelas wrap_env_t di SObjectizer.  Dengan cara yang sama, SObjectizer dimulai di konstruktor, dan berhenti di destruktor.  Jadi saat menulis tes, Anda tidak perlu memikirkan memulai dan menghentikan SObjectizer. <br><br>  Selanjutnya, kita perlu membuat dan mendaftarkan agen Pinger dan Ponger.  Dalam hal ini, kita perlu menggunakan agen ini dalam menentukan apa yang disebut.  "Uji skenario."  Karena itu, kami secara terpisah menyimpan pointer ke agen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  Dan kemudian kita mulai bekerja dengan "skenario pengujian". <br><br>  Kasing uji adalah bagian yang terdiri dari urutan langkah-langkah langsung yang harus diselesaikan dari awal hingga akhir.  Ungkapan "dari urutan langsung" berarti bahwa dalam SObjectizer-5.5.24 script langkah "bekerja" secara ketat berurutan, tanpa bercabang atau loop. <br><br>  Menulis tes untuk agen adalah definisi skrip uji yang perlu dijalankan.  Yaitu  semua langkah skenario pengujian harus bekerja, dari yang pertama hingga yang terakhir. <br><br>  Oleh karena itu, dalam kasus uji kami, kami menetapkan skenario dua langkah.  Langkah pertama memverifikasi bahwa agen Ponger akan menerima dan memproses pesan Ping: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br>  Langkah kedua memeriksa apakah agen Pinger menerima pesan Pong: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br>  Dua langkah ini cukup untuk uji kasus kami, oleh karena itu, setelah ditentukan, kami melanjutkan ke eksekusi skrip.  Kami menjalankan skrip dan memungkinkannya bekerja tidak lebih dari 100 ms: <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br>  Seratus milidetik harus lebih dari cukup bagi kedua agen untuk bertukar pesan (bahkan jika tes dijalankan di dalam mesin virtual yang sangat lambat, seperti yang terkadang terjadi pada Travis CI).  Nah, jika kita membuat kesalahan dalam menulis agen atau salah menggambarkan skrip pengujian, maka menunggu selesainya skrip yang salah selama lebih dari 100 ms tidak masuk akal. <br><br>  Jadi, setelah kembali dari run_for (), skrip kami dapat berhasil diselesaikan atau tidak.  Karena itu, kami cukup memeriksa hasil skrip: <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br>  Jika skrip tidak berhasil diselesaikan, maka ini akan menyebabkan kegagalan uji kasus kami. <br><br><h3>  Beberapa klarifikasi dan tambahan </h3><br>  Jika kita menjalankan kode ini di dalam SObjectizer normal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  kemudian, kemungkinan besar, agen Pinger dan Ponger akan mengatur untuk bertukar pesan dan menyelesaikan pekerjaan mereka sebelum kembali dari perkenalan_coop (keajaiban multithreading begitu).  Tetapi di dalam lingkungan pengujian, yang dibuat berkat testing_env_t, ini tidak terjadi, agen Pinger dan Ponger dengan sabar menunggu sampai kami menjalankan skrip pengujian kami.  Bagaimana ini bisa terjadi? <br><br>  Faktanya adalah bahwa di dalam lingkungan pengujian, agen tampak dalam keadaan beku.  Yaitu  setelah pendaftaran, mereka hadir di SObjectizer, tetapi mereka tidak dapat memproses pesan mereka.  Oleh karena itu, bahkan so_evt_start () tidak dipanggil untuk agen sebelum skrip uji dijalankan. <br><br>  Ketika kami menjalankan skrip uji menggunakan metode run_for (), skrip uji pertama mencairkan semua agen beku.  Dan kemudian skrip mulai menerima pemberitahuan dari SObjectizer tentang apa yang terjadi pada agen.  Misalnya, bahwa agen Ponger menerima pesan Ping dan bahwa agen Ponger memproses pesan tersebut, tetapi tidak menolaknya. <br><br>  Ketika pemberitahuan tersebut mulai datang ke skrip pengujian, skrip mencoba untuk "mencoba" mereka ke langkah pertama.  Jadi, kami memiliki pemberitahuan bahwa Ponger menerima dan memproses Ping - apakah ini menarik bagi kami atau tidak?  Ternyata itu menarik, karena deskripsi langkah itu mengatakan dengan tepat bahwa: ia bekerja ketika Ponger bereaksi terhadap Ping.  Apa yang kita lihat dalam kode: <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br>  Oke  Jadi langkah pertama berhasil, lanjutkan ke langkah berikutnya. <br><br>  Selanjutnya muncul pemberitahuan bahwa Agen Pinger bereaksi terhadap Pong.  Dan inilah yang Anda butuhkan untuk langkah kedua untuk bekerja: <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br>  Oke  Jadi langkah kedua berhasil, apakah kita memiliki sesuatu yang lain?  Tidak.  Ini berarti bahwa seluruh skrip pengujian selesai dan Anda dapat mengembalikan kontrol dari run_for (). <br><br>  Di sini, pada prinsipnya, cara kerja skrip uji.  Sebenarnya, semuanya agak lebih rumit, tetapi kita akan menyentuh aspek yang lebih kompleks ketika kita mempertimbangkan contoh yang lebih kompleks. <br><br><h2>  Contoh Filsuf Bersantap </h2><br>  Contoh yang lebih kompleks dari agen penguji dapat dilihat dalam menyelesaikan tugas terkenal "Makan filsuf."  Pada aktor, masalah ini dapat diselesaikan dengan beberapa cara.  Selanjutnya, kita akan mempertimbangkan solusi paling sepele: aktor dan filsuf diwakili dalam bentuk aktor, yang harus diperangi oleh para filsuf.  Setiap filsuf berpikir sejenak, lalu mencoba mengambil garpu di sebelah kiri.  Jika ini berhasil, ia mencoba mengambil garpu di sebelah kanan.  Jika ini berhasil, maka filsuf makan untuk beberapa waktu, setelah itu ia meletakkan garpu dan mulai berpikir.  Jika tidak mungkin untuk mengambil steker di sebelah kanan (mis., Itu diambil oleh filsuf lain), maka filsuf mengembalikan steker di sebelah kiri dan berpikir untuk beberapa waktu lagi.  Yaitu  ini bukan solusi yang baik dalam arti bahwa beberapa filsuf mungkin kelaparan terlalu lama.  Tapi kemudian itu sangat sederhana.  Dan memiliki ruang untuk menunjukkan kemampuan untuk menguji agen. <br><br>  Kode sumber dengan implementasi agen Fork dan Filsuf dapat ditemukan di <a href="">sini</a> , dalam artikel kami tidak akan mempertimbangkan mereka untuk menghemat ruang. <br><br><h3>  Tes untuk Fork </h3><br>  Tes pertama untuk agen dari Philosophers Makan adalah untuk agen Fork. <br><br>  Agen ini bekerja sesuai dengan skema sederhana.  Dia memiliki dua negara: Gratis dan Diambil.  Saat agen berada dalam status Bebas, ia merespons pesan Ambil.  Dalam hal ini, agen memasuki status Diambil dan merespons dengan pesan tanggapan Diambil. <br><br>  Ketika agen berada di negara bagian Diambil, itu menanggapi pesan Ambil berbeda: keadaan agen tidak berubah, dan Sibuk dikirim sebagai pesan respon.  Juga di status Diambil, agen merespons pesan Put: agen kembali ke status Bebas. <br><br>  Dalam status bebas, pesan Put diabaikan. <br><br>  Kami akan mencoba menguji yang ini dengan menggunakan test case berikut: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br>  Ada banyak kode, jadi kita akan mengatasinya di bagian-bagian, melewatkan bagian-bagian yang seharusnya sudah jelas. <br><br>  Hal pertama yang kita butuhkan di sini adalah mengganti agen Filsuf yang asli.  Agen Fork harus menerima pesan dari seseorang dan merespons seseorang.  Tetapi kita tidak dapat menggunakan filsuf asli dalam kasus uji ini, karena agen filsuf nyata memiliki logika perilaku sendiri, ia mengirim pesan sendiri dan kemerdekaan ini akan mengganggu kita di sini. <br><br>  Karena itu, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengejek</a> , mis.  alih-alih filsuf asli, kami akan memperkenalkan pengganti untuk itu: agen kosong yang tidak mengirim apa pun itu sendiri, tetapi hanya menerima pesan yang dikirim, tanpa proses yang bermanfaat.  Ini adalah filsuf semu yang diimplementasikan dalam kode: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br>  Selanjutnya, kami membuat kolaborasi dari agen Fork dan agen PseudoPhilospher dan mulai menentukan konten dari kasus pengujian kami. <br><br>  Langkah pertama skrip adalah memverifikasi bahwa Fork, yang berada dalam status Bebas (dan ini adalah kondisi awalnya), tidak menanggapi pesan Put.  Begini cara penulisan cek ini: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br>  Hal pertama yang menarik perhatian adalah dampak konstruksi. <br><br>  Dia dibutuhkan karena agen kami Fork tidak melakukan apa-apa sendiri, dia hanya bereaksi terhadap pesan yang masuk.  Karena itu, seseorang harus mengirim pesan kepada agen.  Tapi siapa <br><br>  Tetapi langkah skrip itu sendiri mengirimkan melalui dampak.  Bahkan, dampak adalah analog dari fungsi kirim yang biasa (dan formatnya sama). <br><br>  Nah, langkah skrip itu sendiri akan mengirim pesan melalui dampak.  Tetapi kapan dia akan melakukannya? <br><br>  Dan dia akan melakukannya ketika giliran datang kepadanya.  Yaitu  jika langkah dalam skrip adalah yang pertama, maka dampak akan dieksekusi segera setelah memasukkan run_for.  Jika langkah dalam skrip bukan yang pertama, maka dampak akan dieksekusi segera setelah langkah sebelumnya berhasil dan skrip akan melanjutkan untuk memproses langkah berikutnya. <br><br>  Hal kedua yang perlu kita diskusikan di sini adalah panggilan abaikan.  Fungsi helper ini mengatakan bahwa langkah tersebut dipicu ketika agen gagal memproses pesan.  Yaitu  dalam hal ini, agen Fork harus menolak untuk memproses pesan Put. <br><br>  Mari kita pertimbangkan satu langkah lagi dari skenario pengujian lebih terinci: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br>  Pertama, di sini kita melihat when_all bukan when.  Ini karena untuk memicu langkah, kita perlu memenuhi beberapa kondisi sekaligus.  Agen garpu perlu menangani Take.  Dan Filsuf perlu menangani tanggapan Diambil.  Karena itu, kami menulis when_all, bukan kapan.  Ngomong-ngomong, ada juga when_any, tetapi kita tidak akan bertemu dengannya dalam contoh-contoh yang dipertimbangkan hari ini. <br><br>  Kedua, kita juga perlu memeriksa fakta bahwa setelah Mengambil pemrosesan, agen Fork akan berada dalam status Taken.  Kami melakukan pemeriksaan sebagai berikut: pertama kami menunjukkan bahwa segera setelah agen Fork selesai memproses Take, nama negara saat ini harus disimpan menggunakan tag tag "fork".  Konstruksi ini hanya mempertahankan nama negara agen: <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br>  Dan kemudian, ketika skrip selesai dengan sukses, kami memeriksa nama yang disimpan ini: <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br>  Yaitu  kami meminta skrip: beri kami nama yang disimpan dengan tag garpu untuk langkah bernama take_when_free, lalu bandingkan nama dengan nilai yang diharapkan. <br><br>  Di sini, mungkin, adalah semua yang dapat dicatat dalam kasus uji untuk agen Fork.  Jika pembaca memiliki pertanyaan, maka tanyakan di komentar, kami akan menjawab dengan senang hati. <br><br><h3>  Tes Naskah yang Berhasil untuk Filsuf </h3><br>  Untuk agen Philosopher, kami hanya akan mempertimbangkan satu test case - untuk kasus ketika Philosopher dapat mengambil garpu dan makan. <br><br>  Test case ini akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br>  Cukup tebal, tapi sepele.  Pertama, periksa apakah Filsuf telah selesai berpikir dan sudah mulai menyiapkan makanan.  Lalu kami periksa apakah dia mencoba mengambil garpu kiri.  Selanjutnya, ia harus mencoba mengambil garpu yang tepat.  Maka dia harus makan dan menghentikan aktivitas ini.  Maka dia harus meletakkan kedua garpu diambil. <br><br>  Secara umum, semuanya sederhana.  Tetapi Anda harus fokus pada dua hal. <br><br>  Pertama, kelas testing_env_t, seperti prototipenya, envelop_env_t, memungkinkan Anda untuk menyesuaikan Lingkungan SObjectizer.  Kami akan menggunakan ini untuk mengaktifkan mekanisme pelacakan pengiriman pesan: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br>  Mekanisme ini memungkinkan Anda untuk "memvisualisasikan" proses pengiriman pesan, yang membantu dalam penyelidikan perilaku agen (kami sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membicarakan</a> hal ini secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih rinci</a> ). <br><br>  Kedua, agen Filsuf melakukan serangkaian tindakan tidak segera, tetapi setelah beberapa waktu.  Jadi, mulai bekerja, agen harus mengirim sendiri pesan StopThinking yang tertunda.  Jadi pesan ini harus sampai ke agen setelah beberapa milidetik.  Yang kami tunjukkan dengan menetapkan batasan yang diperlukan untuk langkah tertentu: <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br>  Yaitu  di sini kita mengatakan bahwa kita tidak tertarik pada reaksi apa pun dari agen Filsuf terhadap StopThinking, tetapi hanya itu yang terjadi tidak lebih awal dari 250 ms setelah dimulainya pemrosesan langkah ini. <br><br>  Pembatasan dari jenis not_before memberitahu skrip bahwa semua peristiwa yang terjadi sebelum batas waktu yang ditentukan berakhir harus diabaikan. <br><br>  Ada juga pembatasan bentuk not_after, ia bekerja sebaliknya: hanya peristiwa yang terjadi sampai batas waktu yang ditentukan telah kedaluwarsa yang diperhitungkan. <br><br>  Batasan not_before dan not_after dapat digabungkan, misalnya: <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br>  tetapi dalam kasus ini, SObjectizer tidak memeriksa konsistensi dari nilai yang diberikan. <br><br><h1>  Bagaimana Anda bisa menerapkan ini? </h1><br>  Saya ingin mengatakan beberapa patah kata tentang bagaimana semuanya bekerja.  Bagaimanapun, pada umumnya, kami dihadapkan pada satu pertanyaan ideologis besar: "Bagaimana cara menguji agen pada prinsipnya?"  dan satu pertanyaan yang lebih kecil, sudah teknis: "Bagaimana cara menerapkan ini?" <br><br>  Dan jika tentang ideologi pengujian itu mungkin untuk keluar dari pikiran Anda, maka tentang implementasi situasinya lebih rumit.  Itu perlu untuk menemukan solusi yang, pertama, tidak akan memerlukan perubahan radikal dari interior SObjectizer.  Dan, kedua, itu seharusnya menjadi solusi yang dapat diimplementasikan dalam waktu dekat dan, sangat diinginkan, dalam waktu singkat. <br><br>  Sebagai hasil dari proses sulit merokok bambu, solusinya ditemukan.  Untuk ini, diperlukan, pada kenyataannya, untuk membuat hanya satu inovasi kecil dalam perilaku reguler dari SObjectizer.  Dan dasar solusinya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mekanisme amplop untuk pesan, yang ditambahkan dalam versi 5.5.23 dan yang sudah kita bicarakan</a> . <br><br>  Di dalam lingkungan pengujian, setiap pesan yang dikirim terbungkus dalam amplop khusus.  Ketika sebuah amplop dengan pesan diberikan kepada agen untuk diproses (atau, sebaliknya, ditolak oleh agen), skenario pengujian menjadi sadar akan hal ini.  Berkat amplop, skrip uji tahu apa yang terjadi dan dapat menentukan saat-saat ketika skrip langkah "bekerja". <br><br>  Tetapi bagaimana membuat SObjectizer membungkus setiap pesan dalam amplop khusus? <br><br>  Itu pertanyaan yang menarik.  Dia memutuskan sebagai berikut: hal seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">event_queue_hook</a> ditemukan.  Ini adalah objek khusus dengan dua metode - on_bind dan on_unbind. <br><br>  Ketika agen terikat ke dispatcher tertentu, dispatcher mengeluarkan event_queue agen ke agen.  Melalui event_queue ini, permintaan untuk agen masuk ke antrian yang diperlukan dan tersedia untuk dispatcher untuk diproses.  Ketika agen berjalan di dalam SObjectizer, ia memiliki pointer ke event_queue.  Ketika agen dihapus dari SObjectizer, penunjuknya ke event_queue dibatalkan. <br><br>  Jadi, dimulai dengan versi 5.5.24, agen, setelah menerima event_queue, harus memanggil metode on_bind dari event_queue_hook.  Di mana agen harus meneruskan pointer yang diterima ke event_queue.  Dan event_queue_hook dapat mengembalikan pointer yang sama atau pointer lain sebagai respons.  Dan agen harus menggunakan nilai yang dikembalikan. <br><br>  Ketika agen dihapus dari SObjectizer, itu harus memanggil on_unbind pada event_queue_hook.  Di on_unbind, agen melewati nilai yang dikembalikan oleh metode on_bind. <br><br>  Seluruh dapur ini dijalankan di dalam SObjectizer dan pengguna tidak melihat hal ini.  Dan, pada prinsipnya, Anda mungkin tidak tahu tentang ini sama sekali.  Tapi lingkungan pengujian SObjectizer, testing_env_t yang sama, mengeksploitasi event_queue_hook persis.  Di dalam testing_env_t, implementasi khusus event_queue_hook dibuat.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi ini di on_bind membungkus setiap event_queue dalam objek proxy khusus. Dan sudah objek proxy ini menempatkan pesan yang dikirim ke agen dalam amplop khusus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi itu belum semuanya. Anda mungkin ingat bahwa dalam lingkungan pengujian, agen harus dibekukan. Ini juga diimplementasikan melalui objek proxy yang disebutkan. Saat skrip uji tidak berjalan, objek proxy menyimpan pesan yang dikirim ke agen di rumah. Tetapi ketika skrip dijalankan, objek proxy mentransfer semua pesan yang terakumulasi sebelumnya ke antrian pesan agen saat ini.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulannya, saya ingin mengatakan dua hal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama-tama, kami menerapkan pandangan kami tentang bagaimana agen dapat diuji dalam SObjectizer. Pendapat saya karena tidak ada banyak panutan yang baik di sekitar. Kami melihat ke arah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akka</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Pengujian</font></a><font style="vertical-align: inherit;"> . Tetapi Akka dan SObjectizer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terlalu berbeda</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk port pendekatan yang bekerja di Akka ke SObjectizer. Dan C ++ bukan Scala / Java, di mana beberapa hal yang berkaitan dengan introspeksi dapat dilakukan melalui refleksi. Jadi saya harus datang dengan pendekatan yang akan jatuh pada SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam versi 5.5.24, implementasi eksperimental yang pertama menjadi tersedia. Tentunya Anda bisa melakukan yang lebih baik. Tetapi bagaimana memahami apa yang akan berguna dan apa fantasi yang tidak berguna? Sayangnya, tidak ada apa-apa. Anda perlu mengambil dan mencoba, lihat apa yang terjadi dalam latihan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi kami membuat versi minimal yang dapat Anda ambil dan coba. Apa yang kami usulkan untuk dilakukan bagi semua orang: coba, bereksperimen, dan bagikan kesan Anda dengan kami. Apa yang kamu suka, apa yang tidak kamu sukai? Mungkin ada yang hilang? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, kata-kata yang diucapkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di awal 2017</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menjadi lebih relevan </font><font style="vertical-align: inherit;">:</font></font><br><blockquote> …       ,   ,   ,    .      -      —      .             .      . :  ,   . <br><br>    ,  ,   ,       —    ,           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, saran saya untuk mereka yang mencari kerangka aktor yang sudah jadi: perhatikan tidak hanya keaslian ide dan keindahan contoh. </font><font style="vertical-align: inherit;">Lihat juga segala macam hal tambahan yang akan membantu Anda mengetahui apa yang terjadi dalam aplikasi Anda: misalnya, cari tahu berapa banyak aktor yang ada di dalam sekarang, apa ukuran antrian mereka, jika pesan tidak mencapai penerima, lalu ke mana ia pergi ... Jika kerangka kerjanya tidak menyediakan sesuatu seperti itu, akan lebih mudah bagi Anda. </font><font style="vertical-align: inherit;">Jika tidak, maka Anda akan memiliki lebih banyak pekerjaan.</font></font><br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua hal di atas bahkan lebih penting dalam hal menguji aktor. </font><font style="vertical-align: inherit;">Karena itu, ketika memilih kerangka aktor untuk diri sendiri, perhatikan apa yang ada di dalamnya dan apa yang tidak. </font><font style="vertical-align: inherit;">Sebagai contoh, kita sudah memiliki alat untuk menyederhanakan pengujian :)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435606/">https://habr.com/ru/post/id435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435592/index.html">Azores: cadangan flora terakhir di tengah Samudra Atlantik</a></li>
<li><a href="../id435594/index.html">Grafik Rute untuk Apache Camel</a></li>
<li><a href="../id435600/index.html">Cara bermigrasi ke operator seluler lain dan tidak bangkrut (untuk pemilik iOS)</a></li>
<li><a href="../id435602/index.html">Persiapan Ujian Azure</a></li>
<li><a href="../id435604/index.html">BlaBlaCar menjadi apa yang tidak dimaksudkan untuk itu</a></li>
<li><a href="../id435608/index.html">Layar DIY</a></li>
<li><a href="../id435610/index.html">Telur paskah untuk ZX Spectrum - di album musik dan film</a></li>
<li><a href="../id435612/index.html">Percayai Codd atau fasilitas Anda?</a></li>
<li><a href="../id435614/index.html">Rust News # 4 (Desember 2018)</a></li>
<li><a href="../id435616/index.html">Bagaimana Peer Zoning menyederhanakan kehidupan kami dan membantu menyeimbangkan muatan EMC VPLEX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>