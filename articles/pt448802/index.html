<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öΩÔ∏è üìÇ üèáüèΩ Pensando em portais: criando portais no Unreal Engine 4 üßñüèª üë©üèæ‚Äç‚úàÔ∏è ‚õπüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, mostrarei como criar portais no Unreal Engine 4. N√£o encontrei nenhuma fonte que descreva esse sistema em detalhes (monitorando atrav√©s ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensando em portais: criando portais no Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448802/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif" alt="imagem"></div><br>  Neste artigo, mostrarei como criar portais no Unreal Engine 4. N√£o encontrei nenhuma fonte que descreva esse sistema em detalhes (monitorando atrav√©s de portais e passando por eles), por isso decidi escrever meus pr√≥prios. <br><br><h2>  O que √© um portal? </h2><br>  Vamos come√ßar com exemplos e explica√ß√µes sobre o que √© um portal.  A maneira mais f√°cil de descrever os portais como um caminho de passagem de um espa√ßo para outro.  Em alguns jogos populares, esse conceito √© usado para efeitos visuais e at√© para a mec√¢nica de jogo: <br><br><div class="spoiler">  <b class="spoiler_title">Exemplos de portal de jogos (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/611/020/f86/611020f86b634e1946a79f86ee8c4024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/7b9/813/77d7b9813811fc5b1748d8d29c7599ad.gif"></div><br>  <i>Antichamber (2013) e Portal (2007)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/671/ad1/527671ad1b23838f56c324d350bf2e1e.gif"></div><br>  <i>Presa, 2006</i> </div></div><br>  Dos tr√™s jogos, o mais famoso √© provavelmente o Portal, mas pessoalmente sempre admirei a Prey e era ela que eu queria copiar.  Uma vez tentei implementar minha pr√≥pria vers√£o no Unreal Engine 4, mas n√£o consegui, porque o mecanismo n√£o tinha funcionalidade.  No entanto, eu consegui realizar essas experi√™ncias: <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Seu navegador n√£o suporta v√≠deo HTML5. <source src="http://froyok.fr/vine_archive/videos/1318354931002269696.mp4" type="video/mp4"></video></div></div></div><br>  No entanto, somente em novas vers√µes do Unreal Engine eu finalmente consegui alcan√ßar o efeito desejado: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5lga4ppJiuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Portais - como eles funcionam? </h2><br>  Antes de prosseguir com os detalhes, vejamos a imagem geral de como os portais funcionam. <br><br>  De fato, um portal √© uma janela que n√£o sai, mas para outro local, ou seja, definimos localmente um ponto de vista espec√≠fico em rela√ß√£o ao objeto e replicamos esse ponto de vista em outro lugar.  Usando esse princ√≠pio, podemos conectar dois espa√ßos, mesmo que estejam muito distantes um do outro.  A janela se assemelha a uma m√°scara que nos permite descobrir onde e quando exibir outro espa√ßo em vez do original.  Como o ponto de partida da vis√£o √© replicado em outro lugar, isso nos d√° a ilus√£o de continuidade. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b3/d56/84b/6b3d5684bf30d66c8b60d551049f7a9b.png"></div><br>  Nesta imagem, o dispositivo de captura (SceneCapture no UE4) est√° localizado na frente do espa√ßo que corresponde ao espa√ßo visto do ponto de vista do jogador.  Tudo o que √© vis√≠vel ap√≥s a linha √© substitu√≠do pelo que a captura pode ver.  Como o dispositivo de captura pode estar localizado entre a porta e outros objetos, √© importante usar o chamado "plano de corte".  No caso do portal, queremos que o plano de recorte pr√≥ximo mascara os objetos vis√≠veis na frente do portal. <br><br>  Para resumir.  Precisamos de: <br><br><ul><li>  Localiza√ß√£o do Jogador </li><li>  Ponto de entrada do portal </li><li>  Ponto de Sa√≠da do Portal </li><li>  Dispositivo de recorte com plano de recorte </li></ul><br>  Como implementar isso no Unreal Engine? <br><br>  Eu constru√≠ meu sistema com base em duas classes principais gerenciadas pelo <b>PlayerController</b> e <b>Character</b> .  A classe <b>Portal</b> √© um verdadeiro ponto de entrada do portal, cujo ponto de visualiza√ß√£o / sa√≠da √© o ator de Destino.  H√° tamb√©m um <b>Portal Manager</b> , que √© gerado pelo PlayerController e atualizado pelo Character para gerenciar cada portal no n√≠vel e atualiz√°-los, al√©m de manipular o objeto SceneCapture (que √© comum a todos os portais). <br><br><blockquote>  Lembre-se de que o tutorial espera que voc√™ tenha acesso √†s classes Character e PlayerController a partir do c√≥digo.  No meu caso, eles s√£o chamados ExedreCharacter e ExedrePlayerController. </blockquote><br><h2>  Criando uma classe de ator do portal </h2><br>  Vamos come√ßar com o ator do portal, que ser√° usado para definir as "janelas" pelas quais veremos o n√≠vel.  A tarefa do ator √© fornecer informa√ß√µes sobre o jogador para calcular v√°rias posi√ß√µes e turnos.  Ele tamb√©m se empenhar√° em reconhecer se o jogador atravessa o portal e seu teletransporte. <br><br>  Antes de iniciar uma discuss√£o detalhada do ator, deixe-me explicar alguns conceitos que eu criei para gerenciar o sistema do portal: <br><br><ul><li>  Para uma recusa conveniente de c√°lculos, o portal possui um status ativo-inativo.  Este estado √© atualizado pelo Portal Manager. </li><li>  O portal possui lados dianteiro e traseiro determinados por sua posi√ß√£o e dire√ß√£o (vetor para frente). </li><li>  Para descobrir se o jogador atravessa o portal, ele armazena a posi√ß√£o anterior do jogador e a compara com a atual.  Se na medida anterior o jogador estava na frente do portal e na corrente - atr√°s dele, acreditamos que o jogador o atravessou.  O comportamento inverso √© ignorado. </li><li>  O portal possui um volume limitador, para n√£o realizar c√°lculos e verifica√ß√µes at√© que o player esteja nesse volume.  Exemplo: ignore o cruzamento se o jogador n√£o estiver realmente tocando o portal. </li><li>  A localiza√ß√£o do jogador √© calculada a partir da localiza√ß√£o da c√¢mera para garantir o comportamento correto quando o ponto de vista cruza o portal, mas n√£o o corpo do jogador. </li><li>  O portal recebe um destino de renderiza√ß√£o, que exibe um ponto de vista diferente em cada medida, caso a textura da pr√≥xima vez esteja incorreta e precise ser substitu√≠da. </li><li>  O portal armazena um link para outro ator chamado Target, para saber onde o outro espa√ßo deve ser contatado. </li></ul><br>  Usando essas regras, criei uma nova classe ExedrePortal herdada do AActor como ponto de partida.  Aqui est√° o seu t√≠tulo: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortal.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API AExedrePortal : public AActor { GENERATED_UCLASS_BODY() protected: virtual void BeginPlay() override; public: virtual void Tick(float DeltaTime) override; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Status of the Portal (being visualized by the player or not) UFUNCTION(BlueprintPure, Category="Exedre|Portal") bool IsActive(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetActive( bool NewActive ); //Render target to use to display the portal UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void ClearRTT(); UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category="Exedre|Portal") void SetRTT( UTexture* RenderTexture ); UFUNCTION(BlueprintNativeEvent, Category="Exedre|Portal") void ForceTick(); //Target of where the portal is looking UFUNCTION(BlueprintPure, Category="Exedre|Portal") AActor* GetTarget(); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void SetTarget( AActor* NewTarget ); //Helpers UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") bool IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ); UFUNCTION(BlueprintCallable, Category="Exedre|Portal") void TeleportActor( AActor* ActorToTeleport ); protected: UPROPERTY(BlueprintReadOnly) USceneComponent* PortalRootComponent; private: bool bIsActive; AActor* Target; //Used for Tracking movement of a point FVector LastPosition; bool LastInFront; };</span></span></span></span></code> </pre> <br>  Como voc√™ pode ver, existem muitos dos comportamentos descritos aqui.  Agora vamos ver como eles s√£o processados ‚Äã‚Äãno corpo (.cpp). <br><br><hr><br>  O designer aqui est√° preparando os componentes raiz.  Decidi criar dois componentes raiz, porque o ator do portal combinaria efeitos gr√°ficos e colis√µes / reconhecimento.  Ent√£o, eu precisava de uma maneira simples de determinar onde est√° o plano da janela / portal, sem a necessidade de recursos bluetooth ou outros truques.  PortalRootComponent ser√° a base para todos os c√°lculos relacionados ao portal. <br><br>  A raiz do portal √© configurada como din√¢mica, caso a classe Blueprint a anime (por exemplo, use uma anima√ß√£o de abrir / fechar). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Sets default values AExedrePortal::AExedrePortal(const FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = true; bIsActive = false; RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("RootComponent")); RootComponent-&gt;Mobility = EComponentMobility::Static; PortalRootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT("PortalRootComponent")); PortalRootComponent-&gt;SetupAttachment( GetRootComponent() ); PortalRootComponent-&gt;SetRelativeLocation( FVector(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;SetRelativeRotation( FRotator(0.0f, 0.0f, 0.0f) ); PortalRootComponent-&gt;Mobility = EComponentMobility::Movable; }</span></span></code> </pre> <br><hr><br>  Existem apenas fun√ß√µes Get e Set, e nada mais.  Gerenciaremos o estado da atividade de outro local. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsActive() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bIsActive; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetActive( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> NewActive ) { bIsActive = NewActive; }</code> </pre> <br><hr><br>  Eventos do Blueprint, n√£o estou fazendo nada na classe C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ClearRTT_Implementation() { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetRTT_Implementation( UTexture* RenderTexture ) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::ForceTick_Implementation() { }</code> </pre> <br><hr><br>  As fun√ß√µes Get e Set para o ator Target.  Tamb√©m n√£o h√° nada mais complicado nesta parte. <br><br><pre> <code class="cpp hljs">AActor* AExedrePortal::GetTarget() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Target; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::SetTarget( AActor* NewTarget ) { Target = NewTarget; }</code> </pre> <br><hr><br>  Com essa fun√ß√£o, podemos verificar facilmente se um ponto est√° na frente de um avi√£o e, no nosso caso, √© um portal.  A fun√ß√£o usa a estrutura FPlane do mecanismo UE4 para executar c√°lculos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointInFrontOfPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-comment"><span class="hljs-comment">//If &lt; 0 means we are behind the Plane //See : http://api.unrealengine.com/INT/API/Runtime/Core/Math/FPlane/PlaneDot/index.html return ( PortalDot &gt;= 0 ); }</span></span></code> </pre> <br><hr><br>  Esta fun√ß√£o verifica se o ponto cruzou o plano do portal.  √â aqui que usamos a posi√ß√£o antiga para descobrir como o ponto se comporta.  Essa fun√ß√£o √© comum para que possa funcionar com qualquer ator, mas no meu caso √© usada apenas com o player. <br><br>  A fun√ß√£o cria uma dire√ß√£o / segmento entre o local anterior e o atual e verifica se eles cruzam o plano.  Nesse caso, verificamos se cruza na dire√ß√£o certa (da frente para tr√°s?). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AExedrePortal::IsPointCrossingPortal( FVector Point, FVector PortalLocation, FVector PortalNormal ) { FVector IntersectionPoint; FPlane PortalPlane = FPlane( PortalLocation, PortalNormal ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> PortalDot = PortalPlane.PlaneDot( Point ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCrossing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsInFront = PortalDot &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsIntersect = FMath::SegmentPlaneIntersection( LastPosition, Point, PortalPlane, IntersectionPoint ); <span class="hljs-comment"><span class="hljs-comment">//Did we intersect the portal since last Location ? //If yes, check the direction : crossing forward means we were in front and now at the back //If we crossed backward, ignore it (similar to Prey 2006) if( IsIntersect &amp;&amp; !IsInFront &amp;&amp; LastInFront ) { IsCrossing = true; } //Store values for Next check LastInFront = IsInFront; LastPosition = Point; return IsCrossing; }</span></span></code> </pre> <br><h2>  Ator de teletransporte </h2><br>  A √∫ltima parte do ator do portal que veremos √© a fun√ß√£o <b>TeleportActor ()</b> . <br><br>  Ao teleportar um ator do ponto A para o ponto B, voc√™ precisa replicar seu movimento e posi√ß√£o.  Por exemplo, se um jogador entra no portal, em combina√ß√£o com efeitos visuais adequados, parece-lhe que ele passou por uma porta comum. <br><br>  A interse√ß√£o do portal parece mover-se em uma linha reta, mas, na realidade, algo completamente diferente acontece.  Ao sair do portal, o jogador pode estar em um contexto muito diferente.  Considere um exemplo do Portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/809/d4f/185809d4fd81675cdd6f1cc871eaf193.gif"></div><br>  Como voc√™ pode ver, ao atravessar o portal, a c√¢mera gira em rela√ß√£o ao seu vetor para frente (gira).  Isso ocorre porque os pontos inicial e final s√£o paralelos a diferentes planos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/072/97f/b30/07297fb30171a80c1cc0d831701feb74.jpg"></div><br>  Portanto, para que isso funcione, precisamos transformar o movimento do jogador no espa√ßo relativo do portal para convert√™-lo no espa√ßo Alvo.  Ao implementar isso, podemos ter certeza de que, ap√≥s entrar no portal e sair do outro lado, o player estar√° alinhado corretamente com rela√ß√£o ao espa√ßo.  Isso se aplica n√£o apenas √† posi√ß√£o e rota√ß√£o do ator, mas tamb√©m √† sua <b>velocidade</b> . <br><br><blockquote>  Se teleportarmos um ator sem altera√ß√µes, convertendo-o em uma rota√ß√£o local, ent√£o, como resultado, o ator poder√° se ver de cabe√ßa para baixo.  Isso pode ser adequado para objetos, mas n√£o aplic√°vel aos personagens ou ao pr√≥prio jogador.  Voc√™ precisa alterar a posi√ß√£o do ator, conforme mostrado acima no exemplo do Portal. </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortal::TeleportActor( AActor* ActorToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ActorToTeleport == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//------------------------------- //Retrieve and save Player Velocity //(from the Movement Component) //------------------------------- FVector SavedVelocity = FVector::ZeroVector; AExedreCharacter* EC = nullptr; if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { EC = Cast&lt;AExedreCharacter&gt;( ActorToTeleport ); SavedVelocity = EC-&gt;GetCharMovementComponent()-&gt;GetCurrentVelocity(); } //------------------------------- //Compute and apply new location //------------------------------- FHitResult HitResult; FVector NewLocation = UTool::ConvertLocationToActorSpace( ActorToTeleport-&gt;GetActorLocation(), this, Target ); ActorToTeleport-&gt;SetActorLocation( NewLocation, false, &amp;HitResult, ETeleportType::TeleportPhysics ); //------------------------------- //Compute and apply new rotation //------------------------------- FRotator NewRotation = UTool::ConvertRotationToActorSpace( ActorToTeleport-&gt;GetActorRotation(), this, Target ); //Apply new rotation ActorToTeleport-&gt;SetActorRotation( NewRotation ); //------------------------------- //If we are teleporting a character we need to //update its controller as well and reapply its velocity //------------------------------- if( ActorToTeleport-&gt;IsA( AExedreCharacter::StaticClass() ) ) { //Update Controller AExedrePlayerController* EPC = EC-&gt;GetPlayerController(); if( EPC != nullptr ) { NewRotation = UTool::ConvertRotationToActorSpace( EPC-&gt;GetControlRotation(), this, Target ); EPC-&gt;SetControlRotation( NewRotation ); } //Reapply Velocity (Need to reorient direction into local space of Portal) { FVector Dots; Dots.X = FVector::DotProduct( SavedVelocity, GetActorForwardVector() ); Dots.Y = FVector::DotProduct( SavedVelocity, GetActorRightVector() ); Dots.Z = FVector::DotProduct( SavedVelocity, GetActorUpVector() ); FVector NewVelocity = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); EC-&gt;GetCharMovementComponent()-&gt;Velocity = NewVelocity; } } //Cleanup Teleport LastPosition = NewLocation; }</span></span></code> </pre> <br><hr><br>  Como voc√™ provavelmente notou, para chamar rota√ß√£o / posi√ß√£o, eu chamo fun√ß√µes externas.  Eles s√£o chamados da classe de usu√°rio UTool, que define fun√ß√µes est√°ticas que podem ser chamadas de qualquer lugar (incluindo plantas).  O c√≥digo deles √© mostrado abaixo; voc√™ pode implement√°-los da maneira que lhe parecer melhor (provavelmente √© mais f√°cil coloc√°-los na classe de ator do Portal). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FVector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertLocationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Location, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FVector::ZeroVector; } FVector Direction = Location - Reference-&gt;GetActorLocation(); FVector TargetLocation = Target-&gt;GetActorLocation(); FVector Dots; Dots.X = FVector::DotProduct( Direction, Reference-&gt;GetActorForwardVector() ); Dots.Y = FVector::DotProduct( Direction, Reference-&gt;GetActorRightVector() ); Dots.Z = FVector::DotProduct( Direction, Reference-&gt;GetActorUpVector() ); FVector NewDirection = Dots.X * Target-&gt;GetActorForwardVector() + Dots.Y * Target-&gt;GetActorRightVector() + Dots.Z * Target-&gt;GetActorUpVector(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TargetLocation + NewDirection; }</code> </pre> <br>  A transforma√ß√£o aqui √© realizada calculando o produto escalar de vetores para determinar √¢ngulos diferentes.  O vetor Direction n√£o √© normalizado, ou seja, podemos multiplicar novamente o resultado Dots por vetores Target para obter a posi√ß√£o exatamente na mesma dist√¢ncia no espa√ßo local do ator Target. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FRotator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertRotationToActorSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FRotator Rotation, AActor* Reference, AActor* Target )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Reference == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || Target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FRotator::ZeroRotator; } FTransform SourceTransform = Reference-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat QuatRotation = FQuat( Rotation ); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * QuatRotation; FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewWorldQuat.Rotator(); }</code> </pre> <br>  Transformar a transforma√ß√£o foi um pouco mais dif√≠cil.  No final, a melhor solu√ß√£o acabou sendo o uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer">quaternions</a> , porque isso √© muito mais preciso do que trabalhar com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer">√¢ngulos de Euler</a> normais e requer apenas algumas linhas de c√≥digo.  As rota√ß√µes por quaternions s√£o realizadas usando multiplica√ß√£o; portanto, no nosso caso, aplicando Inverse () na rota√ß√£o que queremos converter, a moveremos para o espa√ßo local.  Em seguida, basta multiplic√°-lo novamente pelo turno Alvo para obter o turno final. <br><br><h2>  Criando uma malha do portal </h2><br>  Para ficar bonita do ponto de vista de um jogador, meu sistema de portal usa uma malha espec√≠fica.  A malha √© dividida em dois planos diferentes: <br><br><ul><li>  <b>Plano 1</b> : O plano principal no qual o destino de renderiza√ß√£o do portal √© exibido.  Este avi√£o tem um comportamento bastante incomum, porque sua tarefa √© se afastar um pouco do jogador enquanto ele se aproxima para evitar o corte pela c√¢mera.  Como as bordas do avi√£o n√£o se movem, mas apenas seus picos m√©dios se movem, isso permite ao jogador se sobrepor na renderiza√ß√£o do portal sem artefatos visuais.  As bordas nas bordas t√™m seu pr√≥prio UV na metade superior, enquanto as bordas internas t√™m seu pr√≥prio UV na metade inferior, o que facilita mascar√°-las no shader. </li><li>  <b>Plano 2</b> : Este plano √© usado apenas para estender a caixa delimitadora padr√£o da malha.  As normais dos v√©rtices s√£o direcionadas para baixo, portanto, mesmo em terreno n√£o plano, a malha n√£o ser√° vis√≠vel por padr√£o (porque o material de renderiza√ß√£o n√£o ter√° dois lados). </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72e/125/f6f/72e125f6fd315caa2777f65dc0eaf39a.gif"></div><br>  Por que usar uma malha como esta? <br><br>  Eu decidi que o "avi√£o 1" esticaria quando o jogador se aproximasse.  Isso permite que o player se sobreponha ao portal e passe por ele sem aparar (cortar).  Isso pode acontecer, por exemplo, se a c√¢mera ainda n√£o atravessou o plano do portal, mas os p√©s do jogador j√° o tocaram.  Isso permite que voc√™ n√£o corte o reprodutor e duplique a malha, por outro lado. <br><br>  A tarefa "plano 2" √© estender a caixa delimitadora padr√£o da malha.  Como o "plano 1" √© plano, a caixa delimitadora de um eixo tem uma espessura de 0 e, se a c√¢mera estiver atr√°s dela, o mecanismo a interromper√° (isto √©, n√£o a renderizar√°).  O plano 1 tem um tamanho de 128 √ó 128, para que possa ser facilmente escalado usando o mecanismo.  O plano 2 √© um pouco maior e abaixo do piso (abaixo de 0). <br><br>  Ap√≥s criar a malha, simplesmente a exportamos de um editor 3D de terceiros e importamos para a Unreal.  Ser√° usado na pr√≥xima etapa. <br><br><h2>  Criando material do portal </h2><br>  Para exibir o outro lado do portal, precisamos criar nosso pr√≥prio material.  Crie um novo material no navegador de conte√∫do (eu o chamei <b>MAT_PortalBase</b> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b0/402/a9c/7b0402a9cd6c6d62438e06fa3a7cd1f4.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/96c/a1b/dea96ca1b613a92acc7ca35e0bbe44b1.png"></div><br>  Agora abra-o e crie o seguinte gr√°fico: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfe/4fa/c17/cfe4fac175e5e399c9e615a6afd0b800.jpg"></div><br>  Veja como o material funciona: <br><br><ul><li>  <b>FadeColor</b> √© a cor que ser√° vis√≠vel atrav√©s do portal quando estiver muito longe.  √â necess√°rio porque nem sempre renderizamos todos os portais, por isso obscurecemos a renderiza√ß√£o quando o player / c√¢mera est√° longe. </li><li>  Para descobrir a que dist√¢ncia o jogador est√° do portal, eu determino a <b>dist√¢ncia</b> entre a posi√ß√£o da c√¢mera e a posi√ß√£o do ator.  Em seguida, divido a dist√¢ncia pelo valor m√°ximo com o qual quero realizar uma compara√ß√£o.  Por exemplo, se o n√∫mero m√°ximo definido √© 2000 e a dist√¢ncia para o jogador √© 1000, obtemos 0,5.  Se o player estiver mais longe, receberei um valor maior que 1, ent√£o utilizo n√≥s saturados para limit√°-lo.  Em seguida, vem o n√≥ Smoothstep, usado para dimensionar a dist√¢ncia como um gradiente e controlar com mais precis√£o o sombreamento do portal.  Por exemplo, quando o jogador est√° perto, a sombra desaparece completamente. </li><li>  Uso o c√°lculo da dist√¢ncia como o valor do canal alfa do n√≥ <b>Lerp</b> para misturar a cor do sombreamento e a <b>textura</b> que renderizar√° o destino do portal. </li><li>  Por fim, isolei o componente Y das coordenadas UV para criar uma m√°scara que permite saber quais v√©rtices da malha ser√£o empurrados.  Eu multiplico essa m√°scara pela quantidade de repulsa que preciso.  Uso um valor negativo para que, quando as normais dos v√©rtices sejam multiplicadas pelos v√©rtices, elas se movam na dire√ß√£o oposta. </li></ul><br>  Depois de tudo isso, criamos material pronto para uso. <br><br><h2>  Criando um ator do portal no Blueprint </h2><br>  Vamos configurar uma nova classe de blueprint herdada do ator do Portal.  Clique com o bot√£o direito do mouse no navegador de conte√∫do e selecione a classe Blueprint: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/28b/5a2/ead28b5a23369c2c86a076ec8bb1dda0.png"></div><br>  Agora digite "portal" no campo de pesquisa para selecionar a classe do portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/da4/555/bd7da4555cff2dc953ab3b0b0f4d1057.png"></div><br>  Abra o bluetooth, se ainda n√£o estiver aberto.  Na lista de componentes, voc√™ ver√° a seguinte hierarquia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/34c/308/73c34c308a70f644759dc9057b0facd2.png"></div><br>  Como esper√°vamos, h√° um componente raiz e uma raiz do portal.  Vamos adicionar um componente de malha est√°tica ao PortalRootComponent e carregar nela a malha criada na etapa anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/ef3/11d/fa4ef311d11c803afc565060a9902c24.jpg"></div><br><hr><br>  Tamb√©m adicionamos a Collision Box, que ser√° usada para determinar se o player est√° dentro do volume do portal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b0/28f/df6/0b028fdf696598f6b3eca9af3049caa1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2a/85d/747/c2a85d747c8b76900cae32e9f9cc1a59.png"></div><br>  A caixa Colis√£o est√° localizada abaixo do componente da cena associado √† raiz principal e n√£o sob a raiz do Portal.  Tamb√©m adicionei um √≠cone (outdoor) e um componente de seta para tornar o portal mais vis√≠vel nos n√≠veis.  Claro, isso n√£o √© necess√°rio. <br><br>  Agora vamos configurar o material no blueprint. <br><br>  Para come√ßar, precisamos de duas vari√°veis ‚Äã‚Äã- uma ser√° do tipo <b>Actor</b> e o nome √© <b>PortalTarget</b> , a segunda √© do tipo <b>Dynamic Material Instance</b> e √© chamada <b>MaterialInstance</b> .  O PortalTarget ser√° uma refer√™ncia √† posi√ß√£o que a janela do portal est√° visualizando (portanto, a vari√°vel √© comum, com um √≠cone de olho aberto), para que possamos alter√°-la quando o ator for colocado no n√≠vel.  O MaterialInstance armazenar√° um link para material din√¢mico para que, no futuro, possamos atribuir o destino de renderiza√ß√£o do portal rapidamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/0b9/772/4740b9772dfc7ce30cda63300f1682a5.png"></div><br>  Tamb√©m precisamos adicionar nossos pr√≥prios n√≥s de eventos.  √â melhor abrir o menu do bot√£o direito do mouse no <b>Gr√°fico de Eventos</b> e encontrar os nomes dos eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/719/d22/bc2719d224381581c9bdb8ea5ce7c365.png"></div><br>  E aqui para criar o seguinte diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f4/400/24f/0f440024f5c322c6640609bb8d20bcad.jpg"></div><br><ul><li>  <b>Begin Play</b> : aqui chamamos a fun√ß√£o pai SetTarget () do portal para atribuir um link ao ator, que ser√° usado mais tarde no SceneCapture.  Em seguida, criamos um novo material din√¢mico e atribu√≠mos a ele o valor da vari√°vel MaterialInstance.  Com este novo material, podemos atribu√≠-lo ao componente de malha est√°tica.  Tamb√©m dei uma textura fict√≠cia ao material, mas isso √© opcional. </li><li>  <b>Limpar RTT</b> : O objetivo deste recurso √© limpar a textura Target Target atribu√≠da ao material do portal.  √â lan√ßado pelo gerente do portal. </li><li>  <b>Definir RTT</b> : o objetivo desta fun√ß√£o √© definir o material de destino da renderiza√ß√£o do portal.  √â lan√ßado pelo gerente do portal. </li></ul><br>  At√© agora, terminamos o Bluetooth, mas retornaremos mais tarde para implementar as fun√ß√µes de Tick. <br><br><h2>  Gerenciador de portal </h2><br>  Portanto, agora temos todos os elementos b√°sicos necess√°rios para criar uma nova classe herdada do AActor, que ser√° o Portal Manager.  Voc√™ pode n√£o precisar da classe Portal Manager no seu projeto, mas no meu caso, isso simplifica bastante o trabalho com alguns aspectos.  Aqui est√° uma lista de tarefas executadas pelo gerente do Portal: <br><br><ul><li>  O gerente do Portal √© um ator <b>criado pelo Player Controller</b> e anexado a ele para rastrear o estado e a evolu√ß√£o do jogador no n√≠vel do jogo. </li><li>  Crie e destrua <b>o portal de destino de renderiza√ß√£o</b> .  A ideia √© criar dinamicamente uma textura de destino de renderiza√ß√£o que corresponda √† resolu√ß√£o da tela do jogador.  Al√©m disso, ao alterar a resolu√ß√£o durante o jogo, o gerente a converter√° automaticamente no tamanho desejado. </li><li>  O gerenciador do Portal <b>localiza e atualiza</b> o n√≠vel de ator do Portal para fornecer a eles um destino de renderiza√ß√£o.  Essa tarefa √© executada de forma a garantir a compatibilidade com o n√≠vel de streaming.  Quando um novo ator aparece, ele deve ter uma textura.  Al√©m disso, se o destino de renderiza√ß√£o for alterado, o gerente tamb√©m poder√° atribuir um novo automaticamente.  Isso facilita o gerenciamento do sistema, em vez de cada agente do Portal entrar em contato manualmente com o gerente. </li><li>  O componente <b>SceneCapture √©</b> anexado ao gerenciador do Portal, para n√£o criar uma c√≥pia para cada portal.  Al√©m disso, permite reutiliz√°-lo sempre que mudarmos para um ator espec√≠fico do portal no n√≠vel. </li><li>  Quando o portal decide <b>teleportar o</b> player, ele envia uma solicita√ß√£o ao Portal Manager.  Isso √© necess√°rio para atualizar os portais de origem e de destino (se houver), para que a transi√ß√£o ocorra sem juntas. </li><li>  <b>O</b> gerente do portal √© <b>atualizado</b> no final da fun√ß√£o <b>tick ()</b> do <b>personagem,</b> para que tudo seja atualizado corretamente, incluindo a c√¢mera do jogador.  Isso garante que tudo na tela seja sincronizado e evite um atraso de um quadro durante a renderiza√ß√£o pelo mecanismo. </li></ul><br>  Vamos dar uma olhada no cabe√ßalho do Portal Manager: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GameFramework/Actor.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedrePortalManager.generated.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Forward declaration class AExedrePlayerController; class AExedrePortal; class UExedreScriptedTexture; UCLASS() class EXEDRE_API AExedrePortalManager : public AActor { GENERATED_UCLASS_BODY() public: AExedrePortalManager(); //Called by a Portal actor when wanting to teleport something UFUNCTION(BlueprintCallable, Category="Portal") void RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ); //Save a reference to the PlayerControler void SetControllerOwner( AExedrePlayerController* NewOwner ); //Various setup that happens during spawn void Init(); //Manual Tick void Update( float DeltaTime ); //Find all the portals in world and update them //returns the most valid/usable one for the Player AExedrePortal* UpdatePortalsInWorld(); //Update SceneCapture void UpdateCapture( AExedrePortal* Portal ); //Accessor for Debug purpose UTexture* GetPortalTexture(); //Accessor for Debug purpose FTransform GetCameraTransform(); private: //Function to create the Portal render target void GeneratePortalTexture(); UPROPERTY() USceneCaptureComponent2D* SceneCapture; //Custom class, can be replaced by a "UCanvasRenderTarget2D" instead //See : https://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UCanvasRenderTarget2D/index.html UPROPERTY() UExedreScriptedTexture* PortalTexture; UPROPERTY() AExedrePlayerController* ControllerOwner; int32 PreviousScreenSizeX; int32 PreviousScreenSizeY; float UpdateDelay; };</span></span></span></span></code> </pre> <br><hr><br>  Antes de entrar em detalhes, mostrarei como um ator √© criado a partir da classe Player Controller, chamada a partir da fun√ß√£o BeginPlay (): <br><br><pre> <code class="cpp hljs"> FActorSpawnParameters SpawnParams; PortalManager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PortalManager = GetWorld()-&gt;SpawnActor&lt;AExedrePortalManager&gt;( AExedrePortalManager::StaticClass(), FVector::ZeroVector, FRotator::ZeroRotator, SpawnParams); PortalManager-&gt;AttachToActor( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, FAttachmentTransformRules::SnapToTargetIncludingScale); PortalManager-&gt;SetControllerOwner( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); PortalManager-&gt;Init();</code> </pre> <br>  Portanto, criamos um ator, anexamos ao controlador do jogador (this) e salvamos o link e chamamos a fun√ß√£o Init (). <br><br>  Tamb√©m √© importante observar que atualizamos o ator manualmente a partir da classe Character: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedreCharacter::TickActor( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime, <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ELevelTick TickType, FActorTickFunction&amp; ThisTickFunction ) { Super::TickActor( DeltaTime, TickType, ThisTickFunction ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( UGameplayStatics::GetPlayerController(GetWorld(), <span class="hljs-number"><span class="hljs-number">0</span></span>) ); EPC-&gt;PortalManager-&gt;Update( DeltaTime ); } }</code> </pre> <br>  E aqui est√° o construtor do Portal Manager.  Observe que Tick est√° desativado, novamente porque atualizaremos manualmente o Portal Manager atrav√©s do player. <br><br><pre> <code class="cpp hljs">AExedrePortalManager::AExedrePortalManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer) { PrimaryActorTick.bCanEverTick = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; PortalTexture = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; UpdateDelay = <span class="hljs-number"><span class="hljs-number">1.1f</span></span>; PreviousScreenSizeX = <span class="hljs-number"><span class="hljs-number">0</span></span>; PreviousScreenSizeY = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><hr><br>  Aqui est√£o as fun√ß√µes do get / set Portal Manager (depois disso, passaremos para coisas mais interessantes): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::SetControllerOwner( AExedrePlayerController* NewOwner ) { ControllerOwner = NewOwner; } FTransform AExedrePortalManager::GetCameraTransform() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( SceneCapture != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SceneCapture-&gt;GetComponentTransform(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FTransform(); } } UTexture* AExedrePortalManager::GetPortalTexture() { <span class="hljs-comment"><span class="hljs-comment">//Portal Texture is a custom component class that embed a UCanvasRenderTraget2D //The GetTexture() simply returns the RenderTarget contained in that class. //IsValidLowLevel() is used here as a way to ensure the Texture has not been destroyed or garbage collected. if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { return PortalTexture-&gt;GetTexture(); } else { return nullptr; } }</span></span></code> </pre> <br><hr><br>  Obviamente, a primeira coisa a come√ßar √© a fun√ß√£o <b>Init ()</b> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O principal objetivo desta fun√ß√£o √© criar o componente SceneCapture (ou seja, o dispositivo de captura mencionado acima) e configur√°-lo corretamente. </font><font style="vertical-align: inherit;">Come√ßa com a cria√ß√£o de um novo objeto e seu registro como componente desse ator. </font><font style="vertical-align: inherit;">Em seguida, passamos a definir propriedades relacionadas a esta captura. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propriedades a mencionar:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bCaptureEveryFrame = false</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : n√£o queremos que a captura seja </font><b><font style="vertical-align: inherit;">ativada</font></b><font style="vertical-align: inherit;"> quando n√£o precisamos dela. </font><font style="vertical-align: inherit;">N√≥s o gerenciaremos manualmente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bEnableClipPlane = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uma propriedade muito importante para renderizar a captura do portal corretamente.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bUseCustomProjectionMatrix = true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : isso nos permite substituir a proje√ß√£o do Capture pela nossa, com base no ponto de vista do jogador.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CaptureSource = ESceneCaptureSource :: SCS_SceneColorSceneDepth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esse modo √© um pouco caro, mas necess√°rio para renderizar uma quantidade suficiente de informa√ß√µes.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As demais propriedades est√£o relacionadas principalmente aos par√¢metros de p√≥s-processamento. </font><font style="vertical-align: inherit;">Eles s√£o uma maneira conveniente de controlar a qualidade e, portanto, capturar o desempenho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima parte chama a fun√ß√£o que cria o Target Render, que veremos abaixo.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Init() { <span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------ //Create Camera //------------------------------------------------ SceneCapture = NewObject&lt;USceneCaptureComponent2D&gt;(this, USceneCaptureComponent2D::StaticClass(), *FString("PortalSceneCapture")); SceneCapture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); SceneCapture-&gt;RegisterComponent(); SceneCapture-&gt;bCaptureEveryFrame = false; SceneCapture-&gt;bCaptureOnMovement = false; SceneCapture-&gt;LODDistanceFactor = 3; //Force bigger LODs for faster computations SceneCapture-&gt;TextureTarget = nullptr; SceneCapture-&gt;bEnableClipPlane = true; SceneCapture-&gt;bUseCustomProjectionMatrix = true; SceneCapture-&gt;CaptureSource = ESceneCaptureSource::SCS_SceneColorSceneDepth; //Setup Post-Process of SceneCapture (optimization : disable Motion Blur, etc) FPostProcessSettings CaptureSettings; CaptureSettings.bOverride_AmbientOcclusionQuality = true; CaptureSettings.bOverride_MotionBlurAmount = true; CaptureSettings.bOverride_SceneFringeIntensity = true; CaptureSettings.bOverride_GrainIntensity = true; CaptureSettings.bOverride_ScreenSpaceReflectionQuality = true; CaptureSettings.AmbientOcclusionQuality = 0.0f; //0=lowest quality..100=maximum quality CaptureSettings.MotionBlurAmount = 0.0f; //0 = disabled CaptureSettings.SceneFringeIntensity = 0.0f; //0 = disabled CaptureSettings.GrainIntensity = 0.0f; //0 = disabled CaptureSettings.ScreenSpaceReflectionQuality = 0.0f; //0 = disabled CaptureSettings.bOverride_ScreenPercentage = true; CaptureSettings.ScreenPercentage = 100.0f; SceneCapture-&gt;PostProcessSettings = CaptureSettings; //------------------------------------------------ //Create RTT Buffer //------------------------------------------------ GeneratePortalTexture(); }</span></span></code> </pre> <br><hr><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeneratePortalTexture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma fun√ß√£o chamada quando necess√°rio quando voc√™ precisa criar uma nova textura de destino de renderiza√ß√£o para portais. </font><font style="vertical-align: inherit;">Isso acontece na fun√ß√£o de inicializa√ß√£o, mas tamb√©m pode ser chamada durante a atualiza√ß√£o do Portal Manager. </font><font style="vertical-align: inherit;">√â por isso que esta fun√ß√£o possui uma verifica√ß√£o interna para alterar a resolu√ß√£o da janela de visualiza√ß√£o. </font><font style="vertical-align: inherit;">Se isso n√£o aconteceu, a atualiza√ß√£o n√£o √© executada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No meu caso, criei uma classe de wrapper para UCanvasRenderTarget2D. Eu chamei de ExedreScriptedTexture, √© um componente que pode ser anexado a um ator. Criei esta classe para gerenciar convenientemente os destinos de renderiza√ß√£o com atores que t√™m tarefas de renderiza√ß√£o. Ele faz a inicializa√ß√£o adequada do destino de renderiza√ß√£o e √© compat√≠vel com meu pr√≥prio sistema de interface do usu√°rio. No entanto, no contexto de portais, uma textura RenderTarget2D regular √© mais que suficiente. Portanto, voc√™ pode simplesmente us√°-lo.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::GeneratePortalTexture() { int32 CurrentSizeX = <span class="hljs-number"><span class="hljs-number">1920</span></span>; int32 CurrentSizeY = <span class="hljs-number"><span class="hljs-number">1080</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;GetViewportSize(CurrentSizeX, CurrentSizeY); } CurrentSizeX = FMath::Clamp( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(CurrentSizeX / <span class="hljs-number"><span class="hljs-number">1.7</span></span>), <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">1920</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1920 / 1.5 = 1280 CurrentSizeY = FMath::Clamp( int(CurrentSizeY / 1.7), 128, 1080); if( CurrentSizeX == PreviousScreenSizeX &amp;&amp; CurrentSizeY == PreviousScreenSizeY ) { return; } PreviousScreenSizeX = CurrentSizeX; PreviousScreenSizeY = CurrentSizeY; //Cleanup existing RTT if( PortalTexture != nullptr &amp;&amp; PortalTexture-&gt;IsValidLowLevel() ) { PortalTexture-&gt;DestroyComponent(); GEngine-&gt;ForceGarbageCollection(); } //Create new RTT PortalTexture = nullptr; PortalTexture = NewObject&lt;UExedreScriptedTexture&gt;(this, UExedreScriptedTexture::StaticClass(), *FString("PortalRenderTarget")); PortalTexture-&gt;SizeX = CurrentSizeX; PortalTexture-&gt;SizeY = CurrentSizeY; //Custom properties of the UExedreScriptedTexture class PortalTexture-&gt;Gamma = 1.0f; PortalTexture-&gt;WrapModeX = 1; //Clamp PortalTexture-&gt;WrapModeY = 1; //Clamp PortalTexture-&gt;bDrawWidgets = false; PortalTexture-&gt;bGenerateMipMaps = false; PortalTexture-&gt;SetClearOnUpdate( false ); //Will be cleared by SceneCapture instead PortalTexture-&gt;Format = ERenderTargetFormat::RGBA16; //Needs 16b to get &gt;1 for Emissive PortalTexture-&gt;AttachToComponent( GetRootComponent(), FAttachmentTransformRules::SnapToTargetIncludingScale ); PortalTexture-&gt;RegisterComponent(); PortalTexture-&gt;SetOwner( this ); PortalTexture-&gt;Init(); PortalTexture-&gt;SetFilterMode( TextureFilter::TF_Bilinear ); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como mencionado acima, criei minha pr√≥pria classe, portanto, as propriedades definidas aqui devem ser adaptadas ao destino de renderiza√ß√£o usual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â importante entender onde a captura ser√° exibida. </font><font style="vertical-align: inherit;">Como o destino da renderiza√ß√£o ser√° exibido no jogo, isso significa que isso acontecer√° antes de todo o p√≥s-processamento e, portanto, precisamos renderizar a cena com informa√ß√µes suficientes (para armazenar valores acima de 1 para criar Bloom). </font><font style="vertical-align: inherit;">Foi por isso que escolhi o formato RGBA16 (observe que ele possui seu pr√≥prio Enum, voc√™ precisar√° usar ETextureRenderTargetFormat). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mais informa√ß√µes, consulte as seguintes fontes:</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTextureRenderTarget2D</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ETextureRenderTargetFormat</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USceneCaptureComponent2D</font></font></a> </li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, consideraremos as fun√ß√µes de atualiza√ß√£o. </font><font style="vertical-align: inherit;">A fun√ß√£o b√°sica √© bastante simples e causa mais complexidade. </font><font style="vertical-align: inherit;">H√° um atraso antes de chamar a fun√ß√£o GeneratePortalTexture () para evitar a recria√ß√£o do destino de renderiza√ß√£o ao redimensionar a viewport (por exemplo, no editor). </font><font style="vertical-align: inherit;">Durante a publica√ß√£o do jogo, esse atraso pode ser removido.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::Update( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime ) { <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Generate Portal texture ? //----------------------------------- UpdateDelay += DeltaTime; if( UpdateDelay &gt; 1.0f ) { UpdateDelay = 0.0f; GeneratePortalTexture(); } //----------------------------------- //Find portals in the level and update them //----------------------------------- AExedrePortal* Portal = UpdatePortalsInWorld(); if( Portal != nullptr ) { UpdateCapture( Portal ); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chamamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para encontrar todos os portais presentes no mundo atual (incluindo todos os n√≠veis carregados) e atualiz√°-los. </font><font style="vertical-align: inherit;">A fun√ß√£o tamb√©m determina qual deles √© "ativo", ou seja, </font><font style="vertical-align: inherit;">vis√≠vel para o jogador. </font><font style="vertical-align: inherit;">Se encontrarmos um portal ativo, chamamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que controla o componente SceneCapture.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veja como a atualiza√ß√£o mundial funciona em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdatePortalsInWorld ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><ol><li>   <b></b>   (    ) </li><li>   <b>iterator</b> ,         </li><li>     ,   ,    <b>ClearRTT()</b> ,    .    <b> </b> (,   ). </li><li>  ,     <b></b>  ,    ,     ,     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verifica√ß√£o que determina a corre√ß√£o do portal √© simples: priorizamos o portal mais pr√≥ximo do jogador, porque ele provavelmente ser√° o mais vis√≠vel do ponto de vista dele. </font><font style="vertical-align: inherit;">Para descartar parentes, mas, por exemplo, portais localizados atr√°s do player, ser√£o necess√°rias verifica√ß√µes mais complexas, mas eu n√£o queria me concentrar nisso no meu tutorial, porque pode se tornar bastante dif√≠cil.</font></font><br><br><pre> <code class="cpp hljs">AExedrePortal* AExedrePortalManager::UpdatePortalsInWorld() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update Portal actors in the world (and active one if nearby) //----------------------------------- AExedrePortal* ActivePortal = nullptr; FVector PlayerLocation = Character-&gt;GetActorLocation(); FVector CameraLocation = Character-&gt;GetCameraComponent()-&gt;GetComponentLocation(); float Distance = 4096.0f; for( TActorIterator&lt;AExedrePortal&gt;ActorItr( GetWorld() ); ActorItr; ++ActorItr ) { AExedrePortal* Portal = *ActorItr; FVector PortalLocation = Portal-&gt;GetActorLocation(); FVector PortalNormal = -1 * Portal-&gt;GetActorForwardVector(); //Reset Portal Portal-&gt;ClearRTT(); Portal-&gt;SetActive( false ); //Find the closest Portal when the player is Standing in front of float NewDistance = FMath::Abs( FVector::Dist( PlayerLocation, PortalLocation ) ); if( NewDistance &lt; Distance ) { Distance = NewDistance; ActivePortal = Portal; } } return ActivePortal; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â hora de considerar a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UpdateCapture ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este √© um recurso de atualiza√ß√£o que captura o outro lado do portal. </font><font style="vertical-align: inherit;">A partir dos coment√°rios, tudo deve ficar claro, mas aqui est√° uma breve descri√ß√£o:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s temos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">links</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o Character e o Player Controller.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se est√° tudo correto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Portal, componente SceneCapture, Player).</font></font></li><li>   <b>Camera</b>    <b>Target</b>  . </li><li> <b></b>    ,     SceneCapture. </li><li>      SceneCapture     Target. </li><li> ,  SceneCapure  ,  ,   <b></b> . </li><li> <b> Render Target</b>  SceneCapture,  . </li><li>  <b> </b>  PlayerController. </li><li> ,    <b>Capture</b>  SceneCapture     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como podemos ver, ao teleportar um jogador, um elemento-chave do comportamento natural e sem falhas do SceneCapture √© a transforma√ß√£o correta da posi√ß√£o e rota√ß√£o do portal no espa√ßo de destino local. </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para a defini√ß√£o de ConvertLocationToActorSpace (), consulte ‚ÄúTeleportando um ator‚Äù. </font></font></blockquote><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::UpdateCapture( AExedrePortal* Portal ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AExedreCharacter* Character = ControllerOwner-&gt;GetCharacter(); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Update SceneCapture (discard if there is no active portal) //----------------------------------- if(SceneCapture != nullptr &amp;&amp; PortalTexture != nullptr &amp;&amp; Portal != nullptr &amp;&amp; Character != nullptr ) { UCameraComponent* PlayerCamera = Character-&gt;GetCameraComponent(); AActor* Target = Portal-&gt;GetTarget(); //Place the SceneCapture to the Target if( Target != nullptr ) { //------------------------------- //Compute new location in the space of the target actor //(which may not be aligned to world) //------------------------------- FVector NewLocation = UTool::ConvertLocationToActorSpace( PlayerCamera-&gt;GetComponentLocation(), Portal, Target ); SceneCapture-&gt;SetWorldLocation( NewLocation ); //------------------------------- //Compute new Rotation in the space of the //Target location //------------------------------- FTransform CameraTransform = PlayerCamera-&gt;GetComponentTransform(); FTransform SourceTransform = Portal-&gt;GetActorTransform(); FTransform TargetTransform = Target-&gt;GetActorTransform(); FQuat LocalQuat = SourceTransform.GetRotation().Inverse() * CameraTransform.GetRotation(); FQuat NewWorldQuat = TargetTransform.GetRotation() * LocalQuat; //Update SceneCapture rotation SceneCapture-&gt;SetWorldRotation( NewWorldQuat ); //------------------------------- //Clip Plane : to ignore objects between the //SceneCapture and the Target of the portal //------------------------------- SceneCapture-&gt;ClipPlaneNormal = Target-&gt;GetActorForwardVector(); SceneCapture-&gt;ClipPlaneBase = Target-&gt;GetActorLocation() + (SceneCapture-&gt;ClipPlaneNormal * -1.5f); //Offset to avoid visible pixel border } //Switch on the valid Portal Portal-&gt;SetActive( true ); //Assign the Render Target Portal-&gt;SetRTT( PortalTexture-&gt;GetTexture() ); SceneCapture-&gt;TextureTarget = PortalTexture-&gt;GetTexture(); //Get the Projection Matrix SceneCapture-&gt;CustomProjectionMatrix = ControllerOwner-&gt;GetCameraProjectionMatrix(); //Say Cheeeeese ! SceneCapture-&gt;CaptureScene(); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A </font><font style="vertical-align: inherit;">fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetCameraProjectionMatrix ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o existe por padr√£o na classe PlayerController, eu mesmo a adicionei. </font><font style="vertical-align: inherit;">√â mostrado abaixo:</font></font><br><br><pre> <code class="cpp hljs">FMatrix AExedrePlayerController::GetCameraProjectionMatrix() { FMatrix ProjectionMatrix; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( GetLocalPlayer() != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { FSceneViewProjectionData PlayerProjectionData; GetLocalPlayer()-&gt;GetProjectionData( GetLocalPlayer()-&gt;ViewportClient-&gt;Viewport, EStereoscopicPass::eSSP_FULL, PlayerProjectionData ); ProjectionMatrix = PlayerProjectionData.ProjectionMatrix; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProjectionMatrix; }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, precisamos implementar a chamada para a fun√ß√£o Teleport. </font><font style="vertical-align: inherit;">O motivo do processamento parcial do teletransporte atrav√©s do gerenciador do Portal √© que √© necess√°rio garantir a atualiza√ß√£o dos portais necess√°rios, pois somente o Manager possui informa√ß√µes sobre todos os portais em cena. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se tivermos dois portais conectados, ao mudar de um para outro, precisamos atualizar ambos em um Tick. </font><font style="vertical-align: inherit;">Caso contr√°rio, o jogador se teletransportar√° e estar√° do outro lado do portal, mas o Portal de Alvos n√£o estar√° ativo at√© o pr√≥ximo quadro / medida. </font><font style="vertical-align: inherit;">Isso criar√° lacunas visuais com o material de deslocamento da malha plana que vimos acima.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { Portal-&gt;TeleportActor( TargetToTeleport ); <span class="hljs-comment"><span class="hljs-comment">//----------------------------------- //Force update //----------------------------------- AExedrePortal* FuturePortal = UpdatePortalsInWorld(); if( FuturePortal != nullptr ) { FuturePortal-&gt;ForceTick(); //Force update before the player render its view since he just teleported UpdateCapture( FuturePortal ); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bem, √© isso, finalmente terminamos o Portal Manager! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Concluir o projeto </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de concluir o Portal Manager, precisamos apenas concluir o pr√≥prio agente do Portal, ap√≥s o qual o sistema funcionar√°. </font><font style="vertical-align: inherit;">A √∫nica coisa que falta aqui s√£o os recursos do Tick:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/455/bd3/f0f/455bd3f0f3b7c9f4f3fb36d5d1ae85d0.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veja como funciona: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estamos atualizando o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para que ele n√£o permane√ßa ativo.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o portal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estiver inativo no</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> momento </font><font style="vertical-align: inherit;">, o restante da medida ser√° descartado.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s obtemos a classe Character para acessar o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">local da c√¢mera</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira parte verifica se a c√¢mera est√° na caixa de colis√£o do portal. </font><font style="vertical-align: inherit;">Nesse caso, compensamos a malha do portal com seu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Material</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda parte √© verificar novamente o local dentro da caixa de colis√£o. </font><font style="vertical-align: inherit;">Se for executado, chamamos uma fun√ß√£o que verifica </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se atravessamos o portal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li>        ,   Portal manager,    <b> Teleport</b> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na captura de tela do meu gr√°fico, voc√™ pode observar dois pontos interessantes: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â Point Inside Box</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Portal Manager</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ainda n√£o expliquei essas duas fun√ß√µes. Essas s√£o fun√ß√µes est√°ticas que defini na minha pr√≥pria classe para que voc√™ possa cham√°-las de qualquer lugar. Este √© um tipo de classe auxiliar. O c√≥digo dessas fun√ß√µes √© mostrado abaixo, voc√™ mesmo pode decidir onde inseri-las. Se voc√™ n√£o precisar deles fora do sistema do portal, poder√° inseri-los diretamente na classe de ator do Portal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No come√ßo, eu queria usar o sistema de colis√£o para encontrar o ator do portal dentro da caixa de colis√£o, mas me pareceu n√£o ser confi√°vel o suficiente. Al√©m disso, parece-me que esse m√©todo √© mais r√°pido de usar e tem uma vantagem: leva em considera√ß√£o a rota√ß√£o do ator.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsPointInsideBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( FVector Point, UBoxComponent* Box )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Box != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//From : //https://stackoverflow.com/questions/52673935/check-if-3d-point-inside-a-box/52674010 FVector Center = Box-&gt;GetComponentLocation(); FVector Half = Box-&gt;GetScaledBoxExtent(); FVector DirectionX = Box-&gt;GetForwardVector(); FVector DirectionY = Box-&gt;GetRightVector(); FVector DirectionZ = Box-&gt;GetUpVector(); FVector Direction = Point - Center; bool IsInside = FMath::Abs( FVector::DotProduct( Direction, DirectionX ) ) &lt;= Half.X &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionY ) ) &lt;= Half.Y &amp;&amp; FMath::Abs( FVector::DotProduct( Direction, DirectionZ ) ) &lt;= Half.Z; return IsInside; } else { return false; } }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AExedrePortalManager* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPortalManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AActor* Context )</span></span></span><span class="hljs-function"> </span></span>{ AExedrePortalManager* Manager = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Retrieve the World from the Context actor if( Context != nullptr &amp;&amp; Context-&gt;GetWorld() != nullptr ) { //Find PlayerController AExedrePlayerController* EPC = Cast&lt;AExedrePlayerController&gt;( Context-&gt;GetWorld()-&gt;GetFirstPlayerController() ); //Retrieve the Portal Manager if( EPC != nullptr &amp;&amp; EPC-&gt;GetPortalManager() != nullptr ) { Manager = EPC-&gt;GetPortalManager(); } } return Manager; }</span></span></code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A √∫ltima parte do ator do Blueprint √© o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ForceTick</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lembre-se de que o Force Tick √© chamado quando um jogador atravessa um portal e fica ao lado de outro portal para o qual o Portal Manager est√° for√ßando uma atualiza√ß√£o. </font><font style="vertical-align: inherit;">Como acabamos de nos teletransportar, n√£o √© necess√°rio usar o mesmo c√≥digo e voc√™ pode usar sua vers√£o simplificada:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf3/562/22e/cf356222e9d9c81dc38c57d021e51a90.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O processo inicia aproximadamente ao mesmo tempo que a fun√ß√£o Tick, mas apenas executamos a primeira parte da sequ√™ncia, que atualiza o material. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≥s terminamos? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quase. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se implementarmos o sistema do portal neste formul√°rio, provavelmente encontraremos o seguinte problema:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c1/f2f/9f7/4c1f2f9f71e8ce213764d42dad1d20c3.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que est√° acontecendo aqui? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste gif, a taxa de quadros do jogo √© limitada a 6 FPS para mostrar o problema mais claramente. Em um quadro, o cubo desaparece porque o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sistema de recorte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">Unreal Engine o considera invis√≠vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso ocorre porque a descoberta √© realizada no quadro atual e usada no pr√≥ximo. Isso cria um </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atraso de um quadro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso geralmente pode ser resolvido expandindo a caixa delimitadora do objeto para que seja registrado antes de se tornar vis√≠vel. No entanto, isso n√£o funcionar√° aqui, porque quando atravessamos o portal, nos teletransportamos de um lugar para outro completamente diferente.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desabilitar o sistema de recorte tamb√©m √© imposs√≠vel, principalmente porque em n√≠veis com muitos objetos isso reduz o desempenho. Al√©m disso, tentei muitas equipes do mecanismo Unreal, mas n√£o obtive resultados positivos: em todos os casos, permaneceu um atraso de um quadro. Felizmente, depois de um estudo detalhado do c√≥digo fonte do Unreal Engine, consegui encontrar uma solu√ß√£o (o caminho foi longo - levou mais de uma semana)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim como no componente SceneCapture, voc√™ pode dizer √† c√¢mera do jogador que fizemos um </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">corte</font></a><font style="vertical-align: inherit;"> r√°pido</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a posi√ß√£o da c√¢mera saltou entre dois quadros, o que significa que n√£o podemos confiar nas informa√ß√µes do quadro anterior. </font><font style="vertical-align: inherit;">Esse comportamento pode ser observado ao usar o Matinee ou o Sequencer, por exemplo, ao alternar as c√¢meras: desfoque ou suaviza√ß√£o de movimento n√£o podem confiar nas informa√ß√µes do quadro anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para fazer isso, precisamos considerar dois aspectos:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LocalPlayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : essa classe processa v√°rias informa√ß√µes (por exemplo, a janela de visualiza√ß√£o do jogador) e est√° associada ao PlayerController. </font><font style="vertical-align: inherit;">√â aqui que podemos influenciar o processo de renderiza√ß√£o da c√¢mera do jogador.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayerController</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : quando um jogador se teleporta, essa classe come√ßa a se unir gra√ßas ao acesso ao LocalPlayer.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A grande vantagem dessa solu√ß√£o √© que a interven√ß√£o no processo de renderiza√ß√£o do mecanismo √© m√≠nima e f√°cil de manter em futuras atualiza√ß√µes do Unreal Engine. </font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar criando uma nova classe herdada do LocalPlayer. </font><font style="vertical-align: inherit;">Abaixo est√° um cabe√ßalho que identifica dois componentes principais: redefinindo os c√°lculos do Scene Viewport e uma nova fun√ß√£o para chamar a colagem da c√¢mera.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CoreMinimal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Engine/LocalPlayer.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.generated.h"</span></span></span><span class="hljs-meta"> UCLASS() class EXEDRE_API UExedreLocalPlayer : public ULocalPlayer { GENERATED_BODY() UExedreLocalPlayer(); public: FSceneView* CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) override; void PerformCameraCut(); private: bool bCameraCut; };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veja como tudo √© implementado: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Exedre.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ExedreLocalPlayer.h"</span></span></span><span class="hljs-meta"> UExedreLocalPlayer::UExedreLocalPlayer() { bCameraCut = false; } FSceneView* UExedreLocalPlayer::CalcSceneView( class FSceneViewFamily* ViewFamily, FVector&amp; OutViewLocation, FRotator&amp; OutViewRotation, FViewport* Viewport, class FViewElementDrawer* ViewDrawer, EStereoscopicPass StereoPass) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ULocalPlayer::CalcSceneView() use a ViewInitOptions to create // a FSceneView which contains a "bCameraCut" variable // See : H:\GitHub\UnrealEngine\Engine\Source\Runtime\Renderer\Private\SceneCaptureRendering.cpp // as well for bCameraCutThisFrame in USceneCaptureComponent2D FSceneView* View = Super::CalcSceneView(ViewFamily, OutViewLocation, OutViewRotation, Viewport, ViewDrawer, StereoPass ); if( bCameraCut ) { View-&gt;bCameraCut = true; bCameraCut = false; } return View; } void UExedreLocalPlayer::PerformCameraCut() { bCameraCut = true; }</span></span></span></span></code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PerformCameraCut ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> apenas inicia o Camera Cut com um valor booleano. </font><font style="vertical-align: inherit;">Quando o mecanismo chama a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , primeiro executamos a fun√ß√£o original. </font><font style="vertical-align: inherit;">Ent√£o verificamos, precisamos realizar colagem. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> caso, redefinimos a vari√°vel booleana Camera Cut dentro da estrutura </font><b><font style="vertical-align: inherit;">FSceneView</font></b><font style="vertical-align: inherit;"> , que ser√° usada pelo processo de renderiza√ß√£o do mecanismo, e redefinimos a vari√°vel booleana (use-a).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No lado do Player Controller, as altera√ß√µes s√£o m√≠nimas. </font><font style="vertical-align: inherit;">Voc√™ precisa adicionar uma vari√°vel ao cabe√ßalho para armazenar um link para a classe nativa LocalPlayer:</font></font><br><br><pre> <code class="cpp hljs"> UPROPERTY() UExedreLocalPlayer* LocalPlayer;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, na fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BeginPlay ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"> LocalPlayer = Cast&lt;UExedreLocalPlayer&gt;( GetLocalPlayer() );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamb√©m adicionei uma fun√ß√£o para iniciar rapidamente o Cut: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePlayerController::PerformCameraCut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( LocalPlayer != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { LocalPlayer-&gt;PerformCameraCut(); } }</code> </pre> <br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, na fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RequestTeleportByPortal ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do Portal Manager </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> podemos executar durante o teletransporte do Camera Cut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AExedrePortalManager::RequestTeleportByPortal( AExedrePortal* Portal, AActor* TargetToTeleport ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Portal != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; TargetToTeleport != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ControllerOwner != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) { ControllerOwner-&gt;PerformCameraCut(); } [...]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E isso √© tudo! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O corte da c√¢mera deve ser chamado antes que o SceneCapture seja atualizado, e √© por isso que est√° no in√≠cio da fun√ß√£o.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultado final </font></font></h2><br> <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora aprendemos a pensar em portais. </font></font></a></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o sistema funcionar bem, poderemos criar o seguinte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/47f/229/5a947f2299f45d3deab4cfc258045cc1.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se voc√™ estiver tendo problemas, verifique o seguinte: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifique se o Portal Manager est√° criado e inicializado corretamente. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O destino de renderiza√ß√£o foi criado corretamente (voc√™ pode usar o criado no navegador de conte√∫do para come√ßar). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Portais est√£o corretamente ativados e desativados. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Os portais t√™m o ator Alvo definido corretamente no editor. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perguntas e Respostas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As perguntas mais populares que me foram feitas sobre este tutorial: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â poss√≠vel implementar isso em blunts, e n√£o atrav√©s de C ++? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maior parte do c√≥digo pode ser implementada em blunts, com exce√ß√£o de dois aspectos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetProjectionData ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usada para obter a matriz de proje√ß√£o n√£o est√° dispon√≠vel nos blueprints.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o LocalPlayer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CalcSceneView ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , essencial para resolver o problema do sistema de recorte, n√£o est√° dispon√≠vel nos blueprints.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, voc√™ precisa usar uma implementa√ß√£o C ++ para acessar essas duas fun√ß√µes ou modificar o c√≥digo-fonte do mecanismo para torn√°-las acess√≠veis atrav√©s de blueprints. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posso usar este sistema em VR? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sim, na maior parte. </font><font style="vertical-align: inherit;">No entanto, algumas partes ter√£o que ser adaptadas, por exemplo:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ precisa usar dois Destinos de renderiza√ß√£o (um para cada olho) e mascar√°-los no material do portal para exibir lado a lado no espa√ßo da tela. </font><font style="vertical-align: inherit;">Cada destino de renderiza√ß√£o deve ter metade da largura da resolu√ß√£o do dispositivo VR.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voc√™ precisa usar dois SceneCapture para renderizar o alvo com a dist√¢ncia correta (a dist√¢ncia entre os olhos) para criar efeitos estereosc√≥picos. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O principal problema ser√° o desempenho, porque o outro lado do portal precisar√° ser renderizado duas vezes. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro objeto pode atravessar o portal?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√£o existe no meu c√≥digo. No entanto, torn√°-lo mais geral n√£o √© t√£o dif√≠cil. Para fazer isso, o portal precisa rastrear mais informa√ß√µes sobre todos os objetos pr√≥ximos, a fim de verificar se eles o atravessam. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sistema suporta recurs√£o (portal dentro do portal)?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este tutorial n√£o √©. Para recurs√£o, voc√™ precisa de um destino de renderiza√ß√£o adicional e do SceneCapture. Tamb√©m ser√° necess√°rio determinar qual RenderTarget renderizar primeiro e assim por diante. Isso √© bastante dif√≠cil e eu n√£o queria fazer isso, porque para o meu projeto isso n√£o √© necess√°rio. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posso atravessar o portal perto da parede?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente n√£o. </font><font style="vertical-align: inherit;">No entanto, vejo duas maneiras de implementar isso (teoricamente):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desative as colis√µes do jogador para que ele possa atravessar as paredes. </font><font style="vertical-align: inherit;">√â f√°cil de implementar, mas leva a muitos efeitos colaterais.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invada um sistema de colis√£o para criar um buraco dinamicamente, o que permitir√° ao jogador passar. </font><font style="vertical-align: inherit;">Para fazer isso, voc√™ precisa modificar o sistema f√≠sico do mecanismo. </font><font style="vertical-align: inherit;">No entanto, pelo que sei, depois de carregar o n√≠vel, a f√≠sica est√°tica n√£o pode ser atualizada. </font><font style="vertical-align: inherit;">Portanto, para oferecer suporte a esse recurso, ser√° necess√°rio muito trabalho. </font><font style="vertical-align: inherit;">Se seus portais s√£o est√°ticos, provavelmente voc√™ pode solucionar esse problema usando o n√≠vel de streaming para alternar entre diferentes colis√µes.</font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448802/">https://habr.com/ru/post/pt448802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448782/index.html">Teste de Python com pytest. Introdu√ß√£o ao pytest, Cap√≠tulo 1</a></li>
<li><a href="../pt448784/index.html">Novos recursos para autores de extens√£o no Visual Studio 2019 vers√£o 16.1</a></li>
<li><a href="../pt448792/index.html">Teste de Python com pytest. Acess√≥rios Internos, Cap√≠tulo 4</a></li>
<li><a href="../pt448796/index.html">Teste de Python com pytest. Configura√ß√£o, CAP√çTULO 6</a></li>
<li><a href="../pt448798/index.html">Teste de Python com pytest. Usando pytest com outras ferramentas, CAP√çTULO 7</a></li>
<li><a href="../pt448804/index.html">Preparando-se para o tempo de execu√ß√£o e o not√°rio refor√ßados do macOS</a></li>
<li><a href="../pt448808/index.html">Sobre coisas simples, complicadas. "Dormindo a√ßo". Como lubrificar parafusos enferrujados ou n√£o WD-40 com um √∫nico ...</a></li>
<li><a href="../pt448810/index.html">Como eu peguei um hacker</a></li>
<li><a href="../pt448812/index.html">Miss√£o lunar ‚ÄúBereshit‚Äù - procura a primeira biblioteca lunar ap√≥s o in√≠cio do acidente de sua transportadora</a></li>
<li><a href="../pt448814/index.html">Linguagem Bosque - Nova Linguagem de Programa√ß√£o da Microsoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>