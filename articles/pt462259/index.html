<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üâë ü§æüèª üë©üèΩ‚Äç‚öïÔ∏è Fazendo um controlador para uma casa inteligente ü§† ‚ô£Ô∏è üíáüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fazemos um controlador para uma casa inteligente e n√£o apenas. 

 Em um artigo anterior, descrevi o desenvolvimento do sistema como um todo. Nele, des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fazendo um controlador para uma casa inteligente</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462259/">  Fazemos um controlador para uma casa inteligente e n√£o apenas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Em um artigo anterior,</a> descrevi o desenvolvimento do sistema como um todo.  Nele, descreverei o desenvolvimento de um controlador respons√°vel por sensores de sondagem e m√≥dulos de E / S.  "Por que reinventar a roda?"  - voc√™ pergunta.  Em primeiro lugar, √© interessante e, em segundo lugar, estranhamente, n√£o existe uma solu√ß√£o OpenSource para esse controlador que cubra software e hardware.  O artigo √© destinado a pessoas que s√£o um pouco versadas em eletr√¥nica e no desenvolvimento de Linux embarcado. <br><br>  Fazer um controlador, voc√™ diz, √© t√£o complicado - voc√™ precisa montar um quadro, escrever um software, imprimir o estojo.  Mas, na realidade, tudo √© um pouco mais complicado, foi isso que me serviu, mas voc√™ est√° certo em princ√≠pio: <br><a name="habracut"></a><br>  1. hardware do controlador <br><br>  - escolha da placa da CPU para o controlador <br>  - escolha do controlador IO <br>  - escolha da fonte de alimenta√ß√£o <br>  - diagrama de blocos do controlador <br>  - desenvolvimento de uma placa cruzada para o controlador <br>  - desenvolvimento de placas para m√≥dulos RS-485 <br>  - produ√ß√£o de placas <br><br>  2. software para o controlador <br><br>  - escolha do sistema de compila√ß√£o para kernel linux e rootfs <br>  - estrutura de parti√ß√£o do cart√£o SD <br>  - escolha do gerenciador de inicializa√ß√£o e carregamento dos rootfs necess√°rios <br>  - mudan√ßas na √°rvore de dispositivos <br>  - a escolha de um sistema para cobran√ßa de d√©bitos negociados <br>  - escrevendo um sistema de constru√ß√£o <br>  - escrevendo um n√∫cleo de comunica√ß√£o <br>  - escrevendo gateway mqtt (pontos do controlador discreto / anal√≥gico -&gt; t√≥picos mqtt) <br>  - escrevendo um analisador do Google e construindo um arquivo de configura√ß√£o json para o gateway <br>  - escrevendo um monitor de ponto para acessar os pontos do controlador <br>  - montar sistema de arquivos somente leitura <br><br>  3. caixa do controlador <br><br>  - o que deveria ser: conectores, refrigera√ß√£o, assentos para uma prancha, hipotecas de clipes para suportes em um dinrake. <br>  - design e impress√£o <br><br>  Algumas palavras sobre o hardware. <br><br>  Provavelmente, apenas os mais desesperados agora usam um processador separado, mem√≥ria, flash, controlador de energia, mais algumas centenas de componentes e come√ßam a esculpir tudo isso juntos.  O resto usa os frutos do trabalho de outras pessoas, √© mais r√°pido e f√°cil.  Voc√™ s√≥ precisa abrir um navegador e escrever "computador de placa √∫nica" e passar o resto do dia escolhendo o caminho certo.  Eu precisava de muitas portas seriais e √© desej√°vel que a placa suporte -40 ¬∞ C a + 85 ¬∞ C, ent√£o a escolha foi feita no BeagleBone Black (BBB).  Tamb√©m no BBB, todos os perif√©ricos s√£o conectados a dois conectores PBD de 46 pinos em incrementos de 2,54, o que √© conveniente para a cria√ß√£o de prot√≥tipos e o desenvolvimento de uma placa cruzada.  √â necess√°ria uma placa cruzada para combinar todos os componentes em uma placa; para mim, √© uma placa de CPU, uma fonte de alimenta√ß√£o, um controlador IO e placas de canal RS485.  Al√©m disso, √© a placa cruzada que precisa ser fixada ao gabinete e h√° conectores nele para alimenta√ß√£o e cabo RS485. <br><br><img src="https://habrastorage.org/webt/oy/jo/6j/oyjo6jzy2qtidg-9ehm5zmtnqtg.jpeg"><br><br>  Assim, como descobrimos a placa da CPU, a pr√≥xima coisa a decidir √© se √© necess√°rio colocar um controlador de entrada / sa√≠da (IO) na placa cruzada ou n√£o.  Coloquei-o no quadro e ainda n√£o o usei com sucesso.  A √∫nica coisa que ele faz √© adiar o in√≠cio do BBB por 1s ap√≥s aplicar energia e acionar o bot√£o de reinicializa√ß√£o. <br><br>  A fonte de alimenta√ß√£o para o controlador, eu peguei o MeanWell NSD10-12S5 j√° pronto, desenvolv√™-lo para um √∫nico dispositivo √© uma tarefa sem sentido, apenas peguei para consumo e √© isso.  N√£o preste aten√ß√£o no LCD, ele est√° no quadro, mas eu n√£o implementei suporte. <br><br><img src="https://habrastorage.org/webt/uu/ub/hx/uuubhxrvgg7imxkdmtk6rjsojtu.jpeg"><br><br><img src="https://habrastorage.org/webt/hd/wn/l2/hdwnl2uo05wm6isu1pudumcx8zk.jpeg"><br><br>  Algumas palavras sobre placas de canal RS485. <br><br>  Existem 4 interfaces seriais BBB na placa cruzada.  Ent√£o, a√≠ voc√™ pode colocar qualquer tipo de canal que precisar, m√≥dulo RS485, CAN, Zigbee ... <br><br>  Eu precisava de canais RS485, ent√£o os fiz apenas, eles est√£o com controle autom√°tico de recep√ß√£o / transmiss√£o e com isolamento galv√¢nico.  Por que n√£o usar o controle do transceptor com BBB, porque a TI parou oficialmente de suportar o estrobosc√≥pio para RS485 no driver de dispositivo serial.  Voc√™ pode encontrar um patch para o driver, pode adicion√°-lo, mas por qu√™?  Tendo tornado o canal autotrav√°vel, ele pode ser colocado em qualquer placa, por exemplo, no RaspberyPi, onde nunca houve esse suporte, se houver, ent√£o me corrija.  O estrobosc√≥pio para o driver rs485 est√° configurado no attiny10, barato e alegre. <br><br>  Voltamos ao software. <br><br>  Escolhendo um sistema de compila√ß√£o para o kernel do linux e o rootfs. <br><br>  Existem v√°rios sistemas desse tipo, os mais populares s√£o o Yocto e o BuildRoot.  Se voc√™ precisa desenvolver um projeto grande, se tem muito tempo e deseja escrever receitas, o Yocto √© a sua escolha.  Com a ajuda do BuildRoot, voc√™ pode coletar tudo o que precisa para iniciar o f√≥rum facilmente, muito, muito simples, porque  Estou criando um sistema no Beaglebone Black (a seguir BBB) ent√£o: <br><br><ol><li>  leia o que est√° escrito aqui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr.com/en/post/448638</a> </li><li>  fazer limpo </li><li>  make beaglebone_defconfig </li><li>  fazer </li></ol><br>  Isso √© tudo.  Agora tudo o que voc√™ precisa para executar o quadro est√° na pasta / buildroot / output / images. <br><br>  Tudo parece muito simples e n√£o √© interessante, ent√£o voc√™ pode fazer um pouco mais complicado: <br><br><ol><li>  integre o buildroot ao seu sistema de constru√ß√£o, fa√ßa o download com um script, lembre-se de usar uma tag est√°vel e n√£o fa√ßa o √∫ltimo desenvolvimento </li><li>  escreva seu defconfig e jogue o script na pasta / buildroot / configs antes de montar o buildroot, n√£o esque√ßa que todos os defconfigs devem terminar com * _defconfig, caso contr√°rio o buildroot n√£o o v√™ </li><li>  copie seu post-build.sh para board / beaglebone / post-build.sh </li><li>  fa√ßa preparar um script que far√° n1, n2 e n3 para voc√™ </li></ol><br>  Como resultado, o buildroot ir√° gerar zImage e rootfs.tar <br><br>  Selecionando a estrutura da parti√ß√£o do cart√£o SD: <br><br>  Acho que n√£o √© necess√°rio focar muita aten√ß√£o nisso. <br>  Fiz 4 se√ß√µes BOOT / ROOT_1 / ROOT_2 / DATA. <br>  A se√ß√£o BOOT cont√©m tudo o que voc√™ precisa para inicializa√ß√£o: MLO, barebox.bin, barebox.env, am335x-boneblack.dtb, zImage, boot.txt. <br><br>  ROOT_1 e ROOT_2 cont√™m rootfs, cuja sele√ß√£o √© inserida no arquivo boot.txt (veja abaixo).  Todas essas parti√ß√µes s√£o montadas como somente leitura para evitar falhas no sistema de arquivos quando a energia √© desligada.  DATA cont√©m configura√ß√µes de design, ao alterar as quais n√£o h√° necessidade de reconstruir o c√≥digo. <br><br>  Essa estrutura de parti√ß√µes no futuro facilitar√° a grava√ß√£o de um componente de atualiza√ß√£o de software.  Este componente substituir√° uma das se√ß√µes ROOT_1 / ROOT_2, que n√£o √© usada agora e, em seguida, altere o arquivo boot.txt se voc√™ n√£o precisar alterar o kernel. <br><br>  Escolhendo um gerenciador de inicializa√ß√£o. <br><br>  Eu tive muitas experi√™ncias com bootloaders para BBB.  No come√ßo, usei, como todo mundo, o U-Boot que o BuildRoot gera.  Mas eu n√£o gostei, talvez, √© claro, isso seja uma quest√£o de h√°bito, mas me pareceu que era demais, muito pesado e dif√≠cil de configurar.  Ent√£o, pensei que n√£o seria uma m√° id√©ia iniciar o sistema rapidamente, em 2 a 3 segundos, e arquivar o X-Loader para que ele carregasse o kernel, consegui, mas novamente houve um problema de configura√ß√£o e a hora de in√≠cio para mim. n√£o √© cr√≠tico (o sistema no systemd inicializa lentamente por si s√≥, mesmo se voc√™ excluir tudo o que n√£o √© necess√°rio). <br><br>  No final, decidi pelo barebox, gostei muito da sua simplicidade, al√©m de o site ter toda a documenta√ß√£o (www.barebox.org). <br><br>  Por exemplo, para carregar rootfs da primeira ou segunda parti√ß√£o, voc√™ s√≥ precisa: <br><br>  1. na se√ß√£o de inicializa√ß√£o, crie o arquivo boot.txt que exportar√° uma vari√°vel do tipo "export BOOT_NUM = X" <br><br>  2. crie dois scripts / env / boot / sdb1 / env / boot / sdb2 para descrever as op√ß√µes de inicializa√ß√£o, por exemplo: <br><br><pre><code class="plaintext hljs">echo "botting with mmcblk0p2 as rootfs..." global.bootm.image=/boot/zImage global.bootm.oftree=/boot/am335x-boneblack.dtb global.linux.bootargs.console="console=ttyO0,115200" global.linux.bootargs.debug="earlyprintk ignore_loglevel" global.linux.bootargs.base="root=/dev/mmcblk0p2 ro rootfstype=ext4 rootwait"</code> </pre> <br>  3. crie um script / env / boot / sd no qual, dependendo do BOOT_NUM, inicie o script sdb1 ou sdb2 <br><br>  4. defina a vari√°vel boot.default <br><br><pre> <code class="plaintext hljs">nv boot.default=sd saveenv</code> </pre> <br>  5. Alterando ainda mais o BOOT_NUM no boot.txt, carregaremos o rootfs da primeira ou segunda parti√ß√£o, que no futuro poder√° ser usada para atualiza√ß√£o de software. <br><br>  Altera√ß√µes na √°rvore de dispositivos. <br><br>  Como eu uso o MODBUS RTU via RS485 para me comunicar com os m√≥dulos, eu precisava habilitar quase todas as portas seriais existentes no BBB.  Para fazer isso, √© necess√°rio reativ√°-los na √°rvore de dispositivos, porque  Por padr√£o, a maioria deles est√° desativada. <br><br>  Seria correto fazer o seu patch para o arquivo am335x-bone-common.dtsi do pacote buildrut e aplic√°-lo todas as vezes antes de mont√°-lo, mas a pregui√ßa venceu e eu apenas peguei todos os arquivos necess√°rios, alterei tudo o que precisava e constru√≠-o com as m√£os. <br><br>  Porque  isso √© feito uma vez, √© poss√≠vel e assim: <br><br>  1. Crie uma pasta com os arquivos necess√°rios para a montagem: <br><br><pre> <code class="plaintext hljs">am335x-bone-common.dtsi am335x-boneblack-common.dtsi am335x-boneblack.dts am33xx-clocks.dtsi am33xx.dtsi am33xx.h gpio.h omap.h tps65217.dtsi</code> </pre> <br>  2. No arquivo am335x-bone-common.dtsi, voc√™ precisa configurar corretamente os pinos e desabilitar os drivers da porta: <br><br><pre> <code class="plaintext hljs">uart1_pins: pinmux_uart1_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x980, PIN_INPUT_PULLUP | MUX_MODE0) AM33XX_IOPAD(0x984, PIN_OUTPUT_PULLDOWN | MUX_MODE0) &gt;; }; uart2_pins: pinmux_uart2_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE1) AM33XX_IOPAD(0x954, PIN_OUTPUT_PULLDOWN | MUX_MODE1) &gt;; }; uart4_pins: pinmux_uart4_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE6) AM33XX_IOPAD(0x874, PIN_OUTPUT_PULLDOWN | MUX_MODE6) &gt;; }; uart5_pins: pinmux_uart5_pins { pinctrl-single,pins = &lt; AM33XX_IOPAD(0x8C4, PIN_INPUT_PULLUP | MUX_MODE4) AM33XX_IOPAD(0x8C0, PIN_OUTPUT_PULLDOWN | MUX_MODE4) &gt;; }; &amp;uart1 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart1_pins&gt;; status = "okay"; }; &amp;uart2 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart2_pins&gt;; status = "okay"; }; &amp;uart4 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart4_pins&gt;; status = "okay"; }; &amp;uart5 { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;uart5_pins&gt;; status = "okay"; };</code> </pre><br>  3. Em seguida, um pouco de m√°gica e o arquivo finalizado am335x-boneblack.dtb fica no mesmo diret√≥rio: <br><br><pre> <code class="plaintext hljs">a. sudo apt-get install device-tree-compiler</code> </pre> <br>  b.  execute o pr√©-processador: <br><br><pre> <code class="plaintext hljs">cpp -Wp,-MD,am335x-boneblack.dtb.d.pre.tmp -nostdinc -Iinclude -Isrc -Itestcase-data -undef -D__DTS__ -x assembler-with-cpp -o am335x-boneblack.dtb.dts.tmp am335x-boneblack.dts</code> </pre> <br>  c.  execute o pr√≥prio compilador: <br><br><pre> <code class="plaintext hljs">dtc -O dtb -o am335x-boneblack.dtb -b 0 -i src -d am335x-boneblack.dtb.d.dtc.tmp am335x-boneblack.dtb.dts.tmp</code> </pre> <br>  4. am335x-boneblack.dtb deve ser colocado na parti√ß√£o de inicializa√ß√£o ao lado do kernel e, no script de inicializa√ß√£o do barebox, adicione a seguinte linha - " <code>global.bootm.oftree=/boot/am335x-boneblack.dtb</code> " <br><br>  Escolha de um sistema para cobran√ßa de d√©bitos negociados. <br><br>  Como voc√™ sabe, os sistemas sem erros n√£o existem, bem como a an√°lise de um sistema multithread sem rastreios.  √â muito conveniente que esses rastreamentos n√£o sejam exibidos simplesmente no console, mas sejam coletados usando algo especialmente criado para isso, para que seja poss√≠vel classific√°-los por processos, aplicar filtros etc.  E eu apenas conhe√ßo um bom sistema que √© f√°cil de construir sob host e destino.  Esse √© o DLT, se voc√™ nunca ouviu falar disso, n√£o importa, todas as lacunas de conhecimento podem ser facilmente cobertas lendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em.projects.genivi.org/wiki/display/PROJ/Diagnostic+Log+e+Trace</a> . <br>  Este sistema consiste em dlt-daemon e dlt-viewer.  Como o nome indica, o dlt-daemon √© executado no destino e o dlt-viewer no host.  Al√©m de tudo isso, para o seu bin√°rio, do qual queremos coletar rastros, voc√™ precisa vincular a dlt lib. <br><br><img src="https://habrastorage.org/webt/oi/go/b-/oigob-peuxj5pdvmkdr0vzu5wkc.png"><br><br>  Em geral, tudo √© conveniente, como coletar tra√ßos e analis√°-los, eu recomendo. <br><br>  Escrevendo um sistema de compila√ß√£o. <br><br>  Por que escrever um sistema de constru√ß√£o, porque voc√™ pode fazer o download de tudo dos reposit√≥rios, constru√≠-lo com suas m√£os, construir com base nesse rootfs e v√©u, o controlador funciona.  Mas repetir esse truque em um m√™s ser√° mais dif√≠cil e em dois - isso geralmente √© imposs√≠vel.  Novamente, voc√™ deve se lembrar do que, onde colocar, o que construir e como come√ßar.  Portanto, tendo passado muito tempo no in√≠cio, voc√™ o salva mais tarde, al√©m de ter a oportunidade de criar convenientemente sob host e destino.  O sistema de compila√ß√£o consiste em um conjunto de scripts que primeiro preparam o host para a compila√ß√£o, baixam componentes de terceiros, como buildroot, mosquitto, daemon DLT, de seus reposit√≥rios, compilam e colocam em seus lugares.  E ent√£o voc√™ pode iniciar a constru√ß√£o do seu projeto.  Se a constru√ß√£o sob o host n√£o for dif√≠cil de executar, voc√™ sempre precisar√° mexer com a constru√ß√£o sob o destino, e seria melhor se o script fizesse isso. <br><br>  O Buildroot pode ser configurado para chamar um script p√≥s-build ap√≥s formar rootfs, que estar√° no buildroot / output / target.  Isso oferece uma √≥tima oportunidade de colocar tudo o que voc√™ precisa l√°.  E ent√£o, a imagem do sistema de arquivos j√° conter√° tudo o que voc√™ precisa para iniciar o sistema. <br><br>  A receita √© algo como isto: <br><br><ol><li>  voc√™ precisa copiar seus bin√°rios em algum lugar em buildroot / output / target, por exemplo em / opt / bin </li><li>  se houver configura√ß√µes, fa√ßa o mesmo com elas, apenas em / opt / etc </li><li>  copiar bin√°rios de terceiros, para mim √© mosquitto, DLT daemon, suas bibliotecas e configura√ß√µes </li><li>  Para iniciar o pr√≥prio sistema ao carregar o controlador, √© necess√°rio copiar os servi√ßos do systemd, √© melhor combin√°-los no seu destino e reativ√°-lo, criando um link simb√≥lico para v√°rios usu√°rios. </li><li>  copie o fstab modificado (por que, depois eu digo) </li></ol><br>  Depois disso, basta descompactar buildroot / output / images / rootfs.tar na se√ß√£o desejada do cart√£o SD e ligar a alimenta√ß√£o. <br><br><pre> <code class="plaintext hljs">build git repo: https://github.com/azhigaylo/build</code> </pre> <br>  Escrevendo um n√∫cleo de comunica√ß√£o. <br><br>  O conceito disso √© t√£o antigo quanto o pr√≥prio modbus. <br><br>  Cada dispositivo de E / S em uma rede modbus possui (16 bits) registros dispon√≠veis para leitura, leitura / grava√ß√£o, nos quais os dados s√£o armazenados e atrav√©s dos quais esses dispositivos s√£o controlados.  O controlador, por sua vez, possui matrizes de pontos discretos (status e valor de bytes) e anal√≥gicos (status e valor flutuante), nos quais armazena o estado de todos os par√¢metros. <br><br>  Portanto, a tarefa do n√∫cleo de comunica√ß√£o √© simples - coletar dados de dispositivos de E / S usando o protocolo modbus, mape√°-los para pontos do controlador e fornecer acesso a esses pontos para o n√≠vel superior.  E se voc√™ precisar gerenciar alguma coisa, tudo estar√° na outra dire√ß√£o - o dispositivo l√≥gico (mais sobre isso posteriormente) deve ser inscrito no ponto do controlador e a grava√ß√£o nesse ponto inicia a convers√£o desse par√¢metro no dispositivo f√≠sico de sa√≠da de √°gua. <br><br><img src="https://habrastorage.org/webt/1v/zb/x4/1vzbx4smmroaleak2dy4jol9gno.jpeg"><br><br>  Para estruturar de alguma forma os dados e trabalhar com dispositivos, voc√™ pode introduzir o conceito de um dispositivo l√≥gico que exibir√° o estado de um dispositivo f√≠sico em seu software. <br><br>  Tamb√©m decidi dividir os dispositivos l√≥gicos em dois grupos: <br><br><ol><li>  Padr√£o (m√≥dulos Aries de entrada / sa√≠da discreta), para os quais os n√∫meros de modbus registram dados s√£o conhecidos com anteced√™ncia, e basta determinar os pontos do controlador onde os dados ser√£o salvos. </li><li>  Dispositivos do usu√°rio, para eles √© necess√°rio descrever independentemente o mapeamento dos registradores modbus para os pontos do controlador. </li></ol><br>  De todas as op√ß√µes acima, √© l√≥gico ter algum tipo de configurador para o controlador, seja apenas uma configura√ß√£o json ou uma ferramenta auto-escrita que gera uma configura√ß√£o bin√°ria, qualquer coisa que seja conveniente.  Eu tenho a segunda op√ß√£o, porque havia id√©ias para escrever um n√∫cleo de comunica√ß√£o para que ele pudesse ser executado facilmente n√£o apenas na placa Linux, mas tamb√©m no Arduin com FreeRtos, alterando o n√≠vel PAL no software. <br><br>  No configurador de cada dispositivo, voc√™ precisa definir o n√∫mero da porta do controlador rs485, o endere√ßo do dispositivo e o ponto do controlador no qual o status da comunica√ß√£o com o dispositivo √© exibido, al√©m de cada dispositivo padr√£o em que seus canais s√£o descritos e, para um dispositivo de usu√°rio, seus registros s√£o mapeados para pontos. <br><br><img src="https://habrastorage.org/webt/p7/gh/cu/p7ghcubristizrus5hzq_zlfo5i.jpeg"><br><br><img src="https://habrastorage.org/webt/xr/go/nk/xrgonkcogvsn-6j2vjktiiryrlw.jpeg"><br><br>  Esse arquivo de configura√ß√£o, contendo todos os dados necess√°rios na constru√ß√£o da rede modbus, permite que voc√™ n√£o modifique o c√≥digo fonte do projeto, se precisar adicionar / remover / alterar dispositivos de entrada / sa√≠da, basta alterar os par√¢metros no configurador e salv√°-los no arquivo de configura√ß√£o. <br><br>  Na inicializa√ß√£o, o n√∫cleo de comunica√ß√£o analisa a configura√ß√£o e cria com base em listas de dispositivos l√≥gicos para cada porta rs485 do controlador, em seguida, os threads s√£o criados em cada porta e uma pesquisa c√≠clica de dispositivos f√≠sicos √© iniciada. <br><br><pre> <code class="plaintext hljs">core git repo: https://github.com/azhigaylo/homebrain_core</code> </pre> <br>  Escrevendo o gateway mqtt. <br><br>  Na verdade - seus pontos de controle, discretos e anal√≥gicos, com uma interface propriet√°ria para acesso a eles, s√£o de pouco interesse para ningu√©m.  Portanto, h√° apenas uma sa√≠da - mqtt.  Acho que n√£o exagerarei se disser que atualmente √© o protocolo mais comum para a troca de pequenas mensagens, al√©m de ser muito simples e compreens√≠vel de usar.  Ent√£o, quando eu precisava transmitir dados do controlador - n√£o pensei muito sobre o que usar. <br><br><img src="https://habrastorage.org/webt/o_/sf/w0/o_sfw0yj5i-ptu7ohxdqdvnmw68.jpeg"><br><br>  Porque  Eu tenho muitos par√¢metros, sempre houve confus√µes no arquivo de configura√ß√£o do gateway, onde o mapeamento do controlador aponta para os t√≥picos do gateway mqtt foi registrado.  O Google ajudou a tabela e gravou um analisador csv dessa tabela no arquivo de configura√ß√£o json do gateway. <br><br><img src="https://habrastorage.org/webt/b-/wt/zm/b-wtzmutugygf-_8mj5odnnrguw.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio git de gateway</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">analisador git repo</a> <br><br>  Monitor de ponto de escrita. <br><br>  √Äs vezes, √© muito √∫til ver o que est√° acontecendo com os pontos do controlador. Para isso, escrevi um pequeno aplicativo que se conecta diretamente ao n√∫cleo da comunica√ß√£o e l√™ o status de pontos discretos e anal√≥gicos.  Eu sou muito firme com a interface do usu√°rio, ent√£o, de alguma forma, pude lan√ßar o aplicativo no QML, ele funcionou com um rangido, voc√™ pode contar o ponto, pode escrever, mas n√£o preciso de mais. <br><br><pre> <code class="plaintext hljs">pointmonitor git repo: https://github.com/azhigaylo/pointmonitor</code> </pre> <br>  Monte o sistema de arquivos somente leitura. <br><br>  Geralmente, poucas pessoas prestam aten√ß√£o a isso e, mesmo em projetos de produ√ß√£o, voc√™ pode encontrar dispositivos nos quais a parti√ß√£o com rootfs √© grav√°vel.  Isso mais cedo ou mais tarde leva √† falha de qualquer sistema de arquivos, mesmo o mais est√°vel.  Porque  Como o controlador pode ser desligado a qualquer momento, √© apenas uma quest√£o de tempo / caso quando isso acontece.  Para minimizar essa probabilidade, voc√™ precisa mexer um pouco com o fstab e, antes de criar a imagem rootfs, coloque-a l√°, como descrito acima.  No fstab, primeiro, voc√™ precisa montar o sistema de arquivos como somente leitura e, segundo, tudo o que pode mudar pode ser mapeado no tmpfs. <br><br>  Meu fstab √© este, pode ser diferente para voc√™: <br><br><pre> <code class="plaintext hljs">/dev/root / auto ro 0 1 tmpfs /tmp tmpfs nodev,nosuid,size=50M 0 0 tmpfs /srv tmpfs nodev,size=50M 0 0 tmpfs /var/log tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/tmp tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/run tmpfs defaults,noatime,size=50M 0 0 tmpfs /var/lib tmpfs defaults,noatime,size=10M 0 0</code> </pre> <br>  Corpo do controlador <br><br>  H√° muito tempo, uma impressora 3D √© inclu√≠da nas se√ß√µes do cabe√ßalho de cada engenheiro coletivo de agricultores, infelizmente eu n√£o a tenho, mas ela est√° funcionando.  Recentemente, a empolga√ß√£o de outros funcion√°rios por ele desapareceu. Eu uso isso ao imprimir tudo o que preciso e o que n√£o preciso; voc√™ pode se convencer disso lendo o meu post anterior. <br><br>  Desenhamos no FreeCAD, geramos o gcode no Cura e obtemos um estojo, sem esquecer de fazer assentos para o quadro, recortes para conectores e refrigera√ß√£o e hipotecas para clipes em um trilho din√¢mico. <br><br><img src="https://habrastorage.org/webt/7m/yc/y6/7mycy6gz9axqfvspdk_cmyz5oc8.jpeg"><br><br><img src="https://habrastorage.org/webt/j5/i3/dv/j5i3dvtfcb8wkpn1t0uphq7d9lg.jpeg"><br><br>  Bem, isso √© tudo, agora temos uma placa, software em um cart√£o SD e um gabinete.  Pegamos um arquivo (n√£o estou brincando) e conectamos tudo, conectamos a alimenta√ß√£o, os cabos RS485 e tudo come√ßa a funcionar.  E voc√™ disse dif√≠cil, dif√≠cil ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462259/">https://habr.com/ru/post/pt462259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462243/index.html">Aprimorando o desempenho do front-end do Magento com o ReactJS</a></li>
<li><a href="../pt462245/index.html">auto git bisect como um exemplo do kernel do Linux</a></li>
<li><a href="../pt462251/index.html">O modo de navega√ß√£o an√¥nima no navegador √© uma fic√ß√£o?</a></li>
<li><a href="../pt462253/index.html">As primeiras experi√™ncias usando o protocolo de streaming no exemplo de comunica√ß√£o de CPU e processador no FPGA Redd</a></li>
<li><a href="../pt462257/index.html">Kafka em Kubernetes - isso √© bom?</a></li>
<li><a href="../pt462263/index.html">Pedal no ch√£o: crie outro manipulador de p√© para PC</a></li>
<li><a href="../pt462265/index.html">Python e cubos</a></li>
<li><a href="../pt462267/index.html">Conhe√ßa o PVS-Studio Static Analyzer for Java</a></li>
<li><a href="../pt462269/index.html">John Romero para Doom: 80s Game Dev</a></li>
<li><a href="../pt462271/index.html">C√≥digo de bloqueio no iOS: como a Apple mudou de defesa em defesa para proteger uma √∫nica fronteira</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>