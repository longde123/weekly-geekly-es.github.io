<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèª üë©üèΩ‚Äçü§ù‚Äçüë®üèæ üë©üèΩ‚Äçü§ù‚Äçüë©üèº Cach√© de reserva sin dolor en Scala üíû üöÄ ü¶Ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En arquitecturas grandes o de microservicios, el servicio m√°s importante no siempre es el m√°s productivo y, en ocasiones, no est√° destinado a cargas e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cach√© de reserva sin dolor en Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/466295/">  En arquitecturas grandes o de microservicios, el servicio m√°s importante no siempre es el m√°s productivo y, en ocasiones, no est√° destinado a cargas elevadas.  Estamos hablando del backend.  Funciona lentamente: pierde tiempo en el procesamiento de datos y espera una respuesta entre este y el DBMS, y no escala.  Incluso si la aplicaci√≥n en s√≠ se escala f√°cilmente, este cuello de botella no se escala en absoluto.  ¬øC√≥mo resolver este problema y garantizar un alto rendimiento?  ¬øC√≥mo proporcionar una respuesta del sistema cuando las fuentes importantes de informaci√≥n est√°n en silencio? <br><br><img src="https://habrastorage.org/webt/tw/3o/ti/tw3otiqpnki3jcwa8ittvdrpzoc.jpeg"><br><br>  Si su arquitectura cumple totalmente con el manifiesto Reactivo, los componentes de la aplicaci√≥n se escalan indefinidamente con una carga creciente independientemente uno del otro, y resisten la ca√≠da de cualquier nodo: ya sabe la respuesta.  Pero si no, entonces <b>Oleg Nizhnikov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Odomontois</a> ) contar√° c√≥mo se resolvi√≥ el problema de escalabilidad en Tinkoff construyendo su Fallback Cache indolora en Scala sin reescribir la aplicaci√≥n. <br><br>  <i>Nota</i>  <i>El art√≠culo tendr√° un m√≠nimo de c√≥digo Scala y un m√°ximo de principios e ideas generales.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p9j6_nOP4Kk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Backend inestable o lento </h2><br>  Al interactuar con el back-end, la aplicaci√≥n promedio es r√°pida.  Pero el backend hace la mayor parte del trabajo y procesa la mayor parte de los datos internamente; lleva m√°s tiempo.  Se pierde tiempo extra esperando una respuesta de back-end y DBMS.  Incluso si la aplicaci√≥n en s√≠ se escala f√°cilmente, este cuello de botella no se escala en absoluto.  ¬øC√≥mo aliviar la carga en el backend y resolver el problema? <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Su servicio</b> <br></td><td>  <b>Backend</b> <br></td></tr><tr><td>  Tiempo de trabajo neto en cada respuesta: (des) serializaci√≥n, verificaciones, l√≥gica, costos de asincron√≠a <br></td><td>  53 ms <br></td><td>  785ms <br></td></tr><tr><td>  Esperando backend y DBMS <br></td><td>  3015 ms <br></td><td>  1932 ms <br></td></tr><tr><td>  Numero de nodos <br></td><td>  32 <br></td><td>  2 <br></td></tr><tr><td>  Respuesta resumida <br></td><td>  3070 ms <br></td><td>  2702 ms <br></td></tr></tbody></table></div><br><h3>  Cach√© incrustado </h3><br>  La primera idea es tomar datos para leer, solicitudes que reciben datos y configurar el cach√© al nivel de cada nodo en memoria. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/e7d/18f/e98e7d18f9f43d97f36941011d82b3b4.jpg"><br><br>  El cach√© vive hasta que el nodo se reinicia y almacena solo la √∫ltima pieza de datos.  Si la aplicaci√≥n falla y entran nuevos usuarios que no han estado en la √∫ltima hora, d√≠a o semana, la aplicaci√≥n no puede hacer nada al respecto. <br><br><h3>  Proxy </h3><br>  La segunda opci√≥n es un proxy, que toma parte de las solicitudes o modifica la aplicaci√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ff/817/a49/7ff817a49b919c269c55e9995eaca4f0.jpg"><br><br>  Pero en proxy, no puede hacer todo el trabajo para la aplicaci√≥n en s√≠. <br><br><h3>  Base de datos de cach√© </h3><br>  La tercera opci√≥n es complicada cuando la parte de los datos que devuelve el back-end se puede almacenar durante mucho tiempo.  Cuando son necesarios, mostramos al cliente, incluso si ya no son relevantes.  Esto es mejor que nada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/024/8a3/72f/0248a372f78828298f116a711321a55f.jpg"><br><br>  Esta decisi√≥n ser√° discutida. <br><br><h2>  Cach√© de reserva </h2><br>  Esta es nuestra biblioteca  Est√° incrustado en la aplicaci√≥n y se comunica con el backend.  Con un refinamiento m√≠nimo, analiza la estructura de datos, genera formatos de serializaci√≥n y, con la ayuda del algoritmo del disyuntor, aumenta la tolerancia a fallas.  La serializaci√≥n efectiva se puede implementar en cualquier idioma donde los tipos se puedan analizar de antemano si se definen de forma suficientemente estricta. <br><br><h3>  Componentes </h3><br>  Nuestra biblioteca se parece a esto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/57c/ce0/90657cce0e43cbaf09ba1a38b3e8eaff.jpg"><br><br>  La parte izquierda est√° dedicada a interactuar con este repositorio, que incluye dos componentes importantes: <br><br><ul><li>  el componente responsable del proceso de inicializaci√≥n: acciones preliminares con el DBMS antes de usar Fallback Cache; <br></li><li>  M√≥dulo de generaci√≥n de serializaci√≥n autom√°tica. <br></li></ul><br>  El lado derecho es la funcionalidad general que se relaciona con Fallback. <br><br>  ¬øC√≥mo funciona todo?  Hay consultas en el medio de la aplicaci√≥n y tipos intermedios para almacenar el estado.  Este formulario expresa los datos que recibimos del servidor para una o m√°s solicitudes.  Enviamos los par√°metros a nuestro m√©todo y obtenemos los datos desde all√≠.  Estos datos deben ser serializados de alguna manera para poder almacenarse, por lo que los envolvemos en c√≥digo.  Un m√≥dulo separado es responsable de esto.  Utilizamos el patr√≥n del disyuntor. <br><br><h3>  Requisitos de almacenamiento </h3><br>  <b>Larga vida √∫til: 30-500 d√≠as</b> .  Algunas acciones pueden llevar mucho tiempo, y todo este tiempo es necesario para almacenar datos.  Por lo tanto, queremos un almacenamiento que pueda almacenar datos durante mucho tiempo.  En memoria no es adecuado para esto. <br><br>  <b>Gran volumen de datos: 100 GB-20 TB</b> .  Queremos almacenar docenas de terabytes de datos en el cach√©, y a√∫n m√°s debido al crecimiento.  Mantener todo esto en la memoria es ineficiente: la mayor√≠a de los datos no se solicitan constantemente.  Mienten mucho tiempo, esperando a su usuario, que entrar√° y preguntar√°.  En la memoria no cae bajo estos requisitos. <br><br>  <b>Alta disponibilidad de datos</b> .  Al servicio le puede pasar cualquier cosa, pero queremos que el DBMS permanezca disponible todo el tiempo. <br><br>  <b>Bajos costos de almacenamiento</b> .  Enviamos datos adicionales al cach√©.  Como resultado, se produce una sobrecarga.  Al implementar nuestra soluci√≥n, queremos minimizarla. <br><br>  <b>Soporte para consultas a intervalos</b> .  Nuestra base de datos deber√≠a haber podido extraer un dato no solo en su totalidad, sino a intervalos: una lista de acciones, el historial de un usuario durante un per√≠odo determinado.  Por lo tanto, un valor clave puro no es adecuado. <br><br><h3>  Supuestos </h3><br>  Los requisitos limitan la lista de candidatos.  Suponemos que hemos implementado el resto, y hacemos las siguientes suposiciones, sabiendo por qu√© exactamente necesitamos Fallback Cache. <br><br>  <b>No se requiere integridad de datos entre dos solicitudes GET diferentes</b> .  Por lo tanto, si muestran dos estados diferentes que no son consistentes entre s√≠, lo soportaremos. <br><br>  <b>No se requiere relevancia ni invalidaci√≥n de datos</b> .  En el momento de la solicitud, se supone que tenemos la √∫ltima versi√≥n que estamos mostrando. <br><br>  Enviamos y recibimos datos del backend.  <b>La estructura de estos datos se conoce de antemano</b> . <br><br><h2>  Selecci√≥n de almacenamiento </h2><br>  Como alternativas, consideramos tres opciones principales. <br><br>  El primero es <b>Cassandra</b> .  Ventajas: alta disponibilidad, f√°cil escalabilidad y mecanismo de serializaci√≥n integrado con la colecci√≥n UDT. <br><br>  <b>UDT</b> o <b>tipos definidos por el usuario</b> , significa alg√∫n tipo.  Le permiten apilar eficientemente tipos estructurados.  Los campos de tipo se conocen de antemano.  Estos campos de serializaci√≥n est√°n marcados con etiquetas separadas como en Protocol Buffers.  Despu√©s de leer esta estructura, es posible comprender qu√© campos hay en funci√≥n de las etiquetas.  Suficientes metadatos para averiguar su nombre y tipo. <br><br>  Otra ventaja de Cassandra es que, adem√°s de la clave de partici√≥n, tiene una <b>clave de agrupaci√≥n</b> adicional.  Esta es una clave especial, debido a que los datos se ordenan en un nodo.  Esto le permite implementar una opci√≥n como consultas de intervalo. <br><br>  Cassandra ha existido por un tiempo relativamente largo, hay <b>muchas soluciones de monitoreo para ello</b> , y <b>una menos es la JVM</b> .  Esta no es la opci√≥n m√°s productiva para plataformas en las que puede escribir un DBMS.  La JVM tiene problemas con la recolecci√≥n de basura y los gastos generales. <br><br>  La segunda opci√≥n es <b>CouchBase</b> .  Ventajas: accesibilidad de datos, escalabilidad y sin esquema. <br><br>  Con CouchBase, debe pensar menos en la serializaci√≥n.  Esto es tanto un m√°s como un menos: no necesitamos controlar el esquema de datos.  Existen √≠ndices globales que le permiten ejecutar consultas de intervalo de forma global en un cl√∫ster. <br><br>  CouchBase es un h√≠brido donde <b>Memcache se</b> agrega a un DBMS habitual <b>: cach√© r√°pido</b> .  Le permite almacenar autom√°ticamente en cach√© todos los datos en el nodo, el m√°s caliente, con una disponibilidad muy alta.  Gracias a su cach√©, CouchBase puede ser r√°pido si se solicitan los mismos datos con mucha frecuencia. <br><br>  <b>Sin esquema</b> y <b>JSON</b> tambi√©n pueden ser un signo menos.  Los datos pueden almacenarse durante tanto tiempo que la aplicaci√≥n tenga tiempo de cambiar.  En este caso, la estructura de datos que CouchBase va a almacenar y leer tambi√©n cambiar√°.  La versi√≥n anterior puede no ser compatible.  Solo aprender√° sobre esto cuando lea, y no cuando desarrolle datos, cuando se encuentren en alg√∫n lugar de la producci√≥n.  Tenemos que pensar en una migraci√≥n adecuada, y esto es exactamente lo que no queremos hacer. <br><br>  La tercera opci√≥n es <b>Tarantool</b> .  Es famoso por su s√∫per velocidad.  Tiene un maravilloso motor LUA que le permite escribir un mont√≥n de l√≥gica que se ejecutar√° directamente en el servidor en LuaJit. <br><br>  Por otro lado, este es un valor clave modificado.  Los datos se almacenan en tuplas.  Necesitamos pensar por nosotros mismos en la serializaci√≥n correcta, esto no siempre es una tarea obvia.  Tarantool tambi√©n tiene un enfoque espec√≠fico para la <b>escalabilidad</b> .  Lo que est√° mal con √©l, lo discutiremos m√°s a fondo. <br><br><h3>  Fragmentaci√≥n / replicaci√≥n </h3><br>  Quiz√°s nuestra aplicaci√≥n necesite <b>Sharding / Replication</b> .  Tres repositorios los implementan de manera diferente. <br><br>  Cassandra sugiere una estructura que generalmente se llama un "anillo". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/b22/828/387b228289ece281dd70ecea2ded8890.jpg"><br><br>  Muchos nodos est√°n disponibles.  Cada uno de ellos almacena sus datos y los datos de los nodos m√°s cercanos como r√©plicas.  Si uno abandona, los nodos a su lado pueden servir parte de sus datos hasta que aumente el abandono. <br><br>  Sharding \ Replication es responsable de la misma estructura.  Para desempaquetar en 10 piezas y factor de replicaci√≥n 3, 10 nodos son suficientes.  Cada uno de los nodos almacenar√° 2 r√©plicas de las vecinas. <br><br>  En CouchBase, la estructura de interacci√≥n entre nodos se estructura de manera similar: <br><br><ul><li>  hay datos que est√°n marcados como activos, de los cuales el nodo mismo es responsable; <br></li><li>  Hay r√©plicas de nodos vecinos que almacena CouchBase. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/296/09a/1c8/29609a1c8391653566cb36ab9434da21.jpg"><br><br>  Si un nodo se cae, los vecinos, los compartidos, se responsabilizan del mantenimiento de esta parte de las claves. <br><br>  En Tarantool, la arquitectura es similar a MongoDB.  Pero con un matiz: hay grupos de particiones que se replican entre s√≠. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/5f8/5a5/e815f85a59d330b8250071def6cc0d25.jpg"><br><br>  Para las dos arquitecturas anteriores, si queremos hacer 4 fragmentos y el factor de replicaci√≥n 3, se requieren 4 nodos.  Para Tarantool - 12!  Pero la desventaja se compensa con la velocidad que garantiza Tarantool. <br><br><h2>  Cassandra </h2><br>  Los m√≥dulos opcionales para fragmentaci√≥n en Tarantool aparecieron recientemente.  Por lo tanto, elegimos el DBMS Cassandra como el principal candidato.  Recordemos que hablamos sobre su serializaci√≥n espec√≠fica. <br><br><h3>  Serializaci√≥n autom√°tica </h3><br><blockquote>  El protocolo SQL supone que es bastante libre de definir un esquema de datos. </blockquote><br>  Puedes usar esto como una ventaja.  Por ejemplo, serialice datos para que los nombres de campo largos de nuestras estructuras frondosas no se almacenen cada vez en nuestros valores.  En este caso, tendremos algunos metadatos que describen el dispositivo de datos.  Los UDT tambi√©n indican qu√© campos corresponden a etiquetas y etiquetas. <br><br>  Por lo tanto, la serializaci√≥n generada autom√°ticamente tiene lugar aproximadamente de la misma manera.  Si tenemos uno de los tipos b√°sicos que pueden coincidir con el tipo de la base de datos uno a uno, lo hacemos.  Un conjunto de tipos Int, Long, String, Double tambi√©n est√° en Cassandra. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de datos de la aplicaci√≥n</b> <br></td><td>  <b>Tipo de datos en cassandra</b> <br></td></tr><tr><td>  Tipo primitivo <br>  (Int, Long, String, Double, BigDecimal) <br></td><td>  Tipo primitivo <br>  (int, biging, texto, doble, decimal) <br></td></tr></tbody></table></div><br>  Si se encuentra un campo opcional en alguna estructura, no hacemos nada extra.  Le indicamos el tipo en el que debe convertirse este campo.  La estructura almacenar√° nulo.  Si encontramos nulo en la estructura en el nivel de deserializaci√≥n, asumimos que esta es la ausencia de un valor. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de datos de la aplicaci√≥n</b> <br></td><td>  <b>Tipo de datos en cassandra</b> <br></td></tr><tr><td>  Opci√≥n [A] <br></td><td>  un <br></td></tr></tbody></table></div><br>  Todos los tipos de colecci√≥n de la colecci√≥n en Scala se convierten a la lista de tipos.  Estas son colecciones ordenadas que tienen un elemento de coincidencia de √≠ndice. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de datos de la aplicaci√≥n</b> <br></td><td>  <b>Tipo de datos en cassandra</b> <br></td></tr><tr><td>  Seq [A], Lista [A], Secuencia [A], Vector [A] <br></td><td>  &lt;lista "a" congelada&gt; <br></td></tr></tbody></table></div><br>  Las colecciones de conjuntos sin ordenar garantizan que hay exactamente un elemento con cada valor.  Cassandra tambi√©n tiene un tipo de set especial para ellos. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de datos de la aplicaci√≥n</b> <br></td><td>  <b>Tipo de datos en cassandra</b> <br></td></tr><tr><td>  Establecer [A] <br></td><td>  congelado &lt;conjunto "a"&gt; <br></td></tr></tbody></table></div><br>  Lo m√°s probable es que tengamos muchos mapas (), especialmente con las teclas de cadena.  Cassandra tiene un tipo de mapa especial para ellos.  Tambi√©n est√° escrito y tiene dos par√°metros de tipo.  Para que podamos crear un tipo apropiado para cualquier clave <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de datos de la aplicaci√≥n</b> <br></td><td>  <b>Tipo de datos en cassandra</b> <br></td></tr><tr><td>  Mapa [K, V] <br></td><td>  congelado &lt;mapa "k, v"&gt; <br></td></tr></tbody></table></div><br>  Hay tipos de datos que nos definimos en nuestra aplicaci√≥n.  En muchos idiomas se denominan <b>tipos de datos algebraicos</b> .  Se definen definiendo un producto con nombre de tipos, es decir, una estructura.  Asignamos esta estructura al tipo definido por el usuario.  Cada campo de la estructura corresponder√° a un campo en el UDT. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de datos de la aplicaci√≥n</b> <br></td><td>  <b>Tipo de datos en cassandra</b> <br></td></tr><tr><td>  Tipo de producto: clase de caso <br></td><td>  UDT <br></td></tr></tbody></table></div><br>  El segundo tipo es la <b>suma algebraica de tipos</b> .  En este caso, el tipo corresponde a varios subtipos o subespecies previamente conocidos.  Adem√°s, de cierta manera, le asignamos una estructura. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Tipo de datos de la aplicaci√≥n</b> <br></td><td>  <b>Tipo de datos en cassandra</b> <br></td></tr><tr><td>  Tipo Sum: rasgo sellado \ clase <br></td><td>  UDT <br></td></tr></tbody></table></div><br><h3>  El tipo de datos abstracto se traduce a UDT </h3><br>  Tenemos una estructura y la mostramos uno a uno: para cada campo definimos el campo en el UDT creado en Cassandra: <br><br><pre><code class="plaintext hljs">case class Account ( id: Long, tags: List[String], user: User, finData: Option[FinData] ) create type account ( id bigint, tags: frozen&lt;list&lt;text&gt;&gt;, user frozen&lt;user&gt;, fin_data frozen&lt;fin_data&gt; )</code> </pre> <br>  Los tipos primitivos se convierten en tipos primitivos.  Un enlace a un tipo predefinido antes de que esto se congele.  Este es un contenedor especial en Cassandra, lo que significa que no puede leer de este campo pieza por pieza.  El contenedor est√° "congelado" en este estado.  Solo podemos leer o guardar al usuario, o la lista, como en el caso de las etiquetas. <br><br>  Si nos encontramos con un campo opcional, descartamos esta caracter√≠stica.  Tomamos solo el tipo de datos correspondiente al tipo de campo que ser√°.  Si encontramos no aqu√≠, la ausencia de un valor, escribimos nulo en el campo correspondiente.  Al leer, tambi√©n tomaremos correspondencia no nula. <br><br>  Si nos encontramos con un tipo que tiene varias alternativas conocidas, tambi√©n definimos un nuevo tipo de datos en Cassandra.  Para cada alternativa, un campo en nuestro tipo de datos en UDT. <br><br>  Como resultado, en esta estructura, solo uno de los campos en un momento dado no ser√° nulo.  Si conoci√≥ a alg√∫n tipo de usuario y result√≥ ser una instancia de un moderador en tiempo de ejecuci√≥n, el campo del moderador contendr√° alg√∫n valor, el resto ser√° nulo.  Para admin - admin, el resto - nulo. <br><br>  Esto le permite codificar la estructura de la siguiente manera: tenemos 4 campos opcionales, le garantizamos que solo se escribir√° uno de ellos.  Cassandra usa solo una etiqueta para identificar la presencia de un campo particular en la estructura.  Gracias a esto, obtenemos una estructura de almacenamiento sin gastos generales. <br><br>  De hecho, para guardar el tipo de usuario, si es un moderador, tomar√° la misma cantidad de bytes necesarios para almacenar el moderador.  M√°s un byte para mostrar qu√© alternativa particular est√° presente aqu√≠. <br><br><h3>  Inicializaci√≥n </h3><br><blockquote>  La inicializaci√≥n es un procedimiento preliminar que debe completarse antes de que podamos usar nuestro respaldo. </blockquote><br>  ¬øC√≥mo funciona este proceso? <br><br><ul><li>  En cada nodo generamos definiciones de tablas, tipos y textos de consulta basados ‚Äã‚Äãen los tipos que se presentan. <br></li><li>  Lea el esquema actual del DBMS.  En Cassandra, esto es f√°cil de hacer simplemente conect√°ndose a √©l.  Cuando est√° conectado, en casi todos los controladores, el objeto "sesi√≥n" mismo bombea los metadatos del espacio clave al que est√° conectado.  Entonces puedes ver lo que tienen. <br></li><li>  Revisamos los metadatos, comparamos y verificamos que todo lo que queremos crear est√© permitido y que la migraci√≥n incremental sea posible. <br></li><li>  Si todo es normal y la inicializaci√≥n es posible, realizamos la migraci√≥n. <br></li><li>  Estamos preparando solicitudes. <br></li></ul><br><pre> <code class="plaintext hljs">sealed trait User case class Anonymous extends User case class Registered extends User case class Moderator extends User case class Admin extends User create type user ( anonymous frozen&lt;anonymous&gt;, registered frozen&lt;registered&gt;, moderator frozen&lt;moderator&gt;, admin frozen&lt;admin&gt; )</code> </pre> <br>  Sucede as√≠.  Tenemos <b>tipos</b> , <b>tablas</b> y <b>consultas</b> .  Los tipos dependen de otros tipos, los de otros.  Las tablas dependen de estos tipos.  Las consultas ya dependen de las tablas de las que leen los datos.  La inicializaci√≥n verificar√° todas estas dependencias y crear√° en el DBMS todo lo que pueda crear, de acuerdo con ciertas reglas. <br><br><h3>  Tipo de migraci√≥n </h3><br>  ¬øC√≥mo determinar que un tipo se puede migrar gradualmente? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/eeb/554/105eeb554bcc5eadaf10753f8c150531.jpg"><br><br><ul><li>  Leemos c√≥mo se define este tipo en el DBMS. <br></li><li>  Si no existe ese tipo, es decir, se nos ocurri√≥ uno nuevo: lo creamos. <br></li><li>  Si tal tipo ya existe, estamos tratando de comparar campo por campo la definici√≥n existente con la que queremos dar a este tipo. <br></li><li>  Si resulta que queremos agregar solo unos pocos campos que ya no existen, lo hacemos.  Cree una lista de operaciones ALTER TYPE mutantes e in√≠cielas. <br></li><li>  Si resulta que tenemos alg√∫n tipo de campo que era de un tipo diferente, generamos un error.  Por ejemplo, hab√≠a una lista, se convirti√≥ en un mapa, o hab√≠a un enlace a un tipo definido por el usuario, y estamos tratando de hacerlo diferente. <br></li></ul><br>  El desarrollador puede ver este error incluso antes de iniciar la funcionalidad en producci√≥n.  Supongo que exactamente el mismo esquema de datos est√° en su entorno de desarrollo.  √âl ve que de alguna manera cre√≥ un esquema de datos no migrables, y para evitar estos errores, puede anular la serializaci√≥n generada autom√°ticamente, agregar opciones, renombrar campos o todos los tipos y tablas en su conjunto. <br><br><h3>  Inicializaci√≥n: tipos </h3><br>  Imagine que hay varios tipos de definiciones: <br><br><pre> <code class="plaintext hljs">case class Product (id: Long, name: ctring, price: BigDecimal) case class UserOffers (valiDate: LocalDate, offers: Seq[Products]) case class UserProducts (user User, products: Map[Date, Product]) case class UserInfo: UserOffers, products: UserProducts)</code> </pre> <br>  <b>Clase de caso</b> : una clase que contiene un conjunto de campos.  Este es un an√°logo de struct en Rust. <br><br>  Generaremos aproximadamente tales definiciones de datos para cada uno de los 4 tipos, lo que queremos eventualmente aumentar: <br><br><pre> <code class="plaintext hljs">CREATE TYPE product (id bigint, name text, price decimal); CREATE TYPE user_offers (valid_date date, offers frozen&lt;list&lt;frozen&lt;offer&gt;&gt;&gt;); CREATE TYPE user_products (user frozen&lt;user&gt;, products frozen&lt;map&lt;date, frozen&lt;product&gt;&gt;); CREATE TYPE user_jnfo (offers: frozen&lt;user_offers&gt;, products: frozen&lt;user_products&gt;);</code> </pre> <br>  El tipo de ofertas de usuario depende del tipo de oferta, los productos de usuario dependen del tipo de producto, la informaci√≥n de usuario en el segundo y tercer tipo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5bb/e3b/e9d/5bbe3be9d2694677b42b59613305752b.jpg"><br><br>  Tenemos tal dependencia entre tipos, y queremos inicializarla correctamente.  El diagrama muestra que inicializaremos user_offers y user_products en paralelo.  Esto no significa que lanzaremos dos operaciones paralelas.  No, comenzamos todas las declaraciones, todos los an√°lisis secuencialmente, para no crear accidentalmente el mismo tipo en dos hilos paralelos. <br><br>  Pero hay cierto paralelismo a nivel de correcci√≥n de errores.  Si se produce un error de tipo, todo lo que dependa de √©l extraer√° el error original. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/122/93f/0ba/12293f0bab8bd0a8b7e12d092380a5c5.jpg"><br><br>  Si cualquiera de las ramas paralelas genera un error, todo lo que dependa de los datos migrados normalmente se generar√° sin un error.  Si hay m√°s definiciones de tablas, declaraciones preparadas de ellas, podemos inicializar de manera segura esta parte de nuestra cach√© de reserva.  La comunicaci√≥n se perder√° solo con alguna parte de los backends o con alguna funcionalidad.  Los restos se inicializan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/5ec/3a2/a8d5ec3a2483d899c7db16ac56974fe9.jpg"><br><br>  Puede suceder que dos tipos que se inicializan simult√°neamente generen errores diferentes.  En este caso, la funcionalidad que depende de ambos tipos producir√° un tipo de error sumador.  El desarrollador, al inicializar su Fallback en el entorno de desarrollo, recibir√° una lista completa de datos con errores.  Naturalmente, puede solucionarlo aqu√≠ y obtener el error a√∫n m√°s.  Pero no ser√° tal que una rama completamente independiente cierre los errores que podamos obtener, independientemente de esta rama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/e94/4ba/d08e944ba9b210d16f6f6c0b57048051.jpg"><br><br><h3>  Inicializaci√≥n: tablas </h3><br>  A continuaci√≥n creamos las tablas. <br><br><pre> <code class="plaintext hljs">def getOffer (user: User, number: Long): Future[OfferData] create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt;PRIMARY KEY, value frozen&lt;friend_data&gt; )</code> </pre> <br>  Dicha solicitud puede iniciar directamente una solicitud REST o SOAP, crear operaciones adicionales dentro o incluso ejecutar varias solicitudes.  Todo depende de su c√≥digo: c√≥mo organizar√° el c√≥digo ser√° as√≠.  Fallback no analiza por completo lo que sucede dentro del m√©todo en el que cuelgas dicho trozo. <br><br><blockquote>  El m√©todo debe ser as√≠ncrono, porque Fallback es el mismo. </blockquote><br>  En Scala, esto est√° etiquetado con un tipo especial de futuro.  Esto significa que el resultado volver√° alg√∫n d√≠a.  Cu√°ndo exactamente, es desconocido: tal vez de inmediato, o tal vez no. <br><br>  Para el m√©todo, cree una tabla.  La clave en la tabla es una tupla de todos los tipos que corresponden a los par√°metros de este m√©todo.  El valor no clave es el resultado, que se devuelve de forma asincr√≥nica.  Para cada una de esas tablas, preparamos dos consultas param√©tricas por adelantado: insertar datos y leer datos. <br><br><pre> <code class="plaintext hljs">insert into get_offer(key, value) values (?key, ?value); select value from get_offer where key = ?key;</code> </pre> <br>  Todo est√° listo para interactuar con el DBMS.  Queda por descubrir c√≥mo leeremos los datos de Fallback. <br><br><h3>  Disyuntor </h3><br>  Aqu√≠, la responsabilidad pasa a la zona del famoso patr√≥n de disyuntor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c0/de1/91c/5c0de191c5c1699cc8f324f38d62b6ee.jpg"><br><br>  Un disyuntor t√≠pico incluye tres estados. <br><br>  <b>Cerrado: el estado cerrado predeterminado</b> que cierra nuestro backend.  El principio es que primero leemos los datos del backend, y solo si no podemos obtenerlos, vamos a Fallback.  Si logramos obtener los datos, no buscamos en Fallback, sino que guardamos los datos en √©l y no sucede nada. <br><br>  Si los problemas van uno tras otro, asumimos que el servidor est√° mintiendo.  Para no enviar correos no deseados con una cantidad gigantesca de nuevas solicitudes, cambiamos a <b>Abrir, en un estado desgarrado</b> .  En √©l, estamos tratando de leer datos solo de Fallback.  Si no funciona, inmediatamente devolvemos un error, y ni siquiera tocamos el back-end principal. <br><br>  Despu√©s de un tiempo, decidimos averiguar si el backend se despert√≥ e intentamos restablecer el estado <b>Half-Open, un estado de corta duraci√≥n</b> .  Su esperanza de vida es una petici√≥n. <br><br>  En el estado de corta duraci√≥n, elegimos cerrar de nuevo o abrir por un tiempo a√∫n m√°s largo.  Si en el estado Medio abierto llegamos con √©xito a Fallback y recibimos la siguiente solicitud, pasamos al estado Cerrado.  Si no pudimos pasar, volvemos a Open, pero durante mucho tiempo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ad/92e/4a4/9ad92e4a417201c8655ed4785ae21dfc.jpg"><br><br>  Agregamos dos estados adicionales que claramente no est√°n relacionados con el circuito del disyuntor: <br><br><ul><li>  Forzado - estado forzado cerrado; <br></li><li>  Invertido: prioridad para el estado abierto, cerrado invertido. <br></li></ul><br>  Veamos que hacen. <br><br><h3>  El principio de funcionamiento de los estados. </h3><br>  <b>Cerrado</b>  El esquema es grande, pero es suficiente para entender el principio general de √©l.  Mantenemos Fallback en paralelo con la forma en que devolvemos el resultado del backend, si todo sali√≥ bien all√≠ y leemos de Fallback.  Si es malo en todas partes, devolvemos la prioridad de error. <br><br><blockquote>  De los dos errores, seleccione el error del backend. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/541/f99/5b7541f99197cc1730c6a934cebe6516.jpg"><br><br>  Si no hay errores, incrementamos el contador en paralelo con esto y pasamos al estado abierto cuando hay demasiadas solicitudes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/182/18f/25d/18218f25de112cf7f6a88291fccbe72f.jpg"><br><br>  <b>Abierto</b>  El estado abierto de Abrir es m√°s simple: leemos constantemente de Fallback, pase lo que pase, y despu√©s de un tiempo intentamos cambiar al estado Medio abierto. <br><br>  <b>Medio abierto</b> .  El estado en la estructura se asemeja a Cerrado.  La diferencia es que en el caso de una respuesta exitosa, entramos en un estado cerrado.  En caso de falla, volvemos a la apertura con un intervalo extendido. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/a1e/7c8/b82a1e7c89774bbe327613b51f50f5c0.jpg"><br><br>  <b>Forzado es un estado adicional para calentar el cach√©</b> .  Cuando lo llenamos con datos, nunca intenta leer de Fallback, sino que solo agrega registros. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdc/8e3/b33/bdc8e3b335750b826fdd21db6c0f0ac7.jpg"><br><br>  <b>Invertido es un segundo estado descabellado</b> .  Funciona como un cach√© persistente.  Activamos el estado cuando queremos eliminar permanentemente la carga del back-end, incluso si los datos pueden ser irrelevantes.  Invierte las primeras b√∫squedas en Fallback, y si la b√∫squeda falla, va al backend y se ocupa de ello. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/618/0da/8ed/6180da8edf69398780bd37fae9bc8ba7.jpg"><br><br><h3>  Los problemas </h3><br>  Con todo este esquema, tuvimos varios problemas.  La m√°s grave es comprender c√≥mo funcionan las <b>declaraciones preparadas</b> en Cassandra.  Este problema se ha solucionado en la versi√≥n 4.0, que a√∫n no se ha lanzado, as√≠ que te lo dir√©. <br><br>  Cassandra est√° dise√±ada para conectar a millones de clientes al mismo tiempo, y todos est√°n tratando de preparar sus declaraciones preparadas.  Naturalmente, Cassandra no prepara todas las declaraciones preparadas, de lo contrario se quedar√° sin memoria.  Calcula el par√°metro MD5 en funci√≥n del texto, el espacio clave y las opciones de consulta.  Si recibe exactamente la misma solicitud con exactamente el mismo MD5, acepta la solicitud ya preparada.  Ya tiene informaci√≥n sobre metadatos y c√≥mo manejarlo. <br><br>  Pero hay problemas de versi√≥n.  Estamos lanzando una nueva versi√≥n, realiz√≥ migraciones con √©xito, agreg√≥ campos en tipos y ejecut√≥ declaraciones preparadas.  Vuelven con la versi√≥n anterior de nuestro estado y metadatos, con tipos sin campos.  Al momento de leer los datos, estamos tratando de escribir sus nuevas columnas requeridas, ¬°y nos enfrentamos al hecho de que simplemente no existen!  Cassandra dice que este es generalmente un tipo diferente que ella no conoce. <br><br>  Nos ocupamos de este problema de la siguiente manera: <b>agregamos un texto √∫nico a cada una de nuestras solicitudes preparadas</b> . <br><br><pre> <code class="plaintext hljs">create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt; PRIMARY KEY, value frozen&lt;friend_data&gt;, query_tag text ) insert into get_offer (key, value, query_tag) values (?key, ?value, 'tag_123'); select value as tag_123 from get_offer where key = ?key;</code> </pre> <br>  No tendremos millones de clientes conectados, sino solo una sesi√≥n para cada nodo que contenga varias conexiones.  Para cada declaraci√≥n de preparaci√≥n una vez.  Suponemos que est√° bien si para cada versi√≥n de la aplicaci√≥n o para cada inicio de un nodo, se genera un texto √∫nico, que claramente estar√° en el texto de nuestra solicitud. <br><br>  Agregamos un campo especial para enga√±arlo.  Al insertar, escribimos una constante en este campo.  Es √∫nico para cada versi√≥n de lanzamiento o aplicaci√≥n; esto se configura en la biblioteca.  Al leer, usamos este nombre como alias para el valor que obtenemos.  La solicitud es exactamente la misma, todav√≠a estamos haciendo un valor de selecci√≥n, pero el texto es diferente.  Cassandra no se da cuenta de que esta es la misma solicitud, calcula otro MD5 y prepara la solicitud nuevamente con nuevos metadatos. <br><br>  El segundo problema es la <b>carrera migratoria</b> .  Por ejemplo, queremos hacer varias migraciones paralelas.  Comencemos algunas notas y al mismo tiempo comenzar√°n los c√°lculos, ejecutar√°n crear tablas, crear tipos.  Esto puede llevar al hecho de que en cada nodo o en cada uno de los subprocesos paralelos todo ser√° exitoso y dos tablas parecen ser creadas con √©xito.  Pero dentro de Cassandra se confunde, y recibiremos tiempos de espera para escribir y leer. <br><br><blockquote>  Puede romper Cassandra si intenta paralelizar procesos de m√∫ltiples hilos o de m√∫ltiples nodos. </blockquote><br>  Si sabemos que debemos tener una migraci√≥n alternativa, <b>migramos desde un nodo especial antes del lanzamiento</b> .  Solo entonces comenzaremos todos nuestros nodos durante el lanzamiento.  Entonces resolvimos este problema. <br><br>  El tercer problema es la <b>falta de datos en Fallback Cache</b> .  Puede ser que hayamos "respaldado" el m√©todo, deber√≠a almacenar datos hist√≥ricos de hace un a√±o, pero en realidad lo lanzamos ayer. <br><br>  <b>El problema se resolvi√≥ calentando</b> .  Utilizamos el estado Forzado y lanzamos nodos especiales que no se comunicar√°n con usuarios reales.  Tomar√°n todas las claves posibles que suponemos y calentar√°n el cach√© en un c√≠rculo.  El calentamiento va muy r√°pido para no matar el backend del que estamos leyendo. <br><br><blockquote>  Escalado de aplicaciones, backend, big data y frontend: Scala es adecuado para todo esto.  26 de noviembre, estamos celebrando una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conferencia</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para desarrolladores de Scala</a> .  Estilos, enfoques, docenas de soluciones para el mismo problema, los matices del uso de enfoques antiguos y probados, la pr√°ctica de la programaci√≥n funcional, la teor√≠a de la cosmonautica funcional radical: hablaremos de todo esto en la conferencia.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solicite</a> un informe si desea compartir su experiencia Scala antes del 26 de septiembre, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reserve sus boletos</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466295/">https://habr.com/ru/post/466295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466283/index.html">Opencartforum y amigos</a></li>
<li><a href="../466285/index.html">Un peque√±o regalo de promoci√≥n: combo de rifa dvr y detector de radar</a></li>
<li><a href="../466287/index.html">Informe e investigaci√≥n de confiabilidad de los segmentos nacionales de Internet de 2019</a></li>
<li><a href="../466289/index.html">Iniciativas legislativas. Extra√±o, pero presentado a la Duma del Estado</a></li>
<li><a href="../466291/index.html">Encuesta de sostenibilidad de segmentos nacionales de Internet para 2019</a></li>
<li><a href="../466299/index.html">Los soci√≥logos rusos realizaron la primera encuesta de chatbots del mundo</a></li>
<li><a href="../466301/index.html">Algo m√°s: paquetes de aplicaciones Haiku?</a></li>
<li><a href="../466305/index.html">Takashi Kokubun: c√≥mo hacer que las aplicaciones de Ruby se ejecuten m√°s r√°pido</a></li>
<li><a href="../466307/index.html">¬øC√≥mo dise√±o SCS?</a></li>
<li><a href="../466311/index.html">Taller SLS 6 de septiembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>