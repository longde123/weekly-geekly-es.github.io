<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📹 🎖️ ㊗️ 朱莉娅NLP。 我们处理文本 👨‍👩‍👦‍👦 🍎 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="用自然语言对文本进行分析和处理是一项始终不变的主题任务，已经解决，正在解决并且将以所有可用的方式解决。 今天，我想谈谈解决此问题的解决方案工具，即使用Julia语言。 当然，由于该语言的年轻性，因此没有像Java语言这样的发达的分析工具，例如Stanford CoreNLP，Apache OpenN...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>朱莉娅NLP。 我们处理文本</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475922/"><p><img src="https://habrastorage.org/webt/xe/e4/uw/xee4uwgjba6dylvtphbi2jvconu.png"></p><br><p> 用自然语言对文本进行分析和处理是一项始终不变的主题任务，已经解决，正在解决并且将以所有可用的方式解决。 今天，我想谈谈解决此问题的解决方案工具，即使用Julia语言。 当然，由于该语言的年轻性，因此没有像Java语言这样的发达的分析工具，例如Stanford CoreNLP，Apache OpenNLP，GATE等。 但是，即使是已经开发的库也可以用于解决典型问题，也可以推荐给对文字处理领域感兴趣的学生入学。  Julia的语法简单性及其先进的数学工具使您轻松沉浸于文本的聚类和分类任务中。 </p><a name="habracut"></a><br><p> 本文的目的是回顾Julia文字处理工具，并提供一些有关其用法的解释。 我们将在为NLP主题但希望完全了解Julia工具的人员提供的简短机会列表与为决定首次涉足NLP（自然语言处理）领域的人员的详细说明和应用示例之间取得平衡。 </p><br><p> 好了，现在，让我们继续看一下软件包概述。 </p><br><h2 id="textanalysisjl">  TextAnalysis.jl </h2><br><p>  <a href="">TextAnalysis.jl</a>软件包是一个基本库，可实现最少的典型文本处理功能集。 我们从她那里开始。 示例部分取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 </p><br><h3 id="dokument"> 文件 </h3><br><p> 基本实体是文档。 </p><br><p> 支持以下类型： </p><br><ul><li>  FileDocument-由磁盘上的简单文本文件表示的文档 </li></ul><br><pre><code class="julia hljs">julia&gt; pathname = <span class="hljs-string"><span class="hljs-string">"/usr/share/dict/words"</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/share/dict/words"</span></span> julia&gt; fd = FileDocument(pathname) A FileDocument * Language: Languages.English() * Title: /usr/share/dict/words * Author: Unknown Author * Timestamp: Unknown Time * Snippet: AA's AMD AMD's AOL AOL's Aachen Aachen's Aaliyah</code> </pre> <br><ul><li>  StringDocument-由UTF-8字符串表示并存储在RAM中的文档。  StringDocument结构提供了整个文本的存储。 </li></ul><br><pre> <code class="julia hljs">julia&gt; str = <span class="hljs-string"><span class="hljs-string">"To be or not to be..."</span></span> <span class="hljs-string"><span class="hljs-string">"To be or not to be..."</span></span> julia&gt; sd = StringDocument(str) A StringDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>} * Language: Languages.English() * Title: Untitled Document * Author: Unknown Author * Timestamp: Unknown Time * Snippet: To be or not to be...</code> </pre> <br><ul><li>  TokenDocument-一个由UTF-8令牌（突出显示的单词）组成的文档。  <code>TokenDocument</code>结构存储一组令牌，但是，完整的文本将无法恢复而不会丢失。 </li></ul><br><pre> <code class="julia hljs">julia&gt; my_tokens = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>[<span class="hljs-string"><span class="hljs-string">"To"</span></span>, <span class="hljs-string"><span class="hljs-string">"be"</span></span>, <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-string"><span class="hljs-string">"not"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span>, <span class="hljs-string"><span class="hljs-string">"be..."</span></span>] <span class="hljs-number"><span class="hljs-number">6</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"To"</span></span> <span class="hljs-string"><span class="hljs-string">"be"</span></span> <span class="hljs-string"><span class="hljs-string">"or"</span></span> <span class="hljs-string"><span class="hljs-string">"not"</span></span> <span class="hljs-string"><span class="hljs-string">"to"</span></span> <span class="hljs-string"><span class="hljs-string">"be..."</span></span> julia&gt; td = TokenDocument(my_tokens) A TokenDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>} * Language: Languages.English() * Title: Untitled Document * Author: Unknown Author * Timestamp: Unknown Time * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code> </pre> <br><ul><li>  NGramDocument-以UTF8表示形式的一组<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">n-gram</a>表示的文档，即<code>n</code> UTF-8字符的序列，以及一个出现它们的计数器。 呈现文档的此选项是避免分析的文本中出现语言形态，拼写错误以及语言结构特征的某些最简单方法之一。 但是，与考虑语言信息的方法相比，这样做的代价是降低了文本分析的质量。 </li></ul><br><pre> <code class="julia hljs">julia&gt; my_ngrams = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}(<span class="hljs-string"><span class="hljs-string">"To"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"be"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"or"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"not"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"be..."</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">6</span></span> entries: <span class="hljs-string"><span class="hljs-string">"or"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"be..."</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"not"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"to"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"To"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"be"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> julia&gt; ngd = NGramDocument(my_ngrams) A NGramDocument{<span class="hljs-built_in"><span class="hljs-built_in">AbstractString</span></span>} * Language: Languages.English() * Title: Untitled Document * Author: Unknown Author * Timestamp: Unknown Time * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code> </pre> <br><p> 或一个简短的选择： </p><br><pre> <code class="julia hljs">julia&gt; str = <span class="hljs-string"><span class="hljs-string">"To be or not to be..."</span></span> <span class="hljs-string"><span class="hljs-string">"To be or not to be..."</span></span> julia&gt; ngd = NGramDocument(str, <span class="hljs-number"><span class="hljs-number">2</span></span>) NGramDocument{<span class="hljs-built_in"><span class="hljs-built_in">AbstractString</span></span>}(<span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">AbstractString</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>}(<span class="hljs-string"><span class="hljs-string">"To be"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"or not"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"be or"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"or"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"not to"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"not"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"to be"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"to"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"To"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"be"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>…), <span class="hljs-number"><span class="hljs-number">2</span></span>, TextAnalysis.DocumentMetadata( Languages.English(), <span class="hljs-string"><span class="hljs-string">"Untitled Document"</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown Author"</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown Time"</span></span>))</code> </pre> <br><p> 也可以使用通用的Document构造函数简单地创建文档，并且库将找到该文档的适当实现。 </p><br><pre> <code class="julia hljs">julia&gt; Document(<span class="hljs-string"><span class="hljs-string">"To be or not to be..."</span></span>) A StringDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>} * Language: Languages.English() * Title: Untitled Document * Author: Unknown Author * Timestamp: Unknown Time * Snippet: To be or not to be... julia&gt; Document(<span class="hljs-string"><span class="hljs-string">"/usr/share/dict/words"</span></span>) A FileDocument * Language: Languages.English() * Title: /usr/share/dict/words * Author: Unknown Author * Timestamp: Unknown Time * Snippet: AA's AMD AMD's AOL AOL's Aachen Aachen's Aaliyah julia&gt; Document(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>[<span class="hljs-string"><span class="hljs-string">"To"</span></span>, <span class="hljs-string"><span class="hljs-string">"be"</span></span>, <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-string"><span class="hljs-string">"not"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span>, <span class="hljs-string"><span class="hljs-string">"be..."</span></span>]) A TokenDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>} * Language: Languages.English() * Title: Untitled Document * Author: Unknown Author * Timestamp: Unknown Time * Snippet: ***SAMPLE TEXT NOT AVAILABLE*** julia&gt; Document(<span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>}(<span class="hljs-string"><span class="hljs-string">"a"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>)) A NGramDocument{<span class="hljs-built_in"><span class="hljs-built_in">AbstractString</span></span>} * Language: Languages.English() * Title: Untitled Document * Author: Unknown Author * Timestamp: Unknown Time * Snippet: ***SAMPLE TEXT NOT AVAILABLE***</code> </pre> <br><p> 如您所见，文档的主体由文本/令牌和元数据组成。 可以使用<code>text(...)</code>方法获取文档的<code>text(...)</code> ： </p><br><pre> <code class="julia hljs">julia&gt; td = TokenDocument(<span class="hljs-string"><span class="hljs-string">"To be or not to be..."</span></span>) TokenDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}([<span class="hljs-string"><span class="hljs-string">"To"</span></span>, <span class="hljs-string"><span class="hljs-string">"be"</span></span>, <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-string"><span class="hljs-string">"not"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span>, <span class="hljs-string"><span class="hljs-string">"be"</span></span>], TextAnalysis.DocumentMetadata( Languages.English(), <span class="hljs-string"><span class="hljs-string">"Untitled Document"</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown Author"</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown Time"</span></span>)) julia&gt; text(td) ┌ Warning: TokenDocument's can only approximate the original text └ @ TextAnalysis ~/.julia/packages/TextAnalysis/pcFQf/src/document.jl:<span class="hljs-number"><span class="hljs-number">111</span></span> <span class="hljs-string"><span class="hljs-string">"To be or not to be"</span></span> julia&gt; tokens(td) <span class="hljs-number"><span class="hljs-number">6</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"To"</span></span> <span class="hljs-string"><span class="hljs-string">"be"</span></span> <span class="hljs-string"><span class="hljs-string">"or"</span></span> <span class="hljs-string"><span class="hljs-string">"not"</span></span> <span class="hljs-string"><span class="hljs-string">"to"</span></span> <span class="hljs-string"><span class="hljs-string">"be"</span></span></code> </pre> <br><p> 该示例演示了带有自动分析的令牌的文档。 我们看到对<code>text(td)</code>的调用<code>text(td)</code>发出警告，指出文本仅被近似还原，因为<code>TokenDocument</code>不存储单词定界符。  <code>tokens(td)</code>的调用<code>tokens(td)</code>使得准确获取突出显示的单词成为可能。 </p><br><p> 您可以从文档中请求元数据： </p><br><pre> <code class="julia hljs">julia&gt; StringDocument(<span class="hljs-string"><span class="hljs-string">"This document has too foo words"</span></span>) A StringDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>} * Language: Languages.English() * Title: Untitled Document * Author: Unknown Author * Timestamp: Unknown Time * Snippet: This document has too foo words julia&gt; language(sd) Languages.English() julia&gt; title(sd) <span class="hljs-string"><span class="hljs-string">"Untitled Document"</span></span> julia&gt; author(sd) <span class="hljs-string"><span class="hljs-string">"Unknown Author"</span></span> julia&gt; timestamp(sd) <span class="hljs-string"><span class="hljs-string">"Unknown Time"</span></span></code> </pre> <br><p> 所有这些都可以通过相应的功能进行更改。 在Julia中修改功能的符号与Ruby语言中的符号相同。 修改对象的函数具有后缀<code>!</code>  ： </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TextAnalysis.Languages julia&gt; language!(sd, Languages.Russian()) Languages.Russian () julia&gt; title!(sd, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-string"><span class="hljs-string">""</span></span> julia&gt; author!(sd, <span class="hljs-string"><span class="hljs-string">" .."</span></span>) <span class="hljs-string"><span class="hljs-string">" .."</span></span> julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dates:now julia&gt; timestamp!(sd, string(now())) <span class="hljs-string"><span class="hljs-string">"2019-11-09T22:53:38.383"</span></span></code> </pre> <br><h3 id="osobennosti-strok-s-utf-8"> 具有UTF-8的字符串的功能 </h3><br><p>  Julia在处理字符串时支持UTF-8编码，因此使用非拉丁字母没有问题。 任何字符处理选项都是自然可用的。 但是，请记住，Julia的行索引是字节，而不是字符。 每个字符可以用不同数量的字节表示。 并且有使用UNICODE字符的单独方法。 有关详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unicode和UTF-8</a> 。 但这是一个简单的例子。 让我们用数学UNICODE字符设置一行，并用空格将x和y隔开： </p><br><pre> <code class="julia hljs">julia&gt; s = <span class="hljs-string"><span class="hljs-string">"\u2200 x \u2203 y"</span></span> <span class="hljs-string"><span class="hljs-string">"∀ x ∃ y"</span></span> julia&gt; length(s) <span class="hljs-comment"><span class="hljs-comment"># ! 7 julia&gt; ncodeunits(s) # ! 11</span></span></code> </pre><br><p> 现在让我们看一下索引： </p><br><pre> <code class="julia hljs">julia&gt; s[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-string"><span class="hljs-string">'∀'</span></span>: Unicode U+<span class="hljs-number"><span class="hljs-number">2200</span></span> (category Sm: <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>, math) julia&gt; s[<span class="hljs-number"><span class="hljs-number">2</span></span>] ERROR: StringIndexError(<span class="hljs-string"><span class="hljs-string">"∀ x ∃ y"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) [...] julia&gt; s[<span class="hljs-number"><span class="hljs-number">3</span></span>] ERROR: StringIndexError(<span class="hljs-string"><span class="hljs-string">"∀ x ∃ y"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) Stacktrace: [...] julia&gt; s[<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-string"><span class="hljs-string">' '</span></span>: ASCII/Unicode U+<span class="hljs-number"><span class="hljs-number">0020</span></span> (category Zs: Separator, space)</code> </pre> <br><p> 该示例清楚地表明，索引<code>1</code>允许我们获得符号<code>∀</code> 。 但是所有后续索引（包括3）（含3个索引）均导致错误。 并且只有第四个索引产生一个空格，作为字符串中的下一个字符。 但是，要通过字符串中的索引确定字符的边界，有一些有用的函数<code>prevind</code> （上一个索引）， <code>nextind</code> （下一个索引）和<code>thisind</code> （此索引）。 例如，对于上面找到的差距，我们要求上一个的边界在哪里： </p><br><pre> <code class="julia hljs">julia&gt; prevind(s, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p> 我们将索引1作为符号beginning的开头。 </p><br><pre> <code class="julia hljs">julia&gt; thisind(s, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p> 检查索引3并获得相同的有效1。 </p><br><p> 如果我们需要“遍历”所有字符，那么可以通过至少两种简单的方法来完成： <br>  1）使用设计： </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s print(c) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ∀ x ∃ y</code> </pre> <br><p>  2）使用<code>eachindex</code>枚举器： </p><br><pre> <code class="julia hljs">julia&gt; collect(eachindex(s)) <span class="hljs-number"><span class="hljs-number">7</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> eachindex(s) print(s[i]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ∀ x ∃ y</code> </pre> <br><h3 id="predobrabotka-dokumentov"> 文件预处理 </h3><br><p> 如果文档的文本是从某种外部表示形式获得的，则字节流中很可能存在编码错误。 要消除它们，请使用<code>remove_corrupt_utf8!(sd)</code>函数。 论据是上面讨论的文档。 </p><br><p> 处理TextAnalysis包中文档的主要功能是<code>prepare!(...)</code> 。 例如，从文本中删除标点符号： </p><br><pre> <code class="julia hljs">julia&gt; str = StringDocument(<span class="hljs-string"><span class="hljs-string">"here are some punctuations !!!..."</span></span>) julia&gt; prepare!(str, strip_punctuation) julia&gt; text(str) <span class="hljs-string"><span class="hljs-string">"here are some punctuations "</span></span></code> </pre> <br><p> 同样，单词处理中的一个有用步骤是将所有字母都转换为小写，因为这简化了单词之间的进一步比较。 在这种情况下，通常情况下，必须理解，我们可能会丢失有关文本的重要信息，例如，单词是专有名称，或者单词是句子的边界。 但这一切都取决于进一步处理的模型。 小写由<code>remove_case!()</code>函数完成。 </p><br><pre> <code class="julia hljs">julia&gt; sd = StringDocument(<span class="hljs-string"><span class="hljs-string">"Lear is mad"</span></span>) A StringDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>} julia&gt; remove_case!(sd) julia&gt; text(sd) <span class="hljs-string"><span class="hljs-string">"lear is mad"</span></span></code> </pre> <br><p> 在此过程中，我们可以删除无用字，即在信息检索和匹配分析中没有用的无用字。 可以使用<code>remove_words!(…)</code>函数和这些停用词的数组来明确地完成此操作。 </p><br><pre> <code class="julia hljs">julia&gt; remove_words!(sd, [<span class="hljs-string"><span class="hljs-string">"lear"</span></span>]) julia&gt; text(sd) <span class="hljs-string"><span class="hljs-string">" is mad"</span></span></code> </pre> <br><p> 在要删除的单词中，还有冠词，介词，代词，数字和只是停用词，它们的出现频率是寄生的。 对于每种特定语言，这些词典都是单独的。 这些数字设置在Languages.jl包中，数字使我们感到困扰，因为在将来为热文档建模时，它们可以极大地增加矩阵的尺寸，而不会改善例如文本的聚类。 但是，例如在搜索问题中，不再总是可以丢弃数字。 </p><br><p> 可用的清洁方法包括以下选项： </p><br><ul><li> <code>prepare!(sd, strip_articles)</code> </li> <li> <code>prepare!(sd, strip_indefinite_articles)</code> </li> <li> <code>prepare!(sd, strip_definite_articles)</code> </li> <li> <code>prepare!(sd, strip_preposition)</code> </li> <li> <code>prepare!(sd, strip_pronouns)</code> </li> <li> <code>prepare!(sd, strip_stopwords)</code> </li> <li> <code>prepare!(sd, strip_numbers)</code> </li> <li> <code>prepare!(sd, strip_non_letters)</code> </li> <li> <code>prepare!(sd, strip_spares_terms)</code> </li> <li> <code>prepare!(sd, strip_frequent_terms)</code> </li> <li> <code>prepare!(sd, strip_html_tags)</code> </li> </ul><br><p> 选项可以组合。 例如，一个电话<code>prepare!</code> 同时删除文章，数字和html标签- <code>prepare!(sd, strip_articles| strip_numbers| strip_html_tags)</code> </p><br><p> 另一种处理方式是突出显示单词的基础，删除结尾和后缀。 这使您可以组合不同的单词形式，并大大降低文档表示模型的维数。 为此需要使用字典，因此必须明确指出文档的语言。 俄语处理示例： </p><br><pre> <code class="julia hljs">julia&gt; sd = StringDocument(<span class="hljs-string"><span class="hljs-string">"   "</span></span>) StringDocument{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}(<span class="hljs-string"><span class="hljs-string">"   "</span></span>, TextAnalysis.DocumentMetadata(Languages.English(), <span class="hljs-string"><span class="hljs-string">"Untitled Document"</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown Author"</span></span>, <span class="hljs-string"><span class="hljs-string">"Unknown Time"</span></span>)) julia&gt; language!(sd, Languages.Russian()) Languages.Russian() julia&gt; stem!(sd) julia&gt; text(sd) <span class="hljs-string"><span class="hljs-string">"   "</span></span></code> </pre> <br><h3 id="korpus-dokumentov"> 文件主体 </h3><br><p> 语料库被理解为将根据相同规则处理的一组文档。  TextAnalysis包实现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">术语文档</a>矩阵的形成。 对于其构造，我们需要立即拥有一整套文档。 在一个简单的文档示例中： <br> <code>D1 = "I like databases"</code> <br> <code>D2 = "I hate databases"</code> </p> <br><p> 这个矩阵看起来像： </p><br><div class="scrollable-table"><table><thead><tr><th></th><th> 我 </th><th> 喜欢 </th><th> 讨厌 </th><th> 资料库 </th></tr></thead><tbody><tr><td>  D1 </td><td>  1个 </td><td>  1个 </td><td>  0 </td><td>  1个 </td></tr><tr><td>  D2 </td><td>  1个 </td><td>  0 </td><td>  1个 </td><td>  1个 </td></tr></tbody></table></div><br><p> 列由文档的词表示，行是文档的标识符（或索引）。 因此，如果单词（项）未出现在文档中，则该单元格将为0。 如果发生多次则为1。 更复杂的模型会同时考虑出现的频率（TF模型）和相对于整个身体的重要性（TF-IDF）。 </p><br><p> 我们可以使用<code>Corpus()</code>构造函数构建主体： </p><br><pre> <code class="julia hljs">crps = Corpus([StringDocument(<span class="hljs-string"><span class="hljs-string">"Document 1"</span></span>), StringDocument(<span class="hljs-string"><span class="hljs-string">"Document 2"</span></span>)])</code> </pre> <br><p> 如果我们立即请求条款列表，则会得到： </p><br><pre> <code class="julia hljs">julia&gt; lexicon(crps) <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">0</span></span> entries</code> </pre> <br><p> 并且，在这里，使用<code>update_lexicon!(crps)</code>强制库重新计算属于案例的所有术语，我们得到了不同的结果： </p><br><pre> <code class="julia hljs">julia&gt; update_lexicon!(crps) julia&gt; lexicon(crps) <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">3</span></span> entries: <span class="hljs-string"><span class="hljs-string">"1"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"2"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"Document"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p> 也就是说，我们可以在文档正文中看到选定的术语（单词和数字）及其条目数。 </p><br><p> 同时，我们可以澄清术语的频率，例如“文档”： </p><br><pre> <code class="julia hljs">julia&gt; lexical_frequency(crps, <span class="hljs-string"><span class="hljs-string">"Document"</span></span>) <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre> <br><p> 同样，我们可以建立一个反向索引，即针对每个主题，获取案例编号。 当您需要从术语列表中查找文档列表时，该索引用于信息检索： </p><br><pre> <code class="julia hljs">julia&gt; update_inverse_index!(crps) julia&gt; inverse_index(crps) <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}} with <span class="hljs-number"><span class="hljs-number">3</span></span> entries: <span class="hljs-string"><span class="hljs-string">"1"</span></span> =&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-string"><span class="hljs-string">"2"</span></span> =&gt; [<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-string"><span class="hljs-string">"Document"</span></span> =&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre> <br><p> 对于整个案例，您可以应用预处理功能，就像处理每个单独的文档一样。 使用<code>prepare!</code>功能的另一种方法<code>prepare!</code> 考虑较早。 在这里，第一个论点就是这种情况。 </p><br><pre> <code class="julia hljs">julia&gt; crps = Corpus([StringDocument(<span class="hljs-string"><span class="hljs-string">"Document ..!!"</span></span>), StringDocument(<span class="hljs-string"><span class="hljs-string">"Document ..!!"</span></span>)]) julia&gt; prepare!(crps, strip_punctuation) julia&gt; text(crps[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-string"><span class="hljs-string">"Document "</span></span> julia&gt; text(crps[<span class="hljs-number"><span class="hljs-number">2</span></span>]) <span class="hljs-string"><span class="hljs-string">"Document "</span></span></code> </pre> <br><p> 除了单个文档，您还可以请求整个正文的元数据。 </p><br><pre> <code class="julia hljs">julia&gt; crps = Corpus([StringDocument(<span class="hljs-string"><span class="hljs-string">"Name Foo"</span></span>), StringDocument(<span class="hljs-string"><span class="hljs-string">"Name Bar"</span></span>)]) julia&gt; languages(crps) <span class="hljs-number"><span class="hljs-number">2</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{Languages.English,<span class="hljs-number"><span class="hljs-number">1</span></span>}: Languages.English() Languages.English() julia&gt; titles(crps) <span class="hljs-number"><span class="hljs-number">2</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"Untitled Document"</span></span> <span class="hljs-string"><span class="hljs-string">"Untitled Document"</span></span> julia&gt; authors(crps) <span class="hljs-number"><span class="hljs-number">2</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"Unknown Author"</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown Author"</span></span> julia&gt; timestamps(crps) <span class="hljs-number"><span class="hljs-number">2</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"Unknown Time"</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown Time"</span></span></code> </pre> <br><p> 您可以一次为整个主体设置相同的值，也可以为特定文档单独设置一个值，方法是传递一个带有逐元素值的数组。 </p><br><pre> <code class="julia hljs">julia&gt; languages!(crps, Languages.German()) julia&gt; titles!(crps, <span class="hljs-string"><span class="hljs-string">""</span></span>) julia&gt; authors!(crps, <span class="hljs-string"><span class="hljs-string">"Me"</span></span>) julia&gt; timestamps!(crps, <span class="hljs-string"><span class="hljs-string">"Now"</span></span>) julia&gt; languages!(crps, [Languages.German(), Languages.English julia&gt; titles!(crps, [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Untitled"</span></span>]) julia&gt; authors!(crps, [<span class="hljs-string"><span class="hljs-string">"Ich"</span></span>, <span class="hljs-string"><span class="hljs-string">"You"</span></span>]) julia&gt; timestamps!(crps, [<span class="hljs-string"><span class="hljs-string">"Unbekannt"</span></span>, <span class="hljs-string"><span class="hljs-string">"2018"</span></span>])</code> </pre> <br><h3 id="vydelenie-priznakov"> 功能突出 </h3><br><p> 特征提取是机器学习的基本阶段之一。 这与本文的主题没有直接关系，但是在TextAnalysis程序包的文档中，有相当大的一部分专门用于识别这种表示形式中的功能。 该部分实际上包括术语文档矩阵的构造以及许多其他方法。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://juliatext.github.io/TextAnalysis.jl/dev/features/</a> </p><br><p> 我们简要地考虑建议的方案。 </p><br><p> 用于呈现文档的基本模型是其中为每个文档存储一组单词的模型。 而且，它们的位置并不重要。 因此，在英语作家中，此选项称为单词袋。 对于每个单词，只有其存在于文档中的事实，出现频率（TF-术语频率）或考虑整体中该术语出现频率的模型（TF-IDF-术语频率-逆文档频率）才是重要的。 </p><br><p> 以最简单的示例为例，其中三个文档包含术语<code>Document</code> ， <code>3</code> 。 </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TextAnalysis julia&gt; crps = Corpus([StringDocument(<span class="hljs-string"><span class="hljs-string">"Document 1"</span></span>), StringDocument(<span class="hljs-string"><span class="hljs-string">"Document 2"</span></span>), StringDocument(<span class="hljs-string"><span class="hljs-string">"Document 1 3"</span></span>)])</code> </pre> <br><p> 我们将不使用预处理。 但是，我们将建立术语文档的完整词典和矩阵： </p><br><pre> <code class="julia hljs">julia&gt; update_lexicon!(crps) julia&gt; m = DocumentTermMatrix(crps) DocumentTermMatrix( [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"3"</span></span>, <span class="hljs-string"><span class="hljs-string">"Document"</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">"2"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-string"><span class="hljs-string">"Document"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"3"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br><p> 变量<code>m</code>具有类型<code>DocumentTermMatrix</code>的值。 在打印结果中，我们看到维是4个术语的3个文档，其中包括单词<code>Document</code>和数字<code>3</code> 。 为了进一步使用该模型，我们需要传统表示形式的矩阵。 我们可以使用<code>dtm()</code>方法获取它： </p><br><pre> <code class="julia hljs">julia&gt; dtm(m) <span class="hljs-number"><span class="hljs-number">3</span></span>×<span class="hljs-number"><span class="hljs-number">4</span></span> SparseArrays.<span class="hljs-built_in"><span class="hljs-built_in">SparseMatrixCSC</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">7</span></span> stored entries: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p> 此选项由<code>SparseMatrixCSC</code>类型表示，该类型在表示非常稀疏的矩阵时很经济，但是支持它的库数量有限。 术语文档矩阵大小的问题是由于以下事实造成的：术语数量随着处理的文档数量而迅速增长。 如果您不对文档进行预处理，那么绝对所有带有其单词形式，数字，日期的单词都将落入此矩阵。 即使由于减少了主形式而减少了词的形式，剩余词干的数量也将是数千至数万。 即，术语文档矩阵的整个维度由该数量的总乘积与已处理文档的数量确定。 完整矩阵不仅需要存储单位，还需要存储零，但是比<code>SparseMatrixCSC</code>易于使用。 您可以通过另一种方法<code>dtm(..., :dense)</code>或通过使用<code>collect()</code>方法将稀疏矩阵转换为完整的矩阵来获取它： </p><br><pre> <code class="julia hljs">julia&gt; dtm(m, :dense) <span class="hljs-number"><span class="hljs-number">3</span></span>×<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p> 如果您打印一组术语，则在每一行中都可以很容易地看到文档的原始组成（不考虑术语的原始顺序）。 </p><br><pre> <code class="julia hljs">julia&gt; m.terms <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"1"</span></span> <span class="hljs-string"><span class="hljs-string">"2"</span></span> <span class="hljs-string"><span class="hljs-string">"3"</span></span> <span class="hljs-string"><span class="hljs-string">"Document"</span></span></code> </pre> <br><p> 可以使用<code>tf()</code>和<code>tf_idf()</code>方法获得频率模型的术语文档矩阵： </p><br><pre> <code class="julia hljs">julia&gt; tf(m) |&gt; collect <span class="hljs-number"><span class="hljs-number">3</span></span>×<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.5</span></span> <span class="hljs-number"><span class="hljs-number">0.333333</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.333333</span></span> <span class="hljs-number"><span class="hljs-number">0.333333</span></span></code> </pre> <br><p> 很容易看出每个文档中术语的重要性。 前两个文档包含两个术语。 最后是三个。 因此，它们的重量得以减轻。 </p><br><p> 而对于TF-IDF和<code>tf_idf()</code>方法： </p><br><pre> <code class="julia hljs">julia&gt; tdm = tf_idf(m) |&gt; collect <span class="hljs-number"><span class="hljs-number">3</span></span>×<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.202733</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.549306</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.135155</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.366204</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br><p> 在此模型中，很容易看到在所有文档中都找到的术语<code>Document</code>的值为0。但是在第三个文档中，术语<code>3</code>的权重大于在同一文档中的权重，因为在第一个文档中也发现1 。 </p><br><p> 生成的矩阵非常易于使用，例如，用于解决文档聚类的问题。 为此，您需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Clustering包</a> 。 我们使用最简单的k均值聚类算法，该算法需要指定所需聚类的数量。 我们将三个文档分为两个类。  <code>kmeans</code>的输入矩阵是特征矩阵，其中行表示要素，列表示模式。 因此，以上获得的矩阵必须转置。 </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Clustering julia&gt; R = kmeans(tdm', <span class="hljs-number"><span class="hljs-number">2</span></span>; maxiter=<span class="hljs-number"><span class="hljs-number">200</span></span>, display=:iter) Iters objv objv-change | affected ------------------------------------------------------------- <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.386722e-01</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">6.933608e-02</span></span> -<span class="hljs-number"><span class="hljs-number">6.933608e-02</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">6.933608e-02</span></span> <span class="hljs-number"><span class="hljs-number">0.000000e+00</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span> K-means converged with <span class="hljs-number"><span class="hljs-number">2</span></span> iterations (objv = <span class="hljs-number"><span class="hljs-number">0.06933608051588186</span></span>) KmeansResult{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>},<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>}( [<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.16894379504506848</span></span>; <span class="hljs-number"><span class="hljs-number">0.5493061443340549</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.1831020481113516</span></span>; <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">0.03466804025794093</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.03466804025794093</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">0.06933608051588186</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) julia&gt; c = counts(R) <span class="hljs-comment"><span class="hljs-comment">#    2-element Array{Int64,1}: 1 2 julia&gt; a = assignments(R) #     3-element Array{Int64,1}: 2 1 2 julia&gt; M = R.centers #     4×2 Array{Float64,2}: 0.0 0.168944 0.549306 0.0 0.0 0.183102 0.0 0.0</span></span></code> </pre> <br><p> 结果，我们看到第一个群集包含一个文档，群集编号2包含两个文档。 此外，包含<code>R.centers</code>簇中心的矩阵清楚地表明，第一列被术语<code>2</code> “吸引”。 第二列由术语<code>1</code>和<code>3</code>的存在确定。 </p><br><p>  <code>Clustering.jl</code>软件包包含一组典型的聚类算法，其中包括：K-均值，K-medoids，亲和传播，基于噪声的基于应用程序的空间密度聚类（DBSCAN），Markov聚类算法（MCL），模糊C均值聚类，层次聚类（单个，平均，完整，沃德联动）。 但是，对其适用性的分析超出了本文的范围。 </p><br><p>  <code>TextAnalysis.jl</code>软件包目前正在积极开发中，因此，仅当直接从git存储库直接安装该软件包时，某些功能才可用。 做到这一点并不难，但是只能建议那些不打算在不久的将来将该解决方案投入运行的用户： </p><br><pre> <code class="julia hljs">julia&gt; ] (v1<span class="hljs-number"><span class="hljs-number">.2</span></span>) pkg&gt; add https://github.com/JuliaText/TextAnalysis.jl</code> </pre> <br><p> 但是，您不应在审阅中忽略这些功能。 因此，我们也考虑它们。 </p><br><p> 改进之一是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Okapi BM25</a>排名功能。 与以前的<code>tf</code>模型相似。  <code>tf_idf</code> ，我们使用<code>bm_25(m)</code>方法。 所得矩阵的使用与之前的情况类似。 </p><br><p> 可以使用以下方法对文本的音调进行分析： </p><br><pre> <code class="julia hljs">model = SentimentAnalyzer(doc) model = SentimentAnalyzer(doc, handle_unknown)</code> </pre> <br><p> 而且， <code>doc</code>是上述文件类型之一。  <code>handle_unknown</code>用于处理未知单词的函数。 使用基于IMDB包的Flux.jl包可以实现音调分析。 返回值在0到1的范围内。 </p><br><p> 可以使用<code>summarize(d, ns)</code>方法实现文档概括。 第一个参数是文档。 第二个是<code>ns=</code>的句子数。 </p><br><pre> <code class="julia hljs">julia&gt; s = StringDocument(<span class="hljs-string"><span class="hljs-string">"Assume this Short Document as an example. Assume this as an example summarizer. This has too foo sentences."</span></span>) julia&gt; summarize(s, ns=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">2</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">SubString</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"Assume this Short Document as an example."</span></span> <span class="hljs-string"><span class="hljs-string">"This has too foo sentences."</span></span></code> </pre> <br><p> 任何文本分析库的一个非常重要的组成部分是当前正在开发的语法解析器，它可以区分语音部分-POS（语音部分）。 有几种使用它的选项。 有关详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">词性标记。</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  。 之所以称为<code>Tagging</code>是因为对于源文本中的每个单词，都会形成一个标记，这意味着语音的一部分。 </p><br><p> 正在制定两种实施方案。 第一个是平均感知器算法。 第二种基于神经网络架构LSTM，CNN和CRF方法的使用。 这是一个简单句子标记的示例。 </p><br><pre> <code class="julia hljs">julia&gt; pos = PoSTagger() julia&gt; sentence = <span class="hljs-string"><span class="hljs-string">"This package is maintained by John Doe."</span></span> <span class="hljs-string"><span class="hljs-string">"This package is maintained by John Doe."</span></span> julia&gt; tags = pos(sentence) <span class="hljs-number"><span class="hljs-number">8</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"DT"</span></span> <span class="hljs-string"><span class="hljs-string">"NN"</span></span> <span class="hljs-string"><span class="hljs-string">"VBZ"</span></span> <span class="hljs-string"><span class="hljs-string">"VBN"</span></span> <span class="hljs-string"><span class="hljs-string">"IN"</span></span> <span class="hljs-string"><span class="hljs-string">"NNP"</span></span> <span class="hljs-string"><span class="hljs-string">"NNP"</span></span> <span class="hljs-string"><span class="hljs-string">"."</span></span></code> </pre> <br><p> 意思词性的缩写清单取自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">宾州树银行</a> 。 特别是DT-限定词，NN-名词，单数或质量，VBZ-动词，第三人称单数现在，动词，过去分词，IN-介词或从属连词，NNP-专有名词，单数。 </p><br><p> 该标记的结果还可以用作文档分类的附加功能。 </p><br><h3 id="metody-snizheniya-razmernosti"> 降维方法 </h3><br><p>  TextAnalysis提供了两个选项，可通过定义从属术语来减少维数。 这种潜在的语义分析-LSA和潜在的Dirichlet放置-LDA。 </p><br><p>  LSA的主要任务是将术语文档矩阵（使用TF-IDF）分解为3个矩阵，其乘积与原始矩阵大致对应。 </p><br><pre> <code class="julia hljs">julia&gt; crps = Corpus([StringDocument(<span class="hljs-string"><span class="hljs-string">"this is a string document"</span></span>), TokenDocument(<span class="hljs-string"><span class="hljs-string">"this is a token document"</span></span>)]) julia&gt; update_lexicon!(crps) julia&gt; m = DocumentTermMatrix(crps) julia&gt; tf_idf(m) |&gt; collect <span class="hljs-number"><span class="hljs-number">2</span></span>×<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.138629</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.138629</span></span> julia&gt; F2 = lsa(m) SVD{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}}([<span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>], [<span class="hljs-number"><span class="hljs-number">0.138629</span></span>, <span class="hljs-number"><span class="hljs-number">0.138629</span></span>], [<span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> … <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">0.0</span></span> … <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>])</code> </pre> <br><p>    ,    -,  TF-IDF     .    SVD,     ,      . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> LDA</a>           . 一个例子： </p><br><pre> <code class="julia hljs">julia&gt; crps = Corpus([StringDocument(<span class="hljs-string"><span class="hljs-string">"This is the Foo Bar Document"</span></span>), StringDocument(<span class="hljs-string"><span class="hljs-string">"This document has too Foo words"</span></span>)]) julia&gt; update_lexicon!(crps) julia&gt; m = DocumentTermMatrix(crps) julia&gt; k = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment"># number of topics julia&gt; iterations = 1000 # number of gibbs sampling iterations julia&gt; α = 0.1 # hyper parameter julia&gt; β = 0.1 # hyper parameter julia&gt; ϕ, θ = lda(m, k, iterations, α, β) ( [2 , 1] = 0.333333 [2 , 2] = 0.333333 [1 , 3] = 0.222222 [1 , 4] = 0.222222 [1 , 5] = 0.111111 [1 , 6] = 0.111111 [1 , 7] = 0.111111 [2 , 8] = 0.333333 [1 , 9] = 0.111111 [1 , 10] = 0.111111, [0.5 1.0; 0.5 0.0])</span></span></code> </pre> <br><p>  <code>k</code>    <code>lda</code>   ,        .    <code>ϕ</code>  <code>θ</code> ,      <code>ntopics × nwords</code>      ,  — <code>ntopics × ndocs</code>      . </p><br><h3 id="klassifikaciya-dokumentov">   </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>         — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> .        .          ,     .       <code>NaiveBayesClassifier()</code> .    —    <code>fit!()</code> : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TextAnalysis: NaiveBayesClassifier, fit!, predict m = NaiveBayesClassifier([:legal, :financial]) fit!(m, <span class="hljs-string"><span class="hljs-string">"this is financial doc"</span></span>, :financial) fit!(m, <span class="hljs-string"><span class="hljs-string">"this is legal doc"</span></span>, :legal)</code> </pre> <br><p>       <code>predict</code> : </p><br><pre> <code class="julia hljs">julia&gt; predict(m, <span class="hljs-string"><span class="hljs-string">"this should be predicted as a legal document"</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} with <span class="hljs-number"><span class="hljs-number">2</span></span> entries: :legal =&gt; <span class="hljs-number"><span class="hljs-number">0.666667</span></span> :financial =&gt; <span class="hljs-number"><span class="hljs-number">0.333333</span></span></code> </pre> <br><p> ,    ,       <code>:legal</code> . </p><br><p>      TextAnalysis.jl      . ,        .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MLJ.jl</a> .   AdaBoostClassifier, BaggingClassifier, BernoulliNBClassifier, ComplementNBClassifier, ConstantClassifier, XGBoostClassifier, DecisionTreeClassifier.     -     LSA,         .     . </p><br><p>   TextAnalysis.jl    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CRF — Conditional Random Fields</a> ,        Flux.jl,     .       . </p><br><h3 id="raspoznavanie-suschnostey">   </h3><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  TextAnalysis.jl</a>       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">NER</a> .  <code>NERTagger()</code>           : </p><br><ul><li> PER:  </li><li> LOC:   </li><li> ORG:  </li><li> MISC:  </li><li> O:    </li></ul><br><p>  : </p><br><pre> <code class="julia hljs">julia&gt; sentence = <span class="hljs-string"><span class="hljs-string">"This package is maintained by John Doe."</span></span> <span class="hljs-string"><span class="hljs-string">"This package is maintained by John Doe."</span></span> julia&gt; tags = ner(sentence) <span class="hljs-number"><span class="hljs-number">8</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"O"</span></span> <span class="hljs-string"><span class="hljs-string">"O"</span></span> <span class="hljs-string"><span class="hljs-string">"O"</span></span> <span class="hljs-string"><span class="hljs-string">"O"</span></span> <span class="hljs-string"><span class="hljs-string">"O"</span></span> <span class="hljs-string"><span class="hljs-string">"PER"</span></span> <span class="hljs-string"><span class="hljs-string">"PER"</span></span> <span class="hljs-string"><span class="hljs-string">"O"</span></span></code> </pre> <br><p> <code>NERTagger</code>       TextAnalysis.            . </p><br><h2 id="stringdistancesjl"> StringDistances.jl </h2><br><p>      .         , ,  .   .     ,    <a href="">StringDistances.jl</a> .    : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StringDistances compare(<span class="hljs-string"><span class="hljs-string">"martha"</span></span>, <span class="hljs-string"><span class="hljs-string">"martha"</span></span>, Hamming()) <span class="hljs-comment"><span class="hljs-comment">#&gt; 1.0 compare("martha", "marhta", Jaro()) #&gt; 0.9444444444444445 compare("martha", "marhta", Winkler(Jaro())) #&gt; 0.9611111111111111 compare("william", "williams", QGram(2)) #&gt; 0.9230769230769231 compare("william", "williams", Winkler(QGram(2))) #&gt; 0.9538461538461539</span></span></code> </pre> <br><p>   <code>compare</code>  —   . , 1 —  . 0 —  . </p><br><p>      ,   Jaro-Winkler.    ,         .  RatcliffObershelp, ,          .  ,        .   . </p><br><pre> <code class="julia hljs"> compare(<span class="hljs-string"><span class="hljs-string">"mariners vs angels"</span></span>, <span class="hljs-string"><span class="hljs-string">"angels vs mariners"</span></span>, RatcliffObershelp()) <span class="hljs-comment"><span class="hljs-comment">#&gt; 0.44444 compare("mariners vs angels", "angels vs mariners", TokenSort(RatcliffObershelp()) #&gt; 1.0 compare("mariners vs angels", "los angeles angels at seattle mariners", Jaro()) #&gt; 0.559904 compare("mariners vs angels", "los angeles angels at seattle mariners", TokenSet(Jaro())) #&gt; 0.944444 compare("mariners vs angels", "los angeles angels at seattle mariners", TokenMax(RatcliffObershelp())) #&gt; 0.855</span></span></code> </pre> <br><p>   ,       ,     . ,   TokenSort  ,         .    Julia    —     Julia,               . </p><br><h2 id="wordtokenizersjl"> WordTokenizers.jl </h2><br><p>  <a href="">WordTokenizers.jl</a>        .  , ,   TextAnalysis.jl. </p><br><p>     —     . ,    <code>tokenize(text)</code> . </p><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WordTokenizers julia&gt; text = <span class="hljs-string"><span class="hljs-string">"I cannot stand when they say \"Enough is enough.\""</span></span>; julia&gt; tokenize(text) |&gt; print <span class="hljs-comment"><span class="hljs-comment"># Default tokenizer SubString{String}["I", "can", "not", "stand", "when", "they", "say", "``", "Enough", "is", "enough", ".", "''"]</span></span></code> </pre> <br><p>    WordTokenizers     . </p><br><pre> <code class="julia hljs">julia&gt; text = <span class="hljs-string"><span class="hljs-string">"The leatherback sea turtle is the largest, measuring six or seven feet (2 m) in length at maturity, and three to five feet (1 to 1.5 m) in width, weighing up to 2000 pounds (about 900 kg). Most other species are smaller, being two to four feet in length (0.5 to 1 m) and proportionally less wide. The Flatback turtle is found solely on the northerncoast of Australia."</span></span>; julia&gt; split_sentences(text) <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">SubString</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-string"><span class="hljs-string">"The leatherback sea turtle is the largest, measuring six or seven feet (2 m) in length at maturity, and three to five feet (1 to 1.5 m) in width, weighing up to 2000 pounds (about900 kg). "</span></span> <span class="hljs-string"><span class="hljs-string">"Most other species are smaller, being two to four feet in length (0.5 to 1 m) and proportionally less wide. "</span></span> <span class="hljs-string"><span class="hljs-string">"The Flatback turtle is found solely on the northern coast of Australia."</span></span> julia&gt; tokenize.(split_sentences(text)) <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">SubString</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-built_in"><span class="hljs-built_in">SubString</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}[<span class="hljs-string"><span class="hljs-string">"The"</span></span>, <span class="hljs-string"><span class="hljs-string">"leatherback"</span></span>, <span class="hljs-string"><span class="hljs-string">"sea"</span></span>, <span class="hljs-string"><span class="hljs-string">"turtle"</span></span>, <span class="hljs-string"><span class="hljs-string">"is"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"largest"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"measuring"</span></span>, <span class="hljs-string"><span class="hljs-string">"six"</span></span> … <span class="hljs-string"><span class="hljs-string">"up"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span>, <span class="hljs-string"><span class="hljs-string">"2000"</span></span>, <span class="hljs-string"><span class="hljs-string">"pounds"</span></span>, <span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">"about"</span></span>, <span class="hljs-string"><span class="hljs-string">"900"</span></span>, <span class="hljs-string"><span class="hljs-string">"kg"</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">SubString</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}[<span class="hljs-string"><span class="hljs-string">"Most"</span></span>, <span class="hljs-string"><span class="hljs-string">"other"</span></span>, <span class="hljs-string"><span class="hljs-string">"species"</span></span>, <span class="hljs-string"><span class="hljs-string">"are"</span></span>, <span class="hljs-string"><span class="hljs-string">"smaller"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"being"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span>, <span class="hljs-string"><span class="hljs-string">"four"</span></span> … <span class="hljs-string"><span class="hljs-string">"0.5"</span></span>, <span class="hljs-string"><span class="hljs-string">"to"</span></span>, <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"m"</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">"and"</span></span>, <span class="hljs-string"><span class="hljs-string">"proportionally"</span></span>, <span class="hljs-string"><span class="hljs-string">"less"</span></span>, <span class="hljs-string"><span class="hljs-string">"wide"</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">SubString</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}[<span class="hljs-string"><span class="hljs-string">"The"</span></span>, <span class="hljs-string"><span class="hljs-string">"Flatback"</span></span>, <span class="hljs-string"><span class="hljs-string">"turtle"</span></span>, <span class="hljs-string"><span class="hljs-string">"is"</span></span>, <span class="hljs-string"><span class="hljs-string">"found"</span></span>, <span class="hljs-string"><span class="hljs-string">"solely"</span></span>, <span class="hljs-string"><span class="hljs-string">"on"</span></span>, <span class="hljs-string"><span class="hljs-string">"the"</span></span>, <span class="hljs-string"><span class="hljs-string">"northern"</span></span>, <span class="hljs-string"><span class="hljs-string">"coast"</span></span>, <span class="hljs-string"><span class="hljs-string">"of"</span></span>, <span class="hljs-string"><span class="hljs-string">"Australia"</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>]</code> </pre> <br><p>    : </p><br><ul><li> Poorman's tokenizer —        .     ,   <code>split</code> . </li><li> Punctuation space tokenize —        . ,     . </li><li> Penn Tokenizer —  ,    Penn Treebank. </li><li> Improved Penn Tokenizer — ,      NLTK. </li><li> NLTK Word tokenizer —  ,   NLTK,   ,        UNICODE-  . </li><li> Reversible Tokenizer — ,         .     </li><li> TokTok Tokenizer — ,    . </li><li> Tweet Tokenizer — ,     ,  , HTML-  . </li></ul><br><p>       <code>set_tokenizer(nltk_word_tokenize)</code> </p><br><h2 id="embeddingsjl"> Embeddings.jl </h2><br><p>  <a href="">Embeddings.jl</a>        .        ,      ,   ,   ,       ,      ,    .          Word2Vec.     ,   : <code>king - man + woman = queen</code> .    ,    ,      . ,   ,   ,   Wikipedia,         .  ,            .        «semantic space»,    ,   «semantic distance».         ,       ,    ,    «»  «»      .    ,             ,             ,        . </p><br><p>    ,    «embedding»  ,   ,    ,        .  ,      ,     ,     , , ,    .  ,     -,        .    ,           . ,   .        . </p><br><p> Embeddings.jl    : Word2Vec, GloVe (English only), FastText.       . ,           ,       .        —   ,          .  , , word2vec,    8-16   .   ,       . </p><br><p> , ,  <a href="">DataDeps.jl</a> .           ,    ("  ").   ,  Embedding.jl   ,        ,    .          ,          . </p><br><pre> <code class="julia hljs"><span class="hljs-literal"><span class="hljs-literal">ENV</span></span>[<span class="hljs-string"><span class="hljs-string">"DATADEPS_ALWAYS_ACCEPT"</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>   —        .      <code>~/.julia/datadeps</code>    . </p><br><p>  .   —      : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Embeddings <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> embtable = load_embeddings(Word2Vec) <span class="hljs-comment"><span class="hljs-comment"># or load_embeddings(FastText_Text) or ... const get_word_index = Dict(word=&gt;ii for (ii,word) in enumerate(embtable.vocab)) function get_embedding(word) ind = get_word_index[word] emb = embtable.embeddings[:,ind] return emb end</span></span></code> </pre> <br><p>   —      : </p><br><pre> <code class="julia hljs">julia&gt; get_embedding(<span class="hljs-string"><span class="hljs-string">"blue"</span></span>) <span class="hljs-number"><span class="hljs-number">300</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float32</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">0.01540828</span></span> <span class="hljs-number"><span class="hljs-number">0.03409082</span></span> <span class="hljs-number"><span class="hljs-number">0.0882124</span></span> <span class="hljs-number"><span class="hljs-number">0.04680265</span></span> -<span class="hljs-number"><span class="hljs-number">0.03409082</span></span> ...</code> </pre> <br><p>      WordTokenizers    TextAnalysis,  .       ,    Julia: </p><br><pre> <code class="julia hljs">julia&gt; a = rand(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">0.012300397820243392</span></span> <span class="hljs-number"><span class="hljs-number">0.13543646950484067</span></span> <span class="hljs-number"><span class="hljs-number">0.9780602985106086</span></span> <span class="hljs-number"><span class="hljs-number">0.24647179461578816</span></span> <span class="hljs-number"><span class="hljs-number">0.18672770774122105</span></span> julia&gt; b = ones(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-number"><span class="hljs-number">5</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> julia&gt; a+b <span class="hljs-number"><span class="hljs-number">5</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: <span class="hljs-number"><span class="hljs-number">1.0123003978202434</span></span> <span class="hljs-number"><span class="hljs-number">1.1354364695048407</span></span> <span class="hljs-number"><span class="hljs-number">1.9780602985106086</span></span> <span class="hljs-number"><span class="hljs-number">1.2464717946157882</span></span> <span class="hljs-number"><span class="hljs-number">1.186727707741221</span></span></code> </pre> <br><p>     Clustering.jl.   ,    — .  MLJ.jl.       ,      <a href="">https://github.com/JuliaStats/Distances.jl</a> ,       : </p><br><ul><li> Euclidean distance </li><li> Squared Euclidean distance </li><li> Periodic Euclidean distance </li><li> Cityblock distance </li><li> Total variation distance </li><li> Jaccard distance </li><li> Rogers-Tanimoto distance </li><li> Chebyshev distance </li><li> Minkowski distance </li><li> Hamming distance </li><li> Cosine distance </li><li> Correlation distance </li><li> Chi-square distance </li><li> Kullback-Leibler divergence </li><li> Generalized Kullback-Leibler divergence </li><li> Rényi divergence </li><li> Jensen-Shannon divergence </li><li> Mahalanobis distance </li><li> Squared Mahalanobis distance </li><li> Bhattacharyya distance </li><li> Hellinger distance </li><li> Haversine distance </li><li> Mean absolute deviation </li><li> Mean squared deviation </li><li> Root mean squared deviation </li><li> Normalized root mean squared deviation </li><li> Bray-Curtis dissimilarity </li><li> Bregman divergence </li></ul><br><p>           . </p><br><h2 id="transformersjl"> Transformers.jl </h2><br><p> <a href="">Transformers.jl</a> —      Julia  «Transformers»,      BERT  Google.  ,               NER —   ,     . </p><br><p> Transformers.jl   <a href="">Flux.jl</a> , ,   ,     Julia-    ,           . Flux.jl    CPU  GPU,  , ,    ,    . </p><br><p>         BERT    ,      .      : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Transformers <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Transformers.Basic <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Transformers.Pretrain <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Transformers.Datasets <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Transformers.BidirectionalEncoder <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Flux <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Flux: onehotbatch, gradient <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flux.Optimise: update! <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> WordTokenizers <span class="hljs-literal"><span class="hljs-literal">ENV</span></span>[<span class="hljs-string"><span class="hljs-string">"DATADEPS_ALWAYS_ACCEPT"</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FromScratch = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">#use wordpiece and tokenizer from pretrain const wordpiece = pretrain"bert-uncased_L-12_H-768_A-12:wordpiece" const tokenizer = pretrain"bert-uncased_L-12_H-768_A-12:tokenizer" const vocab = Vocabulary(wordpiece) const bert_model = gpu( FromScratch ? create_bert() : pretrain"bert-uncased_L-12_H-768_A-12:bert_model" ) Flux.testmode!(bert_model) function vectorize(str::String) tokens = str |&gt; tokenizer |&gt; wordpiece text = ["[CLS]"; tokens; "[SEP]"] token_indices = vocab(text) segment_indices = [fill(1, length(tokens) + 2);] sample = (tok = token_indices, segment = segment_indices) bert_embedding = sample |&gt; bert_model.embed collect(sum(bert_embedding, dims=2)[:]) end</span></span></code> </pre> <br><p>    <code>vectorize</code>     .       : </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Distances x1 = vectorize(<span class="hljs-string"><span class="hljs-string">"Some test about computers"</span></span>) x2 = vectorize(<span class="hljs-string"><span class="hljs-string">"Some test about printers"</span></span>) cosine_dist(x1, x2)</code> </pre> <br><p>   , <code>wordpiece</code> , <code>tokenizer</code> —    .   12 —  . 768 —   .    . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://chengchingwen.github.io/Transformers.jl/dev/pretrain/</a> .   ,  Transformers.Pretrain.@pretrain_str,     <code>pretrain"model-description:item"</code>        . </p><br><p>      ,      ,  Transformers.jl    ,          . </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>  ,  ,   Julia   .          . , ,         .    ,    Julia   ,    . ,          Julia. </p><br><p> ,       ,  ,    -   «»,      .   , ,        «open source»  , ,    ,      .        ,       , Julia    .   ,      Jupyter Notebook   ,      ,   —     Atom/Juno, VS Code, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a>    . , ,   Julia —      2-3    ,       ( ,      ,     ),     C++      . </p><br><p>      ,      ,    Julia,  -,   .   ,         ,  ,  ,        .         ,        2-3   ,         ,     . Julia       .          -    ,        <code>for</code>       .     —  «   ».   ,   C,    .  Julia,   ,   -  ,     ,    —  Julia-.  , Julia —             ,             . </p><br><p>  , ,            Julia  . , ,        . </p><br><p>    ,   -   Julia — @JuliaLanguage,         . </p><br><h2 id="ssylki"> 参考文献 </h2><br><ul><li> <a href="">TextAnalysis.jl</a> —     </li><li> <a href="">Languages.jl</a> —         </li><li> <a href="">WordTokenizers.jl</a> —    </li><li> <a href="">StringDistances.jl</a> —       </li><li> <a href="">Transformers.jl</a> —   Transformers   BERT. </li><li> <a href="">Distances.jl</a> —     . </li><li> <a href="">Clustering.jl</a> —    . </li><li> <a href="">MLJ.jl</a> — ,     ,      . </li><li> <a href="">Flux.jl</a> —     . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN475922/">https://habr.com/ru/post/zh-CN475922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN475904/index.html">给新经理的5条笔记</a></li>
<li><a href="../zh-CN475908/index.html">十个最受欢迎的俄语俄语课程</a></li>
<li><a href="../zh-CN475912/index.html">如何评估和比较以太网的加密设备</a></li>
<li><a href="../zh-CN475916/index.html">向机器人注视</a></li>
<li><a href="../zh-CN475920/index.html">不是在运行时，而是在设计时</a></li>
<li><a href="../zh-CN475924/index.html">Github安全实验室公告：一起保护所有代码</a></li>
<li><a href="../zh-CN475926/index.html">可视化遥远的边界：太空，赛博朋克，潜意识</a></li>
<li><a href="../zh-CN475934/index.html">9个Web组件库</a></li>
<li><a href="../zh-CN475936/index.html">太空战斗-冷战惊悚片</a></li>
<li><a href="../zh-CN475940/index.html">Vue店面：第二种Shell方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>