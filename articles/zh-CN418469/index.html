<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥃 🍞 😉 什么时候不使用STL算法。 设置例子 👩🏾‍⚕️ 🐓 👩‍👩‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="同志们，晚上好！ 您如此冷淡地从我们这里拆分了本书的第一版“ C ++ 17 STL。Standard Template Library ”，并且您继续分析第二本书，以至于我们最终决定在这里提出另一种观点。 今天的文章的作者是IvanČukić，他还拥有《 C ++函数式编程 》一书，该书正准备在曼...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>什么时候不使用STL算法。 设置例子</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/418469/">同志们，晚上好！ 您如此冷淡地<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从我们这里拆分</a>了本书的第一版“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++ 17 STL。Standard Template Library</a> ”，并且您继续分析第二本书，以至于我们最终决定在这里提出另一种观点。 今天的文章的作者是IvanČukić，他还拥有《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++函数式编程</a> 》一书，该书正准备在曼宁出版社出版。 我们提供评估他的怀疑思想，代码和计算方法 <br><a name="habracut"></a><br>  <b>前言</b> <br><br> 我想将此帖子命名为“关于STL算法的恶性”，以测试我自己在激发点击方面的技能。 但是后来他认为最好是为目标受众写一篇文章，而不是写这样的帖子，让那些想争论我的出色论文的人聚在一起。 <br><br> 因此，我可以假设您对算法，算法的复杂性感兴趣，并且想编写最完美的代码。 <br><br>  <b>演算法</b> <br><br> 在现代的专业C ++社区中，通常建议人们：使您的程序更安全，更快，更富有表现力，等等。  -使用标准库中的算法。 我还会尝试在有合适受众的地方，在我的书，演讲，研讨会中推广此建议。 <br><br> 当然，如果我们被迫编写一个<code>for</code>循环来解决摆在我们面前的问题，那是绝对正确的，我们首先需要考虑标准库（或boost）的现有算法是否适合于此，而不是盲目行动。 <br><br> 我们仍然需要知道这些算法是如何实现的，与它们相关的要求和保证，它们的时空复杂性是什么。 <br><br> 通常，如果我们面临的任务完全符合STL算法的要求，并且可以直接应用，那么该算法将是最有效的解决方案。 <br><br> 如果我们需要在应用算法之前以某种方式准备数据，则可能会出现问题。 <br><br>  <b>套路口</b> <br><br> 假设我们正在为C ++开发人员编写一个工具，该工具将提供有关替换lambda表达式中的默认捕获选项（谈论<code>[=]</code>和<code>[&amp;]</code> ）的提示，并显式显示捕获变量的列表。 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partition(begin(elements), end(elements), [=] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> element) { ^~~ -  -  ,   [threshold] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element &gt; threshold; });</code> </pre> <br> 解析文件时，我们需要一个集合，用于存储当前作用域和相邻作用域的变量。 一旦遇到带有默认捕获的lambda表达式，我们将需要查看那里使用了哪些变量。 <br><br> 结果，我们有两组：一组在周围可见性区域中的变量，另一组在lambda表达式主体中使用的变量。 <br><br> 我们将要提供的捕获选项列表应该是这两个集合的交集（lambda表达式可以使用不需要捕获的全局变量，并且lambda表达式中不会使用周围范围的所有变量）。 <br><br> 而且，如果需要交集，则可以使用<code>std::set_intersection</code> 。 <br><br> 该算法简单易用。 它接受两个排序的集合，并从头到尾同时运行它们： <br><br><ul><li> 如果第一个集合中的当前项目与第二个集合中的当前项目相同，则将其添加到结果中，该算法将简单地移至两个集合中的下一个项目； </li><li> 如果第一个集合中的实际项目小于第二个集合中的实际项目，则该算法将仅跳过第一个集合中的当前项目； </li><li> 如果第一个集合中的实际项目大于第二个集合中的实际项目，则该算法将跳过第二个集合中的当前项目；否则，该算法将跳过第二个集合中的当前项目。 </li></ul><br> 在每次迭代中，至少一个元素（来自第一个或第二个输入集合）被跳过-因此，算法的复杂度将是线性的<code>O(m + n)</code> ，其中<code>m</code>是第一个集合中的元素数量， <code>n</code>是第二个集合中的元素数量。 <br><br> 简单有效。 只要对输入集合进行排序。 <br><br>  <b>排序</b> <br><br> 问题是：如果集合没有预先排序怎么办？ <br><br> 在前面的示例中，明智的做法是将周围可见性区域中的变量存储在类似堆栈的结构中，在该结构中，解析器可以简单地添加进入新作用域的新元素，并在其离开时立即删除当前作用域的变量。 <br><br> 因此，变量将不会按名称排序，并且我们将无法直接使用<code>std::set_intersection</code>进行操作。 同样，如果您在lambda表达式的主体中跟踪变量，那么我们很可能将无法以排序形式保存它们。 <br><br> 由于<code>std::set_intersection</code>仅适用于已排序的集合，因此在许多项目中会发生此原理：首先对集合进行排序，然后调用<code>std::set_intersection</code> 。 <br><br> 如果我们忘记了在示例中对一堆变量进行排序会完全贬低我们定义的堆栈的全部使用价值，那么未排序集合的交集算法将如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::set_intersection(first1, last1, first2, last2, dest); }</code> </pre> <br> 整个算法的复杂度是多少？ 排序需要准线性时间，因此此方法的总体复杂度为<code>O(n log n + m log m + n + m)</code> 。 <br><br>  <b>排序较小</b> <br><br> 是否可以不进行分类？ <br><br> 如果两个集合都没有排序，那么对于第一个元素中的每个元素，我们将不得不遍历第二个集合-以确定是否将其包括在结果集中。 尽管这种方法在实际项目中非常普遍，但比以前的方法还要糟糕-其复杂度为<code>O(n * m)</code> 。 <br><br> 请记住Zen并选择“第三条路径”，而不是将所有内容连续排列或不进行任何排序，我们只对一个集合进行排序。 <br><br> 如果仅对一个集合进行排序，则可以逐一迭代未排序的所有值，并针对每个值检查它是否在排序的集合中。 为此，请应用二进制搜索。 <br><br> 在这种情况下，用于对第一个集合进行排序的时间复杂度将为<code>O(n log n)</code>对于进行排序和检查的时间复杂度将为<code>O (m log n)</code> 。 总复杂度将为<code>O((n + m) log n)</code> 。 <br><br> 如果我们决定对第二个集合而不是第一个集合进行排序，那么复杂度将为<code>O((n + m) log m)</code> 。 <br><br> 为了获得最大效率，我们总是对元素较少的集合进行排序，以使算法的最终复杂度为 <br>  <code>((m + n) log (min(m, n))</code> 。 <br><br> 该实现将如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_2(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::binary_search(first1, last1, FWD(value)); }); }</code> </pre> <br> 在我们的具有lambda表达式中的捕获列表的示例中，通常对lambda表达式中存在的变量的集合进行排序，因为它可能小于来自所有周围范围的所有变量的集合。 <br><br>  <b>散列</b> <br><br> 最后一个选择是从较小的集合中构建<code>std::unordered_set</code> （基于哈希的无序集实现），而不是对其进行排序。 在这种情况下，搜索操作的复杂度将平均为<code>O(1)</code> ，但是构建<code>std::unordered_set</code>会花费一些时间。 建筑物的复杂度范围从<code>O(n)</code>到<code>O(n*n)</code> ，这是一个潜在的问题。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIt2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIt&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unordered_intersection_3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> size2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first2, last2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size1 &gt; size2) { unordered_intersection_3(first2, last2, first1, last1, dest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; test_set(first1, last1); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy_if(first2, last2, dest, [&amp;] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test_set.count(FWD(value)); }); }</code> </pre> <br> 当您需要计算具有单个预定义的小集合的多个集合的交集时，散列方法将完全胜出。 也就是说，我们有集合<code>A</code> ，集合<code>B₁</code> ， <code>B₂…</code>并且我们要计算<code>A ∩ B₁, A ∩ B₂…</code> <br><br> 在这种情况下，您可以忽略<code>std::unordered_set</code>构造的复杂度，并且计算每个交集的复杂度将是线性的<code>O(m)</code> ，其中<code>m</code>是第二个集合中元素的数量。 <br><br>  <b>控制权</b> <br><br> 当然，检查算法的复杂性总是有用的，但是在这种情况下，使用检查点检查各种方法也是明智的。 特别是从最后两个选项中进行选择时，我们将比较二进制搜索和基于哈希的集合。 <br> 我最简单的测试表明，必须对两个集合进行排序的第一个选项始终是最慢的。 <br><br> 对较小的集合进行排序的性能要优于<code>std::unordered_set</code> ，但并非特别如此。 <br><br> 当两个集合具有相同数量的元素时，第二种和第三种方法都比第一种略快，而当一个集合中的元素数量比第二种多大约1000倍时，第二种和第三种方法都快得多（最多六倍）。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN418469/">https://habr.com/ru/post/zh-CN418469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN418457/index.html">感谢帖子：系统管理员之日</a></li>
<li><a href="../zh-CN418459/index.html">具有两个DisplayPort接口的LVDS定标器的开发</a></li>
<li><a href="../zh-CN418463/index.html">在Angular中处理数据</a></li>
<li><a href="../zh-CN418465/index.html">发现了新的Spectre攻击选项，能够通过网络远程接收数据</a></li>
<li><a href="../zh-CN418467/index.html">武术发展商分类</a></li>
<li><a href="../zh-CN418475/index.html">Windows 10使用机器学习技术来确定是否可以升级</a></li>
<li><a href="../zh-CN418477/index.html">DEFCON会议23.我如何失去视线，或对数据破坏的进一步研究。 第一部分</a></li>
<li><a href="../zh-CN418479/index.html">DEFCON会议23.我如何失去视线，或对数据破坏的进一步研究。 第二部分</a></li>
<li><a href="../zh-CN418481/index.html">以色列生活-与IT相关的一些时刻</a></li>
<li><a href="../zh-CN418483/index.html">如何将STM8的Bootloader压缩为FLASH存储器中的8个字节</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>