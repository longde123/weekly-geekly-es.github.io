<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😤 👼🏿 🏤 美洲印第安人堡垒的字节机（不仅如此）（第4部分） 👩🏼‍🤝‍👨🏾 🏂🏾 🗡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="再一次，我高估了这篇文章的数量！ 我计划这将是最后一篇文章，我们将在其中编写一个编译器并进行测试。 但是结果却很大，因此我决定将文章分成两部分。 

 在本文中，我们将完成编译器的几乎所有基本功能。 这将成为现实，并且可以编写，编译和执行相当严格的代码。 我们将在下一部分中进行测试。 （顺便说一下，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>美洲印第安人堡垒的字节机（不仅如此）（第4部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437466/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="字节堡堡（及更多）美国原住民"><br><br> 再一次，我高估了这篇文章的数量！ 我计划这将是最后一篇文章，我们将在其中编写一个编译器并进行测试。 但是结果却很大，因此我决定将文章分成两部分。 <br><br> 在本文中，我们将完成编译器的几乎所有基本功能。 这将成为现实，并且可以编写，编译和执行相当严格的代码。 我们将在下一部分中进行测试。  （顺便说一下，前面的部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1、2、3</a> ）。 <br><br> 我是第一次在哈布雷（Habré）写作；也许并非总是如此。 我认为，第2、3条相当干燥，代码很多，描述很少。 这次，我将尝试做一些不同的事情，着重于对想法本身的描述。 好吧，代码……代码当然会！ 谁想彻底了解，这样的机会将是。 在许多情况下，我会将代码放在破坏者的下面。 而且，当然，您始终可以在github上查看完整的源代码。 <br><br> 编译器将继续在汇编器中写入一段时间，然后进入要塞，继续自己编写编译器。 这将类似于蒙克豪森男爵（Baron Munchausen），他从沼泽地的头发中拉了自己。 但是，对于初学者来说，我将概述要塞上的编译器的工作方式。 欢迎来到猫！ <br><a name="habracut"></a><br><h4> 编译器如何工作？ </h4><br> 堡垒中的内存由一个连续的片段组成，在该片段中顺序排列字典条目。 完成后，紧随其后的是空闲存储区。 第一个空闲字节由变量h指示。 这里还有一个经常使用的词，它会将第一个空闲字节的地址压入堆栈，它的确定非常简单： <br><br><pre><code class="cpp hljs">: here h @ ;</code> </pre> <br><img src="https://habrastorage.org/webt/bd/eg/sq/bdegsqg7t06egwbvxoib9lqk_nc.png"><br><br> 值得一提的是分配字，它通过移动指针h保留了指定的字节数。 分配词可以定义如下： <br><br><pre> <code class="cpp hljs">: allot h +! ;</code> </pre> <br> 实际上，编译器使用特殊的解释器模式以及一些特殊的单词。 因此，只需一句话，您就可以在堡垒中描述编译器的整个原理。 解释器的工作模式由状态变量决定。 如果为零，则设置执行模式，否则为编译模式。 我们已经熟悉执行模式，其中输入缓冲区中的单词只是一个接一个地执行。 但是在编译模式下，它们不会执行，而是由指针h编译到内存中。 因此，指针向前移动。 <br><br> 在经典的堡垒中，单词“，”用于编译整数值，单词“ c，”用于编译字节。 我们的系统使用不同位深度（8、16、32、64）的值，因此，我们将另外加上单词“ w”和“ i”。 我们还制作了单词“ str”，它将编译字符串，并从堆栈中获取两个值-字符串的地址和长度。 <br><br> 特殊的编译器字用于形成控制结构。 这些是if，do，loop和其他词。 这些字甚至在编译模式下也被执行。 例如，单词if在执行时会编译条件分支字节命令（？Nbranch）。 为了使系统知道需要在编译模式下执行哪些字，而不是编译哪些字，请使用立即标记（符号）。 我们已经在字典条目的标志字段中拥有它。 在汇编器源代码中，它称为f_immediate。 要设置此标志，请使用单词立即。 它没有参数，立即标记设置在字典的最后一个单词上。 <br><br> 现在，让我们从理论转向实践！ <br><br><h4> 准备工作 </h4><br> 首先，我们需要使用所需的汇编语言来执行一些简单的字节命令。 它们是：移动（复制存储区），填充（填充存储区），位操作（和，或“异或”，“取反”），移位命令（rshift，lshift）。 让我们执行相同的rpick（这与pick相同，它仅适用于返回堆栈，不适用于数据堆栈）。 <br><br><div class="spoiler">  <b class="spoiler_title">这些命令非常简单，这是它们的代码</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_move = <span class="hljs-number"><span class="hljs-number">0x66</span></span> bcmd_move: pop rcx pop rdi pop rsi repz movsb jmp _next b_fill = <span class="hljs-number"><span class="hljs-number">0x67</span></span> bcmd_fill: pop rax pop rcx pop rdi repz stosb jmp _next b_rpick = <span class="hljs-number"><span class="hljs-number">0x63</span></span> bcmd_rpick: pop rcx push [rbp + rcx * <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_and = <span class="hljs-number"><span class="hljs-number">0x58</span></span> bcmd_and: pop rax <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [rsp], rax jmp _next b_or = <span class="hljs-number"><span class="hljs-number">0x59</span></span> bcmd_or: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [rsp], rax jmp _next b_xor = <span class="hljs-number"><span class="hljs-number">0x5A</span></span> bcmd_xor: pop rax xor [rsp], rax jmp _next b_invert = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> bcmd_invert: notq [rsp] jmp _next b_rshift = <span class="hljs-number"><span class="hljs-number">0x5C</span></span> bcmd_rshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shrq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next b_lshift = <span class="hljs-number"><span class="hljs-number">0x5D</span></span> bcmd_lshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shlq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next</code> </pre> </div></div><br> 仍然需要使单词单词。 这与blword相同，但是在堆栈上指示了一个特定的定界符。 我没有提供代码，可以在源代码中找到。 我复制/粘贴单词blworld并替换了比较命令。 <br><br> 总之，我们将单词syscall命名。 有了它，就有可能进行丢失的系统操作，例如，处理文件。 如果需要平台独立性，则这种解决方案将不起作用。 但是此系统现在用于测试，所以现在就这样吧。 如有必要，所有操作都可以转换为字节命令，这并不困难。  syscall命令将接受6个用于系统调用的参数和来自堆栈的电话号码。 它将返回一个参数。 参数分配和返回值由系统调用号确定。 <br><br><pre> <code class="cpp hljs">b_syscall = <span class="hljs-number"><span class="hljs-number">0xFF</span></span> bcmd_syscall: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 pop rax pop r9 pop r8 pop r10 pop rdx pop rsi pop rdi syscall push rax mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre><br> 现在让我们直接进入编译器。 <br><br><h4> 编译器 </h4><br> 让我们创建变量h，这里的一切都很简单。 <br><br><pre> <code class="cpp hljs"> item h h: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> 我们将在开始行中编写其初始化： <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! h dup 8 + swap ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call16 .word h - . - 2 .byte b_dup, b_num8, b_add, b_swap, b_set .byte b_quit</span></span></code> </pre><br> 让我们在这里说一下： <br><br><pre> <code class="cpp hljs"> item here .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_get .byte b_exit</code> </pre><br><div class="spoiler">  <b class="spoiler_title">还有用于编译值的单词：“ allot”和“ c”，“ w”，“ i”，“，”，“ str”</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : allot h +! ; item allot allot: .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_setp, b_exit # : , here ! <span class="hljs-number"><span class="hljs-number">8</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">","</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set, b_num8, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : i, here i! <span class="hljs-number"><span class="hljs-number">4</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"i,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set32, b_num4, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : w, here w! <span class="hljs-number"><span class="hljs-number">2</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"w,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set16, b_num2, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : c, here c! <span class="hljs-number"><span class="hljs-number">1</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"c,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set8, b_num1, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : str, dup -rot dup c, here swap move <span class="hljs-number"><span class="hljs-number">1</span></span>+ h +!; item <span class="hljs-string"><span class="hljs-string">"str,"</span></span> c_str: .byte b_dup, b_mrot, b_dup callb c_8 callb here .byte b_swap, b_move callb h .byte b_setp .byte b_exit</code> </pre></div></div><br> 现在，让状态变量和两个单词来控制其值：“ [”和“]”。 通常，这些词在编译时用于执行某些操作。 因此，单词“ [”关闭编译模式，单词“]”打开编译模式。 但是，在需要打开或关闭编译模式的其他情况下，没有什么可以阻止使用它们。 单词“ [”将是我们的第一个带有立即符号的单词。 否则，它将无法关闭编译模式，因为它将被编译而不执行。 <br><br><pre> <code class="cpp hljs"> item state .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-string"><span class="hljs-string">"]"</span></span> .byte b_num1 callb state .byte b_set, b_exit item <span class="hljs-string"><span class="hljs-string">"["</span></span>, f_immediate .byte b_num0 callb state .byte b_set, b_exit</code> </pre><br> 转向$编译一词。 它将从堆栈中获取字典条目的地址，并编译指定的单词。 为了在普通Fort实现中编译一个单词，只需将单词“，”应用到执行地址即可。 这里的一切都更加复杂。 首先，有两种类型的单词-字节码和机器码。 前者按字节编译，后者按调用字节命令编译。 其次-我们有多达四​​个call命令的变体：call8，call16，call32和call64。 四个？ 不行 当我编写编译器时，我在这四个中又增加了16个！  :) <br><br> 这是怎么发生的？ 我们必须做一点题外话。 <br><br><h4> 改善通话指令 </h4><br> 当编译器开始工作时，我发现在许多情况下（但不是全部），call8命令就足够了。 这是当被调用字在128字节以内时。 我想-以及如何确保几乎在所有情况下都会发生这种情况？ 如何在一个字节中放置超过256个值？ <br> 我注意到的第一点是，在要塞中，呼叫始终指向较低的地址。 这意味着您可以重做call命令，使其只能调用低位地址，但可以调用256个字节，而不能调用128个字节。更好。 <br><br> 但是，如果您在某些地方放一些东西……事实证明那里是那里！ 我们有两个字节：一个字节是命令，第二个字节是偏移量。 但是，没有什么能阻止命令的低位放置参数的高位（偏移）。 对于字节机，似乎有多个而不是一个调用命令。 是的，通过这种方式，我们用一个命令占据了字节命令代码表的几个单元，但是有时值得这样做。 调用命令是最常用的命令之一，因此我决定在命令中放入4个偏移量位。 因此，您可以拨打多达4095字节的距离！ 这意味着几乎总是会使用这样的短呼叫命令。 我将这些命令放置为代码0xA0，并且以下行出现在命令表中： <br><br><pre> <code class="cpp hljs">.quad bcmd_call8b0, bcmd_call8b1, bcmd_call8b2, bcmd_call8b3, bcmd_call8b4, bcmd_call8b5, bcmd_call8b6, bcmd_call8b7 # <span class="hljs-number"><span class="hljs-number">0xA0</span></span> .quad bcmd_call8b8, bcmd_call8b9, bcmd_call8b10, bcmd_call8b11, bcmd_call8b12, bcmd_call8b13, bcmd_call8b14, bcmd_call8b15</code> </pre> <br> 这些字节命令中的第一个简单地以参数中指定的偏移量（最多为255）向低地址方向进行调用。 其余的将相应的偏移量添加到参数。  bcmd_call8b1添加256，bcmd_call8b2添加512，依此类推。 我分别发出了第一个调用命令，其余的则使用了宏。 <br><br> 第一条命令： <br><br><pre> <code class="cpp hljs">b_call8b0 = <span class="hljs-number"><span class="hljs-number">0xA0</span></span> bcmd_call8b0: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 sub r8, rax jmp _next</code> </pre><br> 宏并创建其余的调用命令： <br><br><pre> <code class="cpp hljs">.macro call8b N b_call8b\N = <span class="hljs-number"><span class="hljs-number">0xA</span></span>\N bcmd_call8b\N: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 add rax, \N * <span class="hljs-number"><span class="hljs-number">256</span></span> mov [rbp], r8 sub r8, rax jmp _next .endm call8b <span class="hljs-number"><span class="hljs-number">1</span></span> call8b <span class="hljs-number"><span class="hljs-number">2</span></span> call8b <span class="hljs-number"><span class="hljs-number">3</span></span> call8b <span class="hljs-number"><span class="hljs-number">4</span></span> call8b <span class="hljs-number"><span class="hljs-number">5</span></span> call8b <span class="hljs-number"><span class="hljs-number">6</span></span> call8b <span class="hljs-number"><span class="hljs-number">7</span></span> call8b <span class="hljs-number"><span class="hljs-number">8</span></span> call8b <span class="hljs-number"><span class="hljs-number">9</span></span> call8b <span class="hljs-number"><span class="hljs-number">10</span></span> call8b <span class="hljs-number"><span class="hljs-number">11</span></span> call8b <span class="hljs-number"><span class="hljs-number">12</span></span> call8b <span class="hljs-number"><span class="hljs-number">13</span></span> call8b <span class="hljs-number"><span class="hljs-number">14</span></span> call8b <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br> 好吧，我重做了旧的call8命令以进行转接，因为我们已经有16个团队进行了回调。 无论有什么困惑，我都将其重命名为b_call8f： <br><br><pre> <code class="cpp hljs">b_call8f = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8f: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next</code> </pre><br> 顺便说一句，为方便起见，我制作了一个宏，该宏在汇编器中自动在4095内编译相应的回调。然后，我就不需要再进行:) <br><br><pre> <code class="cpp hljs">.macro callb adr .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \adr &gt; . .error <span class="hljs-string"><span class="hljs-string">"callb do not for forward!"</span></span> .endif .byte b_call8b0 + (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> .byte (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> .endm</code> </pre> <br> 现在... <br><br><h4> 团队编制 </h4><br> 因此，我们得到了一个相当复杂的命令编译算法。 如果这是字节命令，则仅编译一个字节（字节命令代码）。 并且，如果此字已用字节码编写，则需要使用call命令（从20个中选择一个）来编译其调用。 更准确地说是19，因此我们没有呼叫转移，因此call8f不会用作堡垒。 <br><br> 所以选择就是这个。 如果偏移量在0到4095之间，请选择代码为0xA0的bcmd_call8b命令，将四个最高有效偏移量位放在命令的最低有效位中。 同时，对于字节机，bcmd_call8b0命令之一的代码为bcmd_call8b15。 <br><br> 如果后向偏移量大于或等于4095，则我们确定偏移量放置在哪个尺寸上，并使用来自call16 / 32/64的适当命令。 应该记住的是，这些球队的补偿金额是有符号的。 它们可能导致前进和后退。 例如，call16可以在两个方向上调用32767的距离。 <br><br> 结果是实现： <br><br>  <b>$编译</b> <br><br> 编译一个单词。 作为参数，采用已编译单词的字典条目的地址。 实际上，它检查f_code标志，计算代码地址（cfa），并调用compile_b或compile_c（如果设置了标志）。 <br><br>  <b>compile_c</b> <br><br> 编译一个字节命令。 这里最简单的单词在堡垒上的描述如下： <br><br><pre> <code class="cpp hljs">: compile_c c@ c, ;</code> </pre> <br>  <b>compile_b</b> <br> 它在堆栈上使用字节码地址并编译其调用。 <br><br>  <b>test_bv</b> <br><br> 它从堆栈中偏移（带符号），并确定要使用的位深度（1、2、4或8个字节）。 返回值0、1、2或3。使用此字，您可以从call16 / 32/64命令中确定要使用哪个值。 该单词在编译数字时会派上用场（从lit8 / 16/32/64中选择）。 <br><br> 顺便说一句，您可以启动系统并使用以下任何一个单词在堡垒控制台中“玩转”。 例如： <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 222 test_bv ( 2 ): 222 1 &gt; drop drop ( 0 ): &gt; 1000000 test_bv ( 2 ): 1000000 2 &gt; drop drop ( 0 ): &gt; -33 test_bv ( 2 ): -33 0 &gt;</code> </pre> <br>  <b>test_bvc</b> <br><br> 它从堆栈中获取一个偏移量（带有符号），并确定要使用的调用命令。 实际上，它会检查偏移量是否在0 ... -4095内，并返回0。在这种情况下，如果在此间隔内没有命中，它将调用test_bv。 <br><br><div class="spoiler">  <b class="spoiler_title">这就是编译命令所需要的全部。</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : test_bvc dup <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= over FFF &lt;= <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... item test_bvc test_bvc: .byte b_dup, b_neg .byte b_num0 .byte b_gteq .byte b_over, b_neg .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0xFFF</span></span> .byte b_lteq .byte b_and .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_num0 .byte b_exit item test_bv test_bv: .byte b_dup, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_gteq, b_over, b_lit8, <span class="hljs-number"><span class="hljs-number">0x7f</span></span>, b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_num0 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x8001</span></span> .byte b_gteq .byte b_over .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x7ffe</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_num1, b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_dup .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80000002</span></span> .byte b_gteq .byte b_over .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x7ffffffd</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_num2, b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_num3 .byte b_exit #  - item compile_c compile_c: .byte b_get8 callb c_8 .byte b_exit #   - item compile_b compile_b: callb here .byte b_num2, b_add .byte b_sub callb test_bvc .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop .byte b_neg .byte b_dup .byte b_lit8, <span class="hljs-number"><span class="hljs-number">8</span></span> .byte b_rshift .byte b_lit8, b_call8b0 .byte b_or callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_call16 callb c_8 .byte b_wm callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_call32 callb c_8 .byte b_num3, b_sub callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_call64 callb c_8 .byte b_lit8, <span class="hljs-number"><span class="hljs-number">7</span></span>, b_sub callb c_64 .byte b_exit #: $compile dup c@ <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa compile_c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa compile_b then ; item <span class="hljs-string"><span class="hljs-string">"$compile"</span></span> _compile: .byte b_dup, b_get8, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_cfa callb compile_c .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_cfa callb compile_b .byte b_exit</code> </pre><br></div></div><br> 现在我们需要编译数字。 <br><br><h4> 编制数字（文字） </h4><br> 写了一个完整的字幕，准备专门描述文字的编译，但是事实证明没有什么特别的描述：） <br><br> 我们已经在test_bv一词中完成了一半的工作。 仅保留调用test_bv，并根据结果编译lit8 / 16/32/64，然后编译大小分别为1、2、4或8个字节的值。 <br><br><div class="spoiler">  <b class="spoiler_title">我们通过定义单词compile_n来实现</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#   item compile_n compile_n: callb test_bv .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop, b_lit8, b_lit8 callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_lit16 callb c_8 callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_lit32 callb c_8 callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_lit64 callb c_8 callb c_64 .byte b_exit</code> </pre></div></div><br><h4> 修改解释器 </h4><br> 一切准备就绪，可以编译命令和文字。 现在需要将其内置到解释器中。 此修改很简单。 执行命令的位置，添加状态检查。 如果state不为null，并且单词不包含立即标志，请执行$ compile而不是执行。 从输入流中获取数字的操作大致相同。 如果状态为零，则将数字保留在堆栈上，否则不调用compile_n。 <br><br><div class="spoiler">  <b class="spoiler_title">这是口译员</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop callb state .byte b_get .byte b_qnbranch8, irpt_execute - . #  <span class="hljs-number"><span class="hljs-number">0</span></span>,    .byte b_dup, b_get8, b_lit8, f_immediate, b_and #  immediate    .byte b_qbranch8, irpt_execute - . #    -   #   ! callb _compile .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . irpt_execute: .byte b_cfa #  ,    (state = <span class="hljs-number"><span class="hljs-number">0</span></span>  immediate  ) .byte b_execute .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) #   -   callb state # ,    .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . #   -     ;   -   #   callb compile_n <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre></div></div><br> 现在我们离编译器仅一步之遥... <br><br><h4> 新单词的定义（单词“：”） </h4><br> 现在，如果将状态变量设置为非零值，则将开始编译过程。 但是结果将是无用的，我们无法实现它，甚至无法在内存中找到它。 为了使所有这些操作成为可能，有必要以字典文章的形式格式化编译结果。 为此，在打开编译模式之前，您需要为该单词创建标题。 <br><br> 标头应包含标志，通信字段和名称。 在这里，我们有一个熟悉的故事-通信字段可以是1、2、4或8个字节。 让我们使用compile_1248这个词，它将帮助我们形成这样一个交流领域。 堆栈上将使用两个数字-偏移量和test_bv命令生成的值。 <br><br><div class="spoiler">  <b class="spoiler_title">编译_1248</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#    , ,     #     ,  test_dv item compile_1248 compile_1248: .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_drop callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: callb c_64 .byte b_exit</code> </pre></div></div><br> 现在使$创建。 这将对我们不止一次有用。 您可以在需要为字典条目创建标题时使用它。 它将从堆栈中获取两个值-创建的单词的名称的地址及其长度。 执行完该单词后，创建的字典条目的地址将出现在堆栈中。 <br><br><div class="spoiler">  <b class="spoiler_title">$创建</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : $create here current @ @ here - test_bv dup c, compile_1248 -rot str, current @ ! <span class="hljs-string"><span class="hljs-string">' var0 here c!; item "$create" create: callb here callb current .byte b_get, b_get callb here .byte b_sub callb test_bv .byte b_dup callb c_8 callb compile_1248 .byte b_mrot callb c_str #       callb current .byte b_get, b_set #     - var0,      here #   ,    -    ,    #     ,     #    1 allot   ,   .byte b_lit8, b_var0 callb here .byte b_set8 .byte b_exit</span></span></code> </pre> </div></div><br> 下一个单词将使用单词blword从输入流中选取新单词的名称，并调用$ create，以指定的名称创建一个新单词。 <br><br><div class="spoiler">  <b class="spoiler_title">create_in</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item <span class="hljs-string"><span class="hljs-string">"create_in"</span></span> create_in: .byte b_blword .byte b_dup .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> #     <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\ncreate_in - name not found!\n"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: callb create .byte b_exit</code> </pre></div></div><br> 最后，加上单词“：”。 它将使用create_in创建一个新单词并设置编译模式，但尚未安装。 如果已安装，则会出现错误。 单词“：”将带有立即符号。 <br><br><div class="spoiler">  <b class="spoiler_title">这个词：</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : : create_in <span class="hljs-number"><span class="hljs-number">1</span></span> state dup @ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .<span class="hljs-string"><span class="hljs-string">" : - no execute state!"</span></span> then ! <span class="hljs-number"><span class="hljs-number">110</span></span> ; immediate item <span class="hljs-string"><span class="hljs-string">":"</span></span>, f_immediate colon: callb create_in .byte b_num1 callb state .byte b_dup .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">3f</span></span> #     <span class="hljs-number"><span class="hljs-number">3</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n: - no execute state!\n"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_set .byte b_lit8, <span class="hljs-number"><span class="hljs-number">110</span></span> .byte b_exit</code> </pre></div></div><br> 如果有人查看了代码，那么他会看到这个词还有其他作用:) <br><br> 这是110 ??? <br><br> 是的，这个单词还将数字110推入堆栈，这就是原因。 编译时，各种构造必须是一个整体。 例如，如果必须之后。 使用“：”创建的单词应以“;”结尾。 为了检查这些条件，编译器的特殊字将某些值放在堆栈上并检查它们的存在。 例如，单词“：”的值是110，单词“;”的值是 检查110是否位于堆栈的顶部，如果不是这种情况，则为错误。 因此，控制结构没有配对。 <br><br> 此类检查是在编译器的所有此类词中进行的，因此，我们将为此专门制作一个词-“？Pairs”。 它将从堆栈中获取两个值，如果它们不相等，则抛出错误。 <br><br> 同样，换句话说，您通常必须检查是否设置了编译模式。 为此，让我们使用“？State”一词。 <br><br><div class="spoiler">  <b class="spoiler_title">成对状态</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#: ?pairs = ifnot <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> then .<span class="hljs-string"><span class="hljs-string">" \nerror: no pairs operators"</span></span> quit then ; item <span class="hljs-string"><span class="hljs-string">"?pairs"</span></span> .byte b_eq, b_qbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no pairs operators"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit #: ?state state @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span><span class="hljs-string"><span class="hljs-string">" error: no compile state"</span></span> then ; item <span class="hljs-string"><span class="hljs-string">"?state"</span></span> callb state .byte b_get, b_zeq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no compile state"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit</code> </pre></div></div><br> 仅此而已！ 我们不会在汇编器中手动编译其他任何东西：) <br><br> 但是直到最后，还没有编写编译器，因此一开始您将不得不使用一些不寻常的方法... <br><br><h4> 让我们准备好使用创建的编译器编译创建的编译器 </h4><br> 首先，您可以通过编译一些简单的命令来检查单词“：”的工作方式。 让我们做一个词，例如： <br><br><pre> <code class="cpp hljs">: ^<span class="hljs-number"><span class="hljs-number">2</span></span> dup * ;</code> </pre> <br> 这个词是平方。 但是我们没有单词“;”怎么办？<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们改写exit一词，然后编译。</font><font style="vertical-align: inherit;">然后使用单词“ [”关闭编译模式，并降低值110：</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^2 dup * exit [ drop ( 0 ): &gt; 4 ^2 ( 1 ): 16 &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有效！</font><font style="vertical-align: inherit;">让我们</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继续... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们将继续在堡垒上编写堡垒，因此我们需要考虑堡垒的源代码在哪里以及何时编译。</font><font style="vertical-align: inherit;">让我们做出最简单的选择。</font><font style="vertical-align: inherit;">堡垒的源代码将作为文本字符串放置在汇编器的源代码中。</font><font style="vertical-align: inherit;">为了避免占用过多空间，我们将其立即放置在此处的地址之后的可用内存区域中。</font><font style="vertical-align: inherit;">当然，我们需要此区域进行编译，但是解释的“失控”速度将大于对新内存的需求。</font><font style="vertical-align: inherit;">因此，从头开始，编译后的代码将开始覆盖要塞上的源代码，但是由于我们已经阅读并使用了本节，因此不再需要它。</font></font><br><br><pre> <code class="cpp hljs">fcode: .ascii <span class="hljs-string"><span class="hljs-string">" 2 2 + . quit"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，在该行的开头，应该放置一打空格。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使此工作有效，我们更改了起始字节码，以便tib，＃tib指向此行。</font><font style="vertical-align: inherit;">最后，退出进入系统的正常命令行。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起始字节码已经变成这样</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_call16 .word vhere - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word h - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word definitions - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word fcode_end - fcode .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_quit</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发射！ </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth 4 ( 0 ): &gt;</code> </pre><br> 太好了！ <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用编译器编译编译器 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我们在fcode行中编写代码。</font><font style="vertical-align: inherit;">当然，要做的第一件事是单词“;”。</font></font><br><br><pre> <code class="cpp hljs">: ; ?state <span class="hljs-number"><span class="hljs-number">110</span></span> ?pairs lit8 [ blword <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> find cfa c@ c, ] c, <span class="hljs-number"><span class="hljs-number">0</span></span> state ! <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> [ current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! drop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我会做一些解释。 </font></font><br><br><pre> <code class="plaintext hljs">?state 110 ?pairs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这里，我们检查编译状态是否已真正设置好，堆栈上是否有110，否则会错误地中断。 </font></font><br><br><pre> <code class="plaintext hljs">lit8 [ blword exit find cfa c@ c, ]</code> </pre> <br>     lit  -  exit.     ,   exit,   ,     .            compile.    ,         «compile exit» :) <br><br><pre> <code class="plaintext hljs">c, 0 state !</code> </pre> <br>     exit     ";",     .  "["   ,      immediate   <b></b> ,    <b></b>     ";",      . <br><br><pre> <code class="plaintext hljs">exit [</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经经历过了。</font><font style="vertical-align: inherit;">单词exit被编译，编译模式被关闭。</font><font style="vertical-align: inherit;">一切，单词“;” </font><font style="vertical-align: inherit;">编译。</font><font style="vertical-align: inherit;">还有什么进一步写的呢？</font></font><br><br><pre> <code class="plaintext hljs">current @ @ dup c@ 96 or swap c! drop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要为新单词设置立即标记。</font><font style="vertical-align: inherit;">除了单词drop以外，这正是所指示的顺序。</font><font style="vertical-align: inherit;">单词drop删除在创建开始时放置单词“：”的被遗忘的110。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在就全部了！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们启动并尝试。</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^3 dup dup * * ; ( 0 ): &gt; 6 ^3 . 216 ( 0 ): &gt;</code> </pre><br> 有！<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是我们的编译器“真正”编译的第一个词。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们仍然没有条件，没有循环，还有更多……让我们从一个很小但非常必要的词开始创建一个编译器：立即数。</font><font style="vertical-align: inherit;">它在创建的最后一个单词上设置即时属性：</font></font><br><br><pre> <code class="cpp hljs">: immediate current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">熟悉的序列：）最近，它是手动编写的，不再需要。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在让我们写一些小而有用的词：</font></font><br><br><pre> <code class="cpp hljs">: hex <span class="hljs-number"><span class="hljs-number">16</span></span> base ! ; : decimal <span class="hljs-number"><span class="hljs-number">10</span></span> base ! ; : bl <span class="hljs-number"><span class="hljs-number">32</span></span> ; : tab <span class="hljs-number"><span class="hljs-number">9</span></span> ; : lf <span class="hljs-number"><span class="hljs-number">10</span></span> ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十六进制和十进制设置相应的数字系统。</font><font style="vertical-align: inherit;">其余的是用于获取相应字符代码的常量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还说了一个复制带有计数器的行的方法</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：::在c @ 1+上移动cmove；</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们将从事条件。</font><font style="vertical-align: inherit;">通常，如果有一个词compile，它将看起来像这样：</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开头的所有这些单词都会验证是否设置了编译模式，如果不是这种情况，则会生成错误。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if字编译条件分支，为条件分支命令参数保留一个字节，并将该字节的地址压入堆栈。然后，它将控制值111压入堆栈</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后该字检查控制值111的存在，然后将偏移量写入堆栈中的地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并立即说其他话。</font><font style="vertical-align: inherit;">它在开始时编译无条件跳转命令以绕过else分支。</font><font style="vertical-align: inherit;">好像还不知道过渡偏移，只是保留过渡偏移，并将其地址压入堆栈一样。</font><font style="vertical-align: inherit;">好吧，此后，便完成了与之完全相同的操作：catch转换的地址设置为else分支。</font><font style="vertical-align: inherit;">比代码本身更难描述：)如果某人想彻底理解它，则最好分解这样一个最大程度简化的代码：</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, ; immediate : then dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好了，现在我们编写真实代码。</font><font style="vertical-align: inherit;">由于我们没有编译一词，因此我们采用了与创建单词“;”相同的技巧：</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state lit8 [ blword ?nbranch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs lit8 [ blword branch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, swap dup here swap - swap c! <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，您可以尝试编译条件。</font><font style="vertical-align: inherit;">例如，假设有一个单词，如果堆栈上有5个，则输出1000；在其他情况下，则显示0：</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = if 1000 . else 0 . then ; ( 0 ): &gt; 22 test 0 ( 0 ): &gt; 3 test 0 ( 0 ): &gt; 5 test 1000 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，这样的结果不能立即生效，有错误，有调试。</font><font style="vertical-align: inherit;">但最终，条件奏效了！</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关于过渡命令的长度有一点点偏离</font></font></b> <div class="spoiler_text">  ,       ,      127 .       . ,  ,       .     ,   ,        .   8   ,    40  127    .   ,       ? <br><br>   .   —    16 . <br><br>      . 16        —    . ,      ,     call,      . , 11     ( 1023   ).         300  1000  .      ,        .      3  ,     8    .    :   (?nbranch),    (?branch)   (branch).  — 24 . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有条件，生活会变得更轻松:) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们说一个单词。“（点引号）。它在执行时显示指定的文本。使用这种方式：</font></font><br><br><pre> <code class="cpp hljs">.<span class="hljs-string"><span class="hljs-string">"    "</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您只能在编译模式下使用此词。</font><font style="vertical-align: inherit;">在我们分析这个单词的装置之后，这将变得显而易见：</font></font><br><br><pre> <code class="cpp hljs">: .<span class="hljs-string"><span class="hljs-string">" ?state 34 word dup if lit8 [ blword (."</span></span>) find cfa c@ c, ] c, str, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop then ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该词在编译模式下执行。它从输入流到引号（34个字）取一个字符串。如果无法获得该行，则不执行任何操作。虽然，这里最好进行诊断。但是对于该行的输出，这个词正是我们正在做的事情：)如有必要，那么您可以使用诊断程序重新定义这个词。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果有可能获得该字符串，则先编译字节命令（。“），然后再接收该字符串。执行该字节命令（括号内的双引号）时，将显示编译在命令字节后面的字符串</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test ."    " ; ( 0 ): &gt; test     ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，让我们编译一下这个词。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然，在编译模式下，该单词应采用流中下一个单词的名称，并在字典中找到它。然后会有一些选择：它可以是字节命令，也可以是用字节代码编写的单词。这些词必须以不同的方式进行编译。因此，我们将使用两个辅助词：“（compile_b）”和“（compile_c）”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（compile_b）将编译调用命令以调用字节码。参数将是一个64位字-被调用的字节码的地址。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（compile_c）将编译字节命令。因此，该命令的参数将是一个字节-命令代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">好吧，单词compile本身将使用相应的参数编译（compile_b）或（compile_c）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从（compile_c）开始，与最简单的一样：</font></font><br><br><pre> <code class="cpp hljs">: (compile_c) r&gt; dup c@ swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ &gt;rc, ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管它很简单，我们还是先用字节码写一个单词，它本身具有参数。因此，我将发表评论。输入（compile_c）后，返回地址位于返回堆栈上，因为它不是陈旧的。这是调用命令后的下一个字节的地址。通话时的情况如下所示。 A0-调用命令代码，XX-调用命令参数-字（compile_c）字节代码的调用地址（偏移）。</font></font><br><br><img src="https://habrastorage.org/webt/vj/jh/kh/vjjhkhqa7e35ygxdzclv0lf4-pw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回地址指示字节NN。通常有命令下一个字节的代码。但是我们的单词有参数，因此NN只是单词“（compile_c）”的参数，即已编译命令的字节码。您需要读取该字节并通过将其移至下一个字节命令来更改返回地址。这是通过序列“ r&gt; dup c @ swap 1+&gt; r”完成的。此序列将返回地址从返回堆栈拉到常规堆栈，从中检索一个字节，向其添加一个字节（返回地址），然后将其返回到返回堆栈。其余命令“ c”编译从参数获得的字节命令代码。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（compile_b）并不复杂：</font></font><br><br><pre> <code class="cpp hljs">: (compile_b) r&gt; dup @ swap <span class="hljs-number"><span class="hljs-number">8</span></span> + &gt;r compile_b ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里的一切都一样，只读取了64位参数，并且使用了compile_b来编译我们已经为编译器创建的单词。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在这个词编译了。</font><font style="vertical-align: inherit;">正如已经讨论过的，它读取单词的名称，找到它的名称，然后编译前面两个命令之一。</font><font style="vertical-align: inherit;">我不会对此发表评论，我们已经应用并分解了所有使用过的结构。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Word编译</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">: compile blword over over find dup <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dup c@ <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa c@ (compile_b) [ blword (compile_c) find cfa , ] c, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa (compile_b) [ blword (compile_b) find cfa , ] , then drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop .<span class="hljs-string"><span class="hljs-string">" compile: "</span></span> type .<span class="hljs-string"><span class="hljs-string">" - not found"</span></span> then ; immediate</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 要检查创建的单词，我们将在其帮助下制作ifnot单词。 </font></font><br><br><pre> <code class="cpp hljs">: ifnot ?state compile ?branch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 看看吧！ </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = ifnot 1000 . else 0 . then ; ( 0 ): &gt; 22 test 1000 ( 0 ): &gt; 3 test 1000 ( 0 ): &gt; 5 test 0 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切都很好！现在是时候进行循环了…… </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我们将根据条件进行循环。堡垒有条件的自行车有两个选择。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个选择是开始...直到。直到字会从堆栈中删除该值，如果该值不等于零，则循环结束。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个选择是开始...而...重复。在这种情况下，将在执行单词while时进行检查。如果堆栈上的值为零，则退出循环。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堡垒上的循环以与条件相同的方式进行-在有条件和无条件转换上。我带来了代码，我认为不需要注释。</font></font><br><br><pre> <code class="cpp hljs">: begin ?state here <span class="hljs-number"><span class="hljs-number">112</span></span> ; immediate : until ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here - c, ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">113</span></span> ; immediate : repeat ?state <span class="hljs-number"><span class="hljs-number">113</span></span> ?pairs swap compile branch8 here - c, dup here swap - swap c! ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">今天，我们完成了编译器。</font><font style="vertical-align: inherit;">剩下的很少了。</font><font style="vertical-align: inherit;">尚未实现的关键功能中只有带有计数器的循环。</font><font style="vertical-align: inherit;">而且退出退出循环命令也是值得的。</font><font style="vertical-align: inherit;">下次我们会做。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是我们没有经历过循环命令！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们通过写标准单词单词来做到这一点。</font><font style="vertical-align: inherit;">我们最终必须看到我们的字典。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我们首先将单词link @。</font><font style="vertical-align: inherit;">它将从字典条目中提取通信字段（偏移到上一个条目）。</font><font style="vertical-align: inherit;">我们记得，通信字段的大小可以不同：1、2、4或8个字节。</font><font style="vertical-align: inherit;">这个单词将把字典条目的地址放在堆栈上，并返回两个值：名称字段的地址和通讯字段的值。</font></font><br><br><pre> <code class="cpp hljs">: link@ dup c@ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap dup <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap c@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">2</span></span> + swap w@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">4</span></span> + swap i@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop dup <span class="hljs-number"><span class="hljs-number">8</span></span> + swap @ then then then ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，您可以将单词改为： </font></font><br><br><pre> <code class="cpp hljs">: words context @ @ <span class="hljs-number"><span class="hljs-number">0</span></span> begin + dup link@ swap count type tab emit dup <span class="hljs-number"><span class="hljs-number">0</span></span>= until drop drop ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 发射中... </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; words words link@ repeat while until begin ifnot compile (compile_b) (compile_c) ." else then if cmove tab bl decimal hex immediate ; bye ?state ?pairs : str, interpret $compile compile_b compile_n compile_1248 compile_c c, w, i, , allot here h test_bv test_bvc [ ] state .s &gt;in #tib tib . #&gt; #s 60 # hold span holdpoint holdbuf base quit execute cfa find word blword var16 var8 (.") (") count emit expect type lshift rshift invert xor or and &gt;= &lt;= &gt; &lt; = 0&gt; 0&lt; 0= bfind compare syscall fill move rpick r@ r&gt; &gt;r -! +! i! i@ w! w@ c! c@ ! @ depth roll pick over -rot rot swap drop dup abs /mod mod / * - + 1+ 1- exit ?nbranch16 ?nbranch8 ?branch16 ?branch8 branch16 branch8 call8b0 call64 call32 call16 call8f lit64 lit32 lit16 lit8 8 4 3 2 1 0 context definitions current forth ( 0 ): &gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这就是我们的财富：）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我想说的一切...不，我们还是可以使用堡垒程序指定一个文件作为参数进行编译和执行。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用syscall命令打开，关闭和读取文件。</font><font style="vertical-align: inherit;">我们为它们定义必要的常数。</font></font><br><br><pre> <code class="cpp hljs">: file_open <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> syscall ; : file_close <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> syscall ; : file_read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> syscall ; : file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> ; : file_O_WRONLY <span class="hljs-number"><span class="hljs-number">1</span></span> ; : file_O_RDWR <span class="hljs-number"><span class="hljs-number">3</span></span> ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，您可以将起始词_start设置为： </font></font><br><br><pre> <code class="cpp hljs">: _start <span class="hljs-number"><span class="hljs-number">0</span></span> pick <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pick file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> file_open dup <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .\<span class="hljs-string"><span class="hljs-string">" error: \" . quit then dup here 32 + 32768 file_read dup 0&lt; if .\" error: \" . quit then swap file_close drop #tib ! here 32 + tib ! 0 &gt;in ! interpret then ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该字将从文件中加载并执行任何要塞程序。</font><font style="vertical-align: inherit;">更准确地说，解释器将执行此文件中的所有内容。</font><font style="vertical-align: inherit;">例如，可能会有新单词的汇编及其执行。</font><font style="vertical-align: inherit;">文件名在启动时由第一个参数指示。</font><font style="vertical-align: inherit;">我不会详细介绍，但是Linux中的启动参数是通过堆栈传递的。</font><font style="vertical-align: inherit;">单词_start将通过命令0 pick（参数数量）和2 pick（指向第一个参数的指针）到达它们。</font><font style="vertical-align: inherit;">对于一个堡垒系统，这些值位于堆栈之外，但是您可以使用pick命令获取它们。</font><font style="vertical-align: inherit;">文件大小限制为32 KB，而没有内存管理。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在仍然需要在末尾的fcode行中写：</font></font><br><br><pre> <code class="cpp hljs">_start quit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建文件test.f并在要塞上写一些东西。</font><font style="vertical-align: inherit;">例如，用于找到最大公因子的欧几里得算法：</font></font><br><br><pre> <code class="cpp hljs">: NOD begin over over &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> over over &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> swap over - swap <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> over - then repeat drop ; <span class="hljs-number"><span class="hljs-number">23101</span></span> <span class="hljs-number"><span class="hljs-number">44425</span></span> NOD . bye</code> </pre><br> 我们开始。 <br><br><pre> <code class="plaintext hljs">$ ./forth test.f 1777 Bye! $</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">答案是正确的。</font><font style="vertical-align: inherit;">这个词被编译，然后实现。</font><font style="vertical-align: inherit;">显示结果，然后执行再见命令。</font><font style="vertical-align: inherit;">如果删除最后两行，则将NOD单词添加到字典中，系统将转到其命令行。</font><font style="vertical-align: inherit;">您已经可以编写程序了：-)</font></font><br><br> 仅此而已。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">谁在乎，您可以从Github下载x86-64上Linux的源代码或现成的二进制文件：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">//github.com/hal9000cc/forth64</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码随附</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU GPL v2</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCH v1 </font><font style="vertical-align: inherit;">许可证</font><font style="vertical-align: inherit;">-做您想做的事情:-)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437466/">https://habr.com/ru/post/zh-CN437466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437454/index.html">测力计Felix M评估</a></li>
<li><a href="../zh-CN437456/index.html">较年轻：Snom D315和D305 IP电话的评论</a></li>
<li><a href="../zh-CN437458/index.html">通过IMEI强制注册才能付款</a></li>
<li><a href="../zh-CN437460/index.html">32 GB假闪存驱动器示例</a></li>
<li><a href="../zh-CN437464/index.html">打字稿价格</a></li>
<li><a href="../zh-CN437468/index.html">Retropie Dreamcast</a></li>
<li><a href="../zh-CN437470/index.html">关于导弹防御的几句话</a></li>
<li><a href="../zh-CN437472/index.html">从办公室到udalenka的过渡：分享经验和生活技巧</a></li>
<li><a href="../zh-CN437474/index.html">使用Unity声音导入选项优化游戏性能</a></li>
<li><a href="../zh-CN437476/index.html">好的，Yandex！ 我们的达成目标在哪里？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>