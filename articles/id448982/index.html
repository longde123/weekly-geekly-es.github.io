<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔱 💩 🗓️ CMS tanpa kepala. Kenapa aku menulis milikku 👨🏾‍💼 🤱🏻 🛌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Artikel terbaru ini mendorong saya untuk menulis publikasi ini (saya melihatnya kemarin). 

 Ceritakan kembali fitur utama Headless ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CMS tanpa kepala. Kenapa aku menulis milikku</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448982/"> Halo semuanya! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel terbaru ini mendorong</a> saya untuk menulis publikasi ini (saya melihatnya kemarin). <br><br>  Ceritakan kembali fitur utama Headless / content-first / api-first, dll.  Saya tidak akan menjadi CMS, materi sudah penuh dan mungkin banyak yang sudah terbiasa dengan tren ini.  Dan saya ingin memberi tahu Anda mengapa dan bagaimana saya menulis sistem saya, mengapa saya tidak bisa memilih dari yang ada, apa yang saya pikirkan tentang sistem lain yang telah saya temui sebelumnya dan prospek apa yang saya lihat untuk semua ini.  Fiksi akan banyak sekali (untuk materi dalam dua tahun), tetapi saya akan mencoba menulis lebih menarik dan bermanfaat.  Siapa yang peduli, tolong, di bawah kucing. <br><a name="habracut"></a><br>  Secara umum, ceritanya sangat panjang dan saya akan mencoba menceritakannya terlebih dahulu.  Entah untuk membuatnya lebih jelas apa alasan sebenarnya untuk membuat mesin ini sendiri, atau hanya karena tanpa ini akan sulit di lapangan untuk menjelaskan mengapa saya melakukannya dengan cara ini, dan bukan dengan cara tertentu. <br><br>  Tetapi untuk memulainya, saya akan secara singkat menuliskan kriteria seleksi utama untuk CMS Tanpa Kepala modern bagi saya secara pribadi, mengapa saya masih tidak dapat memilih solusi yang sudah jadi untuk saya sendiri.  <i>Supaya orang-orang tidak berhenti membaca banyak beech, tidak mengerti apa yang pada akhirnya akan diceritakan.</i> <br><br>  Secara singkat: Saya ingin semuanya berada di satu tempat: bagian belakang dan depan (dan bukan ini atau itu), dan GraphQL-API, dan bahwa basis data dikelola dan banyak lagi, termasuk tombol "Make Beautiful".  Saya belum menemukan ini.  Saya sendiri belum melakukan ini, tetapi secara keseluruhan ternyata cukup banyak, dan yang paling penting, ini memungkinkan saya untuk melakukan proyek nyata. <br><br>  Jadi, pendekatan saya hampir tidak bisa disebut ilmiah dan dibenarkan.  Faktanya adalah saya biasanya sangat sering menulis sesuatu sendiri.  Saya suka program di sini.  Dan dua tahun lalu (dan sebelum itu 8 tahun lagi) saya duduk di MODX CMF (di mana saya juga menemukan banyak kruk saya).  Dan selama tiga tahun kami memulai satu proyek berskala besar, di mana, menurut saya, saya bisa menggunakan MODX.  Tapi ternyata, saya tidak bisa ... Alasan utamanya adalah itu adalah startup tanpa persyaratan teknis, dengan banyak ide yang berubah dan ditambah setiap hari (dan beberapa kali sehari).  Dan sekarang, setiap kali ketika di bawah ide baru perlu menambahkan beberapa entitas baru, mendaftar / mengubah bidang untuk yang sudah ada, membuat / menghapus / mengubah hubungan antara entitas-entitas ini (masing-masing, dengan perubahan dalam struktur database), saya memiliki beberapa titik Mulai beberapa jam untuk mengubah entitas ini.  Memang, selain fakta bahwa perlu mendaftarkan perubahan-perubahan ini dalam skema, perlu mengubah database (hampir secara manual), memperbarui API, menulis ulang kode program, dll., Dll.  Karenanya, bagian depan harus diperbarui berdasarkan semua ini.  Akibatnya, saya memutuskan bahwa kita harus mencari sesuatu yang baru, lebih nyaman, yang entah bagaimana akan menyederhanakan semua ini.  Saya akan mengklarifikasi sekali lagi bahwa pada saat itu saya adalah backend php, jadi jangan kaget atau tertawa bahwa saya mulai menemukan berbagai pembangun front-end, prosesor yang lebih sedikit, npm, dll.  dll.  Tapi bagaimanapun, secara bertahap dalam proyek kami sebuah front muncul pada reaksi + kurang, API pada GraphQL, dan server pada express. <br><br>  Tetapi tidak semuanya semarak seperti kelihatannya bagi banyak orang sekarang.  Biarkan saya mengingatkan Anda, ini lebih dari dua tahun yang lalu.  Jika Anda berada di web JS modern selama kurang dari dua tahun, saya menyarankan Anda untuk membaca artikel ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">N alasan untuk menggunakan Aplikasi Buat Reaksi</a> (habr).  Singkatnya, terlalu malas: dengan munculnya skrip reaksi, Anda tidak dapat repot dengan mengonfigurasi webpack, dll.  Semua ini masuk ke latar belakang.  Orang-orang baik telah mengonfigurasi webpack sehingga sebagian besar proyek reaksi hampir dijamin untuk mengerjakannya, dan pengembang akhir berfokus langsung pada pemrograman produk akhir, daripada mengonfigurasi banyak dependensi, loader, dll.  Tapi ini nanti.  Dan sebelum itu, saya hanya perlu mengkonfigurasi paket web ini, ikuti pembaruan tumpukan semua yang terbang dengannya untuk mengejar ketinggalan, dll.  dll.  Tapi ini hanya bagian dari pekerjaan, pada dasarnya hanya bagian depan.  Dan Anda juga membutuhkan server.  Dan Anda juga membutuhkan API.  Dan Anda juga perlu SSR (Server-side rendering), yang, omong-omong, masih bereaksi-skrip tidak memberikan, sejauh yang saya tahu.  Secara umum, semuanya jauh lebih rumit daripada daripada sekarang, tidak ada banyak, dan semua orang mengeruk sebaik mungkin.  Dan bagaimana saya kruk lalu ... <br><br>  Bayangkan saja: <br><br><ul><li>  Konfigurasi webpack asli secara terpisah untuk depan dan server. </li><li>  Implementasi SSR sendiri, sehingga async bekerja secara normal dengan server reaksi, dan gaya segera siap tiba, dan diindeks secara normal, dan status server untuk halaman yang tidak ditemukan diberikan. </li><li>  Tidak ada redux.  Yah, saya tidak langsung suka redux.  Saya menyukai ide menggunakan fluks reaksi asli saya (walaupun saya harus menulis ulang sedikit untuk diri saya sendiri). </li><li>  Skema dan resolver GraphQL yang diresepkan secara manual, tanpa penyebaran database secara otomatis (server API digunakan sebagai perantara untuk situs MODX). </li><li>  Tidak ada reaksi-apollo / apollo-klien, dll.  Semuanya ditulis secara independen dengan permintaan melalui fetch, repositori dalam browser berdasarkan fluks kustom. </li></ul><br>  Akibatnya: sampai sekarang, salah satu versi pertama ini memiliki satu proyek dengan kehadiran lebih dari 500, dan di musim (musim dingin) 1000-1700 siswa unik per hari.  Waktu kerja 2 bulan.  Ini karena saya secara manual me-reboot server setelah pembaruan perangkat lunak pencegahan.  Dan sebelum reboot ini, uptime adalah 6+ bulan lagi.  Namun yang paling menarik adalah konsumsi memori.  Saat ini ada hampir 700 megabytes proses js.  Ya, ya, saya juga tertawa dengan Anda di sini :) Tentu saja, ini banyak.  Dan sebelum itu saya melakukan sedikit pencegahan dan meningkatkan indikator ini.  Sebelumnya, ada total 1000 juta + per proses ... Namun demikian, ini berhasil dan cukup dapat ditoleransi.  Dan sebelum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google mengubah algoritma PageSpeed ​​Insights</a> pada bulan November, situs tersebut memiliki metrik kinerja 97/100.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bukti</a> <br><br>  Kesimpulan antara berdasarkan proyek ini berdasarkan pada sistem yang dikembangkan lebih lanjut tanpa proyek ini (proyek tertinggal): <br><br>  <b>Pro</b> <br><br><ol><li>  API proyek menjadi lebih fleksibel melalui penggunaan GraphQL, dan jumlah permintaan server telah berkurang secara signifikan. </li><li>  Proyek ini memiliki akses ke sejumlah besar komponen pada npm. </li><li>  Manajemen proyek menjadi lebih transparan melalui penggunaan dependensi, git, dll. </li><li>  Skrip dan gaya bawaan jelas lebih menyenangkan daripada banyak skrip terpisah di situs lama, ketika Anda tidak tahu apa yang dapat Anda hapus dari kebun binatang ini tanpa konsekuensi (dan Anda sering melihat beberapa versi bug di satu situs). </li><li>  Situs ini menjadi lebih interaktif, halaman berfungsi tanpa me-reboot, kembali ke halaman yang dilihat sebelumnya tidak memerlukan panggilan berulang ke server. </li><li>  Pengeditan data dilakukan langsung di halaman, dengan prinsip "edit apa yang Anda lihat dan di mana Anda melihat", tanpa panel admin yang terpisah. </li></ol><br>  <b>Kontra (terutama untuk pengembang)</b> <br><br><ol><li>  Semuanya sangat rumit.  Sungguh.  Tidak realistis untuk menghubungkan beberapa pengembang pihak ketiga ke proyek.  Saya sendiri sulit menemukan apa dan bagaimana cara kerjanya dan dari mana kaki saya tumbuh.  Jika Anda melihat hal 3 dari plus, di mana dikatakan tentang transparansi, maka transparansi hanya dalam hal itu jika Anda mengaitkan sesuatu di suatu tempat, Anda dapat langsung melihat apa yang rusak (skrip tidak membangun, dll.), Tetapi dengan komit dan berbeda Anda bisa menemukan di mana ketagihan itu.  Nah, jika Anda berhasil menambahkan sesuatu yang baru dan berfungsi, setidaknya Anda jelas memahami itu, ya, semuanya berjalan dengan baik.  Tapi secara keseluruhan itu masih neraka. </li><li>  Kesulitan dengan caching.  Kemudian, saya menemukan klien-apollo untuk diri saya sendiri.  Dan sebelum itu, seperti yang saya katakan, saya menulis penyimpanan berbasis fluks.  Karena penyimpanan ini, dimungkinkan untuk mendapatkan data yang diperlukan untuk rendering dari komponen yang berbeda, tetapi volume cache pada sisi klien sangat besar (setiap set entitas yang khas memiliki repositori sendiri).  Akibatnya, sulit untuk memverifikasi apakah objek diminta sebelumnya atau tidak (yaitu, apakah layak untuk membuat permintaan ke server untuk menemukannya), apakah semua data terkait tersedia, dll. </li><li>  Kesulitan dengan skema, struktur database dan resolvers (fungsi API untuk menerima / memodifikasi data).  Seperti yang saya katakan, saya menulis skema secara manual, dan resolvers juga.  Pada apa dalam resolvers saya mencoba memberikan caching, dan memproses permintaan bersarang dan seluk-beluk lainnya.  Pada saat itu saya harus masuk jauh ke esensi dan kode program GraphQL.  Keuntungannya adalah saya secara umum memahami dengan baik bagaimana GraphQL bekerja, apa kelebihan dan kekurangannya, dan cara memasaknya dengan lebih baik.  Kelemahannya adalah, tentu saja, Anda tidak dapat menulis semua fasilitas dan roti yang ditulis dengan perintah seperti apollo dalam satu.  Akibatnya, ketika saya menemukan apollo, tentu saja, saya mulai menggunakan komponen mereka dengan sangat senang (tetapi terutama di bagian depan, saya akan memberi tahu Anda alasannya di bawah). </li></ol><br>  Secara umum, proyek ini menggunakan teknologi yang sudah ketinggalan zaman secara pribadi adalah milik saya pada 100%, jadi saya dapat meninggalkannya sampai waktu yang lebih baik.  Tetapi ada proyek-proyek lain yang saya harus melangkah lebih jauh dan mengembangkan platform.  Dan beberapa kali saya harus menulis ulang semuanya dari awal.  Selanjutnya, saya akan berbicara lebih detail tentang tugas-tugas individu yang saya temui dan solusi apa yang saya kembangkan dan terapkan sebagai hasilnya. <br><br>  <b>Skema-pertama.</b>  <b>Pertama sirkuit, dan kemudian segalanya</b> <br><br>  Situs (antarmuka web, thin client, dll.) Adalah semua tampilan informasi (well, manajemen informasi, jika diizinkan dan fungsionalitas memungkinkan).  Tapi pertama-tama, semuanya sama, sebuah basis data (tabel, kolom, dll.).  Setelah menemui beberapa pendekatan berbeda untuk bekerja dengan database dalam perjalanan, saya paling menyukai pendekatan Schema-first.  Yaitu, Anda menggambarkan skema entitas dan tipe data (secara manual atau melalui antarmuka), menggunakan skema, dan Anda segera memiliki perubahan yang dijelaskan dalam database (tabel / kolom dibuat / dihapus, serta hubungan di antara mereka).  Bergantung pada implementasinya, Anda juga akan menghasilkan semua fungsi penyelesai yang diperlukan untuk mengelola data ini.  Yang paling penting dalam arah ini saya menyukai proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prisma.io</a> . <br><br>  Dengan izin Anda, karena bahkan di hub saya belum melihat satu artikel tentang prisma, saya akan menarik perhatian mereka sedikit, karena proyek ini sangat menarik, dan tanpa mereka saya tidak akan memiliki platform seperti sekarang yang membuat saya sangat bahagia .  Sebenarnya, itu sebabnya saya menyebut platform saya prisma-cms, karena prisma.io memainkan peran yang sangat besar di dalamnya. <br><br>  Sebenarnya, prisma.io adalah proyek SaaS, tetapi dengan peringatan besar: mereka menempatkan hampir semua yang mereka lakukan pada github.  Artinya, Anda dapat menggunakan server mereka dengan biaya yang sangat masuk akal (dan konfigurasikan database dan API Anda sendiri untuk diri sendiri dalam hitungan menit), atau Anda dapat sepenuhnya menggunakan semuanya di rumah.  Dalam hal ini, prisma harus secara logis dibagi menjadi dua bagian terpisah yang penting: <br><br><ol><li>  Prisma-server, yaitu server tempat basis data juga berputar. </li><li>  Prisma-klien.  Ini pada dasarnya juga merupakan server, tetapi dalam kaitannya dengan sumber data (prisma-server) itu adalah klien. </li></ol><br>  Sekarang saya akan mencoba menjelaskan situasi yang membingungkan ini.  Secara umum, inti dari prisma adalah menggunakan titik akhir API tunggal, Anda dapat bekerja dengan sumber data yang berbeda.  Ya, di sini siapa pun akan mengatakan bahwa mereka semua datang dengan GraphQL dan prisma tidak diperlukan di sini.  Secara umum, semua orang akan benar, tetapi ada poin serius: GraphQL hanya mendefinisikan prinsip-prinsip dan pekerjaan secara keseluruhan, tetapi dengan sendirinya, itu tidak memberikan pekerjaan dengan sumber data akhir di luar kotak.  Dia mengatakan, "Anda dapat membuat API untuk menggambarkan permintaan apa yang dapat dikirim pengguna, tetapi bagaimana Anda menangani permintaan ini terserah Anda."  Dan prisma juga, tentu saja, menggunakan GraphQL (omong-omong, dan banyak hal lainnya, termasuk berbagai produk apollo).  Tetapi prisma plus untuk ini hanya menyediakan pekerjaan dengan database.  Artinya, menggambarkan skema dan penyebarannya, tabel dan kolom yang diperlukan (serta hubungan di antara mereka) akan segera dibuat dalam database yang ditentukan, dan bahkan segera menghasilkan semua fungsi CRUD yang diperlukan.  Artinya, dengan prisma, Anda tidak hanya mendapatkan server GraphQL, tetapi API kerja lengkap yang segera memungkinkan Anda untuk bekerja dengan database.  Jadi, Prisma-server menyediakan basis data dan interaksi dengannya, dan prisma-klien memungkinkan Anda untuk menulis resolver dan mengirim permintaan ke server-prisma (atau di tempat lain, bahkan untuk beberapa server prisma).  Dan ternyata Anda hanya dapat menggunakan prisma-klien sendiri (dan prisma.io SaaS akan digunakan sebagai prisma-server), dan Anda dapat menggunakan prisma-server sendiri, dan umumnya tidak bergantung pada prisma dengan cara apa pun, itu saja milikmu. <br><br>  Di sini saya telah memilih prisma untuk diri saya sendiri, sebagai dasar untuk platform saya.  Tapi kemudian saya harus memutarnya sendiri untuk mendapatkan platform penuh. <br><br><h4>  1. Gabungkan skema </h4><br>  Pada saat itu, prisma tidak dapat menggabungkan sirkuit.  Artinya, tugasnya adalah sebagai berikut: <br><br>  Anda memiliki model pengguna yang dijelaskan dalam satu modul <br><br><pre><code class="javascript hljs">type User { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: ID! @unique username: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! @unique email: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> @unique }</code> </pre> <br>  dan dalam modul lain <br><br><pre> <code class="javascript hljs">type User { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: ID! @unique username: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! @unique firstname: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> lastname: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> }</code> </pre><br>  Sebagai bagian dari satu proyek, Anda ingin menggabungkan kedua skema ini secara otomatis untuk mendapatkan hasil <br><br><pre> <code class="javascript hljs">type User { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: ID! @unique username: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>! @unique email: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> @unique firstname: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> lastname: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> }</code> </pre><br>  Tapi kemudian prisma ini tidak bisa dilakukan.  Ternyata mengimplementasikan ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka merge-graphql-schemas</a> . <br><br><h4>  Bekerja dengan prisma-server sewenang-wenang. </h4><br>  Dalam prisma, konfigurasi ditulis dalam file konfigurasi khusus.  Jika Anda ingin mengubah alamat server prisma yang digunakan, Anda harus mengedit file.  Agak, tidak menyenangkan.  Saya ingin membuat URL mungkin untuk ditentukan dalam perintah, misalnya endpoint = http: // endpoint-address yarn deploy (awal benang).  Itu terbunuh selama beberapa hari ... Tapi sekarang Anda dapat menggunakan satu proyek prisma untuk sejumlah titik akhir.  By the way, prisma-cms sejauh ini dengan mudah bekerja bahkan dengan database lokal, bahkan dengan server prisma SaaS. <br><br><h4>  Modul / Plugin </h4><br>  Ini umumnya tidak cukup.  Seperti yang saya katakan, tugas utama prisma adalah menyediakan pekerjaan dengan berbagai basis data.  Dan mereka melakukan pekerjaan dengan sangat baik.  Sudah, mereka mendukung bekerja dengan MySQL, PostgreSQL, Amazon RDS dan MongoDB, beberapa jenis lebih banyak sumber di jalan.  Tetapi mereka tidak menyediakan infrastruktur modular apa pun.  Sejauh ini tidak ada pasar atau sesuatu seperti itu.  Hanya ada beberapa kekosongan khas.  Tetapi Anda tidak dapat memilih dua atau tiga dari beberapa kekosongan dan menginstal pada satu proyek.  Kita harus memilih satu.  Saya ingin sehingga mungkin untuk menginstal sejumlah modul yang berbeda pada tugas akhir, dan ketika memasang sirkuit dan resolver akan bergembira dan mendapatkan proyek tunggal dengan fungsionalitas total.  Dan meskipun belum ada antarmuka grafis, sudah ada lebih dari dua lusin modul dan komponen yang dapat digabungkan pada tugas akhir.  Di sini saya akan segera memutuskan sedikit tentang definisi pribadi: modul adalah apa yang dipasang di belakang (memperluas database dan API), dan komponen adalah apa yang dipasang di depan (untuk menambahkan berbagai elemen antarmuka).  Sejauh ini, tidak ada antarmuka grafis untuk menghubungkan modul, tetapi tidak sulit bagi saya untuk menulis dengan cara ini (ini tidak sering dilakukan): <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(options = {}) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(options); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mergeModules([ LogModule, MailModule, UploadModule, SocietyModule, EthereumModule, WebrtcModule, UserModule, RouterModule, ]); }</code> </pre><br>  Setelah menambahkan modul baru, cukup hanya melakukan penyebaran dengan satu perintah lagi dan hanya itu, di sini kita sudah memiliki tabel / kolom baru dan fungsi tambahan. <br><br><h4>  5 depan, responsif terhadap perubahan di backend </h4><br>  Ini sama sekali tidak cukup.  Ini akan diikuti oleh penyimpangan.  Faktanya adalah bahwa semua CMS API-pertama yang saya lihat mengatakan "Kami luar biasa untuk menyediakan API, dan Anda mengacaukan bagian depan yang Anda inginkan."  Ini adalah apa yang mereka "sekrupkan apa pun yang kamu suka" sebenarnya berarti "mengganggu sesukamu."  Persis sama dengan kerangka kerja UI mengatakan, "lihat apa tombol keren kita dan lakukan semua itu, dan bingung dengan backend sendiri".  Itu selalu membunuh.  Saya hanya ingin menemukan CMS komprehensif yang ditulis dalam javascript, menggunakan GraphQL dan menyediakan bagian belakang dan depan.  Tetapi saya tidak menemukan yang seperti itu.  Saya benar-benar ingin perubahan API segera dirasakan di depan.  Dan untuk ini, beberapa subteps diselesaikan: <br><br><h4>  5.1 Menghasilkan fragmen API </h4><br>  Di depan, fragmen dari file skema terdaftar dalam permintaan.  Ketika API dibangun kembali di server, file JS baru dengan fragmen API juga dihasilkan.  Dan dalam permintaan tertulis seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { UserNoNestingFragment, EthAccountNoNestingFragment, NotificationTypeNoNestingFragment, BatchPayloadNoNestingFragment, } = queryFragments; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userFragment = <span class="hljs-string"><span class="hljs-string">` fragment user on User { ...UserNoNesting EthAccounts{ ...EthAccountNoNesting } NotificationTypes{ ...NotificationTypeNoNesting } } </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${UserNoNestingFragment}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${EthAccountNoNestingFragment}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${NotificationTypeNoNestingFragment}</span></span></span><span class="hljs-string"> `</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> usersConnection = <span class="hljs-string"><span class="hljs-string">` query usersConnection ( $where: UserWhereInput $orderBy: UserOrderByInput $skip: Int $after: String $before: String $first: Int $last: Int ){ objectsConnection: usersConnection ( where: $where orderBy: $orderBy skip: $skip after: $after before: $before first: $first last: $last ){ aggregate{ count } edges{ node{ ...user } } } } </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${userFragment}</span></span></span><span class="hljs-string"> `</span></span>;</code> </pre><br><h4>  5.2 Satu konteks untuk semua komponen </h4><br>  Bereaksi 16.3 memperkenalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API konteks baru</a> .  Saya membuatnya sehingga dalam komponen anak di tingkat mana pun dimungkinkan untuk mengakses konteks tunggal tanpa mencantumkan jenis yang sebelumnya diinginkan dari konteks, tetapi hanya menunjukkan static contextType = PrismaCmsContext dan mendapatkan semua pesona melalui konteks ini-&gt; (termasuk klien API, skema , permintaan, dll.). <br><br><h4>  5.3 filter dinamis </h4><br>  Saya juga sangat ingin.  GraphQL memungkinkan Anda membangun kueri kompleks dengan struktur bersarang.  Saya ingin filter menjadi dinamis juga, dibentuk dari skema API, dan memungkinkan kami membuat kondisi bersarang.  Inilah yang terjadi: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YOCF3ttK2Mg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h4>  5.4 Pembuat Situs Web </h4><br>  Dan akhirnya, yang kurang dari saya adalah editor situs eksternal, yaitu seorang desainer.  Saya hanya menginginkan tindakan minimum yang dilakukan di server, dan semua desain akhir harus dilakukan di depan (termasuk mengatur rute, membuat pilihan, dll.).  Ini adalah topik untuk artikel terpisah, karena di antara hal-hal lain, saya juga menulis editor wysiwyg kruk saya untuk itu pada contentEditable murni, dan ada banyak seluk-beluk.  Jika saya dikembalikan ke hak saya dan siapa yang akan tertarik, saya akan menulis artikel terpisah. <br><br>  Yah, akhirnya, video demo pendek dari perancang beraksi.  Masih cukup mentah, tetapi saya menyukainya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4j9ePxDhHGU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Saya akan menyelesaikannya.  Saya belum banyak menulis, apa yang ingin saya tulis, tetapi banyak yang telah terjadi.  Saya akan senang berkomentar. <br><br>  PS: semua kode sumber, termasuk kode sumber situs itu sendiri, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada di sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448982/">https://habr.com/ru/post/id448982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448968/index.html">PHP asinkron. Mengapa</a></li>
<li><a href="../id448970/index.html">Otentikasi dua faktor untuk SSH</a></li>
<li><a href="../id448974/index.html">Pendekatan tanpa server untuk pengembangan cepat layanan video yang berfungsi</a></li>
<li><a href="../id448976/index.html">Peristiwa musim semi Gamedev di HSE</a></li>
<li><a href="../id448980/index.html">Makan siang pertama kami bersama: mengapa dan bagaimana kami menghabiskan hari ujian kami</a></li>
<li><a href="../id448986/index.html">Rekayasa balik 3D dengan pemindaian 3D</a></li>
<li><a href="../id448988/index.html">Kingston SSD menjadi lebih luas, mempertahankan biaya yang hampir sama - kami memenuhi seri A400-R</a></li>
<li><a href="../id448992/index.html">Hashing serbaguna dan sempurna</a></li>
<li><a href="../id448994/index.html">Apakah sulit untuk memulai jalur perekrut TI?</a></li>
<li><a href="../id448996/index.html">Membuat kebijakan kata sandi di Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>