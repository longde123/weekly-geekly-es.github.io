<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‡ ğŸ†š ğŸ‘¨ğŸ½â€ğŸ¤ Membuat generator puzzle prosedural ğŸ§—ğŸ¿ ğŸ§–ğŸ¼ ğŸ‘©â€âš–ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Posting ini menjelaskan generator level untuk permainan puzzle Linjat saya. Posting dapat dibaca tanpa persiapan, tetapi lebih mudah untuk berasimilas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat generator puzzle prosedural</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452090/"> Posting ini menjelaskan generator level untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permainan</a> puzzle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Linjat</a> saya.  Posting dapat dibaca tanpa persiapan, tetapi lebih mudah untuk berasimilasi jika Anda bermain di beberapa level.  Saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memposting</a> kode sumber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di github</a> ;  semua yang dibahas dalam artikel ini ada di file <code>src/main.cc</code> <br><br>  Paket contoh pos: <br><br><ul><li>  Linjat adalah gim logika di mana Anda harus menutup semua angka dan poin dalam kotak dengan garis. </li><li>  Teka-teki ini dihasilkan secara prosedural menggunakan kombinasi solver, generator, dan optimizer. </li><li>  Solver mencoba memecahkan teka-teki dengan cara yang akan dilakukan seseorang, dan memberikan peringkat menarik kepada setiap teka-teki. </li><li>  Generator puzzle dirancang sedemikian rupa sehingga memungkinkan untuk dengan mudah mengubah satu bagian dari puzzle (angka), sementara semua bagian lainnya (poin) diubah sehingga puzzle tetap dapat dipecahkan. </li><li>  Pengoptimal puzzle berulang kali memecahkan level dan menghasilkan variasi baru dari yang paling menarik yang ditemukan saat ini. </li></ul><br><h3>  Aturannya </h3><br>  Untuk memahami bagaimana generator level bekerja, Anda perlu, sayangnya, untuk memahami aturan permainan.  Untungnya, mereka sangat sederhana.  Teka-teki ini terdiri dari kisi yang berisi kotak, angka, dan titik kosong.  Contoh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br>  Tujuan pemain adalah menggambar garis vertikal atau horizontal melalui masing-masing angka, dengan tunduk pada tiga syarat: <br><br><ul><li>  Garis melalui angka harus sama panjang dengan angka. </li><li>  Garis tidak dapat berpotongan. </li><li>  Semua poin harus ditutup dengan garis. </li></ul><br>  Contoh solusi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br>  Hore!  Desain game sudah siap, UI diimplementasikan, dan sekarang satu-satunya yang tersisa adalah menemukan beberapa ratus teka-teki yang bagus.  Dan untuk gim semacam itu, biasanya tidak masuk akal untuk mencoba membuat puzzle semacam itu secara manual.  Ini adalah pekerjaan komputer. <br><a name="habracut"></a><br><h3>  Persyaratan </h3><br>  Apa yang membuat puzzle untuk game ini bagus?  Saya cenderung percaya bahwa permainan puzzle dapat dibagi menjadi dua kategori.  Ada gim di mana Anda menjelajahi ruang keadaan rumit dari awal hingga akhir (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sokoban</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rush Hour</a> ), dan di mana mungkin tidak jelas status mana yang ada dalam gim tersebut.  Dan ada permainan di mana semua negara diketahui dari awal, dan kami secara bertahap membuat ruang negara menggunakan proses menghilangkan yang tidak perlu (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sudoku</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Picross</a> ).  Game saya pasti termasuk dalam kategori kedua. <br><br>  Pemain memiliki persyaratan yang sangat berbeda untuk berbagai jenis teka-teki ini.  Dalam kasus kedua, mereka berharap bahwa puzzle hanya dapat diselesaikan dengan deduksi, dan bahwa mereka tidak akan pernah perlu kembali / tebak / coba-coba <sup>[0]</sup> <sup>[1]</sup> . <br><br>  Tidak cukup hanya untuk mengetahui apakah sebuah teka-teki hanya dapat diselesaikan dengan logika.  Selain itu, kita perlu entah bagaimana memahami seberapa baik teka-teki yang dibuat.  Kalau tidak, sebagian besar level akan hanya terak sepele.  Dalam situasi yang ideal, prinsip ini juga dapat digunakan untuk membuat kurva kemajuan yang halus, sehingga saat pemain maju melalui permainan, levelnya secara bertahap menjadi lebih sulit. <br><br><h3>  Solver </h3><br>  Langkah pertama untuk memenuhi persyaratan ini adalah membuat pemecah permainan yang dioptimalkan untuk tujuan ini.  Solver backtracking memungkinkan Anda untuk dengan cepat dan akurat menentukan apakah puzzle dapat dipecahkan;  selain itu, dapat dimodifikasi untuk menentukan apakah solusinya unik.  Tapi dia tidak bisa memberikan gambaran betapa rumitnya teka-teki itu, karena orang menyelesaikannya secara berbeda.  Solver harus meniru perilaku manusia. <br><br>  Bagaimana seseorang memecahkan teka-teki ini?  Berikut adalah beberapa langkah nyata yang diajarkan oleh tutorial dalam game: <br><br><ul><li>  Jika suatu titik dapat dicapai hanya dari satu angka, maka untuk menutup suatu titik Anda perlu menggambar garis dari angka itu.  Dalam contoh ini, poin hanya dapat dicapai dari ketiganya, tetapi tidak dari empat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br>  Dan ini mengarah pada situasi ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li><li>  Jika garis tidak pas di satu arah, maka harus ditempatkan di yang lain.  Pada contoh di atas, keempat tidak dapat lagi diposisikan secara vertikal, jadi kita tahu bahwa itu akan horisontal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li><li>  Jika diketahui bahwa garis panjang X harus dalam posisi tertentu (vertikal / horizontal) dan tidak ada ruang kosong yang cukup untuk menempatkan garis sel kosong X di kedua sisi, maka Anda perlu menutup beberapa kotak di tengah.  Jika keempatnya tiga dalam contoh yang ditunjukkan di atas, maka kita tidak akan tahu apakah itu membentang sampai ke kanan atau kiri.  Tapi kita akan tahu bahwa garis harus mencakup dua kotak tengah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li></ul><br>  Alasan yang sama adalah dasar dari game ini.  Pemain mencari cara untuk merentangkan satu garis kecil, dan kemudian memeriksa bidang lagi, karena itu dapat memberinya informasi untuk membuat kesimpulan logis lain.  Membuat solver yang mengikuti aturan-aturan ini akan cukup untuk menentukan <i>apakah</i> seseorang dapat memecahkan puzzle tanpa kembali. <br><br>  Namun, ini tidak memberi tahu kami apa pun tentang kompleksitas atau ketertarikan level.  Selain solvabilitas, kita perlu mengukur kompleksitas. <br><br>  Gagasan pertama yang jelas untuk fungsi peringkat: semakin banyak gerakan yang Anda butuhkan untuk menyelesaikan teka-teki, semakin sulit.  Ini mungkin metrik yang baik di gim lain, tetapi saya, kemungkinan besar, lebih penting daripada jumlah gerakan yang diizinkan yang dimiliki pemain.  Jika seorang pemain dapat membuat 10 kesimpulan logis, maka ia kemungkinan besar akan menemukan salah satu dari mereka dengan sangat cepat.  Jika hanya ada satu gerakan yang benar, itu akan membutuhkan lebih banyak waktu. <br><br>  Artinya, sebagai perkiraan pertama, kita membutuhkan pohon keputusan untuk menjadi dalam dan sempit: ada ketergantungan yang panjang dari gerakan dari awal ke akhir, dan pada setiap saat waktu hanya ada sejumlah kecil cara untuk naik ke atas rantai <sup>[2]</sup> . <br><br>  Bagaimana kita menentukan lebar dan kedalaman pohon?  Solusi tunggal untuk teka-teki dan evaluasi pohon yang dibuat tidak akan memberikan jawaban yang pasti.  Urutan yang tepat di mana gerakan dilakukan mempengaruhi bentuk pohon.  Kita perlu mempertimbangkan semua solusi yang mungkin dan lakukan dengan mereka sesuatu seperti optimasi untuk kasus terbaik dan terburuk.  Saya akrab dengan teknik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian kasar grafik pencarian di permainan puzzle</a> , tetapi untuk proyek ini saya ingin membuat pemecah satu arah, dan bukan pencarian yang lengkap.  Karena fase optimasi, saya mencoba memastikan bahwa runtime dari solver diukur tidak dalam hitungan detik, tetapi dalam milidetik. <br><br>  Saya memutuskan untuk tidak melakukannya.  Sebagai gantinya, pemecah saya sebenarnya tidak membuat satu langkah pada satu waktu, tetapi memecahkan teka-teki berlapis-lapis: mengambil keadaan, ia menemukan semua langkah valid yang dapat dibuat.  Kemudian ia menerapkan semua gerakan ini pada saat yang sama dan memulai yang baru dalam keadaan baru.  Jumlah lapisan dan jumlah gerakan maksimum yang ditemukan pada satu lapisan kemudian digunakan sebagai nilai perkiraan kedalaman dan lebar pohon pencarian secara keseluruhan. <br><br>  Berikut cara memecahkan salah satu teka-teki sulit dengan model ini.  Garis putus-putus adalah garis yang direntangkan pada lapisan pemecah ini, garis padat adalah garis yang tidak berubah.  Garis hijau adalah panjang yang benar, yang merah belum lengkap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br>  Masalah selanjutnya adalah bahwa semua gerakan yang dilakukan oleh pemain dibuat sama.  Apa yang kami sebutkan di awal bagian ini hanyalah akal sehat.  Berikut adalah contoh aturan pengurangan yang lebih kompleks, pencarian yang akan membutuhkan sedikit pemikiran.  Pertimbangkan bidang berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br>  Poin-poin dalam C dan D hanya dapat dicakup oleh lima dan empat tengah (dan tidak satu angka pun dapat mencakup kedua poin pada saat yang sama).  Ini berarti bahwa keempat di tengah harus mencakup satu titik dua, dan karena itu tidak dapat digunakan untuk menutupi A. Oleh karena itu, titik A harus menutup empat di sudut kiri bawah. <br><br>  Jelas, akan bodoh untuk menganggap rantai penalaran ini sama dengan kesimpulan sederhana "titik ini hanya dapat dicapai dari angka ini."  Apakah mungkin untuk memberikan bobot lebih pada aturan yang lebih kompleks ini dalam fungsi evaluasi?  Sayangnya, dalam pemecah berbasis lapisan, ini tidak mungkin, karena tidak dijamin untuk menemukan solusi dengan biaya terendah.  Ini bukan hanya masalah teoritis - dalam praktiknya sering terjadi bahwa bagian dari lapangan dapat diselesaikan baik dengan argumen tunggal yang kompleks, atau dengan rantai gerakan yang jauh lebih sederhana.  Bahkan, pemecah berbasis lapisan menemukan jalur terpendek, dan bukan yang paling murah, dan ini tidak dapat tercermin dalam fungsi evaluasi. <br><br>  Akibatnya, saya sampai pada keputusan ini: Saya mengubah solver sehingga setiap lapisan hanya terdiri dari satu jenis penalaran.  Algoritme memintas aturan penalaran dalam urutan kompleksitas yang mendekati.  Jika aturan menemukan beberapa gerakan, maka mereka diterapkan, dan iterasi berakhir, dan iterasi berikutnya memulai daftar dari awal. <br><br>  Kemudian keputusan diberikan penilaian: setiap lapisan diberi biaya berdasarkan pada satu aturan yang digunakan di dalamnya.  Ini masih tidak menjamin bahwa solusi akan menjadi yang paling murah, tetapi jika bobot dipilih dengan benar, algoritma setidaknya tidak akan menemukan solusi yang mahal jika ada yang murah. <br><br>  Selain itu, ini sangat mirip dengan cara orang memecahkan teka-teki.  Mereka pertama-tama mencoba menemukan solusi mudah, dan mulai secara aktif menggerakkan otak mereka hanya jika tidak ada gerakan sederhana. <br><br><h3>  Generator </h3><br>  Bagian sebelumnya menentukan apakah level tertentu baik atau buruk.  Tapi ini saja tidak cukup, kita masih perlu entah bagaimana menghasilkan level sehingga pemecah dapat mengevaluasinya.  Sangat tidak mungkin bahwa dunia yang dihasilkan secara acak akan terpecahkan, belum lagi menarik. <br><br>  Gagasan utama (ini sama sekali tidak baru) adalah penggunaan alternatif dari solver dan generator.  Mari kita mulai dengan sebuah teka-teki, yang mungkin tidak dapat dipecahkan: cukup tempatkan dua hingga lima angka dalam kuadrat acak sel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br>  Solver berfungsi hingga dapat berkembang lebih lanjut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br>  Kemudian generator menambahkan lebih banyak informasi ke puzzle dalam bentuk titik, setelah itu eksekusi solver berlanjut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br>  Dalam hal ini, titik yang ditambahkan ke pemecah tidak cukup untuk pengembangan lebih lanjut.  Kemudian generator akan terus menambahkan poin baru sampai memuaskan pemecah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br>  Dan kemudian si pemecah melanjutkan pekerjaannya yang biasa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br>  Proses ini berlanjut baik sampai puzzle diselesaikan, atau sampai ada lebih banyak informasi yang tersisa untuk ditambahkan (misalnya, ketika setiap sel yang dapat dihubungi dari angka sudah mengandung titik). <br><br>  Metode ini hanya berfungsi jika informasi baru yang ditambahkan tidak dapat membuat kesimpulan yang dibuat sebelumnya salah.  Ini akan sulit dilakukan ketika menambahkan angka ke kotak <sup>[3]</sup> .  Tetapi menambahkan poin baru ke bidang memiliki properti ini;  setidaknya untuk aturan penalaran yang saya gunakan dalam program ini. <br><br>  Di mana seharusnya algoritma menambahkan poin?  Pada akhirnya, saya memutuskan untuk menambahkannya ke ruang kosong, yang dapat ditutup dalam keadaan awal dengan sebanyak mungkin garis, sehingga setiap titik berusaha memberikan informasi sesedikit mungkin.  Saya tidak mencoba untuk secara khusus menempatkan titik di tempat di mana akan berguna untuk kemajuan dalam memecahkan teka-teki pada saat pemecah macet.  Ini menciptakan efek yang sangat nyaman: sebagian besar poin di awal puzzle tampak sama sekali tidak berguna, yang membuat puzzle lebih sulit daripada yang sebenarnya.  Jika semua ini banyak gerakan jelas yang bisa dilakukan oleh seorang pemain, tetapi untuk beberapa alasan tidak satu pun dari mereka tidak bekerja dengan baik.  Hasilnya, ternyata generator puzzle itu berperilaku agak seperti babi. <br><br>  Proses ini tidak selalu menciptakan solusi, tetapi cukup cepat (sekitar 50-100 milidetik), jadi untuk menghasilkan level, Anda cukup mengulanginya beberapa kali.  Sayangnya, ia biasanya membuat teka-teki biasa-biasa saja.  Sejak awal ada terlalu banyak gerakan yang jelas, lapangan mengisi dengan sangat cepat dan pohon keputusan ternyata agak dangkal. <br><br><h3>  Pengoptimal </h3><br>  Proses yang dijelaskan di atas membuat teka-teki biasa-biasa saja.  Pada tahap terakhir, saya menggunakan level ini sebagai dasar untuk proses optimasi.  Ini berfungsi sebagai berikut. <br><br>  Pengoptimal membuat kumpulan yang berisi hingga 10 pilihan puzzle.  Kolam diinisialisasi dengan puzzle acak baru yang dihasilkan.  Pada setiap iterasi, optimizer memilih satu puzzle dari pool dan melakukan mutasinya. <br><br>  Mutasi menghapus semua poin, dan kemudian sedikit mengubah angka (mis. Mengurangi / meningkatkan nilai angka yang dipilih secara acak atau memindahkan angka ke sel lain di dalam kisi).  Anda dapat menerapkan beberapa mutasi ke bidang secara bersamaan.  Kemudian kami menjalankan solver dalam mode generasi tingkat khusus yang dijelaskan di bagian sebelumnya.  Dia menambahkan cukup banyak poin pada teka-teki itu sehingga menjadi bisa dipecahkan lagi. <br><br>  Setelah itu, kita mulai solver lagi, kali ini dalam mode normal.  Selama menjalankan ini, pemecah monitor a) kedalaman pohon keputusan, b) frekuensi kebutuhan untuk berbagai jenis aturan, c) lebar pohon keputusan pada berbagai titik waktu.  Teka-teki dievaluasi berdasarkan kriteria yang dijelaskan di atas.  Fungsi evaluasi lebih menyukai solusi yang dalam dan sempit, dan tingkat kompleksitas yang meningkat juga menambah bobot teka-teki di mana aturan penalaran yang lebih kompleks diperlukan. <br><br>  Kemudian sebuah teka-teki baru ditambahkan ke kolam.  Jika kolam berisi lebih dari 10 teka-teki, maka yang terburuk dibuang. <br><br>  Proses ini diulang beberapa kali (sekitar 10.000-50000 iterasi membawa saya).  Setelah itu, versi puzzle dengan nilai tertinggi disimpan ke basis data level puzzle.  Begini bagaimana kemajuan puzzle terbaik dalam satu kali pengoptimalan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br>  Saya mencoba menggunakan cara lain untuk menyusun optimasi.  Dalam satu versi, simulated annealing digunakan, yang lain adalah algoritma genetika dengan berbagai operasi cross-over.  Tidak ada solusi yang dilakukan serta algoritma naif dengan kumpulan opsi yang kembali ke atas. <br><br><h3>  Solusi tunggal yang unik </h3><br>  Ketika sebuah puzzle memiliki solusi unik yang unik, muncul kesulitan yang menarik.  Apakah mungkin untuk memungkinkan pemain untuk berasumsi bahwa ada satu solusi dan menarik kesimpulan berdasarkan ini?  Apakah adil jika pembuat puzzle menyarankan agar pemain melakukannya? <br><br>  Dalam sebuah posting di HackerNews, saya mengatakan bahwa ada empat opsi untuk mendekati situasi ini: <br><br><ul><li>  Nyatakan keunikan solusi sejak awal dan paksakan generator untuk membuat level yang memerlukan alasan seperti ini.  Ini adalah keputusan yang buruk karena mempersulit pemahaman aturan.  Dan biasanya ini adalah detail yang orang lupa. </li><li>  Jangan menjamin keunikan suatu keputusan: berpotensi memiliki banyak keputusan dan membuat semuanya.  Sebenarnya, ini tidak menyelesaikan masalah, tetapi mendorongnya. </li><li>  Anggap saja ini adalah peristiwa yang sangat jarang, yang dalam praktiknya tidak penting.  (Ini adalah solusi yang digunakan dalam implementasi awal.) </li><li>  Ubah generator puzzle agar tidak menghasilkan teka-teki di mana pengetahuan tentang keunikan solusi akan membantu.  (Mungkin solusi yang tepat, tetapi membutuhkan pekerjaan tambahan.) </li></ul><br>  Awalnya, saya memilih opsi yang terakhir, dan itu adalah kesalahan yang mengerikan.  Ternyata saya hanya memperhitungkan satu cara di mana keunikan solusi menyebabkan kebocoran informasi, dan itu sebenarnya sangat jarang.  Tetapi ada yang lain;  salah satu dari mereka sebenarnya hadir di setiap level yang saya hasilkan dan sering kali mengarah pada fakta bahwa solusinya menjadi sepele.  Oleh karena itu, pada Mei 2019, saya mengubah mode Keras dan Pakar menggunakan opsi ketiga. <br><br>  Kasing yang paling menyebalkan adalah deuce dengan garis putus-putus di bidang ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br>  Mengapa pemain yang licik dapat membuat kesimpulan seperti itu?  Deuce dapat menutupi salah satu dari empat kotak tetangga.  Tak satu pun dari mereka yang memiliki titik, sehingga mereka tidak harus ditutupi oleh garis.  Dan kuadrat di bawah ini tidak memiliki overlay dengan angka lainnya.  Jika ada solusi tunggal, maka ini harus menjadi kasus ketika nomor lainnya menutupi tiga kotak yang tersisa, dan keduanya menutup kotak di bawahnya. <br><br>  Solusinya adalah menambahkan beberapa poin lagi ketika mengenali kasus-kasus tersebut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br>  Kasus umum lainnya adalah tanda hubung dengan garis putus-putus di bidang ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br>  Kotak di sebelah kiri dan atas keduanya tidak berbeda.  Tak satu pun dari mereka ada benarnya, dan tidak ada yang bisa dihubungi dari nomor lain.  Setiap solusi yang mana deuce menutupi kuadrat atas akan memiliki solusi yang sesuai di mana ia menutup kuadrat kiri, dan sebaliknya.  Jika ada solusi tunggal yang unik, maka ini tidak mungkin, dan deuce seharusnya sudah menutupi bagian bawah. <br><br>  Saya memutuskan jenis kasus ini dengan cara "jika itu menyakitkan, maka jangan menyentuhnya."  Solver menerapkan aturan ini pada tahap awal dalam daftar prioritas dan memberikan bobot negatif pada gerakan tersebut.  Teka-teki dengan fitur ini biasanya dibuang oleh pengoptimal, dan beberapa yang tersisa dibuang pada tahap pemilihan level akhir untuk game yang diterbitkan. <br><br>  Ini bukan daftar lengkap. Selama pengujian bermain dengan pencarian kesalahan yang disengaja, saya menemukan banyak aturan lain untuk solusi unik.  Tetapi kebanyakan dari mereka tampak langka dan mereka cukup untuk menemukannya, sehingga mereka tidak terlalu menyederhanakan permainan.  Jika seseorang memecahkan puzzle menggunakan alasan seperti itu, maka saya tidak akan menyalahkannya. <br><br><h3>  Kesimpulan </h3><br>  Awalnya, game ini dikembangkan sebagai percobaan dalam pembuatan teka-teki prosedural.  Desain dan generator game berjalan beriringan, sehingga tekniknya sendiri sulit diterapkan langsung ke game lain. <br><br>  Pertanyaan yang saya tidak punya jawaban: apakah investasi dari upaya-upaya semacam itu dalam generasi prosedural membenarkan dirinya sendiri?        .       ,      -  .      ,       . <br><br>         ,     ,          .    :          . <br><br><h3>  Catatan </h3><br> [0] ,   ,   .       ,        ,     .  Oh baiklah <br><br> [1]        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solving Minesweeper and making it better</a>  . <br><br> [2] ,  /  â€”  ,       ,      . ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20130703141244/"> </a>  ,   Rush Hour ,         ,     .    ,  Rush Hour â€”      ,    - . <br><br> [3]    .       ,     ,        .     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452090/">https://habr.com/ru/post/id452090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452076/index.html">Menghancurkan Browser UC</a></li>
<li><a href="../id452078/index.html">Reservasi Kubernetes: Ada</a></li>
<li><a href="../id452082/index.html">Pembaruan Fleksibel Aplikasi dalam Aplikasi: Mempercepat Proses Pembaruan Aplikasi di Android</a></li>
<li><a href="../id452086/index.html">Apa yang ada di pixel saya untuk Anda: membuat nanopixels menggunakan metasurfaces plasmon</a></li>
<li><a href="../id452088/index.html">Pengenalan jalan melalui segmentasi semantik</a></li>
<li><a href="../id452092/index.html">Pembaruan Dalam Aplikasi: Mempercepat Pembaruan Aplikasi Android</a></li>
<li><a href="../id452094/index.html">.NET: Alat untuk bekerja dengan multithreading dan asynchrony. Bagian 1</a></li>
<li><a href="../id452098/index.html">Log Habr pengembang front-end: refactor dan reflex</a></li>
<li><a href="../id452102/index.html">Permainan foto untuk mereka yang menyukai drone: secara singkat tentang AirSelfie 2</a></li>
<li><a href="../id452106/index.html">Kami mengundang pembicara ke pertemuan DIY musim panas pada 16 Juni 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>