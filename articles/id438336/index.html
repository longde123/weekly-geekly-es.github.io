<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›€ğŸ¿ ğŸ’¿ ğŸ‘©ğŸ»â€ğŸ¨ Panduan untuk audit otomatis kontrak pintar. Bagian 1: Mempersiapkan Audit ğŸ‘©ğŸ¼â€âš–ï¸ ğŸŒ² ğŸ¤°ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Perusahaan kami terlibat dalam audit keamanan kontrak pintar, dan masalah menggunakan alat otomatis sangat akut. Seberapa banyak merek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan untuk audit otomatis kontrak pintar. Bagian 1: Mempersiapkan Audit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438336/"><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Perusahaan kami terlibat dalam audit keamanan kontrak pintar, dan masalah menggunakan alat otomatis sangat akut.  Seberapa banyak mereka dapat membantu dalam mengidentifikasi tempat-tempat yang mencurigakan, mana yang harus digunakan, apa yang dapat mereka lakukan dan apa spesifik pekerjaan di bidang ini?  Ini dan masalah-masalah terkait adalah subjek dari artikel ini.  Dan materi akan menjadi upaya untuk bekerja dengan kontrak nyata dengan bantuan perwakilan dan resep paling menarik untuk meluncurkan perangkat lunak yang sangat beraneka ragam dan sangat menarik ini.  Pada awalnya saya ingin membuat satu artikel, tetapi setelah beberapa waktu jumlah informasi menjadi terlalu besar, sehingga diputuskan untuk membuat serangkaian artikel, satu untuk setiap autoanalyzer.  Daftar dari mana kita akan mengambil alat disajikan, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , tetapi jika alat menarik lainnya ditemukan selama penulisan, saya akan menggambarkannya dengan senang hati dan mengujinya. </p><a name="habracut"></a><br><p> Saya harus mengatakan bahwa tugas audit sangat menarik, karena  sejauh ini, pengembang belum banyak memperhatikan aspek ekonomi dari algoritma, dan optimasi internal.  Dan audit kontrak pintar telah menambahkan beberapa vektor serangan menarik yang harus dipertimbangkan ketika mencari kesalahan.  Juga, ternyata, banyak alat untuk pengujian otomatis muncul: analisis statis, analisis bytecode, fuzzers, parser dan banyak perangkat lunak bagus lainnya. </p><br><p>  Tujuan artikel: untuk mempromosikan distribusi kode kontrak aman dan memungkinkan pengembang dengan cepat dan mudah menyingkirkan bug bodoh, yang seringkali paling menjengkelkan.  Ketika protokol itu sendiri benar-benar dapat diandalkan dan memecahkan masalah serius, keberadaan kesalahan bodoh yang dilupakan pada tahap pengujian dapat secara serius merusak kehidupan proyek.  Karena itu, mari kita belajar untuk menggunakan, paling tidak, alat yang memungkinkan "sedikit darah" untuk menyingkirkan masalah-masalah terkenal. </p><br><p>  Ke depan, saya harus mengatakan bahwa bug kritis paling umum yang kami temui dalam audit masih merupakan masalah implementasi logis, dan bukan kerentanan khas seperti hak akses, integer overflow, reentrancy.  Audit solusi yang besar dan lengkap tidak mungkin tanpa pengembang berpengalaman yang mampu mengaudit logika kontrak tingkat tinggi, siklus hidupnya, aspek operasi nyata dan kepatuhan terhadap tugas, dan bukan hanya pola serangan biasa.  Ini adalah logika tingkat tinggi yang sering menjadi sumber bug kritis. </p><br><p>  Tetapi peringatan, lubang tipuan dan kesalahan yang ditinggalkan karena kecerobohan yang tidak boleh dilewatkan adalah takdir penganalisa otomatis, mereka harus mengatasi tugas-tugas ini lebih baik daripada orang.  Ini adalah tesis ini yang akan diuji. </p><br><h2 id="osobennosti-audita-koda-smart-kontraktov">  Fitur audit kode kontrak pintar </h2><br><p>  Audit kode kontrak pintar adalah bidang yang agak spesifik.  Terlepas dari ukurannya yang kecil, kontrak pintar Ethereum adalah program lengkap yang dapat mengatur cabang, loop, pohon keputusan yang rumit, dan bahkan untuk mengotomatisasi transaksi yang tampaknya sederhana memerlukan pemikiran melalui semua cabang yang mungkin pada setiap langkah.  Dari sudut pandang ini, pengembangan blockchain adalah level yang sangat rendah, sangat menuntut sumber daya dan sangat mengingatkan pada pengembangan sistem dan perangkat lunak yang disematkan dalam bahasa C / C ++ dan assembler.  Itulah sebabnya kami senang melihat pada wawancara para pengembang algoritma tingkat rendah, tumpukan jaringan, layanan yang sangat banyak, semua orang yang berurusan dengan optimasi tingkat rendah dan audit kode. </p><br><p>  Dari sudut pandang pengembang, Solidity juga cukup spesifik, meskipun mudah dibaca oleh hampir semua programmer dan pada langkah pertama dan tampaknya sangat sederhana.  Kode soliditas cukup mudah dibaca, itu biasa bagi setiap pengembang yang tahu sintaks C / C ++ dan OOP, seperti JavaScript. </p><br><p>  Di sini kesederhanaan kode adalah kunci untuk bertahan hidup, tidak ada pekerjaan berat, sehingga seluruh persenjataan pengembangan tingkat rendah digunakan dalam pekerjaan - algoritma yang memungkinkan penggunaan sumber daya yang efisien, menghemat memori: Merkle trees, Bloom filter, pemuatan sumber daya "malas", loop terbuka, pengumpulan sampah manual dan masih banyak lagi. <br>  Sejumlah kecil kode sumber dan bytecode yang dihasilkan. </p><br><p>  Kontrak pintar terpisah dibatasi dalam volume bytecode, setiap byte menghabiskan sejumlah gas, dan maksimum dibatasi dari atas, sehingga Anda dapat mendorong sekitar 10Kb ke dalam blockchain (saat ini), itu tidak akan berhasil lagi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah artikel yang bagus tentang berapa banyak biaya kontrak menyebarkan dan berapa banyak biaya gas</a> .  Karena itu, banyak yang tidak bisa didorong.  Jika Anda melebih-lebihkan, maka beberapa ribu baris kode "rata-rata" adalah maksimum.  Beberapa lusin metode, kurangnya agregasi dan logika yang kompleks umumnya sangat karakteristik kontrak.  Segala sesuatu yang tidak sesuai mengharuskan Anda untuk memilih kode di perpustakaan yang terpisah, mengubah dan mempersulit prosedur untuk meletakkannya di jaringan.  Pengembang soliditas mungkin senang untuk mendorong sekelompok kode ke dalam satu kontrak, tetapi mereka hanya perlu mengatur sistem kontrak mereka dengan benar dengan membuat perpustakaan kelas terpisah dengan penyimpanan mereka sendiri.  Dan itu nyaman untuk menguraikan "kelas" yang terpisah seperti itu ke dalam file yang terpisah, dan karena itu, membaca kode kontrak itu cukup bagus, semuanya terstruktur dengan baik sejak awal - itu tidak akan berhasil jika tidak.  Sebagai contoh, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">merekomendasikan untuk melihat bagaimana ERC721 dibuat dalam openzeppelin-solidity</a> . </p><br><h3 id="gaz-gaz-gaz">  Gas, gas, gas </h3><br><p>  Gas memperkenalkan lapisan logika tambahan dalam pelaksanaan kode kontrak, yang membutuhkan audit.  Selain itu, tidak seperti kode tradisional, bagian kode yang sama dapat menghabiskan jumlah gas yang berbeda.  Sebuah tabel opmode EVM dan biayanya berguna untuk memahami pembatasan gas. </p><br><p>  Untuk menunjukkan mengapa Anda harus mencurahkan banyak waktu untuk mengevaluasi gas, pertimbangkan pseudo-code ini (tentu saja, tidak realistis, menembak di loop dengan eter adalah ide yang buruk): </p><br><pre><code class="plaintext hljs">//          function fixSomeAccountAction(uint _actionId) public onlyValidator { // â€¦ events[msg.sender].push(_actionId); } //   ,           function receivePaymentForSavedActions() { // ... for (uint256 i = 0; i &lt; events[msg.sender].length; i++) { //  actionId   uint actionId = events[msg.sender][i]; //      action uint payment = getPriceByEventId(actionId); if (payment &gt; 0) { paymentAccumulators[msg.sender] += payment; } emit LogEventPaymentForAction(msg.sender, actionId, payment); // â€¦ // delete â€œevents[msg.sender][i]â€ from array } }</code> </pre> <br><p>  faktanya adalah bahwa siklus dalam kontrak dijalankan peristiwa [msg.sender] .length kali, dan setiap iterasi adalah entri di blockchain (transfer () dan emit ()).  Jika panjang array kecil, maka siklus memenuhi sepuluh kali, mendistribusikan pembayaran untuk setiap tindakan.  Tetapi, jika array [msg.sender] event besar, maka akan ada banyak iterasi dan gas yang dihabiskan akan mencapai batas gas maksimum yang dikodekan keras (~ 8.000.000).  Transaksi akan jatuh, dan sekarang tidak akan pernah berfungsi, karena tidak ada cara untuk mengurangi lamanya array [msg.sender] dalam kontrak.  Jika siklus tidak hanya menghitung nilai unit, tetapi menulis ke blockchain (misalnya, beberapa biaya dibayar, pembayaran untuk tindakan), maka jumlah iterasi yang diperbolehkan sangat terbatas.  Nilai sendiri - batas: 8.000.000, merekam nilai 256-bit baru: 20.000.  Anda dapat menyimpan atau memperbarui metadata hanya untuk beberapa ratusan alamat 256-bit dengan beberapa metadata. Bagian lain yang menyenangkan adalah menulis nilai baru: 20.000, dan pembaruan yang sudah ada: 5.000, bahkan dengan lingkungan yang sama persis dengan kontrak Anda saat Anda melakukan transfer token ke alamat yang sudah memiliki token, Anda menghabiskan 4 kali lebih sedikit gas (5.000 vs 20.000) pada catatan. </p><br><p>  Oleh karena itu, jangan heran bahwa masalah gas dalam kontrak pintar sangat erat kaitannya dengan keamanan kontrak, karena situasi ketika dana secara permanen terjebak dalam kontrak dari sudut pandang praktis sedikit berbeda dari situasi ketika mereka dicuri.  Fakta bahwa instruksi ADD menghabiskan 3 gas, dan SSTORE (penghematan ke penyimpanan): 20.000 berarti bahwa sumber daya paling mahal dalam blockchain adalah penyimpanan, dan tugas-tugas mengoptimalkan kode kontrak memiliki banyak kesamaan dengan tugas-tugas pengembangan tingkat rendah dalam C dan ASM untuk disematkan. sistem, di mana penyimpanan juga sumber daya yang sangat terbatas. </p><br><h3 id="prekrasnyy-blokcheyn">  Blockchain yang indah </h3><br><p>  Ini adalah paragraf yang sangat positif tentang mengapa blockchain begitu baik dari sudut pandang keamanan hanya untuk auditor.  Determinasi dari pelaksanaan kode kontrak adalah kunci keberhasilan debugging dan pemutaran bug dan kerentanan.  Secara teknis, setiap panggilan ke kode kontrak dapat direproduksi pada platform apa pun dengan sedikit akurasi, ini memungkinkan tes untuk bekerja di mana-mana dan sangat mudah untuk didukung, dan investigasi insiden dapat diandalkan dan tidak dapat disangkal.  Sekarang kita selalu tahu siapa ketika fungsi apa dipanggil, dengan parameter apa, kode apa yang memprosesnya dan apa hasilnya.  Semua ini sepenuhnya ditentukan, mis.  bermain di mana saja, bahkan di JS di halaman web.  Jika kita berbicara tentang Ethereum, maka setiap test case sangat mudah ditulis dalam JavaScript yang nyaman, termasuk parameter fuzzing, dan bekerja dengan baik di mana pun ada Node.js. </p><br><p>  Semua kata-kata indah ini, bagaimanapun, tidak boleh membuat para pengembang rileks, karena, sebagaimana disebutkan di atas, kesalahan paling serius adalah logis, dan bagi mereka determinisme eksekusi adalah properti ortogonal. </p><br><h2 id="okruzhenie-dlya-sborki-kontrakta">  Lingkungan untuk perakitan kontrak </h2><br><p>  Untuk menulis artikel, saya mengambil kontrak eksperimental lama untuk memesan rumah dari perancang Smartz: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/smartzplatform/constructor-eth-booking</a> .  Kontrak memungkinkan Anda untuk membuat catatan objek (apartemen atau kamar hotel), menetapkan harga dan tanggal pengiriman, setelah kontrak menunggu pembayaran dan, jika diterima, memperbaiki tindakan pemesanan, menjaga dana pada saldo sampai tamu memasuki ruangan dan tidak akan mengkonfirmasi entri.  Pada titik ini, pemilik ruangan menerima pembayaran.  Kontrak pada dasarnya adalah mesin negara, negara bagian dan transisi yang dapat dilihat di Booking.sol.  Kami melakukannya dengan sangat cepat, mengubahnya selama proses pengembangan dan tidak berhasil melakukan sejumlah besar tes, itu jauh dari versi baru dari kompiler dan lebih atau kurang logika internal yang kaya.  Jadi mari kita lihat bagaimana analis mengatasinya, kesalahan apa yang akan mereka temukan, dan, jika perlu, kita tambahkan sendiri. </p><br><h3 id="rabota-s-raznymi-versiyami-solc">  Bekerja dengan berbagai versi solc </h3><br><p>  Analisis yang berbeda harus digunakan dengan cara yang berbeda - ada yang diluncurkan dari buruh pelabuhan, yang lain menggunakan bytecode yang sudah jadi, dan auditor sendiri juga harus berurusan bukan dengan pasangan, tetapi dengan lusinan kontrak awal dengan versi berbeda dari kompiler.  Oleh karena itu, versi <code>solc</code> berbeda harus dapat "memulai" dengan cara yang berbeda, baik di sistem host, dan di dalam gambar buruh pelabuhan, dan di dalam truffle, jadi saya akan memberikan Anda beberapa opsi untuk peretasan kotor: </p><br><p>  1 cara: di dalam truffle </p><br><p>  Untuk ini, tidak ada trik yang diperlukan, karena  dimulai dengan truffle versi 5.0.0, Anda dapat menentukan versi kompiler langsung di truffle.js, seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diff ini</a> . </p><br><p>  Sekarang truffle akan mengunduh kompiler yang diperlukan dan menjalankannya.  Terima kasih banyak kepada tim untuk ini, Solidity adalah bahasa yang muda, perubahan dalam bahasa itu serius, dan beralih dari satu versi ke versi lainnya tidak dapat diterima oleh auditor - dengan cara ini Anda dapat memperkenalkan kesalahan baru dan menutupi yang lama. </p><br><p>  Metode 2: mengganti / usr / bin / solc dalam wadah buruh pelabuhan analyzer <br>  Jika penganalisis didistribusikan dalam bentuk Dockerfile, Anda dapat menggantinya saat merakit gambar buruh pelabuhan dengan menambahkan garis ke Dockerfile yang mendapatkan versi yang diinginkan <code>solc</code> langsung dari gambar, yang menariknya dari jaringan dan menggantikan / usr / bin / solc: </p><br><pre> <code class="plaintext hljs">COPY --from=ethereum/solc:0.4.19 /usr/bin/solc /usr/bin</code> </pre> <br><p>  3 cara: mengganti / usr / bin / solc </p><br><p>  Cara paling kotor di dahi, jika tidak ada jalan keluar sama sekali, Anda bisa mengganti biner / usr / bin / solc dengan script seperti ini (jangan lupa untuk menyimpan file asli): </p><br><pre> <code class="plaintext hljs">#!/bin/bash # run Solidity compiler of given version, pass all parameters # you can run â€œSOLC_DOCKER_VERSION=0.4.20 solc --versionâ€ SOLC_DOCKER_VERSION="${SOLC_DOCKER_VERSION:-0.4.24}" docker run \ --entrypoint "" \ --tmpfs /tmp \ -v $(pwd):/project \ -v $(pwd)/node_modules:/project/node_modules \ -w /project \ ethereum/solc:$SOLC_DOCKER_VERSION \ /usr/bin/solc \ "$@"</code> </pre> <br><p>  Ini mengunduh dan cache gambar buruh pelabuhan dengan versi <code>solc</code> , pergi ke direktori saat ini dan menjalankan <code>/usr/bin/solc</code> dengan parameter yang dilewati.  Bukan cara yang sangat baik, tapi mungkin untuk beberapa tugas itu cocok untuk Anda. </p><br><h3 id="flattening-code">  Kode rata </h3><br><p>  Sekarang mari kita cari tahu sumbernya.  Tentu saja, dalam teori, autoanalyzers (terutama untuk analisis sumber statis) harus mengumpulkan kontrak, menarik semua dependensi, menggabungkan semuanya menjadi satu monolit dan menganalisanya.  Tapi, seperti yang sudah saya katakan, perubahan dari versi ke versi bisa serius, dan saya selalu tersandung pada kebutuhan untuk menjatuhkan direktori tambahan ke buruh pelabuhan, mengkonfigurasinya di dalam path, dan semua ini sehingga benar menarik impor yang diperlukan.  Beberapa analis memahami semuanya, yang kedua bukan, karena itu, opsi universal, agar tidak menderita melempar direktori tambahan, lebih mudah bagi analis yang memakan satu file untuk menggabungkan semuanya menjadi satu file dan hanya menganalisisnya. </p><br><p>  Untuk melakukan ini, gunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">truffle-flattener biasa</a> . </p><br><p>  Ini adalah modul npm standar, digunakan sangat sederhana: </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/trailofbits/slither</a> <br>  Jika Anda perlu mengubahsuaikan perataan, Anda dapat menulis perataan sendiri, misalnya, sebelum kami menggunakan opsi berbasis python: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/mixbytes/solidity-flattener</a> </p><br><h2 id="nachnem-analiz">  Mari kita mulai analisisnya. </h2><br><p>  Pada contoh orang tua yang sama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/smartzplatform/constructor-eth-booking, kami</a> melanjutkan analisis.  Kontrak menunjukkan versi lama dari kompiler "0.4.20", dan saya sengaja mengambil kontrak lama untuk menyelesaikan masalah dengan kompiler.  Situasi diperparah oleh fakta bahwa autoanalyzer, misalnya, mempelajari bytecode, dapat bergantung pada versi solc ini, dan di sini perbedaan versi dapat sangat mempengaruhi hasil atau bahkan menghancurkan segalanya.  jadi bahkan jika Anda melakukan segalanya dengan halal menggunakan versi terbaru, Anda masih bisa menemui penganalisis yang telah disetel ke versi kompiler sebelumnya. <br>  Mengompilasi dan menjalankan tes </p><br><p>  Untuk memulai, cukup tarik proyek dari github dan coba kompilasi: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/smartzplatform/constructor-eth-booking.git cd constructor-eth-booking npm install truffle compile</code> </pre> <br><p>  Tentunya Anda memiliki masalah dengan versi kompiler.  Selain itu, autoanalyzers juga memiliki masalah ini, jadi gunakan segala cara untuk mendapatkan kompiler 0.4.20 dan membangun proyek.  Saya baru saja mendaftarkan versi yang diperlukan dari kompiler di truffle.js dan semuanya sudah dirakit seperti dijelaskan di atas. </p><br><p>  Juga jalankan </p><br><pre> <code class="bash hljs">truffle-flattener contracts/Booking.sol &gt; contracts/flattened.sol</code> </pre> <br><p>  seperti yang ditunjukkan dalam paragraf tentang perataan, itu adalah <code>contracts/flattened.sol</code> akan kami berikan untuk analisis kepada analis <br>  Kesimpulan dari pengantar </p><br><p>  Sekarang, setelah diratakan.sol dan kemampuan untuk menggunakan <code>solc</code> versi sewenang-wenang, Anda dapat mulai menganalisis.  Saya akan menghilangkan masalah dengan menjalankan truffle dan tes, ada banyak dokumentasi tentang masalah ini, atur sendiri.  Tentu saja, tes harus dijalankan dan dijalankan dengan sukses.  Juga, untuk memeriksa logika, auditor sering harus menambahkan tesnya sendiri, memeriksa tempat-tempat yang berpotensi bocor, misalnya, memeriksa fungsionalitas kontrak pada batas array, mencakup semua variabel dengan tes, bahkan yang dimaksudkan hanya untuk penyimpanan data, dll.  Ada banyak rekomendasi, selain ini hanya produk yang dipasok oleh perusahaan kami ke pasar, jadi studi logika adalah tugas murni manusia. </p><br><p>  Kami akan pergi ke penganalisa yang menarik dari sudut pandang kami, mencoba memasukkan kontrak kami ke dalamnya, dan kami akan secara artifisial memperkenalkan kerentanan ke dalamnya untuk mengevaluasi bagaimana penganalisa otomatis akan bereaksi terhadap mereka.  Artikel selanjutnya akan dikhususkan untuk penganalisa Slither, dan secara umum, rencana tindakan kira-kira sebagai berikut: </p><br><p>  Bagian 1. Pendahuluan.  Kompilasi, perataan, versi Solidity (artikel ini) <br>  Bagian 2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meluncur</a> <br>  Bagian 3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mythril</a> <br>  Bagian 4. Manticore <br>  Bagian 5. Echidna <br>  Bagian 6. Alat tidak dikenal 1 <br>  Bagian 7. Alat tidak dikenal 2 </p><br><p>  Set analisis ini diperoleh karena penting bagi auditor untuk dapat menggunakan berbagai jenis analisis - statis dan dinamis, dan mereka memerlukan pendekatan yang sama sekali berbeda.  Tugas kita adalah mempelajari cara menggunakan alat dasar di setiap jenis analisis dan memahami yang mana yang digunakan saat itu. </p><br><p>  Mungkin dalam proses studi terperinci, kandidat baru akan muncul untuk dipertimbangkan, atau urutan artikel akan berubah, jadi tetaplah disini.  Untuk pergi ke bagian selanjutnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"klik di sini"</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438336/">https://habr.com/ru/post/id438336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438326/index.html">5G di Rusia: mengapa diperlukan, berapa biayanya dan kapan akan muncul? Secara singkat tentang hal utama</a></li>
<li><a href="../id438328/index.html">Bagaimana menggembungkan gelembung gaji untuk programmer?</a></li>
<li><a href="../id438330/index.html">Universitas Negeri Adams. Cara meretas situs web. Bagian 1</a></li>
<li><a href="../id438332/index.html">Universitas Negeri Adams. Cara meretas situs web. Bagian 2</a></li>
<li><a href="../id438334/index.html">Transisi ke 3D: Dampak Arsitektur Chip dan Algoritma Perekaman terhadap Kehidupan SSD</a></li>
<li><a href="../id438338/index.html">Panduan untuk audit otomatis kontrak pintar. Bagian 2: Meluncur</a></li>
<li><a href="../id438340/index.html">Media: iCloud mungkin memiliki kebocoran data yang coba disembunyikan Apple</a></li>
<li><a href="../id438342/index.html">Mengapa Curang Ramah AI di Ghost Recon Wildlands</a></li>
<li><a href="../id438346/index.html">Bagaimana mereka melakukannya? Tinjauan umum tentang teknologi anonimisasi cryptocurrency</a></li>
<li><a href="../id438348/index.html">Cara belajar program pada usia 9 tahun secara mandiri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>