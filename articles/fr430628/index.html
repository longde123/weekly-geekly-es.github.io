<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔰 👨🏼‍🤝‍👨🏻 🥛 Algorithme de Fortune, détails d'implémentation 🤬 🔺 ♑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours des dernières semaines, j'ai travaillé sur l'implémentation de l'algorithme de Fortune en C ++. Cet algorithme prend beaucoup de points 2D et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithme de Fortune, détails d'implémentation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430628/"> Au cours des dernières semaines, j'ai travaillé sur l'implémentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme de Fortune</a> en C ++.  Cet algorithme prend beaucoup de points 2D et construit à partir d'eux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un diagramme</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voronoi</a> .  Si vous ne savez pas ce qu'est un diagramme de Voronoi, regardez la figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br>  Pour chaque point d'entrée, appelé «site», nous devons trouver de nombreux points plus proches de cet endroit que de tout le monde.  Ces ensembles de points forment les cellules montrées dans l'image ci-dessus. <br><br>  Il est remarquable dans l'algorithme de Fortune qu'il construit de tels diagrammes dans le temps <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-29" x="3868" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (n \ log n) </script>  (ce qui est optimal pour un algorithme de comparaison), où <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> n </script>  Est le nombre de places. <br><br>  J'écris cet article car je considère que la mise en œuvre de cet algorithme est une tâche très difficile.  Pour le moment, c'est le plus compliqué des algorithmes que j'ai dû implémenter.  Par conséquent, je veux partager les problèmes que j'ai rencontrés et comment les résoudre. <br><br>  Comme d'habitude, le code est affiché sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> , et tous les documents de référence que j'ai utilisés sont répertoriés à la fin de l'article. <br><a name="habracut"></a><br><h1>  Description de l'algorithme Fortune </h1><br>  Je ne vais pas expliquer comment fonctionne l'algorithme, car d'autres personnes l'ont déjà bien fait.  Je peux recommander d'étudier ces deux articles: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  La seconde est très intéressante - l'auteur a écrit une démo interactive en Javascript, utile pour comprendre le fonctionnement de l'algorithme.  Si vous avez besoin d'une approche plus formelle avec toutes les preuves, je vous recommande de lire le chapitre 7 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Computational Geometry, 3e édition</em></a> . <br><br>  De plus, je préfère traiter des détails d'implémentation qui ne sont pas bien documentés.  Et ce sont eux qui rendent la mise en œuvre de l'algorithme si complexe.  Je me concentrerai en particulier sur les structures de données utilisées. <br><br>  Je viens d'écrire un pseudo-code de l'algorithme pour vous faire une idée de sa structure globale: <br><br><blockquote><pre>  ajouter un événement de lieu à la file d'attente d'événements pour chaque lieu
 jusqu'à ce que la file d'attente d'événements soit vide
     récupérer le meilleur événement
     si l'événement est un événement de lieu
         insérer un nouvel arc dans le littoral
         vérifier les nouveaux événements du cercle
     sinon
         créer un sommet dans le diagramme
         on retire du littoral un arc resserré
         supprimer les événements invalides
         vérifier les nouveaux événements du cercle </pre></blockquote><br><h1>  Structure des données du graphique </h1><br>  Le premier problème que j'ai rencontré a été de choisir la façon de stocker le diagramme de Voronoi. <br><br>  J'ai décidé d'utiliser une structure de données largement utilisée en géométrie numérique appelée la liste des bords doublement connectés (DCEL). <br><br>  Ma classe <code>VoronoiDiagram</code> utilise quatre conteneurs comme champs: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiDiagram</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: std::vector&lt;Site&gt; mSites; std::vector&lt;Face&gt; mFaces; std::list&lt;Vertex&gt; mVertices; std::list&lt;HalfEdge&gt; mHalfEdges; }</span></span></code> </pre> <br>  Je vais parler en détail de chacun d'eux. <br><br>  La classe <code>Site</code> décrit le point d'entrée.  Chaque lieu a un index, qui est utile pour le mettre dans la file d'attente, des coordonnées et un pointeur vers la cellule ( <code>face</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Site</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; Vector2 point; Face* face; };</code> </pre> <br>  Les sommets de la cellule sont représentés par la classe <code>Vertex</code> , ils n'ont qu'un champ de coordonnées: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> Vector2 point; };</code> </pre> <br>  Voici l'implémentation des demi-bords: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HalfEdge</span></span></span><span class="hljs-class"> {</span></span> Vertex* origin; Vertex* destination; HalfEdge* twin; Face* incidentFace; HalfEdge* prev; HalfEdge* next; };</code> </pre> <br>  Vous vous demandez peut-être ce qu'est une demi-côte?  Un bord dans le diagramme de Voronoi est commun à deux cellules voisines.  Dans la structure de données DCEL, nous divisons ces bords en deux demi-bords, un pour chaque cellule, et ils sont liés par un pointeur <code>twin</code> .  De plus, le demi-bord a un point de départ et un point d'arrivée.  Le champ <code>incidentFace</code> indique la face à laquelle appartient le demi-bord.  Les cellules dans DCEL sont implémentées en tant que liste cyclique de demi-bords liés, dans laquelle les demi-bords adjacents sont connectés ensemble.  Par conséquent, les champs précédent et suivant indiquent les demi-bords précédent et suivant dans la cellule. <br><br>  La figure ci-dessous montre tous ces champs pour le demi-bord rouge: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/459/a46/ac3/459a46ac330ea630a58cb69d083a2a61.svg"></div><br>  Enfin, la classe <code>Face</code> définit la cellule.  Il contient simplement un pointeur sur sa place et un autre sur l'une de ses demi-côtes.  Peu importe lequel des demi-bords est sélectionné, car la cellule est un polygone fermé.  Ainsi, nous avons accès à toutes les demi-arêtes tout en parcourant une liste chaînée cyclique. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face</span></span></span><span class="hljs-class"> {</span></span> Site* site; HalfEdge* outerComponent; };</code> </pre> <br><h1>  File d'attente des événements </h1><br>  La manière standard d'implémenter une file d'attente d'événements est avec une file d'attente prioritaire.  Lors du traitement des événements de lieu et de cercle, il se peut que nous devions supprimer les événements de cercle de la file d'attente car ils ne sont plus valides.  Mais la plupart des implémentations de file d'attente prioritaire standard ne vous permettent pas de supprimer un élément qui n'est pas en haut.  Cela s'applique en particulier à <code>std::priority_queue</code> . <br><br>  Il existe deux façons de résoudre ce problème.  La première, la plus simple, consiste à ajouter un indicateur <code>valid</code> aux événements.  <code>valid</code> est initialement défini sur <code>true</code> .  Ensuite, au lieu de supprimer l'événement Circle de la file d'attente, nous pouvons simplement définir son indicateur sur <code>false</code> .  Enfin, lors du traitement de tous les événements de la boucle principale, nous vérifions si la valeur de drapeau <code>valid</code> de l'événement est <code>false</code> , et si c'est le cas, sautez-la simplement et traitez la suivante. <br><br>  La deuxième méthode que j'ai appliquée n'était pas d'utiliser <code>std::priority_queue</code> .  Au lieu de cela, j'ai implémenté ma propre file d'attente prioritaire, qui prend en charge la suppression de tout élément qu'elle contient.  La mise en place d'une telle file d'attente est assez simple.  J'ai choisi cette méthode car elle rend le code de l'algorithme plus propre. <br><br><h1>  Littoral </h1><br>  La structure des données du littoral est une partie complexe de l'algorithme.  En cas d'implémentation incorrecte, rien ne garantit que l'algorithme sera exécuté en <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-29" x="3868" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-3"> O (n \ log n) </script>  .  La clé pour obtenir cette complexité temporelle est d'utiliser un arbre à équilibrage automatique.  Mais c'est plus facile à dire qu'à faire! <br><br>  La plupart des ressources que j'ai étudiées (les deux articles ci-dessus et le livre sur la <em>géométrie computationnelle</em> ) vous conseillent d'implémenter le littoral comme un arbre dans lequel les nœuds internes indiquent les points de rupture et les feuilles indiquent les arcs.  Mais ils ne disent rien sur la façon d'équilibrer un arbre.  Je pense qu'un tel modèle n'est pas le meilleur, et voici pourquoi: <br><br><ul><li>  il y a des informations redondantes: nous savons qu'il y a un point de rupture entre deux arcs adjacents, il n'est donc pas nécessaire de représenter ces points comme des nœuds </li><li>  il est inadéquat pour l'auto-équilibrage: seul le sous-arbre formé par les points de rupture peut être équilibré.  Nous ne pouvons vraiment pas équilibrer tout l'arbre, sinon les arcs peuvent devenir des nœuds internes et des feuilles de points de rupture.  Écrire un algorithme pour équilibrer uniquement le sous-arbre formé par les nœuds internes me semble un cauchemar. </li></ul><br>  J'ai donc décidé de présenter le littoral différemment.  Dans mon implémentation, le littoral est également un arbre, mais tous les nœuds sont des arcs.  Un tel modèle ne présente aucun des inconvénients énumérés. <br><br>  Voici la définition de l'arc <code>Arc</code> dans mon implémentation: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class">{</span></span>RED, BLACK}; <span class="hljs-comment"><span class="hljs-comment">// Hierarchy Arc* parent; Arc* left; Arc* right; // Diagram VoronoiDiagram::Site* site; VoronoiDiagram::HalfEdge* leftHalfEdge; VoronoiDiagram::HalfEdge* rightHalfEdge; Event* event; // Optimizations Arc* prev; Arc* next; // Only for balancing Color color; };</span></span></code> </pre> <br>  Les trois premiers champs sont utilisés pour structurer l'arbre.  Le champ <code>leftHalfEdge</code> indique la demi-arête dessinée par le point le plus à gauche de l'arc.  Et <code>rightHalfEdge</code> est sur le demi-bord dessiné par le point d'extrême droite.  Deux pointeurs, précédent et suivant <code>next</code> sont utilisés pour accéder directement à l'arc précédent et suivant du littoral.  En outre, ils vous permettent également de contourner le littoral en tant que liste doublement liée.  Enfin, chaque arc a une couleur qui sert à équilibrer le littoral. <br><br>  Pour équilibrer le littoral, j'ai décidé d'utiliser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schéma rouge-noir</a> .  Lors de l'écriture de code, je me suis inspiré du livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction to Algorithms</a> .  Le chapitre 13 décrit deux algorithmes intéressants, <code>insertFixup</code> et <code>deleteFixup</code> , qui équilibrent l'arbre après l'insertion ou la suppression. <br><br>  Cependant, je ne peux pas utiliser la méthode d' <code>insert</code> indiquée dans le livre, car les clés sont utilisées pour trouver le point d'insertion du nœud.  Il n'y a pas de clés dans l'algorithme de Fortune, nous savons seulement que nous devons insérer un arc avant ou après un autre dans le littoral.  Pour implémenter cela, j'ai créé les <code>insertAfter</code> <code>insertBefore</code> et <code>insertAfter</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Beachline::insertBefore(Arc* x, Arc* y) { <span class="hljs-comment"><span class="hljs-comment">// Find the right place if (isNil(x-&gt;left)) { x-&gt;left = y; y-&gt;parent = x; } else { x-&gt;prev-&gt;right = y; y-&gt;parent = x-&gt;prev; } // Set the pointers y-&gt;prev = x-&gt;prev; if (!isNil(y-&gt;prev)) y-&gt;prev-&gt;next = y; y-&gt;next = x; x-&gt;prev = y; // Balance the tree insertFixup(y); }</span></span></code> </pre> <br>  L'insertion de <code>y</code> avant <code>x</code> se fait en trois étapes: <br><br><ol><li>  Trouvez un endroit pour insérer un nouveau nœud.  Pour ce faire, j'ai utilisé l'observation suivante: l'enfant gauche <code>x</code> ou l'enfant droit <code>x-&gt;prev</code> est <code>Nil</code> , et celui qui est <code>Nil</code> est avant <code>x</code> et après <code>x-&gt;prev</code> . </li><li>  À l'intérieur du littoral, nous conservons la structure d'une liste doublement liée, nous devons donc mettre à jour en conséquence les pointeurs <code>prev</code> et <code>next</code> des éléments <code>x-&gt;prev</code> , <code>y</code> et <code>x</code> . </li><li>  Enfin, nous appelons simplement la méthode <code>insertFixup</code> décrite dans le livre pour équilibrer l'arbre. </li></ol><br>  <code>insertAfter</code> est implémenté de manière similaire. <br><br>  La méthode de suppression extraite du livre peut être implémentée sans modifications. <br><br><h1>  Limite du graphique </h1><br>  Voici la sortie de l'algorithme de Fortune décrit ci-dessus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/c3f/443/ed5c3f4438b59de6c99e1645effe0be6.png"></div><br>  Il y a un petit problème avec certains bords de cellules sur le bord de l'image: ils ne sont pas dessinés car ils sont infinis. <br><br>  Pire, une cellule peut ne pas être un fragment unique.  Par exemple, si nous prenons trois points qui sont sur la même ligne, le point médian aura deux demi-bords infinis qui ne sont pas connectés ensemble.  Cela ne nous convient pas beaucoup, car nous ne pourrons pas accéder à l'un des demi-bords, car la cellule est une liste chaînée d'arêtes. <br><br>  Pour résoudre ces problèmes, nous limiterons le diagramme.  J'entends par là que nous limiterons chaque cellule du diagramme afin qu'elles n'aient plus de bords infinis et que chaque cellule soit un polygone fermé. <br><br>  Heureusement, l'algorithme de Fortune nous permet de trouver rapidement des bords sans fin: ils correspondent à des demi-bords toujours dans le littoral à la fin de l'algorithme. <br><br>  Mon algorithme de restriction reçoit une boîte en entrée et se compose de trois étapes: <br><br><ol><li>  Il fournit le placement de chaque sommet du diagramme à l'intérieur du rectangle. </li><li>  Coupez chaque bord infini. </li><li>  Ferme les cellules. </li></ol><br>  L'étape 1 est triviale - nous avons juste besoin d'agrandir le rectangle s'il ne contient pas de sommet. <br><br>  L'étape 2 est également assez simple - elle consiste à calculer les intersections entre les rayons et le rectangle. <br><br>  L'étape 3 n'est pas non plus très compliquée, ne nécessite qu'une attention particulière.  Je l'exécute en deux temps.  Tout d'abord, j'ajoute les points d'angle du rectangle aux cellules aux sommets dont ils devraient être.  Ensuite, je m'assure que tous les sommets de la cellule sont reliés par des demi-bords. <br><br>  Je vous recommande d'étudier le code et de poser des questions si vous avez besoin de détails sur cette partie. <br><br>  Voici le diagramme de sortie de l'algorithme de délimitation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/910/a79/33f910a79c155bd8a395fca1fd590a72.png"></div><br>  Nous voyons maintenant que toutes les arêtes sont dessinées.  Et si vous effectuez un zoom arrière, vous pouvez vous assurer que toutes les cellules sont fermées: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/402/6a6/f084026a6afbf57b142a60e5cbc49edc.png"></div><br><h1>  Intersection avec rectangle </h1><br>  Super!  Mais la première image du début de l'article est meilleure, non? <br><br>  Dans de nombreuses applications, il est utile d'avoir l'intersection entre le diagramme de Voronoi et le rectangle, comme indiqué dans la première image. <br><br>  La bonne chose est qu'après avoir restreint le graphique, c'est beaucoup plus facile à faire.  La mauvaise nouvelle est que bien que l'algorithme ne soit pas très compliqué, nous devons être prudents. <br><br>  L'idée est la suivante: nous contournons son demi-bord de chaque cellule et vérifions l'intersection entre le demi-bord et le rectangle.  Cinq cas sont possibles: <br><br><ol><li>  La demi-côte est complètement à l'intérieur du rectangle: on enregistre une telle demi-côte </li><li>  La demi-côte est complètement en dehors du rectangle: on jette une telle demi-côte </li><li>  La demi-nervure sort du rectangle: on tronque la demi-nervure et la sauvegarde comme <em>dernière demi-nervure qui sort</em> . </li><li>  La demi-nervure va à l'intérieur du rectangle: on tronque la demi-nervure pour la relier à la <em>dernière demi-nervure qui est sortie</em> (on la sauvegarde dans le cas 3 ou 5) </li><li>  La demi-nervure traverse le rectangle deux fois: nous tronquons la demi-nervure et ajoutons une demi-nervure pour la relier à la <em>dernière demi-nervure qui est sortie</em> , puis l'enregistrons en tant que nouvelle <em>dernière demi-nervure qui est sortie</em> . </li></ol><br>  Oui, il y a eu de nombreux cas.  J'ai créé une image pour les montrer tous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/368/3f1/4123683f10d59989d879315f2f83ae17.svg"></div><br>  Le polygone orange est la cellule d'origine et le rouge est la cellule tronquée.  Les demi-côtes tronquées sont marquées en rouge.  Des nervures vertes ont été ajoutées pour relier les demi-nervures entrant dans le rectangle avec les demi-nervures qui sortent. <br><br>  En appliquant cet algorithme à un diagramme borné, nous obtenons le résultat attendu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br><h1>  Conclusion </h1><br>  L'article s'est avéré assez long.  Et je suis sûr que de nombreux aspects ne sont toujours pas clairs pour vous.  J'espère néanmoins que cela vous sera utile.  Examinez le code pour plus de détails. <br><br>  Pour résumer et m'assurer que nous n'avons pas perdu de temps en vain, j'ai mesuré sur mon portable (pas cher) le temps de calculer le diagramme de Voronoi pour un nombre de places différent: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mn>1000</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.143ex" height="1.937ex" viewBox="0 -728.2 3936.6 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="1501" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>1000</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> n = 1000 </script>  : 2 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mn>10</mn><mn>000</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.305ex" height="1.937ex" viewBox="0 -728.2 4437.1 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="500" y="0"></use></g><g transform="translate(2935,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="1001" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>10</mn><mn>000</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> n = 10 000 </script>  : 33 ms </li><li><math></math><img src="https://habrastorage.org/getpro/habr/formulas/8d7/c27/89f/8d7c2789fecef0992766126bfa319a90.svg" alt="n = 100 000 $" data-tex="inline">  : 450 ms </li><li><math></math><img src="https://habrastorage.org/getpro/habr/formulas/ee9/787/123/ee9787123a0a8187eceb614a2a7fedc8.svg" alt="n = 1 000 000 $" data-tex="inline">  : 6600 ms </li></ul><br>  Je n'ai rien avec quoi comparer ces indicateurs, mais il semble que ce soit incroyablement rapide! <br><br><h1>  Les références </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article original de Stephen Fortune</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Computational Geometry, 3e édition</em></a> par Mark de Berg, Otfried Cheong, Marc van Kreveld et Mark Overmars </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorithme Fortunes: une explication intuitive</a> sur jacquesheunis.com </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorithme et implémentation</a> de Fortune sur blog.ivank.net </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Introduction to Algorithms, 3e édition</em></a> par Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest et Clifford Stein </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430628/">https://habr.com/ru/post/fr430628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430616/index.html">Séminaire "Testing and Monitoring", 27 novembre, Moscou</a></li>
<li><a href="../fr430618/index.html">Vue.js SSR & Mobile Safari: un problème non évident avec un logiciel trop intelligent</a></li>
<li><a href="../fr430620/index.html">Pensée fonctionnelle. Partie 4</a></li>
<li><a href="../fr430622/index.html">Pensée fonctionnelle. Partie 5</a></li>
<li><a href="../fr430626/index.html">Annonce du Meetup Moscou GraphQL</a></li>
<li><a href="../fr430630/index.html">Comparaison des baskets Two Balls des années 60 et 2016. De la semelle aux lacets</a></li>
<li><a href="../fr430632/index.html">Service en entreprise: comment les détaillants étrangers ouvrent des magasins clé en main en Russie</a></li>
<li><a href="../fr430634/index.html">Création d'un module logiciel pour le programmateur XELTEK SuperPro 6100</a></li>
<li><a href="../fr430636/index.html">Cervelet et noyaux basaux au lieu de la boule de cristal: comment le cerveau prédit l'avenir</a></li>
<li><a href="../fr430640/index.html">Mer Rouge: pourquoi les actions d'Apple et d'autres sociétés technologiques baissent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>