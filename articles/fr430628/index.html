<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî∞ üë®üèº‚Äçü§ù‚Äçüë®üèª ü•õ Algorithme de Fortune, d√©tails d'impl√©mentation ü§¨ üî∫ ‚ôëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours des derni√®res semaines, j'ai travaill√© sur l'impl√©mentation de l'algorithme de Fortune en C ++. Cet algorithme prend beaucoup de points 2D et...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algorithme de Fortune, d√©tails d'impl√©mentation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430628/"> Au cours des derni√®res semaines, j'ai travaill√© sur l'impl√©mentation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme de Fortune</a> en C ++.  Cet algorithme prend beaucoup de points 2D et construit √† partir d'eux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un diagramme</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voronoi</a> .  Si vous ne savez pas ce qu'est un diagramme de Voronoi, regardez la figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br>  Pour chaque point d'entr√©e, appel√© ¬´site¬ª, nous devons trouver de nombreux points plus proches de cet endroit que de tout le monde.  Ces ensembles de points forment les cellules montr√©es dans l'image ci-dessus. <br><br>  Il est remarquable dans l'algorithme de Fortune qu'il construit de tels diagrammes dans le temps <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-29" x="3868" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (n \ log n) </script>  (ce qui est optimal pour un algorithme de comparaison), o√π <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> n </script>  Est le nombre de places. <br><br>  J'√©cris cet article car je consid√®re que la mise en ≈ìuvre de cet algorithme est une t√¢che tr√®s difficile.  Pour le moment, c'est le plus compliqu√© des algorithmes que j'ai d√ª impl√©menter.  Par cons√©quent, je veux partager les probl√®mes que j'ai rencontr√©s et comment les r√©soudre. <br><br>  Comme d'habitude, le code est affich√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> , et tous les documents de r√©f√©rence que j'ai utilis√©s sont r√©pertori√©s √† la fin de l'article. <br><a name="habracut"></a><br><h1>  Description de l'algorithme Fortune </h1><br>  Je ne vais pas expliquer comment fonctionne l'algorithme, car d'autres personnes l'ont d√©j√† bien fait.  Je peux recommander d'√©tudier ces deux articles: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  La seconde est tr√®s int√©ressante - l'auteur a √©crit une d√©mo interactive en Javascript, utile pour comprendre le fonctionnement de l'algorithme.  Si vous avez besoin d'une approche plus formelle avec toutes les preuves, je vous recommande de lire le chapitre 7 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Computational Geometry, 3e √©dition</em></a> . <br><br>  De plus, je pr√©f√®re traiter des d√©tails d'impl√©mentation qui ne sont pas bien document√©s.  Et ce sont eux qui rendent la mise en ≈ìuvre de l'algorithme si complexe.  Je me concentrerai en particulier sur les structures de donn√©es utilis√©es. <br><br>  Je viens d'√©crire un pseudo-code de l'algorithme pour vous faire une id√©e de sa structure globale: <br><br><blockquote><pre>  ajouter un √©v√©nement de lieu √† la file d'attente d'√©v√©nements pour chaque lieu
 jusqu'√† ce que la file d'attente d'√©v√©nements soit vide
     r√©cup√©rer le meilleur √©v√©nement
     si l'√©v√©nement est un √©v√©nement de lieu
         ins√©rer un nouvel arc dans le littoral
         v√©rifier les nouveaux √©v√©nements du cercle
     sinon
         cr√©er un sommet dans le diagramme
         on retire du littoral un arc resserr√©
         supprimer les √©v√©nements invalides
         v√©rifier les nouveaux √©v√©nements du cercle </pre></blockquote><br><h1>  Structure des donn√©es du graphique </h1><br>  Le premier probl√®me que j'ai rencontr√© a √©t√© de choisir la fa√ßon de stocker le diagramme de Voronoi. <br><br>  J'ai d√©cid√© d'utiliser une structure de donn√©es largement utilis√©e en g√©om√©trie num√©rique appel√©e la liste des bords doublement connect√©s (DCEL). <br><br>  Ma classe <code>VoronoiDiagram</code> utilise quatre conteneurs comme champs: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiDiagram</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: std::vector&lt;Site&gt; mSites; std::vector&lt;Face&gt; mFaces; std::list&lt;Vertex&gt; mVertices; std::list&lt;HalfEdge&gt; mHalfEdges; }</span></span></code> </pre> <br>  Je vais parler en d√©tail de chacun d'eux. <br><br>  La classe <code>Site</code> d√©crit le point d'entr√©e.  Chaque lieu a un index, qui est utile pour le mettre dans la file d'attente, des coordonn√©es et un pointeur vers la cellule ( <code>face</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Site</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; Vector2 point; Face* face; };</code> </pre> <br>  Les sommets de la cellule sont repr√©sent√©s par la classe <code>Vertex</code> , ils n'ont qu'un champ de coordonn√©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> Vector2 point; };</code> </pre> <br>  Voici l'impl√©mentation des demi-bords: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HalfEdge</span></span></span><span class="hljs-class"> {</span></span> Vertex* origin; Vertex* destination; HalfEdge* twin; Face* incidentFace; HalfEdge* prev; HalfEdge* next; };</code> </pre> <br>  Vous vous demandez peut-√™tre ce qu'est une demi-c√¥te?  Un bord dans le diagramme de Voronoi est commun √† deux cellules voisines.  Dans la structure de donn√©es DCEL, nous divisons ces bords en deux demi-bords, un pour chaque cellule, et ils sont li√©s par un pointeur <code>twin</code> .  De plus, le demi-bord a un point de d√©part et un point d'arriv√©e.  Le champ <code>incidentFace</code> indique la face √† laquelle appartient le demi-bord.  Les cellules dans DCEL sont impl√©ment√©es en tant que liste cyclique de demi-bords li√©s, dans laquelle les demi-bords adjacents sont connect√©s ensemble.  Par cons√©quent, les champs pr√©c√©dent et suivant indiquent les demi-bords pr√©c√©dent et suivant dans la cellule. <br><br>  La figure ci-dessous montre tous ces champs pour le demi-bord rouge: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/459/a46/ac3/459a46ac330ea630a58cb69d083a2a61.svg"></div><br>  Enfin, la classe <code>Face</code> d√©finit la cellule.  Il contient simplement un pointeur sur sa place et un autre sur l'une de ses demi-c√¥tes.  Peu importe lequel des demi-bords est s√©lectionn√©, car la cellule est un polygone ferm√©.  Ainsi, nous avons acc√®s √† toutes les demi-ar√™tes tout en parcourant une liste cha√Æn√©e cyclique. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face</span></span></span><span class="hljs-class"> {</span></span> Site* site; HalfEdge* outerComponent; };</code> </pre> <br><h1>  File d'attente des √©v√©nements </h1><br>  La mani√®re standard d'impl√©menter une file d'attente d'√©v√©nements est avec une file d'attente prioritaire.  Lors du traitement des √©v√©nements de lieu et de cercle, il se peut que nous devions supprimer les √©v√©nements de cercle de la file d'attente car ils ne sont plus valides.  Mais la plupart des impl√©mentations de file d'attente prioritaire standard ne vous permettent pas de supprimer un √©l√©ment qui n'est pas en haut.  Cela s'applique en particulier √† <code>std::priority_queue</code> . <br><br>  Il existe deux fa√ßons de r√©soudre ce probl√®me.  La premi√®re, la plus simple, consiste √† ajouter un indicateur <code>valid</code> aux √©v√©nements.  <code>valid</code> est initialement d√©fini sur <code>true</code> .  Ensuite, au lieu de supprimer l'√©v√©nement Circle de la file d'attente, nous pouvons simplement d√©finir son indicateur sur <code>false</code> .  Enfin, lors du traitement de tous les √©v√©nements de la boucle principale, nous v√©rifions si la valeur de drapeau <code>valid</code> de l'√©v√©nement est <code>false</code> , et si c'est le cas, sautez-la simplement et traitez la suivante. <br><br>  La deuxi√®me m√©thode que j'ai appliqu√©e n'√©tait pas d'utiliser <code>std::priority_queue</code> .  Au lieu de cela, j'ai impl√©ment√© ma propre file d'attente prioritaire, qui prend en charge la suppression de tout √©l√©ment qu'elle contient.  La mise en place d'une telle file d'attente est assez simple.  J'ai choisi cette m√©thode car elle rend le code de l'algorithme plus propre. <br><br><h1>  Littoral </h1><br>  La structure des donn√©es du littoral est une partie complexe de l'algorithme.  En cas d'impl√©mentation incorrecte, rien ne garantit que l'algorithme sera ex√©cut√© en <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-29" x="3868" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-3"> O (n \ log n) </script>  .  La cl√© pour obtenir cette complexit√© temporelle est d'utiliser un arbre √† √©quilibrage automatique.  Mais c'est plus facile √† dire qu'√† faire! <br><br>  La plupart des ressources que j'ai √©tudi√©es (les deux articles ci-dessus et le livre sur la <em>g√©om√©trie computationnelle</em> ) vous conseillent d'impl√©menter le littoral comme un arbre dans lequel les n≈ìuds internes indiquent les points de rupture et les feuilles indiquent les arcs.  Mais ils ne disent rien sur la fa√ßon d'√©quilibrer un arbre.  Je pense qu'un tel mod√®le n'est pas le meilleur, et voici pourquoi: <br><br><ul><li>  il y a des informations redondantes: nous savons qu'il y a un point de rupture entre deux arcs adjacents, il n'est donc pas n√©cessaire de repr√©senter ces points comme des n≈ìuds </li><li>  il est inad√©quat pour l'auto-√©quilibrage: seul le sous-arbre form√© par les points de rupture peut √™tre √©quilibr√©.  Nous ne pouvons vraiment pas √©quilibrer tout l'arbre, sinon les arcs peuvent devenir des n≈ìuds internes et des feuilles de points de rupture.  √âcrire un algorithme pour √©quilibrer uniquement le sous-arbre form√© par les n≈ìuds internes me semble un cauchemar. </li></ul><br>  J'ai donc d√©cid√© de pr√©senter le littoral diff√©remment.  Dans mon impl√©mentation, le littoral est √©galement un arbre, mais tous les n≈ìuds sont des arcs.  Un tel mod√®le ne pr√©sente aucun des inconv√©nients √©num√©r√©s. <br><br>  Voici la d√©finition de l'arc <code>Arc</code> dans mon impl√©mentation: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class">{</span></span>RED, BLACK}; <span class="hljs-comment"><span class="hljs-comment">// Hierarchy Arc* parent; Arc* left; Arc* right; // Diagram VoronoiDiagram::Site* site; VoronoiDiagram::HalfEdge* leftHalfEdge; VoronoiDiagram::HalfEdge* rightHalfEdge; Event* event; // Optimizations Arc* prev; Arc* next; // Only for balancing Color color; };</span></span></code> </pre> <br>  Les trois premiers champs sont utilis√©s pour structurer l'arbre.  Le champ <code>leftHalfEdge</code> indique la demi-ar√™te dessin√©e par le point le plus √† gauche de l'arc.  Et <code>rightHalfEdge</code> est sur le demi-bord dessin√© par le point d'extr√™me droite.  Deux pointeurs, pr√©c√©dent et suivant <code>next</code> sont utilis√©s pour acc√©der directement √† l'arc pr√©c√©dent et suivant du littoral.  En outre, ils vous permettent √©galement de contourner le littoral en tant que liste doublement li√©e.  Enfin, chaque arc a une couleur qui sert √† √©quilibrer le littoral. <br><br>  Pour √©quilibrer le littoral, j'ai d√©cid√© d'utiliser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sch√©ma rouge-noir</a> .  Lors de l'√©criture de code, je me suis inspir√© du livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction to Algorithms</a> .  Le chapitre 13 d√©crit deux algorithmes int√©ressants, <code>insertFixup</code> et <code>deleteFixup</code> , qui √©quilibrent l'arbre apr√®s l'insertion ou la suppression. <br><br>  Cependant, je ne peux pas utiliser la m√©thode d' <code>insert</code> indiqu√©e dans le livre, car les cl√©s sont utilis√©es pour trouver le point d'insertion du n≈ìud.  Il n'y a pas de cl√©s dans l'algorithme de Fortune, nous savons seulement que nous devons ins√©rer un arc avant ou apr√®s un autre dans le littoral.  Pour impl√©menter cela, j'ai cr√©√© les <code>insertAfter</code> <code>insertBefore</code> et <code>insertAfter</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Beachline::insertBefore(Arc* x, Arc* y) { <span class="hljs-comment"><span class="hljs-comment">// Find the right place if (isNil(x-&gt;left)) { x-&gt;left = y; y-&gt;parent = x; } else { x-&gt;prev-&gt;right = y; y-&gt;parent = x-&gt;prev; } // Set the pointers y-&gt;prev = x-&gt;prev; if (!isNil(y-&gt;prev)) y-&gt;prev-&gt;next = y; y-&gt;next = x; x-&gt;prev = y; // Balance the tree insertFixup(y); }</span></span></code> </pre> <br>  L'insertion de <code>y</code> avant <code>x</code> se fait en trois √©tapes: <br><br><ol><li>  Trouvez un endroit pour ins√©rer un nouveau n≈ìud.  Pour ce faire, j'ai utilis√© l'observation suivante: l'enfant gauche <code>x</code> ou l'enfant droit <code>x-&gt;prev</code> est <code>Nil</code> , et celui qui est <code>Nil</code> est avant <code>x</code> et apr√®s <code>x-&gt;prev</code> . </li><li>  √Ä l'int√©rieur du littoral, nous conservons la structure d'une liste doublement li√©e, nous devons donc mettre √† jour en cons√©quence les pointeurs <code>prev</code> et <code>next</code> des √©l√©ments <code>x-&gt;prev</code> , <code>y</code> et <code>x</code> . </li><li>  Enfin, nous appelons simplement la m√©thode <code>insertFixup</code> d√©crite dans le livre pour √©quilibrer l'arbre. </li></ol><br>  <code>insertAfter</code> est impl√©ment√© de mani√®re similaire. <br><br>  La m√©thode de suppression extraite du livre peut √™tre impl√©ment√©e sans modifications. <br><br><h1>  Limite du graphique </h1><br>  Voici la sortie de l'algorithme de Fortune d√©crit ci-dessus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/c3f/443/ed5c3f4438b59de6c99e1645effe0be6.png"></div><br>  Il y a un petit probl√®me avec certains bords de cellules sur le bord de l'image: ils ne sont pas dessin√©s car ils sont infinis. <br><br>  Pire, une cellule peut ne pas √™tre un fragment unique.  Par exemple, si nous prenons trois points qui sont sur la m√™me ligne, le point m√©dian aura deux demi-bords infinis qui ne sont pas connect√©s ensemble.  Cela ne nous convient pas beaucoup, car nous ne pourrons pas acc√©der √† l'un des demi-bords, car la cellule est une liste cha√Æn√©e d'ar√™tes. <br><br>  Pour r√©soudre ces probl√®mes, nous limiterons le diagramme.  J'entends par l√† que nous limiterons chaque cellule du diagramme afin qu'elles n'aient plus de bords infinis et que chaque cellule soit un polygone ferm√©. <br><br>  Heureusement, l'algorithme de Fortune nous permet de trouver rapidement des bords sans fin: ils correspondent √† des demi-bords toujours dans le littoral √† la fin de l'algorithme. <br><br>  Mon algorithme de restriction re√ßoit une bo√Æte en entr√©e et se compose de trois √©tapes: <br><br><ol><li>  Il fournit le placement de chaque sommet du diagramme √† l'int√©rieur du rectangle. </li><li>  Coupez chaque bord infini. </li><li>  Ferme les cellules. </li></ol><br>  L'√©tape 1 est triviale - nous avons juste besoin d'agrandir le rectangle s'il ne contient pas de sommet. <br><br>  L'√©tape 2 est √©galement assez simple - elle consiste √† calculer les intersections entre les rayons et le rectangle. <br><br>  L'√©tape 3 n'est pas non plus tr√®s compliqu√©e, ne n√©cessite qu'une attention particuli√®re.  Je l'ex√©cute en deux temps.  Tout d'abord, j'ajoute les points d'angle du rectangle aux cellules aux sommets dont ils devraient √™tre.  Ensuite, je m'assure que tous les sommets de la cellule sont reli√©s par des demi-bords. <br><br>  Je vous recommande d'√©tudier le code et de poser des questions si vous avez besoin de d√©tails sur cette partie. <br><br>  Voici le diagramme de sortie de l'algorithme de d√©limitation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/910/a79/33f910a79c155bd8a395fca1fd590a72.png"></div><br>  Nous voyons maintenant que toutes les ar√™tes sont dessin√©es.  Et si vous effectuez un zoom arri√®re, vous pouvez vous assurer que toutes les cellules sont ferm√©es: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/402/6a6/f084026a6afbf57b142a60e5cbc49edc.png"></div><br><h1>  Intersection avec rectangle </h1><br>  Super!  Mais la premi√®re image du d√©but de l'article est meilleure, non? <br><br>  Dans de nombreuses applications, il est utile d'avoir l'intersection entre le diagramme de Voronoi et le rectangle, comme indiqu√© dans la premi√®re image. <br><br>  La bonne chose est qu'apr√®s avoir restreint le graphique, c'est beaucoup plus facile √† faire.  La mauvaise nouvelle est que bien que l'algorithme ne soit pas tr√®s compliqu√©, nous devons √™tre prudents. <br><br>  L'id√©e est la suivante: nous contournons son demi-bord de chaque cellule et v√©rifions l'intersection entre le demi-bord et le rectangle.  Cinq cas sont possibles: <br><br><ol><li>  La demi-c√¥te est compl√®tement √† l'int√©rieur du rectangle: on enregistre une telle demi-c√¥te </li><li>  La demi-c√¥te est compl√®tement en dehors du rectangle: on jette une telle demi-c√¥te </li><li>  La demi-nervure sort du rectangle: on tronque la demi-nervure et la sauvegarde comme <em>derni√®re demi-nervure qui sort</em> . </li><li>  La demi-nervure va √† l'int√©rieur du rectangle: on tronque la demi-nervure pour la relier √† la <em>derni√®re demi-nervure qui est sortie</em> (on la sauvegarde dans le cas 3 ou 5) </li><li>  La demi-nervure traverse le rectangle deux fois: nous tronquons la demi-nervure et ajoutons une demi-nervure pour la relier √† la <em>derni√®re demi-nervure qui est sortie</em> , puis l'enregistrons en tant que nouvelle <em>derni√®re demi-nervure qui est sortie</em> . </li></ol><br>  Oui, il y a eu de nombreux cas.  J'ai cr√©√© une image pour les montrer tous: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/368/3f1/4123683f10d59989d879315f2f83ae17.svg"></div><br>  Le polygone orange est la cellule d'origine et le rouge est la cellule tronqu√©e.  Les demi-c√¥tes tronqu√©es sont marqu√©es en rouge.  Des nervures vertes ont √©t√© ajout√©es pour relier les demi-nervures entrant dans le rectangle avec les demi-nervures qui sortent. <br><br>  En appliquant cet algorithme √† un diagramme born√©, nous obtenons le r√©sultat attendu: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br><h1>  Conclusion </h1><br>  L'article s'est av√©r√© assez long.  Et je suis s√ªr que de nombreux aspects ne sont toujours pas clairs pour vous.  J'esp√®re n√©anmoins que cela vous sera utile.  Examinez le code pour plus de d√©tails. <br><br>  Pour r√©sumer et m'assurer que nous n'avons pas perdu de temps en vain, j'ai mesur√© sur mon portable (pas cher) le temps de calculer le diagramme de Voronoi pour un nombre de places diff√©rent: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mn>1000</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.143ex" height="1.937ex" viewBox="0 -728.2 3936.6 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="1501" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>1000</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> n = 1000 </script>  : 2 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>=</mo><mn>10</mn><mn>000</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.305ex" height="1.937ex" viewBox="0 -728.2 4437.1 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="500" y="0"></use></g><g transform="translate(2935,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhij5PIHZhbO7WmRJbj6fouuhSHd-Q#MJMAIN-30" x="1001" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>10</mn><mn>000</mn></math></span></span><script type="math/tex" id="MathJax-Element-5"> n = 10 000 </script>  : 33 ms </li><li><math></math><img src="https://habrastorage.org/getpro/habr/formulas/8d7/c27/89f/8d7c2789fecef0992766126bfa319a90.svg" alt="n = 100 000 $" data-tex="inline">  : 450 ms </li><li><math></math><img src="https://habrastorage.org/getpro/habr/formulas/ee9/787/123/ee9787123a0a8187eceb614a2a7fedc8.svg" alt="n = 1 000 000 $" data-tex="inline">  : 6600 ms </li></ul><br>  Je n'ai rien avec quoi comparer ces indicateurs, mais il semble que ce soit incroyablement rapide! <br><br><h1>  Les r√©f√©rences </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article original de Stephen Fortune</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Computational Geometry, 3e √©dition</em></a> par Mark de Berg, Otfried Cheong, Marc van Kreveld et Mark Overmars </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorithme Fortunes: une explication intuitive</a> sur jacquesheunis.com </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Algorithme et impl√©mentation</a> de Fortune sur blog.ivank.net </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Introduction to Algorithms, 3e √©dition</em></a> par Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest et Clifford Stein </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430628/">https://habr.com/ru/post/fr430628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430616/index.html">S√©minaire "Testing and Monitoring", 27 novembre, Moscou</a></li>
<li><a href="../fr430618/index.html">Vue.js SSR & Mobile Safari: un probl√®me non √©vident avec un logiciel trop intelligent</a></li>
<li><a href="../fr430620/index.html">Pens√©e fonctionnelle. Partie 4</a></li>
<li><a href="../fr430622/index.html">Pens√©e fonctionnelle. Partie 5</a></li>
<li><a href="../fr430626/index.html">Annonce du Meetup Moscou GraphQL</a></li>
<li><a href="../fr430630/index.html">Comparaison des baskets Two Balls des ann√©es 60 et 2016. De la semelle aux lacets</a></li>
<li><a href="../fr430632/index.html">Service en entreprise: comment les d√©taillants √©trangers ouvrent des magasins cl√© en main en Russie</a></li>
<li><a href="../fr430634/index.html">Cr√©ation d'un module logiciel pour le programmateur XELTEK SuperPro 6100</a></li>
<li><a href="../fr430636/index.html">Cervelet et noyaux basaux au lieu de la boule de cristal: comment le cerveau pr√©dit l'avenir</a></li>
<li><a href="../fr430640/index.html">Mer Rouge: pourquoi les actions d'Apple et d'autres soci√©t√©s technologiques baissent</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>