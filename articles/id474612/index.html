<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏻 🐹 👴🏾 Arsitektur EBA alias reaktivitas penuh ↙️ 👎🏿 🐘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya datang ke Tinkoff beberapa tahun yang lalu, pada sebuah proyek baru, Pelanggan dan Proyek , yang baru saja dimulai saat itu. 
 Sekarang saya tida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur EBA alias reaktivitas penuh</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/474612/"><p>  Saya datang ke Tinkoff beberapa tahun yang lalu, pada sebuah proyek baru, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelanggan dan Proyek</a> , yang baru saja dimulai saat itu. <br>  Sekarang saya tidak ingat perasaan saya dari arsitektur baru itu untuk saya.  Tapi saya ingat pasti: itu tidak biasa bahwa Rx digunakan di tempat lain, di luar perjalanan biasa ke jaringan dan ke pangkalan.  Sekarang setelah arsitektur ini telah melewati beberapa jalur perkembangan evolusi, saya ingin akhirnya berbicara tentang apa yang terjadi dan apa yang terjadi. </p><br><p><img src="https://habrastorage.org/webt/gk/ru/ve/gkruveswoxzhqfxjfasm_vaf2qq.png"></p><br><p>  Menurut pendapat saya, semua arsitektur yang saat ini populer - MVP, MVVM, dan bahkan MVI - telah lama berada di arena dan tidak selalu layak.  Bukankah mereka memiliki kekurangan?  Saya melihat banyak dari mereka.  Kami memutuskan di tempat kami bahwa itu cukup untuk bertahan, dan (kembali) menemukan arsitektur baru yang tidak sinkron. </p><a name="habracut"></a><br><p>  Saya akan menjelaskan secara singkat apa yang tidak saya sukai tentang arsitektur saat ini.  Beberapa poin mungkin kontroversial.  Mungkin Anda belum pernah mengalami ini, Anda menulis pemrograman Jedi yang sempurna dan umumnya.  Lalu maafkan aku, orang berdosa. <br>  Jadi rasa sakit saya adalah: </p><br><ul><li>  Presenter Besar / ViewModel. </li><li>  Sejumlah besar switch-case di MVI. </li><li>  Ketidakmampuan untuk menggunakan kembali bagian Presenter / ViewModel dan, sebagai akibatnya, kebutuhan untuk menduplikasi kode. </li><li>  Tumpukan variabel yang bisa berubah yang dapat dimodifikasi dari mana saja.  Karenanya, kode tersebut sulit dipertahankan dan dimodifikasi. </li><li>  Pembaruan layar tidak terurai. </li><li>  Sulit untuk menulis tes. </li></ul><br><h2 id="problematika">  <strong>Masalah</strong> </h2><br><blockquote>  Setiap saat, aplikasi memiliki status tertentu yang menentukan perilakunya dan apa yang dilihat pengguna.  Keadaan ini mencakup semua nilai variabel - dari bendera sederhana hingga objek individual.  Masing-masing variabel hidup sendiri dan dikendalikan oleh bagian kode yang berbeda.  Anda dapat menentukan kondisi aplikasi saat ini hanya dengan memeriksa semuanya, satu demi satu. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel tentang arsitektur Kotlin MVI modern</a> <br><cut></cut><br></blockquote><br><h2 id="glava-1-evolyuciya--nashe-vsyo">  <strong>Bab 1. Evolusi adalah segalanya bagi kita</strong> </h2><br><p>  Awalnya, kami menulis di MVP, tetapi sedikit bermutasi.  Itu campuran MVP dan MVI.  Ada entitas dari MVP dalam bentuk presenter dan tampilan antarmuka: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewTaskView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newTaskAction: Observable&lt;NewTaskAction&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> taskNameChangeAction: Observable&lt;String&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onChangeState: Consumer&lt;SomeViewState&gt; }</code> </pre> <br><p>  Sudah di sini Anda dapat melihat tangkapan: Lihat di sini sangat jauh dari kanon MVP.  Ada metode dalam presenter: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeView</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Disposable</code> </pre> <br><p>  Di luar, implementasi antarmuka disahkan yang secara reaktif berlangganan perubahan UI.  Dan itu sudah menampar MVI! </p><br><p>  Lebih banyak lebih.  Di Presenter, berbagai interaksi dibuat dan berlangganan perubahan Lihat, tetapi mereka tidak memanggil metode UI secara langsung, tetapi mengembalikan beberapa Negara global, di mana ada semua kemungkinan kondisi layar: </p><br><pre> <code class="kotlin hljs">compositeDisposable.add( Observable.merge(firstAction, secondAction) .observeOn(AndroidSchedulers.mainThread()) .subscribe(view.onChangeState)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compositeDisposable</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewState</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> progress: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> error: Throwable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage: String? = error?.message, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result: TaskUi? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre><br><p>  Aktivitas adalah turunan dari antarmuka SomeViewStateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSuccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeUiModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toProgress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buttonEnabled: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Ketika pengguna mengklik sesuatu di layar, sebuah peristiwa datang ke presenter dan ia menciptakan model baru, yang digambar oleh kelas khusus: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateResolver</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateMachine: SomeViewStateMachine) : Consumer&lt;SomeViewState&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stateUpdate: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeViewState</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.toSuccess(stateUpdate.result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.error != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { stateMachine.toError(stateUpdate.errorMessage) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { stateMachine.toProgress() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.someButtonEnabled != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.changeSomeButton(stateUpdate.someButtonEnabled) } } }</code> </pre> <br><p>  Setuju, beberapa MVP aneh, dan bahkan jauh dari MVI.  Mencari inspirasi. </p><br><h2 id="glava-2-redux">  <strong>Bab 2. Redux</strong> </h2><br><p><img src="https://habrastorage.org/webt/sw/bm/pf/swbmpfddkyjohcxemag4a0zdatm.jpeg"></p><br><p>  Berbicara tentang masalahnya dengan pengembang lain, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemimpin</a> kami (yang masih) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sergey Boishtyan</a> belajar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux</a> . </p><br><p>  Setelah menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembicaraan Dorfman tentang semua arsitektur</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bermain</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Redux</a> , kami memutuskan untuk menggunakannya untuk meningkatkan arsitektur kami. <br>  Tapi pertama-tama, mari kita melihat lebih dekat pada arsitektur dan melihat pro dan kontra. </p><br><p>  <strong>Aksi</strong> <br>  Menjelaskan tindakannya. </p><br><p>  <strong>Actioncreator</strong> <br>  Dia seperti analis sistem: format, melengkapi spesifikasi kebutuhan pelanggan sehingga pemrogram memahaminya. <br>  Ketika pengguna mengklik pada layar, ActionsCreator membentuk Tindakan yang masuk ke middleware (semacam logika bisnis).  Logika bisnis memberi kita data baru yang diterima dan digambar Reducer tertentu. </p><br><p>  Jika Anda melihat gambar lagi, Anda mungkin melihat objek seperti Store.  Toko toko Reduksi.  Yaitu, kita melihat bahwa saudara-saudara front-end - saudara yang malang - telah menebak bahwa satu benda besar dapat digergaji menjadi banyak benda kecil, yang masing-masing akan bertanggung jawab atas bagian layarnya.  Dan ini hanya pemikiran yang luar biasa! </p><br><p>  Kode contoh untuk ActionCreators sederhana (hati-hati, JavaScript!): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ADD_TODO, text } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggleTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: TOGGLE_TODO, index } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setVisibilityFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: SET_VISIBILITY_FILTER, filter } }</code> </pre> <br><p>  <strong>Peredam</strong> </p><br><blockquote>  Tindakan menggambarkan fakta bahwa sesuatu terjadi, tetapi tidak menunjukkan bagaimana keadaan aplikasi harus berubah sebagai respons, ini berfungsi untuk Peredam. </blockquote><p>  Singkatnya, Reducer tahu bagaimana cara mendekomposisi layar / view secara terurai. </p><br><p>  Pro: </p><br><ul><li>  Pembaruan layar terurai. </li><li>  Aliran data searah. </li></ul><br><p>  Cons: </p><br><ul><li>  Beralih favorit lagi. <br><pre> <code class="kotlin hljs">function todoApp(state = initialState, action) { switch (action.type) { case SET_VISIBILITY_FILTER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { visibilityFilter: action.filter }) case ADD_TODO: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { todos: [ ...state.todos, { text: action.text, completed: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] }) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state }</code> </pre> </li><li>  Banyak objek negara. </li><li>  Pemisahan logika menjadi ActionCreator dan Reducer. </li></ul><br><p>  Ya, bagi kami sepertinya pemisahan ActionCreator dan Reducer bukanlah pilihan terbaik untuk menghubungkan model dan layar, karena menulis instanceof adalah pendekatan yang buruk.  Dan di sini kami menemukan arsitektur KAMI! </p><br><h2 id="glava-3-eba">  <strong>Bab 3. EBA</strong> </h2><br><p><img src="https://habrastorage.org/webt/os/6w/7_/os6w7_sgmegw6nsh7lyebs_o9de.jpeg"></p><br><p>  Apa itu Action dan ActionCreator dalam konteks EBA: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionCreator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"></span></span><span class="hljs-class"><span class="hljs-type"></span></span>(T) -&gt; (Observable&lt;Action&gt;)</code> </pre> <br><p>  Ya, setengah dari arsitekturnya adalah typealias dan antarmuka.  Kesederhanaan sama dengan keanggunan! </p><br><p>  Diperlukan tindakan untuk memanggil sesuatu tanpa mengirimkan data apa pun.  Karena ActionCreator mengembalikan Observable, kami harus membungkus Action dengan lambda lain untuk mengirimkan beberapa data.  Dan ternyata ActionMapper - Aksi yang diketik di mana kita bisa melewati apa yang kita butuhkan untuk memperbarui layar / tampilan. <br><br>  <strong>Postulat dasar:</strong> <br></p><div class="spoiler">  <b class="spoiler_title">One ActionCreator - satu bagian dari layar</b> <div class="spoiler_text"><p>  Dengan paragraf pertama, semuanya jelas: sehingga tidak ada neraka dari pembaruan lintas yang tidak dapat dipahami, kami sepakat bahwa satu ActionCreator dapat memperbarui hanya bagian layarnya.  Jika itu daftar, itu hanya memperbarui daftar, jika tombol hanya itu. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Belati tidak dibutuhkan</b> <div class="spoiler_text"><p>  Tapi, orang bertanya-tanya, mengapa belati tidak menyenangkan kita?  Aku memberitahumu. <br>  Sebuah kisah yang khas adalah ketika seorang Sergey abstrak alias master belati alias "Apa yang dilakukan abstrak ini?" Ada di proyek. </p><br><p>  Ternyata jika Anda bereksperimen dengan belati, Anda harus menjelaskan setiap kali kepada setiap pengembang baru (dan bukan hanya baru).  Atau mungkin Anda sendiri sudah lupa apa yang dilakukan anotasi ini, dan Anda membuka google. </p><br><p>  Semua ini sangat menyulitkan proses pembuatan fitur tanpa memperkenalkan banyak kenyamanan.  Oleh karena itu, kami memutuskan bahwa kami akan menciptakan hal-hal yang kami butuhkan dengan tangan kami, sehingga akan lebih cepat untuk berkumpul, karena tidak ada pembuatan kode.  Ya, kami akan menghabiskan lima menit ekstra untuk menulis semua dependensi dengan tangan kami, tetapi kami akan menghemat banyak waktu untuk kompilasi.  Ya, di mana-mana kita tidak meninggalkan belati, itu digunakan pada tingkat global, itu menciptakan beberapa hal umum, tetapi kita menulisnya di Jawa untuk optimasi yang lebih baik, agar tidak menarik kapt. </p></div></div><br><p>  <strong>Skema arsitektur</strong> : </p><br><p><img src="https://habrastorage.org/webt/1w/m6/1a/1wm61atrwg2dmy4hkzfherwsbqc.png"></p><br><p>  Komponen adalah analog dari komponen yang sama dari Dagger, hanya tanpa Dagger.  Tugasnya adalah membuat binder.  Binder mengikat ActionCreator bersama.  Dari Lihat ke Acara Binder muncul tentang apa yang terjadi, dan dari Binder ke Lihat, Tindakan dikirimkan untuk memperbarui layar. </p><br><p>  <strong>Actioncreator</strong> </p><br><p><img src="https://habrastorage.org/webt/8v/nw/3p/8vnw3p52mcfzyyhegcxtkexgokm.png"></p><br><p>  Sekarang mari kita lihat seperti apa ini - ActionCreator.  Dalam kasus yang paling sederhana, ia hanya memproses tindakan secara tidak langsung.  Misalkan ada skenario seperti itu: pengguna mengklik tombol "Buat tugas".  Layar lain harus terbuka, di mana kami akan menggambarkannya, tanpa permintaan tambahan. </p><br><p>  Untuk melakukan ini, kita cukup berlangganan tombol menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RxBinding</a> dari Jake yang kita cintai dan menunggu pengguna mengkliknya.  Segera setelah klik terjadi, Binder akan mengirimkan Acara ke ActionCreator tertentu, yang akan memanggil Aksi kami, yang akan membuka layar baru untuk kami.  Perhatikan bahwa tidak ada sakelar.  Selanjutnya saya akan tunjukkan dalam kode mengapa demikian. <br>  Jika kami tiba-tiba perlu pergi ke jaringan atau database, kami membuat permintaan ini di sana, tetapi melalui interaktor yang kami berikan ke konstruktor ActionCreator melalui antarmuka untuk memanggil mereka: </p><br><blockquote>  Penafian: pemformatan kode tidak cukup di sini, saya punya aturan untuk artikel sehingga kode dibaca dengan baik. </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadItemsActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> getItems: () -&gt; Observable&lt;List&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> showLoadedItems: ActionMapper&lt;DiffResult&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diffCalculator: DiffCalculator&lt;ViewTyped&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorItem: ErrorView, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> emptyItem: ViewTyped? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) : ActionOnEvent</code> </pre> <br><p>  Dengan kata-kata "oleh antarmuka panggilan mereka", saya maksudkan persis bagaimana getItems dideklarasikan (di sini ViewTyped adalah antarmuka kami untuk bekerja dengan daftar).  Ngomong-ngomong, kami telah menggunakan kembali ActionCreator ini di delapan bagian aplikasi yang berbeda, karena ini ditulis seserbuk mungkin. </p><br><p>  Karena peristiwa bersifat reaktif, kita dapat merakit rantai dengan menambahkan operator lain di sana, misalnya, mulai dengan (showLoadingAction) untuk menampilkan pemuatan, dan onErrorReturn (errorAction) untuk menunjukkan keadaan layar dengan kesalahan. <br>  Dan semua ini reaktif! </p><br><h2 id="primer-">  <strong>Contoh</strong> </h2><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompositionFragment</span></span></span></span>(R.layout.fragment_about) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.clicks(), openProcessingPersDataEvent = personalDataProtection.clicks(), unbindEvent = unBindEvent) component.binder().bind(events) }</code> </pre> <br><p>  Mari kita lihat arsitektur menggunakan kode sebagai contoh.  Untuk memulai, saya memilih salah satu layar paling sederhana - tentang aplikasi, karena ini adalah layar statis. <br>  Pertimbangkan untuk membuat komponen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } } )</code> </pre> <br><p>  Argumen komponen - Actions / ActionMappers - membantu mengaitkan View dengan ActionCreators.  Di ActionMapper'e setVersionName kami melewati versi proyek dan memberikan nilai ini ke teks di layar.  Di openPdfAction, sepasang tautan ke dokumen dan nama untuk membuka layar berikutnya di mana pengguna dapat membaca dokumen ini. </p><br><p>  Berikut adalah komponen itu sendiri: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionMapper&lt;String&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, someUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, anotherUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName = setVersionName.toSimpleActionCreator( moreComponent::currentVersionName ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AboutEventsBinder(setVersionName, openPolicyPrivacy, openProcessingPersonalData) } }</code> </pre> <br><p>  Biarkan saya mengingatkan Anda bahwa: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action</code> </pre> <br><p>  Oke, mari kita lanjutkan. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder</code> </pre> <br><p>  Mari kita lihat AboutEventsBinder lebih terinci. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEventsBinder</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData: ActionOnEvent) : BaseEventsBinder&lt;AboutEvents&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AboutEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.merge( setVersionName(events.bindEvent), openPolicyPrivacy(events.openPolicyPrivacyEvent), openProcessingPersonalData(events.openProcessingPersDataEvent)) } }</code> </pre> <br><p>  ActionOnEvent adalah typealias lain, agar tidak menulis setiap waktu. </p><br><pre> <code class="kotlin hljs">ActionCreator&lt;Observable&lt;*&gt;&gt;</code> </pre> <br><p>  Di AboutEventsBinder, kami melewati ActionCreators dan, memohonnya, mengikat ke acara tertentu.  Tetapi untuk memahami bagaimana semua ini terhubung, mari kita lihat kelas dasar - BaseEventsBinder. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread() ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(events).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  Kita melihat metode bindInternal yang kita kenal, yang kita definisikan ulang sebagai penerusnya.  Sekarang pertimbangkan metode bind.  Semua keajaiban ada di sini.  Kami menerima pewaris antarmuka BaseEvents, meneruskannya ke bindInternal untuk menghubungkan Acara dan Tindakan.  Begitu kami mengatakan bahwa apa pun yang datang, kami mengeksekusi di ui-stream dan berlangganan.  Kami juga melihat peretasan yang menarik - takeUntil. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEvents</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable }</code> </pre> <br><p>  Setelah mendefinisikan bidang unbindEvent di BaseEvents untuk mengontrol berhenti berlangganan, kita harus mengimplementasikannya di semua ahli waris.  Bidang luar biasa ini memungkinkan Anda untuk berhenti berlangganan secara otomatis segera setelah acara ini selesai.  Bagus sekali!  Sekarang Anda tidak bisa mengikuti dan tidak khawatir tentang siklus hidup dan tidur dengan tenang. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, policyPrivacyUrl) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, personalDataUrl)</code> </pre> <br><p>  Kembali ke komponen.  Dan di sini Anda sudah dapat melihat metode penggunaan kembali.  Kami menulis satu kelas yang dapat membuka layar tampilan pdf, dan tidak masalah bagi kami apa urlnya.  Tidak ada duplikasi kode. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenPdfActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pdfUrl: String) : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { openPdfAction(pdfUrl to pdfUrl.substringAfterLast(FILE_NAME_DELIMITER)) } } }</code> </pre> <br><p>  Kode ActionCreator juga sesederhana mungkin, di sini kita hanya melakukan beberapa manipulasi string. </p><br><p>  Mari kita kembali ke komponen dan pertimbangkan ActionCreator berikut: </p><br><pre> <code class="kotlin hljs">setVersionName.toSimpleActionCreator(moreComponent::currentVersionName)</code> </pre> <br><p>  Suatu kali kami menjadi terlalu malas untuk menulis ActionCreators yang sama dan inheren sederhana.  Kami menggunakan kekuatan Kotlin dan menulis ekstensi'y.  Misalnya, dalam hal ini, kami hanya perlu memberikan string statis ke ActionMapper. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function"> ActionMapper</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSimpleActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( mapper: ()</span></span></span></span> -&gt; R): ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observable</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toSimpleActionCreator</span></span>(mapper()) } } } }</code> </pre> <br><p>  Ada saat-saat ketika kita tidak perlu mengirimkan apa pun, tetapi hanya memanggil beberapa Tindakan - misalnya, untuk membuka layar berikut: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Action.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toActionCreator</span></span> } } } }</code> </pre> <br><p>  Jadi, dengan komponen selesai, kembali ke fragmen: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.throttleFirstClicks(), openProcessingPersDataEvent = personalDataProtection.throttleFirstClicks(), unbindEvent = unBindEvent)</code> </pre> <br><p>  Di sini kita melihat pembuatan kelas yang bertanggung jawab untuk menerima acara dari pengguna.  Dan unbind dan bind hanya menyaring peristiwa siklus hidup yang kami ambil menggunakan perpustakaan Navi Trello. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;T&gt; NaviComponent.observe(event: Event&lt;T&gt;): Observable&lt;T&gt; = RxNavi.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this, event)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unBindEvent: Observable&lt;*&gt; = observe(Event.DESTROY_VIEW) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: Observable&lt;*&gt; = Observable.just(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)  <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent = observe(Event.POST_CREATE)</code> </pre> <br><p>  Antarmuka Acara menggambarkan peristiwa layar tertentu, plus itu harus mewarisi BaseEvents.  Berikut ini selalu merupakan implementasi dari antarmuka.  Dalam hal ini, peristiwa-peristiwa tersebut ternyata merupakan satu-satu dengan yang datang dari layar, tetapi Anda harus menyimpan dua acara secara bersamaan. </p><br><p>  Misalnya, peristiwa pemuatan layar saat membuka dan memuat ulang jika terjadi kesalahan harus digabungkan menjadi satu - hanya memuat layar. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseEvents { val bindEvent: EventObservable val openPolicyPrivacyEvent: EventObservable val openProcessingPersDataEvent: EventObservable } class AboutEventsImpl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacyEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersDataEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable) : AboutEvents</code> </pre> <br><p>  Kami kembali ke fragmen dan menggabungkan semuanya!  Kami meminta komponen untuk membuat dan mengembalikan binder kepada kami, lalu kami memanggil metode bind di atasnya, di mana kami melewati objek yang menonton acara layar. </p><br><pre> <code class="kotlin hljs">component.binder().bind(events)</code> </pre> <br><p>  Kami telah menulis proyek tentang arsitektur ini selama sekitar dua tahun sekarang.  Dan tidak ada batasan untuk kebahagiaan manajer dalam kecepatan berbagi fitur!  Mereka tidak punya waktu untuk membuat yang baru, karena kita sudah menyelesaikan yang lama.  Arsitekturnya sangat fleksibel dan memungkinkan Anda menggunakan kembali banyak kode. <br>  Kerugian dari arsitektur ini bisa disebut non-konservasi negara.  Kami tidak memiliki keseluruhan model yang menggambarkan keadaan layar, seperti pada MVI, tetapi kami dapat mengatasinya.  Seperti - lihat di bawah. </p><br><h2 id="glava-4-bonus">  <strong>Bab 4. Bonus</strong> </h2><br><p>  Saya pikir semua orang tahu masalah analitik: tidak ada yang suka menulisnya, karena ia merayapi semua lapisan dan menghilangkan tantangan.  Beberapa waktu lalu, dan kami harus menghadapinya.  Namun berkat arsitektur kami, implementasi yang sangat indah diperoleh. </p><br><p>  Jadi, apa ide saya: analytics biasanya memberikan respons terhadap tindakan pengguna.  Dan kami hanya memiliki kelas yang mengakumulasi tindakan pengguna.  Ok, mari kita mulai. </p><br><p>  <strong>Langkah 1</strong>  Kami sedikit mengubah kelas dasar BaseEventsBinder dengan membungkus peristiwa di trackAnalytics: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> trackAnalytics: TrackAnalytics&lt;EVENTS&gt; = EmptyAnalyticsTracker(), <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread()) { <span class="hljs-meta"><span class="hljs-meta">@SuppressLint(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CheckResult"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(trackAnalytics(events)).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  <strong>Langkah 2</strong>  Kami membuat implementasi yang stabil dari variabel trackAnalytics untuk menjaga kompatibilitas ke belakang dan tidak mematahkan ahli waris yang belum membutuhkan analitik: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyAnalyticsTracker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS = events }</code> </pre> <br><p>  <strong>Langkah 3</strong>  Kami menulis implementasi antarmuka TrackAnalytics untuk layar yang diinginkan - misalnya, untuk layar daftar proyek: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackProjectsEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ProjectsEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ProjectsEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ProjectsEvents { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ProjectsEvents <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> events { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boardClickEvent = events.boardClickEvent.trackTypedEvent { allProjectsProjectClick(it.title) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoardCreationEvent = events.openBoardCreationEvent.trackEvent { allProjectsAddProjectClick() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardsSearchEvent = events.openCardsSearchEvent.trackEvent { allProjectsSearchBarClick() } } } }</code> </pre> <br><p>  Di sini kita kembali menggunakan kekuatan Kotlin dalam bentuk delegasi.  Kami sudah memiliki pewaris antarmuka yang dibuat oleh kami - dalam hal ini ProjectsEvents.  Tetapi untuk beberapa acara, Anda perlu mendefinisikan kembali bagaimana acara berjalan dan menambahkan ikatan di sekitarnya dengan mengirim analitik.  Faktanya, trackEvent hanya doOnNext: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec) } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackTypedEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec, it) }</code> </pre> <br><p>  <strong>Langkah 4</strong>  Masih mentransfer ini ke Binder.  Karena kami membangunnya dalam komponen, kami memiliki kesempatan, jika Anda tiba-tiba perlu, untuk menambahkan dependensi tambahan ke konstruktor.  Sekarang konstruktor ProjectsEventsBinder akan terlihat seperti ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectsEventsBinder</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loadItems: LoadItemsActionCreator, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshBoards: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoard: ActionCreator&lt;Observable&lt;BoardId&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openScreen: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardSearch: ActionOnEvent, trackAnalytics: TrackAnalytics&lt;ProjectsEvents&gt;) : BaseEventsBinder&lt;ProjectsEvents&gt;(trackAnalytics)</code> </pre> <br><p>  Anda dapat melihat contoh lain di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>GitHub</strong></a> . </p><br><h2 id="voprosy-i-otvety">  <strong>Tanya Jawab</strong> </h2><br><div class="spoiler">  <b class="spoiler_title">Bagaimana Anda menjaga status layar?</b> <div class="spoiler_text"><p>  Tidak mungkin.  Kami memblokir orientasi.  Tetapi kami juga menggunakan argumen / maksud dan menyimpan variabel OPENED_FROM_BACKSTACK di sana.  Dan ketika merancang Binder, kami melihatnya.  Jika salah memuat data dari jaringan.  Jika benar - dari cache.  Ini memungkinkan Anda untuk dengan cepat membuat ulang layar. </p><br><p>  Untuk semua orang yang menentang pemblokiran orientasi: cobalah untuk menguji dan menyimpan analitik pada seberapa sering pengguna Anda membalikkan ponsel dan berapa banyak yang berada dalam orientasi yang berbeda.  Hasilnya mungkin mengejutkan. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Saya tidak ingin menulis komponen, bagaimana saya bisa berteman dengan belati?</b> <div class="spoiler_text"><p>  Saya tidak menyarankan, tetapi jika Anda tidak keberatan menyusun waktu, Anda dapat membuat Komponen melalui belati juga.  Tetapi kami tidak mencoba. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Saya tidak menulis di kotlin, apa kesulitan dengan implementasi di Jawa?</b> <div class="spoiler_text"><p>  Semua sama bisa ditulis di Jawa, hanya saja tidak akan terlihat begitu indah. </p></div></div><br><p>  Jika Anda menyukai artikel ini, bagian selanjutnya adalah tentang cara menulis tes pada arsitektur seperti itu (maka akan menjadi jelas mengapa ada begitu banyak antarmuka).  Spoiler - menulis itu mudah dan Anda dapat menulis di semua lapisan kecuali komponennya, tetapi Anda tidak perlu mengujinya, itu hanya membuat objek pengikat. </p><br><p>  Terima kasih kepada rekan-rekan dari tim pengembangan ponsel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tinkoff Business</a> untuk bantuan mereka menulis artikel ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474612/">https://habr.com/ru/post/id474612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474596/index.html">Aplikasi pada TSD dan komunikasi dengan 1C: Enterprise 8.3 melalui HTTP-Service. Bagian 5 (Menu, objek pengiring)</a></li>
<li><a href="../id474598/index.html">Cara mendapatkan wawancara dengan insinyur QA tanpa pengalaman kerja</a></li>
<li><a href="../id474602/index.html">Memecahkan persamaan regresi linier sederhana</a></li>
<li><a href="../id474606/index.html">Cara Kerja Blogspam</a></li>
<li><a href="../id474610/index.html">Sistem Media Berbasis NUC - Pengalaman Rumah</a></li>
<li><a href="../id474618/index.html">Membuat konfigurator 3D untuk WooCommerce</a></li>
<li><a href="../id474620/index.html">Keamanan Informasi Pusat Data</a></li>
<li><a href="../id474622/index.html">34 pustaka Python open source (2019)</a></li>
<li><a href="../id474626/index.html">Google Analytics dan terminologi Yandex.Metrica: bagaimana tidak bingung dalam semua data ini</a></li>
<li><a href="../id474628/index.html">Memperkenalkan Microsoft Edge dan Bing Baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>