<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèº üíµ üíÆ El juego Snake para FPGA Cyclone IV (con joystick VGA y SPI) üïπÔ∏è üöç ‚õΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 


 ¬øRecuerdas el juego de la serpiente de la infancia, donde una serpiente corre en la pantalla tratando de comer una manzana? Este art√≠...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El juego Snake para FPGA Cyclone IV (con joystick VGA y SPI)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431226/"><h2 id="introduction">  Introduccion </h2><br><p>  ¬øRecuerdas el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">juego</a> de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">serpiente</a> de la infancia, donde una serpiente corre en la pantalla tratando de comer una manzana?  Este art√≠culo describe nuestra implementaci√≥n del juego en un FPGA <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1</a></sup> . </p><br><p><img src="https://github.com/Sitiritis/SnakeGame_FPGA/blob/master/text/img/gameplay.gif?raw=true" alt="Gameplay.gif"><br>  <strong>Figura 1.</strong> Jugabilidad </p><a name="habracut"></a><br><p>  Primero, perm√≠tanos presentarnos y explicar la raz√≥n por la que hemos trabajado en el proyecto.  Somos 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tymur Lysenko</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Daniil Manakovskiy</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sergey Makarov</a> .  Como estudiantes de primer a√±o de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Universidad</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Innopolis</a> , tuvimos un curso de "Arquitectura de Computadores", que se ense√±a profesionalmente y permite al alumno comprender la estructura de bajo nivel de una computadora.  En alg√∫n momento durante el curso, los instructores nos brindaron la oportunidad de desarrollar un proyecto para un FPGA para puntos adicionales en el curso.  Nuestra motivaci√≥n no ha sido solo la calificaci√≥n, sino nuestro inter√©s por obtener m√°s experiencia en el dise√±o de hardware, compartir los resultados y, finalmente, tener un juego agradable. </p><br><p>  Ahora, entremos en detalles oscuros y profundos. </p><br><h2 id="project-overview">  Resumen del proyecto </h2><br><p>  Para nuestro proyecto, seleccionamos un juego f√°cil de implementar y divertido, a saber, la "Serpiente".  La estructura de la implementaci√≥n es la siguiente: en primer lugar, se toma una entrada de un joystick SPI, luego se procesa y, finalmente, se env√≠a una imagen a un monitor VGA y se muestra una puntuaci√≥n en una pantalla de 7 segmentos (en hexadecimal).  Aunque la l√≥gica del juego es intuitiva y directa, VGA y el joystick han sido desaf√≠os interesantes y su implementaci√≥n ha llevado a una buena experiencia de juego. </p><br><p>  El juego tiene las siguientes reglas.  Un jugador comienza con una sola cabeza de serpiente.  El objetivo es comer manzanas, que se generan aleatoriamente en la pantalla despu√©s de comer la anterior.  Adem√°s, la serpiente se extiende 1 cola despu√©s de satisfacer el hambre.  Las colas se mueven una tras otra, siguiendo la cabeza.  La serpiente siempre se est√° moviendo.  Si se alcanzan los bordes de la pantalla, la serpiente se est√° transfiriendo a otro lado de la pantalla.  Si la cabeza golpea la cola, el juego termina. </p><br><h2 id="tools-used">  Herramientas utilizadas </h2><br><ul><li>  Altera Cyclone IV (EP4CE6E22C8N) con 6272 elementos l√≥gicos, reloj integrado de 50 MHz, VGA a color de 3 bits, pantalla de 8 d√≠gitos y 7 segmentos.  El FPGA no puede llevar una entrada anal√≥gica a sus pines. </li><li>  Joystick SPI (KY-023) </li><li>  Un monitor VGA que admite una frecuencia de actualizaci√≥n de 60 Hz </li><li>  Quartus Prime Lite Edition 18.0.0 Build 614 </li><li>  Verilog HDL IEEE 1364-2001 </li><li>  Tablero de pan </li><li>  Elementos electricos: <br><ul><li>  8 conectores macho-hembra </li><li>  1 conector hembra-hembra </li><li>  1 conector macho-macho </li><li>  4 resistencias (4.7 KŒ©) </li></ul></li></ul><br><h2 id="architecture-overview">  Resumen de arquitectura </h2><br><p>  La arquitectura del proyecto es un factor importante a tener en cuenta.  La Figura 2 muestra esta arquitectura desde el punto de vista del nivel superior: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c92/2a4/4b2/c922a44b20cdc085b7061e7b5c5f8cd4.png" alt="Design.png"><br>  <strong>Figura 2.</strong> Vista de nivel superior del dise√±o ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pdf</a> ) </p><br><p>  Como puede ver, hay muchas entradas, salidas y algunos m√≥dulos.  Esta secci√≥n describir√° lo que significa cada elemento y especificar√° qu√© pines se utilizan en la placa para los puertos. </p><br><h3 id="main-inputs">  Entradas principales </h3><br><p>  Las entradas principales necesarias para la implementaci√≥n son <em>res_x_one</em> , <em>res_x_two</em> , <em>res_y_one</em> , <em>res_y_two</em> , que se utilizan para recibir la direcci√≥n actual de un joystick.  La Figura 3 muestra el mapeo entre sus valores y las direcciones. </p><br><table><thead><tr><th>  De entrada </th><th>  Izquierda </th><th>  Derecho </th><th>  Arriba </th><th>  Abajo </th><th>  Sin cambio de direcci√≥n </th></tr></thead><tbody><tr><td>  res_x_one (PIN_30) </td><td>  1 </td><td>  0 0 </td><td>  x </td><td>  x </td><td>  1 </td></tr><tr><td>  res_x_two (PIN_52) </td><td>  1 </td><td>  0 0 </td><td>  x </td><td>  x </td><td>  0 0 </td></tr><tr><td>  res_y_one (PIN_39) </td><td>  x </td><td>  x </td><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  res_y_two (PIN_44) </td><td>  x </td><td>  x </td><td>  1 </td><td>  0 0 </td><td>  0 0 </td></tr></tbody></table><br><p>  <strong>Figura 3.</strong> Mapeo de entradas de joystick y direcciones </p><br><h3 id="other-inputs">  Otras entradas </h3><br><ul><li>  <em>clk</em> - el reloj del tablero (PIN_23) </li><li>  <em>restablecer</em> : se√±al para restablecer el juego y detener la impresi√≥n (PIN_58) </li><li>  <em>color</em> : cuando 1, todos los colores posibles se muestran en la pantalla y se usan solo con fines de demostraci√≥n (PIN_68) </li></ul><br><h3 id="main-modules">  M√≥dulos principales </h3><br><h4 id="joystick_input">  joystick_input </h4><br><p>  <em>joystick_input</em> se usa para producir un c√≥digo de direcci√≥n basado en una entrada del joystick. </p><br><h4 id="game_logic">  game_logic </h4><br><p>  <em>game_logic</em> contiene toda la l√≥gica necesaria para jugar un juego.  El m√≥dulo mueve una serpiente en una direcci√≥n dada.  Adem√°s, es responsable de comer manzanas y detectar colisiones.  Adem√°s, recibe las coordenadas xey actuales de un p√≠xel en la pantalla y devuelve una entidad colocada en la posici√≥n. </p><br><h4 id="vga_draw">  VGA_Draw </h4><br><p>  El caj√≥n establece un color de un p√≠xel a un valor particular basado en la posici√≥n actual ( <em>iVGA_X, iVGA_Y</em> ) y la entidad actual ( <em>ent</em> ). </p><br><h4 id="vga_ctrl">  VGA_Ctrl </h4><br><p>  Genera un flujo de bits de control para salida VGA ( <em>V_Sync, H_Sync, R, G, B</em> ). </p><br><h4 id="sseg_displaysup22sup">  SSEG_Display <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a></sup> </h4><br><p>  <em>SSEG_Display</em> es un controlador para generar la puntuaci√≥n actual en la pantalla de 7 segmentos. </p><br><h4 id="vga_clk">  Vga_clk </h4><br><p>  <em>VGA_clk</em> recibe un reloj de 50MHz y lo reduce a 25.175 MHz. </p><br><h4 id="game_upd_clk">  game_upd_clk </h4><br><p>  <em>game_upd_clk</em> es un m√≥dulo que genera un reloj especial que activa una actualizaci√≥n del estado del juego. </p><br><h3 id="outputs">  Salidas </h3><br><ul><li>  <em>VGA_B</em> - Pin azul VGA (PIN_144) </li><li>  <em>VGA_G</em> - Pin verde VGA (PIN_1) </li><li>  <em>VGA_R</em> - Pin rojo VGA (PIN_2) </li><li>  <em>VGA_HS</em> - Sincronizaci√≥n horizontal VGA (PIN_142) </li><li>  <em>VGA_VS</em> - Sincronizaci√≥n vertical VGA (PIN_143) </li><li>  <em>sseg_a_to_dp</em> : especifica cu√°l de los 8 segmentos se encender√° (PIN_115, PIN_119, PIN_120, PIN_121, PIN_124, PIN_125, PIN_126, PIN_127) </li><li>  <em>sseg_an</em> : especifica cu√°l de las 4 pantallas de 7 segmentos se utilizar√° (PIN_128, PIN_129, PIN_132, PIN_133) </li></ul><br><h2 id="implementation">  Implementaci√≥n </h2><br><h3 id="input-with-spi-joystick">  Entrada con joystick SPI </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e3f/4ab/fc4/e3f4abfc45c5a87151db34738e9c3a92.jpg" alt="stick.jpg"></p><br><p>  <strong>Figura 4.</strong> Joystick SPI (KY-023) </p><br><p>  Mientras implementamos un m√≥dulo de entrada, descubrimos que el dispositivo produce una se√±al anal√≥gica.  El joystick tiene 3 posiciones para cada eje: </p><br><ul><li>  arriba - ~ 5V de salida </li><li>  salida media - ~ 2.5V </li><li>  bajo - ~ 0V de salida </li></ul><br><p> La entrada es muy similar al sistema ternario: para el eje X, tenemos <code>true</code> (izquierda), <code>false</code> (derecha) y un estado <code>undetermined</code> , donde el joystick no est√° ni a la izquierda ni a la derecha.  El problema es que la placa FPGA solo puede procesar una entrada digital.  Por lo tanto, no podemos convertir esta l√≥gica ternaria a binaria simplemente escribiendo alg√∫n c√≥digo.  La primera soluci√≥n sugerida fue encontrar un convertidor anal√≥gico-digital, pero luego decidimos usar nuestro conocimiento escolar de f√≠sica e implementar el divisor de voltaje <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">3</a></sup> .  Para definir los tres estados, necesitaremos dos bits: 00 es <code>false</code> , 01 <code>undefined</code> est√° <code>undefined</code> y 11 es <code>true</code> .  Despu√©s de algunas mediciones, descubrimos que en nuestro tablero, el l√≠mite entre cero y uno es de aproximadamente 1.7V.  Por lo tanto, creamos el siguiente esquema (imagen creada usando circuitlab <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4</a></sup> ): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/009/36c/a43/00936ca435f219d64f7078bec64e9b8c.png" alt="Stick_connection.png"></p><br><p>  <strong>Figura 5.</strong> Circuito para ADC para joystick </p><br><p>  La implementaci√≥n f√≠sica se construye utilizando los elementos del kit Arduino y tiene el siguiente aspecto: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3eb/34b/c9e/3eb34bc9e0210b8f336a7fd8ba89f1a9.jpg" alt="stick_imp"></p><br><p>  <strong>Figura 6.</strong> Implementaci√≥n de ADC </p><br><p>  Nuestro circuito toma una entrada para cada eje y produce dos salidas: la primera proviene directamente del stick y se convierte en cero solo si el joystick sale a <code>zero</code> .  El segundo es 0 en estado <code>undetermined</code> , pero a√∫n 1 en <code>true</code> .  Este es el resultado exacto que esper√°bamos. </p><br><p>  La l√≥gica del m√≥dulo de entrada es: </p><br><ol><li>  Traducimos nuestra l√≥gica ternaria a cables binarios simples para cada direcci√≥n; </li><li>  En cada ciclo de reloj, verificamos si solo una direcci√≥n es <code>true</code> (la serpiente no puede ir en diagonal); </li><li>  Comparamos nuestra nueva direcci√≥n con la anterior para evitar que la serpiente se coma al no permitir que el jugador cambie la direcci√≥n a la opuesta. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Una parte del c√≥digo del m√≥dulo de entrada</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">reg left, right, up, down; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `TOP_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> //<span class="hljs-number"><span class="hljs-number">1</span></span> left = two_resistors_x; right = ~one_resistor_x; up = two_resistors_y; down = ~one_resistor_y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left + right + up + down == <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b001</span></span>) //<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (left &amp;&amp; (direction != `RIGHT_DIR)) //<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> direction = `LEFT_DIR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> //same code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> other directions <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-vga">  Salida a VGA </h3><br><p>  Decidimos hacer una salida con una resoluci√≥n de 640x480 en una pantalla de 60Hz que funciona a 60 FPS. </p><br><p>  El m√≥dulo VGA consta de 2 partes principales: un <strong>controlador</strong> y un <strong>caj√≥n</strong> .  El controlador genera un flujo de bits que consta de se√±ales de sincronizaci√≥n verticales y horizontales y un color que se otorga a las salidas VGA.  Un art√≠culo <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">5</a></sup> escrito por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@SlavikMIPT</a> describe los principios b√°sicos de trabajar con VGA.  Hemos adaptado el controlador del art√≠culo a nuestra placa. </p><br><p>  Decidimos dividir la pantalla en una cuadr√≠cula de elementos de 40x30, que consta de cuadrados de 16x16 p√≠xeles.  Cada elemento representa 1 entidad del juego: una manzana, la cabeza de una serpiente, una cola o nada. </p><br><p>  El siguiente paso en nuestra implementaci√≥n fue crear sprites para las entidades. </p><br><p>  El cicl√≥n IV tiene solo 3 bits para representar un color en VGA (1 para rojo, 1 para verde y 1 para azul).  Debido a dicha limitaci√≥n, necesit√°bamos implementar un convertidor para adaptar los colores de las im√°genes a las disponibles.  Para ese prop√≥sito, creamos un script de Python que divide un valor RGB de cada p√≠xel por 128. </p><br><div class="spoiler">  <b class="spoiler_title">El script de python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageDraw filename = <span class="hljs-string"><span class="hljs-string">"snake_head"</span></span> index = <span class="hljs-number"><span class="hljs-number">1</span></span> im = Image.open(filename + <span class="hljs-string"><span class="hljs-string">".png"</span></span>) n = Image.new(<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)) d = ImageDraw.Draw(n) pix = im.load() size = im.size data = [] code = <span class="hljs-string"><span class="hljs-string">"sp["</span></span> + str(index) + <span class="hljs-string"><span class="hljs-string">"][{i}][{j}] = 3'b{RGB};\\\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"code_"</span></span> + filename + <span class="hljs-string"><span class="hljs-string">".txt"</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">0</span></span>]): tmp = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(size[<span class="hljs-number"><span class="hljs-number">1</span></span>]): clr = im.getpixel((i, j)) vg = <span class="hljs-string"><span class="hljs-string">"{0}{1}{2}"</span></span>.format(int(clr[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-number"><span class="hljs-number">128</span></span>), <span class="hljs-comment"><span class="hljs-comment"># an array representation for pixel int(clr[1] / 128), # since clr[*] in range [0, 255], int(clr[2] / 128)) # clr[*]/128 is either 0 or 1 tmp.append(vg) f.write(code.format(i=i, j=j, RGB=vg)) # Verilog code to initialization d.point((i, j), tuple([int(vg[0]) * 255, int(vg[1]) * 255, int(vg[2]) * 255])) # Visualize final image data.append(tmp) n.save(filename + "_3bit.png") for el in data: print(" ".join(el))</span></span></code> </pre></div></div><br><table><tbody><tr><td align="center">  Original </td><td align="center">  Despu√©s del gui√≥n </td></tr><tr><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/720/34d/b40/72034db4092a25711654562bc4523661.png" width="128" height="128"><br></td><td align="center" width="150"><img src="https://habrastorage.org/getpro/habr/post_images/529/254/02e/52925402e158986901bc6278d7d0bb28.png" width="128" height="128"><br></td></tr></tbody></table><br><p>  <strong>Figura 7.</strong> Comparaci√≥n entre entrada y salida </p><br><p>  El objetivo principal del caj√≥n es enviar un color de un p√≠xel a VGA en funci√≥n de la posici√≥n actual ( <em>iVGA_X, iVGA_Y</em> ) y la entidad actual ( <em>ent</em> ).  Todos los sprites est√°n codificados pero pueden cambiarse f√°cilmente generando un nuevo c√≥digo usando el script anterior. </p><br><div class="spoiler">  <b class="spoiler_title">L√≥gica del caj√≥n</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">always @(posedge iVGA_CLK <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // DRAW CURRENT STATE <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ent == `ENT_NOTHING) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> oRed &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oGreen &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; oBlue &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // Drawing a particular pixel from sprite oRed &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">0</span></span>]; oGreen &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">1</span></span>]; oBlue &lt;= sp[ent][iVGA_X % `H_SQUARE][iVGA_Y % `V_SQUARE][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><h3 id="output-to-the-7-segment-display">  Salida a la pantalla de 7 segmentos </h3><br><p>  Con el fin de permitir que el jugador vea su puntaje, decidimos enviar un puntaje de juego a la pantalla de 7 segmentos.  Debido a la escasez de tiempo, utilizamos el c√≥digo de la Documentaci√≥n de la placa de inicio EP4CE6 <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2</a></sup> .  Este m√≥dulo emite un n√∫mero hexadecimal a la pantalla. </p><br><h3 id="game-logic">  L√≥gica del juego </h3><br><p>  Durante el desarrollo, probamos varios enfoques, sin embargo, terminamos con el que requiere una cantidad m√≠nima de memoria, es f√°cil de implementar en hardware y puede beneficiarse de los c√°lculos paralelos. </p><br><p>  El m√≥dulo realiza varias funciones.  A medida que VGA dibuja un p√≠xel en cada ciclo de reloj, comenzando desde el superior izquierdo hacia el inferior derecho, el m√≥dulo VGA_Draw, que es responsable de producir un color para un p√≠xel, necesita identificar qu√© color usar para las coordenadas actuales.  Eso es lo que deber√≠a generar el m√≥dulo l√≥gico del juego: un c√≥digo de entidad para las coordenadas dadas. <br>  Adem√°s, tiene que actualizar el estado del juego solo despu√©s de que se dibuja la pantalla completa.  Una se√±al producida por el m√≥dulo <em>game_upd_clk</em> se usa para determinar cu√°ndo actualizar. </p><br><h4 id="game-state">  Estado del juego </h4><br><p>  El estado del juego consiste en: </p><br><ul><li>  Coordenadas de la cabeza de la serpiente. </li><li>  Un conjunto de coordenadas de la cola de la serpiente.  La matriz est√° limitada por 128 elementos en nuestra implementaci√≥n </li><li>  N√∫mero de colas </li><li>  Coordenadas de una manzana </li><li>  Juego sobre bandera </li><li>  Juego gan√≥ bandera </li></ul><br><p>  La actualizaci√≥n del estado del juego incluye varias etapas: </p><br><ol><li>  Mueva la cabeza de la serpiente a nuevas coordenadas, en funci√≥n de una direcci√≥n determinada.  Si resulta que una coordenada est√° en su borde y necesita ser cambiada a√∫n m√°s, entonces la cabeza tiene que saltar a otro borde de la pantalla.  Por ejemplo, una direcci√≥n se establece a la izquierda y la coordenada X actual es 0. Por lo tanto, la nueva coordenada X deber√≠a ser igual a la √∫ltima direcci√≥n horizontal. </li><li>  Las nuevas coordenadas de la cabeza de la serpiente se prueban contra las coordenadas de la manzana: <br>  2.1.  En caso de que sean iguales y la matriz no est√© llena, agregue una nueva cola a la matriz e incremente el contador de cola.  Cuando el contador alcanza su valor m√°s alto (128 en nuestro caso), se est√° configurando la bandera de juego ganado y eso significa que esa serpiente ya no puede crecer, y el juego a√∫n contin√∫a.  La nueva cola se coloca en las coordenadas anteriores de la cabeza de la serpiente.  Deben tomarse coordenadas aleatorias para X e Y para colocar una manzana all√≠. <br>  2.2.  En caso de que no sean iguales, cambie secuencialmente las coordenadas de las colas adyacentes.  (n + 1) -th tail debe recibir coordenadas de n-th, en caso de que la en√©sima cola se haya agregado antes de (n + 1) -th.  La primera cola recibe viejas coordenadas de la cabeza. </li><li>  Comprueba si las nuevas coordenadas de la cabeza de la serpiente coinciden con las coordenadas de cualquier cola.  Si ese es el caso, el juego sobre la bandera se levanta y el juego se detiene. </li></ol><br><h4 id="random-coordinate-generation">  Generaci√≥n de coordenadas aleatorias </h4><br><p>  N√∫meros aleatorios producidos al tomar bits aleatorios generados por <em>registros de desplazamiento de cambio de retroalimentaci√≥n lineal de</em> 6 bits <em>(LFSR)</em> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">6</a></sup> .  Para ajustar los n√∫meros en una pantalla, se dividen por las dimensiones de la cuadr√≠cula del juego y se toma el resto. </p><br><h2 id="conclusion">  Conclusi√≥n </h2><br><p>  Despu√©s de 8 semanas de trabajo, el proyecto se implement√≥ con √©xito.  Hemos tenido algo de experiencia en el desarrollo de juegos y terminamos con una versi√≥n agradable del juego "Snake" para un FPGA.  El juego es jugable y nuestras habilidades en programaci√≥n, dise√±o de arquitectura y habilidades blandas han mejorado. </p><br><h2 id="acknowledgments">  Segmentos reconocidos </h2><br><p>  Nos gustar√≠a expresar nuestro especial agradecimiento y gratitud a nuestros profesores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Muhammad Fahim</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexander Tormasov</a> por darnos el profundo conocimiento y la oportunidad de ponerlo en pr√°ctica.  Agradecemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sinceramente a Vladislav Ostankovich</a> por proporcionarnos el hardware esencial utilizado en el proyecto y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Temur Kholmatov</a> por ayudarnos con la depuraci√≥n.  No nos olvidar√≠amos de recordar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Anastassiya Boiko</a> dibujando hermosos sprites para el juego.  Adem√°s, nos gustar√≠a extender nuestras sinceras estimaciones a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rabab Marouf</a> por la revisi√≥n y edici√≥n de este art√≠culo. </p><br><p>  Gracias a todos los que nos ayudaron a probar el juego y trataron de establecer un r√©cord.  ¬°Espero que disfrutes jugando! </p><br><h2 id="references">  Referencias </h2><br><p>  [1]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecto en el Github</a> <br>  [2]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">[FPGA] Documentaci√≥n de la placa de inicio EP4CE6</a> <br>  [3]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">divisor de voltaje</a> <br>  [4]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta para modelar circuitos</a> <br>  [5]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Adaptador VGA para FPGA Altera Cyclone III</a> <br>  [6]: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Registro de desplazamiento de retroalimentaci√≥n lineal (LFSR) en Wikipedia</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LFSR en un FPGA - C√≥digo VHDL y Verilog</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una textura de manzana</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Idea para generar n√∫meros aleatorios</a> <br>  Palnitkar, S. (2003).  <em>Verilog HDL: una gu√≠a de dise√±o y s√≠ntesis digital, segunda edici√≥n.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431226/">https://habr.com/ru/post/es431226/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431212/index.html">Paginaci√≥n de almacenamiento en cach√© en Android</a></li>
<li><a href="../es431216/index.html">Revisi√≥n del tel√©fono Snom D345 IP</a></li>
<li><a href="../es431218/index.html">C√≥mo hice un juego de c√≥mics de Lovecraft</a></li>
<li><a href="../es431220/index.html">La mirada de un bi√≥logo a las ra√≠ces de nuestro envejecimiento.</a></li>
<li><a href="../es431222/index.html">Archivo de sitios web</a></li>
<li><a href="../es431228/index.html">Obst√°culo para la luz: cristales l√≠quidos para ayudar</a></li>
<li><a href="../es431230/index.html">Almacenamiento para infraestructura HPC, o c√≥mo recolectamos 65 PB de almacenamiento en el Centro de Investigaci√≥n RIKEN Jap√≥n</a></li>
<li><a href="../es431232/index.html">Generamos marcadores de posici√≥n SVG hermosos en Node.js</a></li>
<li><a href="../es431234/index.html">11 de diciembre, Mosc√∫ - Alfa JS MeetUp</a></li>
<li><a href="../es431236/index.html">C√≥mo escribir en Objective-C en 2018. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>