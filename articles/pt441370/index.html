<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè≠ üàπ ‚ô†Ô∏è Prote√ß√£o sem medo. Seguran√ßa da rosca na ferrugem üéä ü§≥üèª üë®üèª‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a segunda parte da s√©rie de artigos da Fearless Protection. No primeiro, falamos sobre seguran√ßa de mem√≥ria 

 Os aplicativos modernos s√£o mult...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prote√ß√£o sem medo. Seguran√ßa da rosca na ferrugem</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441370/">  <font color="gray"><i>Esta √© a segunda parte da s√©rie de artigos da Fearless Protection.</i></font>  <font color="gray"><i>No primeiro, falamos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seguran√ßa de mem√≥ria</a></i></font> <br><br>  Os aplicativos modernos s√£o multithread: em vez de executar tarefas sequencialmente, o programa usa threads para executar simultaneamente v√°rias tarefas.  Todos n√≥s observamos <i>trabalho simult√¢neo</i> e <i>simultaneidade</i> todos os dias: <br><br><ul><li>  Os sites atendem a v√°rios usu√°rios ao mesmo tempo. <br></li><li> A interface do usu√°rio faz um trabalho em segundo plano que n√£o incomoda o usu√°rio (imagine que toda vez que voc√™ digita um caractere, o aplicativo congela para verificar a ortografia). <br></li><li>  Um computador pode executar v√°rios aplicativos ao mesmo tempo. </li></ul><br>  Fluxos paralelos aceleram o trabalho, mas introduzem um conjunto de problemas de sincroniza√ß√£o, como deadlocks e condi√ß√µes de corrida.  Do ponto de vista da seguran√ßa, por que nos preocupamos com a seguran√ßa do encadeamento?  Porque a seguran√ßa da mem√≥ria e dos threads tem o mesmo problema principal: uso inadequado de recursos.  Os ataques aqui t√™m os mesmos efeitos que os ataques de mem√≥ria, incluindo escalonamento de privil√©gios, execu√ß√£o arbitr√°ria de c√≥digo (ACE) e ignorar as verifica√ß√µes de seguran√ßa. <br><a name="habracut"></a><br>  Erros de simultaneidade, como erros de implementa√ß√£o, est√£o intimamente relacionados √† corre√ß√£o do programa.  Embora as vulnerabilidades de mem√≥ria sejam quase sempre perigosas, os erros de implementa√ß√£o / l√≥gica nem sempre indicam um problema de seguran√ßa se n√£o ocorrerem na parte do c√≥digo relacionada √† conformidade com os contratos de seguran√ßa (por exemplo, permiss√£o para ignorar uma verifica√ß√£o de seguran√ßa).  Mas os erros de concorr√™ncia t√™m uma peculiaridade.  Se problemas de seguran√ßa devido a erros l√≥gicos geralmente aparecem ao lado do c√≥digo correspondente, os erros de simultaneidade geralmente ocorrem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em outras fun√ß√µes, e n√£o na onde o erro foi cometido diretamente</a> , o que dificulta o rastreamento e a elimina√ß√£o deles.  Outra dificuldade √© uma certa sobreposi√ß√£o entre o processamento inadequado da mem√≥ria e os erros de concorr√™ncia, que vemos nas corridas de dados. <br><br>  As linguagens de programa√ß√£o desenvolveram v√°rias estrat√©gias de simultaneidade para ajudar os desenvolvedores a gerenciar os problemas de desempenho e seguran√ßa de aplicativos multithread. <br><br><h1>  Problemas de simultaneidade </h1><br>  √â geralmente aceito que a programa√ß√£o paralela √© mais dif√≠cil do que o habitual: nosso c√©rebro est√° melhor adaptado ao racioc√≠nio seq√ºencial.  O c√≥digo paralelo pode ter intera√ß√µes inesperadas e indesejadas entre threads, incluindo deadlocks, conten√ß√£o e corridas de dados. <br><br>  <i>Um conflito</i> ocorre quando v√°rios encadeamentos esperam um ao outro executar determinadas a√ß√µes para continuar funcionando.  Embora esse comportamento indesejado possa causar um ataque de nega√ß√£o de servi√ßo, n√£o causar√° vulnerabilidades como o ACE. <br><br>  <i>Uma condi√ß√£o de corrida</i> √© uma situa√ß√£o em que o tempo ou a ordem das tarefas podem afetar a corre√ß√£o de um programa.  A corrida de dados ocorre quando v√°rios fluxos tentam acessar simultaneamente o mesmo local de mem√≥ria com pelo menos uma tentativa de grava√ß√£o.  Acontece que uma condi√ß√£o de corrida e uma corrida de dados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ocorrem independentemente</a> uma da outra.  Mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">as corridas de dados s√£o sempre perigosas</a> . <br><br><h3>  Consequ√™ncias potenciais de erros de simultaneidade </h3><br><ol><li>  Impasse <br></li><li>  Perda de informa√ß√µes: outro segmento substitui as informa√ß√µes <br></li><li>  Perda de integridade: informa√ß√µes de v√°rios fluxos est√£o entrela√ßadas <br></li><li>  Perda de viabilidade: problemas de desempenho devido ao acesso desigual a recursos compartilhados </li></ol><br>  O tipo mais famoso de ataque de simultaneidade √© chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TOCTOU</a> (tempo de verifica√ß√£o at√© o tempo de uso): em ess√™ncia, o estado de uma corrida √© entre verificar condi√ß√µes (por exemplo, credenciais de seguran√ßa) e usar os resultados.  Um ataque TOCTOU resulta em perda de integridade. <br><br>  Bloqueios m√∫tuos e perda de capacidade de sobreviv√™ncia s√£o considerados problemas de desempenho, n√£o de seguran√ßa, enquanto a perda de informa√ß√µes e a integridade provavelmente est√£o relacionadas √† seguran√ßa.  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo da Red Balloon Security</a> analisa algumas das poss√≠veis explora√ß√µes.  Um exemplo √© a corrup√ß√£o do ponteiro seguida pela escalada de privil√©gios ou pela execu√ß√£o remota de c√≥digo.  Na explora√ß√£o, uma fun√ß√£o que carrega a biblioteca compartilhada ELF (formato execut√°vel e vincul√°vel) inicia corretamente um sem√°foro apenas na primeira chamada e limita incorretamente o n√∫mero de threads, o que causa corrup√ß√£o na mem√≥ria do kernel.  Este ataque √© um exemplo de perda de informa√ß√µes. <br><br>  A parte mais dif√≠cil da programa√ß√£o paralela √© testar e depurar, porque os erros de simultaneidade s√£o dif√≠ceis de reproduzir.  Tempo de eventos, decis√µes do sistema operacional, tr√°fego de rede e outros fatores ... tudo isso muda o comportamento do programa a cada in√≠cio. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/aa1/702/1b2/aa17021b2f9cb3eb726ea37995ed4e2e.png"></a> </div><br>  <i><font color="gray">√Äs vezes, √© realmente mais f√°cil remover o programa inteiro do que procurar um bug.</font></i>  <i><font color="gray"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Heisenbugs</a></font></i> <br><br>  N√£o apenas o comportamento muda cada vez que √© iniciado, mas mesmo operadores de sa√≠da ou depura√ß√£o podem mudar o comportamento, resultando em "bugs de Heisenberg" (erros n√£o determin√≠sticos e dif√≠ceis de reproduzir, t√≠picos da programa√ß√£o paralela) que surgem e desaparecem misteriosamente. <br><br>  A programa√ß√£o paralela √© dif√≠cil.  √â dif√≠cil prever como o c√≥digo paralelo ir√° interagir com outro c√≥digo paralelo.  Quando os erros aparecem, s√£o dif√≠ceis de encontrar e corrigir.  Em vez de confiar nos testadores, vamos ver maneiras de desenvolver programas e o uso de linguagens que facilitam a escrita de c√≥digos paralelos. <br><br>  Primeiro, formulamos o conceito de "seguran√ßa de threads": <br><br><blockquote>  ‚ÄúUm tipo de dado ou m√©todo est√°tico √© considerado seguro para threads se se comportar corretamente quando chamado de v√°rios threads, independentemente de como esses threads s√£o executados, e n√£o requer coordena√ß√£o adicional do c√≥digo de chamada.‚Äù  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MIT</a> </blockquote><br><h1>  Como as linguagens de programa√ß√£o funcionam com paralelismo </h1><br>  Em idiomas sem seguran√ßa de thread est√°tica, os programadores precisam monitorar constantemente a mem√≥ria compartilhada com outro thread e podem mudar a qualquer momento.  Na programa√ß√£o seq√ºencial, somos ensinados a evitar vari√°veis ‚Äã‚Äãglobais se outra parte do c√≥digo as alterar silenciosamente.  √â imposs√≠vel exigir que os programadores garantam uma altera√ß√£o segura nos dados compartilhados, al√©m do gerenciamento manual da mem√≥ria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/3e3/5d2/e3e3e35d2775715a1f337d7c58aad7f7.gif"></div><br>  <i><font color="gray">"Vigil√¢ncia constante!"</font></i> <br><br>  Normalmente, as linguagens de programa√ß√£o s√£o limitadas a duas abordagens: <br><br><ol><li>  Limita√ß√£o de mutabilidade ou restri√ß√£o de acesso compartilhado <br></li><li>  Seguran√ßa manual da linha (por exemplo, travas, sem√°foros) </li></ol><br>  Os idiomas com restri√ß√£o de encadeamento colocam um limite de 1 encadeamento para vari√°veis ‚Äã‚Äãmut√°veis ‚Äã‚Äãou exigem que todas as vari√°veis ‚Äã‚Äãcomuns sejam imut√°veis.  Ambas as abordagens abordam o problema b√°sico da corrida de dados - dados compartilhados incorretamente modific√°veis ‚Äã‚Äã- mas as restri√ß√µes s√£o muito severas.  Para resolver o problema, os idiomas criaram primitivas de sincroniza√ß√£o de baixo n√≠vel, como mutexes.  Eles podem ser usados ‚Äã‚Äãpara criar estruturas de dados seguras para encadeamento. <br><br><h3>  Python e bloqueio global por int√©rprete </h3><br>  A implementa√ß√£o de refer√™ncia em Python e Cpython possui um tipo de mutex chamado Global Interpreter Lock (GIL), que bloqueia todos os outros threads quando um thread acessa um objeto.  O Python multithread √© not√≥rio por sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inefici√™ncia</a> devido √† lat√™ncia do GIL.  Portanto, a maioria dos programas Python simult√¢neos trabalha em v√°rios processos para que cada um tenha seu pr√≥prio GIL. <br><br><h3>  Exce√ß√µes de Java e tempo de execu√ß√£o </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Java</a> suporta programa√ß√£o simult√¢nea por meio de um modelo de mem√≥ria compartilhada.  Cada encadeamento possui seu pr√≥prio caminho de execu√ß√£o, mas pode acessar qualquer objeto no programa: o programador deve sincronizar o acesso entre os encadeamentos usando as primitivas Java integradas. <br><br>  Embora o Java tenha blocos de constru√ß√£o para a cria√ß√£o de programas seguros para encadeamento, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seguran√ßa do encadeamento</a> <b>n√£o</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√©</a> <b>garantida pelo</b> compilador (em oposi√ß√£o √† seguran√ßa da mem√≥ria).  Se ocorrer acesso n√£o sincronizado √† mem√≥ria (ou seja, corrida de dados), o Java lan√ßar√° uma exce√ß√£o em tempo de execu√ß√£o, mas os programadores devem usar corretamente as primitivas de simultaneidade corretamente. <br><br><h3>  C ++ e o c√©rebro do programador </h3><br>  Enquanto o Python evita condi√ß√µes de corrida com o GIL e o Java lan√ßa exce√ß√µes em tempo de execu√ß√£o, o C ++ espera que o programador sincronize manualmente o acesso √† mem√≥ria.  Antes do C ++ 11, a biblioteca padr√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o inclu√≠a primitivas de simultaneidade</a> . <br><br>  A maioria dos idiomas fornece ferramentas para escrever c√≥digos seguros para threads, e existem m√©todos especiais para detectar dados de corrida e status de corrida;  mas n√£o oferece nenhuma garantia de seguran√ßa do encadeamento e n√£o protege contra a corrida de dados. <br><br><h1>  Como resolver o problema de ferrugem? </h1><br>  O Rust adota uma abordagem multifacetada para eliminar as condi√ß√µes de corrida, usando regras de propriedade e tipos seguros para proteger completamente contra as condi√ß√µes de corrida em tempo de compila√ß√£o. <br><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo,</a> introduzimos o conceito de propriedade, este √© um dos conceitos b√°sicos do Rust.  Cada vari√°vel possui um propriet√°rio √∫nico e a propriedade pode ser transferida ou emprestada.  Se outro encadeamento quiser alterar o recurso, transferimos a propriedade movendo a vari√°vel para um novo encadeamento. <br><br>  Mover gera uma exce√ß√£o: v√°rios threads podem gravar na mesma mem√≥ria, mas nunca ao mesmo tempo.  Como o propriet√°rio est√° sempre sozinho, o que acontece se outro encadeamento emprestar uma vari√°vel? <br><br>  Em Rust, voc√™ tem um empr√©stimo mut√°vel ou v√°rios empr√©stimos imut√°veis.  N√£o √© poss√≠vel introduzir simultaneamente empr√©stimos mut√°veis ‚Äã‚Äãe imut√°veis ‚Äã‚Äã(ou v√°rios mut√°veis).  Na seguran√ßa da mem√≥ria, √© importante que os recursos sejam liberados corretamente e, na seguran√ßa do encadeamento, √© importante que apenas um encadeamento tenha o direito de alterar uma vari√°vel a qualquer momento.  Al√©m disso, em tal situa√ß√£o, nenhum outro fluxo se refere a empr√©stimos obsoletos: a grava√ß√£o ou o compartilhamento s√£o poss√≠veis, mas n√£o os dois. <br><br>  O conceito de propriedade foi projetado para solucionar vulnerabilidades de mem√≥ria.  Descobriu-se que tamb√©m impede a corrida de dados. <br><br>  Embora muitos idiomas possuam m√©todos de seguran√ßa de mem√≥ria (como contagem de links e coleta de lixo), eles geralmente contam com sincroniza√ß√£o manual ou proibi√ß√µes de compartilhamento simult√¢neo para impedir a corrida de dados.  A abordagem Rust aborda os dois tipos de seguran√ßa, tentando resolver o principal problema de determinar o uso aceit√°vel dos recursos e garantir essa validade no tempo de compila√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/972/88b/4d9/97288b4d9796a35d8cce9400c2dbfd73.png"></div><br><br><h3>  Mas espera!  Isso n√£o √© tudo! </h3><br>  As regras de propriedade impedem que v√°rios threads gravem dados no mesmo local de mem√≥ria e pro√≠bem a troca simult√¢nea de dados entre threads e mutabilidade, mas isso n√£o fornece necessariamente estruturas de dados seguras para threads.  Cada estrutura de dados no Rust √© thread thread safe ou n√£o.  Isso √© passado para o compilador usando um sistema de tipos. <br><br><blockquote>  "Um programa bem digitado n√£o pode cometer um erro."  - Robin Milner, 1978 </blockquote><br>  Nas linguagens de programa√ß√£o, os sistemas de tipos descrevem um comportamento aceit√°vel.  Em outras palavras, um programa bem digitado est√° bem definido.  Enquanto nossos tipos forem expressivos o suficiente para capturar o significado pretendido, um programa bem digitado se comportar√° como pretendido. <br><br>  Rust √© uma linguagem de tipo seguro, aqui o compilador verifica a consist√™ncia de todos os tipos.  Por exemplo, o c√≥digo a seguir n√£o √© compilado: <br><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-string"><span class="hljs-string">"I am a string"</span></span>; x = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br><pre> <code class="rust hljs"> error[E0308]: mismatched types --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">6</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span> | x = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-comment"><span class="hljs-comment">// | ^ expected &amp;str, found integral variable | = note: expected type `&amp;str` found type `{integer}`</span></span></code> </pre> <br>  Todas as vari√°veis ‚Äã‚Äãem Rust s√£o do tipo frequentemente impl√≠citas.  Tamb√©m podemos definir novos tipos e descrever os recursos de cada tipo usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o sistema de caracter√≠sticas</a> .  Os tra√ßos fornecem uma abstra√ß√£o da interface.  Duas caracter√≠sticas internas importantes s√£o <code>Send</code> e <code>Sync</code> , que s√£o fornecidas por padr√£o pelo compilador para cada tipo: <br><br><ul><li>  <code>Send</code> indica que a estrutura pode ser transferida com seguran√ßa entre encadeamentos (necess√°rio para transferir a propriedade) <br></li><li>  <code>Sync</code> indica que os threads podem usar a estrutura com seguran√ßa. </li></ul><br>  O exemplo abaixo √© uma vers√£o simplificada do <a href="">c√≥digo da biblioteca padr√£o</a> que gera threads: <br><br><pre> <code class="rust hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn</span></span></span></span>&lt;Closure: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() + <span class="hljs-built_in"><span class="hljs-built_in">Send</span></span>&gt;(closure: Closure){ ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = std::rc::Rc::new(<span class="hljs-number"><span class="hljs-number">6</span></span>); spawn(|| { x; });</code> </pre> <br>  A fun√ß√£o de <code>spawn</code> usa um √∫nico argumento, <code>closure</code> e requer um tipo para o √∫ltimo que implementa os tra√ßos <code>Send</code> e <code>Fn</code> .  Ao tentar criar um fluxo e transmitir o valor de <code>closure</code> com a vari√°vel <code>x</code> compilador gera um erro: <br><br><pre>  erro [E0277]: `std :: rc :: Rc &lt;i32&gt;` n√£o pode ser enviado entre threads com seguran√ßa
      -&gt; src / main.rs: 8: 1
       |
     8  desovar (mover || {x;});
       |  ^^^^^ `std :: rc :: Rc &lt;i32&gt;` n√£o pode ser enviado entre threads com seguran√ßa
       |
       = help: dentro de `[encerramento@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`, o atributo `std :: marker :: Send` n√£o est√° implementado para `std :: rc :: Rc &lt;i32&gt;`
       = note: obrigat√≥rio porque aparece dentro do tipo `[encerramento@src/main.rs: 8: 7: 8:21 x: std :: rc :: Rc &lt;i32&gt;]`
     nota: requerido por `spawn` </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As caracter√≠sticas de</a> <code>Send</code> e <code>Sync</code> permitem que o sistema do tipo Rust entenda quais dados podem ser compartilhados.  Ao incluir essas informa√ß√µes no sistema de tipos, a seguran√ßa da rosca se torna parte do tipo de seguran√ßa.  Em vez de documenta√ß√£o, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seguran√ßa do thread √© implementada pela lei do compilador</a> . <br><br>  Os programadores veem claramente objetos comuns entre os encadeamentos, e o compilador garante a confiabilidade dessa instala√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/af5/27e/35caf527e18989b41893e6fd37239dab.gif"></div><br><br>  Embora ferramentas de programa√ß√£o paralela estejam dispon√≠veis em v√°rios idiomas, n√£o √© f√°cil impedir as condi√ß√µes de corrida.  Se voc√™ precisar que os programadores alternem instru√ß√µes complexamente e interajam entre os threads, os erros ser√£o inevit√°veis.  Embora as viola√ß√µes de seguran√ßa de thread e mem√≥ria tenham consequ√™ncias semelhantes, as prote√ß√µes tradicionais de mem√≥ria, como contagem de links e coleta de lixo, n√£o impedem as condi√ß√µes de corrida.  Al√©m da garantia est√°tica de seguran√ßa da mem√≥ria, o modelo de propriedade Rust tamb√©m evita altera√ß√µes inseguras de dados e compartilhamento incorreto de objetos entre threads, enquanto o sistema de tipos fornece seguran√ßa de thread no tempo de compila√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/429/fb9/92d429fb9c3812ddfdf115d71a3695ed.jpg"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt441370/">https://habr.com/ru/post/pt441370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt441360/index.html">Openshift - artesanato com chap√©u vermelho</a></li>
<li><a href="../pt441362/index.html">Guia do Usu√°rio Kibana. Visualiza√ß√£o. Parte 3</a></li>
<li><a href="../pt441364/index.html">Programa de confer√™ncias Lua em Moscou 2019</a></li>
<li><a href="../pt441366/index.html">A loja precisa da experi√™ncia do Stylish Crossell: Retail Rocket em an√°lise de imagens para formar recomenda√ß√µes</a></li>
<li><a href="../pt441368/index.html">Como √© a lua anteriormente invis√≠vel de Netuno?</a></li>
<li><a href="../pt441372/index.html">[Sexta-feira] Como fritar frango em termos de f√≠sica</a></li>
<li><a href="../pt441376/index.html">Al√©m da pureza: o que pode e o que n√£o pode reverter a membrana de osmose</a></li>
<li><a href="../pt441378/index.html">Pesquisadores do Google: para se proteger contra o Spectre requer uma altera√ß√£o na arquitetura do processador, os patches de software n√£o ajudar√£o</a></li>
<li><a href="../pt441380/index.html">7 pontos de crescimento da convers√£o ou como aumentar a clicabilidade dos bot√µes</a></li>
<li><a href="../pt441382/index.html">Cientistas chineses desenvolveram um gerador piezoel√©trico para marcapasso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>