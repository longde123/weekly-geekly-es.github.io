<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¼â€âœˆï¸ ğŸ‘¨ğŸ¾â€ğŸ’¼ â˜¹ï¸ VIM - Ini bukan hanya editor, ini adalah integrasi dengan semua lingkungan kerja Anda â™¦ï¸ ğŸ¤ ğŸ›¥ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa Vim / Neovim sangat baik? Fakta bahwa toolkit Anda bukan hanya editor (yang dengan sendirinya sangat dapat diperluas dengan plugin dan memilik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>VIM - Ini bukan hanya editor, ini adalah integrasi dengan semua lingkungan kerja Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483580/"><p>  Mengapa <strong>Vim</strong> / <strong>Neovim</strong> sangat baik?  Fakta bahwa toolkit Anda bukan hanya editor (yang dengan sendirinya sangat dapat diperluas dengan plugin dan memiliki fungsi dasar yang kaya dan sangat fleksibel dalam bidang penyesuaian), tetapi juga <strong>seluruh lingkungan kerja Anda</strong> , dengan semua toolkit unix-way termasuk dari gnu / coreutils dan tidak hanya.  Anda dapat mengambil program atau juru bahasa apa pun tanpa meninggalkan editor dan menggunakannya langsung di editor. </p><a name="habracut"></a><br><h2 id="predislovie">  Kata Pengantar </h2><br><p>  Posting ini ditulis dengan tergesa-gesa untuk lingkaran pribadi orang, tetapi saya memutuskan bahwa sangat mungkin untuk mempostingnya di Habr.  Bagi sebagian orang, ini bisa menjadi inspirasi, seseorang akan membantu untuk lebih memahami filosofi Vim, dan seseorang akan mengambil beberapa trik untuk diri mereka sendiri.  Untuk berjaga-jaga, saya akan membuat reservasi yang seharusnya tidak saya harapkan bahwa saya akan membuktikan sesuatu kepada seseorang di komentar, misalnya, untuk meyakinkan Anda bahwa Anda pasti harus melepaskan IDE Anda yang gemuk dan mulai menggunakan Vim, saya sama sekali tidak tertarik dengan hal ini. </p><br><h2 id="k-delu">  Untuk bisnis </h2><br><p>  Di sini, misalnya, ambil sepotong kode (dari konfigurasi proyek Haskell), daftar dependensi paket (contoh dalam ruang hampa): </p><br><pre><code class="plaintext hljs">build-depends: X11 , base , directory , extra , GLFW-b , safe , aeson , containers , data-default , text , process , time , dbus</code> </pre> <br><h2 id="chto-my-hotim">  Apa yang kita inginkan? </h2><br><ol><li>  Urutkan dependensi berdasarkan abjad </li><li>  Sortir case-insensitive ( <code>X11</code> dan <code>GLFW-b</code> tidak harus naik di atas segalanya) </li><li>  Pulihkan koma ( <code>aeson</code> akan menuju ke paling atas dan seharusnya tidak lagi memiliki koma di sebelah kiri, tetapi <code>X11</code> harus memiliki koma di sebelah kiri) </li><li>  Pulihkan lekukan (sehingga Anda juga bisa mendapatkan perintah dari sejarah dan menggunakannya kembali di konfigurasi lain dengan tingkat bersarang yang berbeda, atau bahkan mengikat perintah hotkey di konfigurasi Vim) </li></ol><br><h2 id="reshenie">  Solusi </h2><br><p>  Pertama-tama, pilih (dengan menyoroti visual) daftar dependensi kecuali baris pertama <code>build-depends</code> .  Anda tentu saja dapat cukup menekan <code>V</code> (mode visual dengan pemilihan baris demi baris) dan memilih garis yang diperlukan melalui <code>jk</code> atau panah atas dan bawah.  Dalam kasus saya, saya melakukan ini dengan satu gelombang tangan saya menggunakan hotkey khusus untuk mode visual: </p><br><pre> <code class="plaintext hljs">xn iz &lt;esc&gt;[zV]z</code> </pre> <br><p>  Misalnya, berada di tengah daftar dependensi, saya hanya menekan <code>viz</code> dan semua dependensi disorot, karena  seluruh lipatan disorot, yang pada gilirannya adalah blok bersarang saat ini (karena saya telah menetapkan <code>foldmethod</code> sebagai <code>indent</code> ).  Tetapi Anda juga dapat secara manual mengetik <code>[zV]z</code> secara berurutan tanpa hotkey khusus ( <code>[z</code> melompat ke awal flip, a <code>]z</code> ke akhir), tetapi karena  bagi saya operasi seperti itu sering digunakan, maka saya mempersingkatnya menjadi <code>viz</code> - tidak ada pengubah seperti pergeseran dan kompres pada refleks dalam sekejap (analog standar terdekat adalah <code>vip</code> untuk memilih blok ke garis kosong terdekat). </p><br><p>  Kemudian tekan <code>:</code> (titik dua) untuk masuk ke mode perintah untuk menjalankan perintah relatif terhadap sorotan visual saat ini.  Bahkan, mode perintah yang biasa, tetapi dengan segera menambahkan marker seleksi, mis.  akan terlihat seperti <code>:'&lt;,'&gt;</code> mana <code>'&lt;,'&gt;</code> adalah rentang pilihan, di mana <code>'&lt;</code> adalah baris pertama dari pemilihan visual, dan <code>'&gt;</code> adalah yang terakhir. </p><br><p>  Setelah kita klik <code>!</code>  (tanda seru) pada keyboard, ini berarti bahwa semua yang berjalan lebih jauh adalah perintah shell / bash (tergantung pada pengaturan).  Akan terlihat seperti <code>:'&lt;,'&gt;!</code>  .  Bahkan, setelah memilih, Anda bisa langsung mengklik <code>!</code>  dan dapatkan hasil yang sama - <code>:'&lt;,'&gt;!</code>  . </p><br><p>  Operasi ini akan mengalihkan garis yang disorot ke perintah STDIN dan mengganti garis yang disorot dengan knalpot STDOUT dari perintah ini.  Misalnya, Anda dapat menggunakan perintah <code>sort</code> , murni untuk verifikasi, hasilnya bukan apa yang kita butuhkan - <code>'&lt;,'&gt;!sort</code> dan tekan <em>Enter</em> , kita dapatkan: </p><br><pre> <code class="plaintext hljs"> build-depends: , aeson , base , containers , data-default , dbus , directory , extra , GLFW-b , process , safe , text , time X11</code> </pre> <br><h3 id="sposob-s-coreutils-i-voobsche-bashem">  Fashion dengan coreutils dan menara umum </h3><br><p>  Kembalikan pilihan sebelumnya (Anda dapat menekan <code>gv</code> untuk mengembalikan pilihan terakhir) dan tekan <code>!</code>  dan kemudian panah atas - ini akan mengembalikan perintah terakhir dari sejarah, jadi kita tidak perlu menulis lagi, kita cukup mengekstrak perintah sebelumnya dari sejarah dan mengubahnya.  Untuk mengedit perintah yang lebih nyaman, Anda dapat menekan <code>Ctrl</code> + <code>f</code> - ini akan membuka tambahan.  sebuah jendela dengan pengeditan standar normal perintah, dengan semua kemampuan Vim, omong-omong, semua tim sebelumnya dari sejarah akan terlihat di sana sebagai baris terpisah, yang juga dapat dipilih, diedit dan dieksekusi. </p><br><p>  Apa hal yang benar untuk dilakukan - Anda dapat memikirkan suatu penemuan, maksud saya adalah ini: pertama kita menghapus koma, mengurutkannya tanpa mereka (tanpa case-case), kemudian kita mengembalikan koma, kecuali untuk baris pertama. </p><br><p>  Pertama, hapus koma (dan baris pertama memiliki lekukan tambahan sehingga semua baris memiliki lekukan yang sama) menggunakan perintah <code>sed</code> dengan ekspresi reguler ( <code>[, ]</code> - koma atau spasi, dan kemudian spasi lain, <code>\(\w\)</code> lolos dari tanda kurung untuk menyorot blokir untuk substitusi, sehingga tersedia sebagai <code>\1</code> , <code>\w</code> adalah karakter alfabet pertama, dalam penggantian kita akan mengembalikan karakter alfabet dengan mengganti <code>\1</code> ): </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!sed 's/[, ] \(\w\)/\1/'</code> </pre> <br><p>  Kami mendapatkan yang berikut ini: </p><br><pre> <code class="plaintext hljs"> build-depends: X11 base directory extra GLFW-b safe aeson containers data-default text process time dbus</code> </pre> <br><p>  Selanjutnya, kita pipe (melalui simbol <code>|</code> adalah fitur bash) ke perintah sort <code>sort</code> , melewati <code>-f</code> untuk case insensitivity: </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!sed 's/[, ] \(\w\)/\1/' | sort -f</code> </pre> <br><p>  Kami mendapatkan: </p><br><pre> <code class="plaintext hljs"> build-depends: aeson base containers data-default dbus directory extra GLFW-b process safe text time X11</code> </pre> <br><p>  Hampir selesai!  Tetap hanya menambahkan koma, dan baris pertama - beberapa spasi.  Kami menggunakan <code>sed</code> sama, dalam sintaks operasinya Anda dapat menentukan string dan rentang string (seperti dalam Vim itu sendiri, sintaksnya sama, baik, atau hampir sama).  Awalan <code>1</code> akan berarti baris pertama, <code>2,$</code> berarti kisaran dari baris ke-2 sampai akhir ( <code>$</code> , seperti <code>^</code> berarti awal file, dengan analogi dengan karakter yang sama dalam ekspresi reguler yang berarti akhir dan awal dari baris).  Kami akan menggunakan <code>\w</code> untuk melewati lekukan dan segera memilih karakter alfabet pertama: <code>1s/\w/ &amp;/</code> - di sini kami melakukan penggantian untuk baris pertama, mengembalikan karakter alfabet pertama melalui <code>&amp;</code> (mirip dengan <code>\1</code> , hanya <code>&amp;</code> berarti segalanya di bawah seluruh regex, sedangkan <code>\1</code> berarti blok pertama yang dibungkus dengan tanda kurung), menambahkan beberapa spasi di depannya.  Untuk baris yang tersisa, alih-alih dua spasi, tambahkan koma + spasi diikuti oleh: <code>2,$s/\w/, &amp;/</code> , seluruh perintah akan seperti ini: <code>sed -e '1s/\w/ &amp;/' -e '2,$s/\w/, &amp;/'</code> , - <code>-e</code> kita gunakan untuk memisahkan 2 operasi dari satu sama lain.  Di Vim, seluruh operasi akan terlihat seperti: </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!sed 's/[, ] \([^, ]\)/\1/' | sort -f | sed -e '1s/\w/ &amp;/' -e '2,$s/\w/, &amp;/'</code> </pre> <br><p>  Kami mendaftar dan mendapatkan: </p><br><pre> <code class="plaintext hljs"> build-depends: aeson , base , containers , data-default , dbus , directory , extra , GLFW-b , process , safe , text , time , X11</code> </pre> <br><p>  Selesai!  Tidak perlu lagi menulis kedua, cukup ketikkan beberapa karakter pertama, misalnya :: <code>:'&lt;,'&gt;!se</code> (sebenarnya, Anda hanya perlu menekan <code>!se</code> ), dan gunakan panah atas untuk mendapatkan perintah yang diinginkan dari sejarah.  Dengan satu atau lain cara, saya sering merekomendasikan berlatih menulis hal-hal seperti itu <em>segera</em> .  Dengan demikian, Anda berdua akan memompa keterampilan kerja harian Anda di bash dan di Vim sendiri  pada dasarnya Anda melakukan hal yang sama. </p><br><p>  Pada akhirnya, seluruh perintah ini dapat ditugaskan ke hotkey, atau diabstraksi menjadi fungsi, dan digunakan kembali di mana-mana untuk satu atau dua. </p><br><h3 id="ispolzuya-storonniy-yap">  Menggunakan PL pihak ketiga </h3><br><p>  Alih-alih meluncurkan sesuatu dari coreutils, Anda dapat menjalankan juru bahasa dari beberapa jenis <strong>bahasa</strong> yang nyaman bagi Anda, saya suka melakukan hal-hal seperti itu melalui <strong>Perl6</strong> (baru-baru ini diubah namanya menjadi <strong>Raku</strong> ): </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!perl6 -e 'my @x=lines.map(*.subst(/&lt;[,\s]&gt;\s(\w)/,{$0})).sort(*.lc); @x.shift.subst(/\w/,{q/ /~$_}).say; .subst(/\w/,{q/, /~$_}).say for @x'</code> </pre> <br><p>  Ya, setidaknya pada zoskopi (simpul.js): </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!node -e 'let fs=require("fs"), x=fs.readFileSync(process.stdin.fd).toString().replace(/\n$/,'').split(/\n/).map(x=&gt;x.replace(/[, ] (\w)/,"$1")).sort((a,b)=&gt;a.toLowerCase().localeCompare(b.toLowerCase())); console.log(x.shift().replace(/(\w)/," $1")); process.stdout.write(x.map(x=&gt;x.replace(/(\w)/,", $1")).join("\n"))'</code> </pre> <br><p>  Ini juga dapat dilakukan pada VimL / Vimscript di dalam Vim itu sendiri, tanpa memanggil perintah eksternal.  Tapi posting ini bukan tentang itu. </p><br><p>  Tentu saja, seperti yang sudah Anda duga, Anda dapat dengan mudah menyimpan skrip Anda ke file terpisah, atau bahkan mengkompilasi program Anda sendiri yang mengambil sesuatu untuk masuk ke STDIN dan mengeluarkan sesuatu yang diproses dalam STDOUT dan menggunakannya dalam Vim hanya dengan menelepon (yang , sekali lagi, dapat ditugaskan ke hotkey): </p><br><pre> <code class="plaintext hljs">:'&lt;,'&gt;!~/my-program-or-script</code> </pre> <br><p>  Dengan demikian, ketika Anda menulis kode dalam Vim, tidak hanya Vim itu sendiri siap membantu Anda, tetapi juga seluruh lingkungan kerja Anda. </p><br><p>  Salah satu contoh paling sederhana adalah menolak file JSON: </p><br><pre> <code class="plaintext hljs">:%!jq</code> </pre> <br><p>  Hanya dengan beberapa penekanan tombol, mengapa menciptakan kembali AST parser dan prettifayer untuk JSON untuk editor / IDE / apa pun yang baru, ketika Anda bisa mengambil dan menjalankan file melalui <code>jq</code> tanpa meninggalkan Vim?  Saya tidak berbicara tentang fakta bahwa Anda dapat memproses file JSON besar Anda melalui <code>jq</code> dengan cara ini, tanpa meninggalkan Vim, temukan misalnya kunci yang diinginkan di pohon, urutkan, tinggalkan hanya data yang diperlukan, dll. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483580/">https://habr.com/ru/post/id483580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483564/index.html">Copywriting di IT: bagaimana memulai menulis tentang teknologi</a></li>
<li><a href="../id483568/index.html">Membuat komputer primitif dari awal</a></li>
<li><a href="../id483570/index.html">Tetapi bagaimana jika bumi itu rata?</a></li>
<li><a href="../id483574/index.html">Analisis Keandalan Peralatan Elektronik Shock dan Getaran - Tinjauan Umum</a></li>
<li><a href="../id483578/index.html">Berita dari dunia OpenStreetMap No. 493 (12.24.2019 - 12.30.2019)</a></li>
<li><a href="../id483584/index.html">Mentransfer backend PHP ke Redis stream bus dan memilih perpustakaan yang tidak bergantung pada framework</a></li>
<li><a href="../id483586/index.html">Dasar-dasar bekerja dengan zmq dalam python, membuat penyimpanan kunci / nilai sederhana</a></li>
<li><a href="../id483588/index.html">Cara mencoba memblokir situs apa pun menggunakan ILV</a></li>
<li><a href="../id483590/index.html">Cari kesalahan FDCAN yang tidak</a></li>
<li><a href="../id483594/index.html">Ekonomi masa depan untuk fisikawan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>