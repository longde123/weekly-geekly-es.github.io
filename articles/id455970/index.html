<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ü©Ô∏è ‚òëÔ∏è üßòüèΩ Semua yang ingin Anda ketahui tentang SwiftUI tetapi takut untuk bertanya ü•§ ‚òÆÔ∏è ‚û°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Renat, saya sedang mengembangkan layanan analisis berlangganan di iOS - Apphud. 


 Seperti yang Anda tahu, Apple di WWDC 2019 memperken...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Semua yang ingin Anda ketahui tentang SwiftUI tetapi takut untuk bertanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/apphud/blog/455970/"><p><img src="https://habrastorage.org/getpro/habr/post_images/cf0/767/da2/cf0767da24045153cfec395c841c5a52.png"></p><br><p>  Hai  Nama saya Renat, saya sedang mengembangkan layanan analisis berlangganan di iOS - Apphud. </p><br><p> Seperti yang Anda tahu, Apple di WWDC 2019 memperkenalkan kerangka kerja SwiftUI baru, yang dirancang di masa depan untuk menggantikan (atau tidak?) UIKit yang familier.  SwiftUI memungkinkan Anda untuk menggambarkan antarmuka aplikasi dalam gaya deklaratif dan sangat mengurangi jumlah kode. </p><br><p>  Apple telah memperkenalkan beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tutorial</a> bahasa Inggris yang menarik dengan banyak contoh.  Saya akan mencoba berbicara tentang kerangka kerja baru dalam bentuk pertanyaan dan jawaban.  Jadi ayo pergi. <a name="habracut"></a></p><br><h2 id="pered-nachalom-raboty">  Sebelum Anda mulai </h2><br><p>  Untuk bekerja dengan SwiftUI, Anda perlu mengunduh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Xcode 11 Beta</a> .  Anda juga harus menjadi pengembang Apple terdaftar.  Memiliki macOS Catalina terbaru memang diinginkan, tetapi tidak perlu.  Tanpanya, Canvas tidak akan tersedia. </p><br><p>  Jadi, dalam Xcode 11 Beta, buat proyek baru dan pastikan bahwa "Gunakan SwiftUI" dicentang. </p><br><h2 id="voprosy-i-otvety">  Tanya Jawab </h2><br><h3 id="kuda-podevalsya-interface-builder">  Kemana perginya Interface Builder? </h3><br><p> SwiftUI tidak lagi membutuhkan <em>Interface Builder</em> - telah digantikan oleh <em>Canvas</em> , editor antarmuka interaktif yang terkait erat dengan kode.  Saat menulis kode, bagian visualnya di <em>kanvas dibuat</em> secara otomatis dan sebaliknya.  Sangat nyaman, dan yang paling penting aman.  Sekarang aplikasi Anda tidak akan <code>@IBOutlet</code> karena Anda lupa memperbarui <code>@IBOutlet</code> dengan variabel.  Pada artikel ini kami tidak akan menyentuh <em>kanvas</em> , kami hanya akan mempertimbangkan kode. </p><br><h3 id="izmenilsya-li-zapusk-prilozheniya">  Apakah peluncuran aplikasi berubah? </h3><br><p>  Ya, sekarang objek awal dalam antarmuka aplikasi bukan <code>UIWindow</code> , tetapi kelas <code>UIScene</code> baru (atau <code>UIWindowScene</code> turunannya).  Dan sebuah jendela ditambahkan ke tempat kejadian.  Perubahan ini tidak hanya memengaruhi SwiftUI, tetapi iOS 13 secara keseluruhan. </p><br><p>  Saat Anda membuat proyek, Anda akan melihat file <em>AppDelegate</em> , <em>SceneDelegate,</em> dan <em>ContentView</em> .  <em>SceneDelegate</em> - delegasi dari kelas <code>UIWindowScene</code> , yang digunakan untuk mengontrol adegan dalam aplikasi.  Sangat mengingatkan pada <em>AppDelegate</em> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/02e/176/a9b/02e176a9b712281554aff7496a166ec1.png" alt="Kelas SceneDelegate ditentukan dalam Info.plist"><br>  <em>Kelas SceneDelegate ditentukan dalam Info.plist</em> </p><br><p>  Dalam metode delegasi, <code>scene: willConnectTo: options:</code> membuat jendela dan root <code>UIHostingController</code> yang berisi <code>ContentView</code> .  <code>ContentView</code> adalah halaman "rumah" kami.  Semua pengembangan akan dilakukan di kelas ini. </p><br><h3 id="chem-view-otlichaetsya-ot-uiview">  Apa bedanya View dengan UIView? </h3><br><p>  <code>ContentView.swift</code> Anda membuka <code>ContentView.swift</code> , Anda akan melihat deklarasi kontainer ContentView.  Seperti yang sudah Anda pahami, tidak ada metode <code>viewDidLoad</code> atau metode <code>viewDidAppear</code> <code>viewDidLoad</code> <code>viewDidAppear</code> .  Dasar layar di sini bukanlah <code>UIViewController</code> , melainkan <em>View</em> .  Hal pertama yang perlu diperhatikan adalah <code>ContentView</code> adalah <code>struct</code> yang menerima protokol <code>View</code> .  Ya, <code>View</code> sekarang <code>View</code> menjadi protokol, dan sangat sederhana.  Satu-satunya metode yang perlu Anda terapkan di <code>ContentView</code> adalah mendeskripsikan isi variabel.  Semua <em>subview</em> dan <em>tampilan</em> khusus Anda harus menerima protokol <code>View</code> , mis. Harus memiliki variabel <code>body</code> . </p><br><h3 id="chto-takoe-body">  Apa itu tubuh? </h3><br><p>  <code>Body</code> secara langsung adalah wadah kami di mana semua <em>subview</em> lainnya ditambahkan.  Ini agak mirip dengan <em>badan</em> di halaman <em>html</em> , di mana halaman <em>html</em> adalah <code>ContentView</code> .  <code>Body</code> harus selalu memiliki tepat satu keturunan, dan setiap kelas yang menerima protokol tampilan. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>) } }</code> </pre> <br><h3 id="opaque-return-types-ili-chto-takoe-some">  Jenis pengembalian buram atau apa? </h3><br><p>  Pembangunan <code>some TypeName</code> adalah inovasi Swift 5.1 yang disebut <em>tipe pengembalian buram</em> .  Ini digunakan untuk kasus-kasus ketika tidak penting bagi kita objek yang kembali, yang utama adalah bahwa ia mendukung tipe yang ditentukan, dalam hal ini, protokol tampilan. </p><br><p>  Jika kita hanya menulis <code>var body: View</code> , maka ini berarti kita harus mengembalikan <code>View</code> .  Kelas <code>Any</code> juga tidak berfungsi, karena kita harus melakukan operasi konversi tipe ( <em>menggunakan operator</em> <code>as!</code> ).  Oleh karena itu, mereka datang dengan kata khusus <code>some</code> di depan nama protokol untuk menunjukkan <em>jenis pengembalian buram</em> .  Alih-alih <code>View</code> kita dapat mengembalikan <code>Text</code> , <code>Image</code> , <code>VStack</code> - apa pun, karena semuanya mendukung protokol <code>View</code> .  Tetapi harus ada tepat satu elemen: ketika mencoba mengembalikan lebih dari satu <code>View</code> kompiler akan membuat kesalahan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e17/8d3/628/e178d3628d10d0cd438d776a9c4ecd70.png"><br>  <em>Kesalahan kompilasi ketika mencoba mengembalikan lebih dari satu elemen ke tubuh</em> </p><br><h3 id="chto-za-sintaksis-vnutri-skobok-i-gde-addsubview">  Apa sintaks di dalam tanda kurung dan di mana addSubview? </h3><br><p>  Swift 5.1 memperkenalkan kemampuan untuk mengelompokkan objek menjadi satu kesatuan dalam gaya deklaratif.  Ini mirip dengan larik di dalam blok <em>penutup</em> , tetapi elemen-elemennya disebutkan dari baris baru tanpa koma dan <em>kembali</em> .  Mekanisme ini disebut <em>Function Builder</em> . </p><br><p>  Ini banyak digunakan di SwiftUI.  Berdasarkan <em>Function Builder,</em> mereka membuat <code>ViewBuilder</code> - desainer antarmuka deklaratif.  Menggunakan <code>ViewBuilder</code> kita tidak perlu lagi menulis <code>addSubview</code> untuk setiap elemen - cukup daftarkan semua <code>View</code> dari baris baru di dalam blok <em>closure</em> .  SwiftUI akan menambahkan dan mengelompokkan elemen ke dalam wadah induk yang lebih kompleks. </p><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@available</span></span>(iOS <span class="hljs-number"><span class="hljs-number">13.0</span></span>, <span class="hljs-type"><span class="hljs-type">OSX</span></span> <span class="hljs-number"><span class="hljs-number">10.15</span></span>, tvOS <span class="hljs-number"><span class="hljs-number">13.0</span></span>, watchOS <span class="hljs-number"><span class="hljs-number">6.0</span></span>, *) @_functionBuilder <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/// Builds an empty view from an block containing no statements, `{ }`. public static func buildBlock() -&gt; EmptyView /// Passes a single view written as a child view (e..g, `{ Text("Hello") }`) through /// unmodified. public static func buildBlock&lt;Content&gt;(_ content: Content) -&gt; Content where Content : View }</span></span></code> </pre> <br><p>  <em>Iklan ViewBuilder dalam kerangka kerja SwiftUI</em> </p><br><h3 id="kak-dobavlyat-uilabel-uiimageview-i-drugie-elementy">  Bagaimana cara menambahkan UILabel, UIImageView dan elemen lainnya? </h3><br><p>  Elemen dibuat dengan sangat sederhana: setiap <code>View</code> perlu ditulis dari baris baru dan mengubah tampilan menggunakan fungsi pengubah ( <em>view modifiers</em> ).  Perbedaan antara pengubah dan fungsi yang akrab bagi kita adalah bahwa mereka selalu mengembalikan objek wadah bukannya <code>void</code> .  Oleh karena itu, kita dapat membuat seluruh rantai pengubah melalui titik ini. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span>{ <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"World Time"</span></span>).font(.system(size: <span class="hljs-number"><span class="hljs-number">30</span></span>)) <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Yet another subtitle"</span></span>).font(.system(size: <span class="hljs-number"><span class="hljs-number">20</span></span>)) } }</code> </pre> <br><p>  Namun, tidak semua kontrol dan <em>Lihat</em> memiliki analog mereka di SwiftUI.  Berikut adalah sebagian daftar kelas dari UIKit dan analognya: </p><br><ul><li><p>  <code>UITableView</code> -&gt; <code>List</code> </p><br></li><li><p>  <code>UICollectionView</code> tidak memiliki analog </p><br></li><li><p>  <code>UILabel</code> -&gt; <code>Text</code> </p><br></li><li><p>  <code>UITextField</code> -&gt; <code>TextField</code> </p><br></li><li><p>  <code>UIImageView</code> -&gt; <code>Image</code> </p><br></li><li><p>  <code>UINavigationController</code> -&gt; <code>NavigationView</code> </p><br></li><li><p>  <code>UIButton</code> -&gt; <code>Button</code> </p><br></li><li><p>  <code>UIStackView</code> -&gt; <code>HStack</code> / <code>VStack</code> </p><br></li><li><p>  <code>UISwitch</code> -&gt; <code>Toggle</code> </p><br></li><li><p>  <code>UISlider</code> -&gt; <code>Slider</code> </p><br></li><li><p>  <code>UITextView</code> tidak memiliki analog </p><br></li><li><p>  <code>UIAlertController</code> -&gt; <code>Alert</code> / <code>ActionSheet</code> </p><br></li><li><p>  <code>UISegmentedControl</code> -&gt; <code>SegmentedControl</code> </p><br></li><li><p>  <code>UIStepper</code> -&gt; <code>Stepper</code> </p><br></li><li><p>  <code>UIDatePicker</code> -&gt; <code>DatePicker</code> </p><br></li></ul><br><h3 id="kak-proishodit-navigaciya-mezhdu-ekranami">  Bagaimana navigasi antar layar? </h3><br><p>  <em>Pengontrol navigasi</em> berperan sebagai <code>NavigationView</code> khusus.  Bungkus saja kode Anda di <code>NavigationView{}</code> .  Dan tindakan transisi itu sendiri dapat ditambahkan ke tombol <code>NavigationLink</code> khusus, yang mendorong layar <code>DetailView</code> bersyarat. </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationView</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"World Time"</span></span>).font(.system(size: <span class="hljs-number"><span class="hljs-number">30</span></span>)) <span class="hljs-type"><span class="hljs-type">NavigationLink</span></span>(destination: <span class="hljs-type"><span class="hljs-type">DetailView</span></span>() { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Go Detail"</span></span>) } } }</code> </pre> <br><p>  Bagaimana cara menyajikan tampilan baru secara modern?  Ini dilakukan, misalnya, menggunakan <em>lembar</em> konstruksi: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Button</span></span>(action: { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Button Pushed"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.show_modal = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Present Modal"</span></span>) }.sheet(isPresented: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.$show_modal) { <span class="hljs-type"><span class="hljs-type">ModalView</span></span>() }</code> </pre> <br><p>  Seperti yang disebutkan di atas, <code>body</code> dapat mengembalikan tidak hanya instance <code>View</code> , tetapi juga kelas lain yang menerima protokol ini.  Ini memberi kita kesempatan untuk <code>DetailView</code> bukan <code>DetailView</code> , tetapi bahkan <code>Text</code> atau <code>Image</code> ! </p><br><h3 id="kak-raspolagat-elementy-na-ekrane">  Bagaimana cara mengatur elemen di layar? </h3><br><p>  Elemen disusun secara terpisah satu sama lain dan dapat ditempatkan secara vertikal di dalam <code>VStack</code> , secara horizontal <code>HStack</code> dan satu di atas <code>ZStack</code> lainnya.  <code>ScrollView</code> dan <code>ListView</code> juga tersedia bagi kami.  Anda dapat mengganti dan berbagi wadah ini untuk mendapatkan elemen elemen apa pun. </p><br><p>  Dengan menggabungkan wadah satu sama lain, Anda bisa mendapatkan pohon yang cukup besar dengan banyak lampiran.  Namun, SwiftUI dioptimalkan secara khusus untuk hal ini, sehingga penumpukan kontainer yang dalam tidak mempengaruhi kinerja.  Ini dinyatakan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video dengan wwdc</a> ( <em>mulai 15:32</em> ). </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationView</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationLink</span></span>(destination: <span class="hljs-type"><span class="hljs-type">LargeView</span></span>(timeString: subtitle)) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"See Fullscreen"</span></span>) } <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"World Time"</span></span>).font(.system(size: <span class="hljs-number"><span class="hljs-number">30</span></span>)) } } }</code> </pre> <br><h3 id="kak-pokazat-navigation-bar">  Bagaimana cara menampilkan Bilah Navigasi? </h3><br><p>  Mendeklarasikan <code>NavigationView</code> tidak cukup, Anda harus menentukan <em>judul</em> dan gaya <em>navigasi untuk bilah navigasi</em> . </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">NavigationView</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span>{}.navigationBarTitle(<span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"World Time"</span></span>), displayMode: .inline) }</code> </pre> <br><p>  Perhatikan bahwa fungsi <code>navigationBarTitle</code> tidak dipanggil pada <code>NavigationView</code> , tetapi pada tampilan internalnya.  <em>DisplayMode</em> adalah parameter yang menunjukkan gaya <em>bilah navigasi</em> : besar atau standar. </p><br><h3 id="est-li-analog-metoda-viewdidload">  Apakah ada analog dari metode viewDidLoad? </h3><br><p>  Jika Anda ingin mengeksekusi kode ketika menginisialisasi <code>View</code> , Anda dapat melakukan ini dengan menambahkan fungsi onAppear {}.  <em>OnAppear</em> dapat ditambahkan ke <code>View</code> apa pun, misalnya, ke <code>VStack</code> .  Dalam contoh ini, ketika wadah muncul di layar, permintaan http dibuat ke server. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statusString : <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"World Time"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationView</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationLink</span></span>(destination:<span class="hljs-type"><span class="hljs-type">DetailView</span></span>()) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Go Detail"</span></span>) } <span class="hljs-type"><span class="hljs-type">Text</span></span>(statusString).font(.system(size: <span class="hljs-number"><span class="hljs-number">30</span></span>)) }.onAppear { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.loadTime() } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-type"><span class="hljs-type">NetworkService</span></span>().getTime { (time) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aTime = time { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.statusString = <span class="hljs-string"><span class="hljs-string">"\(aTime.date())"</span></span> } } } }</code> </pre> <br><blockquote>  Kami memanggil fungsi <code>loadTime</code> , yang meminta waktu saat ini dari server dan mengembalikan model <code>WorldTime</code> .  Kami tidak akan pergi dalam siklus di kelas <code>NetworkService</code> , Anda dapat melihat semua kode, memiliki kode sumber yang diunduh.  Tautan di akhir artikel. </blockquote><p>  Variabel <code>var statusString</code> diberikan untuk menetapkan waktu saat ini nanti.  Variabel memiliki atribut khusus <code>@State</code> .  Apa yang dia maksud </p><br><h3 id="property-wrappers-ili-chto-takoe-state">  Pembungkus Properti atau apa itu <code>@State</code> ? </h3><br><p>  Swift 5.1 memperkenalkan apa yang disebut <em>pembungkus properti</em> (atau <em>delegasi properti</em> ).  Dalam <em>pembungkus properti</em> SwiftUI digunakan untuk memperbarui atau mengikat salah satu parameter <em>tampilan</em> dengan variabel kita sendiri, misalnya, nilai sakelar <em>Toggle</em> . </p><br><p>  Atribut <code>@State</code> adalah atribut khusus yang ditempatkan sebelum deklarasi variabel.  Ini memungkinkan kami untuk melacak perubahan properti secara otomatis tanpa kode tambahan.  Pada contoh di atas, teks <em>"Waktu Dunia"</em> akan berubah ke tanggal saat ini segera setelah kami memperbarui nilai statusString. </p><br><p>  Untuk mengikat nilai ( <em>Properties Binding</em> ), kita dapat menentukan karakter khusus <code>$</code> sebelum nama variabel dalam kode itu sendiri: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DetailsView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> changeToggle: <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Toggle</span></span>(isOn: $changeToggle) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Change Toggle"</span></span>) } } }</code> </pre> <br><p>  <em>Dengan mengubah posisi sakelar, nilai variabel juga akan berubah.</em> </p><br><p>  <em>Pembungkus properti</em> adalah komponen yang sangat penting dari SwiftUI, saya hanya menyebutkannya secara sepintas.  Untuk kenalan yang lebih terperinci dengan <em>pembungkus properti,</em> tonton video dari wwdc di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (dari menit ke-37), di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (dari ke-12) dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> (dari ke-19). </p><br><h3 id="kak-dobavlyat-view-v-runtime">  Bagaimana cara menambahkan tampilan ke runtime? </h3><br><p>  Perlu segera dicatat bahwa Anda tidak dapat menambahkan <em>tampilan</em> kapan saja dalam arti kata sebenarnya.  SwiftUI adalah kerangka kerja deklaratif yang menjadikan seluruh <em>tampilan</em> .  Namun, Anda dapat mengatur berbagai kondisi di dalam <em>tubuh</em> dan memperbarui keadaan <em>tampilan</em> ketika mereka berubah.  Dalam contoh ini, kami menggunakan banyak <code>@State ‚Äì if</code> paling sederhana <code>@State ‚Äì if</code> dengan variabel <code>isTimeLoaded</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ContentView</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statusString : <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"World Time"</span></span> @<span class="hljs-type"><span class="hljs-type">State</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isTimeLoaded : <span class="hljs-type"><span class="hljs-type">Bool</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body: some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationView</span></span> { <span class="hljs-type"><span class="hljs-type">VStack</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isTimeLoaded { addNavigationLink() } <span class="hljs-type"><span class="hljs-type">Text</span></span>(statusString).font(.system(size: <span class="hljs-number"><span class="hljs-number">30</span></span>)).lineLimit(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }.navigationBarTitle(<span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"World Time"</span></span>), displayMode: .inline) }.onAppear { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.loadTime() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNavigationLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">NavigationLink</span></span>(destination: <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"124!!!"</span></span>)) { <span class="hljs-type"><span class="hljs-type">Text</span></span>(<span class="hljs-string"><span class="hljs-string">"Go Detail"</span></span>) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-type"><span class="hljs-type">NetworkService</span></span>().getTime { (time) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aTime = time { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.statusString = <span class="hljs-string"><span class="hljs-string">"\(aTime.date().description(with: Locale.current))"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isTimeLoaded = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DetailView</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeString : <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body : some <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-type"><span class="hljs-type">Text</span></span>(timeString).font(.system(size: <span class="hljs-number"><span class="hljs-number">40</span></span>)).lineLimit(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre> <br><p>  Omong-omong, apakah Anda memperhatikan bahwa fungsi <code>addNavigationLink()</code> tidak memiliki kata <code>return</code> ?  Ini adalah inovasi lain dari Swift 5.1 - untuk fungsi dengan satu ekspresi, sekarang opsional untuk menulis <code>return</code> .  Tapi kamu bisa menulis. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Ini hanya bagian dari Tanya Jawab SwiftUI  Saya memeriksa masalah umum, saya harap artikel ini akan membantu pemula memahami poin utama dari kerangka ini.  SwiftUI masih mentah, tetapi tidak diragukan lagi akan ditingkatkan. </p><br><p>  Pertanyaan logisnya adalah: apakah <em>itu layak untuk dipelajari oleh UIKit?</em>  <em>Tentu saja ya</em>  UIKit adalah dasar pemrograman pada iOS dan akan dikembangkan lebih lanjut.  Selain itu, banyak komponen SwiftUI adalah pembungkus di atas UIKit.  Nah, sejauh ini tidak ada perpustakaan, kerangka kerja, pod untuk SwiftUI.  Semuanya harus ditulis sendiri.  Jadi lebih baik untuk mempelajari kedua pendekatan pengembangan - sehingga Anda akan menjadi pengembang yang lebih berharga. </p><br><p>  Anda dapat mengunduh sumber proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Terima kasih telah membaca artikel sampai akhir.  Semoga bermanfaat. </p><br><h2 id="chto-pochitat">  Apa yang harus dibaca? </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana menerapkan Menu Konteks di iOS 13</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">15 Tips untuk Mendapatkan Aplikasi Langganan Anda ke App Store</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Pemberitahuan Langganan Apple untuk iOS.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah mereka benar-benar baik?</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455970/">https://habr.com/ru/post/id455970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455958/index.html">Automata Seluler Berkembang</a></li>
<li><a href="../id455960/index.html">Mengapa pengembang pergi: 8 alasan</a></li>
<li><a href="../id455962/index.html">Ilmu Data dan Konferensi Tropis</a></li>
<li><a href="../id455966/index.html">5 perusahaan pengembang aplikasi seluler teratas di Inggris</a></li>
<li><a href="../id455968/index.html">Saya membuat setengah roda gigi besar di panel surya untuk 250.000 rubel (1 bagian)</a></li>
<li><a href="../id455972/index.html">Slurm: ulat telah berubah menjadi kupu-kupu</a></li>
<li><a href="../id455976/index.html">Kabinet, modul, atau unit - apa yang harus dipilih untuk manajemen daya di pusat data?</a></li>
<li><a href="../id455978/index.html">Lambdas: dari C ++ 11 ke C ++ 20. Bagian 2</a></li>
<li><a href="../id455980/index.html">iOS Digest No. 7 (31 Mei - 13 Juni)</a></li>
<li><a href="../id455982/index.html">Sudah waktunya untuk mengganti GIF dengan video AV1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>