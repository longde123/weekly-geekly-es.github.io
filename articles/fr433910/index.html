<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤥 🚴🏿 👁️ Réflexions sur la rouille 2019 👱🏿 🧚🏼 👨‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chers collègues, bonsoir à tous! 

 Nous sommes heureux de vous offrir la traduction d'un article véritablement programmatique de Raf Levin , dont le ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Réflexions sur la rouille 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/433910/"> Chers collègues, bonsoir à tous! <br><br>  Nous sommes heureux de vous offrir la traduction d'un article véritablement programmatique de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Raf Levin</a> , dont le travail titanesque sur le développement du langage Rust évoque le respect et la révérence: <br><br><img src="https://habrastorage.org/webt/je/yt/3m/jeyt3m5cfmarrq_odmzjjdpxsmm.png"><br><br>  Sans fausse modestie et sans haine, un auteur respecté objectivement et avec enthousiasme a répondu à l'appel de la communauté Rust, publié par référence au début de cet article.  Nous espérons que cela s'est avéré intéressant et révélateur de vie. <br><a name="habracut"></a><br><br>  Récemment, l'équipe Rust Core a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">proposé d'écrire des articles</a> avec des opinions sur la façon dont Rust devrait se développer en 2019.  Voici mon avis. <br><br>  <b>Maturation du cycle de vie</b> <br><br>  Dans cet article, je considérerai le cycle de vie de la maturation sous une forme extrêmement simplifiée.  Qu'il se compose de seulement trois étapes: recherche, développement, polissage.  Les différents éléments de la rouille diffèrent par leur degré de maturité variable.  Ceci est important à considérer lorsque vous essayez de caractériser avec précision le stade actuel du développement du langage et, idéalement, de le faire passer au stade suivant.  Par exemple, il me semble que la langue est principalement au stade du «polissage».  Si vous persistez dans le fait que l'étape de «recherche» n'est pas encore terminée, alors le langage peut être enrichi de types dépendants, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de structures virtuelles</a> , etc., ce qui serait intéressant, mais contre-productif.  L'inverse est également vrai: nous ne pouvons pas formuler exactement ce qui nous manque dans l'interface utilisateur graphique, de sorte que les tentatives prématurées pour amener ces recherches à une solution standard risquent d'entraîner des résultats sous-optimaux. <br><br>  Dans de nombreux produits matures, les versions alternent, dont certaines sont consacrées à l'exécution de nouvelles fonctionnalités, tandis que d'autres sont consacrées à leur stabilisation.  Tel est, par exemple, le système tick-tock d'Intel.  Les versions Android de Kat Kit et Marshmallow étaient stables, tandis que Lollipop était activement en train de pelleter).  En 2018, Rust a été enrichi de nombreuses nouvelles fonctionnalités, je pense donc que le moment est venu pour la phase de stabilisation.  En cela, je suis d'accord avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jonathan Turner</a> , ainsi qu'avec de nombreux autres. <br><br>  <b>Langue rouille</b> <br><br>  Je pense que, dans l'ensemble, la langue Rust est prête.  Il semble que la communauté ait convenu de la nécessité de «débarquer» les fonctionnalités qui sont toujours «à la volée» (en cours de développement): nous parlons d'async / wait, de const génériques et d'un interprète (qui est susceptible de nous fournir une révision <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">types génériques associés</a> ).  Cependant, je pense qu'en plus de cela, nous ne devons pas être trop zélés pour remplir le pipeline de nouvelles fonctionnalités. <br><br>  Le changement coûte de l'argent.  En 2018, deux excellents livres ont été écrits sur Rust, mais les deux sont déjà légèrement dépassés.  Les conventions pour les chemins qualifiés diffèrent en eux, maintenant nous utilisons <code>dyn Trait</code> , etc.  Plus les changements sont dynamiques, plus les utilisateurs sont gênés. <br><br>  Il existe de nombreux facteurs qui limitent le succès de Rust;  Je ne pense pas que la plupart de ces lacunes soient inhérentes à la langue elle-même. <br><br>  <b>Gréement</b> <br><br>  Un gréement Rust aurait pu être bien mieux.  J'ai expérimenté avec RLS, mais je suis toujours retourné à un éditeur de texte normal et à une boucle de ligne de commande (pour être honnête, je n'ai pas défini de telles expériences récemment).  Je pense qu'à long terme, il est nécessaire de modifier considérablement les outils Rust pour au moins en quelque sorte faciliter la courbe d'apprentissage.  J'ai quelques idées (j'espère qu'il est temps de les expliquer plus en détail) sur une langue plus chaude, dont je ne sais pas où c'est faisable, où il n'y aurait pas de différence claire entre la valeur et le lien, la valeur pourrait être utilisée après le déménagement, etc. .  En principe, un tel langage permettrait à une chaîne d'être traitée comme un nombre.  Le serveur accepte les programmes écrits dans cette langue, les corrige rapidement et les convertit en une rouille à part entière. <br><br>  Naturellement, RLS ne correspond qu'à la moitié à cela, les utilisateurs interagissent avec lui via l'éditeur.  Travailler avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">xi-editor est</a> pratique, bien qu'il nécessite généralement quelques conseils et assistance.  Ce travail a été entrepris par une communauté dirigée par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Colin Rofles</a> , et je suis juste heureux de voir comment cet éditeur s’améliore (il est déjà devenu mon principal éditeur).  Il prend en charge le serveur de langue, ainsi que de nouvelles fonctionnalités, par exemple, un mécanisme d'annotation général, qui sera beaucoup mieux finalisé en 2019. <br><br>  <b>Écosystème de bibliothèque</b> <br><br>  Le travail le plus en vogue bat son plein dans la création de bibliothèques pour Rust.  Ci-dessous, j'énumère les choses que j'ai l'intention de faire moi-même. <br><br>  L'un des sujets que je voudrais aborder est la «cohérence», qui, à mon avis, est l'une des caractéristiques les plus précieuses de Rust, avec la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composante technique de son système de typage</a> .  De nombreux composants du «moteur de jeu» dans C ++ sont une sélection soigneusement préparée de bibliothèques qui interagissent bien entre elles.  Mais à Rust, beaucoup de ces choses se produisent de manière organique.  Les conteneurs sont généralement affûtés pour une utilisation en bundles, et si vous utilisez correctement des choses comme <code>into</code> , alors tout va de mieux en mieux.  Un exemple particulièrement convaincant du deuxième type est la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">menthe</a> , qui assure l'interopérabilité de nombreux conteneurs mathématiques, même si les conventions utilisées pour définir les types de vecteurs ne coïncident pas en elles. <br><br>  <b>SIMD</b> <br><br>  Je pense que les bibliothèques SIMD sont toujours sous enquête.  Il existe de nombreuses bibliothèques d'encapsuleurs, chacune offrant une perspective légèrement différente et un ensemble différent de compromis: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">simdeez</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pack_simd</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus rapide</a> et, bien sûr, mon propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fearless_simd</a> .  Ces compromis sont loin d'être inconditionnels, car certains utilisateurs devront éliminer toutes les performances de la langue jusqu'à la dernière goutte et, si vous gravitez à de tels extrêmes, vous devrez recourir aux meilleures instructions pour des processeurs spécifiques.  D'autres apprécieront la portabilité et la sécurité. <br><br>  L'un des bogues SIMD les plus importants est que beaucoup plus de travail doit être fait dans le compilateur, principalement pour l'interaction avec les architectures SIMD AVX-512 et non x86.  Il est également possible que les bibliothèques d'encapsuleur nécessitent des modifications au niveau de la langue pour rendre le travail aussi pratique que possible;  Donc, pour le moment, l'intégration et <code>cfg(target_feature = ...)</code> interagissent mal.  À mon avis, c'est un autre problème qui nécessite des recherches.  Il est intéressant de comprendre jusqu'où nous pouvons aller sans prise en charge supplémentaire au niveau de la langue, et quelles fonctionnalités exactement aideront à augmenter fondamentalement la commodité de travailler avec elle? <br><br>  <b>Audio</b> <br><br>  Il existe des conteneurs audio de bas niveau pratiques, parmi lesquels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cpal</a> doit être particulièrement noté.  Cependant, il peut y avoir des difficultés au niveau des performances (le conteneur n'utilise pas toujours le flux en temps réel), quelques possibilités.  Il est nécessaire de trouver le moyen optimal: soit modifier cpal, soit développer un nouveau conteneur qui corrigerait des problèmes spécifiques.  Pour cela, en particulier, vous devez examiner attentivement les bibliothèques C ++, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RtAudio</a> , qui résolvent bien ces problèmes. <br><br>  Pour une synthèse audio de niveau supérieur, j'ai de grands projets pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">synthétiser-rs</a> .  Cette option ne convient pas à tout le monde, mais je pense que c'est une bonne base pour une variété de techniques de synthèse et d'effets audio.  Il semble qu'aujourd'hui ce domaine se situe entre les étapes de la recherche et du développement. <br><br>  Pour suivre cela, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le flux #synthesizer</a> dans notre chat Zulip.  En novembre, j'ai donné une conférence à ce sujet, sur la base de laquelle je prévois d'écrire prochainement un article. <br><br>  <b>GUI</b> <br><br>  Les interfaces utilisateur graphiques sont actuellement l'un des points faibles de Rust.  Je pense qu'en 2019, nous verrons beaucoup d'articles sur ce sujet dans la communauté Rust. <br>  Personnellement, il me semble que les GUI de Rostov devraient désormais être attribuées à la phase «recherche».  De nombreuses approches alternatives sont en cours d'élaboration et, jusqu'à présent, il n'y a pas de consensus sur la meilleure d'entre elles.  Dans quelle mesure les graphiques 2D et les autres primitives d'interface utilisateur doivent-ils être utilisés activement dans l'architecture du système, ou devons-nous implémenter cette pile entièrement par nous-mêmes?  Le déploiement sur le Web est-il nécessaire (à l'aide de wasm)?  Le processus de programmation dans son ensemble doit-il être perçu comme «natif de Rust», ou vaut-il mieux s’adapter aux conventions établies dans certaines interfaces graphiques matures?  La communauté Rust dispose-t-elle de suffisamment de ressources pour créer une nouvelle boîte à outils GUI, et si oui, cela en vaut-il la peine? <br><br>  J'ai commencé un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Druid</a> pour créer une interface graphique pour mon synthétiseur et mon jeu, mais ce projet est un projet de recherche.  Il présente mon point de vue, mes réponses à toutes les questions formulées ci-dessus et, à mon avis, ce projet se développe bien.  Mais, je le répète, il s'agit d'un projet de recherche, et il serait très stupide à ce stade de l'introduire dans d'autres projets. <br><br>  En outre, un certain nombre d'autres projets de développement d'interface graphique sont en cours.  À mon avis, le plus prometteur d'entre eux est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Azul</a> , car j'aime WebRender comme base pour la construction d'une interface graphique.  Un autre projet très prometteur est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OrbTK</a> , réalisé sur la base de Redox, mais multiplateforme et vraiment avancé.  Vous pouvez apprendre beaucoup des exemples de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Conrod</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ggez</a> , ainsi que des wrappers d'outils d'autres langues. <br><br>  Sans surprise, l'activité de développement d'interface graphique la plus intense dans Rust est étroitement liée aux jeux, et il me semble que c'est bien.  Les innovations prennent mieux racine dans le segment des jeux, et le besoin d'outils matures n'est pas si aigu ici.  Mais, dès qu'une excellente approche de la mise en œuvre de l'interface graphique dans Rust apparaît, je pense qu'elle trouvera l'application la plus large.  Je note également que mon Druide est né sur la base du niveau GUI de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">éditeur client xi pour Windows</a> . <br><br>  <b>Marquage</b> <br><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque pulldown-cmark est</a> assez bien utilisée, en particulier pour rustdoc, mais est déconseillée à certains égards.  Son évolution ne suit pas le développement de la spécification CommonMark.  L'une des raisons pour lesquelles il est resté un peu bloqué est l'algorithme d'analyse;  J'ai déjà une idée de comment écrire un nouvel algorithme à cet effet, bien mieux qu'auparavant;  mais je n'ai pas encore travaillé sur les détails.  Récemment, je suis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">revenu sur ce travail</a> et je me prépare à publier un algorithme.  Lorsque la branche <code>new_algo</code> ajoutée à master, je pense que la communauté devrait poursuivre son développement, l'enrichir de nouvelles fonctionnalités.  Je pense à la compatibilité GFM complète, aux mathématiques et peut-être à quelque chose d'autre comme ça. <br><br>  Merci à tous les membres de la communauté de Rust d'avoir finalisé la langue avec laquelle j'aime vivre. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433910/">https://habr.com/ru/post/fr433910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433900/index.html">ICQ est mort. Vive ICQ?</a></li>
<li><a href="../fr433902/index.html">Répétition pour un programmeur: pourquoi il est important de résoudre des problèmes similaires</a></li>
<li><a href="../fr433904/index.html">Jira DataCenter - qu'est-ce que c'est? Comment ça marche? Comment déployer?</a></li>
<li><a href="../fr433906/index.html">Problèmes d'utilisation de la fonction NtQuerySystemInformation avec des arguments non documentés</a></li>
<li><a href="../fr433908/index.html">Tetris en C # en 100 lignes</a></li>
<li><a href="../fr433912/index.html">Vous voulez attirer les meilleurs ingénieurs? Code ouvert</a></li>
<li><a href="../fr433916/index.html">Allez communauté à Kazan et nos réunions</a></li>
<li><a href="../fr433918/index.html">Pourquoi le Web est-il si compliqué?</a></li>
<li><a href="../fr433920/index.html">Le géant chinois du silicium polycristallin augmente sa capacité</a></li>
<li><a href="../fr433922/index.html">Kubernetes Intensive: Support Jobs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>