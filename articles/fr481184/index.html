<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌦️ 📘 🔟 Top 10 des bugs trouvés dans les projets Java en 2019 📿 👨‍👩‍👧‍👧 📣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2019 touche à sa fin et l'équipe de PVS-Studio revient sur les réalisations de cette année. Au début de 2019, nous avons amélioré les capacités de dia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 des bugs trouvés dans les projets Java en 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481184/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/uy/oe/n2uyoeo7ko6owq_omdtzx419gty.png"></div><br>  2019 touche à sa fin et l'équipe de PVS-Studio revient sur les réalisations de cette année.  Au début de 2019, nous avons amélioré les capacités de diagnostic de notre analyseur en ajoutant la prise en charge Java, ce qui nous a également permis de vérifier et d'examiner les projets Java.  Nous avons trouvé beaucoup de bogues au cours de cette année, et voici notre Top 10 des bogues trouvés dans les projets Java. <br><a name="habracut"></a><br><br><h2>  Non.  10: octet signé </h2><br>  Source: <a href="https://www.viva64.com/en/b/0663/">Analyse du framework RPC Apache Dubbo par l'analyseur de code statique PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 L'</a> expression 'endKey [i] &lt;0xff' est toujours vraie.  OptionUtil.java (32) <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ByteSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixEndOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteSequence prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] endKey = prefix.getBytes().clone(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = endKey.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endKey[i] &lt; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= endKey[i] = (byte) (endKey[i] + 1); return ByteSequence.from(Arrays.copyOf(endKey, i + 1)); } } return ByteSequence.from(NO_PREFIX_END); }</span></span></code> </pre> <br>  De nombreux programmeurs pensent que le type d' <i>octet</i> n'est pas signé.  C'est en effet le cas dans de nombreux langages de programmation.  Par exemple, cela est vrai pour C #.  Mais ce n'est pas le cas en Java. <br><br>  Dans la condition <i>endKey [i] &lt;0xff</i> , une variable de type <i>octet</i> est comparée au nombre 255 (0xff) représenté sous forme hexadécimale.  Le développeur a probablement oublié que la plage du type d' <i>octet</i> Java est [-128, 127].  Cette condition sera toujours vraie et la boucle <i>for</i> ne traitera toujours que le dernier élément du tableau <i>endKey</i> . <br><br><h2>  Non.  9: Deux en un </h2><br>  Source: <a href="https://www.viva64.com/en/b/0621/">PVS-Studio pour Java prend la route.</a>  <a href="https://www.viva64.com/en/b/0621/">Le prochain arrêt est Elasticsearch</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 L'</a> expression '(int) x &lt;0' est toujours fausse.  BCrypt.java (429) <br><br>  <a href="https://www.viva64.com/en/w/v6025/">V6025 L'</a> index '(int) x' est peut-être hors limites.  BCrypt.java (431) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &gt; index_64.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index_64[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x]; }</code> </pre> <br>  Remise!  Une méthode - deux bugs!  Le premier concerne le type <i>char</i> : puisqu'il n'est pas signé en Java, la condition <i>(int) x &lt;0</i> sera toujours fausse.  Le deuxième bogue est l'indexation ordinaire au-delà des limites du tableau <i>index_64</i> lorsque <i>(int) x == index_64.length</i> .  Cela se produit en raison de la condition <i>(int) x&gt; index_64.length</i> .  Le bogue peut être corrigé en changeant l'opérateur '&gt;' en '&gt; =': <i>(int) x&gt; = index_64.length</i> . <br><br><h2>  Non.  8: Une solution et ses implications </h2><br>  Source: <a href="https://www.viva64.com/en/b/0626/">Analyse du code de la plateforme CUBA avec PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007 L'</a> expression 'previousMenuItemFlatIndex&gt; = 0' est toujours vraie.  CubaSideMenuWidget.java (328) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MenuItemWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNextMenuItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MenuItemWidget currentItem)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;MenuTreeNode&gt; menuTree = buildVisibleTree(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); List&lt;MenuItemWidget&gt; menuItemWidgets = menuTreeToList(menuTree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> menuItemFlatIndex = menuItemWidgets.indexOf(currentItem); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previousMenuItemFlatIndex = menuItemFlatIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousMenuItemFlatIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return menuItemWidgets.get(previousMenuItemFlatIndex); } return null; }</span></span></code> </pre> <br>  L'auteur de la méthode <i>findNextMenuItem</i> voulait se débarrasser de la valeur -1 renvoyée par la méthode <i>indexOf</i> lorsque la liste <i>menuItemWidgets</i> ne contient pas <i>currentItem</i> .  Pour ce faire, le programmeur ajoute 1 au résultat d' <i>indexOf</i> (la variable <i>menuItemFlatIndex</i> ) et écrit la valeur résultante dans la variable <i>previousMenuItemFlatIndex</i> , qui est ensuite utilisée dans la méthode.  L'ajout de -1 s'avère être une mauvaise solution car il conduit à plusieurs erreurs à la fois: <br><br><ul><li>  L'instruction <i>return null</i> ne sera jamais exécutée car l'expression <i>précédenteMenuItemFlatIndex&gt; = 0</i> sera toujours vraie;  par conséquent, la méthode <i>findNextMenuItem</i> retournera toujours à partir de l'instruction <i>if</i> ; </li><li>  une <i>IndexOutOfBoundsException</i> sera levée lorsque la liste <i>menuItemWidgets</i> est devenue vide puisque le programme tentera d'accéder au premier élément de la liste vide; </li><li>  une <i>IndexOutOfBoundsException</i> sera levée lorsque l'argument <i>currentItem</i> est devenu le dernier élément de la liste <i>menuItemWidget</i> . </li></ul><br><h2>  Non.  7: Créer un fichier à partir de rien </h2><br>  Source: <a href="https://www.viva64.com/en/b/0688/">Huawei Cloud: c'est nuageux dans PVS-Studio aujourd'hui</a> <br><br>  <a href="https://www.viva64.com/en/w/v6008/">V6008 Déréférence</a> nulle potentielle de 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return; } } .... }</span></span></code> </pre> <br>  Lors de l'écriture de la méthode <i>putToCache</i> , le programmeur a fait une faute de frappe dans la condition <i>dataTmpFile == null ||</i>  <i>! dataTmpFile.exists ()</i> avant de créer un nouveau fichier <i>dataTmpFile.createNewFile ()</i> : ils ont écrit l'opérateur '==' au lieu de '! ='.  Cette faute de frappe entraînera la <i>levée d'une exception</i> <i>NullPointerException</i> lors de l'appel de la méthode <i>createNewFile</i> .  Voici à quoi ressemble la condition avec la faute de frappe corrigée: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists())</code> </pre> <br>  Vous pourriez penser: «Eh bien, d'accord, nous pouvons nous détendre maintenant.» Pas encore! <br><br>  Maintenant qu'un bug a été corrigé, un autre est apparu.  Une <i>exception NullPointerException</i> peut être levée lors de l'appel de la méthode <i>dataTmpFile.exists ()</i> .  Pour résoudre ce problème, nous devons remplacer le '||'  opérateur avec '&amp;&amp;'.  Il s'agit de la version finale de la condition, après toutes les corrections: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Non.  6: Une erreur logique très étrange </h2><br>  Source: <a href="https://www.viva64.com/en/b/0603/">PVS-Studio pour Java</a> <br><br>  <a href="https://www.viva64.com/en/w/v6007/">V6007</a> [CWE-570] L'expression "" 0 ".equals (texte)" est toujours fausse.  ConvertIntegerToDecimalPredicate.java 46 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@NonNls</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) {<span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } return text.charAt(0) == '0'; }</span></span></code> </pre> <br>  La chose intéressante à propos de cette méthode est qu'elle contient une erreur logique évidente.  Si la méthode <i>satisfaiteBy</i> ne retourne pas après la première instruction <i>if</i> , cela signifie que la chaîne de <i>texte</i> comporte au moins deux caractères.  Cela signifie également que la toute première vérification <i>"0" .equals (texte)</i> dans la prochaine instruction <i>if</i> n'a pas de sens.  Ce que le programmeur voulait réellement dire par là reste un mystère. <br><br><h2>  Non.  5: Quelle torsion! </h2><br>  Source: <a href="https://www.viva64.com/en/b/0657/">PVS-Studio visite Apache Hive</a> <br><br>  <a href="https://www.viva64.com/en/w/v6034/">V6034 Le</a> décalage de la valeur de 'bitShiftsInWord - 1' peut ne pas correspondre à la taille du type: 'bitShiftsInWord - 1' = [-1 ... 30].  UnsignedInt128.java (1791) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Avec les arguments d'entrée <i>wordShifts = 3</i> et <i>bitShiftsInWord = 0</i> , la variable <i>roundCarryMask</i> , qui stocke le résultat du décalage au niveau du bit <i>(1 &lt;&lt; (bitShiftsInWord - 1))</i> , deviendra un nombre négatif.  Le développeur ne s'y attendait probablement pas. <br><br><h2>  Non.  4: Pouvons-nous voir les exceptions s'il vous plaît? </h2><br>  Source: <a href="https://www.viva64.com/en/b/0657/">PVS-Studio visite Apache Hive</a> <br><br>  <a href="https://www.viva64.com/en/w/v6051/">V6051</a> L'utilisation de l'instruction 'return' dans le bloc 'finalement' peut entraîner la perte d'exceptions non gérées.  ObjectStore.java (9080) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;MPartitionColumnStatistics&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMPartitionColumnStatistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NoSuchObjectException, MetaException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> committed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  La déclaration de la méthode <i>getMPartitionColumnStatistics</i> est trompeuse car elle dit qu'elle pourrait lever une exception.  En réalité, quelle que soit l'exception générée dans le bloc <i>try</i> , la variable validée sera toujours <i>fausse</i> , donc l'instruction <i>return</i> dans le bloc <i>finally</i> renverra une valeur, tandis que toutes les exceptions levées seront perdues et ne pourront pas être traitées en dehors de la méthode.  Ainsi, aucune des exceptions levées dans cette méthode ne pourra la quitter. <br><br><h2>  Non.  3: Hocus-pocus, ou essayer d'obtenir un nouveau masque </h2><br>  Source: <a href="https://www.viva64.com/en/b/0657/">PVS-Studio visite Apache Hive</a> <br><br>  <a href="https://www.viva64.com/en/w/v6034/">V6034 Le</a> décalage de la valeur de 'j' peut être incompatible avec la taille du type: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Ce bug, aussi, a à voir avec un décalage au niveau du bit, mais pas seulement.  La variable <i>j</i> est utilisée comme compteur sur la plage [0 ... 63] dans la boucle <i>for</i> interne.  Ce compteur participe à un décalage au niveau du bit <i>1 &lt;&lt; j</i> .  Tout semble correct, mais voici où le littéral entier '1' de type <i>int</i> (une valeur de 32 bits) entre en jeu.  À cause de cela, le décalage au niveau du bit commencera à renvoyer les valeurs précédemment renvoyées lorsque la valeur de la variable <i>j</i> a dépassé 31. Si ce comportement n'est pas ce que le programmeur voulait, la valeur 1 doit être représentée aussi <i>longtemps</i> : <i>1L &lt;&lt; j</i> ou <i>(long) 1 &lt;&lt; j</i> . <br><br><h2>  Non.  2: Ordre d'initialisation </h2><br>  Source: <a href="https://www.viva64.com/en/b/0688/">Huawei Cloud: c'est nuageux dans PVS-Studio aujourd'hui</a> <br><br>  <a href="https://www.viva64.com/en/w/v6050/">Le</a> cycle d'initialisation de la classe <a href="https://www.viva64.com/en/w/v6050/">V6050</a> est présent.  L'initialisation de 'INSTANCE' apparaît avant l'initialisation de 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  L'ordre dans lequel les champs sont déclarés dans une classe fait une différence car ils sont initialisés dans le même ordre qu'ils sont déclarés.  Oublier ce fait conduit à des bugs insaisissables comme celui ci-dessus. <br><br>  L'analyseur souligne que le champ statique <i>LOG</i> est déréférencé dans le constructeur au moment où il est initialisé à la valeur <i>null</i> , ce qui conduit à lever une série d'exceptions <i>NullPointerException</i> -&gt; <i>ExceptionInInitializerError</i> . <br><br>  Mais pourquoi le champ statique <i>LOG</i> a-t-il la valeur <i>null</i> au moment d'appeler le constructeur? <br><br>  L' <i>ExceptionInInitializerError</i> est l'indice.  Le constructeur initialise le champ statique <i>INSTANCE</i> , qui est déclaré avant le champ <i>LOG</i> .  C'est pourquoi le champ <i>LOG</i> n'est pas encore initialisé lorsque le constructeur est appelé.  Pour que ce code fonctionne correctement, le champ <i>LOG</i> doit être initialisé avant l'appel. <br><br><h2>  Premièrement: programmation orientée copier-coller </h2><br>  Source: <a href="https://www.viva64.com/en/b/0697/">Apache Hadoop Code Qualité: Production VS Test</a> <br><br>  <a href="https://www.viva64.com/en/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «localFiles» devrait être utilisée à la place de «localArchives».  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  La première place sur notre liste Top 10 est attribuée au copier-coller, ou plutôt à un bug qui découle de l'utilisation imprudente de cette technique.  La seconde instruction <i>if</i> ressemble beaucoup à une copie de la première, avec certaines des variables modifiées: <br><br><ul><li>  <i>localArchives a</i> été remplacé par <i>localFiles</i> ; </li><li>  <i>MRJobConfig.CACHE_LOCALARCHIVES a</i> été remplacé par <i>MRJobConfig.CACHE_LOCALFILES</i> . </li></ul><br>  Mais le programmeur a réussi à faire une erreur même dans cette opération simple: l'instruction <i>if</i> dans la ligne indiquée par l'analyseur utilise toujours la variable <i>localArchives</i> au lieu de la variable <i>localFiles</i> apparemment voulue. <br><br><h2>  Conclusion </h2><br>  La correction des bogues détectés aux stades de développement ultérieurs ou après la publication nécessite beaucoup de ressources.  L'analyseur statique PVS-Studio vous permet de détecter les bogues au stade du codage, ce qui le rend beaucoup plus facile et moins cher.  De nombreuses <a href="https://www.viva64.com/en/customers/">entreprises</a> ont déjà simplifié la vie de leurs développeurs en commençant à utiliser régulièrement l'analyseur.  Si vous voulez vraiment apprécier votre travail, essayez <a href="https://www.viva64.com/en/pvs-studio-download/">PVS-Studio</a> . <br><br>  Nous n'allons pas nous arrêter à cela et prévoyons continuer à améliorer et à améliorer notre outil.  Restez à l'écoute pour de nouveaux diagnostics et articles avec des bogues encore plus intéressants l'année prochaine. <br><br>  Je te vois comme des aventures!  Tout d'abord, vous avez vaincu <a href="https://habr.com/en/company/pvs-studio/blog/481174/">les 10 principaux bogues du projet C # en 2019</a> et maintenant vous avez également géré Java!  Bienvenue au niveau suivant - l'article sur les <a href="https://habr.com/en/company/pvs-studio/blog/481188/">meilleures erreurs dans les projets C ++ en 2019</a> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/24/2j/ex/242jexzqwnmth1lyfcrr8icxmms.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481184/">https://habr.com/ru/post/fr481184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481174/index.html">Top 10 des bugs trouvés dans les projets C # en 2019</a></li>
<li><a href="../fr481176/index.html">Couriers Yandex.Le Food and Delivery Club a besoin d'un syndicat</a></li>
<li><a href="../fr481178/index.html">Top 10 des bugs dans les projets C # pour 2019</a></li>
<li><a href="../fr481180/index.html">Les développeurs doivent-ils recevoir des suggestions des utilisateurs?</a></li>
<li><a href="../fr481182/index.html">Istio Service Mesh Posts Series</a></li>
<li><a href="../fr481186/index.html">Top 10 des bugs dans les projets Java pour 2019</a></li>
<li><a href="../fr481188/index.html">Top 10 des bugs trouvés dans les projets C ++ en 2019</a></li>
<li><a href="../fr481190/index.html">Top 10 des bugs dans les projets C ++ pour 2019</a></li>
<li><a href="../fr481200/index.html">Voice Control et VoiceOver: comment adapter l'application pour les aveugles ou encore</a></li>
<li><a href="../fr481202/index.html">Antiquités: le principe de la collecte des ordures et les résultats de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>