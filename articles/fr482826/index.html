<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜó ‚ÜñÔ∏è üë©üèø‚ÄçüöÄ Analyser une d√©mo de 128 octets √† partir des archives de 1997 üî° üåÆ üé≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C'est tr√®s agr√©able de r√©aliser mes d√©sirs, surtout d'un pass√© lointain, si lointain que j'ai d√©j√† oubli√© que je le voulais une fois. Je connais peu l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyser une d√©mo de 128 octets √† partir des archives de 1997</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/"> C'est tr√®s agr√©able de r√©aliser mes d√©sirs, surtout d'un pass√© lointain, si lointain que j'ai d√©j√† oubli√© que je le voulais une fois.  Je connais peu la d√©mosc√®ne et je n'ai certainement jamais suivi les auteurs ou leur travail, j'ai juste aim√© regarder ce qui s'est pass√©.  Parfois, je voulais comprendre, mais ensuite je manquais de connaissances et d'exp√©rience, plus tard de pers√©v√©rance, puis j'ai compl√®tement perdu tout int√©r√™t pour cela.  Mais r√©cemment, mon ami, avec qui nous avons √©tudi√© √† l'√©poque et qui nous a fourni tous les nouveaux produits, y compris les d√©mos, avec BBS et Fidonet, car il avait presque tous √† la fois un t√©l√©phone et un modem et un ordinateur, a rendu visite √† <a href="https://cafeparty.org.ru/2019/" rel="nofollow">CAFePARTY</a> avec son travail cela m'a fait ouvrir les archives de mon premier ordinateur, s√©lectionner une d√©mo et la d√©couvrir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br>  √âvaluant objectivement mes forces, j'ai pris une intro de 128 octets que j'ai aim√© visuellement.  Le fichier <code>pentagra.com</code> est sign√© par <b>Mcm</b> , 128 octets, derni√®re modification le 9/24/1996 18:10:14, vidage hexad√©cimal: <br><br> <code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42 <br> 000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40 <br> 000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03 <br> 000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7 <br> 000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab <br> 000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88 <br> 000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c <br> 000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d <br></code> <a name="habracut"></a><br>  De la m√™me archive, je me suis retir√©: <br><br><ul><li>  <b>Hiew 6.11</b> ( <a href="http://www.hiew.ru/" rel="nofollow">6.50</a> peut √™tre trouv√© sur le site) - Je l'ai utilis√© comme d√©monteur </li><li>  Package <b>TASM</b> - avec lequel j'ai r√©cup√©r√© le code re√ßu pour m'assurer que je n'ai rien g√¢ch√© </li><li>  <b>Aide TECH de Flambeaux Software!</b>  <b>6.0</b> - r√©f√©rence en ligne mod√©r√©ment d√©taill√©e et compl√®te pour l'API DOS, les fonctions du BIOS, le mat√©riel et l'assembleur </li><li>  <b>Mayko G.V.</b>  <b>Assembleur pour IBM PC</b> - une r√©f√©rence de format presque au format de poche pour toutes les commandes de base Intel 8086 et les r√®gles de formatage du texte du programme.  Sans d√©tails architecturaux et avec des exemples √©l√©mentaires, seules les choses les plus √©l√©mentaires.  Il y a presque tout ce dont vous avez besoin ici, mais vous ne pouvez pas √©crire dans l'assembleur en dehors de l'environnement. </li><li>  Par cons√©quent, le deuxi√®me livre <b>Zubkov S.V.</b>  <b>Assembleur.</b>  <b>Pour DOS, Windows et Unix</b> - Guide des coins mat√©riels et DOS </li></ul><br>  De l'impl√©mentation minimale extr√™me, il faut s'attendre √† l'utilisation d'astuces et d'approches non standard, mais √† part quelques hypoth√®ses dans les conditions initiales, je n'ai pas vu d'astuces techniques, mais j'ai vu une astuce algorithmique.  Et voici quelques mots sur l'exp√©rience.  Quelle pourrait √™tre la difficult√©?  Soit dans l'impl√©mentation, soit dans l'algorithme.  Par exemple, dans la commande <code>mov di, 099d1h</code> , vous pourriez avoir peur d'une constante magique.  Mais si vous √™tes dans le contexte d'utilisation, il devient clair qu'il s'agit de l'adresse d'acc√®s aux coordonn√©es d'√©cran X et Y, o√π X = 17, Y = 123, 320 est la r√©solution horizontale de l'√©cran en pixels.  Ensemble, cela nous donne 17 + 123 * 320, la conversion des coordonn√©es bidimensionnelles en une dimension. <br><br>  En regardant maintenant ce qui se passe √† l'√©cran, je peux facilement imaginer comment je pourrais l'impl√©menter, m√™me si ce n'est pas avec 128 octets, m√™me s'il n'est pas 100% similaire, mais je le pourrais.  Et il y a 20 ans, je ne le pouvais pas, bien que j'aie sorti tous les outils que j'utilisais des √©tag√®res poussi√©reuses et que je n'√©tais pas oblig√© de naviguer sur Internet pour comprendre comment cela fonctionnait.  Par cons√©quent, tout d'abord, c'est un contexte, une compr√©hension de ce qui se passe, et donc la question des astuces et COMMENT faire cela est en deuxi√®me place. <br><br>  Que voyons-nous: <br><br><ol><li>  5 lignes du pentagramme.  Ce ne sont pas n√©cessairement des lignes directes inextricables selon tous les canons.  Nous ne voyons que la figure g√©n√©rale, sans d√©tails </li><li>  L'effet de flamme, qui se compose de deux parties importantes: une palette correctement s√©lectionn√©e et un algorithme pour changer constamment la couleur des points sur l'√©cran avec des √©l√©ments d'incertitude, mais en maintenant une s√©quence de palette continue pour les points voisins.  Par exemple, vous pouvez calculer l'int√©gralit√© de l'√©cran actuel en faisant la moyenne des valeurs des pixels voisins de l'√©cran pr√©c√©dent, et ajouter plus de points ¬´lumineux¬ª √† des endroits al√©atoires, ou pas √† des endroits al√©atoires, mais de valeur al√©atoire, ou pas du tout par hasard, √©loignez-vous simplement de l'ordre lin√©aire.  Une option est de <a href="https://habr.com/ru/post/435122/">savoir comment cela se fait dans DOOM</a> .  Le r√©sultat doit se pr√©senter sous la forme de couleurs qui s‚Äô√©coulent les unes dans les autres, des zones lumineuses √©mergentes en permanence √† la d√©coloration </li></ol><br>  Reste √† comprendre comment cela a √©t√© fait.  Une description plus d√©taill√©e ne remplacera pas les connaissances sur l'architecture informatique et les fonctions DOS ou assembleur, mais avoir ces connaissances vous permettra de comprendre et de vous concentrer sur l'essence de ce qui se passe.  Ayant commenc√© √† √©crire, je me suis rendu compte que cela se passait quand m√™me assez en d√©tail, mais je ne pouvais pas le refuser pour ne pas perdre au sens de l'histoire. <br><br><h3>  DOS et chargement de programmes .COM </h3><br>  Le programme dans le fichier <code>.com</code> est un code propre, pas d'en-t√™tes, il vous suffit de le mettre au bon endroit.  C'est ce que fait DOS, ou plut√¥t l'appel syst√®me 4Bh.  Beaucoup d'actions se d√©roulent, arr√™tons-nous sur le r√©sultat: <br><br><ul><li>  Tous les registres de segments CS, DS, ES, SS charg√©s avec une seule valeur </li><li>  65536 octets sont r√©serv√©s pour l'ensemble du programme, exactement un segment auquel tous les registres de segments indiquent.  Les 256 premiers octets sont occup√©s par l'en-t√™te du syst√®me - PSP (Program Segment Prefix).  √Ä CS: 0, le premier champ de la PSP, la commande INT 20h se trouve - pour terminer le programme en cours et transf√©rer le contr√¥le au processus parent.  Le programme lui-m√™me d√©marre avec l'adresse CS: 100h et occupe les 128 octets suivants </li><li>  Le mot 0000h est pouss√© sur la pile, le registre SP est FFFEh.  Cela signifie que les deux derniers octets de ce segment √† l'adresse SS: FFFEh sont r√©initialis√©s.  En fait, c'est l'adresse de retour la plus proche de la proc√©dure, ce qui nous m√®nera √† la commande d'ach√®vement sur CS: 0 </li><li>  Les registres AL et AH contiennent un indicateur d'erreur pour d√©terminer les lettres de lecteur √† partir du premier et du deuxi√®me argument lorsque le programme est appel√©.  S'il n'y a pas d'erreurs, alors elles sont 0, s'il y a alors FFh </li></ul><br>  Je croyais sinc√®rement que dans le cas g√©n√©ral le statut des registres n'est pas d√©fini.  Mais dans le code analys√©, √† mon avis, une hypoth√®se tr√®s audacieuse est faite sur leur √©tat initial, en particulier sur les registres CX, SI et l'indicateur de direction DF.  Je n'ai pas trouv√© de confirmation de cela dans la liste des sources qui a r√©sult√© ci-dessus, alors je suis all√© chercher dans les sources <a href="" rel="nofollow">MS-DOS 2.0</a> : <br><br><ul><li>  Concernant DF, nous pouvons supposer qu'il a √©t√© r√©initialis√© par la commande <code>cld</code> , car cette derni√®re utilise la direction avant avant de transf√©rer le contr√¥le aux sauts de ligne, par cons√©quent, DF est r√©initialis√©.  Bien qu'il n'y ait pas d'utilisation explicite de <code>cld</code> √† cet endroit, la commande pour effacer l'indicateur de direction est rencontr√©e assez souvent avant de nombreux autres transferts </li><li>  SI contient 100h, car il est utilis√© pour d√©terminer le d√©calage qui sera charg√© dans le registre par le compteur de commandes IP </li><li>  CX est √©gal √† FFh, car il est utilis√© comme compteur avec une valeur initiale de 80h pour transf√©rer le contenu de la ligne de commande enti√®re et, par cons√©quent, apr√®s le transfert, il est 0. Et apr√®s cela, CL, en tant que variable temporaire, charge FFh et est utilis√© pour d√©finir l'indicateur d'erreur de la lettre de lecteur en AL et AH </li></ul><br>  Il n'y a pas de sources de versions plus r√©centes, mais il existe des <a href="https://sourceforge.net/projects/dosbox/files/dosbox/" rel="nofollow">sources DOSBox</a> : <br><br><pre> <code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number"><span class="hljs-number">0</span></span>;reg_cx=<span class="hljs-number"><span class="hljs-number">0xff</span></span>; reg_dx=pspseg; reg_si=RealOff(csip); reg_di=RealOff(sssp);</code> </pre><br>  Autrement dit, cela co√Øncide avec ce que j'ai vu dans le code source MS-DOS (2e version!), Vous pouvez voir les valeurs initiales des autres registres, ici c'est une initialisation explicite et sp√©ciale.  Pour MS-DOS, les valeurs des registres autres que AX, segment et stack sont des rudiments de leur utilisation √† d'autres fins; ce n'est pas un dogme ou une norme, par cons√©quent, elles ne sont mentionn√©es nulle part.  Mais d'un autre c√¥t√©, l'√©cosyst√®me qui s'est form√© et toute la peine de Microsoft √† prendre en charge la compatibilit√© avec les anciennes versions, for√ßant √† faire glisser toutes les valeurs g√©n√©r√©es al√©atoirement, devient un peu compr√©hensible, car les programmeurs y sont tellement habitu√©s. <br><br>  Enfin, pour nous cette connaissance est suffisante, nous commen√ßons √† restaurer le programme √† partir des en-t√™tes: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup</code> </pre><br>  Nous d√©terminons le type de processeur 80186, car nous utilisons la commande <code>outsb</code> , qui n'apparaissait que dans ce mod√®le.  Un segment de code et un point d'entr√©e au programme, qui, avec la d√©finition du <code>tiny</code> mod√®le de m√©moire, permettront au compilateur de calculer correctement tous les d√©calages de variables et de transitions.  Lors de la cr√©ation de <code>tlink</code> , le <code>tlink</code> <code>/t</code> <code>tlink</code> utilis√©; sur la sortie, cela donnera un fichier <code>.com</code> . <br><br><h3>  Graphisme et palette </h3><br>  Pour passer en mode graphique, vous devez vous tourner vers la fonction BIOS, pour laquelle une interruption de 10h, AH = 0 est appel√©e, en AL nous mettons l'identifiant du mode souhait√© - 13h: <br><br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h ;b0 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Veuillez noter que nous ne touchons pas AH, en supposant qu'il y a z√©ro, selon les conditions de chargement du programme.  Le mode s√©lectionn√© correspond √† une r√©solution graphique de 320 x 200 pixels avec une palette de 256 couleurs.  Pour afficher un point √† l'√©cran, vous devez √©crire dans la zone m√©moire, qui commence par l'adresse A000h: 0, l'octet correspondant √† la couleur.  Remplissez les registres de donn√©es de segment avec cette valeur: <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h ;<span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> a0 pop es ;<span class="hljs-number"><span class="hljs-number">07</span></span> push es ;<span class="hljs-number"><span class="hljs-number">06</span></span> pop ds ;<span class="hljs-number"><span class="hljs-number">1f</span></span></code> </pre><br>  Logiquement, la m√©moire est organis√©e comme un tableau bidimensionnel dans lequel les coordonn√©es de l'√©cran sont affich√©es, 0: 0 correspond au coin sup√©rieur gauche.  Apr√®s avoir chang√© de mode, il est rempli de z√©ros - noirs dans la palette par d√©faut.  La formule pour traduire en d√©placement lin√©aire est <b>X + Y * L</b> , o√π L est la r√©solution horizontale, dans notre cas 320. Dans ce formulaire, j'√©crirai aux endroits o√π les constantes sont utilis√©es, lors de la traduction du texte du programme, elles sont calcul√©es automatiquement. <br><br>  Pour changer de palette, on acc√®de directement √† l'√©quipement en utilisant les ports d'entr√©e / sortie: <br><br><pre> <code class="cpp hljs">lodsb ;ac mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h ;ba c8 <span class="hljs-number"><span class="hljs-number">03</span></span> out dx, al ;ee</code> </pre><br>  La premi√®re commande charge dans AL l'octet de donn√©es situ√© dans DS: SI.  Dans DS, nous avons charg√© l'adresse de segment de la m√©moire vid√©o et nous savons qu'elle est remplie de z√©ros, dans SI - dans le cas g√©n√©ral, on ne sait pas qu'au moins 0. Cela n'a pas d'importance pour nous o√π SI indique, nous entrons presque certainement dans la m√©moire vid√©o qui occupe avec cette r√©solution 320 * 200 = 64000 octets, presque tout le segment.  Ainsi, nous nous attendons √† ce qu'apr√®s cette commande AL = 0.  Une unit√© est ajout√©e ou soustraite √† SI, cela d√©pend du r√©glage du drapeau de direction DF.  Bien que cela ne soit pas particuli√®rement important pour nous, peu importe o√π le SI se d√©place, nous restons toujours dans la zone de m√©moire vid√©o remplie de z√©ros. <br><br>  Ensuite, chargez le DX avec le num√©ro de port 03C8h, dont la sortie d√©termine la couleur de 256 que nous allons remplacer.  Dans notre cas, c'est 0 de AL. <br><br>  La couleur est cod√©e dans la palette RVB et pour cela, vous devez √©crire sur le port 03C9h (un de plus de 3C8h) trois fois de suite, une fois pour chacun des composants.  La luminosit√© maximale du composant est de 63, le minimum est de 0. <br><br><pre> <code class="cpp hljs">inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">64</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">40</span></span> PALETTE: out dx, al ;ee inc ax ;<span class="hljs-number"><span class="hljs-number">40</span></span> outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e loop PALETTE ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">,    6  </span></span></code> </pre><br>  Augmentez DX de un pour qu'il ait le num√©ro de port souhait√©.  CL est notre compteur de cycles de 64, et nous supposons que CH = 0, comme d√©crit pr√©c√©demment en fonction des conditions de chargement initiales.  Ensuite, nous sortons le premier composant sur le port - le rouge, dont la luminosit√© sera stock√©e dans AL, c'est lui que nous changerons, dans la premi√®re √©tape 0. Apr√®s cela, nous augmentons sa luminosit√© de un pour l'afficher dans la prochaine it√©ration.  Ensuite, nous <code>outsb</code> deux commandes <code>outsb</code> √©crivent sur le port, dont le num√©ro est contenu dans DX, l'octet de la zone de m√©moire DS: SI, rappelez-vous que nous avons des z√©ros l√†.  SI √† chaque fois change d'un. <br><br>  D√®s que nous avons d√©duit les trois composants, une unit√© est automatiquement ajout√©e au num√©ro de couleur.  Ainsi, il n'est pas n√©cessaire de red√©finir la couleur en sortie vers le port 3C8h si les couleurs sont dans une rang√©e, comme requis.  La commande de <code>loop</code> r√©duira CX de un, si une valeur non nulle est obtenue, elle ira au d√©but du cycle, si 0, puis √† la commande suivante apr√®s le cycle. <br><br>  Un total de 64 r√©p√©titions.  √Ä chaque r√©p√©tition, nous d√©terminons pour la couleur, en commen√ßant de 0 √† 63, la composante rouge dont la luminosit√© co√Øncide avec le num√©ro de couleur actuel.  Nous r√©initialisons les composants vert et bleu pour obtenir une telle palette de luminosit√© rouge minimale √† maximale: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="palette"></div><br><br><h3>  Lignes </h3><br>  Configurez la couleur et les coordonn√©es initiales: <br><br><pre> <code class="cpp hljs">LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh ;b8 <span class="hljs-number"><span class="hljs-number">3f</span></span> <span class="hljs-number"><span class="hljs-number">3f</span></span> mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span></code> </pre><br>  Dans AL et AH, nous chargeons la couleur maximale possible (la plus brillante) 63 (3Fh), respectivement, AX d√©finit deux points √† la fois.  BX - r√©solution horizontale maximale.  √Ä l'avenir, cela sera utilis√© pour ajouter ou soustraire une ligne des coordonn√©es actuelles.  DI - coordonn√©es 64: 4, enregistrez-les sur la pile. <br><br>  <b>Tracez la premi√®re ligne du coin sup√©rieur gauche √† l'extr√™me droite</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE1: stosw ;ab add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE1 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Configurez le compteur - ce sera le nombre de lignes.  Ensuite, enregistrez le mot (deux octets) de AX √† l'adresse ES: DI.  Cette action affichera deux points sur l'√©cran avec la couleur maximale de notre palette, car l'ES est configur√© pour la m√©moire vid√©o et des coordonn√©es sp√©cifiques sont d√©finies dans DI.  Apr√®s cette action, 2 seront ajout√©s au DI, puisque deux octets ont √©t√© √©crits.  Nous ne d√©finissons √©videmment pas l'indicateur de direction DF et comptons sur le fait qu'il est r√©initialis√©, nous rappelons √† nouveau nos conditions initiales de chargement du programme.  Sinon, les deux seraient supprim√©s, ce qui ne permettrait pas de tracer la ligne souhait√©e. <br><br>  Ensuite, DI = DI + BX, ce qui √©quivaut √† augmenter la coordonn√©e Y d'une unit√©.  Ainsi, dans le corps du cycle, deux points sont trac√©s sur une m√™me ligne, la coordonn√©e X est augment√©e de 2, et la coordonn√©e Y de 1 et cette action est r√©p√©t√©e 120 fois, l'image avec le r√©sultat est l√©g√®rement inf√©rieure. <br><br>  <b>La deuxi√®me ligne va du haut √† gauche vers le haut</b> : <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">60</span></span> LINE2: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE2 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Nous restaurons les coordonn√©es initiales 64: 4 et mettons le compteur √† 96 r√©p√©titions.  Nous imprimons un point, mais une ligne sous les coordonn√©es actuelles.  Comme pr√©c√©demment, ceci est r√©alis√© en ajoutant une valeur √† partir de BX, uniquement sans enregistrer les nouvelles coordonn√©es.  La construction <code>[bx+di]</code> ou <code>[bx][di]</code> est appel√©e adressage de base avec indexation et fonctionne au niveau du processeur, pas du traducteur.  Le registre de segment par d√©faut avec BX est DS.  Apr√®s quoi, nous affichons le deuxi√®me point, mais d√©j√† dans les coordonn√©es actuelles.  DI, et donc X augmente d'une unit√©, car une seule commande de transfert d'octets est <code>stosb</code> - <code>stosb</code> .  Les deux derni√®res commandes du corps du cycle sont une augmentation de Y de 2, pour laquelle nous utilisons √† nouveau BX. <br><br>  Apr√®s avoir trac√© deux lignes, l'image suivante est obtenue pr√®s du coin sup√©rieur gauche: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="ligne 1,2"></div><br><br>  Coordonn√©es gauche et haut, droite de l'adresse de d√©calage de ligne dans la m√©moire vid√©o.  Le point 64: 4 sera tir√© deux fois. <br><br>  <b>La troisi√®me ligne va du haut vers le coin sup√©rieur droit</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">61</span></span> LINE3: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb loop LINE3 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  DI contient d√©j√† la valeur de coordonn√©es souhait√©e 160: 196, nous devons tracer une ligne √† partir du haut o√π la ligne pr√©c√©dente s'est termin√©e, en remontant l'√©cran tout en conservant le m√™me angle.  En cons√©quence, le cycle est presque identique.  CX est augment√© de 1, car la coordonn√©e Y actuelle est 2 de plus (inf√©rieure) que l√† o√π se terminait la ligne pr√©c√©dente, elle a d√©j√† √©t√© calcul√©e pour l'it√©ration suivante.  Par cons√©quent, pour atteindre le coin sup√©rieur, vous devez faire un pas suppl√©mentaire.  Le mouvement le long de X continue dans la m√™me direction - plus un apr√®s chaque it√©ration, et le long de Y, au lieu d'ajouter, nous soustrayons les deux.  Les points sont affich√©s dans le m√™me ordre, d'abord inf√©rieur puis sup√©rieur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="ligne 3"></div><br><br>  <b>La quatri√®me ligne va du coin le plus √† gauche au coin sup√©rieur droit:</b> <br><br><pre> <code class="cpp hljs">mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf d1 <span class="hljs-number"><span class="hljs-number">99</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE4: stosw ;ab sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb(<span class="hljs-number"><span class="hljs-number">-5</span></span>) loop LINE4</code> </pre><br>  Nous sommes √† nouveau dans les coordonn√©es n√©cessaires, mais cela n'est pas utilis√©, apparemment pour ne pas changer le drapeau de direction DF.  Par cons√©quent, de nouvelles coordonn√©es sont plac√©es dans le DI et stock√©es sur la pile. <br><br>  De plus, tout est identique √† la premi√®re ligne, seule la coordonn√©e Y ne grandit pas, mais diminue, on monte. <br><br>  <b>La cinqui√®me ligne est horizontale:</b> <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">8f</span></span> rep stosw ;f3 ab</code> </pre><br>  Tout est simple ici, le m√©canisme de retransmission du microprocesseur est utilis√©, car la ligne horizontale correspond √† une simple augmentation de l'adresse de chaque point suivant.  Dans DI, l'adresse correspondant √† la coordonn√©e du coin extr√™me gauche, stock√©e √† l'√©tape pr√©c√©dente, est restaur√©e.  Le nombre de r√©p√©titions dans CX est d√©fini et le pr√©fixe de r√©p√©tition est appliqu√© avec la commande de transfert de mots. <br><br>  Apr√®s cette action, nous avons un pentagramme enti√®rement dessin√© dans la couleur la plus brillante.  80 octets utilis√©s et 48 en r√©serve. <br><br><h3>  Magie du feu </h3><br>  <b>Nous d√©finissons les conditions aux limites pour les calculs:</b> <br><br><pre> <code class="cpp hljs">FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> ;<span class="hljs-number"><span class="hljs-number">81</span></span> fe <span class="hljs-number"><span class="hljs-number">00</span></span> fa jae NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> lodsb ;ac <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al ;<span class="hljs-number"><span class="hljs-number">0</span></span>a c0 jz NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>d</code> </pre><br>  Dans SI, il y aura la coordonn√©e du point actuel pour les calculs, si nous allons au-del√† des limites de l'√©cran, alors nous n'effectuons aucun calcul avec ce point, nous proc√©dons au calcul du suivant. <br><br>  <code>lodsb</code> charge un octet de la zone DS: SI dans AL, c'est-√†-dire la couleur du point dans les coordonn√©es actuelles.  Si c'est 0, alors nous ne faisons rien non plus et passons au point suivant. <br><br>  <b>Nouveau calcul des couleurs</b> <br><br>  Ceci est l'algorithme principal pour changer les valeurs de couleur √† l'√©cran, ce n'est pas une flamme, c'est la base pour cela.  Nous calculons les points voisins et r√©alisons la continuit√© des couleurs: <br><br><pre> <code class="cpp hljs">dec ax ;<span class="hljs-number"><span class="hljs-number">48</span></span> mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> fe mov [si], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> ff mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> bf fe</code> </pre><br>  Soustrayez de AX, en fait de AL, une unit√© qui contient une valeur de couleur non nulle obtenue √† partir des coordonn√©es actuelles.  Ensuite, nous √©crivons la valeur obtenue √† tous les points voisins, par rapport √† la coordonn√©e actuelle, c'est-√†-dire un peu d'entre eux, en fonction de notre palette. <br><br>  √âtant donn√© qu'apr√®s <code>lodsb</code> , la valeur SI a augment√© de un et ne correspond plus au point dont nous lisons la couleur en AL, cela doit √™tre ajust√©.  Notez que les commandes de transfert d'octets <code>stosb</code> ne sont plus utilis√©es; √† la place, <code>mov</code> est utilis√© pour localiser l'adresse o√π la valeur sera plac√©e.  Si nous acceptons que les coordonn√©es actuelles sont X: Y, pour elles SI-1, alors: <br><br><ul><li>  <code>mov [si-2], al</code> - enregistre une nouvelle couleur au point X-1: Y, √† gauche de la couleur actuelle.  2 est soustrait de SI pour la raison d√©crite ci-dessus, car une unit√© suppl√©mentaire lui a d√©j√† √©t√© ajout√©e </li><li>  <code>mov [si], al</code> - enregistre une nouvelle couleur au point X + 1: Y, √† droite de la couleur actuelle.  SI a d√©j√† X + 1 </li><li>  <code>mov [bx+si-1], al</code> - √©crit une nouvelle couleur au point X: Y + 1, en dessous de la couleur actuelle.  Utilisez √† nouveau BX pour Y + 1 </li><li>  <code>mov [si-1-1*320], al</code> - √©crit une nouvelle couleur au point X: Y-1, au-dessus de la couleur actuelle.  Nous ne pourrons pas utiliser BX, car nous devons supprimer les coordonn√©es, l'architecture du processeur ne nous permet pas de le faire sous cette forme, donc une constante est utilis√©e conform√©ment √† la formule de r√©duction des coordonn√©es </li></ul><br>  Le registre de segment est DS, qui est utilis√© par d√©faut avec SI et BX. <br><br>  Nulle part la situation n'est v√©rifi√©e lorsque le point atteint le bord de l'√©cran.  Cela ne peut pas conduire √† un √©chec, car nous serons toujours dans les limites du segment vid√©o.  Un point voisin peut tomber soit dans une zone non d√©clar√©e avec des adresses sup√©rieures √† 64 000, soit sur une ligne adjacente, ce qui ne nous nuit pas et nous aide m√™me un peu, comme on le verra dans la suite de la description. <br><br>  <b>La m√™me magie, le calcul des coordonn√©es du point suivant</b> <br><br><pre> <code class="cpp hljs">NEXT_PIXEL: add si, dx ;<span class="hljs-number"><span class="hljs-number">03</span></span> f2 inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> jnz FLAME ;<span class="hljs-number"><span class="hljs-number">75</span></span> e3(<span class="hljs-number"><span class="hljs-number">-29</span></span>)</code> </pre><br>  Revenons un peu en arri√®re, nous n'avons pas d√©fini sp√©cifiquement la valeur SI initiale nulle part, et dans DX, nous avons toujours le num√©ro du port d'entr√©e de sortie que nous avons utilis√© pour la palette.  Nous n'effectuons que trois actions simples SI = SI + DX, cela va √©videmment d√©finir de nouvelles coordonn√©es, lesquelles?  DX = DX + 1 et si DX n'est pas √©gal √† 0, revenons √† l'algorithme de base pour obtenir et calculer les points voisins, c'est-√†-dire que DX est une sorte de compteur? <br><br>  Nous savons que nous devons faire le tour de tous les points et calculer les changements de luminosit√© de leurs voisins.  Si vous faites cela cons√©cutivement, nous obtiendrons probablement un gradient statique, peut-√™tre pas tout √† fait m√™me, mais inchang√© autour de nos lignes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous connaissons la taille de notre √©cran et le nombre de points dont nous avons besoin pour nous d√©placer, mais ici nous le n√©gligeons plus pr√©cis√©ment, choisissez la valeur de fermeture 65536 au lieu de l'exacte 64000. DX est vraiment un compteur, juste 65536. Mais pourquoi sa valeur initiale n'est pas importante et pourquoi nous prenons La valeur finale est-elle sup√©rieure au nombre total de points √† l'√©cran? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parce que nous contournons des points pas dans une rang√©e et pas tous. Chaque coordonn√©e lin√©aire suivante est plus grande que la pr√©c√©dente de la valeur de DX. Soit, en SI, la somme des √©l√©ments DX d'une progression arithm√©tique simple: 0,1,2,3,4,5,6, ..., 362,363, ..., 65535. Cela nous donne d√©j√† une non-lin√©arit√©, si vous commencez avec SI = 0 et DX = 0, alors dans SI nous obtenons: 0,1,3,4,6,10,15,21, ..., 65341,65703, ..., 2147450880.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce n'est pas tout, car la dimension SI est de 16 bits, nous ne pouvons pas obtenir une valeur sup√©rieure √† 65535, un d√©bordement se produit et le reste en SI reste modulo 65536. La formule de calcul des coordonn√©es lin√©aires prend la forme SI = (SI + DX) MOD 65536, qui rompt compl√®tement l'ordre continu: 0,1,3,4,6,10,15,21, ..., 65341,167,530,894, ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous rappelons que SI n'est pas initialis√© de quelque fa√ßon que ce soit, c'est-√†-dire la prochaine fois que nous reviendrons √† ce cycle alors nous partirons de la coordonn√©e o√π nous nous sommes arr√™t√©s, et non de 0 ou d'une donn√©e. Cela ajoutera du chaos √† notre s√©quence - allongera le nombre d'√©l√©ments non r√©p√©titifs. Sinon, la travers√©e des points serait toujours la m√™me, bien que non lin√©aire. Un effet de flamme serait pr√©sent, mais pas aussi clairement. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous parlons de l'astuce, alors c'est tout.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DX, toujours, sauf pour la premi√®re utilisation, d√©marre implicitement √† 0 √† la suite d'un d√©bordement </font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et un peu plus de chaos est ajout√© par nos valeurs limites, car pour SI&gt; = 64000 aucun point ne sera dessin√© et la s√©quence de sortie est l√©g√®rement confuse. Et sauter tous les points avec une valeur nulle entra√Æne l'effet de l'allumage dans les premi√®res secondes du programme. En effet, le cycle complet se termine plus rapidement, car la plupart des points ne sont pas trait√©s. Mais surtout, parce que la luminosit√© de la plupart des points ne fera qu'augmenter, ils ne peuvent pas √™tre masqu√©s par les sections de gradateur voisines - ils n'existent tout simplement pas encore et les valeurs nulles ne sont pas calcul√©es. Une fois les zones compl√®tement noires disparues, l'√©quilibre est √©tabli, certaines zones augmenteront la luminosit√© et d'autres diminueront.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence, nous ne pouvons plus parler d'aucun ordre ou gradient, les points sont contourn√©s, chaque fois dans une nouvelle s√©quence, y compris en r√©p√©tant plusieurs fois ou en sautant compl√®tement. </font><font style="vertical-align: inherit;">Cela conduit √† la formation de r√©gions de luminosit√© diff√©rente m√©lang√©es les unes aux autres, changeant √† chaque nouvelle it√©ration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce n'est pas tout, si vous n'ajoutez pas de nouveaux points lumineux, ils seront finalement tous rembours√©s. </font><font style="vertical-align: inherit;">Par cons√©quent, une fois que le DX a atteint sa valeur maximale, nous revenons pour dessiner cinq lignes lumineuses encore et encore comptons tous les points √† l'√©cran:</font></font><br><br><pre> <code class="cpp hljs">in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h ;e4 <span class="hljs-number"><span class="hljs-number">60</span></span> cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h ;<span class="hljs-number"><span class="hljs-number">3</span></span>c <span class="hljs-number"><span class="hljs-number">01</span></span> jne LINES ;<span class="hljs-number"><span class="hljs-number">75</span></span> a5(<span class="hljs-number"><span class="hljs-number">-91</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais avant cela, nous lisons depuis le port 60h, c'est le clavier, le code de scan de la derni√®re touche enfonc√©e. </font><font style="vertical-align: inherit;">Pour ESC, il est √©gal √† 1. Si c'est le cas, la touche ESC a √©t√© enfonc√©e, on se dirige vers la sortie.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ach√®vement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de noter que lors de la mise √† jour de l'√©cran actuel, ce qui prend un certain temps, vous ne pouvez pas quitter le programme, c'est-√†-dire que la r√©action √† ESC sera retard√©e. Si pendant l'attente et apr√®s avoir appuy√© sur une touche ESC, nous resterons dans le programme, seul le dernier code de balayage peut √™tre lu depuis le port. Encore une chose, nous ne rempla√ßons ni n'utilisons les fonctions syst√®me DOS et BIOS pour cela, ind√©pendamment de ce que nous lisons depuis le port, la touche enfonc√©e est plac√©e dans un tampon circulaire et sera probablement lue √† partir de l√† par le programme suivant une fois notre introduction termin√©e, fichier le plus probable gestionnaire ou </font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cela conduira √† son traitement, par exemple, Volkov Commander sur ESC masquera ses panneaux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reste √† revenir au mode texte 3:</font></font><br><br><pre> <code class="cpp hljs">mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h ;b8 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On suppose que nous √©tions dans ce mode avant le lancement du programme, mais dans le cas g√©n√©ral, ce n'est peut-√™tre pas le cas. </font><font style="vertical-align: inherit;">Ici, nous mettons √† jour l'ensemble de l'AX, car nous savons avec certitude que AH ne contient pas 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez maintenant quitter:</font></font><br><br><pre> <code class="cpp hljs">retn ;c3</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit d'une commande de sortie proche d'une proc√©dure qui prend la valeur du mot plac√© (deux octets) dans la pile et la charge dans le compteur de commandes IP. </font><font style="vertical-align: inherit;">Selon les conditions initiales, nous avons des z√©ros dans la pile, cela nous m√®nera √† l'adresse CS: 0, o√π, comme nous le savons, le code de commande est situ√© </font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- arr√™t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et 7 octets pour le droit d'auteur:</font></font><br><br><pre> <code class="cpp hljs">dd <span class="hljs-number"><span class="hljs-number">0</span></span>h ;<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> ;<span class="hljs-number"><span class="hljs-number">4</span></span>d <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>d end</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On peut dire qu'il y a encore une place que je consacrerais √† une initialisation plus rigoureuse, mais comme tout fonctionne dans la DOSBox moderne, l'auteur a probablement tout fait correctement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revoyons encore une fois:</font></font><br><br><ol><li>    ,        </li><li>  4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,          </li><li>       SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         ‚Äî <code>add si, dx</code>  <code>inc dx</code> ,            ,       </li><li>     ESC  ,           </li></ol><br><div class="spoiler"> <b class="spoiler_title">  .</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h pop es push es pop ds lodsb mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h out dx, al inc dx mov cl, <span class="hljs-number"><span class="hljs-number">040</span></span>h PALETTE: out dx, al inc ax outsb outsb loop PALETTE LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE1: stosw add di, bx loop LINE1 pop di mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> LINE2: mov [bx+di], al stosb add di, bx add di, bx loop LINE2 mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> LINE3: mov [bx+di], al stosb sub di, bx sub di, bx loop LINE3 mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE4: stosw sub di, bx loop LINE4 pop di mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> rep stosw FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> jae NEXT_PIXEL lodsb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al jz NEXT_PIXEL dec ax mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al mov [si], al mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al NEXT_PIXEL: add si, dx inc dx jnz FLAME in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h jne LINES mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h retn dd <span class="hljs-number"><span class="hljs-number">0</span></span>h db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> end</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour compiler, vous devez faire: </font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne sais pas s'il vous est apparu clairement QUOI et COMMENT cela a √©t√© mis en ≈ìuvre, mais il me semble qu'une approche belle et inhabituelle a √©t√© utilis√©e pour cr√©er l'effet de flamme. </font><font style="vertical-align: inherit;">Bien que je n'aie rien √† comparer, peut-√™tre que tout le monde l'a fait, et maintenant vous pouvez faire de m√™me.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482826/">https://habr.com/ru/post/fr482826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482814/index.html">Vue g√©n√©rale de l'arborescence, mise en ≈ìuvre et pas seulement</a></li>
<li><a href="../fr482816/index.html">Arthur Khachuyan: Intelligence artificielle en marketing</a></li>
<li><a href="../fr482818/index.html">Brefs r√©sultats de la lecture du rapport sur 1C DSS pour Infostart 2019</a></li>
<li><a href="../fr482820/index.html">Optimisation du t√©l√©chargement d'images</a></li>
<li><a href="../fr482822/index.html">Comment sont effectu√©s les tests artistiques pour les jeux</a></li>
<li><a href="../fr482832/index.html">√âconomie future pour les physiciens</a></li>
<li><a href="../fr482834/index.html">La saisie statique ne n√©cessite pas n√©cessairement des c√©r√©monies</a></li>
<li><a href="../fr482840/index.html">T√©l√©chargement s√©quentiel UTorrent en 2 clics</a></li>
<li><a href="../fr482842/index.html">Mash est un langage de programmation qui se compile</a></li>
<li><a href="../fr482846/index.html">AirPods Pro, Apple TV + et beaucoup d'argent: pourquoi les actions Apple ont atteint un prix record</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>