<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>  锔 Apple Metal en MAPS.ME   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! 

 En el mundo hay una gran cantidad de aplicaciones en OpenGL, y parece que Apple no est谩 de acuerdo con esto. A partir de iOS 12 y Mac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apple Metal en MAPS.ME</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/430850/"><img src="https://habrastorage.org/webt/jf/bk/ix/jfbkixzquc9k0dnnqnaorskj4bk.png" alt="imagen" align="left">  Hola a todos! <br><br>  En el mundo hay una gran cantidad de aplicaciones en OpenGL, y parece que Apple no est谩 de acuerdo con esto.  A partir de iOS 12 y MacOS Mojave, OpenGL ha quedado en desuso.  Hemos integrado Apple Metal en MAPS.ME y estamos listos para compartir nuestra experiencia y resultados.  Le diremos c贸mo se refactoriz贸 nuestro motor de gr谩ficos, qu茅 dificultades tuvimos que enfrentar y, lo m谩s importante, cu谩ntos FPS tenemos ahora. <br><br>  Todos los que est茅n interesados o est茅n considerando agregar soporte de Apple Metal al motor gr谩fico son bienvenidos a cat. <br><a name="habracut"></a><br><h2>  Problema </h2><br>  Nuestro motor de gr谩ficos fue dise帽ado como multiplataforma, y dado que OpenGL es, de hecho, la 煤nica API de gr谩ficos multiplataforma para el conjunto de plataformas que nos interesa (iOS, Android, MacOS y Linux), lo elegimos como base.  No hicimos un nivel adicional de abstracci贸n que ocultara las caracter铆sticas espec铆ficas de OpenGL, pero, afortunadamente, dejamos el potencial para su implementaci贸n. <br><br>  Con el advenimiento de la nueva generaci贸n de API de gr谩ficos Apple Metal y Vulkan, por supuesto, consideramos la posibilidad de su aparici贸n en nuestra aplicaci贸n, sin embargo, nos detuvimos por lo siguiente: <br><br><ol><li>  Vulkan solo pod铆a funcionar en Android y Linux, y Apple Metal solo pod铆a funcionar en iOS y MacOS.  No quer铆amos perder multiplataforma a nivel de la API gr谩fica, esto complicar铆a los procesos de desarrollo y depuraci贸n, aumentar铆a la cantidad de trabajo. </li><li>  Una aplicaci贸n en Apple Metal no se puede construir y ejecutar en un simulador de iOS (por cierto, hasta ahora), lo que tambi茅n complicar铆a nuestro desarrollo y no nos permitir铆a deshacernos por completo de OpenGL. </li><li>  Qt Framework, que utilizamos para crear herramientas internas, solo admite OpenGL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ahora se admite Vulkan</a> ). </li><li>  Apple Metal no ten铆a y no tiene una API de C ++, lo que nos obligar铆a a presentar abstracciones no solo para el tiempo de ejecuci贸n, sino tambi茅n para la fase de compilaci贸n de la aplicaci贸n, cuando parte del motor se compila en Objective-C ++ y otra, sustancialmente m谩s grande, en C ++. </li><li>  No est谩bamos listos para hacer un motor separado o una rama de c贸digo separada espec铆ficamente para iOS. </li><li>  La implementaci贸n se evalu贸 al menos seis meses en el trabajo de un desarrollador gr谩fico. </li></ol><br>  Cuando, en la primavera de 2018, Apple anunci贸 la transferencia de OpenGL a un estado en desuso, qued贸 claro que ya no era posible posponer, y los problemas anteriores ten铆an que resolverse de una forma u otra.  Adem谩s, hemos estado trabajando durante mucho tiempo para optimizar tanto la velocidad de la aplicaci贸n como el consumo de energ铆a, y Apple Metal parec铆a poder ayudar. <br><br><h2>  Selecci贸n de decisiones </h2><br>  Casi de inmediato nos dimos cuenta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MoltenVK</a> .  Este marco emula la API de Vulkan usando Apple Metal, y su c贸digo fuente se abri贸 recientemente.  Al parecer, usar MoltenVK permitir铆a reemplazar OpenGL con Vulkan, y no tener que lidiar con la integraci贸n separada de Apple Metal.  Adem谩s, los desarrolladores de Qt han <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rechazado el soporte por separado para renderizar en Apple Metal</a> a favor de MoltenVK.  Sin embargo, nos detuvieron: <br><br><ul><li>  la necesidad de soportar dispositivos Android en los que Vulkan no est谩 disponible; </li><li>  la incapacidad de comenzar en el simulador de iOS sin la presencia de respaldo en OpenGL; </li><li>  la incapacidad de usar herramientas de Apple para depurar, perfilar y precompilar sombreadores, ya que MoltenVK genera sombreadores en tiempo real para Apple Metal a partir de c贸digos fuente SPIR-V o GLSL; </li><li>  la necesidad de esperar actualizaciones y correcciones de errores de MoltenVK cuando se lanzan nuevas versiones de Metal; </li><li>  La imposibilidad de una optimizaci贸n sutil espec铆fica para Metal, pero no espec铆fica o inexistente para Vulkan. </li></ul><br>  Result贸 que necesitamos guardar OpenGL, lo que significa que no podemos hacerlo sin abstraer el motor de la API gr谩fica.  Apple Metal, OpenGL ES y, en el futuro, Vulkan, se utilizar谩n para crear componentes internos independientes del motor de gr谩ficos, que pueden ser completamente intercambiables.  OpenGL desempe帽ar谩 el papel de opci贸n de reserva cuando Metal o Vulkan no est茅 disponible por una raz贸n u otra. <br><br>  El plan de implementaci贸n fue el siguiente: <br><br><ol><li>  Refactorizaci贸n del motor de gr谩ficos para abstraer la API de gr谩ficos utilizada. </li><li>  Renderiza a Apple Metal para la versi贸n iOS de la aplicaci贸n. </li><li>  Haga los puntos de referencia apropiados para la velocidad de representaci贸n y el consumo de energ铆a para ver si las API de gr谩ficos modernos de nivel inferior pueden beneficiar al producto. </li></ol><br><h2>  Diferencias clave entre OpenGL y Metal </h2><br>  Para entender c贸mo abstraer la API gr谩fica, primero determinemos cu谩les son las diferencias conceptuales clave entre OpenGL y Metal. <br><br><ol><li>  Se cree, y no sin raz贸n, que Metal es una API de nivel inferior.  Sin embargo, esto no significa que deba escribir en el ensamblador o implementar la rasterizaci贸n usted mismo.  Metal puede llamarse una API de bajo nivel en el sentido de que realiza un n煤mero muy peque帽o de acciones impl铆citas, es decir, casi todas las acciones deben escribirse en el programador mismo.  OpenGL hace muchas cosas impl铆citamente, comenzando por admitir una referencia impl铆cita a un contexto de OpenGL y vincular este contexto a la secuencia en la que se cre贸. </li><li>  En Metal, "no" validaci贸n en tiempo real de los equipos.  En el modo de depuraci贸n, la validaci贸n, por supuesto, existe y se hace mucho mejor que en muchas otras API, en gran parte debido a su estrecha integraci贸n con Xcode.  Pero cuando el programa se env铆a al usuario, ya no hay validaci贸n, el programa simplemente falla en el primer error.  No hace falta decir que OpenGL se bloquea solo en los casos m谩s extremos.  La pr谩ctica m谩s com煤n: ignorar el error y continuar trabajando. </li><li>  Metal puede precompilar sombreadores y construir bibliotecas a partir de ellos.  En OpenGL, los sombreadores se compilan desde la fuente en el proceso del programa, del cual es responsable la implementaci贸n espec铆fica de bajo nivel de OpenGL en un dispositivo en particular.  Las diferencias y / o errores en la implementaci贸n de compiladores de sombreadores a veces conducen a errores fant谩sticos, especialmente en dispositivos Android de marcas chinas. </li><li>  OpenGL usa activamente la m谩quina de estado, que agrega efectos secundarios a casi todas las funciones.  Por lo tanto, las funciones de OpenGL no son funciones puras, y el orden y el historial de llamadas a menudo son importantes.  El metal no usa estados impl铆citamente y no los conserva m谩s tiempo del necesario para el renderizado.  Los estados existen como objetos pre-creados y fallidos. </li></ol><br><h2>  Motor gr谩fico refactorizado e incrustado de metal </h2><br>  El proceso de refactorizaci贸n del motor de gr谩ficos consisti贸 b谩sicamente en encontrar la mejor soluci贸n para deshacerse de las caracter铆sticas de OpenGL que nuestro motor ha estado utilizando activamente.  Embedded Metal, a partir de una de las etapas, fue en paralelo. <br><br><ul><li>  Como ya se se帽al贸, la API de OpenGL tiene una entidad impl铆cita llamada contexto.  El contexto est谩 asociado con un hilo espec铆fico, y la funci贸n OpenGL llamada en ese hilo mismo encuentra y usa este contexto.  Metal, Vulkan (s铆, y otras API, por ejemplo, Direct3D) no funcionan de esta manera, tienen objetos expl铆citos similares llamados dispositivo o instancia.  El usuario mismo crea estos objetos y es responsable de su transferencia a diferentes subsistemas.  Es a trav茅s de estos objetos que se realizan todas las llamadas a comandos gr谩ficos. <br><br>  Llamamos a nuestro objeto abstracto un contexto gr谩fico, y en el caso de OpenGL simplemente decora las llamadas de los comandos de OpenGL, y en el caso de Metal contiene la interfaz ra铆z MTLDevice a trav茅s de la cual se llaman los comandos de Metal. <br><br>  Por supuesto, tuve que distribuir este objeto (y dado que tenemos renderizado multiproceso, incluso varios de estos objetos) en todos los subsistemas. <br><br>  Ocultamos la creaci贸n de colas de comandos, codificadores y su gesti贸n dentro del contexto gr谩fico, para no difundir entidades que simplemente no existen en OpenGL. </li><li>  La perspectiva de la desaparici贸n de la validaci贸n de comandos gr谩ficos en los dispositivos de los usuarios no nos agrad贸 abiertamente.  Nuestro departamento de control de calidad no puede cubrir completamente una amplia gama de dispositivos y versiones de SO.  Por lo tanto, tuvimos que agregar registros detallados donde previamente recibimos un error significativo de la API gr谩fica.  Por supuesto, esta validaci贸n se agreg贸 solo a ubicaciones potencialmente peligrosas y cr铆ticas del motor de gr谩ficos, ya que cubrir todo el motor con un c贸digo de diagn贸stico es pr谩cticamente imposible y generalmente da帽ino para el rendimiento.  La nueva realidad es que las pruebas de usuario y la depuraci贸n con registros est谩n ahora en el pasado, al menos en t茅rminos de representaci贸n. </li><li>  Nuestro sistema de sombreado anterior no era adecuado para la refactorizaci贸n; tuve que reescribirlo por completo.  El punto aqu铆 no es solo la precompilaci贸n de sombreadores y su validaci贸n en la etapa de ensamblaje del proyecto.  OpenGL utiliza las llamadas variables uniformes para pasar par谩metros a los sombreadores.  La transferencia de datos estructurados solo est谩 disponible con OpenGL ES 3.0, y dado que todav铆a admitimos OpenGL ES 2.0, simplemente no utilizamos este m茅todo.  Metal nos hizo usar estructuras de datos para pasar par谩metros, y para OpenGL tuvimos que idear campos de estructura de mapeo para variables uniformes.  Adem谩s, tuve que volver a escribir cada uno de los sombreadores en el Metal Shading Language. </li><li>  Cuando usamos objetos de estado, tuvimos que hacer un truco.  En OpenGL, todos los estados, como regla, se establecen inmediatamente antes de la representaci贸n, y en Metal, este deber铆a ser un objeto previamente creado y validado.  Nuestro motor, obviamente, utiliz贸 el enfoque OpenGL, y la refactorizaci贸n con la creaci贸n preliminar de objetos de estado fue comparable con una reescritura completa del motor.  Para cortar este nodo, creamos un cach茅 de estado dentro del contexto gr谩fico.  La primera vez que se genera una combinaci贸n 煤nica de par谩metros de estado, se crea un objeto de estado en Metal y se coloca en la memoria cach茅.  Por segunda vez y posteriores, el objeto simplemente se recupera de la memoria cach茅.  Esto funciona en nuestros mapas, ya que el n煤mero de diferentes combinaciones de par谩metros de estado no es demasiado grande (aproximadamente 20-30).  Para un motor gr谩fico de juego complejo, este m茅todo no es adecuado. </li></ul><br>  Como resultado, despu茅s de aproximadamente 5 meses de trabajo, pudimos lanzar MAPS.ME por primera vez con renderizado completo en Apple Metal.  Era hora de averiguar qu茅 pas贸. <br><br><h2>  Prueba de velocidad de renderizado </h2><br><h4>  T茅cnica experimental </h4><br>  Usamos diferentes generaciones de dispositivos Apple en el experimento.  Todos ellos se actualizaron a iOS 12. El mismo script de usuario se ejecut贸 en todos: navegaci贸n de mapa (movimiento y escala).  El script fue creado para garantizar una identidad casi completa de los procesos dentro de la aplicaci贸n cada vez que se inici贸 en cada dispositivo.  Como lugar de prueba, elegimos el 谩rea de Los ngeles, una de las 谩reas con mayor carga en MAPS.ME. <br><br>  Primero, el script se ejecut贸 con renderizado en OpenGL ES 3.0, luego en el mismo dispositivo con renderizado en Apple Metal.  Entre inicios, la aplicaci贸n se descarg贸 completamente de la memoria. <br>  Se midieron los siguientes indicadores: <br><br><ul><li>  FPS (cuadros por segundo) para todo el cuadro; </li><li>  FPS para la parte del cuadro que se dedica solo a la representaci贸n, excluyendo la preparaci贸n de datos y otras operaciones cuadro por cuadro; </li><li>  El porcentaje de cuadros lentos (mayores de ~ 30 ms), es decir  aquellos que el ojo humano puede percibir como idiotas. </li></ul><br>  Al medir FPS, se exclu铆a dibujar directamente en la pantalla del dispositivo, ya que la sincronizaci贸n vertical con la frecuencia de actualizaci贸n de la pantalla no permite obtener resultados confiables.  Por lo tanto, el marco se dibuj贸 en la textura en la memoria.  Para sincronizar la CPU y la GPU, OpenGL us贸 una llamada adicional para <code>glFinish</code> , mientras que Apple Metal us贸 <code>waitUntilCompleted</code> para <code>MTLFrameCommandBuffer</code> . <br><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100"></th><th width="100">  iPhone 7+ </th><th width="100"></th><th width="100">  iPhone 8 </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  Metal </th><th>  Opengl </th><th>  Metal </th><th>  Opengl </th><th>  Metal </th></tr><tr><td>  Fps </td><td>  106 </td><td>  160 </td><td>  159 </td><td>  221 </td><td>  196 </td><td>  298 </td></tr><tr><td>  FPS (solo renderizado) </td><td>  157 </td><td>  596 </td><td>  247 </td><td>  597 </td><td>  271 </td><td>  833 </td></tr><tr><td>  Fracci贸n de fotogramas lentos (&lt;30 fps) </td><td>  4,13% </td><td>  1,25% </td><td>  5,45% </td><td>  0,76% </td><td>  1,5% </td><td>  0.29% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone X </th><th width="100"></th><th width="100">  iPad Pro 12.9 ' </th><th width="100"></th></tr><tr><th></th><th>  Opengl </th><th>  Metal </th><th>  Opengl </th><th>  Metal </th></tr><tr><td>  Fps </td><td>  145 </td><td>  210 </td><td>  104 </td><td>  137 </td></tr><tr><td>  FPS (solo renderizado) </td><td>  248 </td><td>  705 </td><td>  147 </td><td>  463 </td></tr><tr><td>  Fracci贸n de fotogramas lentos (&lt;30 fps) </td><td>  0,15% </td><td>  0,15% </td><td>  17.52% </td><td>  4,46% </td></tr></tbody></table><br><table><tbody><tr><th width="100"></th><th width="100">  iPhone 6s </th><th width="100">  iPhone 7+ </th><th width="100">  iPhone 8 </th><th width="100">  iPhone X </th><th width="100">  iPad Pro 12.9 ' </th></tr><tr><td>  Aceleraci贸n del marco en Metal (N veces) </td><td>  1,5 </td><td>  1,39 </td><td>  1,52 </td><td>  1,45 </td><td>  1,32 </td></tr><tr><td>  Aceleraci贸n de renderizado en Metal (N veces) </td><td>  3.78 </td><td>  2,41 </td><td>  3,07 </td><td>  2,84 </td><td>  3.15 </td></tr><tr><td>  Mejora en cuadros lentos (N veces) </td><td>  3,3 </td><td>  7.17 </td><td>  5.17 </td><td>  1 </td><td>  3.93 </td></tr></tbody></table><br><h4>  An谩lisis de resultados </h4><br>  En promedio, la ganancia de rendimiento del marco con Apple Metal fue del 43%.  El valor m铆nimo se fija en el iPad Pro 12.9 '- 32%, el m谩ximo - 52% en el iPhone 8. Existe una dependencia: cuanto menor es la resoluci贸n de la pantalla, m谩s Apple Metal supera a OpenGL ES 3.0. <br><br>  Si evaluamos la parte del marco que es directamente responsable del renderizado, la velocidad promedio de renderizado en Apple Metal ha aumentado 3 veces.  Esto indica una organizaci贸n significativamente mejor y, como resultado, la eficiencia de la API de Apple Metal en comparaci贸n con OpenGL ES 3.0. <br><br>  El n煤mero de fotogramas lentos (m谩s de ~ 30 ms) en Apple Metal se redujo en aproximadamente 4 veces.  Esto significa que la percepci贸n de las animaciones y moverse por el mapa se ha vuelto m谩s suave.  El peor resultado se registr贸 en el iPad Pro 12.9 'con una resoluci贸n de 2732 x 2048 p铆xeles: OpenGL ES 3.0 ofrece aproximadamente 17.5% de fotogramas lentos, mientras que Apple Metal - solo 4.5%. <br><br><h2>  Prueba de potencia </h2><br><h4>  T茅cnica experimental </h4><br>  El consumo de energ铆a se prob贸 en el iPhone 8 en iOS 12. Se ejecut贸 el mismo escenario de usuario: navegaci贸n de mapa (movimiento y escala) durante 1 hora.  El script fue programado para garantizar una identidad casi completa de los procesos dentro de la aplicaci贸n en cada inicio.  El 谩rea de Los ngeles tambi茅n fue elegida como lugar de prueba. <br><br>  Utilizamos el siguiente enfoque para medir el consumo de energ铆a.  El dispositivo no est谩 conectado a la carga.  En la configuraci贸n del desarrollador, el registro de energ铆a est谩 habilitado.  Antes de comenzar el experimento, el dispositivo est谩 completamente cargado.  El experimento termina al final del gui贸n.  Al final del experimento, se registr贸 el estado de la carga de la bater铆a y se importaron los registros de consumo de energ铆a a la utilidad para perfilar la bater铆a en Xcode.  Registramos cu谩nto de la carga se gast贸 en la GPU.  Adem谩s, aqu铆 tambi茅n ponderamos el renderizado al incluir la visualizaci贸n del esquema de metro y el suavizado de pantalla completa. <br><br>  El brillo de la pantalla no cambi贸 en todos los casos.  No se ejecutaron otros procesos excepto el sistema y MAPS.ME.  El modo avi贸n estaba activado, el wifi y el GPS estaban desactivados.  Adem谩s, se llevaron a cabo varias mediciones de control. <br><br>  Como resultado, para cada uno de los indicadores, se form贸 una comparaci贸n de Metal con OpenGL, y luego se promediaron las razones para obtener una estimaci贸n agregada. <br><br><table><tbody><tr><th width="100"></th><th width="100">  Opengl </th><th width="100">  Metal </th><th width="100">  Ganar </th></tr><tr><td>  Drenaje de la bater铆a </td><td>  32% </td><td>  28% </td><td>  12,5% </td></tr><tr><td>  Perfilado del uso de la bater铆a en Xcode </td><td>  1,95% </td><td>  1,83% </td><td>  6,16% </td></tr></tbody></table><br><h4>  An谩lisis de resultados </h4><br>  En promedio, el consumo de energ铆a de la versi贸n de renderizado en Apple Metal ha mejorado ligeramente.  El consumo de energ铆a de nuestra aplicaci贸n GPU no se ve muy afectado, alrededor del 2%, porque MAPS.ME no se puede llamar altamente cargado en t茅rminos de uso de la GPU.  Probablemente se logre una peque帽a ganancia al reducir los costos computacionales al preparar instrucciones para la GPU en la CPU, que, desafortunadamente, no se pueden distinguir con la ayuda de herramientas de creaci贸n de perfiles. <br><br><h2>  Resumen </h2><br>  Embedded Metal nos cost贸 5 meses de desarrollo.  Dos desarrolladores hicieron esto, sin embargo, casi siempre a su vez.  Obviamente, ganamos significativamente en rendimiento de renderizado, ganamos un poco en consumo de energ铆a.  Adem谩s, tuvimos la oportunidad de incorporar nuevas API de gr谩ficos, en particular, Vulkan, con mucho menos esfuerzo.  Casi completamente "resuelto" el motor de gr谩ficos, como resultado, encontramos y reparamos varios errores antiguos y problemas de rendimiento. <br><br>  A la pregunta de si nuestro proyecto realmente necesita renderizarse en Apple Metal, estamos listos para responder afirmativamente.  No es tanto que nos encante la innovaci贸n, o que Apple finalmente pueda abandonar OpenGL.  Es solo 2018, y OpenGL apareci贸 en el lejano 1997, ya es hora de dar el siguiente paso. <br><br>  <b>PD:</b> Hasta que lanzamos la funci贸n en todos los dispositivos iOS.  Para habilitarlo manualmente, escriba <code>?metal</code> en la barra de b煤squeda y reinicie la aplicaci贸n.  Para devolver el renderizado a OpenGL, ingrese el comando <code>?gl</code> y reinicie la aplicaci贸n. <br><br>  <b>PPS</b> MAPS.ME es un proyecto de c贸digo abierto.  Puedes leer el c贸digo fuente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430850/">https://habr.com/ru/post/es430850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430838/index.html">Las maravillas del marketing masivo o c贸mo promocionar un negocio con rese帽as</a></li>
<li><a href="../es430840/index.html">驴Qu茅 evidencia puede convencer a los matem谩ticos si no hay evidencia rigurosa?</a></li>
<li><a href="../es430842/index.html">Utilizamos blockchain para combatir la corrupci贸n y el ciberacoso</a></li>
<li><a href="../es430844/index.html">C贸mo elegir una bater铆a para UPS</a></li>
<li><a href="../es430846/index.html">Novedades: se conocieron detalles sobre la implementaci贸n de la nueva arquitectura Zen 2</a></li>
<li><a href="../es430852/index.html">Consistencia y garant铆as ACID en sistemas de almacenamiento distribuido</a></li>
<li><a href="../es430854/index.html">"JS se est谩 volviendo m谩s maduro": una entrevista con el comit茅 del programa HolyJS 2018 Mosc煤</a></li>
<li><a href="../es430856/index.html">Toda la verdad sobre RTOS. Art铆culo # 21. Buzones: Introducci贸n y servicios b谩sicos</a></li>
<li><a href="../es430860/index.html">Descargar, guardar y ver PDF en Swift</a></li>
<li><a href="../es430862/index.html">"Monstruos en los juegos: c贸mo hacer que un jugador te odie"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>