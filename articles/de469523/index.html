<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🌾 🎌 🍀 Abhängigkeit der Codeleistung vom Kontext der Variablendeklaration in JavaScript 🐜 💕 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ursprünglich war dieser Artikel als kleiner Benchmark für den eigenen Gebrauch konzipiert, und im Allgemeinen war nicht geplant, ein Artikel zu sein. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abhängigkeit der Codeleistung vom Kontext der Variablendeklaration in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469523/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cx/hu/udcxhuvjpmyigj19lmdrz8ojyja.jpeg"></div><br>  Ursprünglich war dieser Artikel als kleiner Benchmark für den eigenen Gebrauch konzipiert, und im Allgemeinen war nicht geplant, ein Artikel zu sein. Bei der Durchführung von Messungen tauchten jedoch einige interessante Funktionen bei der Implementierung der <i><b>JavaScript-</b></i> Architektur auf, die in einigen Fällen die Leistung des endgültigen Codes stark beeinträchtigen.  Ich schlage vor, dass Sie sich mit den erzielten Ergebnissen vertraut machen und im Übrigen auch einige verwandte Themen untersuchen: <i><b>für</b></i> Schleifen, Umgebung (Ausführungskontext) und Blöcke. <br><br><a name="habracut"></a>  Am Ende meines Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Verwenden von let-Variablendeklarationen und -Funktionen der resultierenden JavaScript-Schließungen“ habe</a> ich kurz auf den Leistungsvergleich von <i><b>let- (LexicalDeclaration)</b></i> und <i><b>var- (VarDeclaredNames)</b></i> Variablendeklarationen in Schleifen <i><b>eingegangen</b></i> .  Zum Vergleich haben wir die Laufzeit des manuellen (ohne die Hilfe von <i><b>Array.prototype.sort ()</b></i> ) Sortierens des Arrays verwendet. Eine der einfachsten Methoden ist das Sortieren nach Auswahl, da wir mit einer Array-Länge von 100.000 etwas mehr als 5 Milliarden haben.  Iterationen in zwei Zyklen (extern und verschachtelt), und diese Zahl hätte am Ende eine angemessene Bewertung ermöglichen müssen. <br><br>  Für <i><b>var</b></i> wurde die Ansicht sortiert: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 9.082 . //   Chrome: 10.783 .</span></span></code> </pre> <br>  Und für <i><b>lassen Sie</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, len = arr.length; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.261 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  Wenn man diese Zahlen sieht, kann man eindeutig argumentieren, dass Anzeigen die Geschwindigkeitsvariante vollständig übertreffen.  Zusätzlich zu dieser Schlussfolgerung blieb jedoch die Frage offen: Was wird passieren, wenn wir Deklarationen außerhalb von <i><b>for-</b></i> Schleifen platzieren? <br><br>  Bevor Sie dies tun, müssen Sie sich jedoch eingehender mit der Arbeit der <i><b>for-</b></i> Schleife befassen, die sich an der aktuellen Spezifikation von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><i>ECMAScript 2019 (ECMA-262) orientiert</i></a> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>Runtime Semantics: LabelledEvaluation With parameter labelSet. IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Expression;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> the first Expression is present, then a. Let exprRef be the result of evaluating the first Expression. b. Perform ? GetValue(exprRef). <span class="hljs-number"><span class="hljs-number">2</span></span>. Return ? ForBodyEvaluation(the second Expression, the third Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(varVariableDeclarationList;Expression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let varDcl be the result of evaluating VariableDeclarationList. <span class="hljs-number"><span class="hljs-number">2</span></span>. ReturnIfAbrupt(varDcl). <span class="hljs-number"><span class="hljs-number">3</span></span>. Return ? ForBodyEvaluation(the first Expression, the second Expression, Statement, « », labelSet). IterationStatement':'<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(LexicalDeclarationExpression;Expression)Statement <span class="hljs-number"><span class="hljs-number">1</span></span>. Let oldEnv be the running execution context's LexicalEnvironment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let loopEnv be NewDeclarativeEnvironment(oldEnv). <span class="hljs-number"><span class="hljs-number">3</span></span>. Let loopEnvRec be loopEnv's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">4</span></span>. Let isConst be the result of performing IsConstantDeclaration of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">5</span></span>. Let boundNames be the BoundNames of LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">6</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of boundNames, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is true, then i. Perform ! loopEnvRec.CreateImmutableBinding(dn, true). b. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, i. Perform ! loopEnvRec.CreateMutableBinding(dn, false). <span class="hljs-number"><span class="hljs-number">7</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to loopEnv. <span class="hljs-number"><span class="hljs-number">8</span></span>. Let forDcl be the result of evaluating LexicalDeclaration. <span class="hljs-number"><span class="hljs-number">9</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> forDcl is an abrupt completion, then a. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. b. Return Completion(forDcl). <span class="hljs-number"><span class="hljs-number">10</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> isConst is false, let perIterationLets be boundNames; otherwise let perIterationLets be « ». <span class="hljs-number"><span class="hljs-number">11</span></span>. Let bodyResult be ForBodyEvaluation(the first Expression, the second Expression, Statement, perIterationLets, labelSet). <span class="hljs-number"><span class="hljs-number">12</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to oldEnv. <span class="hljs-number"><span class="hljs-number">13</span></span>. Return Completion(bodyResult).</code> </pre>  <i>Hinweis: Doppelpunkte nach IterationStatements werden in der Quelle nicht von Apostrophen eingerahmt. Sie werden hier hinzugefügt, damit keine automatische Formatierung die Lesbarkeit des Textes beeinträchtigt.</i> <br><br>  Wie wir sehen, gibt es hier drei Möglichkeiten zum Aufrufen und weiteren Arbeiten der <i><b>for-</b></i> Schleife: <br><ul><li>  mit <i>for (Ausdruck; Ausdruck; Ausdruck) Anweisung</i> <br>  <i><b>ForBodyEvaluation</b> (der zweite Ausdruck, der dritte Ausdruck, Anweisung, "", labelSet)</i> . </li><li>  mit <i><b>for</b> (varVariableDeclarationList; Expression; Expression) -Anweisung</i> <br>  <i><b>ForBodyEvaluation</b> (der erste Ausdruck, der zweite Ausdruck, Anweisung, "", labelSet).</i> </li><li>  at <i><b>for</b> (LexicalDeclarationExpression; Expression) Anweisung</i> <br>  <i><b>ForBodyEvaluation</b> (der erste Ausdruck, der zweite Ausdruck, Anweisung, perIterationLets, labelSet)</i> </li></ul><br>  In der letzten, dritten Variante ist der vierte Parameter im Gegensatz zu den ersten beiden nicht leer - <i><b>perIterationLets</b></i> - dies sind tatsächlich die gleichen <i><b>Let-</b></i> Deklarationen im ersten Parameter, der an die <i><b>for-</b></i> Schleife übergeben wird.  Sie sind in Absatz 10 angegeben: <br>  <i>- Wenn <b>isConst</b> <b>false ist</b> , lassen Sie <b>perIterationLets</b> boundNames sein.</i>  <i>Andernfalls sei perIterationLets "".</i> <br>  Wenn eine Konstante an <i><b>for übergeben wurde</b></i> , jedoch keine Variable, wird der Parameter <i><b>perIterationLets</b></i> leer. <br><br>  Bei der dritten Option muss auch auf Absatz 2 geachtet werden: <br>  <i>- Sei loopEnv <b>NewDeclarativeEnvironment</b> (oldEnv).</i> <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">8</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>NewDeclarativeEnvironment ( E ) When the abstract operation NewDeclarativeEnvironment is called with a Lexical Environment as argument E the following steps are performed: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let env be a new Lexical Environment. <span class="hljs-number"><span class="hljs-number">2</span></span>. Let envRec be a new declarative Environment Record containing no bindings. <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> env's EnvironmentRecord to envRec. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the outer lexical environment reference of env to E. <span class="hljs-number"><span class="hljs-number">5</span></span>. Return env.</code> </pre> <br>  Hier wird als Parameter <i><b>E</b></i> die Umgebung verwendet, aus der die <i><b>for-</b></i> Schleife aufgerufen wurde (global, eine beliebige Funktion usw.), und es wird eine neue Umgebung erstellt, um die <i><b>for-</b></i> Schleife unter Bezugnahme auf die externe Umgebung auszuführen, die sie erstellt hat (Punkt 4).  Wir sind an dieser Tatsache interessiert, da die Umgebung ein Kontext der Ausführung ist. <br><br>  Und wir erinnern uns, dass <i><b>let-</b></i> und <i><b>const-</b></i> Variablendeklarationen kontextuell an den Block gebunden sind, in dem sie deklariert sind. <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.<span class="hljs-number"><span class="hljs-number">14</span></span>Runtime Semantics: BlockDeclarationInstantiation ( code, env ) Note When a Block or CaseBlock is evaluated a new declarative Environment Record is created and bindings <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each block scoped variable, constant, function, or class declared <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the block are instantiated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the Environment Record. BlockDeclarationInstantiation is performed as follows using arguments code and env. code is the Parse Node corresponding to the body of the block. env is the Lexical Environment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> which bindings are to be created. <span class="hljs-number"><span class="hljs-number">1</span></span>. Let envRec be env's EnvironmentRecord. <span class="hljs-number"><span class="hljs-number">2</span></span>. Assert: envRec is a declarative Environment Record. <span class="hljs-number"><span class="hljs-number">3</span></span>. Let declarations be the LexicallyScopedDeclarations of code. <span class="hljs-number"><span class="hljs-number">4</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> declarations, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element dn of the BoundNames of d, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> IsConstantDeclaration of d is true, then <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateImmutableBinding(dn, true). ii. <span class="hljs-keyword"><span class="hljs-keyword">Else</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>. Perform ! envRec.CreateMutableBinding(dn, false). b. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> d is a FunctionDeclaration, a GeneratorDeclaration, an AsyncFunctionDeclaration, or an AsyncGeneratorDeclaration, then i. Let fn be the sole element of the BoundNames of d. ii. Let fo be the result of performing InstantiateFunctionObject <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d with argument env. iii. Perform envRec.InitializeBinding(fn, fo).</code> </pre> <br>  Hinweis: Da es in den ersten beiden Varianten des Aufrufs der <i><b>for-</b></i> Schleife keine solchen Deklarationen gab, war es nicht erforderlich, eine neue Umgebung für sie zu erstellen. <br><br>  Wir gehen weiter und überlegen, was <i><b>ForBodyEvaluation ist</b></i> : <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">8</span></span>Runtime Semantics: ForBodyEvaluation ( test, increment, stmt, perIterationBindings, labelSet ) The abstract operation ForBodyEvaluation with arguments test, increment, stmt, perIterationBindings, and labelSet is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. Let V be undefined. <span class="hljs-number"><span class="hljs-number">2</span></span>. Perform ? CreatePerIterationEnvironment(perIterationBindings). <span class="hljs-number"><span class="hljs-number">3</span></span>. Repeat, a. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> test is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let testRef be the result of evaluating test. ii. Let testValue be ? GetValue(testRef). iii. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> ToBoolean(testValue) is false, return NormalCompletion(V). b. Let result be the result of evaluating stmt. c. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> LoopContinues(result, labelSet) is false, return Completion(UpdateEmpty(result, V)). d. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> result.[[Value]] is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> V to result.[[Value]]. e. Perform ? CreatePerIterationEnvironment(perIterationBindings). f. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> increment is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> [empty], then i. Let incRef be the result of evaluating increment. ii. Perform ? GetValue(incRef).</code> </pre> <br>  Worauf Sie zuerst achten sollten: <br><ul><li>  Beschreibung der eingehenden Parameter: <br><ul><li>  <i><b>test</b></i> : Ausdruck vor der nächsten Iteration des Schleifenkörpers auf Wahrheit überprüft (zum Beispiel: <i><b>i &lt;len</b></i> ); </li><li>  <i><b>Inkrement</b></i> : Ausdruck, der zu Beginn jeder neuen Iteration ausgewertet wird (mit Ausnahme der ersten) (zum Beispiel: <i><b>i ++</b></i> ); </li><li>  <i><b>stmt</b></i> : Schleifenkörper </li><li>  <i><b>perIterationBindings</b></i> : Variablen, die mit <i><b>let</b></i> im ersten <i><b>for-</b></i> Parameter deklariert wurden (zum Beispiel: <i><b>let i = 0 || let i || let i, j</b></i> ); </li><li>  <i><b>labelSet</b></i> : Label der Schleife; </li></ul></li><li>  Punkt 2: Wenn hier der nicht leere Parameter <i><b>perIterationBindings übergeben wird</b></i> , wird eine zweite Umgebung erstellt, um den ersten Durchlauf der Schleife durchzuführen. </li><li>  Absatz 3.a: Überprüfung auf eine bestimmte Bedingung für die Fortsetzung der Ausführung des Zyklus; </li><li>  Abschnitt 3.b: Ausführung des Zykluskörpers; </li><li>  Punkt 3.e: Schaffung einer neuen Umgebung. </li></ul><br>  Nun, und direkt der Algorithmus zum Erstellen interner Umgebungen der <i><b>for-</b></i> Schleife: <br><br><pre> <code class="dos hljs"><span class="hljs-number"><span class="hljs-number">13</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>.<span class="hljs-number"><span class="hljs-number">9</span></span>Runtime Semantics: CreatePerIterationEnvironment ( perIterationBindings ) <span class="hljs-number"><span class="hljs-number">1</span></span>. The abstract operation CreatePerIterationEnvironment with argument perIterationBindings is performed as follows: <span class="hljs-number"><span class="hljs-number">1</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> perIterationBindings has any elements, then a. Let lastIterationEnv be the running execution context's LexicalEnvironment. b. Let lastIterationEnvRec be lastIterationEnv's EnvironmentRecord. c. Let outer be lastIterationEnv's outer environment reference. d. Assert: outer is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> null. e. Let thisIterationEnv be NewDeclarativeEnvironment(outer). f. Let thisIterationEnvRec be thisIterationEnv's EnvironmentRecord. g. <span class="hljs-keyword"><span class="hljs-keyword">For</span></span> each element bn of perIterationBindings, <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> i. Perform ! thisIterationEnvRec.CreateMutableBinding(bn, false). ii. Let lastValue be ? lastIterationEnvRec.GetBindingValue(bn, true). iii. Perform thisIterationEnvRec.InitializeBinding(bn, lastValue). h. <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span> the running execution context's LexicalEnvironment to thisIterationEnv. <span class="hljs-number"><span class="hljs-number">2</span></span>. Return undefined.</code> </pre> <br>  Wie wir sehen können, prüft der erste Absatz das Vorhandensein von Elementen im übergebenen Parameter, und Absatz 1 wird nur ausgeführt, wenn es Ansagen gibt.  Alle neuen Umgebungen werden unter Bezugnahme auf denselben externen Kontext erstellt und verwenden die neuesten Werte aus der vorherigen Iteration (vorherige Arbeitsumgebung) als neue Bindungen für <i><b>let-</b></i> Variablen. <br><br>  Betrachten Sie als Beispiel einen ähnlichen Ausdruck: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { arr.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Und so kann es zerlegt werden, ohne es zu verwenden (mit einem gewissen Maß an Konventionalität): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = []; <span class="hljs-comment"><span class="hljs-comment">//    { let i = 0; //     for } //   ,   { let i = 0; //    i    if (i &lt; 3) arr.push(i); } //    { let i = 0; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 1; //    i    i++; if (i &lt; 3) arr.push(i); } //    { let i = 2; //    i    i++; if (i &lt; 3) arr.push(i); } console.log(arr); // Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Tatsächlich kommen wir zu dem Schluss, dass wir für jeden Kontext, und hier haben wir fünf davon, neue Bindungen für <i><b>let-</b></i> Variablen erstellen, die als erster Parameter in <i><b>for</b></i> deklariert sind (wichtig: Dies gilt nicht für <i><b>let-</b></i> Deklarationen direkt im Hauptteil der Schleife). <br><br>  So sieht diese Schleife beispielsweise aus, wenn <i><b>var verwendet wird,</b></i> wenn keine zusätzlichen Bindungen vorhanden sind: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) arr.push(i); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// Array(3) [ 0, 1, 2 ]</span></span></code> </pre> <br>  Und wir können zu dem scheinbar logischen Schluss kommen, dass wir, wenn während der Ausführung unserer Schleifen keine separaten Bindungen für jede Iteration erstellt werden müssen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehr über Situationen, in denen dies im Gegenteil sinnvoll sein kann</a> ), vorher die Deklaration inkrementeller Variablen vornehmen sollten mit einer <i><b>for-</b></i> Schleife, die uns vor dem Erstellen und Löschen einer großen Anzahl von Kontexten bewahren und theoretisch die Leistung verbessern soll. <br><br>  Versuchen wir dies anhand der gleichen Sortierung eines Arrays von 100.000 Elementen als Beispiel. Aus Gründen der Schönheit definieren wir auch alle anderen Variablen zuvor <i><b>für</b></i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 34.246 . //   Chrome: 10.803 .</span></span></code> </pre> <br>  Unerwartetes Ergebnis ... Genau das Gegenteil von dem, was erwartet wurde, um genau zu sein.  Besonders auffällig ist der <i><b>Firefox-</b></i> Drawdown in diesem Test. <br><br>  Ok  Dies hat nicht funktioniert. Lassen Sie uns die Deklaration der Variablen <i><b>i</b></i> und <i><b>j</b></i> auf die Parameter der entsprechenden Zyklen zurückführen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 6.575 . //   Chrome: 6.749 .</span></span></code> </pre> <br>  Hm.  Technisch gesehen scheint der einzige Unterschied zwischen dem letzten Beispiel und dem Beispiel am Anfang des Artikels die gemachten Deklarationen der Variablen <i><b>min, mini</b></i> und <i><b>len</b></i> außerhalb der <i><b>for-</b></i> Schleife zu sein, und obwohl der Unterschied immer noch kontextbezogen ist, ist er für uns jetzt nicht von besonderem Interesse und darüber hinaus Wir haben die Notwendigkeit beseitigt, diese Variablen im Körper des Zyklus der oberen Ebene 99.999 Mal zu deklarieren, was theoretisch wiederum die Produktivität erhöhen sollte, anstatt sie um mehr als eine Sekunde zu verringern. <br><br>  Das heißt, es stellt sich heraus, dass die Arbeit mit Variablen, die im Parameter oder Hauptteil der <i><b>for-</b></i> Schleife deklariert sind, viel schneller erfolgt als außerhalb. <br><br>  Wir schienen jedoch in der Spezifikation für die <i><b>for-</b></i> Schleife keine "Turbo" -Anweisungen zu sehen, die uns zu einer solchen Idee führen könnten.  Daher sind es nicht die Besonderheiten der Arbeit der <i><b>for-</b></i> Schleife, sondern etwas anderes ... Zum Beispiel die Merkmale von <i><b>let-</b></i> Deklarationen: Was ist das Hauptmerkmal, das <i><b>let</b></i> von <i><b>var unterscheidet</b></i> ?  Blockausführungskontext!  In unseren letzten beiden Beispielen haben wir Anzeigen außerhalb des Blocks verwendet.  Was aber, wenn wir diese Deklarationen nicht auf <i><b>for verschieben,</b></i> sondern nur einen separaten Block für sie auswählen? <br><br><pre> <code class="javascript hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.405 .</span></span></code> </pre> <br>  Voila!  Es stellte sich heraus, dass der Haken darin bestand, dass Ankündigungen in einem globalen Kontext stattfanden, und sobald wir ihnen einen separaten Block zugewiesen hatten, verschwanden alle Probleme genau dort. <br><br>  Und hier wäre es schön, sich an eine andere, leicht unverdient verfluchte Art der Deklaration von Variablen zu erinnern - <i><b>var</b></i> . <br><br>  Im Beispiel am Anfang des Artikels zeigte die Sortierzeit mit <i><b>var im</b></i> Vergleich zu <i><b>let</b></i> ein äußerst bedauerliches Ergebnis.  Wenn Sie sich dieses Beispiel genauer ansehen, werden Sie möglicherweise feststellen, dass der tatsächliche Kontext der Variablen global war, da <i><b>var</b></i> keine Variablenblockbindungen hatte.  Und am Beispiel von <i><b>let</b></i> haben wir bereits herausgefunden, wie sich dies auf die Leistung auswirken kann (und was bei Verwendung von <i><b>let</b></i> typisch ist, stellte sich heraus, dass der Geschwindigkeitsabfall stärker war als im Fall von <i><b>var</b></i> , insbesondere in <i><b>Firefox</b></i> ).  Aus Fairnessgründen werden wir daher ein Beispiel mit <i><b>var</b></i> ausführen, um einen neuen Kontext für Variablen zu erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini, len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.255 . //   Chrome: 5.411 .</span></span></code> </pre> <br>  Und wir haben das Ergebnis fast identisch mit dem bei der Verwendung von <i><b>let erhalten</b></i> . <br><br>  Überprüfen Sie abschließend, ob die Verlangsamung auftritt, indem Sie die globale Variable lesen, ohne ihren Wert zu ändern. <br><br>  <i><b>lass</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> len = arr.length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> min, mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.262 . //   Chrome: 5.391 .</span></span></code> </pre> <br>  <i><b>var</b></i> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> len = arr.length; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j, min, mini; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len<span class="hljs-number"><span class="hljs-number">-1</span></span>; i++) { mini = i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = i+<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; len; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr[mini] &gt; arr[j]) mini = j; } min = arr[mini]; arr[mini] = arr[i]; arr[i] = min; } } test(); <span class="hljs-comment"><span class="hljs-comment">//   Firefox: 5.258 . //   Chrome: 5.439 .</span></span></code> </pre> <br>  Die Ergebnisse zeigen, dass das Lesen der globalen Variablen die Ausführungszeit nicht beeinflusst hat. <br><br><h3>  Zusammenfassend </h3><br><ol><li>  Das Ändern globaler Variablen ist viel langsamer als das Ändern lokaler Variablen.  In Anbetracht dessen können Sie den Code in geeigneten Situationen optimieren, indem Sie einen separaten Block oder eine separate Funktion erstellen, einschließlich zum Deklarieren von Variablen, anstatt einen Teil des Codes in einem globalen Kontext auszuführen.  Ja, in fast jedem Lehrbuch finden Sie Empfehlungen, wie Sie so wenig globale Bindungen wie möglich herstellen können. In der Regel wird jedoch nur eine Verstopfung des globalen Namespace als Grund angegeben und kein Wort über mögliche Leistungsprobleme. </li><li>  Trotz der Tatsache, dass die Ausführung von Schleifen mit einer <i><b>let-</b></i> Deklaration im ersten <i><b>for-</b></i> Parameter eine große Anzahl von Umgebungen erzeugt, hat dies fast keine Auswirkungen auf die Leistung, im Gegensatz zu Situationen, in denen wir solche Deklarationen außerhalb des Blocks ausführen.  Dennoch sollte die Möglichkeit exotischer Situationen nicht ausgeschlossen werden, in denen dieser Faktor die Produktivität stärker beeinflusst. </li><li>  Die Leistung von <i><b>var-</b></i> Variablen ist der von <i><b>let-</b></i> Variablen immer noch nicht unterlegen, überschreitet sie jedoch nicht (wiederum im allgemeinen Fall), was uns zu der nächsten Schlussfolgerung führt, dass es keinen Grund gibt, <i><b>var-</b></i> Deklarationen zu verwenden, außer aus Kompatibilitätsgründen.  Wenn Sie jedoch globale Variablen mit Änderungen ihrer Werte bearbeiten müssen, ist die <i><b>var-</b></i> Variante hinsichtlich der Leistung vorzuziehen (zumindest für den Moment, wenn insbesondere davon ausgegangen wird, dass das Skript auch auf der Gecko-Engine ausgeführt werden kann). </li></ol><br><h4>  Referenzen </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ECMAScript 2019 (ECMA-262)</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden von let-Deklarationen von Variablen und Features der resultierenden Abschlüsse in JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469523/">https://habr.com/ru/post/de469523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469503/index.html">Cybersicherheit: Wir schützen Teilnehmerdaten 2019 vor Lecks</a></li>
<li><a href="../de469505/index.html">3 praktische Möglichkeiten, um Geschäfte auf ausländische Märkte zu bringen: Ansätze und Techniken realer Unternehmen</a></li>
<li><a href="../de469507/index.html">Dritte Steam Windows Client-Sicherheitsanfälligkeit, jedoch nicht 0day</a></li>
<li><a href="../de469509/index.html">Winkelschemata oder wie ich meine Vorlage für Winkelkli geschrieben habe</a></li>
<li><a href="../de469521/index.html">Ich kaufte ein Motorrad, um zu fahren, nicht um zu fallen</a></li>
<li><a href="../de469525/index.html">Automatisiertes Steuerungssystem für einen Bergbaubagger</a></li>
<li><a href="../de469527/index.html">Ist die Gegensprechanlage ein Spionageohr?</a></li>
<li><a href="../de469529/index.html">Text-Rendering hasst dich</a></li>
<li><a href="../de469531/index.html">"Programmiersprachen besser und schlechter zu vergleichen, ist eine völlig idiotische Beschäftigung."</a></li>
<li><a href="../de469533/index.html">Probleme und Bedrohungen der biometrischen Identifizierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>