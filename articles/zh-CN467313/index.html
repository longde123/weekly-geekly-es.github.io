<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♥️ 🧙🏼 🅱️ PostgreSQL和MySQL之间的交叉复制 🤰🏼 🎄 🏮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我将概述PostgreSQL和MySQL之间的交叉复制，以及在这两个数据库服务器之间设置交叉复制的方法。 通常，交叉复制数据库称为同类数据库，这是从一个关系数据库服务器移动到另一个关系数据库服务器的便捷方法。 


 PostgreSQL和MySQL数据库被认为是关系数据库，但是通过附加扩展，它们提...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL和MySQL之间的交叉复制</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/467313/"><p><img src="https://habrastorage.org/webt/ze/m9/h6/zem9h6cpvow7junwu4saxpddvpa.jpeg"></p><br><p> 我将概述PostgreSQL和MySQL之间的交叉复制，以及在这两个数据库服务器之间设置交叉复制的方法。 通常，交叉复制数据库称为同类数据库，这是从一个关系数据库服务器移动到另一个关系数据库服务器的便捷方法。 </p><br><p>  PostgreSQL和MySQL数据库被认为是关系数据库，但是通过附加扩展，它们提供了NoSQL功能。 在这里，我们将根据关系DBMS讨论PostgreSQL和MySQL之间的复制。 </p><br><p> 我们将不描述整个内部厨房，而仅描述基本原理，以便您了解如何配置数据库服务器之间的复制，优点，局限性和使用场景。 </p><a name="habracut"></a><br><p> 通常，两个相同的数据库服务器之间的复制以二进制模式执行，或者通过主节点（它是发布者，主节点或主动节点）和从节点（订户，未决或被动节点）之间的请求执行。 复制的目的是在从属端提供master数据库的实时副本。 在这种情况下，由于复制仅在一个方向上执行，因此数据从主机传输到从机，即从主动传输到被动。 但是，您可以在两个方向上配置两个数据库之间的复制，以便在双活配置中将数据从从服务器传输到主服务器。 所有这一切，包括可能在两个或更多相同数据库服务器之间的级联复制，主动-主动或主动-被动配置取决于需求，初始配置中此类功能的可用性或外部配置解决方案的使用和现有的取舍。 。 </p><br><p> 所描述的配置可以在不同的数据库服务器之间进行。 可以将服务器配置为从另一台数据库服务器接收复制的数据，并且仍然保存复制数据的实时快照。  MySQL和PostgreSQL单独或通过第三方扩展提供了大多数这些配置，包括二进制日志方法，磁盘锁以及基于语句和字符串的方法。 </p><br><p> 从一个数据库服务器到另一个数据库服务器的一次迁移需要MySQL和PostgreSQL之间的交叉复制。 这些数据库使用不同的协议，因此无法直接连接。 要建立数据交换，可以使用外部开源工具，例如pg_chameleon。 </p><br><h3 id="chto-takoe-pg_chameleon"> 什么是pg_chameleon </h3><br><p>  pg_chameleon是Python 3中从MySQL到PostgreSQL的复制系统。它使用开源库mysql-replication，也使用Python。 字符串图像是从MySQL表中提取的，并作为JSONB对象存储在PostgreSQL数据库中，然后由pl / pgsql函数解密并在PostgreSQL数据库中播放。 </p><br><h3 id="vozmozhnosti-pg_chameleon">  pg_chameleon功能 </h3><br><p> 可以使用一对多配置将来自同一集群的多个MySQL模式复制到相同的PostgreSQL目标数据库中 <br> 源模式和目标模式的名称不能匹配。 <br> 可以从级联的MySQL副本中检索复制数据。 <br> 无法复制或生成错误的表被排除。 <br> 每个复制功能均由守护程序控制。 <br> 使用基于YAML的参数和配置文件进行控制。 </p><br><h3 id="primer"> 例子 </h3><br><div class="scrollable-table"><table><thead><tr><th> 主持人 </th><th> 虚拟机1 </th><th> 虚拟机2 </th></tr></thead><tbody><tr><td>  <strong>作业系统版本</strong> </td><td>  CentOS Linux 7.6 x86_64 </td><td>  CentOS Linux 7.5 x86_64 </td></tr><tr><td>  <strong>数据库服务器版本</strong> </td><td>  MySQL 5.7.26 </td><td>  PostgreSQL 10.5 </td></tr><tr><td>  <strong>数据库端口</strong> </td><td>  3306 </td><td>  5433 </td></tr><tr><td>  <strong>IP地址</strong> </td><td>  192.168.56.102 </td><td>  192.168.56.106 </td></tr></tbody></table></div><br><p> 首先，准备安装pg_chameleon所需的所有组件。 在此示例中，安装了Python 3.6.8，它将创建一个虚拟环境并将其激活。 </p><br><pre><code class="plaintext hljs">$&gt; wget https://www.python.org/ftp/python/3.6.8/Python-3.6.8.tar.xz $&gt; tar -xJf Python-3.6.8.tar.xz $&gt; cd Python-3.6.8 $&gt; ./configure --enable-optimizations $&gt; make altinstall</code> </pre> <br><p> 成功安装Python3.6后，您需要满足其他要求，例如，创建和激活虚拟环境。 另外，pip模块已更新到最新版本，并用于安装pg_chameleon。 在以下命令中，有意安装了pg_chameleon 2.0.9，尽管最新版本为2.0.10。 这是避免更新版本中出现新错误的必要条件。 </p><br><pre> <code class="plaintext hljs">$&gt; python3.6 -m venv venv $&gt; source venv/bin/activate (venv) $&gt; pip install pip --upgrade (venv) $&gt; pip install pg_chameleon==2.0.9</code> </pre> <br><p> 然后我们使用set_configuration_files参数调用pg_chameleon（chameleon是一个命令）来启用pg_chameleon并创建默认目录和配置文件。 </p><br><pre> <code class="plaintext hljs">(venv) $&gt; chameleon set_configuration_files creating directory /root/.pg_chameleon creating directory /root/.pg_chameleon/configuration/ creating directory /root/.pg_chameleon/logs/ creating directory /root/.pg_chameleon/pid/ copying configuration example in /root/.pg_chameleon/configuration//config-example.yml</code> </pre> <br><p> 现在，我们将config-example.yml的副本创建为default.yml，以使其成为默认配置文件。 下面显示了此示例的示例配置文件。 </p><br><pre> <code class="plaintext hljs">$&gt; cat default.yml --- #global settings pid_dir: '~/.pg_chameleon/pid/' log_dir: '~/.pg_chameleon/logs/' log_dest: file log_level: info log_days_keep: 10 rollbar_key: '' rollbar_env: '' # type_override allows the user to override the default type conversion into a different one. type_override: "tinyint(1)": override_to: boolean override_tables: - "*" #postgres destination connection pg_conn: host: "192.168.56.106" port: "5433" user: "usr_replica" password: "pass123" database: "db_replica" charset: "utf8" sources: mysql: db_conn: host: "192.168.56.102" port: "3306" user: "usr_replica" password: "pass123" charset: 'utf8' connect_timeout: 10 schema_mappings: world_x: pgworld_x limit_tables: # - delphis_mediterranea.foo skip_tables: # - delphis_mediterranea.bar grant_select_to: - usr_readonly lock_timeout: "120s" my_server_id: 100 replica_batch_size: 10000 replay_max_rows: 10000 batch_retention: '1 day' copy_max_memory: "300M" copy_mode: 'file' out_dir: /tmp sleep_loop: 1 on_error_replay: continue on_error_read: continue auto_maintenance: "disabled" gtid_enable: No type: mysql skip_events: insert: - delphis_mediterranea.foo #skips inserts on the table delphis_mediterranea.foo delete: - delphis_mediterranea #skips deletes on schema delphis_mediterranea update:</code> </pre> <br><p> 此示例中的配置文件是pg_chameleon的示例文件，根据源和目标环境进行了一些细微的更改，以下是配置文件各个部分的概述。 </p><br><p> 在default.yml配置文件中，有一个全局设置部分，您可以在其中控制设置，例如锁定文件的位置，日志的位置，日志的存储期限等。下一部分是类型覆盖部分，其中指定了设置复制期间覆盖类型的规则。 默认示例使用类型重新定义规则，该规则将tinyint（1）转换为布尔值。 在下一节中，我们将说明连接到目标数据库的详细信息。 在我们的例子中，这是一个名为pg_conn的PostgreSQL数据库。 在最后一部分中，我们指示源数据，即源数据库的连接参数，源数据库和目标数据库的映射方案，要跳过的表，超时，内存和包大小。 请注意，“源”以复数形式表示，也就是说，我们可以为同一目标添加多个源数据库以配置多对一配置。 </p><br><p> 示例中的world_x数据库包含4个表，其中包含MySQL社区为示例提供的行。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>下载。 示例数据库以tar和压缩归档的形式出现，其中包含创建和导入字符串的说明。 </p><br><p> 在MySQL和PostgreSQL数据库中创建一个具有相同名称usr_replica的特殊用户。 在MySQL中，他被授予读取所有复制表的附加权限。 </p><br><pre> <code class="plaintext hljs">mysql&gt; CREATE USER usr_replica ; mysql&gt; SET PASSWORD FOR usr_replica='pass123'; mysql&gt; GRANT ALL ON world_x.* TO 'usr_replica'; mysql&gt; GRANT RELOAD ON *.* to 'usr_replica'; mysql&gt; GRANT REPLICATION CLIENT ON *.* to 'usr_replica'; mysql&gt; GRANT REPLICATION SLAVE ON *.* to 'usr_replica'; mysql&gt; FLUSH PRIVILEGES;</code> </pre> <br><p> 在PostgreSQL端，将创建db_replica数据库，该数据库将接受来自MySQL数据库的更改。  PostgreSQL的usr_replica用户自动配置为两个模式pgworld_x和sch_chameleon的所有者，这两个模式分别包含实际的复制表和具有复制目录的表。 如下所示，create_replica_schema参数负责自动配置。 </p><br><pre> <code class="plaintext hljs">postgres=# CREATE USER usr_replica WITH PASSWORD 'pass123'; CREATE ROLE postgres=# CREATE DATABASE db_replica WITH OWNER usr_replica; CREATE DATABASE</code> </pre> <br><p>  MySQL数据库配置了一些更改，以便为复制做好准备，如下所示。 您将需要重新启动数据库服务器，以使更改生效。 </p><br><pre> <code class="plaintext hljs">$&gt; vi /etc/my.cnf binlog_format= ROW binlog_row_image=FULL log-bin = mysql-bin server-id = 1</code> </pre> <br><p> 现在检查两个数据库服务器的连接非常重要，这样在执行pg_chameleon命令时就不会出现问题。 </p><br><p> 在PostgreSQL节点上： </p><br><pre> <code class="plaintext hljs">$&gt; mysql -u usr_replica -Ap'admin123' -h 192.168.56.102 -D world_x</code> </pre> <br><p> 在MySQL节点上： </p><br><pre> <code class="plaintext hljs">$&gt; psql -p 5433 -U usr_replica -h 192.168.56.106 db_replica</code> </pre> <br><p> 以下三个pg_chameleon（chameleon）命令准备环境，添加源并初始化副本。 如前所述，pg_chameleon中的create_replica_schema参数在PostgreSQL数据库中创建默认模式（sch_chameleon）和复制模式（pgworld_x）。  add_source参数通过读取配置文件（default.yml）将原始数据库添加到配置中，在我们的示例中为mysql，init_replica根据配置文件中的参数初始化配置。 </p><br><pre> <code class="plaintext hljs">$&gt; chameleon create_replica_schema --debug $&gt; chameleon add_source --config default --source mysql --debug $&gt; chameleon init_replica --config default --source mysql --debug</code> </pre> <br><p> 这三个命令的输出显然表明它们已成功执行。 所有的崩溃或语法错误均以简单明了的消息表示，并带有故障排除提示。 </p><br><p> 最后，使用start_replica开始复制并获得成功消息。 </p><br><pre> <code class="plaintext hljs">$&gt; chameleon start_replica --config default --source mysql output: Starting the replica process for source mysql</code> </pre> <br><p> 可以使用show_status参数请求复制状态，并可以使用show_errors参数查看错误。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结果。</a> </p><br><p> 如前所述，每个复制功能均由守护程序控制。 要查看它们，我们使用Linux ps命令查询进程表，如下所示。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结果。</a> </p><br><p> 直到我们对实时复制进行了实时测试，才将其视为已配置，如下所示。 我们创建一个表，在MySQL数据库中插入几条记录，然后在pg_chameleon中调用sync_tables参数来更新守护进程，并使用PostgreSQL数据库中的记录复制该表。 </p><br><pre> <code class="plaintext hljs">mysql&gt; create table t1 (n1 int primary key, n2 varchar(10)); Query OK, 0 rows affected (0.01 sec) mysql&gt; insert into t1 values (1,'one'); Query OK, 1 row affected (0.00 sec) mysql&gt; insert into t1 values (2,'two'); Query OK, 1 row affected (0.00 sec)</code> </pre> <br><pre> <code class="plaintext hljs">$&gt; chameleon sync_tables --tables world_x.t1 --config default --source mysql Sync tables process for source mysql started.</code> </pre> <br><p> 为了确认测试结果，我们从PostgreSQL数据库中查询表并显示行。 </p><br><pre> <code class="plaintext hljs">$&gt; psql -p 5433 -U usr_replica -d db_replica -c "select * from pgworld_x.t1"; n1 | n2 ----+------- 1 | one 2 | two</code> </pre> <br><p> 如果我们执行迁移，则以下pg_chameleon命令将结束。 在确保已复制所有目标表的行之后，需要执行命令，并且结果将是整齐地迁移的PostgreSQL数据库，而无需引用原始数据库或复制方案（sch_chameleon）。 </p><br><pre> <code class="plaintext hljs">$&gt; chameleon stop_replica --config default --source mysql $&gt; chameleon detach_replica --config default --source mysql --debug</code> </pre> <br><p> 如果需要，以下命令可以删除原始配置和复制方案。 </p><br><pre> <code class="plaintext hljs">$&gt; chameleon drop_source --config default --source mysql --debug $&gt; chameleon drop_replica_schema --config default --source mysql --debug</code> </pre> <br><h3 id="preimuschestva-pg_chameleon">  pg_chameleon的好处 </h3><br><p> 易于设置和配置。 <br> 方便的故障排除和异常检测以及清晰的错误消息。 <br> 您可以在初始化后将其他特殊表添加到复制中，而无需更改其余配置。 <br> 您可以为一个目标配置多个源数据库，如果将一个或多个MySQL数据库中的数据合并到一个PostgreSQL数据库中，这将非常方便。 <br> 您不能复制所选表。 </p><br><h3 id="nedostatki-pg_chameleon">  pg_chameleon的缺点 </h3><br><p> 仅支持MySQL 5.5及更高版本作为源，PostgreSQL 9.5及更高版本作为目标数据库。 <br> 每个表必须具有主键或唯一键，否则表将在init_replica进程中初始化，但不能复制。 <br> 单向复制-仅从MySQL到PostgreSQL。 因此，它仅适用于主动-被动方案。 <br> 只有MySQL数据库可以作为源，而对PostgreSQL数据库的支持仅是实验性的，并且有局限性（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>了解更多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> ） </p><br><h3 id="itogi-po-pg_chameleon">  pg_chameleon结果 </h3><br><p>  pg_chameleon中的复制方法非常适合将数据库从MySQL迁移到PostgreSQL。 一个重要的缺点是复制只是单向的，因此数据库专家不太可能希望将其用于迁移以外的任何其他用途。 但是单向复制的问题可以通过另一个开源工具SymmetricDS来解决。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读官方文档中的更多内容。 可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://pgchameleon.org/documents/usage.html&amp;usg=ALkJrhh9KgOSoE_NP3QFhySar1gvKimAFQ#">这里</a>找到命令行帮助。 </p><br><h3 id="obzor-symmetricds">  SymmetricDS概述 </h3><br><p>  SymmetricDS是一个开源工具，可将任何数据库复制到任何其他常见数据库：例如，Oracle，MongoDB，PostgreSQL，MySQL，SQL Server，MariaDB，DB2，Sybase，Greenplum，Informix，H2，Firebird和其他云数据库实例Redshift和Azure等。可用功能：数据库和文件的同步，几个主要数据库的复制，筛选的同步，转换等。 这是一个Java工具，需要标准版本的JRE或JDK（8.0或更高版本）。 在这里，您可以将触发器上的数据更改记录在源数据库中，并将其以数据包的形式发送到相应的目标数据库。 </p><br><h3 id="vozmozhnosti-symmetricds">  SymmetricDS功能 </h3><br><p> 该工具是独立于平台的，也就是说，两个或更多不同的数据库可以交换数据。 <br> 关系数据库通过写入数据更改进行同步，而基于文件系统的数据库则使用文件同步。 <br> 使用基于一组规则的Push和Pull方法进行双向复制。 <br> 可以通过安全网络和低带宽网络进行数据传输。 <br> 节点在故障后恢复并自动解决冲突时自动恢复。 <br> 与云兼容且功能强大的扩展API。 </p><br><h3 id="primer-1"> 例子 </h3><br><p> 可以通过以下两种方式之一配置SymmetricDS： <br> 集中协调两个从属（子）节点之间的数据复制的主（父）节点，子节点之间的数据交换仅通过父节点执行。 <br> 活动节点（节点1）可以与另一个活动节点（节点2）交换数据以进行复制，而无需中介。 </p><br><p> 在这两种情况下，都使用“推和拉”交换数据。 在此示例中，我们将查看主动-主动配置。 描述整个架构的时间过长，因此请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">指南</a>以了解有关SymmetricDS的更多信息。 </p><br><p> 安装SymmetricDS非常简单： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从此处</a>下载zip文件的开源版本，然后将其解压缩<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">到</a>任意位置。 下表提供了此示例中有关SymmetricDS的安装位置和版本以及两个节点的数据库版本，Linux版本，IP地址和端口的信息。 </p><br><div class="scrollable-table"><table><thead><tr><th> 主持人 </th><th> 虚拟机1 </th><th> 虚拟机2 </th></tr></thead><tbody><tr><td>  <strong>作业系统版本</strong> </td><td>  CentOS Linux 7.6 x86_64 </td><td>  CentOS Linux 7.6 x86_64 </td></tr><tr><td>  <strong>数据库服务器版本</strong> </td><td>  MySQL 5.7.26 </td><td>  PostgreSQL 10.5 </td></tr><tr><td>  <strong>数据库端口</strong> </td><td>  3306 </td><td>  5832 </td></tr><tr><td>  <strong>IP地址</strong> </td><td>  192.168.1.107 </td><td>  192.168.1.112 </td></tr><tr><td>  <strong>SymmetricDS版本</strong> </td><td>  SymmetricDS 3.9 </td><td>  SymmetricDS 3.9 </td></tr><tr><td>  <strong>SymmetricDS安装路径</strong> </td><td>  /usr/local/symmetric-server-3.9.20 </td><td>  /usr/local/symmetric-server-3.9.20 </td></tr><tr><td>  <strong>SymmetricDS节点名称</strong> </td><td>  corp-000 </td><td> 商店001 </td></tr></tbody></table></div><br><p> 在这里，我们将SymmetricDS安装在/usr/local/symmetric-server-3.9.20中，不同的子目录和文件将存储在此处。 我们对嵌套目录示例和引擎感兴趣。 示例目录包含具有主机属性的示例配置文件，以及用于快速启动演示的示例SQL脚本。 </p><br><p> 在示例目录中，我们看到三个具有节点属性的配置文件-名称显示了特定方案中节点的性质。 </p><br><pre> <code class="plaintext hljs">corp-000.properties store-001.properties store-002.properties</code> </pre> <br><p>  SymmetricDS具有3节点基本模式（选项1）的所有必需配置文件，并且相同的文件可用于2节点模式（选项2）。 将所需的配置文件从示例目录复制到vm1主机上的引擎。 原来是这样的： </p><br><pre> <code class="plaintext hljs">$&gt; cat engines/corp-000.properties engine.name=corp-000 db.driver=com.mysql.jdbc.Driver db.url=jdbc:mysql://192.168.1.107:3306/replica_db?autoReconnect=true&amp;useSSL=false db.user=root db.password=admin123 registration.url= sync.url=http://192.168.1.107:31415/sync/corp-000 group.id=corp external.id=000</code> </pre> <br><p>  SymmetricDS配置中的该节点称为corp-000，数据库连接由mysql jdbc驱动程序处理，该驱动程序使用上面指定的连接字符串和登录凭据。 我们连接到plicate_db数据库，并且将在创建模式期间创建表。  sync.url显示与节点进行通信的站点，以进行同步。 </p><br><p>  vm2主机上的节点2配置为store-001，其余节点在下面的node.properties文件中指定。  store-001节点运行PostgreSQL数据库，而pgdb_replica是用于复制的数据库。  registration.url允许vm2主机联系vm1主机并从中获取配置详细信息。 </p><br><pre> <code class="plaintext hljs">$&gt; cat engines/store-001.properties engine.name=store-001 db.driver=org.postgresql.Driver db.url=jdbc:postgresql://192.168.1.112:5832/pgdb_replica db.user=postgres db.password=admin123 registration.url=http://192.168.1.107:31415/sync/corp-000 group.id=store external.id=001</code> </pre> <br><p>  SymmetricDS预先构建的示例包含用于在两个数据库服务器（两个节点）之间设置双向复制的选项。 以下步骤在vm1主机（corp-000）上执行，这将创建一个包含4个表的示例架构。 然后，使用symadmin命令运行create-sym-tables会创建目录表，其中将存储节点之间的规则和复制方向。 最后，样本数据被加载到表中。 </p><br><pre> <code class="plaintext hljs">vm1$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm1$&gt; ./dbimport --engine corp-000 --format XML create_sample.xml vm1$&gt; ./symadmin --engine corp-000 create-sym-tables vm1$&gt; ./dbimport --engine corp-000 insert_sample.sql</code> </pre> <br><p> 在示例中，item和item_selling_price表被自动配置为从corp-000复制到store-001，sale表（sale_transaction和sale_return_line_item）被自动配置为从store-001复制到corp-000。 现在，在vm2主机（store-001）上的PostgreSQL数据库中创建模式，以准备从corp-000接收数据。 </p><br><pre> <code class="plaintext hljs">vm2$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm2$&gt; ./dbimport --engine store-001 --format XML create_sample.xml</code> </pre> <br><p> 确保检查vm1上的MySQL数据库是否具有示例表和SymmetricDS目录表。 请注意，SymmetricDS系统表（带有前缀sym_）现在仅在corp-000主机上可用，因为我们在此处运行了create-sym-tables命令并将管理复制。 并且在store-001节点上的数据库中，将只有4个示例表没有数据。 </p><br><p> 仅此而已。 该环境已准备就绪，可以在两个节点上运行符号服务器进程，如下所示。 </p><br><pre> <code class="plaintext hljs">vm1$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm1$&gt; sym 2&gt;&amp;1 &amp;</code> </pre> <br><p> 日志条目将发送到安装SymmetricDS的目录中日志文件夹中的后台日志文件（symmetric.log）以及标准输出。 现在可以在store-001节点上启动sym服务器。 </p><br><pre> <code class="plaintext hljs">vm2$&gt; cd /usr/local/symmetric-server-3.9.20/bin vm2$&gt; sym 2&gt;&amp;1 &amp;</code> </pre> <br><p> 如果您在vm2主机上运行sym服务器进程，它还将在PostgreSQL数据库中创建SymmetricDS目录表。 如果在两个节点上都运行sym服务器进程，则它们将相互协调以将数据从corp-000复制到store-001。 如果几秒钟后我们查询双方的所有4个表，我们将看到复制成功。 或者，您可以使用以下命令将引导程序从corp-000发送到store-001。 </p><br><pre> <code class="plaintext hljs">vm1$&gt; ./symadmin --engine corp-000 reload-node 001</code> </pre> <br><p> 此时，将一条新记录插入到主机corp-000（主机：vm1）上的MySQL数据库的项目表中，您可以验证其是否复制到主机store-001（主机：vm2）上的PostgreSQL数据库。 我们看到了将数据从corp-000移动到store-001的Pull操作。 </p><br><pre> <code class="plaintext hljs">mysql&gt; insert into item values ('22000002','Jelly Bean'); Query OK, 1 row affected (0.00 sec)</code> </pre> <br><pre> <code class="plaintext hljs">vm2$&gt; psql -p 5832 -U postgres pgdb_replica -c "select * from item" item_id | name ----------+----------- 11000001 | Yummy Gum 22000002 | Jelly Bean (2 rows)</code> </pre> <br><p> 要执行“推”操作以将数据从store-001移至corp-000，请在sale_transaction表中插入一条记录并验证复制是否完成。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结果。</a> </p><br><p> 我们看到在MySQL和PostgreSQL数据库之间成功建立了示例表的双向复制。 要为新用户表配置复制，请执行以下操作： 我们以创建表t1为例，并按如下配置其复制规则。 因此，我们仅配置从corp-000到store-001的复制。 </p><br><pre> <code class="plaintext hljs">mysql&gt; create table t1 (no integer); Query OK, 0 rows affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_channel (channel_id,create_time,last_update_time) values ('t1',current_timestamp,current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_trigger (trigger_id, source_table_name,channel_id, last_update_time, create_time) values ('t1', 't1', 't1', current_timestamp, current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><pre> <code class="plaintext hljs">mysql&gt; insert into sym_trigger_router (trigger_id, router_id, Initial_load_order, create_time,last_update_time) values ('t1', 'corp-2-store-1', 1, current_timestamp,current_timestamp); Query OK, 1 row affected (0.01 sec)</code> </pre> <br><p> 然后使用symadmin命令和sync-triggers参数将配置更改通知架构更改，即添加新表，该命令将重新创建触发器以匹配表定义。 执行发送模式以将架构更改发送到store-001节点，并配置了t1表复制。 </p><br><pre> <code class="plaintext hljs">vm1$&gt; ./symadmin -e corp-000 --node=001 sync-triggers vm1$&gt; ./symadmin send-schema -e corp-000 --node=001 t1</code> </pre> <br><h3 id="preimuschestva-symmetricds">  SymmetricDS的好处 </h3><br><p> 易于安装和配置，包括带有参数的现成文件集，用于创建具有三个或两个节点的电路。 <br> 跨平台数据库和平台独立性，包括服务器，便携式计算机和移动设备。 <br> 将任何数据库复制到本地，WAN或云中的任何其他数据库。 <br> 可以与几个数据库或数千个数据库进行最佳工作以实现轻松复制的能力。 <br> 付费版本具有图形界面和出色的支持。 </p><br><h3 id="nedostatki-symmetricds">  SymmetricDS的缺点 </h3><br><p> 必须通过命令行上的SQL语句手动确定复制的规则和方向，以加载目录表，这很不方便。 <br> 如果不使用脚本来创建用于定义复制规则和方向的SQL语句，则设置许多用于复制的表可能很繁琐。 <br> 日志中输入的信息过多，有时您需要清理日志文件，以免占用过多空间。 </p><br><h3 id="itogi-po-symmetricds">  SymmetricDS摘要 </h3><br><p>  SymmetricDS允许您在两个，三个甚至数千个节点之间配置双向复制，以复制和同步文件。 这是一个独特的工具，可以独立执行许多任务，例如，在节点长时间停机后自动恢复数据，通过HTTPS在节点之间安全有效地交换数据，基于一组规则的自动冲突管理等。SymmetricDS在任何数据库之间复制，因此，它可以用于各种场景，包括跨平台的迁移，升级，分发，过滤和数据转换。 </p><br><p> 该示例基于官方的SymmetricDS快速<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">入门指南</a> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用户指南</a>详细介绍了与使用SymmetricDS配置复制相关的各种概念。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467313/">https://habr.com/ru/post/zh-CN467313/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467295/index.html">期待已久的Android中的视图绑定</a></li>
<li><a href="../zh-CN467299/index.html">概念：简化STD Utility类的实现</a></li>
<li><a href="../zh-CN467301/index.html">AI在《杀手》中的运作方式（2016）</a></li>
<li><a href="../zh-CN467303/index.html">最年轻的PSB程序员的故事：黑客马拉松成为银行的大门</a></li>
<li><a href="../zh-CN467305/index.html">当城市变得聪明时：大城市的体验</a></li>
<li><a href="../zh-CN467317/index.html">软银如何吞噬世界</a></li>
<li><a href="../zh-CN467323/index.html">Qt Creator 4.10和QBS 1.14微控制器编程功能概述</a></li>
<li><a href="../zh-CN467327/index.html">我在35岁时如何成为一名程序员</a></li>
<li><a href="../zh-CN467329/index.html">最好的产品始于实际的问题：有关即将完成的工作的对讲机。 第一部分</a></li>
<li><a href="../zh-CN467331/index.html">在WordPress上以269美元的价格出售+一个漂亮的在线商店-我们的经验</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>