<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüè≠ üÜó üî≥ HTTP / 3: quebrando as funda√ß√µes e um admir√°vel mundo novo üàÅ ‚úàÔ∏è üàÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° mais de 20 anos, visualizamos p√°ginas da Web usando o protocolo HTTP. A maioria dos usu√°rios n√£o pensa sobre o que √© e como funciona. Outros sabem ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>HTTP / 3: quebrando as funda√ß√µes e um admir√°vel mundo novo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/473930/">  H√° mais de 20 anos, visualizamos p√°ginas da Web usando o protocolo HTTP.  A maioria dos usu√°rios n√£o pensa sobre o que √© e como funciona.  Outros sabem que em algum lugar sob HTTP existe TLS e, sob ele, TCP, sob qual IP e assim por diante.  E o terceiro - hereges - acredita que o TCP √© o s√©culo passado, eles querem algo mais r√°pido, mais confi√°vel e mais seguro.  Mas, em suas tentativas de inventar um novo protocolo ideal, eles voltaram √†s tecnologias dos anos 80 e est√£o tentando construir sobre eles o seu admir√°vel mundo novo. <br><img src="https://habrastorage.org/webt/fg/dx/5l/fgdx5lvjrdjflaapjav9z0xwpyk.jpeg"><br><a name="habracut"></a><br><h2>  Um pouco de hist√≥ria: HTTP / 1.1 </h2><br>  Em 1997, o protocolo de troca de texto HTTP vers√£o 1.1 ganhou seu RFC.  Naquela √©poca, o protocolo era usado pelos navegadores por v√°rios anos, e o novo padr√£o durava outros quinze.  O protocolo funcionava apenas com base na solicita√ß√£o-resposta e era destinado principalmente √† transmiss√£o de informa√ß√µes textuais. <br><br>  O HTTP foi projetado para funcionar com base no protocolo TCP, que garante a entrega confi√°vel de pacotes ao destino.  O TCP baseia-se no estabelecimento e na manuten√ß√£o de uma conex√£o confi√°vel entre os terminais e o tr√°fego de segmenta√ß√£o.  Os segmentos t√™m seu pr√≥prio n√∫mero de sequ√™ncia e soma de verifica√ß√£o.  Se de repente um dos segmentos n√£o vier ou vier com a soma de verifica√ß√£o errada, a transmiss√£o ser√° interrompida at√© que o segmento perdido seja restaurado. <br><br>  No HTTP / 1.0, a conex√£o TCP foi fechada ap√≥s cada solicita√ß√£o.  Foi extremamente in√∫til, j√° que  Estabelecer uma conex√£o TCP (Handshake de 3 vias) n√£o √© um processo r√°pido.  O HTTP / 1.1 introduziu o mecanismo keep-alive, que permite reutilizar uma √∫nica conex√£o para v√°rias solicita√ß√µes.  No entanto, como ele pode facilmente se tornar um gargalo, v√°rias conex√µes TCP / IP com o mesmo host s√£o permitidas em diferentes implementa√ß√µes HTTP / 1.1.  Por exemplo, no Chrome e nas vers√µes recentes do Firefox, s√£o permitidas at√© seis conex√µes. <br><img src="https://habrastorage.org/webt/jg/89/qj/jg89qjf71ebwzitjnv4uwke3oua.png"><br>  A criptografia tamb√©m deveria ser deixada para outros protocolos e, para isso, o protocolo TLS era usado sobre TCP, que protegia dados com seguran√ßa, mas aumentava ainda mais o tempo necess√°rio para estabelecer uma conex√£o.  Como resultado, o processo de handshake come√ßou a ficar assim: <br><img src="https://habrastorage.org/webt/2b/nb/qw/2bnbqw9jz94njlrds7e6l-omzmw.png"><br>  <i>Ilustra√ß√£o Cloudflare</i> <br><br>  Assim, o HTTP / 1.1 teve v√°rios problemas: <br><br><ul><li>  Configura√ß√£o de conex√£o lenta. </li><li>  Uma conex√£o TCP √© usada para uma solicita√ß√£o, o que significa que o restante das solicita√ß√µes deve encontrar outra conex√£o ou aguardar at√© que a solicita√ß√£o atual a libere. </li><li>  Apenas o modelo pull √© suportado.  N√£o h√° nada no padr√£o sobre push do servidor. </li><li>  Os t√≠tulos s√£o transmitidos em texto. </li></ul><br>  Se o push do servidor for implementado de alguma forma usando o protocolo WebSocket, o restante dos problemas precisar√° ser tratado de maneira mais radical. <br><br><h2>  Um pouco de modernidade: HTTP / 2 </h2><br>  Em 2012, o trabalho no protocolo SPDY (pronunciado ‚Äúvelocidade‚Äù) come√ßou nas entranhas do Google.  O protocolo foi projetado para resolver os problemas b√°sicos do HTTP / 1.1 e, ao mesmo tempo, precisava manter a compatibilidade com vers√µes anteriores.  Em 2015, o grupo de trabalho da IETF introduziu a especifica√ß√£o HTTP / 2 com base no protocolo SPDY.  Aqui est√£o as diferen√ßas no HTTP / 2: <br><br><ul><li>  Serializa√ß√£o bin√°ria. </li><li>  Multiplexar v√°rias solicita√ß√µes HTTP em uma √∫nica conex√£o TCP. </li><li>  Push do servidor pronto para uso (sem WebSocket). </li></ul><br>  O protocolo foi um grande passo em frente.  Ele <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://">supera</a> muito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://">a primeira vers√£o</a> e n√£o requer a cria√ß√£o de v√°rias conex√µes TCP: todos os pedidos para um host s√£o multiplexados em um.  Ou seja, em uma conex√£o, existem v√°rios fluxos chamados, cada um com seu pr√≥prio ID.  O b√¥nus √© um push do servidor in a box. <br><br>  No entanto, a multiplica√ß√£o leva a outro problema fundamental.  Imagine que executamos assincronamente 5 solicita√ß√µes para um servidor.  Ao usar HTTP / 2, todas essas solicita√ß√µes ser√£o executadas na mesma conex√£o TCP, o que significa que, se um dos segmentos de qualquer solicita√ß√£o for perdido ou chegar incorretamente, a transmiss√£o de todas as solicita√ß√µes e respostas ser√° interrompida at√© que o segmento perdido seja restaurado.  Obviamente, quanto pior a qualidade da conex√£o, mais lento o HTTP / 2 funciona.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://">De acordo com Daniel Stenberg</a> , em uma situa√ß√£o em que os pacotes perdidos representam 2% de todos, o HTTP / 1.1 em um navegador tem um desempenho melhor que o HTTP / 2 devido ao fato de abrir 6 conex√µes, n√£o uma. <br><br>  Esse problema √© chamado de "bloqueio de linha de frente" e, infelizmente, n√£o √© poss√≠vel resolv√™-lo usando o TCP. <br><img src="https://habrastorage.org/webt/nu/zn/ry/nuznryxm_rxuyjadhx2kjyhbluc.png"><br>  <i>Ilustra√ß√£o de Daniel Steinberg</i> <br><br>  Como resultado, os desenvolvedores do padr√£o HTTP / 2 fizeram um √≥timo trabalho e fizeram quase tudo o que podia ser feito no n√≠vel do aplicativo do modelo OSI.  √â hora de descer ao n√≠vel de transporte e inventar um novo protocolo de transporte. <br><br><h2>  Precisamos de um novo protocolo: UDP vs TCP </h2><br>  Muito rapidamente ficou claro que introduzir um protocolo de camada de transporte completamente novo √© uma tarefa insol√∫vel nas realidades de hoje.  O fato √© que as gl√¢ndulas ou caixas intermedi√°rias (roteadores, firewalls, servidores NAT ...) conhecem o n√≠vel de transporte e ensinar algo novo a elas √© uma tarefa extremamente dif√≠cil.  Al√©m disso, o suporte a protocolos de transporte est√° conectado ao kernel dos sistemas operacionais, e os kernels tamb√©m mudam de maneira n√£o muito volunt√°ria. <br><br>  E aqui pode-se desistir e dizer: "√â claro que inventaremos um novo HTTP / 3 com prefer√™ncia e cortes√£s, mas ser√° implementado em 10 a 15 anos (ap√≥s esse per√≠odo, a maioria das gl√¢ndulas ser√° substitu√≠da)", mas h√° mais uma op√ß√£o √≥bvia: use o protocolo UDP.  Sim, sim, o mesmo protocolo de acordo com o qual lan√ßamos arquivos em uma LAN no final dos anos 90 e no in√≠cio de zero.  Quase todas as pe√ßas de ferro de hoje sabem como trabalhar com ela. <br><br>  Quais s√£o as vantagens do UDP sobre TCP?  Primeiro de tudo, n√£o temos uma sess√£o de n√≠vel de transporte que a Iron conhe√ßa.  Isso nos permite determinar a sess√£o nos pontos de extremidade e resolver conflitos que surgem l√°.  Ou seja, n√£o estamos limitados a uma ou v√°rias sess√µes (como no TCP), mas podemos cri√°-las o quanto for necess√°rio.  Em segundo lugar, a transmiss√£o de dados pelo UDP √© mais r√°pida que pelo TCP.  Assim, em teoria, podemos romper o limite de velocidade de hoje alcan√ßado em HTTP / 2. <br><br>  No entanto, o UDP n√£o garante transmiss√£o de dados confi√°vel.  De fato, simplesmente enviamos pacotes, esperando que sejam recebidos no outro extremo.  N√£o recebeu?  Bem, sem sorte ... Isso foi o suficiente para transmitir v√≠deo para adultos, mas para coisas mais s√©rias voc√™ precisa de confiabilidade, o que significa que voc√™ precisa enrolar algo mais sobre o UDP. <br><br>  Assim como no HTTP / 2, o trabalho de cria√ß√£o de um novo protocolo come√ßou no Google em 2012, ou seja, quase ao mesmo tempo que o in√≠cio do trabalho no SPDY.  Em 2013, Jim Roskind introduziu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o protocolo QUIC (Quick UDP Internet Connections) ao</a> p√∫blico em geral e, em 2015, o Internet Draft foi introduzido para padronizar o IETF.  J√° naquela √©poca, o protocolo desenvolvido por Roskind no Google era muito diferente do padr√£o, ent√£o a vers√£o do Google era chamada gQUIC. <br><br><h4>  O que √© QUIC </h4><br>  Primeiro, como j√° mencionado, este √© um inv√≥lucro sobre o UDP.  A conex√£o QUIC se eleva acima do UDP, na qual, por analogia com HTTP / 2, v√°rios fluxos podem existir.  Esses fluxos existem apenas nos pontos de extremidade e s√£o atendidos independentemente.  Se a perda de pacotes ocorreu em um fluxo, isso n√£o afetar√° os outros. <br><img src="https://habrastorage.org/webt/91/ml/el/91mlel1x2cca1jpzdkmqgyhenog.png"><br>  <i>Ilustra√ß√£o de Daniel Steinberg</i> <br><br>  Em segundo lugar, a criptografia agora √© implementada n√£o em um n√≠vel separado, mas inclu√≠da no protocolo.  Isso permite que voc√™ estabele√ßa uma conex√£o e troque chaves p√∫blicas em um √∫nico handshake, al√©m de usar o complicado mecanismo de handshake 0-RTT e geralmente evite atrasos nas m√£os tr√™mulas.  Al√©m disso, pacotes de dados individuais agora podem ser criptografados.  Isso permite que voc√™ n√£o espere pela conclus√£o do recebimento de dados do fluxo, mas descriptografe os pacotes recebidos independentemente.  Este modo de opera√ß√£o n√£o era poss√≠vel no TCP, porque  O TLS e o TCP funcionavam independentemente um do outro, e o TLS n√£o sabia em que partes os dados do TCP seriam divididos.  E, portanto, n√£o pude preparar meus segmentos para que eles se ajustassem aos segmentos TCP um a um e pudessem ser descriptografados independentemente.  Todas essas melhorias permitem que o QUIC reduza a lat√™ncia em compara√ß√£o com o TCP. <br><img src="https://habrastorage.org/webt/cf/nn/m3/cfnnm3uoherao-9oczolm2h7vxk.png"><br>  Em terceiro lugar, o conceito de fluxos f√°ceis permite desatar a conex√£o do endere√ßo IP do cliente.  Isso √© importante, por exemplo, quando um cliente muda de um ponto de acesso Wi-Fi para outro, alterando seu IP.  Nesse caso, ao usar o TCP, ocorre um longo processo durante o qual as conex√µes TCP existentes caem no tempo limite e novas conex√µes s√£o criadas a partir do novo IP.  No caso do QUIC, o cliente simplesmente continua a enviar pacotes do novo IP para o servidor com o ID do fluxo antigo.  Porque  O ID do fluxo agora √© exclusivo e n√£o √© reutilizado, o servidor entende que o cliente alterou o IP, envia os pacotes perdidos e continua a comunica√ß√£o com o novo endere√ßo. <br><br>  Quarto, o QUIC √© implementado no n√≠vel do aplicativo, n√£o no sistema operacional.  Isso, por um lado, permite mudan√ßas mais r√°pidas no protocolo, como  Para obter uma atualiza√ß√£o, basta atualizar a biblioteca, em vez de esperar por uma nova vers√£o do sistema operacional.  Por outro lado, isso leva a um forte aumento no consumo do processador. <br><br>  E, finalmente, as manchetes.  A compacta√ß√£o de cabe√ßalho refere-se apenas a pontos que diferem em QUIC e gQUIC.  N√£o vejo raz√£o para dedicar muito tempo a isso; s√≥ posso dizer que na vers√£o enviada para padroniza√ß√£o, a compacta√ß√£o de cabe√ßalho foi feita o mais semelhante poss√≠vel √† compacta√ß√£o de cabe√ßalho no HTTP / 2.  Mais detalhes podem ser lidos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h4>  Qu√£o r√°pido √©? </h4><br>  Esta √© uma pergunta complicada.  O fato √© que, embora n√£o tenhamos um padr√£o, n√£o h√° nada especial para medir.  Talvez as √∫nicas estat√≠sticas que temos sejam as estat√≠sticas do Google, que usam o gQUIC desde 2013 e em 2016 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relataram √† IETF</a> que cerca de 90% do tr√°fego que chega aos seus servidores no navegador Chrome agora est√° usando o QUIC.  Na mesma apresenta√ß√£o, eles relatam que, por meio do gQUIC, as p√°ginas carregam cerca de 5% mais r√°pido e o streaming de v√≠deo tem 30% menos congelamentos em compara√ß√£o com o TCP. <br><br>  Em 2017, um grupo de pesquisadores liderado por Arash Molavi Kakhki publicou um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grande trabalho</a> sobre o estudo do desempenho do gQUIC comparado ao TCP. <br>  O estudo revelou v√°rios pontos fracos do gQUIC, como instabilidade na mistura de pacotes de rede, injusti√ßa na capacidade do canal e transfer√™ncia mais lenta de objetos pequenos (at√© 10 kb).  Este √∫ltimo, no entanto, pode ser compensado pelo uso do 0-RTT.  Em todos os outros casos investigados, o gQUIC mostrou um aumento na velocidade em compara√ß√£o ao TCP.  √â dif√≠cil falar sobre n√∫meros espec√≠ficos.  √â melhor ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o estudo em si</a> ou um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post curto</a> . <br><br>  Aqui, deve-se dizer que esses dados s√£o especificamente sobre gQUIC e s√£o irrelevantes para o padr√£o que est√° sendo desenvolvido.  O que acontecer√° com o QUIC: at√© agora, o mist√©rio est√° por tr√°s de sete selos, mas h√° esperan√ßa de que as fraquezas identificadas pelo gQUIC sejam levadas em considera√ß√£o e corrigidas. <br><br><h2>  Um pouco de futuro: e o HTTP / 3? </h2><br>  E aqui est√° tudo claro: a API n√£o muda de forma alguma.  Tudo permanecer√° exatamente igual ao HTTP / 2.  Bem, se a API permanecer a mesma, a transi√ß√£o para o HTTP / 3 ter√° que ser decidida usando a vers√£o mais recente da biblioteca que suporta o transporte via QUIC no back-end.  √â verdade que, por um longo tempo, voc√™ ainda precisa manter o fallback para vers√µes mais antigas do HTTP, porque  a Internet n√£o est√° pronta para uma mudan√ßa completa para o UDP. <br><br><h4>  Quem j√° est√° apoiando </h4><br>  Aqui est√° uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lista de</a> implementa√ß√µes QUIC existentes.  Apesar da falta de um padr√£o, a lista n√£o √© ruim. <br><br>  Atualmente, nenhum navegador suporta QUIC na vers√£o.  Recentemente, havia informa√ß√µes de que o Chrome inclu√≠a suporte a HTTP / 3, mas at√© agora apenas no Canary. <br><br>  Dos back-ends, o HTTP / 3 suporta apenas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caddy</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://blog.cloudflare.com/">Cloudflare</a> , mas at√© agora experimentalmente.  A NGINX <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anunciou</a> no final da primavera de 2019 que havia come√ßado a trabalhar no suporte a HTTP / 3, mas ainda n√£o o havia conclu√≠do. <br><br><h4>  Quais s√£o os problemas </h4><br>  Vivemos no mundo real, onde nem uma √∫nica grande tecnologia pode chegar √†s massas sem encontrar resist√™ncia, e o QUIC n√£o √© exce√ß√£o. <br><br>  Mais importante, voc√™ precisa de alguma forma explicar ao navegador que "https: //" n√£o √© mais um fato que leva √† 443¬™ porta TCP.  Pode n√£o haver TCP.  Para fazer isso, use o cabe√ßalho Alt-Svc.  Ele permite que o navegador seja informado de que este site tamb√©m est√° dispon√≠vel em tal protocolo e em tal endere√ßo.  Em teoria, isso deve funcionar como um rel√≥gio, mas, na pr√°tica, nos deparamos com o fato de que o UDP pode ser, por exemplo, desativado em um firewall para evitar ataques DDoS. <br><br>  Mas, mesmo que o UDP n√£o seja proibido, o cliente pode estar atr√°s de um roteador NAT configurado para armazenar uma sess√£o TCP por endere√ßo IP, como  usamos o UDP, em que n√£o h√° sess√£o de hardware, o NAT n√£o ret√©m a conex√£o e a sess√£o QUIC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sempre √© encerrada</a> . <br><br>  Todos esses problemas est√£o relacionados ao fato de o UDP n√£o ter sido usado anteriormente para transmitir conte√∫do da Internet e os fabricantes de hardware n√£o poderiam prever que isso aconteceria.  Da mesma forma, os administradores ainda n√£o entendem como configurar corretamente suas redes para o QUIC.  Essa situa√ß√£o mudar√° lentamente e, em qualquer caso, essas altera√ß√µes levar√£o menos tempo do que a introdu√ß√£o de um novo protocolo da camada de transporte. <br><br>  Al√©m disso, como j√° descrito, o QUIC aumenta bastante a utiliza√ß√£o do processador.  Daniel Stenberg <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">avaliou o</a> crescimento do processador em at√© tr√™s vezes. <br><br><h4>  Quando o HTTP / 3 chega </h4><br>  Eles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">querem adotar o</a> padr√£o at√© maio de 2020, mas, como os documentos agendados para julho de 2019 permanecem inacabados, podemos dizer que a data provavelmente ser√° adiada. <br><br>  Bem, o Google usa sua implementa√ß√£o do gQUIC desde 2013.  Se voc√™ olhar para a solicita√ß√£o HTTP enviada ao mecanismo de pesquisa do Google, poder√° ver o seguinte: <br><img src="https://habrastorage.org/webt/51/ck/e2/51cke2t4uepw6hbasyq9oqhvjtc.png"><br><br><h2>  Conclus√µes </h2><br>  O QUIC agora parece uma tecnologia bastante bruta, mas muito promissora.  Considerando que, nos √∫ltimos 20 anos, todas as otimiza√ß√µes dos protocolos da camada de transporte relacionadas principalmente ao TCP, QUIC, que na maioria dos casos obt√©m desempenho, agora parecem extremamente boas. <br><br>  No entanto, ainda existem problemas n√£o resolvidos que devem ser tratados nos pr√≥ximos anos.  O processo pode ser atrasado devido ao fato de haver hardware envolvido, que ningu√©m gosta de atualizar, mas, no entanto, todos os problemas parecem bastante solucion√°veis ‚Äã‚Äãe, mais cedo ou mais tarde, todos teremos HTTP / 3. <br><br>  O futuro n√£o est√° longe! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473930/">https://habr.com/ru/post/pt473930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473916/index.html">Hist√≥rias do data center: hist√≥rias de horror do Dia das Bruxas sobre diesel, diplomacia e parafusos perfuradores no aquecedor</a></li>
<li><a href="../pt473918/index.html">Viagem pela Internet na R√∫ssia: velocidade e oportunidade</a></li>
<li><a href="../pt473922/index.html">Confer√™ncia da Academia de Redes Selectel</a></li>
<li><a href="../pt473924/index.html">N√£o apenas SMS e token: autentica√ß√£o multifatorial baseada no Servi√ßo de autentica√ß√£o SafeNet</a></li>
<li><a href="../pt473928/index.html">Extin√ß√£o de arquivos de computador</a></li>
<li><a href="../pt473932/index.html">Como funciona uma IA de jogos h√≠bridos e quais s√£o suas vantagens</a></li>
<li><a href="../pt473936/index.html">Desempenho interativo de √°udio - uma nova era dos jogos de assistente de voz</a></li>
<li><a href="../pt473938/index.html">Armazenar universalmente as configura√ß√µes do aplicativo por meio da configura√ß√£o ICon</a></li>
<li><a href="../pt473940/index.html">Teste de for√ßa: nanomec√¢nica de madrep√©rola concha pinna nobre</a></li>
<li><a href="../pt473944/index.html">Conselho do criador do RimWorld: distor√ß√µes cognitivas na previs√£o de um f√£ do jogo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>