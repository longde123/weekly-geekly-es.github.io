<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🌾 👨🏾‍🚀 😇 Nuevo en SObjectizer-5.5.23: ¿Cumplimiento de los deseos o la caja de Pandora? 👩🏿‍🏫 😸 📉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo es una continuación de un artículo de reflexión publicado hace un mes, " ¿Es fácil agregar nuevas funciones al marco anterior? La agonía...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nuevo en SObjectizer-5.5.23: ¿Cumplimiento de los deseos o la caja de Pandora?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426983/"><img src="https://habrastorage.org/webt/kt/xf/7o/ktxf7oduhnd0zuhd_tpaju7p_em.jpeg"><br><br>  Este artículo es una continuación de un artículo de reflexión publicado hace un mes, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Es fácil agregar nuevas funciones al marco anterior? La agonía de elegir en el ejemplo del desarrollo de SObjectizer</a> ".  Ese artículo describió la tarea que queríamos resolver en la próxima versión de SObjectizer, examinó dos enfoques para su solución y enumeró las ventajas y desventajas de cada uno de los enfoques. <br><br>  Con el paso del tiempo, se implementó uno de los enfoques y nuevas versiones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> , así como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> adjunto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">so_5_extra</a> , ya llamado " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respirar profundamente</a> ".  Literalmente puedes tomar y probar. <br><br>  Hoy hablaremos sobre lo que se hizo, por qué se hizo, a qué condujo.  Si alguien está interesado en seguir cómo se está desarrollando uno de los pocos marcos de actores en vivo, multiplataforma y abiertos para C ++, puede utilizar cat. <br><a name="habracut"></a><br><h1>  ¿Cómo empezó todo? </h1><br>  Todo comenzó con un intento de resolver el problema de la cancelación garantizada de temporizadores.  La esencia del problema es que cuando se envía un mensaje retrasado o periódico, el programador puede cancelar la entrega del mensaje.  Por ejemplo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer_id = so_5::send_periodic&lt;my_message&gt;(my_agent, <span class="hljs-number"><span class="hljs-number">10</span></span>s, <span class="hljs-number"><span class="hljs-number">10</span></span>s, ...); ... <span class="hljs-comment"><span class="hljs-comment">// - . // ,    my_message    . timer_id.release(); //      my_message.</span></span></code> </pre> <br>  Después de llamar a <i>timer_id.release (), el</i> temporizador ya no enviará nuevas instancias del mensaje my_message.  Pero esas copias que ya se han enviado y están en la cola de los destinatarios no irán a ninguna parte.  Con el tiempo, se extraerán de estas mismas colas y se transferirán a los agentes receptores para su procesamiento. <br><br>  Este problema es una consecuencia de los principios básicos de funcionamiento de SObjectizer-5 y no tiene una solución simple debido a que SObjectizer no puede extraer mensajes de las colas.  No puede porque las colas en SObjectizer pertenecen a despachadores, los despachadores son diferentes, sus colas también están organizadas de manera diferente.  Incluyendo que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay despachadores que no son parte del SObjectizer,</a> y SObjectizer, en principio, no puede saber cómo funcionan estos despachadores. <br><br>  En general, existe tal característica en los temporizadores nativos de SObjectizer.  No es que estropee demasiado a los desarrolladores.  Pero se debe tener especial cuidado.  Especialmente para principiantes que recién se están familiarizando con el marco. <br><br>  Y luego, finalmente, las manos fueron al punto de proponer una solución a este problema. <br><br><h1>  ¿Qué camino de solución fue elegido? </h1><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo anterior</a> , se consideraron dos posibles opciones.  La primera opción no requería modificaciones al mecanismo de entrega de mensajes en SObjectizer, pero requería que el programador cambiara explícitamente el tipo de mensaje enviado / recibido. <br><br>  La segunda opción requería la modificación del mecanismo de entrega de mensajes SObjectizer.  Se eligió este camino, ya que permitió ocultar al destinatario del mensaje el hecho de que el mensaje se envió de alguna manera específica. <br><br><h2>  ¿Qué ha cambiado en SObjectizer? </h2><br><h3>  Nuevo concepto: sobre con mensaje dentro </h3><br>  El primer componente de la solución implementada es la adición de un concepto como un sobre a SObjectizer.  Un sobre es un mensaje especial, dentro del cual se encuentra el mensaje actual (carga útil).  SObjectizer entrega el sobre con el mensaje al destinatario casi de la forma habitual.  La diferencia fundamental en el procesamiento de sobres se detecta solo en la última etapa de entrega: <br><br><ul><li>  al entregar un mensaje normal, el agente receptor simplemente busca un controlador para este tipo de mensaje y, si se encuentra dicho controlador, se llama al controlador encontrado y el mensaje entregado se devuelve como un parámetro; </li><li>  y al entregar el sobre con el mensaje después de encontrar el controlador, primero se hace un intento para sacar el mensaje del sobre.  Y solo si el sobre dio el mensaje almacenado en él, solo entonces se llama al controlador. </li></ul><br>  Aquí hay dos puntos clave que tienen un gran impacto en por qué y cómo se pueden usar los sobres de mensajes. <br><br>  El primer punto clave es que se solicita un mensaje de un sobre solo cuando se encuentra un controlador de mensaje en el destinatario.  Es decir  solo cuando el mensaje realmente se haya entregado al destinatario y el destinatario esté aquí y ahora procesará este mensaje. <br><br>  El segundo punto clave aquí es que el sobre puede no revelar el mensaje que contiene.  Es decir, por ejemplo, un sobre puede verificar la hora actual y decidir que se han perdido todas las fechas de entrega y, por lo tanto, el mensaje ha dejado de ser relevante y no se puede procesar.  Por lo tanto, el sobre no dará el mensaje.  En consecuencia, SObjectizer simplemente ignorará este sobre y no tomará ninguna acción adicional. <br><br><h4>  ¿Cómo es un sobre? </h4><br>  Un sobre es una implementación de la interfaz envolvente_t, que se define de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SO_5_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envelope_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-comment"><span class="hljs-comment">// -. //   ,       //    . virtual void handler_found_hook( handler_invoker_t &amp; invoker ) noexcept = 0; //   ,      //     . virtual void transformation_hook( handler_invoker_t &amp; invoker ) noexcept = 0; private : kind_t so5_message_kind() const noexcept override { return kind_t::enveloped_msg; } };</span></span></code> </pre> <br>  Es decir  Un sobre es esencialmente el mismo mensaje que todos los demás.  Pero con un atributo especial, que es devuelto por el método so5_message_kind (). <br><br>  El programador puede desarrollar sus sobres heredando de envolvente_t (o, más convenientemente, de <a href="">so_5 :: extra :: envolped_msg :: just_envelope_t</a> ) y anulando los métodos de enlace handler_found_hook () y transformación_hook (). <br><br>  Dentro de los métodos de enlace, el desarrollador del sobre decide si quiere dar el mensaje dentro del sobre para su procesamiento / transformación o no.  Si lo desea, entonces el desarrollador debe llamar al método invoke () y al objeto invocador.  Si no quiere, no llama, en este caso se ignorará el sobre y su contenido. <br><br><h4>  ¿Cómo resuelven los sobres el problema de cancelar los temporizadores? </h4><br>  La solución, que ahora se implementa en so_5_extra en forma del espacio de nombres so_5 :: extra :: revocable_timer, es muy simple: el envío especial de un mensaje pendiente o periódico crea un sobre especial, dentro del cual se ubica no solo el mensaje en sí, sino también el indicador atómico revocado.  Si se borra esta bandera, el mensaje se considera relevante.  Si se establece, el mensaje se considera retirado. <br><br>  Cuando se llama al método de enlace en el sobre, el sobre verifica el valor de la bandera revocada.  Si se establece la bandera, el sobre no muestra un mensaje.  Por lo tanto, el mensaje no se procesa incluso si el temporizador ya ha logrado poner el mensaje en la cola del receptor. <br><br><h3>  Extensión de interfaz abstract_message_box_t </h3><br>  Agregar la interfaz envolvente_t es solo una parte de la implementación de sobres en SObjectizer.  La segunda parte es tener en cuenta el hecho de la existencia de sobres en el mecanismo de entrega de mensajes dentro del SObjectizer. <br><br>  Aquí, desafortunadamente, no podría prescindir sin hacer que los cambios sean visibles para el usuario.  En particular, en la clase abstract_message_box_t, que define la interfaz de todos los buzones en SObjectizer, fue necesario agregar otro método virtual: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_deliver_enveloped_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::type_index &amp; msg_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> overlimit_reaction_deep )</span></span></span></span>;</code> </pre> <br>  Este método es responsable de entregar un sobre de mensaje con un mensaje de tipo msg_type al receptor.  Tal entrega puede diferir en los detalles de implementación dependiendo de qué tipo de mbox sea. <br><br>  Al agregar do_deliver_enveloped_msg () a abstract_message_box_t, teníamos una opción: convertirlo en un método virtual puro u ofrecer algún tipo de implementación predeterminada. <br><br>  Si hiciéramos do_deliver_enveloped_msg () un método virtual puro, entonces romperíamos la compatibilidad entre las versiones de SObjectizer en la rama 5.5.  Después de todo, los usuarios que escribieron sus propias implementaciones de mbox tendrían que modificar sus propios mboxes al cambiar a SObjectizer-5.5.23, de lo contrario no podrían compilar con la nueva versión de SObjectizer. <br><br>  No queríamos esto, por lo que no hicimos do_deliver_enveloped_msg () un método virtual puro en v.5.5.23.  Tiene una implementación predeterminada que solo arroja una excepción.  Por lo tanto, los usuarios personalizados mbox-s podrán continuar trabajando normalmente con mensajes regulares, pero se negarán automáticamente a aceptar sobres.  Encontramos este comportamiento más aceptable.  Además, en la etapa inicial, es poco probable que los sobres con mensajes sean ampliamente utilizados, y es poco probable que en la "naturaleza" se encuentren a menudo implementaciones personalizadas de SObjectizer mboxes;) <br><br>  Además, hay muchas posibilidades de que en las versiones principales posteriores de SObjectizer, donde no veremos la compatibilidad con la rama 5.5, la interfaz abstract_message_box_t sufra cambios importantes.  Pero ya nos estamos adelantando ... <br><br><h2>  Cómo enviar sobres con mensajes </h2><br>  SObjectizer-5.5.23 en sí mismo no proporciona un medio simple para enviar sobres.  Se supone que se está desarrollando un tipo específico de sobre y herramientas apropiadas para una tarea específica para enviar convenientemente sobres de un tipo específico.  Un ejemplo de esto se puede ver en <a href="">so_5 :: extra :: revocable_timer</a> , donde necesita no solo enviar el sobre, sino también darle al usuario un timer_id especial. <br><br>  Para situaciones más simples, puede usar las herramientas de <a href="">so_5 :: extra :: wrapped_msg</a> .  Por ejemplo, así es como se envía un mensaje con una restricción dada en el momento de su entrega: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// make     . so_5::extra::enveloped_msg::make&lt;my_message&gt;(... /*    */) // envelope         . //  5s        . .envelope&lt;so_5::extra::enveloped_msg::time_limited_delivery_t&gt;(5s) //        . .send_to(destination);</span></span></code> </pre> <br><h2>  Para que todo sea divertido: sobres en sobres </h2><br>  Los sobres están diseñados para llevar algunos mensajes dentro de sí mismos.  Pero cuales? <br><br>  Cualquiera. <br><br>  Y esto nos lleva a una pregunta interesante: ¿es posible poner un sobre dentro de otro sobre? <br><br>  Si puedes.  Tanto como quieras  La profundidad de anidamiento está limitada solo por el sentido común del desarrollador y la profundidad de la pila para la llamada recursiva handler_found_hook / conversion_hook. <br><br>  Al mismo tiempo, SObjectizer se dirige a los desarrolladores de sus propios sobres: el sobre no debe pensar en lo que contiene: un mensaje específico u otro sobre.  Cuando se llama al método de enlace en el sobre y el sobre decide que puede dar su contenido, el sobre simplemente llama a invoke () en handler_invoker_t y pasa un enlace a su contenido en invoke ().  Y ya invocar () dentro descubrirá a qué se enfrenta.  Y si este es otro sobre, invoke () llamará al método de enlace requerido en este sobre. <br><br>  Usando el kit de herramientas que se muestra arriba de so_5 :: extra :: wrapped_msg, el usuario puede hacer varios sobres anidados como este: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;my_message&gt;(...) <span class="hljs-comment"><span class="hljs-comment">// ,        my_message. .envelope&lt;inner_envelope_type&gt;(...) // ,      inner_envelope_type. .envelope&lt;outer_envelope_type&gt;(...) .send_to(destination);</span></span></code> </pre> <br><h1>  Algunos ejemplos de uso de sobres </h1><br>  Ahora, después de haber recorrido los aspectos internos de SObjectizer-5.5.23, es hora de pasar a la parte de aplicación más útil para los usuarios.  A continuación hay algunos ejemplos que se basan en lo que ya está implementado en so_5_extra, o usan las herramientas de so_5_extra. <br><br><h2>  Temporizadores revocables </h2><br>  Dado que toda esta cocina con sobres fue concebida para resolver el problema de la recuperación garantizada de los mensajes del temporizador, veamos qué sucedió al final.  Usaremos el ejemplo de so_5_extra-1.2.0, que usa las herramientas del nuevo espacio de nombres so_5 :: extra :: revocable_timer: <br><br><div class="spoiler">  <b class="spoiler_title">Código de ejemplo con temporizadores revocables</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/revocable_timer/pub.hpp&gt; #include &lt;so_5/all.hpp&gt; namespace timer_ns = so_5::extra::revocable_timer; class example_t final : public so_5::agent_t { //  ,       //    . struct first_delayed final : public so_5::signal_t {}; struct second_delayed final : public so_5::signal_t {}; struct last_delayed final : public so_5::signal_t {}; struct periodic final : public so_5::signal_t {}; //    . timer_ns::timer_id_t m_first; timer_ns::timer_id_t m_second; timer_ns::timer_id_t m_last; timer_ns::timer_id_t m_periodic; public : example_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self() .event( &amp;example_t::on_first_delayed ) .event( &amp;example_t::on_second_delayed ) .event( &amp;example_t::on_last_delayed ) .event( &amp;example_t::on_periodic ); } void so_evt_start() override { using namespace std::chrono_literals; //      ... m_first = timer_ns::send_delayed&lt; first_delayed &gt;( *this, 100ms ); m_second = timer_ns::send_delayed&lt; second_delayed &gt;( *this, 200ms ); m_last = timer_ns::send_delayed&lt; last_delayed &gt;( *this, 300ms ); // ...    . m_periodic = timer_ns::send_periodic&lt; periodic &gt;( *this, 75ms, 75ms ); //    220ms.       //    first_delaye, second_delayed  //    periodic. std::cout &lt;&lt; "hang the agent..." &lt;&lt; std::flush; std::this_thread::sleep_for( 220ms ); std::cout &lt;&lt; "done" &lt;&lt; std::endl; } private : void on_first_delayed( mhood_t&lt;first_delayed&gt; ) { std::cout &lt;&lt; "first_delayed received" &lt;&lt; std::endl; //   second_delayed  periodic. //          ,  //       . m_second.revoke(); m_periodic.revoke(); } void on_second_delayed( mhood_t&lt;second_delayed&gt; ) { std::cout &lt;&lt; "second_delayed received" &lt;&lt; std::endl; } void on_last_delayed( mhood_t&lt;last_delayed&gt; ) { std::cout &lt;&lt; "last_delayed received" &lt;&lt; std::endl; so_deregister_agent_coop_normally(); } void on_periodic( mhood_t&lt;periodic&gt; ) { std::cout &lt;&lt; "periodic received" &lt;&lt; std::endl; } }; int main() { so_5::launch( [](so_5::environment_t &amp; env) { env.register_agent_as_coop( "example", env.make_agent&lt;example_t&gt;() ); } ); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Que tenemos aqui <br><br>  Tenemos un agente que primero inicia varios mensajes del temporizador y luego bloquea su hilo de trabajo por un tiempo.  Durante este tiempo, el temporizador logra poner en cola al agente varias solicitudes como resultado de los temporizadores activados: varias instancias periódicas, una primera demorada y una segunda demorada cada una. <br><br>  En consecuencia, cuando un agente desbloquea su hilo, debe recibir el primer periódico y el primer retraso.  Al procesar first_delayed, el agente cancela la entrega de periódico y second_delayed.  Por lo tanto, estas señales no deben llegar al agente, independientemente de si ya están en la cola del agente o no (y lo están). <br><br>  Nos fijamos en el resultado del ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">hang</span></span> the agent...done periodic received first_delayed received last_delayed received</code> </pre> <br>  Si lo es.  Obtuve el primer periódico y el primer retraso.  Entonces no hay periódicos ni segundos retrasados. <br><br>  Pero si en el ejemplo reemplazamos los "temporizadores" de so_5 :: extra :: revocable_timer con los temporizadores estándar de SObjectizer, el resultado será diferente: todas las instancias de señales periódicas y de segundo retardo que ya ingresaron en la cola del agente llegarán al agente. <br><br><h2>  Mensajes restringidos de tiempo de entrega </h2><br>  Otra cosa útil, a veces, que estará disponible en so_5_extra-1.2.0 es la entrega de mensajes con un límite de tiempo.  Por ejemplo, el agente request_handler envía un mensaje verificar_firma al agente crypto_master.  Al mismo tiempo, request_handler quiere que verificar_signature se entregue en 5 segundos.  Si esto no sucede, entonces no tendrá sentido el procesamiento de verity_signature, el agente request_handler ya detendrá su trabajo. <br><br>  Y el agente de crypto_master es un compañero al que le gusta convertirse en un "cuello de botella": a veces comienza a disminuir la velocidad.  En ese momento, los mensajes se acumulan en la cola, como la firma de verificación anterior, que puede esperar hasta que se alivie crypto_master. <br><br>  Supongamos que request_handler envió un mensaje de verificación de firma al agente crypto_master, pero luego crypto_master se empantanó y se atascó durante 10 segundos.  El agente request_handler ya se ha "caído", es decir  Ya envió a todos una denegación de servicio y completó su trabajo.  ¡Pero el mensaje generate_signature permanece en la cola crypto_master!  Entonces, cuando crypto_master "se despega", tomará este mensaje y procesará este mensaje.  Aunque esto ya no es necesario. <br><br>  Usando el nuevo sobre so_5 :: extra :: envolped_msg :: time_limited_delivery_t, podemos resolver este problema: el agente request_handler enviará verifique_signature time_limited_delivery_t incluido en el sobre con un límite de tiempo de entrega: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;verify_signature&gt;(...) .envelope&lt;so_5::extra::enveloped_msg::<span class="hljs-keyword"><span class="hljs-keyword">time_limited_delivery_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>s) .send_to(crypto_master_mbox);</code> </pre> <br>  Ahora, si crypto_master "se pega" y no logra verificar_firma en 5 segundos, el sobre simplemente no enviará este mensaje para su procesamiento.  Y crypto_master no hará el trabajo que nadie más necesita. <br><br><h2>  Informes de entrega de destinatarios </h2><br>  Y finalmente, un ejemplo de algo curioso que no se implementa regularmente en SObjectizer o so_5_extra, pero que se puede hacer de forma independiente. <br><br>  A veces desea recibir del SObjectizer algo como un mensaje de "informe de entrega" al destinatario.  Después de todo, es una cosa cuando el mensaje llegó al destinatario, pero el destinatario por alguna razón no respondió.  Otra cosa es cuando el mensaje no llegó al destinatario en absoluto.  Por ejemplo, fue bloqueado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un mecanismo de protección de sobrecarga del agente</a> .  En el primer caso, se puede omitir un mensaje al que no esperamos una respuesta.  Pero en el segundo caso, puede tener sentido volver a enviar el mensaje después de un tiempo. <br><br>  Ahora consideraremos cómo se puede implementar el mecanismo más simple de "informes de entrega" utilizando sobres. <br><br>  Entonces, primero hacemos los pasos preparatorios necesarios: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/enveloped_msg/just_envelope.hpp&gt; #include &lt;so_5_extra/enveloped_msg/send_functions.hpp&gt; #include &lt;so_5/all.hpp&gt; using namespace std::chrono_literals; namespace envelope_ns = so_5::extra::enveloped_msg; using request_id_t = int;</span></span></span></span></code> </pre><br>  Ahora podemos definir los mensajes que se utilizarán en el ejemplo.  El primer mensaje es una solicitud para realizar algunas acciones que necesitamos.  Y el segundo mensaje es una confirmación de que el primer mensaje llegó al destinatario: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_id_t</span></span> m_id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delivery_receipt_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   request_t::m_id   request_t. request_id_t m_id; };</span></span></code> </pre> <br>  A continuación, podemos definir un agente procesador_t que procesará mensajes de tipo request_t.  Pero el procesamiento será con una imitación de "pegado".  Es decir  procesa request_t, después de lo cual cambia su estado de st_normal a st_busy.  En el estado st_busy, no hace nada e ignora todos los mensajes que le llegan. <br><br>  Esto significa que si el agente procesador_t envía tres mensajes consecutivos request_t, procesará el primero y los otros dos serán arrojados, porque  Al procesar el primer mensaje, el agente irá a st_busy e ignorará lo que le llegará mientras está en st_busy. <br><br>  En st_busy, el agente procesador_t pasará 2 segundos, después de lo cual volverá nuevamente a st_normal y estará listo para procesar nuevos mensajes. <br><br>  Así se ve el agente procesador_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   .     //   . state_t st_normal{this, "normal"}; //  " ".   . state_t st_busy{this, "busy"}; public: processor_t(context_t ctx) : so_5::agent_t{std::move(ctx)} { this &gt;&gt;= st_normal; st_normal.event(&amp;processor_t::on_request); //     ,    . //  2   ,    st_normal. st_busy.time_limit(2s, st_normal); } private: void on_request(mhood_t&lt;request_t&gt; cmd) { std::cout &lt;&lt; "processor: on_request(" &lt;&lt; cmd-&gt;m_id &lt;&lt; ", " &lt;&lt; cmd-&gt;m_data &lt;&lt; ")" &lt;&lt; std::endl; this &gt;&gt;= st_busy; } };</span></span></code> </pre> <br>  Ahora podemos definir el agente request_generator_t, que tiene un montón de solicitudes que deben entregarse al procesador_t.  El agente request_generator_t envía el paquete completo cada 3 segundos, y luego espera la confirmación de entrega en forma de delivery_receipt_t. <br><br>  Cuando llega delivery_recept_t, el agente request_generator_t arroja la solicitud entregada fuera del paquete.  Si el paquete está completamente vacío, se completa el ejemplo.  Si queda algo más, el paquete restante se enviará nuevamente cuando llegue la próxima vez para reenviar. <br><br>  Así que aquí está el código de agente request_generator_t.  Es bastante voluminoso, pero primitivo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solo puede prestar atención a los aspectos internos del método send_requests (), en el que se envían mensajes request_t, encerrados en un sobre especial. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requests_generator_t código de agente</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests_generator_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_processor; //  ,       . std::map&lt;request_id_t, std::string&gt; m_requests; struct resend_requests final : public so_5::signal_t {}; public: requests_generator_t(context_t ctx, so_5::mbox_t processor) : so_5::agent_t{std::move(ctx)} , m_processor{std::move(processor)} { so_subscribe_self() .event(&amp;requests_generator_t::on_delivery_receipt) .event(&amp;requests_generator_t::on_resend); } void so_evt_start() override { //    . m_requests.emplace(0, "First"); m_requests.emplace(1, "Second"); m_requests.emplace(2, "Third"); m_requests.emplace(3, "Four"); //  . send_requests(); } private: void on_delivery_receipt(mhood_t&lt;delivery_receipt_t&gt; cmd) { std::cout &lt;&lt; "request delivered: " &lt;&lt; cmd-&gt;m_id &lt;&lt; std::endl; m_requests.erase(cmd-&gt;m_id); if(m_requests.empty()) //    .  . so_deregister_agent_coop_normally(); } void on_resend(mhood_t&lt;resend_requests&gt;) { std::cout &lt;&lt; "time to resend requests, pending requests: " &lt;&lt; m_requests.size() &lt;&lt; std::endl; send_requests(); } void send_requests() { for(const auto &amp; item : m_requests) { std::cout &lt;&lt; "sending request: (" &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; ")" &lt;&lt; std::endl; envelope_ns::make&lt;request_t&gt;(item.first, item.second) .envelope&lt;custom_envelope_t&gt;(so_direct_mbox(), item.first) .send_to(m_processor); } //       3 . so_5::send_delayed&lt;resend_requests&gt;(*this, 3s); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos mensajes y agentes que deben usar estos mensajes para comunicarse. </font><font style="vertical-align: inherit;">Solo quedaba una pequeña cosa: hacer que los mensajes delivery_receipt_t lleguen de alguna manera al entregar request_t al procesador_t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se hace usando este sobre:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> custom_envelope_t final : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> envelope_ns::just_envelope_t { //     . const so_5::mbox_t m_to; // ID  . const request_id_t m_id; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: custom_envelope_t(so_5::message_ref_t payload, so_5::mbox_t <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, request_id_t id) : envelope_ns::just_envelope_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(payload)} , m_to{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>)} , m_id{id} {} <span class="hljs-type"><span class="hljs-type">void</span></span> handler_found_hook(handler_invoker_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>) noexcept override { //    ,     . //     . so_5::send&lt;delivery_receipt_t&gt;(m_to, m_id); //      . envelope_ns::just_envelope_t::handler_found_hook(<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, no hay nada complicado. </font><font style="vertical-align: inherit;">Heredamos de so_5 :: extra :: envped_msg :: just_envelope_t. </font><font style="vertical-align: inherit;">Este es un tipo de sobre auxiliar que almacena el mensaje encerrado en él y proporciona la implementación básica de los ganchos </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handler_found_hook () y transformación_hook (). </font><font style="vertical-align: inherit;">Por lo tanto, solo podemos guardar los atributos que necesitamos dentro de custom_envelope_t y enviar delivery_receipt_t dentro del gancho handler_found_hook ().</font></font><br><br>  Eso, de hecho, es todo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si ejecutamos este ejemplo, obtenemos lo siguiente: </font></font><br><br><pre> <code class="hljs vbscript">sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, First) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">0</span></span>, First) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">3</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">2</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">1</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, debo decir que en la práctica, un simple custom_envelope_t para generar informes de entrega no es adecuado. </font><font style="vertical-align: inherit;">Pero si alguien está interesado en este tema, entonces puede discutirse en los comentarios y no aumentar el volumen del artículo.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Qué más se podría hacer con los sobres? </font></font></h1><br>  Gran pregunta!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lo que nosotros mismos no tenemos una respuesta integral. </font><font style="vertical-align: inherit;">Probablemente, las posibilidades están limitadas solo por la imaginación de los usuarios. </font><font style="vertical-align: inherit;">Bueno, si para la realización de fantasías en SObjectizer falta algo, entonces esto se nos puede decir. </font><font style="vertical-align: inherit;">Siempre escuchamos </font><font style="vertical-align: inherit;">Y, lo que es más importante, a veces incluso lo hacemos :)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integración de agentes con mchain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hablando un poco más en serio, esa es otra característica que me gustaría tener de vez en cuando y que incluso se planeó para so_5_extra-1.2.0. Pero, lo más probable, no se incluirá en la versión 1.2.0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se trata de simplificar la integración de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mchains</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y agentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El hecho es que inicialmente se agregaron mchains a SObjectizer para simplificar la comunicación de los agentes con otras partes de la aplicación que están escritas sin agentes. Por ejemplo, existe el hilo principal de la aplicación, en el cual el usuario interactúa usando la GUI. Y hay varios agentes-trabajadores que hacen el trabajo "duro" de fondo. Enviar un mensaje a un agente desde el hilo principal no es un problema: solo llame al envío regular. Pero, ¿cómo transferir la información de regreso?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para esto, se agregaron mchain-s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero con el tiempo, resultó que las cadenas pueden jugar un papel mucho más importante. Es posible, en principio, hacer aplicaciones multiproceso en SObjectizer sin ningún agente, solo en mchain-ahs (más detalles </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Y puede usar mchain-s como un medio para equilibrar la carga de los agentes. Como mecanismo para resolver problemas productor-consumidor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema con el productor-consumidor es que si el productor genera mensajes más rápido de lo que el consumidor puede manejarlos, entonces estamos en problemas. Las colas de mensajes crecerán, el rendimiento puede degradarse con el tiempo o la aplicación se bloqueará por completo debido al agotamiento de la memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La solución habitual que propusimos usar en este caso es usar</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un par de agentes coleccionistas e intérpretes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . También puede usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">límites de mensajes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ya sea como el mecanismo de protección principal o como una adición al recopilador-intérprete). Pero escribir coleccionista-intérprete requiere trabajo adicional del programador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero mchains podría usarse para estos fines con el mínimo esfuerzo del desarrollador. Entonces, el productor pondría el siguiente mensaje en mchain, y el consumidor tomaría mensajes de esta mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero el problema es que cuando el consumidor es un agente, no es muy conveniente que un agente trabaje con mchain a través de las funciones de recepción () y selección () disponibles. Y se podría tratar de eliminar este inconveniente con la ayuda de alguna herramienta para integrar agentes y mchain-s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al desarrollar dicha herramienta, será necesario resolver varios problemas. Por ejemplo, cuando llega un mensaje en mchain, ¿en qué punto debe extraerse de mchain? Si el consumidor es gratuito y no procesa nada, puede recoger el mensaje de mchain de inmediato y entregárselo al agente del consumidor. Si ya se ha enviado un mensaje al consumidor desde mchain, aún no ha logrado procesar este mensaje, pero un nuevo mensaje ya ha llegado a mchain ... ¿Qué se debe hacer en este caso? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se especula que los sobres pueden ayudar en este caso. Entonces, cuando tomamos el primer mensaje de mchain y lo enviamos al consumidor, envolvemos este mensaje en un sobre especial. Cuando el sobre ve que el mensaje ha sido entregado y procesado, solicita el siguiente mensaje de mchain (si hay uno).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, no todo es tan simple aquí. </font><font style="vertical-align: inherit;">Pero hasta ahora parece bastante solucionable. </font><font style="vertical-align: inherit;">Y, espero, un mecanismo similar aparecerá en una de las próximas versiones de so_5_extra.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¿Vamos a abrir la caja de Pandora? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cabe señalar que con nosotros las capacidades adicionales en sí mismas causan sentimientos duales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por un lado, los sobres ya han permitido / permiten hacer cosas que se mencionaron anteriormente (pero que solo soñaron con algo). </font><font style="vertical-align: inherit;">Por ejemplo, esta es una cancelación garantizada de temporizadores y una restricción en el tiempo de entrega, informes de entrega, la capacidad de recuperar un mensaje enviado previamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por otro lado, no está claro a qué conducirá esto posteriormente. </font><font style="vertical-align: inherit;">Después de todo, puede crear un problema con cualquier oportunidad si comienza a usar esta oportunidad donde necesita y donde no. </font><font style="vertical-align: inherit;">¿Entonces tal vez abrimos la caja de Pandora y todavía no imaginamos lo que nos espera? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo queda ser paciente y ver a dónde nos llevará todo esto.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acerca de los planes de desarrollo inmediato de SObjectizer en lugar de concluir </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de una conclusión, quiero hablar sobre cómo vemos el futuro muy cercano (y no solo) de SObjectizer. Si alguien no está contento con algo en nuestros planes, puede hablar e influir en cómo se desarrollará SObjectizer-5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las primeras versiones beta de SObjectizer-5.5.23 y so_5_extra-1.2.0 ya están reparadas y disponibles para descargar y experimentar. Todavía habrá mucho trabajo por hacer en el área de documentación y casos de uso. Por lo tanto, el lanzamiento oficial está previsto para la primera década de noviembre. Si funciona antes, lo haremos antes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El lanzamiento de SObjectizer-5.5.23 parece significar que la evolución de la rama 5.5 está llegando a su fin. El </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primer lanzamiento de este hilo tuvo lugar hace cuatro años, en octubre de 2014.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Desde entonces, SObjectizer-5 ha evolucionado dentro de la rama 5.5 sin ningún cambio importante entre las versiones. No fue facil. Especialmente considerando el hecho de que todo este tiempo tuvimos que mirar hacia atrás a los compiladores que tenían un soporte lejos de ser ideal para C ++ 11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora no vemos ninguna razón para mirar hacia atrás en la compatibilidad dentro de la rama 5.5, y especialmente en los compiladores C ++ más antiguos. Lo que podría estar justificado en 2014, cuando C ++ 14 se estaba preparando para ser adoptado oficialmente, y C ++ 17 aún no estaba en el horizonte, ahora se ve completamente diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Además, en SObjectizer-5.5 ya se ha acumulado una buena cantidad de rake y copias de seguridad, que aparecieron debido a esta misma compatibilidad y que complican el desarrollo posterior de SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, en los próximos meses vamos a actuar de acuerdo con el siguiente escenario: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Desarrollo de la próxima versión de so_5_extra, en la que quiero agregar herramientas para simplificar la redacción de pruebas para agentes. Aún no está claro si será so_5_extra-1.3.0 (es decir, con cambios de ruptura en relación con 1.2.0) o si será so_5_extra-1.2.1 (es decir, sin cambios de ruptura). Veamos cómo va. Solo está claro que la próxima versión de so_5_extra se basará en SObjectizer-5.5.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1a. Si para la próxima versión de so_5_extra necesita hacer algo adicional en SObjectizer-5.5, se lanzará la próxima versión 5.5.24. Si para so_5_extra no será necesario realizar mejoras en el núcleo de SObjectizer, la versión 5.5.23 será la última versión significativa en el marco de la rama 5.5. Saldrán lanzamientos menores de corrección de errores. Pero el desarrollo de la rama 5.5 se detiene en la versión 5.5.23 o 5.5.24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Luego se lanzará una versión de SObjectizer-5.6.0, que abrirá una nueva rama. En la rama 5.6, limpiaremos el código SObjectizer de todas las muletas y copias de seguridad acumuladas, así como de la basura vieja que durante mucho tiempo se ha marcado como obsoleta. Es probable que algunas cosas se sometan a una refactorización (por ejemplo, abstract_message_box_t se puede cambiar), pero difícilmente cardinal. Los principios básicos de trabajo y las características de SObjectizer-5.5 en SObjectizer-5.6 permanecerán en la misma forma. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.6 ya requerirá C ++ 14 (al menos en el nivel GCC-5.5). Los compiladores de Visual C ++ debajo de VC ++ 15 (que es de Visual Studio 2017) no serán compatibles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consideramos la rama 5.6 como una rama estable de SObjectizer, que será relevante hasta que aparezca la primera versión de SObjectizer-5.7.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me gustaría lanzar la versión 5.6.0 a principios de 2019, tentativamente en febrero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Después de estabilizar la rama 5.6, nos gustaría comenzar a trabajar en la rama 5.7, en la que podríamos revisar algunos principios básicos del trabajo de SObjectizer. Por ejemplo, abandone por completo los despachadores públicos, dejando solo los privados. Rehacer el mecanismo de las cooperativas y sus relaciones entre padres e hijos, eliminando así el cuello de botella durante el registro / desregistro de las cooperativas. Eliminar la división por mensaje / señal. Permita que solo send / send_delayed / send_periodic envíe mensajes, y oculte los métodos de delivery_message y schedule_timer "debajo del capó". Modifique el mecanismo para enviar mensajes de modo que elimine completamente dynamic_casts de este proceso o reduzca al mínimo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, hay dónde dar la vuelta. Al mismo tiempo, SObjectizer-5.7 ya requerirá C ++ 17, independientemente de C ++ 14. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si miras las cosas sin gafas de color rosa, es bueno que la versión 5.7.0 tenga lugar a fines del otoño de 2019. La principal versión de trabajo de SObjectizer para 2019 será la rama 5.6. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Paralelo a todo esto, se desarrollará so_5_extra. Probablemente, la versión so_5_extra-2 se lanzará junto con SObjectizer-5.6, que incorporará una nueva funcionalidad en el transcurso de 2019, pero basada en SObjectizer-5.6.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, nosotros mismos vemos una evolución progresiva de SObjectizer-5 con una revisión gradual de algunos de los principios básicos de SObjectizer-5. Al mismo tiempo, intentaremos hacer esto de la forma más fluida posible para que sea posible cambiar de una versión a otra con un mínimo de dolor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, si alguien quisiera cambios más dramáticos y significativos de SObjectizer, entonces </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenemos algunas ideas al respecto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En pocas palabras: puede rehacer SObjectizer como desee, hasta implementar SObjectizer-6 para otro lenguaje de programación. Pero no lo haremos por nuestra cuenta, ya que esto sucede con la evolución de SObjectizer-5.</font></font><br><br>  Eso es probablemente todo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los comentarios </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al artículo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resultaron ser una discusión buena y constructiva. </font><font style="vertical-align: inherit;">Sería útil para nosotros si ocurriera una discusión similar esta vez. </font><font style="vertical-align: inherit;">Como siempre, estamos listos para responder cualquier pregunta, pero a las sensatas, y con gusto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y para los lectores más pacientes que han llegado a estas líneas, muchas gracias por el tiempo dedicado a leer el artículo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426983/">https://habr.com/ru/post/es426983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426973/index.html">Sandwiches corporativos</a></li>
<li><a href="../es426975/index.html">Joker 2018: lo imposible es posible</a></li>
<li><a href="../es426977/index.html">LibreOffice: la pesadilla del contador</a></li>
<li><a href="../es426979/index.html">Cómo aprender inglés gratis: 3 herramientas comunes e instrucciones detalladas para cada</a></li>
<li><a href="../es426981/index.html">10 trucos para tablero avanzado en Splunk. Parte 1</a></li>
<li><a href="../es426985/index.html">Kubebox y otros cascos de consola para Kubernetes</a></li>
<li><a href="../es426987/index.html">Aprende OpenGL. Lección 6.3 - Iluminación basada en imágenes. Irradiación difusa</a></li>
<li><a href="../es426991/index.html">Startup Digest: 10 próximos eventos de TI en Moscú</a></li>
<li><a href="../es426993/index.html">¿Necesito aprender C para entender cómo funciona una computadora?</a></li>
<li><a href="../es426995/index.html">El reciclaje perjudica tanto a los productos como a los empleados.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>