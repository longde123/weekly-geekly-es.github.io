<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüåæ üë®üèæ‚ÄçüöÄ üòá Nuevo en SObjectizer-5.5.23: ¬øCumplimiento de los deseos o la caja de Pandora? üë©üèø‚Äçüè´ üò∏ üìâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo es una continuaci√≥n de un art√≠culo de reflexi√≥n publicado hace un mes, " ¬øEs f√°cil agregar nuevas funciones al marco anterior? La agon√≠a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nuevo en SObjectizer-5.5.23: ¬øCumplimiento de los deseos o la caja de Pandora?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426983/"><img src="https://habrastorage.org/webt/kt/xf/7o/ktxf7oduhnd0zuhd_tpaju7p_em.jpeg"><br><br>  Este art√≠culo es una continuaci√≥n de un art√≠culo de reflexi√≥n publicado hace un mes, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øEs f√°cil agregar nuevas funciones al marco anterior? La agon√≠a de elegir en el ejemplo del desarrollo de SObjectizer</a> ".  Ese art√≠culo describi√≥ la tarea que quer√≠amos resolver en la pr√≥xima versi√≥n de SObjectizer, examin√≥ dos enfoques para su soluci√≥n y enumer√≥ las ventajas y desventajas de cada uno de los enfoques. <br><br>  Con el paso del tiempo, se implement√≥ uno de los enfoques y nuevas versiones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SObjectizer</a> , as√≠ como el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> adjunto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">so_5_extra</a> , ya llamado " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respirar profundamente</a> ".  Literalmente puedes tomar y probar. <br><br>  Hoy hablaremos sobre lo que se hizo, por qu√© se hizo, a qu√© condujo.  Si alguien est√° interesado en seguir c√≥mo se est√° desarrollando uno de los pocos marcos de actores en vivo, multiplataforma y abiertos para C ++, puede utilizar cat. <br><a name="habracut"></a><br><h1>  ¬øC√≥mo empez√≥ todo? </h1><br>  Todo comenz√≥ con un intento de resolver el problema de la cancelaci√≥n garantizada de temporizadores.  La esencia del problema es que cuando se env√≠a un mensaje retrasado o peri√≥dico, el programador puede cancelar la entrega del mensaje.  Por ejemplo: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer_id = so_5::send_periodic&lt;my_message&gt;(my_agent, <span class="hljs-number"><span class="hljs-number">10</span></span>s, <span class="hljs-number"><span class="hljs-number">10</span></span>s, ...); ... <span class="hljs-comment"><span class="hljs-comment">// - . // ,    my_message    . timer_id.release(); //      my_message.</span></span></code> </pre> <br>  Despu√©s de llamar a <i>timer_id.release (), el</i> temporizador ya no enviar√° nuevas instancias del mensaje my_message.  Pero esas copias que ya se han enviado y est√°n en la cola de los destinatarios no ir√°n a ninguna parte.  Con el tiempo, se extraer√°n de estas mismas colas y se transferir√°n a los agentes receptores para su procesamiento. <br><br>  Este problema es una consecuencia de los principios b√°sicos de funcionamiento de SObjectizer-5 y no tiene una soluci√≥n simple debido a que SObjectizer no puede extraer mensajes de las colas.  No puede porque las colas en SObjectizer pertenecen a despachadores, los despachadores son diferentes, sus colas tambi√©n est√°n organizadas de manera diferente.  Incluyendo que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay despachadores que no son parte del SObjectizer,</a> y SObjectizer, en principio, no puede saber c√≥mo funcionan estos despachadores. <br><br>  En general, existe tal caracter√≠stica en los temporizadores nativos de SObjectizer.  No es que estropee demasiado a los desarrolladores.  Pero se debe tener especial cuidado.  Especialmente para principiantes que reci√©n se est√°n familiarizando con el marco. <br><br>  Y luego, finalmente, las manos fueron al punto de proponer una soluci√≥n a este problema. <br><br><h1>  ¬øQu√© camino de soluci√≥n fue elegido? </h1><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> , se consideraron dos posibles opciones.  La primera opci√≥n no requer√≠a modificaciones al mecanismo de entrega de mensajes en SObjectizer, pero requer√≠a que el programador cambiara expl√≠citamente el tipo de mensaje enviado / recibido. <br><br>  La segunda opci√≥n requer√≠a la modificaci√≥n del mecanismo de entrega de mensajes SObjectizer.  Se eligi√≥ este camino, ya que permiti√≥ ocultar al destinatario del mensaje el hecho de que el mensaje se envi√≥ de alguna manera espec√≠fica. <br><br><h2>  ¬øQu√© ha cambiado en SObjectizer? </h2><br><h3>  Nuevo concepto: sobre con mensaje dentro </h3><br>  El primer componente de la soluci√≥n implementada es la adici√≥n de un concepto como un sobre a SObjectizer.  Un sobre es un mensaje especial, dentro del cual se encuentra el mensaje actual (carga √∫til).  SObjectizer entrega el sobre con el mensaje al destinatario casi de la forma habitual.  La diferencia fundamental en el procesamiento de sobres se detecta solo en la √∫ltima etapa de entrega: <br><br><ul><li>  al entregar un mensaje normal, el agente receptor simplemente busca un controlador para este tipo de mensaje y, si se encuentra dicho controlador, se llama al controlador encontrado y el mensaje entregado se devuelve como un par√°metro; </li><li>  y al entregar el sobre con el mensaje despu√©s de encontrar el controlador, primero se hace un intento para sacar el mensaje del sobre.  Y solo si el sobre dio el mensaje almacenado en √©l, solo entonces se llama al controlador. </li></ul><br>  Aqu√≠ hay dos puntos clave que tienen un gran impacto en por qu√© y c√≥mo se pueden usar los sobres de mensajes. <br><br>  El primer punto clave es que se solicita un mensaje de un sobre solo cuando se encuentra un controlador de mensaje en el destinatario.  Es decir  solo cuando el mensaje realmente se haya entregado al destinatario y el destinatario est√© aqu√≠ y ahora procesar√° este mensaje. <br><br>  El segundo punto clave aqu√≠ es que el sobre puede no revelar el mensaje que contiene.  Es decir, por ejemplo, un sobre puede verificar la hora actual y decidir que se han perdido todas las fechas de entrega y, por lo tanto, el mensaje ha dejado de ser relevante y no se puede procesar.  Por lo tanto, el sobre no dar√° el mensaje.  En consecuencia, SObjectizer simplemente ignorar√° este sobre y no tomar√° ninguna acci√≥n adicional. <br><br><h4>  ¬øC√≥mo es un sobre? </h4><br>  Un sobre es una implementaci√≥n de la interfaz envolvente_t, que se define de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SO_5_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envelope_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-comment"><span class="hljs-comment">// -. //   ,       //    . virtual void handler_found_hook( handler_invoker_t &amp; invoker ) noexcept = 0; //   ,      //     . virtual void transformation_hook( handler_invoker_t &amp; invoker ) noexcept = 0; private : kind_t so5_message_kind() const noexcept override { return kind_t::enveloped_msg; } };</span></span></code> </pre> <br>  Es decir  Un sobre es esencialmente el mismo mensaje que todos los dem√°s.  Pero con un atributo especial, que es devuelto por el m√©todo so5_message_kind (). <br><br>  El programador puede desarrollar sus sobres heredando de envolvente_t (o, m√°s convenientemente, de <a href="">so_5 :: extra :: envolped_msg :: just_envelope_t</a> ) y anulando los m√©todos de enlace handler_found_hook () y transformaci√≥n_hook (). <br><br>  Dentro de los m√©todos de enlace, el desarrollador del sobre decide si quiere dar el mensaje dentro del sobre para su procesamiento / transformaci√≥n o no.  Si lo desea, entonces el desarrollador debe llamar al m√©todo invoke () y al objeto invocador.  Si no quiere, no llama, en este caso se ignorar√° el sobre y su contenido. <br><br><h4>  ¬øC√≥mo resuelven los sobres el problema de cancelar los temporizadores? </h4><br>  La soluci√≥n, que ahora se implementa en so_5_extra en forma del espacio de nombres so_5 :: extra :: revocable_timer, es muy simple: el env√≠o especial de un mensaje pendiente o peri√≥dico crea un sobre especial, dentro del cual se ubica no solo el mensaje en s√≠, sino tambi√©n el indicador at√≥mico revocado.  Si se borra esta bandera, el mensaje se considera relevante.  Si se establece, el mensaje se considera retirado. <br><br>  Cuando se llama al m√©todo de enlace en el sobre, el sobre verifica el valor de la bandera revocada.  Si se establece la bandera, el sobre no muestra un mensaje.  Por lo tanto, el mensaje no se procesa incluso si el temporizador ya ha logrado poner el mensaje en la cola del receptor. <br><br><h3>  Extensi√≥n de interfaz abstract_message_box_t </h3><br>  Agregar la interfaz envolvente_t es solo una parte de la implementaci√≥n de sobres en SObjectizer.  La segunda parte es tener en cuenta el hecho de la existencia de sobres en el mecanismo de entrega de mensajes dentro del SObjectizer. <br><br>  Aqu√≠, desafortunadamente, no podr√≠a prescindir sin hacer que los cambios sean visibles para el usuario.  En particular, en la clase abstract_message_box_t, que define la interfaz de todos los buzones en SObjectizer, fue necesario agregar otro m√©todo virtual: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_deliver_enveloped_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::type_index &amp; msg_type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ref_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> overlimit_reaction_deep )</span></span></span></span>;</code> </pre> <br>  Este m√©todo es responsable de entregar un sobre de mensaje con un mensaje de tipo msg_type al receptor.  Tal entrega puede diferir en los detalles de implementaci√≥n dependiendo de qu√© tipo de mbox sea. <br><br>  Al agregar do_deliver_enveloped_msg () a abstract_message_box_t, ten√≠amos una opci√≥n: convertirlo en un m√©todo virtual puro u ofrecer alg√∫n tipo de implementaci√≥n predeterminada. <br><br>  Si hici√©ramos do_deliver_enveloped_msg () un m√©todo virtual puro, entonces romper√≠amos la compatibilidad entre las versiones de SObjectizer en la rama 5.5.  Despu√©s de todo, los usuarios que escribieron sus propias implementaciones de mbox tendr√≠an que modificar sus propios mboxes al cambiar a SObjectizer-5.5.23, de lo contrario no podr√≠an compilar con la nueva versi√≥n de SObjectizer. <br><br>  No quer√≠amos esto, por lo que no hicimos do_deliver_enveloped_msg () un m√©todo virtual puro en v.5.5.23.  Tiene una implementaci√≥n predeterminada que solo arroja una excepci√≥n.  Por lo tanto, los usuarios personalizados mbox-s podr√°n continuar trabajando normalmente con mensajes regulares, pero se negar√°n autom√°ticamente a aceptar sobres.  Encontramos este comportamiento m√°s aceptable.  Adem√°s, en la etapa inicial, es poco probable que los sobres con mensajes sean ampliamente utilizados, y es poco probable que en la "naturaleza" se encuentren a menudo implementaciones personalizadas de SObjectizer mboxes;) <br><br>  Adem√°s, hay muchas posibilidades de que en las versiones principales posteriores de SObjectizer, donde no veremos la compatibilidad con la rama 5.5, la interfaz abstract_message_box_t sufra cambios importantes.  Pero ya nos estamos adelantando ... <br><br><h2>  C√≥mo enviar sobres con mensajes </h2><br>  SObjectizer-5.5.23 en s√≠ mismo no proporciona un medio simple para enviar sobres.  Se supone que se est√° desarrollando un tipo espec√≠fico de sobre y herramientas apropiadas para una tarea espec√≠fica para enviar convenientemente sobres de un tipo espec√≠fico.  Un ejemplo de esto se puede ver en <a href="">so_5 :: extra :: revocable_timer</a> , donde necesita no solo enviar el sobre, sino tambi√©n darle al usuario un timer_id especial. <br><br>  Para situaciones m√°s simples, puede usar las herramientas de <a href="">so_5 :: extra :: wrapped_msg</a> .  Por ejemplo, as√≠ es como se env√≠a un mensaje con una restricci√≥n dada en el momento de su entrega: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// make     . so_5::extra::enveloped_msg::make&lt;my_message&gt;(... /*    */) // envelope         . //  5s        . .envelope&lt;so_5::extra::enveloped_msg::time_limited_delivery_t&gt;(5s) //        . .send_to(destination);</span></span></code> </pre> <br><h2>  Para que todo sea divertido: sobres en sobres </h2><br>  Los sobres est√°n dise√±ados para llevar algunos mensajes dentro de s√≠ mismos.  Pero cuales? <br><br>  Cualquiera. <br><br>  Y esto nos lleva a una pregunta interesante: ¬øes posible poner un sobre dentro de otro sobre? <br><br>  Si puedes.  Tanto como quieras  La profundidad de anidamiento est√° limitada solo por el sentido com√∫n del desarrollador y la profundidad de la pila para la llamada recursiva handler_found_hook / conversion_hook. <br><br>  Al mismo tiempo, SObjectizer se dirige a los desarrolladores de sus propios sobres: el sobre no debe pensar en lo que contiene: un mensaje espec√≠fico u otro sobre.  Cuando se llama al m√©todo de enlace en el sobre y el sobre decide que puede dar su contenido, el sobre simplemente llama a invoke () en handler_invoker_t y pasa un enlace a su contenido en invoke ().  Y ya invocar () dentro descubrir√° a qu√© se enfrenta.  Y si este es otro sobre, invoke () llamar√° al m√©todo de enlace requerido en este sobre. <br><br>  Usando el kit de herramientas que se muestra arriba de so_5 :: extra :: wrapped_msg, el usuario puede hacer varios sobres anidados como este: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;my_message&gt;(...) <span class="hljs-comment"><span class="hljs-comment">// ,        my_message. .envelope&lt;inner_envelope_type&gt;(...) // ,      inner_envelope_type. .envelope&lt;outer_envelope_type&gt;(...) .send_to(destination);</span></span></code> </pre> <br><h1>  Algunos ejemplos de uso de sobres </h1><br>  Ahora, despu√©s de haber recorrido los aspectos internos de SObjectizer-5.5.23, es hora de pasar a la parte de aplicaci√≥n m√°s √∫til para los usuarios.  A continuaci√≥n hay algunos ejemplos que se basan en lo que ya est√° implementado en so_5_extra, o usan las herramientas de so_5_extra. <br><br><h2>  Temporizadores revocables </h2><br>  Dado que toda esta cocina con sobres fue concebida para resolver el problema de la recuperaci√≥n garantizada de los mensajes del temporizador, veamos qu√© sucedi√≥ al final.  Usaremos el ejemplo de so_5_extra-1.2.0, que usa las herramientas del nuevo espacio de nombres so_5 :: extra :: revocable_timer: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de ejemplo con temporizadores revocables</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/revocable_timer/pub.hpp&gt; #include &lt;so_5/all.hpp&gt; namespace timer_ns = so_5::extra::revocable_timer; class example_t final : public so_5::agent_t { //  ,       //    . struct first_delayed final : public so_5::signal_t {}; struct second_delayed final : public so_5::signal_t {}; struct last_delayed final : public so_5::signal_t {}; struct periodic final : public so_5::signal_t {}; //    . timer_ns::timer_id_t m_first; timer_ns::timer_id_t m_second; timer_ns::timer_id_t m_last; timer_ns::timer_id_t m_periodic; public : example_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self() .event( &amp;example_t::on_first_delayed ) .event( &amp;example_t::on_second_delayed ) .event( &amp;example_t::on_last_delayed ) .event( &amp;example_t::on_periodic ); } void so_evt_start() override { using namespace std::chrono_literals; //      ... m_first = timer_ns::send_delayed&lt; first_delayed &gt;( *this, 100ms ); m_second = timer_ns::send_delayed&lt; second_delayed &gt;( *this, 200ms ); m_last = timer_ns::send_delayed&lt; last_delayed &gt;( *this, 300ms ); // ...    . m_periodic = timer_ns::send_periodic&lt; periodic &gt;( *this, 75ms, 75ms ); //    220ms.       //    first_delaye, second_delayed  //    periodic. std::cout &lt;&lt; "hang the agent..." &lt;&lt; std::flush; std::this_thread::sleep_for( 220ms ); std::cout &lt;&lt; "done" &lt;&lt; std::endl; } private : void on_first_delayed( mhood_t&lt;first_delayed&gt; ) { std::cout &lt;&lt; "first_delayed received" &lt;&lt; std::endl; //   second_delayed  periodic. //          ,  //       . m_second.revoke(); m_periodic.revoke(); } void on_second_delayed( mhood_t&lt;second_delayed&gt; ) { std::cout &lt;&lt; "second_delayed received" &lt;&lt; std::endl; } void on_last_delayed( mhood_t&lt;last_delayed&gt; ) { std::cout &lt;&lt; "last_delayed received" &lt;&lt; std::endl; so_deregister_agent_coop_normally(); } void on_periodic( mhood_t&lt;periodic&gt; ) { std::cout &lt;&lt; "periodic received" &lt;&lt; std::endl; } }; int main() { so_5::launch( [](so_5::environment_t &amp; env) { env.register_agent_as_coop( "example", env.make_agent&lt;example_t&gt;() ); } ); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Que tenemos aqui <br><br>  Tenemos un agente que primero inicia varios mensajes del temporizador y luego bloquea su hilo de trabajo por un tiempo.  Durante este tiempo, el temporizador logra poner en cola al agente varias solicitudes como resultado de los temporizadores activados: varias instancias peri√≥dicas, una primera demorada y una segunda demorada cada una. <br><br>  En consecuencia, cuando un agente desbloquea su hilo, debe recibir el primer peri√≥dico y el primer retraso.  Al procesar first_delayed, el agente cancela la entrega de peri√≥dico y second_delayed.  Por lo tanto, estas se√±ales no deben llegar al agente, independientemente de si ya est√°n en la cola del agente o no (y lo est√°n). <br><br>  Nos fijamos en el resultado del ejemplo: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">hang</span></span> the agent...done periodic received first_delayed received last_delayed received</code> </pre> <br>  Si lo es.  Obtuve el primer peri√≥dico y el primer retraso.  Entonces no hay peri√≥dicos ni segundos retrasados. <br><br>  Pero si en el ejemplo reemplazamos los "temporizadores" de so_5 :: extra :: revocable_timer con los temporizadores est√°ndar de SObjectizer, el resultado ser√° diferente: todas las instancias de se√±ales peri√≥dicas y de segundo retardo que ya ingresaron en la cola del agente llegar√°n al agente. <br><br><h2>  Mensajes restringidos de tiempo de entrega </h2><br>  Otra cosa √∫til, a veces, que estar√° disponible en so_5_extra-1.2.0 es la entrega de mensajes con un l√≠mite de tiempo.  Por ejemplo, el agente request_handler env√≠a un mensaje verificar_firma al agente crypto_master.  Al mismo tiempo, request_handler quiere que verificar_signature se entregue en 5 segundos.  Si esto no sucede, entonces no tendr√° sentido el procesamiento de verity_signature, el agente request_handler ya detendr√° su trabajo. <br><br>  Y el agente de crypto_master es un compa√±ero al que le gusta convertirse en un "cuello de botella": a veces comienza a disminuir la velocidad.  En ese momento, los mensajes se acumulan en la cola, como la firma de verificaci√≥n anterior, que puede esperar hasta que se alivie crypto_master. <br><br>  Supongamos que request_handler envi√≥ un mensaje de verificaci√≥n de firma al agente crypto_master, pero luego crypto_master se empantan√≥ y se atasc√≥ durante 10 segundos.  El agente request_handler ya se ha "ca√≠do", es decir  Ya envi√≥ a todos una denegaci√≥n de servicio y complet√≥ su trabajo.  ¬°Pero el mensaje generate_signature permanece en la cola crypto_master!  Entonces, cuando crypto_master "se despega", tomar√° este mensaje y procesar√° este mensaje.  Aunque esto ya no es necesario. <br><br>  Usando el nuevo sobre so_5 :: extra :: envolped_msg :: time_limited_delivery_t, podemos resolver este problema: el agente request_handler enviar√° verifique_signature time_limited_delivery_t incluido en el sobre con un l√≠mite de tiempo de entrega: <br><br><pre> <code class="cpp hljs">so_5::extra::enveloped_msg::make&lt;verify_signature&gt;(...) .envelope&lt;so_5::extra::enveloped_msg::<span class="hljs-keyword"><span class="hljs-keyword">time_limited_delivery_t</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>s) .send_to(crypto_master_mbox);</code> </pre> <br>  Ahora, si crypto_master "se pega" y no logra verificar_firma en 5 segundos, el sobre simplemente no enviar√° este mensaje para su procesamiento.  Y crypto_master no har√° el trabajo que nadie m√°s necesita. <br><br><h2>  Informes de entrega de destinatarios </h2><br>  Y finalmente, un ejemplo de algo curioso que no se implementa regularmente en SObjectizer o so_5_extra, pero que se puede hacer de forma independiente. <br><br>  A veces desea recibir del SObjectizer algo como un mensaje de "informe de entrega" al destinatario.  Despu√©s de todo, es una cosa cuando el mensaje lleg√≥ al destinatario, pero el destinatario por alguna raz√≥n no respondi√≥.  Otra cosa es cuando el mensaje no lleg√≥ al destinatario en absoluto.  Por ejemplo, fue bloqueado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un mecanismo de protecci√≥n de sobrecarga del agente</a> .  En el primer caso, se puede omitir un mensaje al que no esperamos una respuesta.  Pero en el segundo caso, puede tener sentido volver a enviar el mensaje despu√©s de un tiempo. <br><br>  Ahora consideraremos c√≥mo se puede implementar el mecanismo m√°s simple de "informes de entrega" utilizando sobres. <br><br>  Entonces, primero hacemos los pasos preparatorios necesarios: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5_extra/enveloped_msg/just_envelope.hpp&gt; #include &lt;so_5_extra/enveloped_msg/send_functions.hpp&gt; #include &lt;so_5/all.hpp&gt; using namespace std::chrono_literals; namespace envelope_ns = so_5::extra::enveloped_msg; using request_id_t = int;</span></span></span></span></code> </pre><br>  Ahora podemos definir los mensajes que se utilizar√°n en el ejemplo.  El primer mensaje es una solicitud para realizar algunas acciones que necesitamos.  Y el segundo mensaje es una confirmaci√≥n de que el primer mensaje lleg√≥ al destinatario: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_id_t</span></span> m_id; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_data; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delivery_receipt_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   request_t::m_id   request_t. request_id_t m_id; };</span></span></code> </pre> <br>  A continuaci√≥n, podemos definir un agente procesador_t que procesar√° mensajes de tipo request_t.  Pero el procesamiento ser√° con una imitaci√≥n de "pegado".  Es decir  procesa request_t, despu√©s de lo cual cambia su estado de st_normal a st_busy.  En el estado st_busy, no hace nada e ignora todos los mensajes que le llegan. <br><br>  Esto significa que si el agente procesador_t env√≠a tres mensajes consecutivos request_t, procesar√° el primero y los otros dos ser√°n arrojados, porque  Al procesar el primer mensaje, el agente ir√° a st_busy e ignorar√° lo que le llegar√° mientras est√° en st_busy. <br><br>  En st_busy, el agente procesador_t pasar√° 2 segundos, despu√©s de lo cual volver√° nuevamente a st_normal y estar√° listo para procesar nuevos mensajes. <br><br>  As√≠ se ve el agente procesador_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   .     //   . state_t st_normal{this, "normal"}; //  " ".   . state_t st_busy{this, "busy"}; public: processor_t(context_t ctx) : so_5::agent_t{std::move(ctx)} { this &gt;&gt;= st_normal; st_normal.event(&amp;processor_t::on_request); //     ,    . //  2   ,    st_normal. st_busy.time_limit(2s, st_normal); } private: void on_request(mhood_t&lt;request_t&gt; cmd) { std::cout &lt;&lt; "processor: on_request(" &lt;&lt; cmd-&gt;m_id &lt;&lt; ", " &lt;&lt; cmd-&gt;m_data &lt;&lt; ")" &lt;&lt; std::endl; this &gt;&gt;= st_busy; } };</span></span></code> </pre> <br>  Ahora podemos definir el agente request_generator_t, que tiene un mont√≥n de solicitudes que deben entregarse al procesador_t.  El agente request_generator_t env√≠a el paquete completo cada 3 segundos, y luego espera la confirmaci√≥n de entrega en forma de delivery_receipt_t. <br><br>  Cuando llega delivery_recept_t, el agente request_generator_t arroja la solicitud entregada fuera del paquete.  Si el paquete est√° completamente vac√≠o, se completa el ejemplo.  Si queda algo m√°s, el paquete restante se enviar√° nuevamente cuando llegue la pr√≥xima vez para reenviar. <br><br>  As√≠ que aqu√≠ est√° el c√≥digo de agente request_generator_t.  Es bastante voluminoso, pero primitivo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solo puede prestar atenci√≥n a los aspectos internos del m√©todo send_requests (), en el que se env√≠an mensajes request_t, encerrados en un sobre especial. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requests_generator_t c√≥digo de agente</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests_generator_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_processor; //  ,       . std::map&lt;request_id_t, std::string&gt; m_requests; struct resend_requests final : public so_5::signal_t {}; public: requests_generator_t(context_t ctx, so_5::mbox_t processor) : so_5::agent_t{std::move(ctx)} , m_processor{std::move(processor)} { so_subscribe_self() .event(&amp;requests_generator_t::on_delivery_receipt) .event(&amp;requests_generator_t::on_resend); } void so_evt_start() override { //    . m_requests.emplace(0, "First"); m_requests.emplace(1, "Second"); m_requests.emplace(2, "Third"); m_requests.emplace(3, "Four"); //  . send_requests(); } private: void on_delivery_receipt(mhood_t&lt;delivery_receipt_t&gt; cmd) { std::cout &lt;&lt; "request delivered: " &lt;&lt; cmd-&gt;m_id &lt;&lt; std::endl; m_requests.erase(cmd-&gt;m_id); if(m_requests.empty()) //    .  . so_deregister_agent_coop_normally(); } void on_resend(mhood_t&lt;resend_requests&gt;) { std::cout &lt;&lt; "time to resend requests, pending requests: " &lt;&lt; m_requests.size() &lt;&lt; std::endl; send_requests(); } void send_requests() { for(const auto &amp; item : m_requests) { std::cout &lt;&lt; "sending request: (" &lt;&lt; item.first &lt;&lt; ", " &lt;&lt; item.second &lt;&lt; ")" &lt;&lt; std::endl; envelope_ns::make&lt;request_t&gt;(item.first, item.second) .envelope&lt;custom_envelope_t&gt;(so_direct_mbox(), item.first) .send_to(m_processor); } //       3 . so_5::send_delayed&lt;resend_requests&gt;(*this, 3s); } };</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos mensajes y agentes que deben usar estos mensajes para comunicarse. </font><font style="vertical-align: inherit;">Solo quedaba una peque√±a cosa: hacer que los mensajes delivery_receipt_t lleguen de alguna manera al entregar request_t al procesador_t. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se hace usando este sobre:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> custom_envelope_t final : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> envelope_ns::just_envelope_t { //     . const so_5::mbox_t m_to; // ID  . const request_id_t m_id; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: custom_envelope_t(so_5::message_ref_t payload, so_5::mbox_t <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>, request_id_t id) : envelope_ns::just_envelope_t{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(payload)} , m_to{std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>)} , m_id{id} {} <span class="hljs-type"><span class="hljs-type">void</span></span> handler_found_hook(handler_invoker_t &amp; <span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>) noexcept override { //    ,     . //     . so_5::send&lt;delivery_receipt_t&gt;(m_to, m_id); //      . envelope_ns::just_envelope_t::handler_found_hook(<span class="hljs-keyword"><span class="hljs-keyword">invoker</span></span>); } };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, no hay nada complicado. </font><font style="vertical-align: inherit;">Heredamos de so_5 :: extra :: envped_msg :: just_envelope_t. </font><font style="vertical-align: inherit;">Este es un tipo de sobre auxiliar que almacena el mensaje encerrado en √©l y proporciona la implementaci√≥n b√°sica de los ganchos </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">handler_found_hook () y transformaci√≥n_hook (). </font><font style="vertical-align: inherit;">Por lo tanto, solo podemos guardar los atributos que necesitamos dentro de custom_envelope_t y enviar delivery_receipt_t dentro del gancho handler_found_hook ().</font></font><br><br>  Eso, de hecho, es todo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si ejecutamos este ejemplo, obtenemos lo siguiente: </font></font><br><br><pre> <code class="hljs vbscript">sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">0</span></span>, First) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">0</span></span>, First) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">3</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">2</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">2</span></span>, Third) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> resend requests, pending requests: <span class="hljs-number"><span class="hljs-number">1</span></span> sending <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>: (<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) processor: on_request(<span class="hljs-number"><span class="hljs-number">3</span></span>, Four) <span class="hljs-built_in"><span class="hljs-built_in">request</span></span> delivered: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, debo decir que en la pr√°ctica, un simple custom_envelope_t para generar informes de entrega no es adecuado. </font><font style="vertical-align: inherit;">Pero si alguien est√° interesado en este tema, entonces puede discutirse en los comentarios y no aumentar el volumen del art√≠culo.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øQu√© m√°s se podr√≠a hacer con los sobres? </font></font></h1><br>  Gran pregunta!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A lo que nosotros mismos no tenemos una respuesta integral. </font><font style="vertical-align: inherit;">Probablemente, las posibilidades est√°n limitadas solo por la imaginaci√≥n de los usuarios. </font><font style="vertical-align: inherit;">Bueno, si para la realizaci√≥n de fantas√≠as en SObjectizer falta algo, entonces esto se nos puede decir. </font><font style="vertical-align: inherit;">Siempre escuchamos </font><font style="vertical-align: inherit;">Y, lo que es m√°s importante, a veces incluso lo hacemos :)</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Integraci√≥n de agentes con mchain </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hablando un poco m√°s en serio, esa es otra caracter√≠stica que me gustar√≠a tener de vez en cuando y que incluso se plane√≥ para so_5_extra-1.2.0. Pero, lo m√°s probable, no se incluir√° en la versi√≥n 1.2.0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se trata de simplificar la integraci√≥n de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mchains</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y agentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El hecho es que inicialmente se agregaron mchains a SObjectizer para simplificar la comunicaci√≥n de los agentes con otras partes de la aplicaci√≥n que est√°n escritas sin agentes. Por ejemplo, existe el hilo principal de la aplicaci√≥n, en el cual el usuario interact√∫a usando la GUI. Y hay varios agentes-trabajadores que hacen el trabajo "duro" de fondo. Enviar un mensaje a un agente desde el hilo principal no es un problema: solo llame al env√≠o regular. Pero, ¬øc√≥mo transferir la informaci√≥n de regreso?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para esto, se agregaron mchain-s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero con el tiempo, result√≥ que las cadenas pueden jugar un papel mucho m√°s importante. Es posible, en principio, hacer aplicaciones multiproceso en SObjectizer sin ning√∫n agente, solo en mchain-ahs (m√°s detalles </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Y puede usar mchain-s como un medio para equilibrar la carga de los agentes. Como mecanismo para resolver problemas productor-consumidor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema con el productor-consumidor es que si el productor genera mensajes m√°s r√°pido de lo que el consumidor puede manejarlos, entonces estamos en problemas. Las colas de mensajes crecer√°n, el rendimiento puede degradarse con el tiempo o la aplicaci√≥n se bloquear√° por completo debido al agotamiento de la memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La soluci√≥n habitual que propusimos usar en este caso es usar</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un par de agentes coleccionistas e int√©rpretes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tambi√©n puede usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√≠mites de mensajes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ya sea como el mecanismo de protecci√≥n principal o como una adici√≥n al recopilador-int√©rprete). Pero escribir coleccionista-int√©rprete requiere trabajo adicional del programador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero mchains podr√≠a usarse para estos fines con el m√≠nimo esfuerzo del desarrollador. Entonces, el productor pondr√≠a el siguiente mensaje en mchain, y el consumidor tomar√≠a mensajes de esta mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero el problema es que cuando el consumidor es un agente, no es muy conveniente que un agente trabaje con mchain a trav√©s de las funciones de recepci√≥n () y selecci√≥n () disponibles. Y se podr√≠a tratar de eliminar este inconveniente con la ayuda de alguna herramienta para integrar agentes y mchain-s.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al desarrollar dicha herramienta, ser√° necesario resolver varios problemas. Por ejemplo, cuando llega un mensaje en mchain, ¬øen qu√© punto debe extraerse de mchain? Si el consumidor es gratuito y no procesa nada, puede recoger el mensaje de mchain de inmediato y entreg√°rselo al agente del consumidor. Si ya se ha enviado un mensaje al consumidor desde mchain, a√∫n no ha logrado procesar este mensaje, pero un nuevo mensaje ya ha llegado a mchain ... ¬øQu√© se debe hacer en este caso? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se especula que los sobres pueden ayudar en este caso. Entonces, cuando tomamos el primer mensaje de mchain y lo enviamos al consumidor, envolvemos este mensaje en un sobre especial. Cuando el sobre ve que el mensaje ha sido entregado y procesado, solicita el siguiente mensaje de mchain (si hay uno).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, no todo es tan simple aqu√≠. </font><font style="vertical-align: inherit;">Pero hasta ahora parece bastante solucionable. </font><font style="vertical-align: inherit;">Y, espero, un mecanismo similar aparecer√° en una de las pr√≥ximas versiones de so_5_extra.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬øVamos a abrir la caja de Pandora? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cabe se√±alar que con nosotros las capacidades adicionales en s√≠ mismas causan sentimientos duales. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por un lado, los sobres ya han permitido / permiten hacer cosas que se mencionaron anteriormente (pero que solo so√±aron con algo). </font><font style="vertical-align: inherit;">Por ejemplo, esta es una cancelaci√≥n garantizada de temporizadores y una restricci√≥n en el tiempo de entrega, informes de entrega, la capacidad de recuperar un mensaje enviado previamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por otro lado, no est√° claro a qu√© conducir√° esto posteriormente. </font><font style="vertical-align: inherit;">Despu√©s de todo, puede crear un problema con cualquier oportunidad si comienza a usar esta oportunidad donde necesita y donde no. </font><font style="vertical-align: inherit;">¬øEntonces tal vez abrimos la caja de Pandora y todav√≠a no imaginamos lo que nos espera? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solo queda ser paciente y ver a d√≥nde nos llevar√° todo esto.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acerca de los planes de desarrollo inmediato de SObjectizer en lugar de concluir </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de una conclusi√≥n, quiero hablar sobre c√≥mo vemos el futuro muy cercano (y no solo) de SObjectizer. Si alguien no est√° contento con algo en nuestros planes, puede hablar e influir en c√≥mo se desarrollar√° SObjectizer-5. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las primeras versiones beta de SObjectizer-5.5.23 y so_5_extra-1.2.0 ya est√°n reparadas y disponibles para descargar y experimentar. Todav√≠a habr√° mucho trabajo por hacer en el √°rea de documentaci√≥n y casos de uso. Por lo tanto, el lanzamiento oficial est√° previsto para la primera d√©cada de noviembre. Si funciona antes, lo haremos antes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El lanzamiento de SObjectizer-5.5.23 parece significar que la evoluci√≥n de la rama 5.5 est√° llegando a su fin. El </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primer lanzamiento de este hilo tuvo lugar hace cuatro a√±os, en octubre de 2014.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Desde entonces, SObjectizer-5 ha evolucionado dentro de la rama 5.5 sin ning√∫n cambio importante entre las versiones. No fue facil. Especialmente considerando el hecho de que todo este tiempo tuvimos que mirar hacia atr√°s a los compiladores que ten√≠an un soporte lejos de ser ideal para C ++ 11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora no vemos ninguna raz√≥n para mirar hacia atr√°s en la compatibilidad dentro de la rama 5.5, y especialmente en los compiladores C ++ m√°s antiguos. Lo que podr√≠a estar justificado en 2014, cuando C ++ 14 se estaba preparando para ser adoptado oficialmente, y C ++ 17 a√∫n no estaba en el horizonte, ahora se ve completamente diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, en SObjectizer-5.5 ya se ha acumulado una buena cantidad de rake y copias de seguridad, que aparecieron debido a esta misma compatibilidad y que complican el desarrollo posterior de SObjectizer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, en los pr√≥ximos meses vamos a actuar de acuerdo con el siguiente escenario: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Desarrollo de la pr√≥xima versi√≥n de so_5_extra, en la que quiero agregar herramientas para simplificar la redacci√≥n de pruebas para agentes. A√∫n no est√° claro si ser√° so_5_extra-1.3.0 (es decir, con cambios de ruptura en relaci√≥n con 1.2.0) o si ser√° so_5_extra-1.2.1 (es decir, sin cambios de ruptura). Veamos c√≥mo va. Solo est√° claro que la pr√≥xima versi√≥n de so_5_extra se basar√° en SObjectizer-5.5.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1a. Si para la pr√≥xima versi√≥n de so_5_extra necesita hacer algo adicional en SObjectizer-5.5, se lanzar√° la pr√≥xima versi√≥n 5.5.24. Si para so_5_extra no ser√° necesario realizar mejoras en el n√∫cleo de SObjectizer, la versi√≥n 5.5.23 ser√° la √∫ltima versi√≥n significativa en el marco de la rama 5.5. Saldr√°n lanzamientos menores de correcci√≥n de errores. Pero el desarrollo de la rama 5.5 se detiene en la versi√≥n 5.5.23 o 5.5.24.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Luego se lanzar√° una versi√≥n de SObjectizer-5.6.0, que abrir√° una nueva rama. En la rama 5.6, limpiaremos el c√≥digo SObjectizer de todas las muletas y copias de seguridad acumuladas, as√≠ como de la basura vieja que durante mucho tiempo se ha marcado como obsoleta. Es probable que algunas cosas se sometan a una refactorizaci√≥n (por ejemplo, abstract_message_box_t se puede cambiar), pero dif√≠cilmente cardinal. Los principios b√°sicos de trabajo y las caracter√≠sticas de SObjectizer-5.5 en SObjectizer-5.6 permanecer√°n en la misma forma. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5.6 ya requerir√° C ++ 14 (al menos en el nivel GCC-5.5). Los compiladores de Visual C ++ debajo de VC ++ 15 (que es de Visual Studio 2017) no ser√°n compatibles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consideramos la rama 5.6 como una rama estable de SObjectizer, que ser√° relevante hasta que aparezca la primera versi√≥n de SObjectizer-5.7.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Me gustar√≠a lanzar la versi√≥n 5.6.0 a principios de 2019, tentativamente en febrero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Despu√©s de estabilizar la rama 5.6, nos gustar√≠a comenzar a trabajar en la rama 5.7, en la que podr√≠amos revisar algunos principios b√°sicos del trabajo de SObjectizer. Por ejemplo, abandone por completo los despachadores p√∫blicos, dejando solo los privados. Rehacer el mecanismo de las cooperativas y sus relaciones entre padres e hijos, eliminando as√≠ el cuello de botella durante el registro / desregistro de las cooperativas. Eliminar la divisi√≥n por mensaje / se√±al. Permita que solo send / send_delayed / send_periodic env√≠e mensajes, y oculte los m√©todos de delivery_message y schedule_timer "debajo del cap√≥". Modifique el mecanismo para enviar mensajes de modo que elimine completamente dynamic_casts de este proceso o reduzca al m√≠nimo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En general, hay d√≥nde dar la vuelta. Al mismo tiempo, SObjectizer-5.7 ya requerir√° C ++ 17, independientemente de C ++ 14. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si miras las cosas sin gafas de color rosa, es bueno que la versi√≥n 5.7.0 tenga lugar a fines del oto√±o de 2019. La principal versi√≥n de trabajo de SObjectizer para 2019 ser√° la rama 5.6. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Paralelo a todo esto, se desarrollar√° so_5_extra. Probablemente, la versi√≥n so_5_extra-2 se lanzar√° junto con SObjectizer-5.6, que incorporar√° una nueva funcionalidad en el transcurso de 2019, pero basada en SObjectizer-5.6.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, nosotros mismos vemos una evoluci√≥n progresiva de SObjectizer-5 con una revisi√≥n gradual de algunos de los principios b√°sicos de SObjectizer-5. Al mismo tiempo, intentaremos hacer esto de la forma m√°s fluida posible para que sea posible cambiar de una versi√≥n a otra con un m√≠nimo de dolor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, si alguien quisiera cambios m√°s dram√°ticos y significativos de SObjectizer, entonces </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenemos algunas ideas al respecto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En pocas palabras: puede rehacer SObjectizer como desee, hasta implementar SObjectizer-6 para otro lenguaje de programaci√≥n. Pero no lo haremos por nuestra cuenta, ya que esto sucede con la evoluci√≥n de SObjectizer-5.</font></font><br><br>  Eso es probablemente todo.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los comentarios </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al art√≠culo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resultaron ser una discusi√≥n buena y constructiva. </font><font style="vertical-align: inherit;">Ser√≠a √∫til para nosotros si ocurriera una discusi√≥n similar esta vez. </font><font style="vertical-align: inherit;">Como siempre, estamos listos para responder cualquier pregunta, pero a las sensatas, y con gusto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y para los lectores m√°s pacientes que han llegado a estas l√≠neas, muchas gracias por el tiempo dedicado a leer el art√≠culo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426983/">https://habr.com/ru/post/es426983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426973/index.html">Sandwiches corporativos</a></li>
<li><a href="../es426975/index.html">Joker 2018: lo imposible es posible</a></li>
<li><a href="../es426977/index.html">LibreOffice: la pesadilla del contador</a></li>
<li><a href="../es426979/index.html">C√≥mo aprender ingl√©s gratis: 3 herramientas comunes e instrucciones detalladas para cada</a></li>
<li><a href="../es426981/index.html">10 trucos para tablero avanzado en Splunk. Parte 1</a></li>
<li><a href="../es426985/index.html">Kubebox y otros cascos de consola para Kubernetes</a></li>
<li><a href="../es426987/index.html">Aprende OpenGL. Lecci√≥n 6.3 - Iluminaci√≥n basada en im√°genes. Irradiaci√≥n difusa</a></li>
<li><a href="../es426991/index.html">Startup Digest: 10 pr√≥ximos eventos de TI en Mosc√∫</a></li>
<li><a href="../es426993/index.html">¬øNecesito aprender C para entender c√≥mo funciona una computadora?</a></li>
<li><a href="../es426995/index.html">El reciclaje perjudica tanto a los productos como a los empleados.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>