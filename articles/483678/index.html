<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèø üëèüèæ üö® Desarrollando programas Python extremadamente r√°pidos ‚ò¶Ô∏è üî∫ ü•û</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los que odian a Python siempre dicen que una de las razones por las que no quieren usar este lenguaje es porque Python es lento. Pero el hecho de que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollando programas Python extremadamente r√°pidos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483678/">  Los que odian a Python siempre dicen que una de las razones por las que no quieren usar este lenguaje es porque Python es lento.  Pero el hecho de que un determinado programa, independientemente del lenguaje de programaci√≥n utilizado, pueda considerarse r√°pido o lento, depende en gran medida del desarrollador que lo escribi√≥, de su conocimiento y de la capacidad de crear c√≥digo optimizado y de alto rendimiento. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/483678/"><img src="https://habrastorage.org/webt/mr/w_/bl/mrw_bl18nmxvnmxgkcrg6nyguoo.jpeg"></a> <br><br>  El autor del art√≠culo, que publicamos hoy, ofrece probar que aquellos que llaman a Python lento est√°n equivocados.  Quiere hablar sobre c√≥mo mejorar el rendimiento de los programas Python y hacerlos realmente r√°pidos. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Medici√≥n de tiempo y perfil</font> </h2><br>  Antes de comenzar a optimizar cualquier c√≥digo, primero debe averiguar qu√© partes de √©l ralentizan todo el programa.  A veces, un cuello de botella del programa puede ser obvio, pero si el programador no sabe d√≥nde est√°, puede aprovechar algunas oportunidades para identificarlo. <br><br>  A continuaci√≥n se muestra el c√≥digo del programa, que utilizar√© para fines de demostraci√≥n.  Est√° tomado de la documentaci√≥n de Python.  Este c√≥digo eleva <code>e</code> al poder de <code>x</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># slow_program.py from decimal import * def exp(x):    getcontext().prec += 2    i, lasts, s, fact, num = 0, 0, 1, 1, 1    while s != lasts:        lasts = s        i += 1        fact *= i        num *= x        s += num / fact    getcontext().prec -= 2    return +s exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">La forma m√°s f√°cil de "perfilar" el c√≥digo</font> </h2><br>  Para comenzar, considere la forma m√°s sencilla de perfilar su c√≥digo.  Por as√≠ decirlo, "perfilar para los perezosos".  Consiste en usar el comando de <code>time</code> Unix: <br><br><pre> <code class="python hljs">~ $ time python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py real <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">058</span></span>s user <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">050</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0,<span class="hljs-number"><span class="hljs-number">008</span></span>s</code> </pre> <br>  Tal perfil puede brindarle al programador informaci√≥n √∫til, en caso de que necesite medir el tiempo de ejecuci√≥n de todo el programa.  Pero generalmente esto no es suficiente. <br><br><h2>  <font color="#3AC1EF">El m√©todo de perfilado m√°s preciso</font> </h2><br>  En el otro extremo del espectro de m√©todos de creaci√≥n de perfiles de c√≥digo se encuentra la herramienta <code>cProfile</code> , que le da al programador, ciertamente, demasiada informaci√≥n: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> -m cProfile -s time slow_program.py         <span class="hljs-number"><span class="hljs-number">1297</span></span> function calls (<span class="hljs-number"><span class="hljs-number">1272</span></span> primitive calls) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span> seconds   Ordered by: internal time   ncalls tottime percall cumtime percall filename:lineno(function)        <span class="hljs-number"><span class="hljs-number">3</span></span>  <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">4</span></span>(exp)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.002</span></span>  <span class="hljs-number"><span class="hljs-number">0.002</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method _imp.create_dynamic}      <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.<span class="hljs-keyword"><span class="hljs-keyword">exec</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method __new__ of type object at <span class="hljs-number"><span class="hljs-number">0x9d12c0</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">132</span></span>(__new__)       <span class="hljs-number"><span class="hljs-number">23</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> _weakrefset.py:<span class="hljs-number"><span class="hljs-number">36</span></span>(__init__)      <span class="hljs-number"><span class="hljs-number">245</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.getattr}        <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method marshal.loads}       <span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">1233</span></span>(find_spec)      <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">196</span></span>(__subclasscheck__)       <span class="hljs-number"><span class="hljs-number">15</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method posix.stat}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.__build_class__}        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> __init__.py:<span class="hljs-number"><span class="hljs-number">357</span></span>(namedtuple)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">57</span></span>(_path_join)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">59</span></span>(&lt;listcomp&gt;)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">1</span></span>(&lt;module&gt;)</code> </pre> <br>  Aqu√≠ ejecutamos el script investigado usando el m√≥dulo <code>cProfile</code> y usamos el argumento <code>time</code> .  Como resultado, las l√≠neas de salida se ordenan por tiempo interno ( <code>cumtime</code> ).  Nos da mucha informaci√≥n.  De hecho, lo que se muestra arriba es solo alrededor del 10% de la producci√≥n de <code>cProfile</code> . <br><br>  Despu√©s de analizar estos datos, podemos ver que la funci√≥n <code>exp</code> es la raz√≥n del lento funcionamiento del programa (¬°eso es una sorpresa!).  Despu√©s de eso, podemos hacer perfiles de c√≥digo utilizando herramientas m√°s precisas. <br><br><h2>  <font color="#3AC1EF">El estudio de los indicadores temporales de desempe√±o de una funci√≥n espec√≠fica.</font> </h2><br>  Ahora sabemos sobre el lugar del programa donde necesitamos dirigir nuestra atenci√≥n.  Por lo tanto, podemos decidir estudiar la funci√≥n lenta sin perfilar otro c√≥digo de programa.  Para hacer esto, puede usar un decorador simple: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeit_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span>    @wraps(func)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        start = time.perf_counter() <span class="hljs-comment"><span class="hljs-comment">#       time.process_time()        func_return_val = func(*args, **kwargs)        end = time.perf_counter()        print('{0:&lt;10}.{1:&lt;8} : {2:&lt;8}'.format(func.__module__, func.__name__, end - start))        return func_return_val    return wrapper</span></span></code> </pre> <br>  Este decorador se puede aplicar a la funci√≥n a explorar: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@timeit_wrapper def exp(x):    ... print('{0:&lt;10} {1:&lt;8} {2:^8}'.format('module', 'function', 'time')) exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br>  Ahora, despu√©s de comenzar el programa, recibiremos la siguiente informaci√≥n: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py module   function time __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.003267502994276583</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.038535295985639095</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">11.728486061969306</span></span></code> </pre> <br>  Aqu√≠ vale la pena prestar atenci√≥n a exactamente a qu√© hora planeamos medir.  El paquete correspondiente nos proporciona indicadores como <code>time.perf_counter</code> y <code>time.process_time</code> .  La diferencia entre ellos es que <code>perf_counter</code> devuelve un valor absoluto, que incluye el tiempo durante el cual el proceso del programa Python no se est√° ejecutando.  Esto significa que este indicador puede verse afectado por la carga en la computadora creada por otros programas.  La <code>process_time</code> solo devuelve el tiempo del usuario.  No incluye la hora del sistema.  Esto solo nos brinda informaci√≥n sobre el tiempo de ejecuci√≥n de nuestro proceso. <br><br><h2>  <font color="#3AC1EF">Aceleraci√≥n de c√≥digo</font> </h2><br>  Y ahora para la parte divertida.  Trabajemos para acelerar el programa.  No voy a mostrar (en su mayor parte) todo tipo de trucos, trucos y misteriosos c√≥digos aqu√≠ que resuelven m√°gicamente los problemas de rendimiento.  B√°sicamente quiero hablar sobre ideas y estrategias comunes que, si se usan, pueden tener un gran impacto en el rendimiento.  En algunos casos, estamos hablando de un aumento del 30% en la velocidad de ejecuci√≥n del c√≥digo. <br><br><h3>  <font color="#3AC1EF">‚ñçUtilice los tipos de datos incorporados</font> </h3><br>  El uso de tipos de datos integrados es un enfoque muy obvio para acelerar el c√≥digo.  Los tipos de datos integrados son extremadamente r√°pidos, especialmente si los compara con tipos personalizados como √°rboles o listas vinculadas.  El punto aqu√≠ es principalmente que los mecanismos integrados del lenguaje se implementan usando C. Si describe algo usando Python, no puede lograr el mismo nivel de rendimiento. <br><br><h3>  <font color="#3AC1EF">‚ñçAplicar almacenamiento en cach√© (memorizaci√≥n) con lru_cache</font> </h3><br>  El almacenamiento en cach√© es un enfoque popular para mejorar el rendimiento del c√≥digo.  Ya <a href="https://martinheinz.dev/blog/4">escrib√≠</a> sobre √©l, pero creo que vale la pena contarlo sobre √©l aqu√≠: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-comment"><span class="hljs-comment">#   12   @functools.lru_cache(maxsize=12) def slow_func(x):    time.sleep(2) #       return x slow_func(1) # ...  2     slow_func(1) #    -   ! slow_func(3) # ...   2    </span></span></code> </pre> <br>  La funci√≥n anterior simula c√°lculos complejos utilizando <code>time.sleep</code> .  Cuando se llama por primera vez con el par√°metro <code>1</code> , espera 2 segundos y devuelve el resultado solo despu√©s de eso.  Cuando vuelve a llamarla con el mismo par√°metro, resulta que el resultado de su trabajo ya est√° almacenado en cach√©.  El cuerpo de la funci√≥n en esta situaci√≥n no se ejecuta y el resultado se devuelve inmediatamente.  <a href="https://martinheinz.dev/blog/4">Aqu√≠</a> puede encontrar ejemplos de almacenamiento en cach√© m√°s cercanos a la realidad. <br><br><h3>  <font color="#3AC1EF">‚ñçUtilizar variables locales</font> </h3><br>  Aplicando variables locales, tenemos en cuenta la velocidad de b√∫squeda de una variable en cada √°mbito.  Estoy hablando espec√≠ficamente de "todas las √°reas de visibilidad", ya que aqu√≠ tengo en mente no solo una comparaci√≥n de la velocidad del trabajo con variables locales y globales.  De hecho, la diferencia en el trabajo con variables incluso se observa, por ejemplo, entre variables locales en una funci√≥n (la velocidad m√°s alta), atributos de nivel de clase (por ejemplo, <code>self.name</code> , esto ya es m√°s lento) y entidades globales importadas como <code>time.time</code> (la mayor√≠a lento de estos tres mecanismos). <br><br>  Puede mejorar el rendimiento utilizando los siguientes enfoques para asignar valores que pueden parecer completamente innecesarios e in√∫tiles para una persona desinformada: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  #1 class FastClass:    def do_stuff(self):        temp = self.value #           for i in range(10000):            ... #      `temp` #  #2 import random def fast_function():    r = random.random    for i in range(10000):        print(r()) #   `r()` ,     random.random()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç C√≥digo de ajuste en funci√≥n</font> </h3><br>  Este consejo puede parecer contrario al sentido com√∫n, ya que cuando se llama a una funci√≥n, algunos datos se env√≠an a la pila y el sistema est√° bajo carga adicional procesando la operaci√≥n de retorno de la funci√≥n.  Sin embargo, esta recomendaci√≥n est√° relacionada con la anterior.  Si solo coloca todo su c√≥digo en un archivo sin escribirlo como una funci√≥n, se ejecutar√° mucho m√°s lento debido al uso de variables globales.  Esto significa que el c√≥digo se puede acelerar simplemente envolvi√©ndolo en la funci√≥n <code>main()</code> y llam√°ndolo una vez: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    ... <span class="hljs-comment"><span class="hljs-comment">#  ,     main()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçNo acceda a los atributos</font> </h3><br>  Otro mecanismo que puede ralentizar un programa es el operador punto ( <code>.</code> ), Que se utiliza para acceder a los atributos de los objetos.  Esta declaraci√≥n invoca una <code>__getattribute__</code> diccionario usando <code>__getattribute__</code> , lo que <code>__getattribute__</code> un esfuerzo adicional en el sistema.  ¬øC√≥mo limitar el impacto en el rendimiento de esta funci√≥n de Python? <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : import re def slow_func():    for i in range(10000):        re.findall(regex, line) # ! # : from re import findall def fast_func():    for i in range(10000):        findall(regex, line) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Cuidado con las cuerdas</font> </h3><br>  Las operaciones de cadena pueden ralentizar enormemente un programa si se ejecutan en bucles.  En particular, estamos hablando de formatear cadenas usando <code>%s</code> <code>.format()</code> .  ¬øEs posible reemplazarlos con algo?  Si observa un <a href="https://twitter.com/raymondh/status/1205969258800275456">tweet</a> reciente <a href="https://twitter.com/raymondh/status/1205969258800275456">de</a> Raymond Hettinger, puede ver que el √∫nico mecanismo que debe usarse en tales situaciones son las l√≠neas f.  Este es el m√©todo de formateo de cadenas m√°s legible, conciso y r√°pido.  Aqu√≠, de acuerdo con ese tweet, hay una lista de m√©todos que se pueden usar para trabajar con cadenas, desde el m√°s r√°pido hasta el m√°s lento: <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{s}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{t}</span></span></span><span class="hljs-string">'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ! s + ' ' + t ' '.join((s, t)) '%s %s' % (s, t) '{} {}'.format(s, t) Template('$s $t').substitute(s=s, t=t) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Sepa que los generadores tambi√©n pueden funcionar r√°pido</font> </h3><br>  Los generadores no son aquellos mecanismos que, por su naturaleza, son r√°pidos.  El hecho es que fueron creados para realizar c√°lculos "perezosos", lo que no ahorra tiempo, sino memoria.  Sin embargo, ahorrar memoria puede hacer que los programas se ejecuten m√°s r√°pido.  ¬øC√≥mo es esto posible?  El hecho es que al procesar un gran conjunto de datos sin usar generadores (iteradores), los datos pueden provocar un desbordamiento de la cach√© L1 del procesador, lo que ralentizar√° significativamente el proceso de b√∫squeda de valores en la memoria. <br><br>  Cuando se trata del rendimiento, es muy importante esforzarse por garantizar que el procesador pueda acceder r√°pidamente a los datos que procesa, de modo que est√©n lo m√°s cerca posible de ellos.  Y esto significa que dichos datos deben colocarse en la memoria cach√© del procesador.  Este problema se aborda en <a href="https://www.youtube.com/watch%3Fv%3DOSGv2VnC0go%26t%3D8m17s">esta</a> presentaci√≥n de Raymond Hettinger. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  La primera regla de optimizaci√≥n es que la optimizaci√≥n no es necesaria.  Pero si no puede prescindir de la optimizaci√≥n, espero que los consejos que he compartido le ayuden con esto. <br><br>  <b>Estimados lectores!</b>  ¬øC√≥mo aborda la optimizaci√≥n del rendimiento de su c√≥digo Python? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/483678/">https://habr.com/ru/post/483678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483666/index.html">Sobre Volodia y el ozonizador</a></li>
<li><a href="../483668/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 397 (6 al 12 de enero de 2020)</a></li>
<li><a href="../483670/index.html">Todo lo que quer√≠as saber sobre la direcci√≥n MAC</a></li>
<li><a href="../483674/index.html">C√≥mo funcionan las redes neuronales binarias y por qu√© ser√°n populares en 2020</a></li>
<li><a href="../483676/index.html">Evaluaci√≥n de la efectividad y el costo de implementar un sistema de an√°lisis de marketing de extremo a extremo</a></li>
<li><a href="../483680/index.html">Errores de programaci√≥n comunes para evitar</a></li>
<li><a href="../483682/index.html">Agrupaci√≥n y rendimiento de JavaScript: mejores pr√°cticas</a></li>
<li><a href="../483684/index.html">PHP Digest No. 171 (1 al 13 de enero de 2020)</a></li>
<li><a href="../483686/index.html">32 consejos para un desarrollador web que quiere crecer por encima de s√≠ mismo en 2020</a></li>
<li><a href="../483688/index.html">Aproximadamente 30x Concurrency Boost en Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>