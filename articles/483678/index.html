<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏿 👏🏾 🚨 Desarrollando programas Python extremadamente rápidos ☦️ 🔺 🥞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los que odian a Python siempre dicen que una de las razones por las que no quieren usar este lenguaje es porque Python es lento. Pero el hecho de que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollando programas Python extremadamente rápidos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483678/">  Los que odian a Python siempre dicen que una de las razones por las que no quieren usar este lenguaje es porque Python es lento.  Pero el hecho de que un determinado programa, independientemente del lenguaje de programación utilizado, pueda considerarse rápido o lento, depende en gran medida del desarrollador que lo escribió, de su conocimiento y de la capacidad de crear código optimizado y de alto rendimiento. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/483678/"><img src="https://habrastorage.org/webt/mr/w_/bl/mrw_bl18nmxvnmxgkcrg6nyguoo.jpeg"></a> <br><br>  El autor del artículo, que publicamos hoy, ofrece probar que aquellos que llaman a Python lento están equivocados.  Quiere hablar sobre cómo mejorar el rendimiento de los programas Python y hacerlos realmente rápidos. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Medición de tiempo y perfil</font> </h2><br>  Antes de comenzar a optimizar cualquier código, primero debe averiguar qué partes de él ralentizan todo el programa.  A veces, un cuello de botella del programa puede ser obvio, pero si el programador no sabe dónde está, puede aprovechar algunas oportunidades para identificarlo. <br><br>  A continuación se muestra el código del programa, que utilizaré para fines de demostración.  Está tomado de la documentación de Python.  Este código eleva <code>e</code> al poder de <code>x</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># slow_program.py from decimal import * def exp(x):    getcontext().prec += 2    i, lasts, s, fact, num = 0, 0, 1, 1, 1    while s != lasts:        lasts = s        i += 1        fact *= i        num *= x        s += num / fact    getcontext().prec -= 2    return +s exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">La forma más fácil de "perfilar" el código</font> </h2><br>  Para comenzar, considere la forma más sencilla de perfilar su código.  Por así decirlo, "perfilar para los perezosos".  Consiste en usar el comando de <code>time</code> Unix: <br><br><pre> <code class="python hljs">~ $ time python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py real <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">058</span></span>s user <span class="hljs-number"><span class="hljs-number">0</span></span>m11,<span class="hljs-number"><span class="hljs-number">050</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0,<span class="hljs-number"><span class="hljs-number">008</span></span>s</code> </pre> <br>  Tal perfil puede brindarle al programador información útil, en caso de que necesite medir el tiempo de ejecución de todo el programa.  Pero generalmente esto no es suficiente. <br><br><h2>  <font color="#3AC1EF">El método de perfilado más preciso</font> </h2><br>  En el otro extremo del espectro de métodos de creación de perfiles de código se encuentra la herramienta <code>cProfile</code> , que le da al programador, ciertamente, demasiada información: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> -m cProfile -s time slow_program.py         <span class="hljs-number"><span class="hljs-number">1297</span></span> function calls (<span class="hljs-number"><span class="hljs-number">1272</span></span> primitive calls) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span> seconds   Ordered by: internal time   ncalls tottime percall cumtime percall filename:lineno(function)        <span class="hljs-number"><span class="hljs-number">3</span></span>  <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> <span class="hljs-number"><span class="hljs-number">11.079</span></span>  <span class="hljs-number"><span class="hljs-number">3.693</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">4</span></span>(exp)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.002</span></span>  <span class="hljs-number"><span class="hljs-number">0.002</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method _imp.create_dynamic}      <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.<span class="hljs-keyword"><span class="hljs-keyword">exec</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method __new__ of type object at <span class="hljs-number"><span class="hljs-number">0x9d12c0</span></span>}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">132</span></span>(__new__)       <span class="hljs-number"><span class="hljs-number">23</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> _weakrefset.py:<span class="hljs-number"><span class="hljs-number">36</span></span>(__init__)      <span class="hljs-number"><span class="hljs-number">245</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.getattr}        <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method marshal.loads}       <span class="hljs-number"><span class="hljs-number">10</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">1233</span></span>(find_spec)      <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> abc.py:<span class="hljs-number"><span class="hljs-number">196</span></span>(__subclasscheck__)       <span class="hljs-number"><span class="hljs-number">15</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method posix.stat}        <span class="hljs-number"><span class="hljs-number">6</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> {built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> method builtins.__build_class__}        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> __init__.py:<span class="hljs-number"><span class="hljs-number">357</span></span>(namedtuple)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">57</span></span>(_path_join)       <span class="hljs-number"><span class="hljs-number">48</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> &lt;frozen importlib._bootstrap_external&gt;:<span class="hljs-number"><span class="hljs-number">59</span></span>(&lt;listcomp&gt;)        <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span>  <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">11.081</span></span>  <span class="hljs-number"><span class="hljs-number">11.081</span></span> slow_program.py:<span class="hljs-number"><span class="hljs-number">1</span></span>(&lt;module&gt;)</code> </pre> <br>  Aquí ejecutamos el script investigado usando el módulo <code>cProfile</code> y usamos el argumento <code>time</code> .  Como resultado, las líneas de salida se ordenan por tiempo interno ( <code>cumtime</code> ).  Nos da mucha información.  De hecho, lo que se muestra arriba es solo alrededor del 10% de la producción de <code>cProfile</code> . <br><br>  Después de analizar estos datos, podemos ver que la función <code>exp</code> es la razón del lento funcionamiento del programa (¡eso es una sorpresa!).  Después de eso, podemos hacer perfiles de código utilizando herramientas más precisas. <br><br><h2>  <font color="#3AC1EF">El estudio de los indicadores temporales de desempeño de una función específica.</font> </h2><br>  Ahora sabemos sobre el lugar del programa donde necesitamos dirigir nuestra atención.  Por lo tanto, podemos decidir estudiar la función lenta sin perfilar otro código de programa.  Para hacer esto, puede usar un decorador simple: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeit_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span>    @wraps(func)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        start = time.perf_counter() <span class="hljs-comment"><span class="hljs-comment">#       time.process_time()        func_return_val = func(*args, **kwargs)        end = time.perf_counter()        print('{0:&lt;10}.{1:&lt;8} : {2:&lt;8}'.format(func.__module__, func.__name__, end - start))        return func_return_val    return wrapper</span></span></code> </pre> <br>  Este decorador se puede aplicar a la función a explorar: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@timeit_wrapper def exp(x):    ... print('{0:&lt;10} {1:&lt;8} {2:^8}'.format('module', 'function', 'time')) exp(Decimal(150)) exp(Decimal(400)) exp(Decimal(3000))</span></span></code> </pre> <br>  Ahora, después de comenzar el programa, recibiremos la siguiente información: <br><br><pre> <code class="python hljs">~ $ python3<span class="hljs-number"><span class="hljs-number">.8</span></span> slow_program.py module   function time __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.003267502994276583</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">0.038535295985639095</span></span> __main__ .exp : <span class="hljs-number"><span class="hljs-number">11.728486061969306</span></span></code> </pre> <br>  Aquí vale la pena prestar atención a exactamente a qué hora planeamos medir.  El paquete correspondiente nos proporciona indicadores como <code>time.perf_counter</code> y <code>time.process_time</code> .  La diferencia entre ellos es que <code>perf_counter</code> devuelve un valor absoluto, que incluye el tiempo durante el cual el proceso del programa Python no se está ejecutando.  Esto significa que este indicador puede verse afectado por la carga en la computadora creada por otros programas.  La <code>process_time</code> solo devuelve el tiempo del usuario.  No incluye la hora del sistema.  Esto solo nos brinda información sobre el tiempo de ejecución de nuestro proceso. <br><br><h2>  <font color="#3AC1EF">Aceleración de código</font> </h2><br>  Y ahora para la parte divertida.  Trabajemos para acelerar el programa.  No voy a mostrar (en su mayor parte) todo tipo de trucos, trucos y misteriosos códigos aquí que resuelven mágicamente los problemas de rendimiento.  Básicamente quiero hablar sobre ideas y estrategias comunes que, si se usan, pueden tener un gran impacto en el rendimiento.  En algunos casos, estamos hablando de un aumento del 30% en la velocidad de ejecución del código. <br><br><h3>  <font color="#3AC1EF">▍Utilice los tipos de datos incorporados</font> </h3><br>  El uso de tipos de datos integrados es un enfoque muy obvio para acelerar el código.  Los tipos de datos integrados son extremadamente rápidos, especialmente si los compara con tipos personalizados como árboles o listas vinculadas.  El punto aquí es principalmente que los mecanismos integrados del lenguaje se implementan usando C. Si describe algo usando Python, no puede lograr el mismo nivel de rendimiento. <br><br><h3>  <font color="#3AC1EF">▍Aplicar almacenamiento en caché (memorización) con lru_cache</font> </h3><br>  El almacenamiento en caché es un enfoque popular para mejorar el rendimiento del código.  Ya <a href="https://martinheinz.dev/blog/4">escribí</a> sobre él, pero creo que vale la pena contarlo sobre él aquí: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-comment"><span class="hljs-comment">#   12   @functools.lru_cache(maxsize=12) def slow_func(x):    time.sleep(2) #       return x slow_func(1) # ...  2     slow_func(1) #    -   ! slow_func(3) # ...   2    </span></span></code> </pre> <br>  La función anterior simula cálculos complejos utilizando <code>time.sleep</code> .  Cuando se llama por primera vez con el parámetro <code>1</code> , espera 2 segundos y devuelve el resultado solo después de eso.  Cuando vuelve a llamarla con el mismo parámetro, resulta que el resultado de su trabajo ya está almacenado en caché.  El cuerpo de la función en esta situación no se ejecuta y el resultado se devuelve inmediatamente.  <a href="https://martinheinz.dev/blog/4">Aquí</a> puede encontrar ejemplos de almacenamiento en caché más cercanos a la realidad. <br><br><h3>  <font color="#3AC1EF">▍Utilizar variables locales</font> </h3><br>  Aplicando variables locales, tenemos en cuenta la velocidad de búsqueda de una variable en cada ámbito.  Estoy hablando específicamente de "todas las áreas de visibilidad", ya que aquí tengo en mente no solo una comparación de la velocidad del trabajo con variables locales y globales.  De hecho, la diferencia en el trabajo con variables incluso se observa, por ejemplo, entre variables locales en una función (la velocidad más alta), atributos de nivel de clase (por ejemplo, <code>self.name</code> , esto ya es más lento) y entidades globales importadas como <code>time.time</code> (la mayoría lento de estos tres mecanismos). <br><br>  Puede mejorar el rendimiento utilizando los siguientes enfoques para asignar valores que pueden parecer completamente innecesarios e inútiles para una persona desinformada: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  #1 class FastClass:    def do_stuff(self):        temp = self.value #           for i in range(10000):            ... #      `temp` #  #2 import random def fast_function():    r = random.random    for i in range(10000):        print(r()) #   `r()` ,     random.random()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Código de ajuste en función</font> </h3><br>  Este consejo puede parecer contrario al sentido común, ya que cuando se llama a una función, algunos datos se envían a la pila y el sistema está bajo carga adicional procesando la operación de retorno de la función.  Sin embargo, esta recomendación está relacionada con la anterior.  Si solo coloca todo su código en un archivo sin escribirlo como una función, se ejecutará mucho más lento debido al uso de variables globales.  Esto significa que el código se puede acelerar simplemente envolviéndolo en la función <code>main()</code> y llamándolo una vez: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>    ... <span class="hljs-comment"><span class="hljs-comment">#  ,     main()</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍No acceda a los atributos</font> </h3><br>  Otro mecanismo que puede ralentizar un programa es el operador punto ( <code>.</code> ), Que se utiliza para acceder a los atributos de los objetos.  Esta declaración invoca una <code>__getattribute__</code> diccionario usando <code>__getattribute__</code> , lo que <code>__getattribute__</code> un esfuerzo adicional en el sistema.  ¿Cómo limitar el impacto en el rendimiento de esta función de Python? <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># : import re def slow_func():    for i in range(10000):        re.findall(regex, line) # ! # : from re import findall def fast_func():    for i in range(10000):        findall(regex, line) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Cuidado con las cuerdas</font> </h3><br>  Las operaciones de cadena pueden ralentizar enormemente un programa si se ejecutan en bucles.  En particular, estamos hablando de formatear cadenas usando <code>%s</code> <code>.format()</code> .  ¿Es posible reemplazarlos con algo?  Si observa un <a href="https://twitter.com/raymondh/status/1205969258800275456">tweet</a> reciente <a href="https://twitter.com/raymondh/status/1205969258800275456">de</a> Raymond Hettinger, puede ver que el único mecanismo que debe usarse en tales situaciones son las líneas f.  Este es el método de formateo de cadenas más legible, conciso y rápido.  Aquí, de acuerdo con ese tweet, hay una lista de métodos que se pueden usar para trabajar con cadenas, desde el más rápido hasta el más lento: <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{s}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{t}</span></span></span><span class="hljs-string">'</span></span> <span class="hljs-comment"><span class="hljs-comment"># ! s + ' ' + t ' '.join((s, t)) '%s %s' % (s, t) '{} {}'.format(s, t) Template('$s $t').substitute(s=s, t=t) # !</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Sepa que los generadores también pueden funcionar rápido</font> </h3><br>  Los generadores no son aquellos mecanismos que, por su naturaleza, son rápidos.  El hecho es que fueron creados para realizar cálculos "perezosos", lo que no ahorra tiempo, sino memoria.  Sin embargo, ahorrar memoria puede hacer que los programas se ejecuten más rápido.  ¿Cómo es esto posible?  El hecho es que al procesar un gran conjunto de datos sin usar generadores (iteradores), los datos pueden provocar un desbordamiento de la caché L1 del procesador, lo que ralentizará significativamente el proceso de búsqueda de valores en la memoria. <br><br>  Cuando se trata del rendimiento, es muy importante esforzarse por garantizar que el procesador pueda acceder rápidamente a los datos que procesa, de modo que estén lo más cerca posible de ellos.  Y esto significa que dichos datos deben colocarse en la memoria caché del procesador.  Este problema se aborda en <a href="https://www.youtube.com/watch%3Fv%3DOSGv2VnC0go%26t%3D8m17s">esta</a> presentación de Raymond Hettinger. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  La primera regla de optimización es que la optimización no es necesaria.  Pero si no puede prescindir de la optimización, espero que los consejos que he compartido le ayuden con esto. <br><br>  <b>Estimados lectores!</b>  ¿Cómo aborda la optimización del rendimiento de su código Python? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/483678/">https://habr.com/ru/post/483678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483666/index.html">Sobre Volodia y el ozonizador</a></li>
<li><a href="../483668/index.html">El resumen de materiales frescos del mundo del front-end para la última semana No. 397 (6 al 12 de enero de 2020)</a></li>
<li><a href="../483670/index.html">Todo lo que querías saber sobre la dirección MAC</a></li>
<li><a href="../483674/index.html">Cómo funcionan las redes neuronales binarias y por qué serán populares en 2020</a></li>
<li><a href="../483676/index.html">Evaluación de la efectividad y el costo de implementar un sistema de análisis de marketing de extremo a extremo</a></li>
<li><a href="../483680/index.html">Errores de programación comunes para evitar</a></li>
<li><a href="../483682/index.html">Agrupación y rendimiento de JavaScript: mejores prácticas</a></li>
<li><a href="../483684/index.html">PHP Digest No. 171 (1 al 13 de enero de 2020)</a></li>
<li><a href="../483686/index.html">32 consejos para un desarrollador web que quiere crecer por encima de sí mismo en 2020</a></li>
<li><a href="../483688/index.html">Aproximadamente 30x Concurrency Boost en Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>