<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏾 🍌 👨🏽‍⚖️ Investigasi satu arsip yang tidak diketahui 🚭 😻 👩🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Relokasi. Kota baru. Pencarian pekerjaan. Bahkan untuk seorang profesional TI, ini bisa memakan waktu lama. Serangkaian wawancara, yang pada umumnya s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Investigasi satu arsip yang tidak diketahui</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450394/">  Relokasi.  Kota baru.  Pencarian pekerjaan.  Bahkan untuk seorang profesional TI, ini bisa memakan waktu lama.  Serangkaian wawancara, yang pada umumnya sangat mirip satu sama lain.  Dan seperti yang biasanya terjadi ketika Anda sudah menemukan pekerjaan, setelah beberapa saat, satu kantor yang menarik diumumkan. <br><br>  Sulit untuk memahami apa yang dia lakukan secara spesifik, namun, bidang minatnya adalah mempelajari perangkat lunak orang lain.  Kedengarannya menarik, meskipun ketika Anda menyadari bahwa ini tampaknya bukan vendor yang merilis perangkat lunak untuk keamanan siber, Anda berhenti sejenak dan mulai menggaruk lobak Anda. <br><br><img src="https://lh3.googleusercontent.com/Wm2cSc19nc9XsapzlEW-eGMZBZCEgSbZFCSj6hdNNlkqCa40ksCXrYv8ual-VfYF3rcn5OoM9X2OwIJY07u_dD5Lo_7mzZU4D7rQuu164GIDE2_IjBu_J1dIMsjD4uDgyep3yipN"><br><a name="habracut"></a><br>  Singkatnya: mereka membuang arsip dan menawarkan untuk memeriksanya sebagai tugas uji dan mencoba menghitung tanda tangan tertentu berdasarkan data input yang disajikan.  Perlu dicatat bahwa saya memiliki sedikit pengalaman dalam kegiatan seperti itu dan, mungkin, itulah sebabnya pada iterasi pertama dari solusi saya hanya punya beberapa jam - maka motivasi untuk melakukan ini menjadi sia-sia.  Dan ya, tentu saja, hal pertama yang saya coba jalankan di ponsel / emulator - aplikasi ini tidak valid. <br><br>  <b>Apa yang kita miliki:</b> arsip dengan ekstensi <b>".apk"</b> .  Saya menempatkan tugas itu sendiri di bawah spoiler sehingga tidak diindeks oleh mesin pencari: bagaimana jika orang-orang tidak menyukainya, sehingga saya memberikan solusinya pada Habr? <br><br><div class="spoiler">  <b class="spoiler_title">Tugas itu sendiri</b> <div class="spoiler_text">  APK berisi fungsionalitas untuk menghasilkan tanda tangan untuk array asosiatif. <br>  Cobalah untuk mendapatkan tanda tangan untuk kumpulan data berikut: <br><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"user"</span></span> : <span class="hljs-string"><span class="hljs-string">"LeetD3vM4st3R"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"password"</span></span>: <span class="hljs-string"><span class="hljs-string">"__s33cr$$tV4lu3__"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"34765983265937875692356935636464"</span></span> }</code> </pre> <br></div></div><br><h2>  Gulung lengan baju </h2><br>  Dikatakan bahwa arsip berisi fungsi menandatangani array asosiatif.  Dengan ekstensi file, kami segera memahami bahwa kami berurusan dengan aplikasi yang ditulis untuk Android.  Pertama kita membongkar arsip.  Faktanya, ini adalah arsip ZIP biasa, dan pengarsip apa pun akan mengatasinya dengan ringan.  Saya menggunakan utilitas apktool, dan, ternyata, secara tidak sengaja melewati beberapa garu.  Ya, itu terjadi (biasanya sebaliknya, ya?).  Mantranya cukup sederhana: <br><br><pre> <code class="bash hljs">apktool d task.zip</code> </pre> <br>  Ternyata kode dan sumber daya dalam file apk juga disimpan dalam paket biner yang terpisah, dan perangkat lunak lain akan diperlukan untuk mengekstraknya.  Apktool secara implisit menarik byte kelas, sumber daya, dan mendekomposisikan semuanya ke dalam hierarki file alami.  Anda bisa melanjutkan. <br><br><pre> <code class="bash hljs">├── AndroidManifest.xml ├── apktool.yml ├── lib │   └── arm64-v8a ├── original │   ├── AndroidManifest.xml │   └── META-INF ├── res │   ├── anim │   ├── color │   ├── drawable │   ├── layout │   ├── layout-watch-v20 │   ├── mipmap-anydpi-v26 │   ├── values │   └── values-af ├── smali │   ├── android │   ├── butterknife │   ├── com │   ├── net │   └── org └── unknown   └── org</code> </pre> <br>  Kami melihat hierarki yang sama (dibiarkan versi yang disederhanakan) dan mencoba mencari tahu dari mana harus memulai.  Perlu dicatat bahwa saya masih pernah menulis beberapa aplikasi kecil untuk Android, jadi esensi dari bagian direktori dan, secara umum, prinsip-prinsip perangkat aplikasi Android, saya cukup jelas. <br><br>  Untuk mulai dengan, saya memutuskan untuk hanya "berjalan" melalui file.  Saya membuka AndroidManifest.xml dan mulai membaca dengan penuh arti.  Perhatian saya tertarik oleh atribut yang aneh <br><br><pre> <code class="xml hljs">android:supportsRtl="true"</code> </pre> <br>  Ternyata dia bertanggung jawab untuk mendukung bahasa dengan huruf "kanan-ke-kiri" dalam aplikasi.  Kami mulai tegang.  Tidak bagus <br><br>  Selanjutnya, tatapanku menempel ke folder yang tidak diketahui.  Di bawahnya ada hierarki formulir: <b>org.apache.commons.codec.language.bm</b> dan sejumlah besar file teks dengan konten yang tidak jelas.  Google nama lengkap paket dan ternyata apa yang disimpan di sini, sesuatu yang berkaitan dengan algoritma pencarian untuk kata-kata yang secara fonetis mirip dengan yang diberikan.  Terus terang, di sini saya mulai berusaha lebih keras.  Setelah melihat-lihat direktori sedikit, saya benar-benar menemukan kode itu sendiri, dan kemudian kesenangan dimulai.  Saya bertemu bukan dengan bytecode Java yang biasa, dengan yang saya pernah berhasil bermain-main, tetapi sesuatu yang lain.  Sangat mirip, tetapi berbeda. <br><br>  Ternyata, Android memiliki mesin virtual sendiri - Dalvik.  Dan, seperti setiap mesin virtual yang dihormati, ia memiliki bytecode sendiri.  Tampaknya pada upaya pertama untuk menyelesaikan masalah ini, pada catatan sedih ini saya mengumumkan jeda, membungkuk, menjatuhkan tirai dan melemparkan semuanya selama 4 bulan sampai rasa ingin tahu saya benar-benar menyelesaikan saya. <br><br><h2>  Gulung lengan baju [2] </h2><br>  "Tapi tidak bisakah semuanya jadi lebih mudah?"  - Ini adalah pertanyaan yang saya tanyakan pada diri saya ketika saya memulai tugas untuk kedua kalinya.  Saya mulai mencari decompiler dari smali ke Jawa di internet.  Saya hanya melihat bahwa tidak mungkin untuk melakukan proses ini dengan jelas.  Mengernyit sedikit, dia pergi ke Github dan menggerakkan beberapa frasa kunci ke dalam garis pencarian.  Yang pertama datang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">smali2java</a> . <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> gradle build java -jar smali2java.jar ..</code> </pre> <br>  Kesalahan  Saya melihat banyak jejak stack dan kesalahan pada beberapa halaman terminal.  Setelah membaca sedikit tentang esensi konten (dan menahan emosi dari ukuran jejak tumpukan), saya menemukan bahwa alat ini bekerja berdasarkan tata bahasa tertentu yang dijelaskan dan kode kunci yang dia temui jelas tidak sesuai dengannya.  Saya membuka bytecode smali dan melihat anotasi, metode sintetik dan konstruksi aneh lainnya di dalamnya.  Tidak ada hal seperti itu di bytecode Java!  Berapa lama  Hapus! <br><br><div class="spoiler">  <b class="spoiler_title">Lebih detail</b> <div class="spoiler_text">  Mesin virtual Dalvik (dan juga JVM), ternyata, tidak menyadari keberadaan konsep seperti kelas dalam / luar (baca kelas bersarang), dan kompiler menghasilkan apa yang disebut metode "sintetis" untuk menyediakan akses dari kelas bersarang ke bidang eksternal, misalnya. <br><br><h4>  Sebagai contoh: </h4><br>  Jika kelas luar (OuterClass) memiliki bidang <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OuterClass</span></span></span><span class="hljs-class"> </span></span>{ List a; ... }</code> </pre> <br>  Agar kelas privat dapat mengakses bidang kelas eksternal, kompiler secara implisit akan menghasilkan metode berikut: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> synthetic java.util.<span class="hljs-function"><span class="hljs-function">List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OuterClass p1)</span></span></span><span class="hljs-function"> </span></span>{ p1 = p1.a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }</code> </pre> <br>  Juga, karena dapur "kompartemen engine" seperti itu, pekerjaan beberapa mekanisme lain yang disediakan bahasa tercapai. <br><br>  Anda dapat mulai mempelajari pertanyaan ini secara lebih rinci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> . </div></div><br>  Tidak membantu  Dia bahkan bersumpah pada bytecode yang tampaknya tidak mencurigakan.  Saya membuka kode sumber decompiler, membaca dan melihat sesuatu yang sangat aneh: bahkan programmer Hindu (dengan segala hormat) tidak akan menulis ini.  Sebuah pemikiran merayap masuk: bukan kode yang dihasilkan.  Saya menolak ide itu selama sekitar 30 menit, mencoba memahami apa kesalahannya.  KOMPLIKASI.  Saya membuka Github lagi - dan benar-benar, parser yang dihasilkan oleh tata bahasa.  Dan ini generatornya sendiri.  Menyingkirkan semuanya dan mencoba mendekati dari sisi lain. <br><br>  <i>Perlu dicatat bahwa sedikit kemudian saya masih mencoba mengubah tata bahasa dan di tempat-tempat bahkan bytecode itu sendiri sehingga decompiler masih bisa mencernanya.</i>  <i>Tetapi bahkan ketika bytecode menjadi valid dalam hal tata bahasa dekompiler, program tersebut tidak mengembalikan apa pun kepada saya.</i>  <i>Sumber terbuka ...</i> <br><br>  Saya membuka bytecode dan menemukan konstanta yang tidak saya kenal.  Googling, saya menemukan hal yang sama dalam buku tentang aplikasi Android terbalik.  Saya ingat bahwa ini hanya ID yang diberikan oleh preprosesor kompiler, yang ditugaskan ke sumber daya aplikasi Android (konstanta waktu penulisan kode adalah R. *).  Setengah jam berikutnya - jam, saya akan secara singkat memeriksa register mana yang bertanggung jawab untuk apa, dalam urutan apa argumen dilewatkan, dan umumnya mempelajari sintaksis. <br><br><h2>  Seperti apa bentuknya? </h2><br><img src="https://lh4.googleusercontent.com/6vy-LnmhLmjl2TnDiAoA632c026jlrPG7zFlclZNXJRdpethXv_iFjRtzwyvQWrqkd1LUKixzHfzXAyDj4c28JAzqVYTmP9uqJTmUYgjJd8Yx5pEDkd0cad34bNg9LYDf3r2jFVj" width="350" height="496" align="left">  Saya menemukan tata letak jendela aplikasi utama, dan dari situ saya sudah mengerti apa yang sedang terjadi dalam aplikasi: pada layar utama (Aktivitas) ada RecyclerView (syarat, sebuah tampilan yang dapat menggunakan kembali objek UI yang saat ini tidak ditampilkan untuk penggunaan memori) dengan bidang input pasangan kunci / nilai, sepasang tombol yang bertanggung jawab untuk menambahkan pasangan kunci / nilai baru ke wadah abstrak tertentu, dan tombol yang menghasilkan tanda tangan (tanda tangan) untuk wadah ini. <br><br>  Melihat anotasi dan mengamati sejumlah kode yang mencurigakan mirip dengan yang dihasilkan, saya mulai mencari di google.  Proyek ini menggunakan perpustakaan ButterKnife, yang memungkinkan penggunaan anotasi untuk <b>mengembang () -&gt; mengikat ()</b> elemen UI secara otomatis.  Jika ada anotasi di kelas, prosesor anotasi ButterKnife secara implisit membuat kelas pengikat lain dari bentuk <b>&lt;original_class&gt; __ViewBinding</b> , yang melakukan semua pekerjaan kotor di bawah tenda.  Sebenarnya, saya mendapatkan semua informasi ini hanya dari satu file MainActivity setelah saya secara manual menciptakan kembali kemiripan sumber Java dari itu.  Setelah setengah jam, saya menyadari bahwa anotasi pustaka ini juga dapat mengatur panggilan balik pada tindakan tombol dan menemukan fungsi-fungsi kunci yang sebenarnya bertanggung jawab untuk menambahkan pasangan kunci / nilai ke wadah dan menghasilkan tanda tangan. <br><br>  <i>Tentu saja, selama studi, saya harus masuk ke "jeroan ayam itik" dari berbagai perpustakaan dan plug-in, karena bahkan lando yang indah dengan cookie tidak mencakup semua kasus penggunaan dan detail, yang untuk setiap "pembalikan", saya pikir, adalah praktik umum.</i> <br><br><h2>  Laziness adalah teman seorang programmer </h2><br>  Setelah menghabiskan lebih banyak waktu pada sumber kedua, saya benar-benar lelah dan menyadari bahwa tidak mungkin memasak bubur.  Saya mendaki Github lagi, dan kali ini saya melihat lebih dekat.  Saya menemukan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Smali2PsuedoJava</a> - dekompiler dalam "pseudo-Java code".  Bahkan jika utilitas ini, setidaknya sesuatu dapat menyebabkan penampilan manusia, maka bagi saya penulis adalah cangkir bir favoritnya (baik, atau setidaknya beri tanda bintang pada Github, sebagai permulaan). <br><br>  Dan itu benar-benar berfungsi!  Efek pada wajah: <br><br><img src="https://lh6.googleusercontent.com/4yxBPy1Wt7_J7uLey66rp_qHwomfvAW_B1C6g3CsrS0DR73J_U42t4JgobNaGIUXVstTEVIaHriawFfRVZL4IqUEObjCL8RdLUv5VCGKiv_jeAxBclaXZlsMvmFUzFuuuuxfshw7"><br><br><h2>  Temui Cipher.so </h2><br>  Beberapa saat kemudian, mempelajari Java pseudo-code dari proyek dan dengan ragu membandingkannya dengan bytecode smali, saya menemukan perpustakaan aneh dalam kode - Cipher.so.  Googling, saya menemukan bahwa itu adalah enkripsi dari satu set nilai waktu kompilasi di dalam arsip APK.  Ini biasanya diperlukan ketika aplikasi menggunakan konstanta bentuk: alamat IP, kredensial untuk database eksternal, token untuk otorisasi, dll.  - apa yang bisa diperoleh dengan bantuan rekayasa balik aplikasi.  Benar, penulis dengan jelas menulis bahwa proyek ini ditinggalkan, kata mereka, pergi.  Ini semakin menarik. <br><br>  Perpustakaan ini menyediakan akses ke nilai-nilai melalui perpustakaan Java, di mana metode spesifik adalah kunci yang menarik bagi kami.  Itu hanya memicu minat saya, dan saya mulai memanjat lebih dalam. <br><br>  Singkatnya, apa yang dilakukan Cipher.so dan bagaimana cara kerjanya: <br><br><ul><li>  dalam file Gradle proyek kami kunci dan nilai-nilai yang sesuai terdaftar <br></li><li>  semua nilai kunci akan secara otomatis dimasukkan ke perpustakaan dinamis yang terpisah (.so), yang akan dihasilkan pada waktu kompilasi.  Ya - ya, AKAN dihasilkan. <br></li><li>  maka kunci ini dapat diperoleh dari metode Java yang dihasilkan oleh Cipher.so <br></li><li>  setelah membuat APK, nama-nama kunci di-hash oleh MD5 (untuk keamanan yang lebih besar, tentu saja) <br></li></ul><br>  Setelah menemukan perpustakaan dinamis yang saya butuhkan di folder arsip, saya melanjutkan untuk mengambilnya.  Pertama-tama, sebagai pembalikan yang berpengalaman (tidak), saya mencoba memulai dengan yang sederhana - saya memutuskan untuk melihat bagian dengan konstanta dan untuk garis-garis menarik dalam binar seperti ELF.  Sayangnya, pengguna mac yang siap keluar dari kotak tidak ada, dan sebelum awal kami mengucapkan yang berharga: <br><br><pre> <code class="bash hljs">brew install binuitls</code> </pre> <br>  Dan jangan lupa untuk menulis path ke <b>/ usr / local</b> di PATH, karena <i>minuman</i> melindungi Anda dari segala sesuatu dengan cara yang sopan ... <br><br><pre> <code class="bash hljs">greadelf -p .rodata lib/arm64-v8a/libcipher-lib.so | head -n 15</code> </pre> <br>  Kami membatasi output ke 15 jalur pertama, jika tidak, hal ini dapat menyebabkan kejutan bagi insinyur yang tidak siap. <br><br><img src="https://lh6.googleusercontent.com/-ka6awAjaQ6zTDJ4sogEHaqBEG2QL3il5HTS1M-HchKGBg4hK5qe__lAtEKtcL7CT0i_lhqtiEZYYRsnTpLmbc10hdpVTMcAeRP0bGJE87jUBvtkncNMJ3s5YtjgGXk0duZeHIrY"><br><br>  Di alamat yang lebih rendah kami melihat garis yang mencurigakan.  Seperti yang saya ketahui, mempelajari sumber-sumber Cipher.so, kunci dan nilai-nilai diletakkan di <b>std :: map biasa:</b> ini memberikan sedikit informasi, tetapi kita tahu bahwa di binar itu sendiri, bersama dengan kata sandi terenkripsi, ada juga kunci yang dikaburkan. <br><br>  Bagaimana enkripsi nilai?  Mempelajari sumbernya, saya menemukan bahwa enkripsi terjadi menggunakan AES - sistem enkripsi simetris standar.  Jadi, jika ada nilai-nilai terenkripsi, maka kuncinya harus dekat ... Setelah mempelajarinya untuk sementara waktu, saya menemukan masalah dalam proyek yang sama dengan judul provokatif <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Penyimpanan kunci tidak aman: rahasia sangat mudah untuk retreive"</a> .  Di dalamnya, pada kenyataannya, saya menemukan bahwa kunci disimpan dalam bentuk yang jelas di binar, dan menemukan algoritma dekripsi.  Pada contoh, kuncinya ada di alamat nol, dan meskipun saya mengerti bahwa kompiler dapat meletakkannya di tempat lain di bagian .rodata dari file biner, saya memutuskan bahwa unit mencurigakan di alamat nol adalah kuncinya. <br><br>  <b>Percobaan # 1: Saya</b> melanjutkan untuk menguraikan nilai-nilai dan percaya bahwa kunci enkripsi adalah sama.  Kesalahannya.  OpenSSL mengisyaratkan bahwa ada sesuatu yang tidak beres.  Setelah membaca sumber-sumber Cipher.so sedikit, saya mengerti bahwa jika pengguna tidak menentukan kunci selama perakitan, maka kunci default digunakan - <i>Cipher.so@DEFAULT</i> . <br><br>  <b>Percobaan # 2:</b> Kesalahan lagi.  Hmm ... Apakah ini benar-benar didefinisikan ulang oleh konstanta ini?  Cukup mudah untuk membuat kesalahan: kode membingungkan ditulis dalam Gradle, dengan pemformatan "hilang".  Saya periksa lagi.  Segalanya tampak begitu. <br><br>  Alih-alih kuncinya adalah hash MD5 mereka, dan kemudian saya mencoba untuk mencoba keberuntungan saya dan membuka layanan dengan tabel pelangi.  Voila - salah satu kunci adalah kata "kata sandi".  Tidak ada detik.  Itu memberi kita, tentu saja, tidak banyak.  Kedua kunci ini masing-masing berada di alamat 240 dan 2a2.  Pada prinsipnya, mengenali mereka segera itu mudah - 32 karakter (MD5). <br><br>  Saya memeriksa semuanya lagi dan mencoba melakukan dekripsi dengan semua baris lain (yang ada di alamat yang lebih rendah) sebagai kunci untuk dekripsi - semuanya sia-sia. <br>  Jadi, ada beberapa kunci rahasia lainnya, algoritma tindakan tampaknya benar.  Saya mengabaikan tugas ini dan berusaha untuk tidak mengubur diri saya sendiri. <br><br>  Setelah mencari-cari sedikit dalam algoritma tanda tangan kontainer, saya masih melihat panggilan ke perpustakaan Cipher.so dan kode yang juga menggunakan fungsi kriptografi dari perpustakaan Java. <br><br><h2>  Sebuah teka-teki (yang tidak pernah saya pecahkan) </h2><br>  Dalam fungsi yang bertanggung jawab untuk enkripsi, di bagian paling awal ada pemeriksaan untuk kunci dalam wadah. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] a(java/util/Map p1) { v0 = p1.size() v1 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 != <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_0 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; :cond_0 v0 = <span class="hljs-string"><span class="hljs-string">"user"</span></span>; v0 = p1.containsKey(v0) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v0 == <span class="hljs-number"><span class="hljs-number">0</span></span>) goto :cond_1 p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[v1]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; ...</code> </pre><br>  Secara harfiah: jika ada kunci "pengguna", maka wadah ini tidak ditandatangani (tanda tangan nol dikembalikan).  Perasaan aneh: sepertinya masalahnya sudah terpecahkan, tetapi entah bagaimana tampaknya sederhana dan mencurigakan.  Lalu mengapa menciptakan yang lainnya?  Untuk menyesatkan?  Lalu mengapa saya belum mempelajari kode ini dengan lancar sebelumnya?  Hmm ... <br><br>  Tidak, tidak benar.  Saya menentukan jawaban dari pengguna tertentu dengan messenger biru, yang kontaknya saya berikan ketika memberikan tugas.  Menggali lebih jauh.  Mungkin kunci input / nilai yang disetel entah bagaimana berubah karena ditambahkan ke wadah?  Saya membaca kode dengan cermat. <br><br>  Harap dicatat bahwa decompiler menghapus anotasi dari kode smali.  Bagaimana jika dia menghapus sesuatu yang penting?  Saya memeriksa file utama - sepertinya, tidak ada yang signifikan.  Segala sesuatu yang penting sudah ada, tetapi artinya tidak hilang.  Saya memeriksa fungsi panggilan balik yang bertanggung jawab untuk menulis pasangan kunci / nilai dari TextBox bersyarat ke wadah internal.  Saya tidak menemukan sesuatu yang kriminal. <br><br>  Saya menjadi skeptis mungkin tentang setiap baris kode - saya tidak bisa lagi mempercayai siapa pun. <br><br>  Solusi sederhana # 2: Saya perhatikan bahwa prosedur penandatanganan dimulai dengan memeriksa keberadaan beberapa nilai (substring dalam string) dalam tanda tangan sertifikat dengan mana aplikasi ditandatangani. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@OnClick</span></span> <span class="hljs-comment"><span class="hljs-comment">//   protected void huvot324yo873yvo837yvo() { String signature = "no data"; boolean result = some_packages.isKeyInSignature(this); if result { Map map = new HashMap(); ...</span></span></code> </pre> <br>  Makna itu sendiri, tentu saja, terenkripsi dalam binar bernasib buruk itu.  Dan sebenarnya, jika nilai ini tidak ada di tanda tangan, maka algoritme tidak akan menandatangani apa pun, tetapi cukup mengembalikan string "tidak ada data", sebagai tanda tangan ... Sekali lagi, kita dibawa ke Cipher ... <br><br><h2>  Dekripsi kunci pertarungan terakhir </h2><br>  Untuk memahami skala tragedi itu, saya menjadi bingung seperti ini: <br><br>  Saya membuat dump hex bagian ini dan mengintip ke dalam dua baris pertama, kecurigaan yang tidak surut dari awal. <br><br><img src="https://lh4.googleusercontent.com/J4lmChj6kk0lWWy23D8QngSgnJlNfd-xDP1XyBnw1wyQ_U1NBRLYyx2BFZ4y9D1HXEjcSeCKVvZC3xgVCpx-VSV0bIHD5dcmsfdaX4jrmH-uRFsRMc9VJrqpUEMDEEaijeSTPRbk"><br><br>  Jika Anda memperhatikan, karakter yang memisahkan garis-garis di sini adalah '0x00'.  Ini juga biasa digunakan oleh pustaka C standar, dalam fungsi string.  Dari hal itu tidak kalah menarik, karakter ruang seperti apa yang ada di tengah baris pertama?  Selanjutnya, upaya gila dimulai, di mana kuncinya adalah: <br><br><ul><li>  seluruh baris pertama <br></li><li>  baris pertama sebelum ruang <br></li><li>  baris pertama dari luar angkasa sampai akhir <br></li><li>  ... <br></li></ul><br>  Tingkat paranoia sudah bisa diperkirakan.  Ketika Anda tidak mengerti betapa sulit dan liciknya tugas itu, maka Anda mulai mengemudi.  Namun, bukan itu.  Kemudian muncul pikiran di benak saya: "Apakah algoritma bekerja dengan benar dari masalah pada mesin saya?".  Secara umum, urutan tindakan ada logis dan tidak menimbulkan pertanyaan, tetapi pertanyaannya adalah: apakah perintah pada mesin saya melakukan apa yang diminta dari mereka?  Jadi bagaimana menurutmu? <br><br>  Setelah memeriksa semua langkah secara manual, ternyata itu <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"some_base64_input"</span></span> | openssl base64 -d</code> </pre> <br>  pada beberapa argumen input tiba-tiba mengembalikan string kosong.  Hmm. <br><br>  Menggantinya dengan decoder base64 pertama pada mesin, dan memilah-milah kandidat utama, kunci yang cocok segera ditemukan, dan kunci didekripsi sesuai. <br><br><h2>  Mengambil Tanda Tangan dari Sertifikat </h2><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isKeyInSignature</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(android.content.Context p1)</span></span></span><span class="hljs-function"> </span></span>{ v0 = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> TRY_0{ v1 = p1.getPackageManager() p0 = p1.getPackageName() v2 = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-comment"><span class="hljs-comment">// GET_SIGNATURES PackageInfo p0 = v1.getPackageInfo(p0, v2) android.content.pm.Signature[] p0 = p0.signatures; // Order are not guaranteed v1 = p0.length; v2 = 0x0; :goto_0 if (v2 &gt;= v1) goto :cond_1 v3 = p0[v2]; String v3 = v3.toCharsString() String v4 = net.idik.lib.cipher.so.CipherClient.a() v3 = v3.contains(v4) }TRY_0 catch TRY_0 (android/content/pm/PackageManager$NameNotFoundException) goto :catch_0; if (v3 == 0) goto :cond_0 p1 = 0x1; return p1; :cond_0 v2 = v2 + 0x1; goto :goto_0 :catch_0 p0 = Thrown Exception p1.printStackTrace() :cond_1 return v0; }</span></span></code> </pre> <br>  Ini adalah apa yang terlihat seperti pseudocode setelah suntingan kecil saya.  Membingungkan beberapa hal: <br><br><ul><li>  pengetahuan kriptografi yang buruk dan "dapur" sertifikat perangkat <br></li><li>  menurut dokumentasi, metode ini tidak menjamin urutan sertifikat dalam koleksi yang dikembalikan, dan karenanya, tidak mungkin untuk mengulang dalam urutan yang sama - bagaimana jika aplikasi ditandatangani dengan lebih dari satu sertifikat? <br></li><li>  kurangnya pengetahuan tentang cara mengekstrak sertifikat dari APK, mengingat bahwa tidak jelas apa yang dilakukan Android Runtime dalam kasus ini <br></li></ul><br>  Saya harus mempelajari semua masalah ini dan hasilnya adalah sebagai berikut: <br><br><ul><li>  sertifikat itu sendiri ada di direktori <i>asli / META-INF / CERT.RSA</i> <i><br></i> <br>  dalam direktori ini hanya ada satu file dengan ekstensi ini - yang berarti aplikasi tersebut ditandatangani hanya dengan satu sertifikat <br></li><li>  Di situs tentang rekayasa penelitian aplikasi Android, daftar ditemukan yang dapat mengekstrak tanda tangan yang kita butuhkan seperti Android.  Menurut penulis, setidaknya. <br></li></ul><br>  Dengan menjalankan kode ini, saya dapat mengetahui tanda tangan, dan pada kenyataannya, kuncinya adalah substring.  Silakan.  Solusi Sederhana # 2 sedang terhanyut. <br><br>  Memang, kuncinya ada di sertifikat, tetap hanya untuk memahami apa yang berikutnya, karena jika kita memiliki kunci "pengguna", kita semua juga mendapatkan tanda tangan nol, dan seperti yang kita pelajari di atas, ini adalah jawaban yang salah. <br><br><h2>  Tulis dokumentasi dengan cermat! </h2><br>  Penelitian lebih lanjut ke dalam fakta bahwa data yang dimasukkan dari bidang teks diubah dibuang karena kurangnya bukti.  Paranoia menggulung dengan kekuatan baru: mungkin kode yang menarik tanda tangan dari sertifikat tidak benar atau apakah ini merupakan implementasi kode untuk rilis Android lama?  Saya membuka dokumentasi lagi dan melihat yang berikut: ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://developer.android.com/reference/android/content/pm/Signature.html#toChars ()</a> ): <br><br><img src="https://lh5.googleusercontent.com/1TZ3rj6hzTEWw5YHEl1EWnANjsiqpzGR-tTrXP_Nc6jt42ANPf1QW-fmP-mh7Y2MhgMcZF0Z8CpskzT_ge65C0YCcryiWjjpG0UuPeqkUCsde1qcQgm5NbeqFj4KO3QkdtvHM3v2"><br><br>  <b>Catatan:</b> fungsi mengkodekan tanda tangan sebagai teks ASCII.  Output yang saya terima di atas adalah representasi hex data.  API ini tampak aneh bagi saya, tetapi jika Anda meyakini dokumentasinya, ternyata saya terhenti lagi, dan kunci terenkripsi bukan substring dari tanda tangan.  Setelah duduk dengan tenang pada kode untuk sementara waktu, saya tidak tahan dan membuka kode sumber untuk kelas ini.  <a href="">https://android.googlesource.com/platform/frameworks/base/+/e639da7/core/java/android/content/pm/Signature.java</a> <br><br>  Jawabannya tidak lama datang.  Dan sebenarnya, dalam kode itu sendiri - lukisan cat minyak: format output adalah hex-string biasa.  Dan sekarang pikirkan: apakah saya tidak mengerti sesuatu, atau dokumentasinya ditulis "sedikit" secara tidak benar.  Setelah dimarahi sama sekali, saya mulai bekerja lagi. <br><br><h2>  Ringkasan </h2><br>  N jam berikut telah berlalu: <br><br><ul><li>       RecyclerView        ..  ,           StackOverflow <br></li><li>    ,    ,   Java.    ,    -       («user»)     .       . <br></li></ul><br>  ,        (             ). <br><br>  Tidak. ,     .  ,    ,  ,       ,     .  .  —      ,     ,    ,  . <br><br>  ,       ,        .    .       ,           . , -   ,      ,      « »,    ,      . <br><br>  -    c        –      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">arturbrsg</a> . <br><br> Stay tuned. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450394/">https://habr.com/ru/post/id450394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450374/index.html">Papan Ekspansi RAM untuk Apple IIgs</a></li>
<li><a href="../id450376/index.html">Bagaimana Yandex.Taxi mencari mobil ketika tidak</a></li>
<li><a href="../id450378/index.html">GitLab 11.10</a></li>
<li><a href="../id450384/index.html">Kisah studi kode warisan kecil</a></li>
<li><a href="../id450386/index.html">Antarmuka sebagai tipe data abstrak di Go</a></li>
<li><a href="../id450396/index.html">Cara meningkatkan bahasa Inggris tertulis Anda: kiat praktis dan alat yang bermanfaat</a></li>
<li><a href="../id450398/index.html">Racun paling tak kenal takut</a></li>
<li><a href="../id450410/index.html">Terraformer - Infrastruktur Untuk Kode</a></li>
<li><a href="../id450416/index.html">Bagaimana penyedia VPN shareware menjual data Anda</a></li>
<li><a href="../id450418/index.html">Seni Membuat Model 3D Organik: Subdermal Shaders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>