<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßù üõ∂ üï∫üèª Struktur und schreibgesch√ºtzt: So vermeiden Sie Leistungseinbu√üen ü§æüèº üà≥ üé≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Verwendung des Strukturtyps und des schreibgesch√ºtzten Modifikators kann manchmal zu Leistungseinbu√üen f√ºhren. Heute werden wir dar√ºber sprechen, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Struktur und schreibgesch√ºtzt: So vermeiden Sie Leistungseinbu√üen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423053/">  Die Verwendung des Strukturtyps und des schreibgesch√ºtzten Modifikators kann manchmal zu Leistungseinbu√üen f√ºhren.  Heute werden wir dar√ºber sprechen, wie dies mit einem Open Source Code Analyzer - ErrorProne.NET - vermieden werden kann. <br><br><img src="https://habrastorage.org/webt/wc/aa/xn/wcaaxny16t6cvqvl2euetypst3o.jpeg"><a name="habracut"></a><br><br>  Wie Sie wahrscheinlich aus meinen fr√ºheren Ver√∂ffentlichungen wissen, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der 'in'-Modifikator und die schreibgesch√ºtzten Strukturen in C #</a> " ("Der Modifikator in und schreibgesch√ºtzte Strukturen in C #") und " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leistungsfallen von Ref-Einheimischen und Ref-R√ºckgaben in C #</a> " (" Leistungsfallen bei Verwendung lokaler Variablen und R√ºckgabewerte mit dem Modifikator ref)) ist das Arbeiten mit Strukturen schwieriger, als es den Anschein hat.  Abgesehen von der Frage der Ver√§nderlichkeit stelle ich fest, dass das Verhalten von Strukturen mit schreibgesch√ºtztem Modifikator (schreibgesch√ºtzt) und ohne diesen in schreibgesch√ºtzten Kontexten sehr unterschiedlich ist. <br><br>  Es wird davon ausgegangen, dass Strukturen in Programmierskripten verwendet werden, die eine hohe Leistung erfordern. Um effektiv mit ihnen arbeiten zu k√∂nnen, sollten Sie etwas √ºber die verschiedenen versteckten Operationen wissen, die vom Compiler generiert werden, um sicherzustellen, dass die Struktur unver√§ndert bleibt. <br><br>  Hier ist eine kurze Liste von Vorsichtsma√ünahmen, an die Sie sich erinnern sollten: <br><br><ul><li>  Die Verwendung gro√üer Strukturen, die als Wert √ºbergeben oder zur√ºckgegeben werden, kann zu Leistungsproblemen bei kritischen Programmausf√ºhrungspfaden f√ºhren. </li><li> <code>xY</code> bewirkt, dass eine Schutzkopie von x erstellt wird, wenn: <br><ul><li>  <code>x</code> ist ein schreibgesch√ºtztes Feld; </li><li>  Typ <code>x</code> ist eine Struktur ohne schreibgesch√ºtzten Modifikator. </li><li>  <code>Y</code> ist kein Feld. </li></ul></li></ul><br>  Dieselben Regeln gelten, wenn x ein Parameter mit dem Modifikator in, eine lokale Variable mit dem Modifikator ref readonly oder das Ergebnis des Aufrufs einer Methode ist, die einen Wert √ºber eine schreibgesch√ºtzte Referenz zur√ºckgibt. <br><br>  Hier sind einige Regeln, die Sie beachten sollten.  Und vor allem ist der Code, der sich auf diese Regeln st√ºtzt, sehr fragil (dh √Ñnderungen am Code f√ºhren sofort zu signifikanten √Ñnderungen in anderen Teilen des Codes oder der Dokumentation - ca. √ºbersetzt).  Wie viele Leute werden bemerken, dass das Ersetzen von <code>public readonly int X</code> ;  on <code>public int X { get; }</code>  <code>public int X { get; }</code> in einer h√§ufig verwendeten Struktur ohne schreibgesch√ºtzten Modifikator die Leistung erheblich beeintr√§chtigen?  Oder wie einfach ist es zu erkennen, dass die √úbergabe eines Parameters mit dem Modifikator in anstelle der √úbergabe nach Wert die Leistung beeintr√§chtigen kann?  Dies ist wirklich m√∂glich, wenn die in-Eigenschaft eines Parameters in einer Schleife verwendet wird, wenn bei jeder Iteration eine Schutzkopie erstellt wird. <br><br>  Solche Eigenschaften von Strukturen sprechen buchst√§blich die Entwicklung von Analysatoren an.  Und der Anruf wurde geh√∂rt.  <a href="">Lernen</a> Sie <a href="">ErrorProne.NET kennen</a> - eine Reihe von Analyseger√§ten, die Sie √ºber die M√∂glichkeit informieren, Programmcode zu √§ndern, um dessen Design und Leistung bei der Arbeit mit Strukturen zu verbessern. <br><br><h2>  Code-Analyse mit Nachrichtenausgabe "Machen Sie die X-Struktur schreibgesch√ºtzt" </h2><br>  Der beste Weg, um subtile Fehler und negative Auswirkungen auf die Leistung bei der Verwendung von Strukturen zu vermeiden, besteht darin, sie nach M√∂glichkeit schreibgesch√ºtzt zu machen.  Der schreibgesch√ºtzte Modifikator in der Strukturdeklaration dr√ºckt eindeutig die Absicht des Entwicklers aus (wobei betont wird, dass die Struktur unver√§nderlich ist) und hilft dem Compiler, das Laichen von Sicherheitskopien in vielen der oben genannten Kontexte zu vermeiden. <br><br><img src="https://habrastorage.org/webt/tx/fp/5v/txfp5vx1h-8wtkuv_9epx4ulsqe.png"><br><br>  Das Deklarieren einer schreibgesch√ºtzten Struktur verletzt die Code-Integrit√§t nicht.  Sie k√∂nnen den Fixer (den Vorgang des Fixierens des Codes) sicher im Batch-Modus ausf√ºhren und alle Strukturen der gesamten Softwarel√∂sung als schreibgesch√ºtzt deklarieren. <br><br><h2>  Freundlichkeit f√ºr ref readonly Modifikator </h2><br>  Der n√§chste Schritt besteht darin, die Sicherheit der Verwendung neuer Funktionen (in Modifikatoren, lokalen Lesevariablen, Referenzvariablen usw.) zu bewerten.  Dies bedeutet, dass der Compiler keine versteckten Schutzkopien erstellt, die die Leistung beeintr√§chtigen k√∂nnen. <br><br>  Drei Arten von Typen k√∂nnen betrachtet werden: <br><br><ul><li>  ref schreibgesch√ºtzte Strukturen, deren Verwendung niemals zur Erstellung von Schutzkopien f√ºhrt; </li><li>  Strukturen, die nicht schreibgesch√ºtzt sind, deren Verwendung im Zusammenhang mit schreibgesch√ºtzt immer zur Erstellung von Schutzkopien f√ºhrt; </li><li>  neutrale Strukturen - Strukturen, deren Verwendung je nach dem im schreibgesch√ºtzten Kontext verwendeten Element zu Schutzkopien f√ºhren kann. </li></ul><br>  Die erste Kategorie umfasst schreibgesch√ºtzte Strukturen und POCO-Strukturen.  Der Compiler generiert niemals eine Schutzkopie, wenn die Struktur schreibgesch√ºtzt ist.  Es ist auch sicher, POCO-Strukturen im Zusammenhang mit Readonly zu verwenden: Der Zugriff auf Felder wird als sicher angesehen, und es werden keine Schutzkopien erstellt. <br><br>  Die zweite Kategorie sind Strukturen ohne schreibgesch√ºtzten Modifikator, die keine offenen Felder enthalten.  In diesem Fall f√ºhrt jeder Zugriff auf das √∂ffentliche Mitglied im schreibgesch√ºtzten Kontext zur Erstellung einer Schutzkopie. <br><br>  Die letzte Kategorie sind Strukturen mit √∂ffentlichen oder internen Feldern und √∂ffentlichen oder internen Eigenschaften oder Methoden.  In diesem Fall erstellt der Compiler je nach verwendetem Mitglied Schutzkopien. <br><br>  Diese Trennung hilft, sofort Warnungen zu generieren, wenn die "unfreundliche" Struktur mit dem Modifikator in √ºbergeben wird, der in der lokalen Variablen ref readonly usw. gespeichert ist. <br><br><img src="https://habrastorage.org/webt/nc/5a/0p/nc5a0pkfa3xsvrzqxznstyxn5yc.png"><br><br>  Der Analysator zeigt keine Warnung an, wenn die "unfreundliche" Struktur als schreibgesch√ºtztes Feld verwendet wird, da es in diesem Fall keine Alternative gibt.  Die schreibgesch√ºtzten In- und Ref-Modifikatoren wurden speziell optimiert, um das Erstellen redundanter Kopien zu vermeiden.  Wenn die Struktur in Bezug auf diese Modifikatoren "unfreundlich" ist, haben Sie andere M√∂glichkeiten: √úbergeben Sie ein Argument als Wert oder speichern Sie eine Kopie in einer lokalen Variablen.  In dieser Hinsicht verhalten sich schreibgesch√ºtzte Felder anders: Wenn Sie den Typ unver√§nderlich machen m√∂chten, m√ºssen Sie diese Felder verwenden.  Denken Sie daran: Der Code muss klar und elegant sein und nur sekund√§r schnell. <br><br><h2>  Bcc-Analyse </h2><br>  Der Compiler f√ºhrt viele Aktionen aus, die dem Benutzer verborgen bleiben.  Wie in einem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag gezeigt</a> , ist es ziemlich schwer zu erkennen, wann eine Schutzkopie erstellt wird. <br><br>  Der Analysator erkennt die folgenden versteckten Kopien: <br><br><ol><li>  Bcc des schreibgesch√ºtzten Feldes. </li><li>  Bcc von in. </li><li>  Bcc der schreibgesch√ºtzten lokalen Variablen ref. </li><li>  Bcc return ref schreibgesch√ºtzt. </li><li>  Bcc beim Aufrufen einer Erweiterungsmethode, die einen Parameter mit diesem Modifikator als Wert f√ºr eine Instanz der Struktur verwendet. </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> NonReadOnlyStruct { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicField; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PublicProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublicMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> NonReadOnlyStruct _ros; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Samples</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params"> NonReadOnlyStruct nrs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Ok. Public field access causes no hidden copies var x = nrs.PublicField; // Ok. No hidden copies. x = _ros.PublicField; // Hidden copy: Property access on 'in'-parameter x = nrs.PublicProperty; // Hidden copy: Method call on readonly field _ros.PublicMethod(); ref readonly var local = ref nrs; // Hidden copy: method call on ref readonly local local.PublicMethod(); // Hidden copy: method call on ref readonly return Local().PublicMethod(); ref readonly NonReadOnlyStruct Local() =&gt; ref _ros; } }</span></span></code> </pre> <br>  Bitte beachten Sie, dass die Analyseger√§te Diagnosemeldungen nur anzeigen, wenn die Strukturgr√∂√üe ‚â• 16 Byte betr√§gt. <br><br><h2>  Verwendung von Analysatoren in realen Projekten </h2><br>  Die √úbertragung gro√üer Strukturen nach Wert und damit die Erstellung von Schutzkopien durch den Compiler beeintr√§chtigen die Leistung erheblich.  Zumindest zeigen dies die Ergebnisse von Leistungstests.  Aber wie wirken sich diese Ph√§nomene auf reale Anwendungen in Bezug auf die End-to-End-Zeit aus? <br><br>  Um die Analysatoren mit echtem Code zu testen, habe ich sie f√ºr zwei Projekte verwendet: das Roslyn-Projekt und das interne Projekt, an dem ich derzeit bei Microsoft arbeite (das Projekt ist eine eigenst√§ndige Computeranwendung mit strengen Leistungsanforderungen);  Nennen wir es der Klarheit halber "Projekt D". <br><br>  Hier sind die Ergebnisse: <br><br><ol><li>  Projekte mit hohen Leistungsanforderungen enthalten normalerweise viele Strukturen, von denen die meisten schreibgesch√ºtzt sind.  Beispielsweise fand der Analysator im Roslyn-Projekt ungef√§hr 400 Strukturen, die schreibgesch√ºtzt werden k√∂nnen, und im D-Projekt ungef√§hr 300. </li><li>  In Projekten mit hohen Leistungsanforderungen sollten Blindkopien nur in Ausnahmesituationen erstellt werden.  Ich habe im Roslyn-Projekt nur wenige solcher F√§lle gefunden, da die meisten Strukturen √∂ffentliche Felder anstelle von √∂ffentlichen Grundst√ºcken haben.  Dadurch wird vermieden, dass Schutzkopien in Situationen erstellt werden, in denen Strukturen in schreibgesch√ºtzten Feldern gespeichert sind.  In Projekt D gab es mehr Blindkopien, da mindestens die H√§lfte von ihnen Nur-Get-Eigenschaften hatte (Nur-Lese-Zugriff). </li><li>  Die √úbertragung selbst ziemlich gro√üer Strukturen unter Verwendung des In-Modifikators hat wahrscheinlich nur einen sehr geringen (fast nicht wahrnehmbaren) Einfluss auf die Durchlaufzeit des Programms. </li></ol><br>  Ich habe alle 300 Strukturen in Projekt D ge√§ndert, sie schreibgesch√ºtzt gemacht und dann Hunderte von F√§llen ihrer Verwendung korrigiert, um anzuzeigen, dass sie mit dem Modifikator in √ºbergeben wurden.  Dann habe ich die End-to-End-Transitzeit f√ºr verschiedene Leistungsszenarien gemessen.  Die Unterschiede waren statistisch nicht signifikant. <br><br>  Bedeutet dies, dass die oben beschriebenen Funktionen unbrauchbar sind?  √úberhaupt nicht. <br><br>  Die Arbeit an einem Projekt mit hohen Leistungsanforderungen (z. B. an Roslyn oder ‚ÄûProjekt D‚Äú) impliziert, dass eine gro√üe Anzahl von Personen viel Zeit mit verschiedenen Arten der Optimierung verbringt.  In einigen F√§llen wurden Strukturen in unserem Code sogar mit dem ref-Modifikator √ºbergeben, und einige Felder wurden ohne den schreibgesch√ºtzten Modifikator deklariert, um die Erzeugung von Schutzkopien auszuschlie√üen.  Das fehlende Produktivit√§tswachstum w√§hrend der √úbertragung von Strukturen mit dem Modifikator in kann dazu f√ºhren, dass der Code gut optimiert wurde und keine √ºberm√§√üigen Kopien von Strukturen auf den kritischen Pfaden seines Durchgangs vorhanden sind. <br><br><h2>  Was soll ich mit diesen Funktionen tun? </h2><br>  Ich glaube, dass das Problem der Verwendung des schreibgesch√ºtzten Modifikators f√ºr Strukturen nicht viel Nachdenken erfordert.  Wenn die Struktur unver√§nderlich ist, zwingt der schreibgesch√ºtzte Modifikator den Compiler einfach explizit zu einer solchen Entwurfsentscheidung.  Und das Fehlen von Schutzkopien f√ºr solche Strukturen ist nur ein Bonus. <br><br>  Heute lauten meine Empfehlungen wie folgt: Wenn die Struktur nur lesbar ist, dann machen Sie es auf jeden Fall so. <br><br>  Die Verwendung der anderen ber√ºcksichtigten Optionen weist Nuancen auf. <br><br><h2>  Voroptimierung versus Vorpessimierung? </h2><br>  Herb Sutter f√ºhrt das Konzept der ‚Äûvorl√§ufigen Pessimisierung‚Äú in seinem erstaunlichen Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Coding Standards: 101 Rule, Recommendations and Best Practices ein</a> . <br><br>  ‚ÄûCeteris paribus, Codekomplexit√§t und Lesbarkeit, einige effektive Entwurfsmuster und Codierungssprachen sollten nat√ºrlich von Ihren Fingerspitzen abflie√üen.  Ein solcher Code ist nicht schwieriger zu schreiben als seine pessimierten Alternativen.  Sie f√ºhren keine vorl√§ufige Optimierung durch, vermeiden jedoch eine freiwillige Pessimisierung. ‚Äú <br><br>  Aus meiner Sicht ist ein Parameter mit dem Modifikator in genau der Fall.  Wenn Sie wissen, dass die Struktur relativ gro√ü ist (40 Byte oder mehr), k√∂nnen Sie sie jederzeit mit dem Modifikator in √ºbergeben.  Die Kosten f√ºr die Verwendung des Modifikators in sind relativ gering, da Sie die Anrufe nicht anpassen m√ºssen und die Vorteile real sein k√∂nnen. <br><br>  Im Gegensatz dazu ist dies bei lokalen Variablen und R√ºckgabewerten mit dem Modifikator readonly ref nicht der Fall.  Ich w√ºrde sagen, dass diese Funktionen beim Codieren von Bibliotheken verwendet werden sollten, und es ist besser, sie im Anwendungscode abzulehnen (nur wenn die Profilerstellung des Codes nicht ergibt, dass der Kopiervorgang wirklich ein Problem darstellt).  Die Verwendung dieser Funktionen erfordert zus√§tzlichen Aufwand und es wird f√ºr den Codeleser schwieriger, sie zu verstehen. <br><br><h2>  Fazit </h2><br><ol><li>  Verwenden Sie nach M√∂glichkeit den Readonly-Modifikator f√ºr Strukturen. </li><li>  Verwenden Sie den Modifikator in f√ºr gro√üe Strukturen. </li><li>  Erw√§gen Sie die Verwendung lokaler Variablen und R√ºckgabewerte mit dem Modifikator ref readonly, um Bibliotheken zu codieren, oder in F√§llen, in denen die Ergebnisse der Codeprofilerstellung darauf hinweisen, dass dies n√ºtzlich sein kann. </li><li>  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ErrorProne.NET</a> , um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Codeprobleme</a> zu erkennen und die Ergebnisse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">freizugeben</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423053/">https://habr.com/ru/post/de423053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423043/index.html">Aufgrund einer Sicherheitsl√ºcke im Tesla-Schutzsystem f√ºr Elektrofahrzeuge kann ein Auto in wenigen Sekunden gestohlen werden</a></li>
<li><a href="../de423045/index.html">Welchen 3D-Drucker w√§hlen? 3Dtool Video Review</a></li>
<li><a href="../de423047/index.html">Wir reservieren IT-Systeme f√ºr angemessenes Geld</a></li>
<li><a href="../de423049/index.html">Lernprozesse unter Linux</a></li>
<li><a href="../de423051/index.html">Der Kampf um Ressourcen, Teil 1: Die Grundlagen von Cgroups</a></li>
<li><a href="../de423055/index.html">Wall Street Analysten: "Apple hat uns dazu gebracht, unsere H√ºte zu essen"</a></li>
<li><a href="../de423057/index.html">Python lehnt auch die Begriffe Master / Slave teilweise ab</a></li>
<li><a href="../de423059/index.html">Besser als sie sagen: Drei Grundlagen f√ºr das n√§chste MacBook als eines der besten Laptops von Apple</a></li>
<li><a href="../de423061/index.html">ref Einheimische und ref kehrt in C # zur√ºck: Leistungsprobleme</a></li>
<li><a href="../de423063/index.html">Epson WorkForce Pro: Chroniken dar√ºber, wie ein Inkjet-B√ºrodruck eine Decke aus einem Laser gezogen hat und wie es heute dazu kam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>