<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👦‍👦 📔 ☝🏿 Haskell依赖类型：为什么软件开发的未来 💃🏽 🗒️ 🧕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在Serokell，我们不仅从事商业项目，而且致力于使世界变得更好。 例如，我们正在努力改善所有Haskelists的主要工具-格拉斯哥Haskell编译器（GHC）。 在Richard Eisenberg的著作“ Haskell中的从属类型：理论与实践”的影响下，我们专注于扩展类型系统。 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell依赖类型：为什么软件开发的未来</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485174/"><p><img src="https://habrastorage.org/getpro/habr/post_images/fce/995/232/fce99523266b5bc548c3d1730c70b885.jpg"></p><br><p>在Serokell，我们不仅从事商业项目，而且致力于使世界变得更好。 例如，我们正在努力改善所有Haskelists的主要工具-格拉斯哥Haskell编译器（GHC）。 在Richard Eisenberg的著作<a href="https://github.com/goldfirere/thesis/blob/master/built/thesis.pdf" rel="nofollow">“ Haskell中的从属类型：理论与实践”</a>的影响下，我们专注于扩展类型系统。 </p><br><p> 弗拉迪斯拉夫（Vladislav）在<a href="https://serokell.io/blog/why-dependent-haskell" rel="nofollow">我们的博客中</a>已经讨论了Haskell为什么缺少依赖类型以及我们计划如何添加它们。 我们决定将这篇文章翻译成俄语，以便尽可能多的开发人员可以使用依赖类型，并为Haskell语言的发展做出进一步的贡献。 </p><a name="habracut"></a><br><h1 id="tekuschee-polozhenie-del"> 现状 </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6d3/260/bba/6d3260bbad59d047ba6f10b1fffd5383.jpg" alt="编程语言选择算法"></p><br><p> 我在Haskell中最想念依赖类型。 让我们讨论为什么。 从我们想要的代码中： </p><br><ul><li> 性能，即执行速度和低内存消耗； </li><li> 可维护性和易于理解； </li><li> 编译方法保证了正确性。 </li></ul><br><p> 使用现有技术，几乎不可能实现所有这三个特征，但是通过支持Haskell依赖类型，任务得以简化。 </p><br><h2 id="standartnyy-haskell-ergonomika--proizvoditelnost">  Haskell标准：人机工程学+性能 </h2><br><p>  Haskell基于一个简单的系统：具有惰性计算，代数数据类型和类型类的多态Lambda演算。 正是这些语言功能的组合，使我们能够编写优美，受支持且高效的代码。 为了证实这一说法，我们将Haskell与更多流行语言进行了简要比较。 </p><br><p> 内存访问不安全的语言（例如C）会导致最严重的错误和漏洞（例如，缓冲区溢出，内存泄漏）。 有时需要这种语言，但大多数情况下它们的使用是马马虎虎的想法。 </p><br><p> 安全内存访问语言分为两类：依赖垃圾回收器的语言和Rust。  Rust在提供<a href="https://pcwalton.github.io/2013/05/20/safe-manual-memory-management.html" rel="nofollow">无垃圾收集的安全访问内存方面</a>似乎是独一无二的。 该组中也不再支持Cyclone和其他研究语言。 但是与他们不同的是，Rust正在走向流行。 缺点是，尽管具有安全性，Rust的内存管理也不是简单且手动的。 在可以使用垃圾收集器的应用程序中，最好将开发人员的时间花在其他任务上。 </p><br><p> 剩下有垃圾收集器的语言，我们将根据它们的类型系统将其进一步分为两类。 </p><br><p> 动态类型（或更确切地说是<a href="https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" rel="nofollow">单</a>类型）语言（例如JavaScript或Clojure）不提供静态分析，因此无法对代码的正确性提供相同的置信度（并且不能，测试不能替换类型-两者都需要） ！）。 </p><br><p> 诸如Java或Go之类的静态类型语言通常具有非常有限的类型系统。 这迫使程序员编写冗余代码，并放置不安全的语言功能。 例如，Go中缺乏通用类型会强制使用<a href="https://tour.golang.org/methods/14" rel="nofollow">接口{}</a>和<a href="https://golang.org/ref/spec" rel="nofollow">强制转换运行时类型</a> 。 具有副作用（输入，输出）的计算与纯计算之间也没有分隔。 </p><br><p> 最后，在具有安全内存访问，垃圾回收器和功能强大的类型系统的语言中，Haskell在惰性方面脱颖而出。  <a href="https://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html" rel="nofollow">惰性计算</a>对于编写可组合的模块化代码非常有用。 它们使将表达式的任何部分分解为辅助定义成为可能，包括定义控制流的构造。 </p><br><p>  Haskell似乎是一种几乎完美的语言，直到您认识到与静态证明相比与<a href="https://agda.readthedocs.io/en/latest/" rel="nofollow">Agda</a>等定理证明工具相比，Haskell与释放其全部潜力有多远。 </p><br><p>作为Haskell类型系统功能不够强大的简单示例，请考虑<code>Prelude</code>的<a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html" rel="nofollow">列表索引</a>运算符（或从<code>primitive</code>包中<a href="http://hackage.haskell.org/package/primitive-0.6.4.0/docs/Data-Primitive-Array.html" rel="nofollow">索引数组</a> ）： </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a indexArray :: <span class="hljs-type"><span class="hljs-type">Array</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a</code> </pre> <br><p> 这些类型签名中的任何内容都不能反映索引必须为非负且小于集合长度的要求。 对于具有高可靠性要求的软件，这是不可接受的。 </p><br><h2 id="agda-ergonomika--korrektnost">  Agda：人体工程学+正确性 </h2><br><p> 定理的证明手段（例如<a href="https://coq.inria.fr/" rel="nofollow">Coq</a> ）是允许使用计算机开发数学定理的形式证明的软件工具。 对于数学家而言，使用此类工具就像在纸上书写证据。 计算机确定这种证据的有效性所要求的空前严格程度之间的差异。 </p><br><p> 但是，对于程序员而言，证明定理的方法与具有难以置信的类型系统（甚至可能是集成开发环境）的深奥编程语言的编译器并没有什么不同，而其他方面的性能却中等（甚至不存在）。 证明定理的一种方法实际上是编程语言，编程语言的作者花了所有时间开发打字系统，却忘记了仍然需要运行程序。 </p><br><p> 经过验证的软件开发人员的梦想是证明定理的一种方法，这将是具有高质量代码生成器和运行时的良好编程语言。 在这个方向上，包括<a href="https://www.idris-lang.org/" rel="nofollow">伊德里斯</a>的创造者进行了实验。 但这是一种具有严格的（精力充沛的）计算语言，并且目前其实现还不稳定。 </p><br><p> 在证明定理的所有方法中，阿格达·哈斯克尔主义者最喜欢。 在许多方面，它与Haskell类似，但具有更强大的类型系统。 我们在Serokell使用它来证明我们程序的各种特性。 我的同事Dania Rogozin写了<a href="https://serokell.io/blog/2018/11/14/logical-background" rel="nofollow">一系列</a>有关此<a href="https://serokell.io/blog/2018/11/14/logical-background" rel="nofollow">的文章</a> 。 </p><br><p> 这是类似于Haskell运算符<code>(!!)</code>的<a href="" rel="nofollow">查找</a>函数类型： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lookup</span></span> : ∀ (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) → <span class="hljs-type"><span class="hljs-type">Fin</span></span> (length xs) → <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br><p> 这里的第一个参数的类型为<code>List A</code> ，它对应于Haskell中的<code>[a]</code> 。 但是，我们将其命名为<code>xs</code> ，以在其余类型签名中引用它。 在Haskell中，我们只能在术语级别的函数主体中访问函数参数： </p><br><pre> <code class="haskell hljs">(!!) :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; a <span class="hljs-comment"><span class="hljs-comment">--   xs  (!!) = \xs i -&gt; ... --   xs </span></span></code> </pre> <br><p> 但是在Agda中，我们可以在类型级别引用此<code>xs</code>值，这在第二个<code>lookup</code>参数<code>Fin (length xs)</code> 。 在类型级别引用其参数的<em>函数</em>称为<em>相关函数，</em>并且是相关类型的示例。 </p><br><p>  <code>lookup</code>的第二个参数的类型为<code>Fin n</code> ， <code>n ~ length xs</code> 。  <code>Fin n</code>类型的值对应于<code>[0, n)</code>范围内的数字，因此<code>Fin (length xs)</code>是一个小于输入列表长度的非负数。 这正是我们需要提供列表项的有效索引的条件。 粗略地说， <code>lookup ["x","y","z"] 2</code>将通过类型检查，但是<code>lookup ["x","y","z"] 42</code>将失败。 </p><br><p> 关于运行Agda程序，我们可以使用MAlonzo <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php%3Fn%3DDocs.MAlonzo" rel="nofollow">后端</a>在Haskell中对其进行编译。 但是生成的代码的性能将不能令人满意。 这不是MAlonzo的错：他必须插入许多<code>unsafeCoerce</code>以便GHC <code>unsafeCoerce</code> Agda已验证的代码。 但是，相同的<code>unsafeCoerce</code> <a href="https://dspace.library.uu.nl/bitstream/handle/1874/357868/3800296.pdf" rel="nofollow">会降低性能</a> <em>（在本文讨论之后，事实证明性能问题可能是由其他原因引起的-作者的注释）</em> 。 </p><br><p> 这使我们陷入困境：我们必须使用Agda进行建模和形式验证，然后在Haskell上重新实现相同的功能。 通过这种工作流程的组织，我们的Agda代码可作为计算机验证的规范。 这比自然语言规范要好，但远非理想。 目的是如果代码被编译，那么它将按照规范工作。 </p><br><h2 id="haskell-s-rasshireniyami-korrektnost--proizvoditelnost"> 具有扩展功能的Haskell：正确性和性能 </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/954/0e8/735/9540e8735ab539e67787046735ee5789.jpg"></p><br><p> 为了对具有依赖类型的语言进行静态保证，GHC已经走了很长一段路。 扩展已添加到其中，以增加类型系统的表现力。 当GHC 7.4是编译器的最新版本时，我开始使用Haskell。 即使这样，它仍然具有高级类型级别编程的主要扩展： <code>RankNTypes</code> ， <code>GADTs</code> ， <code>TypeFamilies</code> ， <code>DataKinds</code>和<code>PolyKinds</code> 。 </p><br><p> 尽管如此，Haskell中仍然没有成熟的依赖类型：既没有依赖函数（Π型）也没有依赖对（Σ型）。 另一方面，至少我们有一个编码！ </p><br><p> 当前的做法如下： </p><br><ul><li> 将类型级别的功能编码为私有类型族， </li><li> 使用功能化来启用不饱和功能， </li><li> 使用单个类型弥合术语和类型之间的鸿沟。 </li></ul><br><p> 这导致了大量的冗余代码，但是<code>singletons</code>库通过Template Haskell自动生成了代码。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/003/56f/e2a/00356fe2af43f034df850dbb556fb82f.jpg"></p><br><p> 因此，最勇敢和果断的任务可以立即在Haskell中对依赖类型进行编码。 作为演示，这是类似于Agda上的变体的<code>lookup</code>功能的实现： </p><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# OPTIONS -Wall -Wno-unticked-promoted-constructors -Wno-missing-signatures #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE LambdaCase, DataKinds, PolyKinds, TypeFamilies, GADTs, ScopedTypeVariables, EmptyCase, UndecidableInstances, TypeSynonymInstances, FlexibleInstances, TypeApplications, TemplateHaskell #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> ListLookup <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.TH <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Singletons.Prelude singletons [d| data N = Z | SN len :: [a] -&gt; N len [] = Z len (<span class="hljs-title"><span class="hljs-title">_</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = S (<span class="hljs-title"><span class="hljs-title">len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) |] data Fin n where FZ :: Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) FS :: Fin n -&gt; Fin (<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>) lookupS :: SingKind a =&gt; SList (<span class="hljs-title"><span class="hljs-title">xs</span></span> :: [<span class="hljs-title"><span class="hljs-title">a</span></span>]) -&gt; Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) -&gt; Demote a lookupS SNil = \case{} lookupS (<span class="hljs-type"><span class="hljs-type">SCons</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) = \case FZ -&gt; fromSing x FS i' -&gt; lookupS xs i'</code> </pre> <br><p> 这是一个GHCi会话，它显示lookupS确实拒绝太大的索引： </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">GHCi</span></span>, version <span class="hljs-number"><span class="hljs-number">8.6</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span>: http://www.haskell.org/ghc/ :? for help [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-type"><span class="hljs-type">Compiling</span></span> <span class="hljs-type"><span class="hljs-type">ListLookup</span></span> ( <span class="hljs-type"><span class="hljs-type">ListLookup</span></span>.hs, interpreted ) <span class="hljs-type"><span class="hljs-type">Ok</span></span>, one <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> loaded. *ListLookup&gt; :set -XTypeApplications -XDataKinds *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) FZ "x" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>) "y" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)) "z" *ListLookup&gt; lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) &lt;interactive&gt;:5:34: error: • Couldn't match type ''S n0' with ''Z' Expected type: Fin (<span class="hljs-type"><span class="hljs-type">Len</span></span> '["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) Actual type: Fin ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> ('<span class="hljs-type"><span class="hljs-type">S</span></span> <span class="hljs-title"><span class="hljs-title">n0</span></span>)))) • In the second argument of 'lookupS', namely '(<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))' In the expression: lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>))) In an equation for 'it': it = lookupS (<span class="hljs-title"><span class="hljs-title">sing</span></span> @["<span class="hljs-title"><span class="hljs-title">x</span></span>", "<span class="hljs-title"><span class="hljs-title">y</span></span>", "<span class="hljs-title"><span class="hljs-title">z</span></span>"]) (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> (<span class="hljs-type"><span class="hljs-type">FS</span></span> <span class="hljs-type"><span class="hljs-type">FZ</span></span>)))</code> </pre> <br><p> 这个例子表明可行性并不意味着实用。 我很高兴Haskell具有实现<code>lookupS</code>语言功能，但与此同时，我也担心会出现不必要的复杂性。 在研究项目之外，我不建议使用这种代码样式。 </p><br><p> 在这种特殊情况下，我们可以使用长度索引向量以更少的复杂度获得相同的结果。 但是，Agda的直接代码翻译可以更好地揭示您在其他情况下必须遇到的问题。 </p><br><p> 以下是其中一些： </p><br><ul><li> 输入关系<code>a :: t</code>和形式为<code>t :: k</code>的目标关系不同。  <code>5 :: Integer</code>在术语上是正确的，但在类型上不是。  <code>"hi" :: Symbol</code>在类型上正确，但在术语上不正确。 这使得<code>Demote</code>类型<code>Demote</code>必须映射视图和类型。 </li><li> 标准库使用<code>Int</code>表示列表索引（ <code>singletons</code>在提升的定义中使用<code>Nat</code> ）。  <code>Int</code>和<code>Nat</code>是非归纳类型。 尽管比自然数的一元编码更有效，但它们在归纳定义（例如<code>Fin</code>或<code>lookupS</code>不能很好地工作。 因此，我们将<code>length</code>重新定义为<code>len</code> 。 </li><li>  Haskell没有将功能提升到类型级别的内置机制。  <code>singletons</code>将其编码为私有类型族，并应用功能化来避免缺乏部分使用类型族。 这种编码很复杂。 另外，我们必须将<code>len</code>定义放在Template Haskell引号中，以便<code>singletons</code>生成其类型级别的对应项<code>Len</code> 。 </li><li> 没有内置的依赖功能。 人们必须使用<a href="https://repository.brynmawr.edu/cgi/viewcontent.cgi%3Farticle%3D1009%26context%3Dcompsci_pubs" rel="nofollow">单位类型</a>来弥合术语和类型之间的鸿沟。 我们将<code>SList</code>传递给<code>lookupS</code>输入，而不是通常的列表。 因此，我们必须牢记列表的几个定义。 这也导致程序执行期间的开销。 它们的出现是由于普通值和单位类型的值之间的转换（ <code>toSing</code> ， <code>fromSing</code> ）以及转换过程的转移（ <code>SingKind</code>限制）。 </li></ul><br><p> 不便是较小的问题。 更糟糕的是，这些语言功能不可靠。 例如，我在2016年报告了问题<a href="https://gitlab.haskell.org/ghc/ghc/issues/12564" rel="nofollow">＃12564</a> ，同年还有<a href="https://gitlab.haskell.org/ghc/ghc/issues/12564" rel="nofollow">＃12088</a> 。 与教科书中的示例（例如索引列表）相比，这两个问题都阻碍了更高级程序的实现。 这些GHC错误仍未修复，在我看来，原因是开发人员根本没有足够的时间。 积极从事GHC工作的人数非常少，因此有些事情无法解决。 </p><br><h2 id="rezyume"> 总结 </h2><br><p> 前面我提到过，我们需要代码中的所有三个属性，因此下面的表格说明了当前的事务状态： </p><br><div class="scrollable-table"><table><thead><tr><th></th><th> 标准哈斯克尔 </th><th> 阿格达 </th><th>  Haskell扩展 </th></tr></thead><tbody><tr><td> 人机工程学和可维护性 </td><td>  + </td><td>  + </td><td>  -- </td></tr><tr><td> 性能表现 </td><td>  + </td><td>  -- </td><td>  + </td></tr><tr><td> 制图方法保证正确性 </td><td>  -- </td><td>  + </td><td>  + </td></tr></tbody></table></div><br><h1 id="svetloe-buduschee"> 美好的未来 </h1><br><p> 在三个可用选项中，每个都有其缺点。 但是，我们可以修复它们： </p><br><ul><li> 使用标准的Haskell并直接添加从属类型，而不是通过<code>singletons</code>进行不便编码。  （说起来容易做起来难。） </li><li> 以Agda为例，为其实现高效的代码生成器和RTS。  （说起来容易做起来难。） </li><li> 将Haskell与扩展一起使用，修复错误并继续添加新扩展以简化相关类型的编码。  （说起来容易做起来难。） </li></ul><br><p> 好消息是，这三个选项都在某一点上收敛。 想象一下标准Haskell的最小扩展，该扩展添加了依赖类型，因此可以让您通过编写代码的方式保证代码的正确性。 可将Agda代码编译（转换）成这种语言，而无需使用<code>unsafeCoerce</code> 。 从某种意义上说，具有扩展功能的Haskell是该语言的未完成原型。 有些事情需要改进，而某些事情需要消除，但是最后，我们将达到预期的结果。 </p><br><h2 id="izbavlenie-ot-singletons"> 摆脱<code>singletons</code> </h2><br><p> 进步的一个很好的指标是<code>singletons</code>库的简化。 由于在Haskell中实现了依赖类型，因此不再需要变通方法和对<code>singletons</code>例实现的特殊情况的特殊处理。 最终，对该软件包的需求将完全消失。 例如，在2016年，使用<code>-XTypeInType</code>扩展名<code>-XTypeInType</code>我从<code>SingKind</code>和<code>SomeSing</code> <a href="https://github.com/goldfirere/singletons/pull/148/files" rel="nofollow">删除了</a> <code>SomeSing</code> 。 通过类型和类型的并集可以实现此更改。 比较新旧定义： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> ~ '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kparam</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> kparam -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> kparam </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kproxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> ('</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">KProxy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 在旧的定义中， <code>k</code>出现在视图位置中，形式为<code>t :: k</code>的注释的右侧。 我们使用<code>kparam :: KProxy k</code>将<code>k</code>为类型。 </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k :: * fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DemoteRep</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p> 在新的定义中， <code>k</code>在视图位置和类型位置之间自由移动，因此我们不再需要<code>KProxy</code> 。 原因是，从GHC 8.0开始，类型和类型属于同一句法类别。 </p><br><p> 在标准的Haskell中，存在三个完全独立的世界：术语，类型和视图。 如果您查看GHC 7.10的源代码，则可以看到单独的视图<a href="" rel="nofollow">解析器</a>和单独的<a href="" rel="nofollow">check</a> 。  GHC 8.0不再具有它们：类型和视图的<a href="" rel="nofollow">解析器</a>和<a href="" rel="nofollow">验证</a>很常见。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d01/37e/387/d0137e3870470beb4b2aee56240926cf.jpg"></p><br><p> 在具有扩展功能的Haskell中，视图只是类型所扮演的角色： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: <span class="hljs-type"><span class="hljs-type">T</span></span> z -&gt; ... <span class="hljs-comment"><span class="hljs-comment">-- 'z'   g :: T (a :: z) -&gt; ... -- 'z'   h :: T z -&gt; T (a :: z) -&gt; ... -- 'z'   ,  </span></span></code> </pre> <br><p> 在GHC 8.0–8.4中，类型和类型之间的名称解析之间仍然存在一些差异。 但是我将它们最小<code>StarIsType</code> GHC 8.6：我创建了<code>StarIsType</code>扩展，并在<code>PolyKinds</code>引入了<code>TypeInType</code>功能。 我<a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">将</a>其余的差异作为对GHC 8.8的<a href="https://github.com/ghc/ghc/commit/8df24474d0194d28b8273c1539af05793156e23f" rel="nofollow">警告</a> ，并在GHC 8.10中<a href="https://github.com/ghc/ghc/commit/5bc195b1fe788e9a900a15fbe473967850517c3e" rel="nofollow">完全消除了它们</a> （ <em>本段</em>的<em>翻译已更新，原来的工作被描述为将来的任务-作者的注释</em> ）。 </p><br><p> 下一步是什么？ 让我们看看最新版本的<code>singletons</code>中的<code>SingKind</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class">) | r -&gt; k fromSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sing</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> :: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k toSing :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeSing</span></span></span><span class="hljs-class"> k</span></span></code> </pre> <br><p> 必须使用<code>Demote</code>类型<code>Demote</code>来解决打字关系<code>a :: t</code>和形式<code>t :: k</code>的目标关系之间的差异。 大多数情况下（对于代数数据类型）， <code>Demote</code>是一种身份映射： </p><br><ul><li> <code>type Demote Bool = Bool</code> </li> <li> <code>type Demote [a] = [Demote a]</code> </li> <li> <code>type Demote (Either ab) = Either (Demote a) (Demote b)</code> </li> </ul><br><p> 因此， <code>Demote (Either [Bool] Bool) = Either [Bool] Bool</code> 。 此观察提示我们进行以下简化： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SingKind</span></span></span><span class="hljs-class"> k </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fromSing :: <span class="hljs-type"><span class="hljs-type">Sing</span></span> (a :: k) -&gt; k toSing :: k -&gt; <span class="hljs-type"><span class="hljs-type">SomeSing</span></span> k</code> </pre> <br><p> 不需要<code>Demote</code> ！ 而且，实际上，这将同时适用于<code>Either [Bool] Bool</code>和其他代数数据类型。 但是，实际上，我们正在处理非代数数据类型： <code>Integer,</code> <code>Natural</code> ， <code>Char</code> ， <code>Text</code>等。 如果用作物种，则不会填充它们： <code>1 :: Natural</code>在术语级别为true，但在类型级别不是。 因此，我们正在处理以下定义： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Natural</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Symbol</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Text</span></span></span></span></code> </pre> <br><p> 解决此问题的方法是提高基本类型。 例如， <code>Text</code>定义如下： </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | A space efficient, packed, unboxed Unicode text type. data Text = Text {-# UNPACK #-} !Array -- payload (Word16 elements) {-# UNPACK #-} !Int -- offset (units of Word16, not Char) {-# UNPACK #-} !Int -- length (units of Word16, not Char) data Array = Array ByteArray# data Int = I# Int#</span></span></code> </pre> <br><p> 如果我们将<code>ByteArray#</code>和<code>Int#</code>适当地提高到类型级别，则可以使用<code>Text</code>而不是<code>Symbol</code> 。 通过对<code>Natural</code>和可能的其他几种类型进行相同的处理，可以摆脱<code>Demote</code>吧？ </p><br><p>  las，不是这样。 在上面，我对最重要的数据类型：函数视而不见。 它们还有一个特殊的<code>Demote</code>实例： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k1</span></span></span><span class="hljs-class"> ~&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k2</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k1 -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Demote</span></span></span><span class="hljs-class"> k2 </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> a ~&gt; b = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> ab -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TyFun</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span></span></code> </pre> <br><p>  <code>~&gt;</code>这是基于私有类型族和<a href="https://typesandkinds.wordpress.com/2013/04/01/defunctionalization-for-the-win/" rel="nofollow">功能化</a>以单例形式编码类型级别函数的类型。 </p><br><p> 起初，将<code>~&gt;</code>和<code>-&gt;</code>组合起来似乎是一个好主意，因为两者均表示函数的类型（类型）。 问题是在类型位置的<code>-&gt;</code>和在视图位置的<code>-&gt;</code>表示不同的意思。 在术语级别，从<code>a</code>到<code>b</code>所有函数的类型<code>a -&gt; b</code> 。 在类型级别上，只有从<code>a</code>到<code>b</code> <em>构造函数</em>的类型<code>a -&gt; b</code> ，但它们不是类型的同义词，也不是类型族。 为了推断类型，GHC假定f〜g和a〜b跟随<code>fa ~ gb</code> ，这对于构造函数而言是正确的，但对函数而言并非如此-这就是为什么有限制的原因。 </p><br><p> 因此，为了将函数提升到类型级别，但保留类型推断，我们将必须将构造函数移至单独的类型。 我们称其为<code>a :-&gt; b</code> ，因为<code>fa ~ gb</code>从<code>fa ~ gb</code>跟随是真的。 其他功能仍将是a- <code>a -&gt; b</code>类型。 例如， <code>Just :: a :-&gt; Maybe a</code> ，但同时是<code>isJust :: Maybe a -&gt; Bool</code> 。 </p><br><p>  <code>Demote</code>完成后，最后一步是摆脱<code>Sing</code>本身。 为此，我们需要一个新的量词，即<code>forall</code>和<code>-&gt;</code>的混合体。 让我们仔细看看isJust函数： </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">isJust</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> isJust = \x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre> <br><p> 使用类型<code>a</code>参数化<code>isJust</code>函数，然后使用值<code>x :: Maybe a</code> 。 这两个参数具有不同的属性： </p><br><ul><li> 明确的。 在<code>isJust (Just "hello")</code>调用中，我们显式传递<code>x = Just "hello"</code> ，并且编译器隐式输出<code>a = String</code> 。 在现代的Haskell中，我们还可以强制两个参数的显式传递： <code>isJust @String (Just "hello")</code> 。 </li><li> 相关性 传递给代码中<code>isJust</code>的输入的值也将在程序执行过程中传输：我们进行<code>case</code>匹配以验证其为<code>Nothing</code>或<code>Just</code> 。 因此，该值被认为是相关的。 但是它的类型已删除，无法与模式进行比较：该函数处理<code>Maybe Int</code> ， <code>Maybe String</code> ， <code>Maybe Bool</code>等。 因此，这被认为是无关紧要的。 此属性也称为参数性。 </li><li> 成瘾。 总而言之  <code>forall a. t</code> ，类型<code>t</code>可能引用<code>a</code> ，因此取决于传递的<code>a</code> 。 例如， <code>isJust @String</code>的类型<code>Maybe String -&gt; Bool</code>是<code>Maybe String -&gt; Bool</code> <code>isJust @String</code> <code>Maybe String -&gt; Bool</code> ，而<code>isJust @Int</code>的类型<code>Maybe Int -&gt; Bool</code>是<code>Maybe Int -&gt; Bool</code> <code>isJust @Int</code> <code>Maybe Int -&gt; Bool</code> 。 这意味着， <code>forall</code>是一个依赖量词。 请注意与value参数的区别：不管我们叫<code>isJust Nothing</code>还是<code>isJust (Just …)</code> ，结果类型始终为<code>Bool</code> 。 因此， <code>-&gt;</code>是一个独立的量词。 </li></ul><br><p> 要提取<code>Sing</code> ，我们需要一个明确且相关的量词，例如<code>forall (a :: k). t</code> <code>a -&gt; b</code> ，同时还需要一个量词，例如<code>forall (a :: k). t</code>  。 将其表示为<code>foreach (a :: k) -&gt; t</code> 。 为了取出<code>SingI</code> ，我们还引入了一个隐式相关依赖量词<code>foreach (a :: k). t</code>  。 结果，由于我们只向语言添加了相关函数，因此不再需要<code>singletons</code> 。 </p><br><h2 id="kratkiy-vzglyad-na-haskell-s-zavisimymi-tipami"> 简要了解具有相关类型的Haskell </h2><br><p> 随着函数上升到类型级别和<code>foreach</code>量词的水平，我们可以如下重写<code>lookupS</code> ： </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SN</span></span></span><span class="hljs-class"> len :: [a] -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">N</span></span></span><span class="hljs-class"> len [] = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class"> len (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> n -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">S</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) lookupS :: foreach (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">]) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fin</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) -&gt; a lookupS [] = \case{} lookupS (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class">) = \case </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FZ</span></span></span><span class="hljs-class"> -&gt; x </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FS</span></span></span><span class="hljs-class"> i' -&gt; lookupS xs i'</span></span></code> </pre> <br><p> 简而言之，代码没有，但是<code>singletons</code>代码很好地隐藏了冗余代码。 但是，新代码要简单得多：不再有<code>SingKind</code> ， <code>SList</code> ， <code>SNil</code> ， <code>SNil</code> ， <code>SCons</code>和<code>fromSing</code> 。 没有使用<code>TemplateHaskell</code> ，因为现在我们可以直接调用<code>len</code>函数，而不用创建<code>Len</code>类型族。 性能也将更好，因为您不再需要转换<code>fromSing</code> 。 </p><br><p> 我们仍然必须将<code>length</code>重新定义为<code>len</code>以返回归纳定义的<code>N</code>而不是<code>Int</code> 。 也许不应该将此问题视为将依赖类型添加到Haskell的一部分，因为Agda在<code>lookup</code>函数中还使用了归纳定义的<code>N</code> </p><br><p> 在某些方面，具有依赖类型的Haskell甚至比标准Haskell更简单。 就此而言，类型和类型仍然组合为一种统一的语言。 我可以轻松想象在商业项目中以这种方式编写代码以正式证明关键应用程序组件的正确性。 许多Haskell库可以提供更安全的接口，而不会导致<code>singletons</code>的复杂性。 </p><br><p> 这将不容易实现。 我们面临着许多工程问题，这些问题影响到GHC的所有组件：解析器，名称解析，类型检查，甚至是核心语言。 一切都需要修改，甚至完全重新设计。 </p><br><hr><br><h1 id="tezaurus"> 词库 </h1><br><div class="scrollable-table"><table><tbody><tr><td>  <strong>学期</strong> <br></td><td>  <strong>笔译</strong> <br></td><td> <strong></strong> <br></td></tr><tr><td> correct by construction <br></td><td> ,       <br></td><td>  ,         (,   ),   . <br></td></tr><tr><td> memory unsafe <br></td><td>      <br></td><td>         ,    . <br></td></tr><tr><td> unityped <br></td><td>  <br></td><td> ,   Bob Harper     ,    .           . <br></td></tr><tr><td> boilerplate <br></td><td>   <br></td><td>       ,    -   . <br></td></tr><tr><td> generics <br></td><td>   <br></td><td>       . ,     «»  «»,     ,    &lt;&gt;  &lt;&gt;. <br></td></tr><tr><td> runtime cast <br></td><td>     <br></td><td>              . <br></td></tr><tr><td> effectful computation <br></td><td>     <br></td><td> ,          . <br></td></tr><tr><td> composable <br></td><td>  <br></td><td>  ,          . <br></td></tr><tr><td> control structures <br></td><td> ,    <br></td><td>  ,       . <br></td></tr><tr><td> proof assistant <br></td><td>    <br></td><td>       . <br></td></tr><tr><td> strict (eager) evaluation <br></td><td>  ()  <br></td><td>   ,         . <br></td></tr><tr><td> backend <br></td><td>  <br></td><td>  ,         . <br></td></tr><tr><td> singleton type <br></td><td>   <br></td><td> ,   ,       . <br></td></tr><tr><td> promoted definitions <br></td><td>   <br></td><td>    ,         . <br></td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN485174/">https://habr.com/ru/post/zh-CN485174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN485158/index.html">尼古拉·瓦维洛夫（Nikolay Vavilov）。 想要养活整个世界并在监狱牢房中饿死的人</a></li>
<li><a href="../zh-CN485160/index.html">我对ACID的看法是什么？</a></li>
<li><a href="../zh-CN485162/index.html">代码注释如何从1940年代演变到2020年</a></li>
<li><a href="../zh-CN485164/index.html">温哥华的变形金刚和仇恨：反lag窃主义如何影响NeurIPS-2019</a></li>
<li><a href="../zh-CN485172/index.html">大型项目中的架构问题</a></li>
<li><a href="../zh-CN485176/index.html">六种方案可帮助解释产品管理概念</a></li>
<li><a href="../zh-CN485178/index.html">通过照片重建失落建筑物的方法</a></li>
<li><a href="../zh-CN485180/index.html">我们需要一个数据湖吗？ 如何处理数据仓库？</a></li>
<li><a href="../zh-CN485182/index.html">2020年的森海塞尔-周年纪念期间更新了无线耳机</a></li>
<li><a href="../zh-CN485184/index.html">选项卡式投票结果</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>