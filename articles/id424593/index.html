<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§æ üôéüèª üêÖ C ++ 11 dan penanganan acara üôãüèæ üè≥Ô∏è ‚õπüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya pikir bahwa pemrosesan peristiwa sebagai cara interaksi antara objek di OOP diketahui hampir semua orang yang pernah menyentuh OOP setidaknya sek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ 11 dan penanganan acara</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424593/">  Saya pikir bahwa pemrosesan peristiwa sebagai cara interaksi antara objek di OOP diketahui hampir semua orang yang pernah menyentuh OOP setidaknya sekali.  Setidaknya, pendekatan ini sangat nyaman dalam cakupan tugas yang sangat luas, menurut saya.  Dalam banyak bahasa pemrograman, mesin penanganan acara adalah bawaan;  Namun, dalam C ++ tidak ada mekanisme seperti itu.  Mari kita lihat apa yang dapat Anda lakukan. <br><a name="habracut"></a><br><a name="Intro"></a><h1>  Pengantar singkat </h1><br>  <i>Suatu peristiwa</i> adalah sesuatu yang dapat terjadi pada beberapa objek dalam kondisi tertentu (misalnya, dengan tombol ketika Anda mengkliknya dengan mouse).  Entitas lain mungkin perlu mengetahui hal ini;  lalu mereka <i>berlangganan acara tersebut</i> .  Dalam hal ini, ketika suatu peristiwa terjadi, <i>pawang dari</i> objek pihak ketiga yang berlangganan acara tersebut disebut;  Dengan demikian, ia memiliki kesempatan untuk mengeksekusi beberapa kode, mis.  menanggapi suatu acara.  Demikian pula, suatu objek dapat <i>berhenti berlangganan dari suatu peristiwa</i> jika tidak lagi ingin menanggapinya.  Akibatnya, kami memiliki banyak objek yang dapat dihubungkan satu sama lain menggunakan peristiwa salah satunya dan reaksi terhadap peristiwa lain ini. <br><br>  Sesuatu seperti itu, meskipun semua orang tahu itu. <br><br><a name="Trivial"></a><h1>  Implementasi yang paling sederhana </h1><br>  Tampaknya mudah untuk menerapkan perilaku semacam itu.  Dan mungkin terlihat seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventHandler() {} };</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers() { } ~TEvent() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> oneHandler; m_handlers.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) oneHandler-&gt;call( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { m_handlers.push_back( &amp;eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TObject&amp; object, TMethod method ) : AbstractEventHandler&lt;TParams...&gt;(), m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ ( m_object.*m_method )( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createMethodEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">:</span></span>:*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;TObject, TParams...&gt;( object, method ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br>  Penerapan kasus ini harus dalam bentuk: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ ... } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  Tentu saja, metode penangan (-fungsi-anggota kelas) tidak akan menjadi satu-satunya jenis penangan, tetapi lebih pada nanti. <br><br>  Segalanya tampak nyaman, kompak dan hebat.  Namun meski ada sejumlah kekurangan. <br><br><a name="HandlerCompare"></a><h1>  Perbandingan Handler </h1><br>  Untuk menerapkan berhenti berlangganan dari suatu peristiwa, perlu untuk menambahkan kemungkinan perbandingan ke penangan (dengan <i>==</i> dan <i>! ==</i> ).  Penangan yang memanggil metode yang sama (fungsi anggota kelas) dari objek yang sama (mis., Instance yang sama dari kelas yang sama) akan dianggap sama. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; &amp;m_object == &amp;_other.m_object &amp;&amp; m_method == _other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; . . . };</code> </pre><br>  Kemudian kita akan dapat menghapus penangan dari berlangganan acara.  Dalam hal ini, perlu untuk melarang menambahkan penangan yang sama (sama). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( &amp;eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> removedEventHandler; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TEventHandlerIt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findEventHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TEventHandler* oneHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( *oneHandler == eventHandler ); } ); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; . . . };</code> </pre><br>  Di sini, fungsi tambah / hapus dari handler mengembalikan <i>true</i> jika berhasil dan <i>salah</i> jika tindakan yang sesuai (tambah atau hapus) tidak dilakukan. <br><br>  Ya, use case dengan perbandingan melibatkan pembuatan penangan sementara yang tidak ditambahkan di mana pun yang tidak dihapus di mana pun.  Tetapi lebih lanjut tentang itu nanti. <br><br>  Bisakah ini digunakan?  Belum sepenuhnya diimplementasikan. <br><br><a name="HandlerRemoving"></a><h1>  Menghapus pawang di dalam pawang </h1><br>  Jadi, kami segera menemukan crash selama eksekusi kode, di mana pawang berhenti berlangganan dari acara tersebut (saya pikir itu bukan <i>kasus penggunaan</i> paling langka ketika pawang memotong sendiri dalam kondisi apa pun): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TestWindow&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ TestWindow::instance().onButtonClick -= MY_METHOD_HANDLER( ClickEventHandler::testWindowButtonClick ); } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . ClickEventHandler clickEventHandler; TestWindow::instance().onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  Masalah muncul karena alasan yang sangat sederhana: <br><br><ul><li>  acara dipicu dan mulai untuk mengulangi (menggunakan iterator) penangan, memanggil mereka; </li><li>  handler berikutnya di dalam dirinya menyebabkan dirinya dihapus; </li><li>  acara menghapus handler yang diberikan, membuat iterator yang sesuai tidak valid; </li><li>  setelah penyelesaian penangan ini, acara kembali untuk menghitung yang lain, namun, iterator saat ini (terkait dengan penangan jarak jauh) sudah tidak valid; </li><li>  acara ini mencoba mengakses iterator yang tidak valid, menyebabkan jatuh. </li></ul><br>  Oleh karena itu, perlu untuk memeriksa kasus ketika daftar penangan dapat diubah, yang akan menyebabkan pembatalan iterator;  dan kemudian menerapkan perlindungan baca untuk iterator tersebut. <br><br>  Keuntungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: list</a> 'dalam aplikasi ini adalah kenyataan bahwa ketika menghapusnya hanya membuat satu iterator menjadi tidak valid - pada elemen yang dihapus (memengaruhi, misalnya, yang berikut);  dan menambahkan elemen tidak menyebabkan pembatalan iterator sama sekali.  Jadi, kita perlu mengontrol satu-satunya kasus: menghapus elemen yang iteratornya saat ini dalam penghitungan elemen saat ini.  Dalam hal ini, Anda dapat, misalnya, tidak menghapus elemen, tetapi cukup tandai bahwa elemen saat ini akan dihapus, dan biarkan dilakukan di dalam penghitungan elemen. <br><br>  Seseorang dapat segera menjalankan implementasi ini, tetapi saya mengusulkan untuk menyelesaikan masalah ini bersama dengan yang berikut. <br><br><a name="ThreadSafety"></a><h1>  Keamanan benang </h1><br>  Secara potensial, panggilan ke tiga fungsi yang mungkin - menambah, menghapus, dan mengurutkan (ketika suatu kejadian dipicu) penangan - dimungkinkan dari utas yang berbeda secara acak.  Ini menciptakan seluruh bidang kemungkinan untuk "persimpangan" mereka dalam waktu, "tumpang tindih" dari eksekusi mereka satu sama lain dan sebagai hasilnya program jatuh.  Mari kita coba hindari ini;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mutex adalah segalanya bagi kita</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ), m_handlerListMutex() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_currentIt = m_handlers.begin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_isCurrentItRemoved ) { m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( eventHandler ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it == m_currentIt ) m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> deleteHandler( it ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( TEventHandler&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandler* oneHandler ) { return ( *oneHandler == eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); delete removedEventHandler; } std::list&lt;TEventHandler*&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; };</span></span></code> </pre><br>  Jangan lupa untuk membiarkan jendela terbuka hampir setiap kali Anda memanggil setiap penangan.  Ini diperlukan agar di dalam handler dimungkinkan untuk mengakses acara dan mengubahnya (misalnya, menambah / menghapus handler) tanpa menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebuntuan</a> .  Anda tidak boleh takut dengan validitas data, karena, seperti yang kami ketahui, satu-satunya hal yang mengarah ke ini adalah penghapusan elemen saat ini, dan situasi ini telah diproses. <br>  <b>UPD1.</b>  Terima kasih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Cheater</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyarankan</a> agar <i>std :: shared_mutex</i> hanya muncul di <i>C ++ 17</i> (dan <i>std :: shared_lock</i> hanya di <i>C ++ 14</i> ).  Mereka yang sangat kritis mungkin harus melakukan dengan <i>std :: mutex</i> . <br>  <b>UPD2.</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Selanjutnya, tentang keamanan utas</a> (tanpa menjaga urutan narasi). <br><br><a name="EventVisibility"></a><h1>  Masalah Visibilitas Acara </h1><br>  Saat menggunakan acara sebagai anggota kelas, tampaknya logis untuk membuatnya <i>publik</i> , sehingga objek pihak ketiga dapat menambah / menghapus penangannya.  Namun, ini akan menghasilkan <i>operator ()</i> , mis.  panggilan acara juga akan dapat diakses dari luar, yang dalam beberapa kasus mungkin tidak dapat diterima.  Kami akan memecahkan masalah ini dengan mengisolasi dari kelas acara ( <i>TEvent &lt;...&gt;</i> ) antarmuka abstrak yang hanya ditujukan untuk menangani penangan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : IEvent&lt;TParams...&gt;() . . . { } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     'TEvent::operator+=' } virtual bool removeHandler( TEventHandler&amp; eventHandler ) override { // ,     'TEvent::operator-=' } . . . };</span></span></code> </pre><br>  Sekarang kita dapat membagi ke dalam cakupan yang berbeda bagian dari acara yang bertanggung jawab untuk bekerja dengan penangan, dan bagian yang bertanggung jawab untuk menyebutnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestWindow() : onButtonClick( m_onButtonClick ), m_onButtonClick() { } IEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; onButtonClick; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m_onButtonClick; . . . };</code> </pre><br>  Dengan demikian, sekarang objek pihak ketiga dapat menambah / menghapus penangan mereka melalui <i>TestWindow :: onButtonClick</i> , namun mereka tidak akan dapat memicu acara ini sendiri.  Panggilan sekarang dapat dilakukan hanya di dalam kelas <i>TestWindow</i> (dan turunannya, jika ruang lingkup acara, sebagai contoh, <i>dilindungi</i> ). <br><br>  Kode trivial perlahan mulai berubah menjadi sesuatu yang mengerikan, tetapi ini bukan akhir. <br><br><a name="EventHandlerParams"></a><h1>  Cocokkan parameter acara dan penangannya </h1><br>  Dalam implementasi saat ini, acara dan salah satu penangannya harus memiliki daftar parameter yang benar-benar sesuai.  Hal ini menyebabkan sejumlah kerugian. <br><br>  <b>Yang pertama.</b>  Misalkan kita memiliki templat kelas di mana ada acara dengan parameter templat. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TSource&amp;&gt; onValueChanged; . . . };</code> </pre><br>  Karena fakta bahwa jenis yang akan digunakan di sini tidak diketahui sebelumnya, masuk akal untuk mengirimkannya melalui tautan konstan, dan bukan berdasarkan nilai.  Namun, sekarang untuk implementasi apa pun, bahkan dengan tipe fundamental, penangan yang sesuai harus ada. <br><br><pre> <code class="cpp hljs">MyClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; myBoolClass; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHandlerClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; newValue )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue )</span></span></span></span>; . . . }; . . . MyHandlerClass myHandlerClass; myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged1 ); <span class="hljs-comment"><span class="hljs-comment">// OK myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged2 ); // compile error</span></span></code> </pre><br>  Saya ingin dapat menghubungkan penangan formulir <i>MyHandlerClass :: handleValueChanged2</i> ke acara serupa, tetapi sejauh ini tidak ada kemungkinan seperti itu. <br><br>  <b>Yang kedua.</b>  Mari kita coba mengimplementasikan functor handler yang mirip dengan metode handler yang ada (-fungsi-anggota kelas). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( TFunctor&amp; functor ) : AbstractEventHandler&lt;TParams...&gt;(), m_functor( functor ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TParams...&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor )</span></span></code> </pre><br>  Sekarang cobalah untuk mengacaukannya ke beberapa acara. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ . . . } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += FUNCTOR_HANDLER( clickEventHandler ); . . . }</code> </pre><br>  Hasilnya akan menjadi kesalahan kompilasi.  Untuk fungsi <i>createFunctorEventHandler,</i> kompiler tidak dapat menyimpulkan jenis <i>TParams ...</i> dari satu-satunya argumen ke fungsi ini - functor itu sendiri.  Functor benar-benar tidak mengandung informasi tentang jenis penangan yang dibuat berdasarkan itu.  Satu-satunya hal yang dapat dilakukan dalam situasi ini adalah menulis sesuatu seperti: <br><br><pre> <code class="cpp hljs">testWindow.onButtonClick += createFunctorEventHandler&lt;ClickEventHandler, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( clickEventHandler );</code> </pre><br>  Tetapi Anda tidak ingin melakukan ini sama sekali. <br><br><a name="HandlerHolder"></a><h1>  Menghubungkan suatu acara ke berbagai jenis penangan </h1><br>  Jadi, ada Wishlist, terserah implementasi.  Kami akan mempertimbangkan situasi dengan menggunakan contoh dari handler functor; metode handler (-fungsi-anggota kelas) akan diperoleh dengan cara yang sama. <br><br>  Karena atas dasar functor saja tidak mungkin untuk mengatakan apa daftar parameter dari handler yang sesuai, maka kita tidak akan melakukan ini.  Pertanyaan ini menjadi relevan bukan pada saat pawang dibuat, tetapi pada saat mencoba melampirkannya pada peristiwa tertentu.  Dan ya, ini adalah dua poin yang berbeda.  Gagasan ini dapat diimplementasikan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( FunctorHolder&lt;TFunctor&gt;&amp; functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ m_functorHolder.m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;&amp;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">&lt;TFunctor&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorHolder&lt;TFunctor&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">-=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Singkatnya, pemisahan saat-saat penciptaan pawang dan keterikatannya dengan peristiwa di sini lebih terasa daripada sebelumnya.  Ini menghindari masalah yang dijelaskan dalam paragraf sebelumnya.  Jenis pengujian kompatibilitas akan terjadi ketika mencoba untuk melampirkan <i>FunctorHolder</i> spesifik ke <i>FunctorEventHandler</i> tertentu, atau lebih tepatnya, membuat turunan dari <i>FunctorEventHandler &lt;...&gt;</i> Kelas dengan tipe functor yang sangat spesifik;  dan di kelas ini akan ada baris kode <i>m_functorHolder.m_functor (params ...);</i>  , yang tidak bisa dikompilasi untuk sekumpulan tipe yang tidak kompatibel dengan functor (atau jika itu bukan functor sama sekali, mis. objek yang tidak memiliki <i>operator ()</i> ). <br><br>  Saya ulangi bahwa masalah menghapus objek sementara akan dibahas di bawah ini.  Selain itu, perlu dicatat bahwa sekelompok makro untuk setiap kasus dibuat, pertama, untuk menunjukkan kemampuan jenis penangan ini, dan kedua, dalam hal kemungkinan modifikasi dari salah satu dari mereka dengan file. <br><br>  Periksa hasilnya. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor4</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor5</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor6</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor7</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; Functor functor; Functor2 functor2; Functor3 functor3; Functor4 functor4; Functor5 functor5; Functor6 functor6; Functor7 functor7; testWindow.onButtonClick += FUNCTOR_HANDLER( functor ); <span class="hljs-comment"><span class="hljs-comment">// ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor2 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor3 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor4 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor5 ); // compile error testWindow.onButtonClick += FUNCTOR_HANDLER( functor6 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor7 ); // compile error . . . }</span></span></code> </pre><br>  Kesalahan kompilasi terjadi ketika mencoba mengkonversi salah satu parameter dari <i>nilai konstanta</i> ke <i>nilai semula</i> .  Mengubah dari <i>nilai menjadi</i> tidak penting Nilai tidak menyebabkan kesalahan, meskipun perlu dicatat bahwa itu menciptakan potensi ancaman self-shot di kaki: pawang akan dapat mengubah variabel yang disalin ke dalam tumpukan, yang dengan senang hati akan dihapus ketika pawang ini keluar. <br><br>  Secara umum, pesan kesalahan akan terlihat seperti ini: <br><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">Error</span></span> C2664 <span class="hljs-symbol"><span class="hljs-symbol">'void</span></span> Functor5::operator ()(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;,<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int &amp;)': cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'const</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>' <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;'</code> </pre><br>  Untuk kejelasan yang lebih besar, saat menggunakan acara dan penangan dalam kode pihak ketiga, Anda dapat menambahkan pesan kesalahan Anda sendiri.  Ini akan membutuhkan penulisan struktur pendukung kecil (saya akui, saya melihat pendekatan serupa di suatu tempat): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunctorParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedFunctor&gt;()( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;TFunctor, TParams...&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; }; } <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, <span class="hljs-string"><span class="hljs-string">"Event and functor arguments are not compatible"</span></span> ); m_functorHolder-&gt;m_functor( params... ); } . . . };</code> </pre><br><a name="AboutSfinae"></a>  Pekerjaan ini didasarkan pada mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SFINAE</a> .  Singkatnya, suatu usaha dilakukan untuk mengkompilasi fungsi pertama <i>ada</i> , namun, jika ini tidak berfungsi karena ketidakcocokan argumen (atau tidak adanya <i>operator ()</i> dari apa yang disahkan sebagai functor), kompiler tidak melakukan kesalahan, tetapi hanya mencoba mengkompilasi fungsi kedua;  kami melakukan segalanya sehingga kompilasi selalu berhasil, dan kemudian, berdasarkan fakta fungsi yang dikompilasi, kami menyimpulkan (dengan menulis hasilnya ke <i>nilai</i> ) tentang kompatibilitas argumen untuk jenis yang diberikan. <br><br>  Sekarang pesan kesalahan akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs">Error C2338 Event <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> functor arguments are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compatible Error C2664 <span class="hljs-string"><span class="hljs-string">'void Functor5::operator ()(std::string &amp;,unsigned int &amp;)'</span></span>: cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-string"><span class="hljs-string">'const std::string'</span></span> to <span class="hljs-string"><span class="hljs-string">'std::string &amp;'</span></span></code> </pre><br>  Selain pesan kesalahan tambahan yang lebih informatif, pendekatan ini memecahkan masalah konversi argumen dari nilai ke <i>nilai tidak masuk akal</i> : sekarang ini menyebabkan kesalahan ketidakcocokan argumen, mis.  <i>Mencoba</i> untuk menambahkan pengendali <i>functor6</i> dari contoh di atas menghasilkan kesalahan waktu kompilasi. <br>  <b>UPD</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyempitan</a> (tanpa mempertahankan urutan narasi). <br><br><a name="FunctorCompare"></a><h1>  Perbandingan Functor </h1><br>  Karena perubahan dalam kelas handler, implementasi contoh pembandingan dari kelas ini akan sedikit berubah.  Sekali lagi, saya hanya akan menyediakan implementasi dari functor handler, karena metode-handler (-fungsi-anggota kelas) akan terlihat serupa. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorHolder&lt;TFunctor&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_functor == other.m_functor ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . };</code> </pre><br>  Pada ini, kesamaan dalam implementasi akhir perbandingan dan bagian dimulai hanya untuk fungsi-handler. <br><br>  Seperti disebutkan di atas, kami telah memperoleh beberapa jenis penangan functor: objek functor langsung, ekspresi lambda, turunan dari kelas <i>std :: function</i> , fungsi individual.  Dari jumlah tersebut, objek functor, ekspresi lambda, dan instance dari kelas <i>fungsi std ::</i> tidak dapat dibandingkan menggunakan <i>operator ==</i> (mereka perlu dibandingkan di alamat), tetapi fungsi individual dapat, karena  sudah disimpan di.  Agar tidak menulis ulang fungsi perbandingan secara terpisah untuk setiap kasus, kami menulisnya dalam bentuk umum: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEqu</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEnabled</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( operand1 == operand2 ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TNonEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;operand1 == &amp;operand2 ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TFunctor&gt; class FunctorHolder { . . . using MyType = FunctorHolder&lt;TFunctor&gt;; public: bool operator==( const MyType&amp; other ) const { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } private: TFunctor&amp; m_functor; . . . };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapat dipahami bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah templat bantu yang menentukan apakah dua contoh dari jenis yang diberikan dapat diperiksa untuk kesetaraan. </font><font style="vertical-align: inherit;">Dengan bantuannya, menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: enable_if</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kami memilih satu dari dua struktur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EqualityChecker yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagian terspesialisasi </font><font style="vertical-align: inherit;">, yang akan melakukan perbandingan: berdasarkan nilai atau alamat. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diimplementasikan </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> bisa sebagai berikut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_equatable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() == </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;T&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi ini didasarkan pada mekanisme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang telah digunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelumnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hanya di sini kita memeriksa keberadaan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk instance kelas yang diberikan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan cara sederhana ini, implementasi perbandingan fungsi-fungsi handler sudah siap.</font></font><br><br><a name="GarbageCollection"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengumpulan sampah </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bersikap lunak, saya juga ingin memasukkan judul yang keras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sedang mendekati final, dan inilah saatnya untuk menyingkirkan sejumlah besar objek yang dibuat yang tidak dikontrol oleh siapa pun. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan setiap aksi dari suatu peristiwa dengan seorang pawang, dua objek dibuat: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemegang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menyimpan bagian yang dapat dieksekusi dari pawang, dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghubungkannya dengan acara tersebut. Jangan lupa bahwa jika ada upaya untuk menambahkan kembali pawang, tidak ada tambahan yang akan terjadi - dua objek "ditangguhkan di udara" (kecuali, tentu saja, Anda tidak memeriksa kasus ini secara terpisah setiap kali). Situasi lain: melepas pawang; dua objek baru juga dibuat untuk mencari yang sama (sama) dalam daftar event handler; penangan yang ditemukan dari daftar, tentu saja, dihapus (jika ada), dan yang sementara ini, dibuat untuk pencarian dan terdiri dari dua objek, sekali lagi "di udara". Secara umum, tidak keren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beralih ke </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointer cerdas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kita perlu menentukan semantik kepemilikan masing-masing dari dua objek handler nantinya: kepemilikan tunggal ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) atau dibagikan ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemegang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, selain menggunakan acara itu sendiri ketika menambahkan / menghapusnya harus disimpan di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , oleh karena itu kami gunakan untuk kepemilikan bersama, dan untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler itu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah satu-satunya, karena setelah pembuatan, itu akan disimpan hanya dalam daftar penangan acara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyadari ide ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventHandler() {} . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;THandlerPtr&lt;Types...&gt;&gt;( some ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class">&lt;std::shared_ptr&lt;TPtr&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TPtr&gt; some ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; bool operator+=( TSome&amp;&amp; some ) { return addHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool addHandler( TEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TEventHandlerPtr eventHandler ) = 0; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TEventHandlerPtr&gt;::const_iterator; public: TEvent() { . . . } ~TEvent() { // empty } protected: virtual bool addHandler( TEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TEventHandlerPtr eventHandler ) override { . . . } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TEventHandlerPtr&gt; m_handlers; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethodHolderPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TMethodHolder&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TMethodHolderPtr m_methodHolder; . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodHolder( TObject&amp; object, TMethod method ) { . . . } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( <span class="hljs-comment"><span class="hljs-comment">/*   ? */</span></span> ) ); } . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodHolder&lt;TObject, TParams...&gt;( object, method ) ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal pertama yang pertama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memulai, acara dan antarmuka untuk bekerja dengan penangan. Dalam yang terakhir, Anda </font><font style="vertical-align: inherit;">tidak </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lagi </font><font style="vertical-align: inherit;">mengkonversi jenis secara langsung dengan menggunakan </font><i><font style="vertical-align: inherit;">static_cast</font></i><font style="vertical-align: inherit;"> , karena jenis yang dikonversi terletak ‚Äúdi dalam‚Äù </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sekarang, untuk konversi seperti itu, kita akan menggunakan struktur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tambahan </font><font style="vertical-align: inherit;">, yang, dengan spesialisasi pribadinya, akan memberikan akses ke objek di dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan sudah bekerja dengannya (dalam implementasi non-khusus), ia akan menerapkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lama yang baik </font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acara itu sendiri; Ada beberapa perubahan penting di sini juga. Pertama, kami akan berhenti secara manual menghapus instance handler di destructor dan ketika menghapus; sekarang cukup untuk menghapus pointer pintar dengan penangan ini dari daftar. Selain itu, ketika menambahkan handler, penting untuk tidak melupakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: move</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak mendukung penyalinan (yang cukup logis untuk semantik seperti itu). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita beralih ke penangan. Menurut tradisi lama, hanya satu yang diberikan, yang kedua serupa. Dan di sini, pada pandangan pertama, semuanya bermuara pada mengubah jenis objek yang disimpan / dibuat dari tautan / pointer ke pointer pintar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi ada satu titik halus. Fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">createMethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan mengembalikan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke instance</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Beberapa saat kemudian, suatu usaha akan dilakukan untuk mengubahnya menjadi tipe handler ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), di mana ia harus membuat instance baru dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , meneruskannya ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> constructor </font><font style="vertical-align: inherit;">pada dirinya sendiri. Inilah yang dimaksudkan untuk instance </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk </font><i><font style="vertical-align: inherit;">dihapus</font></i><font style="vertical-align: inherit;"> nanti ketika instance </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler dihapus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tetapi masalahnya adalah bahwa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak </font><i><font style="vertical-align: inherit;">memiliki</font></i><font style="vertical-align: inherit;"> akses ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang </font><font style="vertical-align: inherit;">sudah dibuat </font><font style="vertical-align: inherit;">yang menyimpannya sendiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatasi masalah, Anda harus menyimpan </font><font style="vertical-align: inherit;">pointer pintar untuk diri sendiri </font><font style="vertical-align: inherit;">di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Namun, agar tidak memengaruhi penghapusannya, kami gunakan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: lemah_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( object, method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } TObject&amp; m_object; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;TObject, TParams...&gt;::create( object, method ); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk lebih jelasnya, saya akan memberikan perkiraan urutan kejadian saat menghapus pawang dari suatu acara (permintaan maaf saya untuk kata-kata acak): </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peristiwa menghapus item dari daftar ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_handlers.erase (it);</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), yang menyebabkan destruktornya disebut;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destructor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr dipanggil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang mengarah ke panggilan ke destruktor objek yang dikelola;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destructor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler disebut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menghapus semua bidang objek, termasuk bidang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_methodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li>   <i>std::shared_ptr</i> ;  ,      (..         )      ( <i>MethodHolder</i> );      ,     <i>std::weak_ptr</i>    ; </li><li>   <i>MethodHolder</i> ,      ,   ,  <i>m_me</i> ,  <i>std::weak_ptr</i> ; </li><li>   <i>std::weak_ptr</i> ;     ; ..   <i>std::weak_ptr</i>   ,    ; </li><li> . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk diingat bahwa destruktor dari kelas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus virtual; </font><font style="vertical-align: inherit;">jika tidak, setelah klausa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada klausa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , destruktor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan dipanggil </font><font style="vertical-align: inherit;">dan tindakan lebih lanjut tidak akan dilakukan.</font></font><br><br><a name="Joins"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koneksi event dan handler </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam beberapa kasus, ketika menambahkan / menghapus satu handler dari suatu peristiwa cukup sering terjadi (berdasarkan beberapa logika), Anda tidak ingin repot, mendapatkan instance dari event tersebut dan instance dari handler setiap kali, untuk sekali lagi menerapkan berlangganan / berhenti berlangganan dari event ini. </font><font style="vertical-align: inherit;">Tapi saya ingin menghubungkan mereka sekali, dan kemudian, jika perlu, bekerja dengan koneksi ini, menambahkan / menghapus dengan itu handler yang telah ditentukan dari acara yang telah ditentukan. </font><font style="vertical-align: inherit;">Anda dapat menerapkan ini sebagai berikut:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class">&lt;TParams...&gt;;</span></span> . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( findEventHandler( eventHandler ) != m_handlers.end() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { . . . } std::list&lt;TEventHandlerPtr&gt; m_handlers; mutable std::shared_mutex m_handlerListMutex; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, THandlerPtr&lt;TParams...&gt; handler ) : m_event( _event ), m_handler( handler ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.isHandlerAdded( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.addHandler( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.removeHandler( m_handler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: IEvent&lt;TParams...&gt;&amp; m_event; THandlerPtr&lt;TParams...&gt; m_handler; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, sekarang tempat lain yang memungkinkan untuk menyimpan instance dari handler telah ditambahkan, jadi kami akan menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alih-alih </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk ini </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, kelas ini, bagi saya, sedikit tidak nyaman untuk digunakan. Saya ingin menyimpan dan membuat instance koneksi tanpa daftar parameter yang instantiate template kelas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menerapkan ini menggunakan kelas leluhur abstrak dan pembungkus:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventJoin() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventJoin() {} };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventJoin { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> ) :</span></span> m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_eventJoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ } ~EventJoinWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m_eventJoin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isJoined(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAssigned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; m_eventJoin-&gt;isJoined() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;join() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;unjoin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: AbstractEventJoin* m_eventJoin; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EventJoin = EventJoinWrapper;</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah struktur pendukung yang sama yang digunakan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ngomong-ngomong, penting untuk tidak lupa membuat destruktor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virtual sehingga ketika Anda menghapus instansinya di </font><font style="vertical-align: inherit;">destruktor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , destruktor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerEventJoin disebut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , jika tidak bidang </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">THandlerPtr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan, oleh karena itu, pawang itu sendiri </font><font style="vertical-align: inherit;">tidak akan dihancurkan </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi ini tampaknya bisa diterapkan, tetapi hanya pada pandangan pertama. Menyalin atau memindahkan instance dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan menghapus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_eventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di destruktornya </font><font style="vertical-align: inherit;">lagi </font><font style="vertical-align: inherit;">. Oleh karena itu, kami menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menyimpan instance</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , serta mengimplementasikan semantik gerakan yang sedikit dioptimalkan (dan menyalin), karena </font><font style="vertical-align: inherit;">ini akan berpotensi operasi sering.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) : m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ) ) { } EventJoinWrapper( EventJoinWrapper&amp; other ) : m_eventJoin( other.m_eventJoin ) { } ~EventJoinWrapper() { <span class="hljs-comment"><span class="hljs-comment">/*empty*/</span></span> } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( EventJoinWrapper&amp;&amp; other ) { m_eventJoin = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventJoinWrapper&amp; other ) { m_eventJoin = other.m_eventJoin; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventJoin&gt; m_eventJoin; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang saat menghubungkan pawang ke suatu peristiwa, Anda dapat segera mengembalikan instance koneksi baru: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-function"><span class="hljs-function">EventJoin </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;TSome&gt;( some ) )</span></span></span></span>; result.join(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } . . . };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan setelah menyelesaikan ketergantungan segitiga dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyertakan </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(IEvent &lt;= EventJointWrapper.hpp; EventJointWrapper &lt;= HandlerEventJoin.hpp; HandlerEventJoin &lt;= IEvent.hpp) dengan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membagi beberapa file menjadi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.hpp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda bahkan dapat bekerja dengan ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membuat instance koneksi mengikuti aturan yang sama yang berfungsi saat event handler berlangganan:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder _methodsHolder; EventJoin join1 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method1 ) ); <span class="hljs-comment"><span class="hljs-comment">// ok EventJoin join2 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method2 ) ); // ok EventJoin join3 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method3 ) ); // error EventJoin join4 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method4 ) ); // error EventJoin join5 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method5 ) ); // error return 0; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus, Anda dapat "mengaktifkan" / "menonaktifkan" pemrosesan acara (yang, pada prinsipnya, koneksi dibuat): </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Text '"</span></span> &lt;&lt; text &lt;&lt; <span class="hljs-string"><span class="hljs-string">"' handled "</span></span> &lt;&lt; count &lt;&lt; <span class="hljs-string"><span class="hljs-string">" times."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder methodsHolder; EventJoin eventJoin = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( methodsHolder, MethodsHolder::handleEvent ) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> handlingText = <span class="hljs-string"><span class="hljs-string">"testing..."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( eventJoin.isJoined() ) eventJoin.unjoin(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> eventJoin.join(); _eventHolder.onEvent( handlingText, i ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">0</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">2</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">4</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">6</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">8</span></span> times.</code> </pre><br><a name="Totals"></a><h1>  Ringkasan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, perlu dicatat bahwa tugas menulis artikel sesingkat mungkin dan secara singkat gagal total. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya berharap implementasi dari pemrosesan acara yang dihasilkan cukup fungsional dan akan bermanfaat bagi setidaknya seseorang.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh yang sangat rumit yang menunjukkan fitur utama</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "events/event.hpp" #include "events/handler/methodeventhandler.hpp" #include "events/handler/functoreventhandler.hpp" #include "events/join/handlereventjoin.hpp" #include "events/join/eventjoinwrapper.hpp" class Foo { public: Foo() : onMake( m_onMake ), m_onMake(), m_onMakeInner(), m_makeCount( 0 ) { m_onMakeInner += FUNCTOR_HANDLER( m_onMake ); } IEvent&lt;unsigned int&gt;&amp; onMake; void make() { m_onMakeInner( m_makeCount++ ); } private: TEvent&lt;unsigned int&gt; m_onMake, m_onMakeInner; unsigned int m_makeCount; }; namespace instances { Foo&amp; getFoo() { static Foo _foo; return _foo; } } // instances struct FunctorHandler { void operator()( unsigned int makeCount ); }; void functionHandler( unsigned int makeCount ); class ClassHandler { public: void handle( unsigned int makeCount ); }; namespace instances { FunctorHandler&amp; getFunctorHandler() { static FunctorHandler _functorHandler; return _functorHandler; } std::function&lt;void( unsigned int )&gt;&amp; getStdFunctionHandler() { static std::function&lt;void( unsigned int )&gt; _stdFunctionHandler = []( unsigned int makeCount ) { std::cout &lt;&lt; "It's std::function handler" &lt;&lt; std::endl; if( makeCount &gt;= 2 ) instances::getFoo().onMake -= STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); }; return _stdFunctionHandler; } ClassHandler&amp; getClassHandler() { static ClassHandler _classHandler; return _classHandler; } } // instances void FunctorHandler::operator()( unsigned int makeCount ) { std::cout &lt;&lt; "It's functor handler" &lt;&lt; std::endl; if( makeCount &gt;= 0 ) instances::getFoo().onMake -= FUNCTOR_HANDLER( instances::getFunctorHandler() ); } void functionHandler( unsigned int makeCount ) { std::cout &lt;&lt; "It's function handler" &lt;&lt; std::endl; if( makeCount &gt;= 3 ) instances::getFoo().onMake -= FUNCTION_HANDLER( functionHandler ); } void ClassHandler::handle( unsigned int makeCount ) { std::cout &lt;&lt; "It's method handler" &lt;&lt; std::endl; if( makeCount &gt;= 4 ) instances::getFoo().onMake -= MY_METHOD_HANDLER( ClassHandler::handle ); } int main( int argc, char* argv[] ) { Foo&amp; foo = instances::getFoo(); auto lambdaHandler = []( unsigned int ) { std::cout &lt;&lt; "It's lambda handler" &lt;&lt; std::endl; }; foo.onMake += FUNCTOR_HANDLER( instances::getFunctorHandler() ); foo.onMake += LAMBDA_HANDLER( lambdaHandler ); EventJoin lambdaJoin = foo.onMake += LAMBDA_HANDLER( ( [ &amp;foo, &amp;lambdaHandler ]( unsigned int makeCount ) { if( makeCount &gt;= 1 ) foo.onMake -= LAMBDA_HANDLER( lambdaHandler ); } ) ); foo.onMake += STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); foo.onMake += FUNCTION_HANDLER( functionHandler ); foo.onMake += METHOD_HANDLER( instances::getClassHandler(), ClassHandler::handle ); for( int i = 0; i &lt; 6; ++i ) { std::cout &lt;&lt; "Make " &lt;&lt; i &lt;&lt; " time:" &lt;&lt; std::endl; foo.make(); std::cout &lt;&lt; std::endl; } lambdaJoin.unjoin(); return 0; }</span></span></span></span></code> </pre><br>  Kesimpulan: <br><br><pre> <code class="hljs powershell">Make <span class="hljs-number"><span class="hljs-number">0</span></span> time: It<span class="hljs-string"><span class="hljs-string">'s functor handler It'</span></span>s lambda handler It<span class="hljs-string"><span class="hljs-string">'s std::function handler It'</span></span>s <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">2</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">std</span></span></span><span class="hljs-function">::</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">3</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">4</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">It</span></span></span><span class="hljs-function">'</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">5</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-function">:</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perlu dicatat beberapa poin penting: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu tidak ditentukan secara terpisah, jadi saya akan menyebutkan bahwa acara itu sendiri dalam implementasi ini adalah functor, yang berarti dapat bertindak sebagai penangan untuk acara lain; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang Anda tidak dapat menggunakan metode konstan (fungsi anggota kelas) sebagai penangan; </font><font style="vertical-align: inherit;">Saya pikir jika kesempatan seperti itu diperlukan, tidak sulit untuk menulis jenis penangan baru untuk ini berdasarkan yang sudah ada.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Selain itu, dalam versi final ada beberapa poin yang dihilangkan dalam artikel untuk visibilitas dan keterbacaan kode yang lebih besar: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jenis nilai pengembalian metode (fungsi anggota kelas) untuk penangan yang sesuai dapat berupa apa saja, tidak harus </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">batal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (untuk penangan-fungsi, ini juga dilakukan)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seluruh implementasi dibungkus dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">namespaces</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk kemudahan penggunaan dalam proyek (jika ini tampaknya berlebihan bagi seseorang, Anda selalu dapat menghapusnya);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specifier </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noexcept</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> telah ditambahkan di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">beberapa tempat</font></a><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk semua yang telah membaca di sini setidaknya secara diagonal, busur rendah. </font><font style="vertical-align: inherit;">Saya lampirkan semua kode; </font><font style="vertical-align: inherit;">itu juga dapat diambil di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dengan semua perbaikan terbaru).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seluruh kode</font></font></b> <div class="spoiler_text"><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/helpers/is_equatable.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; template&lt;class T&gt; class is_equatable { private: template&lt;class U&gt; static constexpr std::true_type exists( decltype( std::declval&lt;U&gt;() == std::declval&lt;U&gt;() )* = nullptr ) noexcept; template&lt;class U&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;T&gt;( nullptr ) )::value; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/abstracteventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { namespace handlers { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class AbstractEventHandler { using MyType = AbstractEventHandler&lt;TParams...&gt;; public: virtual ~AbstractEventHandler() {} virtual void call( TParams... params ) = 0; bool operator==( const MyType&amp; other ) const noexcept { return isEquals( other ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } protected: AbstractEventHandler() {} virtual bool isEquals( const MyType&amp; other ) const noexcept = 0; }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/eventhandlerptr.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace events { namespace handlers { template&lt;class ...TParams&gt; class AbstractEventHandler; template&lt;class ...Types&gt; using TEventHandlerPtr = std::shared_ptr&lt;AbstractEventHandler&lt;Types...&gt;&gt;; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/functoreventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" #include "../helpers/is_equatable.hpp" namespace events { namespace handlers { namespace { template&lt;class TFunctor, class ...TParams&gt; struct IsFunctorParamsCompatible { private: template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( std::declval&lt;TCheckedFunctor&gt;()( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TFunctor, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TFunctor&gt; class FunctorHolder; template&lt;class TFunctor, class ...TParams&gt; class FunctorEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; using TFunctorHolderPtr = std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt;; public: FunctorEventHandler( TFunctorHolderPtr functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { assert( m_functorHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, "Event and functor arguments are not compatible" ); m_functorHolder-&gt;m_functor( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } private: TFunctorHolderPtr m_functorHolder; }; namespace { template&lt;class TEqu, class TEnabled = void&gt; struct EqualityChecker; template&lt;class TEquatable&gt; struct EqualityChecker&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TEquatable&amp; operand1, const TEquatable&amp; operand2 ) noexcept { return ( operand1 == operand2 ); } }; template&lt;class TNonEquatable&gt; struct EqualityChecker&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TNonEquatable&amp; operand1, const TNonEquatable&amp; operand2 ) noexcept { return ( &amp;operand1 == &amp;operand2 ); } }; } // template&lt;class TFunctor&gt; class FunctorHolder { using MyType = FunctorHolder&lt;TFunctor&gt;; public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TFunctor&gt; static std::shared_ptr&lt;MyType&gt; create( TFunctor&amp;&amp; functor ) { std::shared_ptr&lt;MyType&gt; result( new MyType( functor ) ); result-&gt;m_me = result; return result; } private: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ), m_me() { } TFunctor&amp; m_functor; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TFunctor, class ...TParams&gt; friend class FunctorEventHandler; }; template&lt;class TFunctor&gt; std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt; createFunctorEventHandler( TFunctor&amp;&amp; functor ) { return FunctorHolder&lt;TFunctor&gt;::create( functor ); } } // handlers } // events #define FUNCTOR_HANDLER( Functor ) ::events::handlers::createFunctorEventHandler( Functor ) #define LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #define STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #define FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/methodeventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" namespace events { namespace handlers { namespace { template&lt;class TMethodHolder, class ...TParams&gt; struct IsMethodParamsCompatible { private: template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( ( std::declval&lt;TCheckedMethodHolder&gt;().m_object.*std::declval&lt;TCheckedMethodHolder&gt;().m_method )( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TMethodHolder, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = MethodEventHandler&lt;TMethodHolder, TParams...&gt;; using TMethodHolderPtr = std::shared_ptr&lt;TMethodHolder&gt;; public: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_object.*m_methodHolder-&gt;m_method )( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_methodHolder == *_other-&gt;m_methodHolder ); } private: TMethodHolderPtr m_methodHolder; }; template&lt;class TObject, class TResult, class ...TParams&gt; class MethodHolder { using MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; using TMethod = TResult( TObject::* )( TParams... ); public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return ( &amp;m_object == &amp;other.m_object &amp;&amp; m_method == other.m_method ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TObject, class ...TParams&gt; static std::shared_ptr&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { std::shared_ptr&lt;MyType&gt; result( new MyType( object, method ) ); result-&gt;m_me = result; return result; } private: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != nullptr ); } TObject&amp; m_object; TMethod m_method; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TMethodHolder, class ...TParams&gt; friend class MethodEventHandler; template&lt;class TMethodHolder, class ...TParams&gt; friend struct IsMethodParamsCompatible; }; template&lt;class TObject, class TResult, class ...TParams&gt; std::shared_ptr&lt;MethodHolder&lt;TObject, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, TResult( TObject::*method )( TParams... ) ) { return MethodHolder&lt;TObject, TResult, TParams...&gt;::create( object, method ); } } // handlers } // events #define METHOD_HANDLER( Object, Method ) ::events::handlers::createMethodEventHandler( Object, &amp;Method ) #define MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/handlers/handlercast.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "eventhandlerptr.h" namespace events { namespace handlers { template&lt;class TSome&gt; struct HandlerCast { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( TSome&amp; some ) { return static_cast&lt;TEventHandlerPtr&lt;Types...&gt;&gt;( some ); } }; template&lt;class TPtr&gt; struct HandlerCast&lt;std::shared_ptr&lt;TPtr&gt;&gt; { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( std::shared_ptr&lt;TPtr&gt; some ) { return HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/event.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include &lt;list&gt; #include &lt;memory&gt; #include &lt;shared_mutex&gt; #include &lt;algorithm&gt; #include &lt;assert.h&gt; #include "handlers/abstracteventhandler.hpp" #include "handlers/eventhandlerptr.h" #include "handlers/handlercast.hpp" #include "joins/eventjoinwrapper.hpp" namespace events { namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin; } template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; EventJoin operator+=( TSome&amp;&amp; some ) { EventJoin result( *this, std::forward&lt;TSome&gt;( some ) ); result.join(); return result; } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TMyEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const = 0; virtual bool addHandler( TMyEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) = 0; friend class joins::HandlerEventJoin&lt;TParams...&gt;; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TMyEventHandlerPtr&gt;::const_iterator; public: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( false ), m_handlerListMutex() { } void operator()( TParams... params ) { m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = false; m_currentIt = m_handlers.begin(); while( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); if( m_isCurrentItRemoved ) { m_isCurrentItRemoved = false; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } else { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); return ( findEventHandler( eventHandler ) != m_handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); auto it = findEventHandler( eventHandler ); if( it != m_handlers.end() ) { if( it == m_currentIt ) m_isCurrentItRemoved = true; else deleteHandler( it ); return true; } return false; } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const noexcept { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TMyEventHandlerPtr&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; }; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/abstracteventjoin.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once namespace events { namespace joins { class AbstractEventJoin { public: virtual ~AbstractEventJoin(); virtual bool isJoined() const = 0; virtual bool join() = 0; virtual bool unjoin() = 0; protected: AbstractEventJoin(); }; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/abstracteventjoin.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { AbstractEventJoin::AbstractEventJoin() { } AbstractEventJoin::~AbstractEventJoin() { } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/handlereventjoin.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class IEvent; namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin : public AbstractEventJoin { public: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; handler ) : AbstractEventJoin(), m_event( _event ), m_handler( handler ) { } virtual inline bool isJoined() const override; virtual inline bool join() override; virtual inline bool unjoin() override; private: IEvent&lt;TParams...&gt;&amp; m_event; ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; m_handler; }; } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/handlereventjoin.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::isJoined() const { return m_event.isHandlerAdded( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::join() { return m_event.addHandler( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::unjoin() { return m_event.removeHandler( m_handler ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "../handlers/eventhandlerptr.h" namespace events { template&lt;class ...TParams&gt; class IEvent; namespace joins { class AbstractEventJoin; class EventJoinWrapper { public: template&lt;class TSome, class ...TParams&gt; inline EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ); constexpr EventJoinWrapper() noexcept; EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept; EventJoinWrapper&amp; operator=( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper&amp; operator=( const EventJoinWrapper&amp; other ) noexcept; operator bool() const; bool isAssigned() const; bool isJoined() const; bool join(); bool unjoin(); private: std::shared_ptr&lt;AbstractEventJoin&gt; m_eventJoin; }; } // joins using EventJoin = joins::EventJoinWrapper; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/handlercast.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class TSome, class ...TParams&gt; EventJoinWrapper::EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ) : m_eventJoin( std::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, ::events::handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include "abstracteventjoin.h" namespace events { namespace joins { constexpr EventJoinWrapper::EventJoinWrapper() noexcept : m_eventJoin( nullptr ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept : m_eventJoin( std::move( other.m_eventJoin ) ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept : m_eventJoin( other.m_eventJoin ) { } EventJoinWrapper&amp; EventJoinWrapper::operator=( EventJoinWrapper&amp;&amp; other ) noexcept { m_eventJoin = std::move( other.m_eventJoin ); return *this; } EventJoinWrapper&amp; EventJoinWrapper::operator=( const EventJoinWrapper&amp; other ) noexcept { m_eventJoin = other.m_eventJoin; return *this; } EventJoinWrapper::operator bool() const { return isJoined(); } bool EventJoinWrapper::isAssigned() const { return ( m_eventJoin != nullptr ); } bool EventJoinWrapper::isJoined() const { return ( m_eventJoin != nullptr &amp;&amp; m_eventJoin-&gt;isJoined() ); } bool EventJoinWrapper::join() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;join() : false ); } bool EventJoinWrapper::unjoin() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;unjoin() : false ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini dan sebelumnya dalam artikel, kode yang ditulis di bawah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VC ++ 14 diberikan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Untuk kompatibilitas dengan kompiler lain, lebih baik mengambil kode dari tautan. </font><font style="vertical-align: inherit;">Terima kasih khusus kepada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheater</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> karena memberikan kompatibilitas dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><a name="ThreadRev"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terima kasih </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexxmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> karena </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melihat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada lubang pengaman untuk beberapa panggilan acara secara bersamaan.</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbaikan kecil</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeHelper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandlerPtr&gt;::const_iterator; }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { . . . protected: using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; . . . }; namespace { template&lt;class ...TParams&gt; struct EventCore { using TMyHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; std::list&lt;TMyHandlerPtr&gt; handlers; mutable std::shared_mutex coreMutex; }; template&lt;class ...TParams&gt; class HandlerRunner { using TMyEventCore = EventCore&lt;TParams...&gt;; using TMyHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; public: HandlerRunner( TMyEventCore&amp; eventCore ) : m_eventCore( eventCore ), currentIt(), wasRemoving( false ) { } void run( TParams... params ) { m_eventCore.coreMutex.lock_shared(); currentIt = m_eventCore.handlers.begin(); wasRemoving = false; while( currentIt != m_eventCore.handlers.end() ) { m_eventCore.coreMutex.unlock_shared(); ( *currentIt )-&gt;call( params... ); m_eventCore.coreMutex.lock_shared(); if( wasRemoving ) wasRemoving = false; else ++currentIt; } m_eventCore.coreMutex.unlock_shared(); } TMyHandlerIt currentIt; mutable bool wasRemoving; private: TMyEventCore&amp; m_eventCore; }; } // template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; using TMyEventHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; using TMyHandlerRunner = HandlerRunner&lt;TParams...&gt;; public: TEvent() : m_core() { } void operator()( TParams... params ) { TMyHandlerRunner newHandlerRunner( m_core ); m_core.coreMutex.lock_shared(); auto it = m_handlerRunners.insert( m_handlerRunners.end(), &amp;newHandlerRunner ); m_core.coreMutex.unlock_shared(); newHandlerRunner.run( params... ); m_core.coreMutex.lock_shared(); m_handlerRunners.erase( it ); m_core.coreMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); return ( findEventHandler( eventHandler ) != m_core.handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); if( findEventHandler( eventHandler ) == m_core.handlers.end() ) { m_core.handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); auto it = findEventHandler( eventHandler ); if( it != m_core.handlers.end() ) { for( TMyHandlerRunner* oneHandlerRunner : m_handlerRunners ) { if( it == oneHandlerRunner-&gt;currentIt ) { ++oneHandlerRunner-&gt;currentIt; oneHandlerRunner-&gt;wasRemoving = true; } } m_core.handlers.erase( it ); return true; } return false; } private: //      'm_core.coreMutex' inline TMyEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_core.handlers.cbegin(), m_core.handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } EventCore&lt;TParams...&gt; m_core; std::list&lt;TMyHandlerRunner*&gt; m_handlerRunners; };</span></span></code> </pre><br>        (,  ,     )    <i>HandlerRunner</i> ,       . ,     : <i>currentIt</i> (    )  <i>wasRemoving</i> (,        ).   <i>HandlerRunner'</i>          <i>operator()</i> ;        (,  )  ,    <i>EventCore</i> .  T.O.      ,   ,        ,     ,         ,       . <br></div></div><a name="HolderImprovement"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD3. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isnullxbh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kesalahan lain ditemukan. </font><font style="vertical-align: inherit;">Hal ini terhubung dengan perlakuan yang salah dan penahan berikutnya benda ditransfer melalui </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai p</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (terutama ekspresi lambda).</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koreksi</font></font></b> <div class="spoiler_text">     ,   <i>lvalue</i> ,  <i>lvalue</i> -,  ,   <i>rvalue</i> ,   (,  ).      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;LValue&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = LValue&amp;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;RValue&amp;&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = RValue; };</code> </pre><br>  <i>Holder</i>           ( <i>lvalue</i>  <i>rvalue</i> ),        ,  ¬´¬ª     .     <i>type erasing</i> (   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ).   ,   <i>Holder'</i>   . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractInnerHolder() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;AbstractInnerHolder&lt;TBase&gt;&amp;&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).get(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInnerHolder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractInnerHolder&lt;TBase&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TInnerObject = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjectSaver&lt;TInner&gt;::TObject; TInnerHolder( TInner _inner ) : AbstractInnerHolder&lt;TBase&gt;(), inner( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TInner&gt;( _inner ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TBase&amp;&gt;( inner ); } TInnerObject inner; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TAssignBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class">&lt;TAssignBase&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createInnerHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inner</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TAssignInner = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( inner ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TInnerHolder&lt;TAssignBase, TAssignInner&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgInner&gt;( inner ) ); }</code> </pre><br>      <i>Holder'</i> .    <i>MethodHolder'</i> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = TResult( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~MethodHolder() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> &amp;m_innerHolder; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;m_innerHolder.get() == &amp;other.m_innerHolder.get() &amp;&amp; m_method == other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TArgObject&amp;&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ), method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethod</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class"> ) :</span></span> m_innerHolder( createInnerHolder&lt;TObject&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ) ) ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } AbstractInnerHolder&lt;TObject&gt;&amp; m_innerHolder; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMethodParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( ( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_innerHolder.get().*</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_method )( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; . . . }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { public: virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_innerHolder.get().*m_methodHolder-&gt;m_method )( params... ); } private: TMethodHolderPtr m_methodHolder; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp;&amp; object, TResult( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;::create( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TObject&gt;( object ), method ); }</code> </pre><br>  Selesai <i>FunctorHolder</i>   .        .    -    . <br></div></div><br><a name="Qt"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Perbandingan dengan mekanisme sinyal / slot Qt </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir saya tidak akan salah jika saya mengatakan bahwa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah kerangka kerja yang sangat umum untuk berkembang di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Antara lain, ia juga memiliki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mekanisme pemrosesan peristiwa sendiri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana ada sinyal sebagai analog peristiwa dan slot sebagai analog penangan. </font><font style="vertical-align: inherit;">Ini diimplementasikan menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object Compiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang merupakan bagian dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object System</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang </font><font style="vertical-align: inherit;">lebih global </font><font style="vertical-align: inherit;">, yang, pada gilirannya, diimplementasikan menggunakan </font><font style="vertical-align: inherit;">add-on yang </font><font style="vertical-align: inherit;">digunakan dalam </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fitur kedua implementasi: </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kemampuan untuk menghubungkan sinyal (peristiwa) ke metode (fungsi anggota), fungsi dan fungsi; </font></font></li><li>     ()  (),        ( <i>lvalue</i> , <i>rvalue</i> ); </li><li>      (  ); </li><li>    ()      (   ). </li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   ;</i> <br>  <i>Qt</i>          ;     ¬´¬ª,  ,     ¬´ ¬ª  ;   ,        ; ,       ; <br></li><li> <i>    ;</i> <br>   <i>Qt</i>          (    )      (    );        ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt::UniqueConnection</a> ;      ,        ,  ,  <i>Qt</i>        ; <br></li><li> <i>     ,   ;</i> <br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt::QueuedConnection</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt::BlockingQueuedConnection</a>     ;      ()       ;          ();    ,         ,         ;  yaitu   ,           ; ,       . <br></li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QObject</a> ;</i> <br>    , ,   <i>QObject</i> ,     ,  ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> : <i>Virtual inheritance with QObject is not supported.</i> );    ,   ,  ; <br></li><li> <i>   template';</i> <br>        ,     <i>public</i> - <i>QObject</i> ;     <i>moc'</i> ; ,    <br><div class="spoiler"> <b class="spoiler_title">,</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; class AbstractProperty : public QObject { Q_OBJECT protected: AbstractProperty(); signals: void valueChanged(); }; template&lt;class TSource&gt; class TProperty : public AbstractProperty { public: TProperty( const TSource&amp; value = TSource() ) : AbstractProperty(), m_value( value ) { } const TSource&amp; value() const { return m_value; } void setValue( const TSource&amp; newValue ) { if( newValue != m_value ) { m_value = newValue; emit valueChanged(); } } private: TSource m_value; };</span></span></span></span></code> </pre><br>  ,  <i>valueChanged</i>    (  ,  )  ,        . <br></div></div> ,   ,     ; <br></li><li> <strike><i>     .cpp-;</i></strike> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ; <br></li><li> <i>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QMetaObject::Connection</a> ;</i> <br>    ,  <i>Qt</i>   (   )    ,    ;      ()   ,    ,           ;            ,          ;  <i>Qt</i>     ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penggunaan </font><font style="vertical-align: inherit;">kode </font><font style="vertical-align: inherit;">tambahan yang dihasilkan </font><font style="vertical-align: inherit;">oleh </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini sudah sepenuhnya subjektif, tetapi keputusannya adalah, di mana untuk setiap kelas yang menggunakan sinyal dan slot (slot tidak selalu) ada beberapa (berdasarkan file untuk setiap konfigurasi) file yang dihasilkan yang menyebabkan beberapa ketidaknyamanan; </font><font style="vertical-align: inherit;">tapi jujur ‚Äã‚Äãsaja, ini adalah kekurangan yang paling kecil.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penting untuk dicatat bahwa perbandingan dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini sangat subyektif dan tidak bertujuan meninggikan atau mengutuk kerangka kerja ini. </font><font style="vertical-align: inherit;">Harus diingat bahwa selain mekanisme sinyal / slot, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memberikan fungsionalitas yang hebat, baik menggunakan mekanisme ini dan tidak bergantung padanya. </font><font style="vertical-align: inherit;">Bagaimanapun, selalu terserah Anda untuk memutuskan apa yang akan digunakan dan apa yang tidak.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424593/">https://habr.com/ru/post/id424593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424583/index.html">Anda tidak akan menjadi pahlawan jika Anda seorang pengembang</a></li>
<li><a href="../id424585/index.html">CryEngine 5.5 dirilis oleh Crytek</a></li>
<li><a href="../id424587/index.html">Ringkasan buku "Penjualan ke perusahaan besar"</a></li>
<li><a href="../id424589/index.html">Bagaimana cara mendaftar dalam program pembelajaran mesin PhD</a></li>
<li><a href="../id424591/index.html">Tidak ada yang ideal: bagaimana saya mencari bahasa pemrograman untuk diri saya sendiri</a></li>
<li><a href="../id424595/index.html">MVC + Skenario vs Pengontrol Lemak</a></li>
<li><a href="../id424597/index.html">Wawancara dengan Pembicara Konferensi Ruby Rusia Marcus Schirp</a></li>
<li><a href="../id424599/index.html">Anda harus memilih perangkat lunak mana yang Anda butuhkan: ditulis tepat waktu atau berkualitas tinggi</a></li>
<li><a href="../id424601/index.html">Arsitektur informasi di Internet bagian 1</a></li>
<li><a href="../id424603/index.html">Buku ‚ÄúMengapa kita salah? Berpikir Perangkap dalam Tindakan. " Kutipan Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>