<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏽 👊🏼 🅱️ DevOps d'entreprise: comment une grande entreprise collecte des microservices 👨🏽‍🚒 🏮 📰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! 


 Netracker développe et fournit des applications d'entreprise pour le marché mondial des opérateurs de télécommunications depuis de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevOps d'entreprise: comment une grande entreprise collecte des microservices</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/netcracker/blog/421423/"><p>  Bonjour à tous! </p><br><p>  Netracker développe et fournit des applications d'entreprise pour le marché mondial des opérateurs de télécommunications depuis de nombreuses années.  Le développement de telles solutions est assez compliqué: des centaines de personnes participent à des projets, et le nombre de projets actifs par dizaines. </p><br><p>  Auparavant, les produits étaient monolithiques, mais nous nous dirigeons maintenant en toute confiance vers des applications de microservices.  DevOps a été confronté à une tâche plutôt ambitieuse: fournir ce saut technologique. </p><br><p>  En conséquence, nous avons obtenu un concept d'assemblage réussi, que nous voulons partager comme meilleure pratique.  La description de l'implémentation avec les détails techniques sera assez volumineuse; nous ne le ferons pas dans le cadre de cet article. </p><a name="habracut"></a><br><p>  <i>Dans le cas général, l'assemblage est la transformation de certains artefacts en d'autres.</i> <i><br></i> </p><br><h2>  Qui sera intéressé </h2><br><p>  Les entreprises qui fournissent des logiciels prêts à l'emploi à une organisation entièrement tierce et sont rémunérées pour cela. </p><br><p>  Voici à quoi pourrait ressembler un développement sans livraison externe: </p><br><ul><li>  Le service informatique de l'usine développe des logiciels pour son entreprise. </li><li> L'entreprise est engagée dans l'externalisation pour un client étranger.  Le client compile et exploite indépendamment ce code sur son propre serveur Web. </li><li>  L'entreprise fournit des logiciels à des clients externes, mais sous licence open source.  La majeure partie de la responsabilité est ainsi déchargée. </li></ul><br><p>  Si vous n'êtes pas confronté à une offre externe, une grande partie de ce qui est écrit ci-dessous vous semblera redondante, voire paranoïaque. </p><br><p>  Dans la pratique, tout doit être fait conformément aux exigences internationales pour les licences et le cryptage utilisés, sinon des conséquences juridiques au moins se produiront. </p><br><p>  Un exemple de violation consiste à prendre le code d'une bibliothèque avec une licence GPL3 et à l'intégrer dans une application commerciale. </p><br><h2>  L'émergence des microservices nécessite un changement </h2><br><p>  Nous avons acquis une vaste expérience dans l'assemblage et la livraison d'applications monolithiques. </p><br><p>  Plusieurs serveurs Jenkins, des milliers de travaux CI, plusieurs chaînes de montage entièrement automatisées basées sur Jenkins, des dizaines d'ingénieurs de version dédiés, son propre groupe d'experts sur la gestion de la configuration. </p><br><p>  Historiquement, l'approche dans l'entreprise était la suivante: les développeurs écrivent le code source, et DevOps inventent et écrivent la configuration du système d'assemblage. </p><br><p>  En conséquence, nous avions deux ou trois configurations d'assemblage typiques conçues pour fonctionner dans l'écosystème de l'entreprise.  Schématiquement, cela ressemble à ceci: </p><br><img src="https://habrastorage.org/webt/pr/hi/rm/prhirmtpwufl-vfhheebwfaujpg.png"><br><p>  L'outil de construction est généralement ant ou maven, et quelque chose est implémenté par des plug-ins disponibles publiquement, quelque chose est écrit de lui-même.  Cela fonctionne bien lorsqu'une entreprise utilise un ensemble restreint de technologies. </p><br><p>  <i>Les microservices diffèrent des applications monolithiques principalement par la variété des technologies.</i> </p><br><p>  Il s'avère que de nombreuses configurations d'assemblage pour au moins chaque langage de programmation.  Le contrôle centralisé devient impossible. </p><br><p>  Il est nécessaire de simplifier autant que possible les scripts d'assemblage et de permettre aux développeurs de les modifier indépendamment. </p><br><p>  En plus d'une simple compilation et packaging (dans le diagramme en <font color="green">vert</font> ), ces scripts contiennent beaucoup de code pour l'intégration avec l'écosystème de l'entreprise (dans le diagramme en <font color="red">rouge</font> ). </p><br><p>  Par conséquent, il a été décidé de percevoir l'assemblage comme une "boîte noire", dans laquelle un environnement d'assemblage "intelligent" peut résoudre tous les problèmes, à l'exception de la compilation et du conditionnement lui-même. </p><br><p>  Au début des travaux, il n'était pas clair comment obtenir un tel système.  Prendre des décisions architecturales pour les tâches DevOps nécessite de l'expérience et des connaissances.  Comment les obtenir?  Les options possibles sont ci-dessous: </p><br><ul><li>  Recherchez des informations sur Internet. </li><li>  Propre expérience et connaissance de l'équipe DevOps.  Pour ce faire, il est bon de faire de cette équipe de programmeurs une expérience polyvalente. </li><li>  Expérience et connaissances acquises en dehors de l'équipe DevOps.  De nombreux développeurs de l'entreprise ont de bonnes idées - vous devez les entendre.  La communication est utile. </li><li>  Nous inventons et expérimentons! </li></ul><br><h2>  Ai-je besoin d'automatisation? </h2><br><p>  Pour répondre à cette question, vous devez comprendre à quel stade d'évolution sont nos approches d'assemblage.  En général, une tâche passe par les niveaux suivants. </p><br><ol><li>  Niveau inconscient <br><br><img width="150" src="https://habrastorage.org/webt/an/e2/uv/ane2uvhcdznwqj-bncv49oo58p8.jpeg"><br><br><p>  Nous devons sortir un assemblage par semaine, nos gars vont bien.  C'est naturel, pourquoi en parler? </p></li><li>  Le niveau de «l'artisan», se transformant finalement en niveau de «l'escroc» <br><br><img width="150" src="https://habrastorage.org/webt/ck/mc/-a/ckmc-a4-76nvtsanjjwf4ilsf-i.gif"><br><br><p>  Il est nécessaire de produire deux assemblages par jour de manière stable et sans erreur.  Nous avons Vasya, il le fait cool, et personne d'autre que lui ne passe ce temps. </p></li><li>  Niveau manufacture <br><br><img width="150" src="https://habrastorage.org/webt/hw/_x/57/hw_x572z1bstsfv4gcp9ntekdho.jpeg"><br><br><p>  Les choses sont allées loin.  Vous avez besoin de 20 assemblées par jour, Vasya ne peut pas faire face, et maintenant une équipe de dix personnes est déjà assise.  Ils ont un patron, des plans, des vacances, des congés de maladie, de la motivation, du team building, des formations, des traditions et des règles.  Il s'agit d'une spécialisation, leur travail doit être étudié. <br></p><br><p>  À ce niveau, la tâche est séparée de l'exécuteur testamentaire concret et devient ainsi un processus. </p><br><p>  Le résultat sera une description claire, élaborée, rodée et corrigée des centaines de fois du processus avec du texte. </p></li><li>  Le niveau de «production automatisée» <br><br><img width="150" src="https://habrastorage.org/webt/mw/2c/pt/mw2cptkfee3fmatsj6aw-21eka4.jpeg"><br><br><p>  Les exigences modernes pour les assemblages augmentent: tout doit être rapide, fiable, 800 assemblages doivent être fournis par jour.  Cela est essentiel, car sans ces volumes, l'entreprise perdra ses avantages concurrentiels. </p><br><p>  Une automatisation coûteuse est en cours et quelques DevOps qualifiés peuvent maintenir le processus en cours.  Une mise à l'échelle supplémentaire n'est plus un problème. </p></li></ol><br><p>  <i>Toutes les tâches ne doivent pas atteindre la dernière étape de l'automatisation.</i> </p><br><p>  Souvent, un artisan possédant une ligne de commande résout les problèmes facilement et efficacement. </p><br><p>  L'automatisation «fige» le processus, réduit le coût de fonctionnement et augmente le coût du changement. </p><br><p>  Vous pouvez vous rendre directement à l'assemblage de la voiture, mais le système sera gênant, ne suivra pas les exigences de l'entreprise et, par conséquent, deviendra obsolète. </p><br><h2>  Quels sont les assemblages et pourquoi le problème n'est pas résolu par des systèmes d'assemblage prêts à l'emploi <br></h2><br><img src="https://habrastorage.org/webt/0s/s1/dk/0ss1dkrnmpubpcllntnzuuwofw0.png"><br><p>  Nous utilisons la classification suivante pour déterminer les niveaux d'agrégation d'assemblage. <br><br></p><ul><li><p>  L1.  Une petite partie indépendante d'une grande application.  Il peut s'agir d'un composant, d'un microservice ou d'une bibliothèque auxiliaire.  L'assemblage L1 est une solution aux problèmes techniques linéaires: compilation, packaging, travail avec les dépendances.  Maven, gradle, npm, grunt et d'autres systèmes de construction font un excellent travail.  Il y en a des centaines. </p><p>  <i>L'assemblage L1 doit être effectué à l'aide d'outils tiers prêts à l'emploi.</i> </p></li><li><p>  L2 +.  Entités d'intégration.  Les entités L1 sont combinées en formations plus grandes, par exemple, en applications de microservices à part entière.  Plusieurs de ces applications peuvent être regroupées en une seule solution.  Nous utilisons le signe «+», car en fonction du niveau d'agrégation d'assemblage, un niveau L3 ou même L4 peut être attribué. </p><br><p>  Un exemple de tels assemblages dans le monde des tiers est la préparation des distributions Linux.  Méta-packages là-bas. </p><br><p>  En plus de tâches techniques assez complexes (comme celle-ci: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ru.wikipedia.org/wiki/Dependency_hell</a> ).  Les assemblages L2 + sont souvent le produit final et ont donc de nombreuses exigences de processus: un système de droits, la fixation de personnes responsables, l'absence d'erreurs légales, la fourniture de divers documents. </p><br><p>  <i>Chez L2 +, les exigences de processus sont hiérarchisées par l'automatisation.</i> </p><br><p>  Si la solution automatique ne fonctionne pas car elle convient aux personnes intéressées, elle ne sera pas mise en œuvre. </p><br><p>  Les assemblages L2 + seront très probablement réalisés par un outil propriétaire spécifiquement adapté aux processus de l'entreprise.  Pensez-vous que les gestionnaires de packages Linux viennent juste avec ça? </p></li></ul><br><br><h2>  Nos bonnes pratiques </h2><br><h3>  L'infrastructure </h3><br><h4>  Disponibilité permanente de fer </h4><br><p>  L'ensemble de l'infrastructure d'assemblage se trouve sur des serveurs fermés à l'intérieur du réseau d'entreprise.  Dans certains cas, des services cloud commerciaux sont possibles. <br></p><br><h4>  Autonomie </h4><br><p>  Dans tous les processus CI, Internet n'est pas disponible.  Toutes les ressources nécessaires sont mises en miroir et mises en cache en interne.  Partiellement même github.com (merci, npm!) La plupart de ces problèmes sont résolus par Artifactory. </p><br><p>  Par conséquent, nous sommes calmes lors de la suppression d'artefacts de maven central ou de la fermeture de référentiels populaires.  Il y a un exemple: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">community.oracle.com/community/java/javanet-forge-sunset</a> . </p><br><p>  La mise en miroir réduit considérablement le temps d'assemblage et libère le canal Internet d'entreprise.  Moins de ressources réseau critiques augmentent la stabilité de la construction. </p><br><h4>  Trois référentiels pour chaque type d'artefact </h4><br><ol><li>  Dev est un référentiel où n'importe qui peut publier des artefacts de toute origine.  Ici, vous pouvez expérimenter des approches fondamentalement nouvelles sans les adapter aux normes de l'entreprise dès le premier jour. </li><li>  Le staging est un référentiel rempli uniquement avec un pipeline d'assemblage. </li><li>  Libération - assemblages simples, prêts pour une livraison externe.  Il est rempli d'une opération de transfert spéciale avec confirmation manuelle. </li></ol><br><h4>  Règle des 30 jours <br></h4><br><p>  Dans les référentiels Dev et Staging, nous supprimons tout ce qui date de plus de 30 jours.  Cela permet de garantir à tous des opportunités de publication égales en dépensant une quantité limitée d'espace disque sur le serveur. </p><br><p>  La version est stockée pour toujours, l'archivage est effectué si nécessaire. </p><br><h4>  Environnement d'assemblage propre <br></h4><br><p>  Souvent, après les assemblages, les fichiers auxiliaires restent dans le système, ce qui peut affecter d'autres processus d'assemblage.  Exemples typiques: </p><br><ul><li>  le problème le plus courant est un cache endommagé par un assemblage incorrect (comment traiter les caches, décrit ci-dessous); </li><li>  certains utilitaires, tels que npm, laissent des fichiers de service dans le répertoire $ HOME qui affectent tous les lancements ultérieurs de ces utilitaires; </li><li>  un assembly particulier peut dépenser tout l'espace disque d'une partition / tmp, ce qui entraînera une indisponibilité générale de l'environnement. </li></ul><br><p>  Par conséquent, il vaut mieux abandonner l'environnement unifié au profit des conteneurs dockers.  Les conteneurs ne doivent contenir que le logiciel nécessaire pour un assemblage spécifique avec des versions fixes. </p><br><p>  DevOps gère une collection d'images Docker d'assemblage, qui est constamment mise à jour.  Au début, il y en avait environ six, puis c'était moins de 30, puis nous avons mis en place une génération automatique d'images à partir de la liste des logiciels.  Maintenant, spécifiez simplement des exigences telles que require ('maven 3.3.9', 'python') - et l'environnement est prêt. </p><br><h4>  Auto-diagnostic </h4><br><p>  Il n'est pas seulement nécessaire d'organiser le support utilisateur pour les demandes, nous devons analyser nous-mêmes le comportement de notre propre système.  Nous collectons constamment des journaux, recherchons dans ceux-ci des mots clés montrant des problèmes. </p><br><p>  Sur un système "live", il suffit d'écrire 20 à 30 expressions régulières pour que pour chaque assemblage vous puissiez dire la raison de sa chute au niveau: </p><br><ul><li>  Crash du serveur Git </li><li>  l'espace disque est épuisé; </li><li>  erreur de construction due à la faute du développeur; </li><li>  Bug connu dans Docker. </li></ul><br><p>  Si quelque chose est tombé, mais qu'aucun problème connu n'a été détecté, c'est l'occasion de reconstituer la collection de masques. </p><br><p>  Ensuite, nous allons à l'utilisateur et disons qu'il a une version et cela peut être corrigé de cette façon. </p><br><p>  Vous serez surpris du nombre de problèmes que les utilisateurs ne signalent pas à l'appui.  Il est préférable de les réparer à l'avance et à un moment opportun.  Souvent, une erreur de publication mineure est ignorée pendant deux semaines, et vendredi soir, il s'avère que cela bloque la sortie externe. </p><br><h4>  Nous choisissons soigneusement les systèmes dont dépend l'assemblage <br></h4><br><p>  Idéalement, en général, pour assurer une autonomie complète de l'ensemble, mais le plus souvent cela est impossible.  Pour les assemblys basés sur java, vous avez besoin d'au moins Artifactory pour la mise en miroir - voir ci-dessus pour l'autonomie.  Chaque système intégré augmente le risque de défaillance.  Il est souhaitable que tous les systèmes fonctionnent en mode HA décent. </p><br><h3>  Interface de ligne d'assemblage </h3><br><h4>  Interface unique pour appeler l'assembly </h4><br><p>  Nous réalisons tout type d'assemblage avec un seul système.  Les assemblages de tous les niveaux (L1, L2 +) sont décrits par code de programme et sont appelés via un travail Jenkins. </p><br><p>  Cependant, cette approche n'est pas idéale.  Il est préférable d'utiliser les mécanismes de génération automatique de travaux Jenkins: par exemple, 1 travail = 1 référentiel git ou 1 travail = 1 branche git.  Cela permettra d'atteindre les objectifs suivants: </p><br><ul><li>  les journaux d'assemblages hétérogènes ne sont pas confondus dans une seule histoire sur la page de travail Jenkins; </li><li>  en fait, vous obtenez des emplois attribués confortables pour une équipe ou pour un développeur;  la sensation de confort peut être améliorée en ajustant les graphiques des résultats de junit, cobertura, sonar. </li></ul><br><h4>  Liberté de choisir la technologie <br></h4><br><p>  Le démarrage de la construction est un appel au script bash "./build.sh".  Et puis - tous les systèmes d'assemblage, les langages de programmation et tout ce qui sera nécessaire pour effectuer une tâche commerciale.  Cela fournit une approche de l'assemblage sous forme de boîte noire. </p><br><h4>  Message intelligent </h4><br><p>  La chaîne de montage intercepte les publications de la boîte noire et les place déjà dans le stockage de l'entreprise.  Pour cela, les problèmes ennuyeux tels que la génération de noms d'images Docker et le choix du bon référentiel pour la publication sont automatiquement résolus. </p><br><p>  Les référentiels de staging et de release ont toujours de l'ordre.  Il est nécessaire pour prendre en charge les spécificités des publications de différents types: maven, npm, file, docker. </p><br><h4>  Descripteur d'assemblage <br></h4><br><p>  Build.sh décrit comment compiler du code, mais cela ne suffit pas pour un conteneur d'assembly. </p><br><p>  Vous devez également savoir: </p><br><ol><li>  quel environnement d'assemblage utiliser; </li><li>  variables d'environnement disponibles dans build.sh; </li><li>  quelles publications seront effectuées; </li><li>  d'autres options spécifiques. </li></ol><br><p>  Nous avons choisi un moyen pratique de décrire ces informations sous la forme d'un fichier yaml ressemblant à distance à .gitlab-ci.yaml. </p><br><h4>  Paramétrage de l'assemblage <br></h4><br><p>  L'utilisateur peut spécifier des paramètres arbitraires sans exécuter la commande git commit dès le début de l'assembly. </p><br><p>  Nous l'avons implémenté en définissant des variables d'environnement directement à partir de l'interface de travail Jenkins. </p><br><p>  Par exemple, nous transférons la version de la bibliothèque dépendante vers un tel paramètre d'assembly et, dans certains cas, redéfinissons cette version en une version expérimentale.  Sans un tel mécanisme, l'utilisateur devrait exécuter la commande «git commit» à chaque fois. </p><br><h4>  Portabilité du système <br></h4><br><p>  Vous devez être en mesure de reproduire le processus d'assemblage non seulement sur le serveur CI principal, mais également sur l'ordinateur du développeur.  Cela aide à déboguer des scripts de construction complexes.  De plus, au lieu de Jenkins, il sera parfois plus pratique d'utiliser Gitlab CI.  Par conséquent, le système de génération doit être une application java indépendante.  Nous l'avons implémenté comme un plugin gradle. </p><br><h4>  Un artefact peut être publié sous différents noms. <br></h4><br><p>  Il existe deux exigences opposées pour la publication qui peuvent survenir simultanément. </p><br><p>  D'une part, pour le stockage à long terme et la gestion des versions, il est nécessaire de garantir l'unicité des noms des artefacts publiés.  Cela protégera au moins les artefacts contre l'écrasement. </p><br><p>  D'un autre côté, il est parfois pratique d'avoir un artefact réel avec un nom fixe comme le plus récent.  Par exemple, le développeur n'a pas besoin de connaître la version exacte de la dépendance à chaque fois, vous pouvez simplement travailler avec la dernière version. </p><br><p>  L'artefact dans ce cas est publié sous deux noms ou plus, car il convient à tout le monde. </p><br><p>  Par exemple: </p><br><ol><li>  un nom unique avec horodatage ou UUID - pour ceux qui ont besoin de précision; </li><li>  le nom «dernier» - pour leurs développeurs, qui récupèrent toujours le dernier code; </li><li>  le nom "&lt;major version&gt; .x-latest" est pour une équipe voisine qui est prête à récupérer les dernières versions, mais uniquement dans le cadre d'une certaine majeure. </li></ol><br><p>  Maven fait quelque chose de similaire dans son approche de SNAPSHOT. </p><br><h4>  Moins de restrictions de sécurité <br></h4><br><p>  Tout le monde peut commencer l'assemblage.  Cela ne nuira à personne, car l'assemblage crée uniquement des artefacts. </p><br><h3>  Conformité légale </h3><br><h4>  Contrôle des interactions externes du processus d'assemblage </h4><br><p>  L'assemblée ne peut utiliser aucun élément interdit dans le cadre de ses travaux. </p><br><p>  Pour cela, l'enregistrement du trafic réseau et l'accès aux caches de fichiers sont implémentés.  Nous obtenons le journal d'activité réseau de l'assemblage sous la forme d'une liste d'url avec sha256 hachages des données reçues.  De plus, chaque URL est validée: </p><br><ol><li>  liste blanche statique; </li><li>  base de données dynamique des artefacts autorisés (par exemple, pour les dépendances maven-, rpm-, npm-).  Chaque dépendance est considérée individuellement.  Un permis automatique ou une interdiction d'utilisation peut fonctionner, et une longue discussion avec les avocats peut également commencer. </li></ol><br><h4>  Contenu transparent des artefacts publiés <br></h4><br><p>  Parfois, la tâche consiste à fournir une liste de logiciels tiers dans n'importe quel assemblage.  Pour ce faire, ils ont réalisé un analyseur de composition simple qui analyse tous les fichiers et archives de l'assemblage, reconnaît le tiers par hachage et fait un rapport. </p><br><h4>  Le code source émis ne peut pas être supprimé de GIT <br></h4><br><p>  Parfois, vous devrez peut-être trouver le code source en consultant l'artefact binaire compilé il y a deux ans.  Pour ce faire, il est nécessaire d'allouer automatiquement des balises dans Git avec une sortie externe, ainsi que d'interdire leur suppression. </p><br><h3>  Logistique et comptabilité <br></h3><br><h4>  Tous les assemblages sont stockés dans la base de données. </h4><br><p>  Nous utilisons le référentiel de fichiers dans Artifactory à ces fins.  Il contient toutes les informations à l'appui: qui l'a lancé, quels ont été les résultats des vérifications, quels artefacts ont été publiés, quel git hash a été utilisé, etc. </p><br><h4>  Nous savons reproduire le montage le plus fidèlement possible </h4><br><p>  Selon les résultats de l'assemblage, nous stockons les informations suivantes: </p><br><ul><li>  l'état exact du code qui a été collecté; </li><li>  avec quels paramètres le lancement a été effectué; </li><li>  quelles commandes ont été appelées; </li><li>  quel accès aux ressources externes a eu lieu; </li><li>  environnement d'assemblage utilisé. </li></ul><br><p>  Si nécessaire, nous pouvons répondre avec précision à la question de savoir comment il a été assemblé. </p><br><h4>  Communication bidirectionnelle de l'assemblée avec le ticket JIRA <br></h4><br><p>  Assurez-vous de pouvoir résoudre les problèmes suivants: </p><br><ol><li>  pour l'assemblage, créez une liste des tickets JIRA qui y sont inclus; </li><li>  écrire dans le ticket JIRA dans quels assemblages il est inclus. </li></ol><br><p>  Une communication bidirectionnelle étroite entre l'assembly et git commit est fournie.  Et puis, à partir du texte des commentaires, vous pouvez déjà découvrir tous les liens vers JIRA. </p><br><h3>  La vitesse </h3><br><h4>  Caches de système d'assemblage </h4><br><p>  L'absence de cache Maven peut augmenter le temps de génération d'une heure. </p><br><p>  Le cache viole l'isolement de l'environnement d'assemblage et la propreté de l'assemblage.  Ce problème peut être résolu en déterminant son origine pour chaque artefact mis en cache.  Nous avons chaque fichier cache associé à un lien https à partir duquel il a été téléchargé une fois.  De plus, nous traitons la lecture d'un cache en tant qu'adresse réseau. </p><br><h4>  Caches de ressources réseau </h4><br><p>  La croissance géographique de l'entreprise conduit à la nécessité de transférer des fichiers de 300 Mo entre les continents.  Beaucoup de temps est consacré, surtout si vous devez le faire souvent. </p><br><p>  Référentiels Git, images docker des environnements d'assemblage, stockages de fichiers - tout doit être soigneusement mis en cache.  Eh bien, bien sûr, périodiquement propre. </p><br><h4>  Assemblage - aussi vite que possible, tout le reste - puis </h4><br><p>  La première étape: nous faisons le montage et immédiatement, sans gestes inutiles, nous donnons le résultat. </p><br><p>  La deuxième étape: validation, analyse, comptabilité et autre bureaucratie.  Cela peut déjà être fait dans un travail Jenkins séparé et sans limites de temps strictes. </p><br><h2>  Quel est le résultat </h2><br><ol><li>  L'essentiel est que l' <i>assemblage soit devenu clair pour les développeurs</i> , eux-mêmes peuvent le développer et l'optimiser. </li><li>  La fondation a été créée pour construire des processus métier qui dépendent de l'assemblage: installation, gestion des problèmes, tests, gestion des versions, etc. </li><li>  L'équipe DevOps n'écrit plus de scripts d'assemblage: les développeurs le font. </li><li>  Les exigences complexes de l'entreprise se sont transformées en un rapport transparent avec une liste finale de contrôles. </li><li>  Tout le monde peut créer n'importe quel référentiel simplement en appelant build.sh via une seule interface.  Il lui suffit de spécifier simplement les coordonnées git du code source.  Cette personne peut être chef d'équipe, ingénieur QA / IT, etc. </li></ol><br><p>  Et quelques chiffres </p><br><ol><li>  Coûts de temps.   15    Jenkins job    build.sh.   15    docker-,   ,  .      .        . </li><li>  .         .      2200 .   —  on-commit-. </li><li>      300 git-,     . </li><li>      30   ,   (25 ) —  docker. </li><li>      ,     : <br><ol><li> glide, golang, promu; </li><li> maven, gradle; </li><li> python &amp; pip; </li><li> ruby; </li><li> nodejs &amp; npm; </li><li> docker; </li><li> rpm build tools &amp; gcc; </li><li>  Android   ADT; </li><li>  ; </li><li>    legacy-; </li><li>   . </li></ol><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421423/">https://habr.com/ru/post/fr421423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421413/index.html">Accès correct aux méthodes d'interface par défaut grâce à la réflexion dans Java 8, 9, 10</a></li>
<li><a href="../fr421415/index.html">Magic Leap - trash trash</a></li>
<li><a href="../fr421417/index.html">Machine à café pour les accros au café ou machine à café mobile Wacaco</a></li>
<li><a href="../fr421419/index.html">Ode au nickel «moussé», aux saphirs inexistants et au sous-ministre soviétique: l'OTTO SX-P1 emblématique au Japon, aux USA et en URSS</a></li>
<li><a href="../fr421421/index.html">LAppS: un demi-million de messages WebSocket de 1 Ko par seconde avec TLS sur un processeur</a></li>
<li><a href="../fr421425/index.html">Apprivoiser et consolider: l'histoire du passage à Oracle Supercluster</a></li>
<li><a href="../fr421429/index.html">LSTM - ANN Prix dynamique dans la vente au détail d'articles ménagers</a></li>
<li><a href="../fr421431/index.html">Gestion du temps ou gestion efficace du chaos</a></li>
<li><a href="../fr421433/index.html">Il restait exactement un jour avant le démarrage du serveur.</a></li>
<li><a href="../fr421435/index.html">"Pourquoi faisons-nous tous cela?" - Créateur de Prisma et ancien chef de projet VK à propos de son nouveau projet secret</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>