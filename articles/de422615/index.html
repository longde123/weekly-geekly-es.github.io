<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ñ üß¶ üë¥üèª Die ganze Wahrheit √ºber RTOS. Artikel 9. Scheduler: Implementierung üë®üèΩ‚Äçüåæ üçç üï¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Grundprinzipien der Arbeit der RTOS-Planer wurden im Artikel ‚ÄûAufgaben und Planung‚Äú ber√ºcksichtigt. In diesem Artikel werden die Funktionen von Nu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel 9. Scheduler: Implementierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422615/"><img src="https://habrastorage.org/webt/fe/zo/8m/fezo8mtb5js9kb_juvdmxayq1fa.jpeg"><br><p>  Die Grundprinzipien der Arbeit der RTOS-Planer wurden im Artikel ‚ÄûAufgaben und Planung‚Äú ber√ºcksichtigt.  In diesem Artikel werden die Funktionen von Nucleus RTOS sowie die Funktionen von Nucleus SE ausf√ºhrlicher beschrieben. </p><a name="habracut"></a><br><p> Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </p><br><h2>  Planung bei Nucleus RTOS </h2><br><p>  Da Nucleus RTOS ein vollwertiges, gut etabliertes kommerzielles RTOS ist, k√∂nnen wir davon ausgehen, dass der Scheduler gem√§√ü den Anforderungen eines solchen Produkts entwickelt wurde.  Dieses komplexe und flexible Betriebssystem bietet dem Entwickler eine breite Palette von Funktionen zur L√∂sung nahezu aller denkbaren Echtzeit-Programmieraufgaben. </p><br><p>  Der Scheduler kann eine unbegrenzte Anzahl von Aufgaben unterst√ºtzen (nur durch verf√ºgbare Ressourcen begrenzt) und mit der Priorit√§tsverwaltung arbeiten.  Der Aufgabe kann eine Priorit√§t von 0 bis 255 zugewiesen werden, wobei 0 die h√∂chste Priorit√§t und 255 die niedrigste ist.  Eine Aufgabe hat eine dynamische Priorit√§t, dh sie kann zur Laufzeit entweder von der Aufgabe selbst oder von einer anderen ge√§ndert werden.  Mehrere Aufgaben k√∂nnen derselben Priorit√§tsstufe zugewiesen werden.  Im Extremfall k√∂nnen allen Aufgaben die gleiche Priorit√§t zugewiesen werden, wodurch eine Planungsrichtlinie nach dem Prinzip von Round Robin und Time-Slice implementiert werden kann. <br>  Wenn mehrere Aufgaben mit derselben Priorit√§t vorhanden sind, werden sie mithilfe des Round Robin-Algorithmus in der Reihenfolge geplant, in der sie vorbereitet wurden.  Die Aufgabe muss angehalten oder die Kontrolle √ºbertragen werden, damit die n√§chste Aufgabe beginnt.  Aufgaben k√∂nnen auch Zeitintervalle zugewiesen werden, die eine kontrollierte Trennung der verf√ºgbaren Prozessorzeit erm√∂glichen. </p><br><p>  Die Aufgabenplanung ist zu 100% deterministisch, was von einem √§hnlichen Kern zu erwarten ist.  Aufgaben k√∂nnen auch dynamisch erstellt und zerst√∂rt werden, was dank des Schedulers vom Benutzer unbemerkt bleibt. </p><br><h2>  Planung bei Nucleus SE </h2><br><p>  Ich habe alle Aspekte von Nucleus SE so entwickelt, dass sie im Allgemeinen mit Nucleus RTOS kompatibel sind, aber auch einfacher und effizienter in Bezug auf den Speicher.  Der Scheduler ist keine Ausnahme.  Es bietet viele Funktionen des Nucleus RTOS Scheduler, ist jedoch etwas eingeschr√§nkt.  Flexibilit√§t wird durch Konfiguration w√§hrend der Montage erreicht. <br>  Eine Nucleus SE-Anwendung kann maximal 16 Aufgaben (und mindestens eine) haben.  Obwohl diese Anzahl theoretisch erh√∂ht werden kann, ist die Effizienz der Algorithmen gef√§hrdet.  Eine Reihe von Datenstrukturen basiert darauf, dass die Task-Indexnummer (von 0 bis 15) in einem Halbbyte (vier Bits) gespeichert wird, und sie m√ºssen zusammen mit dem entsprechenden Code verarbeitet werden. </p><br><p>  Um ein Gleichgewicht zwischen Flexibilit√§t und Einfachheit (und Gr√∂√üe) zu erreichen, bietet Nucleus SE anstelle eines Schedulers mit mehreren Funktionen eine von vier Arten von Schedulern zur Auswahl: Run to Component (RTC), Round Robin (RR), Time-Slice ( TS) und Priorit√§t.  Der Scheduler wird zum Zeitpunkt der Montage statisch ausgew√§hlt.  Details zu den einzelnen Schedulertypen werden unten im Abschnitt "Schedulertypen" beschrieben. </p><br><p>  Wie jeder andere Aspekt von Nucleus SE sind Aufgaben statische Objekte.  Sie werden w√§hrend der Konfiguration festgelegt und ihre Priorit√§t (Index) kann nicht ge√§ndert werden. </p><br><h2>  Nucleus SE-Planer </h2><br><p>  Wie oben erw√§hnt, bietet Nucleus SE eine von vier Arten von Schedulern zur Auswahl.  Wie die meisten Aspekte der Nucleus SE-Konfiguration wird diese Auswahl durch Schreiben in <b>nuse_config.h</b> <b>festgelegt. Der</b> Parameter <b>NUSE_SCHEDULER_TYPE</b> muss entsprechend festgelegt werden, wie in diesem Fragment aus der Konfigurationsdatei gezeigt: </p><br><img src="https://habrastorage.org/webt/u8/ln/su/u8lnsu8ido7iqwna4a_nw1tblqc.jpeg"><br><p>  Unabh√§ngig davon, welcher Scheduler ausgew√§hlt ist, wird sein Startcode unmittelbar nach der Initialisierung des Systems aufgerufen.  Vollst√§ndige Informationen zur Initialisierung von Nucleus SE werden im n√§chsten Artikel vorgestellt. </p><br><h3>  Zum Abschlussplaner ausf√ºhren </h3><br><p>  Der RTC-Scheduler ist die einfachste und am besten geeignete L√∂sung, wenn er die Anforderungen der Anwendung erf√ºllt.  Jede Aufgabe muss ihre Arbeit abschlie√üen, bevor die R√ºckgabefunktion ausgef√ºhrt wird und der Scheduler die n√§chste Aufgabe ausf√ºhren kann. </p><br><p>  Es ist kein separater Stapel f√ºr jede Aufgabe erforderlich.  Der gesamte Code ist in C geschrieben, Assemblersprache ist nicht erforderlich.  Unten finden Sie den gesamten RTC-Scheduler-Code. </p><br><img src="https://habrastorage.org/webt/lk/vf/z4/lkvfz4furcpo5bxyuwojbnmzkpq.jpeg"><br><p>  Code ist nur eine Endlosschleife, die abwechselnd jede Aufgabe aufruft.  Das Array <b>NUSE_Task_Start_Address []</b> enth√§lt Zeiger auf die externe Funktion jeder Aufgabe.  Das PF0-Makro ist eine einfache Konvertierung eines <b>Void-</b> Zeigers in einen Zeiger auf eine <b>Void-</b> Funktion ohne Parameter.  Es soll die Lesbarkeit des Codes gew√§hrleisten. <br>  Die bedingte Kompilierung wird verwendet, um die Unterst√ºtzung zus√§tzlicher Funktionen zu aktivieren: <b>NUSE_SUSPEND_ENABLE</b> bestimmt, ob Aufgaben angehalten werden k√∂nnen;  <b>NUSE_SCHEDULE_COUNT_SUPPORT</b> bestimmt, ob bei jeder geplanten Aufgabe ein <b>Z√§hlerwert</b> erforderlich ist.  Weitere Informationen hierzu finden Sie im n√§chsten Artikel. </p><br><h3>  Scheduler Round Robin </h3><br><p>  Wenn etwas mehr Flexibilit√§t erforderlich ist als vom RTC-Scheduler bereitgestellt, ist der RR-Scheduler geeignet.  Dadurch kann die Aufgabe die Kontrolle √ºbertragen oder anhalten und dann an derselben Stelle fortfahren.  Zus√§tzlicher Overhead zus√§tzlich zur Codekomplexit√§t und Nichtportabilit√§t besteht darin, dass f√ºr jede Aufgabe ein eigener Stapel erforderlich ist. <br>  Der Scheduler-Code besteht aus zwei Teilen.  Die Startkomponente lautet wie folgt: </p><br><img src="https://habrastorage.org/webt/-j/83/7r/-j837r3mppxr_3xjpeeazjsuwgc.jpeg"><br><p>  Wenn die Unterst√ºtzung f√ºr den Anfangszustand der Aufgabe aktiviert ist (mithilfe des Parameters <b>NUSE_INITIAL_TASK_STATE_SUPPOR</b> T, siehe "Parameter" im n√§chsten Artikel), beginnt die Planung mit der ersten abgeschlossenen Aufgabe.  Andernfalls wird eine Aufgabe mit dem Index 0 verwendet. Der Kontext dieser Aufgabe wird dann mit <b>NUSE_Context_Load ()</b> geladen.  Weitere Informationen zum Speichern und Wiederherstellen eines Kontexts finden Sie im Abschnitt ‚ÄûSpeichern des Kontexts‚Äú im n√§chsten Artikel. </p><br><p>  Der zweite Teil des Schedulers ist die Komponente ‚ÄûNeuplanung‚Äú: </p><br><img src="https://habrastorage.org/webt/zb/rz/-k/zbrz-ku365uguee3z989gq4-pd8.jpeg"><br><p>  Dieser Code wird aufgerufen, wenn die Task den Zentralprozessor freigibt oder pausiert. </p><br><p>  Der Code w√§hlt die zu startende Aufgabe mit dem folgenden Index aus und platziert den Wert in <b>NUSE_Task_Next,</b> wobei ber√ºcksichtigt wird, ob die Aufgabenunterbrechung aktiviert ist oder nicht.  Das Makro <b>NUSE_CONTEXT_SWAP ()</b> wird dann verwendet, um die <b>Kontextumschaltung unter</b> Verwendung eines Software-Interrupts aufzurufen.  Weitere Informationen zum Speichern und Wiederherstellen eines Kontexts finden Sie im Abschnitt ‚ÄûSpeichern des Kontexts‚Äú im n√§chsten Artikel. </p><br><h3>  Priorit√§tsplaner </h3><br><p>  Der Priority Scheduler in Nucleus SE bietet wie andere Optionen die erforderliche Funktionalit√§t und ist recht einfach.  Infolgedessen hat jede Aufgabe eine eindeutige Priorit√§t. Es ist unm√∂glich, mehrere Aufgaben mit einer Priorit√§tsstufe zu haben.  Die Priorit√§t wird durch den Index der Aufgabe bestimmt, wobei 0 die h√∂chste Priorit√§tsstufe ist.  Der Index der Aufgabe wird durch ihre Position im Array <b>NUSE_Task_Start_Address [] bestimmt.</b>  Der n√§chste Artikel enth√§lt detailliertere Informationen zum Einrichten von Aufgaben. </p><br><p>  Wie die RR- und TS-Scheduler besteht der Priority-Scheduler aus zwei Komponenten.  Die Startkomponente des Priorit√§tsplaners ist dieselbe wie die RR- und TS-Planer, wie oben dargestellt.  Die Umplanungskomponente unterscheidet sich geringf√ºgig: </p><br><img src="https://habrastorage.org/webt/eu/6v/n6/eu6vn6zlqoex1bacs9r1iwq4c4u.jpeg"><br><p>  Es gibt keinen bedingten Code, der die Unterbrechung von Aufgaben deaktivieren k√∂nnte, da diese Funktion f√ºr den Priorit√§tsplaner obligatorisch ist.  Jede Alternative w√§re unlogisch.  Die Funktion <b>NUSE_Reschedule ()</b> akzeptiert einen Parameter, der "sagt", welche Aufgabe als n√§chstes geplant werden kann - <b>new_task.</b>  Dieser Wert wird festgelegt, wenn eine Neuplanung aufgerufen wird, weil eine andere Aufgabe aufgerufen wird.  Der Index dieser Aufgabe wird als Parameter √ºbergeben.  Der Scheduler kann dann bestimmen, ob eine <b>Kontextumschaltung durchgef√ºhrt</b> werden soll, indem der Wert von <b>new_task</b> mit dem Index der aktuellen Task <b>(NUSE_Task_Active) verglichen wird</b> .  Wenn die Neuplanung das Ergebnis einer Aufgabenpause ist, wird der Parameter auf <b>NUSE_NO_TASK gesetzt</b> und der Scheduler sucht nach der Aufgabe mit der h√∂chsten Priorit√§t. </p><br><h2>  Aufgabenzust√§nde </h2><br><p>  In der Regel haben alle Betriebssysteme das Konzept, Aufgaben in einem bestimmten ‚ÄûZustand‚Äú zu finden.  Details variieren je nach RTOS.  In diesem Artikel werden wir uns ansehen, wie Nucleus RTOS und Nucleus SE Taskzust√§nde verwenden. </p><br><h3>  Nucleus RTOS-Taskzust√§nde </h3><br><p>  Nucleus RTOS unterst√ºtzt 5 Taskzust√§nde. </p><br><ul><li>  Ausf√ºhrung: Die Aufgabe, die derzeit den Prozessor verwaltet.  Offensichtlich kann nur eine Aufgabe diesen Zustand einnehmen. </li><li>  Bereitschaft: Eine Aufgabe, die zur Ausf√ºhrung bereit ist (oder die Ausf√ºhrung fortzusetzen), bevor der Planer beschlie√üt, sie zu starten.  In der Regel hat eine Aufgabe eine niedrigere Priorit√§t als die ausgef√ºhrte. </li><li>  Suspendierung: die "schlafende" Aufgabe.  Es wird bei der Planung erst ber√ºcksichtigt, wenn es aufwacht. In diesem Moment ist es ‚Äûbereit‚Äú und kann sp√§ter fortgesetzt werden.  Normalerweise befindet sich eine Aufgabe im Ruhezustand, weil sie auf etwas wartet: wenn die Ressource verf√ºgbar wird, wenn der festgelegte Zeitraum abl√§uft oder wenn eine andere Aufgabe sie aufweckt. </li><li>  Abbrechen: Die Aufgabe wurde "get√∂tet".  Sie wird bei der Planung erst ber√ºcksichtigt, wenn sie zur√ºckgesetzt wird. Danach ist die Aufgabe ‚Äûbereit‚Äú oder ‚Äûangehalten‚Äú. </li><li>  Beenden: Die Aufgabe wird abgeschlossen und ihre externe Funktion verlassen, indem einfach die externe Einheit verlassen oder die return-Anweisung ausgef√ºhrt wird.  Sie wird bei der Planung erst ber√ºcksichtigt, wenn sie zur√ºckgesetzt wird. Danach ist die Aufgabe ‚Äûbereit‚Äú oder ‚Äûangehalten‚Äú. </li></ul>  Da Nucleus RTOS die dynamische Erstellung und Zerst√∂rung von Objekten, einschlie√ülich Aufgaben, unterst√ºtzt, kann die Aufgabe auch in einem "entfernten" Zustand betrachtet werden.  Sobald jedoch die Aufgabe gel√∂scht wird, existieren alle ihre Systemressourcen nicht mehr und die Aufgabe selbst existiert nicht mehr, kann sie keinen Status haben.  Der Aufgabencode ist m√∂glicherweise verf√ºgbar, das Aufgabenobjekt muss jedoch erneut erstellt werden. <br><br><h3>  Aufgabenzust√§nde in Nucleus SE </h3><br>  Das Taskstatusmodell in Nucleus SE ist etwas einfacher.  Normalerweise gibt es nur drei Zust√§nde: Ausf√ºhrung, Verf√ºgbarkeit und Pause.  Der Status jeder Aufgabe wird in <b>NUSE_Task_Status []</b> gespeichert, der Werte vom Typ <b>NUSE_READY enth√§lt</b> , obwohl er niemals einen Wert hat, der den Ausf√ºhrungsstatus widerspiegelt.  Wenn die Task-Suspendierung nicht aktiviert ist (siehe "Optionen" im n√§chsten Artikel), sind nur zwei Task-Status m√∂glich, und dieses Array fehlt. <br><br>  Es gibt verschiedene Arten von Pausenaufgaben.  Wenn eine Aufgabe explizit von sich selbst oder von einer anderen Aufgabe angehalten wird, wird dies als "reine Aussetzung" bezeichnet und durch den Status NUSE_PURE_SUSPEND dargestellt.  Wenn der Status "Schlaf" aktiviert ist und die Aufgabe f√ºr einen bestimmten Zeitraum angehalten wird, hat sie den Status <br>  <b>NUSE_SLEEP_SUSPEND</b> .  Wenn die Funktion zum Blockieren von API-Aufrufen aktiviert ist (√ºber <b>NUSE_BLOCKING_ENABLE</b> , siehe ‚ÄûParameter‚Äú im n√§chsten Artikel), kann die Aufgabe angehalten werden, bis die Ressource verf√ºgbar wird.  Jeder Objekttyp hat seinen eigenen Task-Suspendierungsstatus, z. B. in Form von <b>NUSE_MAILBOX_SUSPEND.</b>  In Nucleus SE kann eine Aufgabe in einer Speicherpartition, einer Ereignisgruppe, einem Postfach, einer Warteschlange, einem Kanal oder einem Semaphor gesperrt werden. <br><br><h3>  Thread-Status </h3><br>  Bei der Er√∂rterung des Aufgabenverhaltens werden die W√∂rter ‚ÄûStatus‚Äú und ‚ÄûStatus‚Äú normalerweise recht frei verwendet.  Es gibt einen zus√§tzlichen Faktor, der bedingt als "Zustand des Flusses" bezeichnet werden kann.  Dies ist die globale Variable <b>NUSE_Thread_State,</b> die einen Hinweis auf die Art des ausgef√ºhrten Codes enth√§lt.  Dies gilt f√ºr das Verhalten vieler API-Aufrufe.  M√∂gliche Werte: <br><br><ul><li>  <b>NUSE_TASK_CONTEXT</b> - Der API-Aufruf wurde von einer Task aus durchgef√ºhrt. </li><li>  <b>NUSE_STARTUP_CONTEXT</b> - Der API-Aufruf wurde aus dem <b>Startcode ausgef√ºhrt</b> .  Der Scheduler wurde noch nicht gestartet. </li><li>  <b>NUSE_NISR_CONTEXT und NUSE_MISR_CONTEXT</b> - Der API-Aufruf wurde vom Interrupt-Handler ausgef√ºhrt.  Unterbrechungen in Nucleus SE werden im n√§chsten Artikel behandelt. </li></ul><br>  Der n√§chste Artikel beschreibt die erweiterten Scheduler-Funktionen in Nucleus SE sowie die Verwaltung des Kontexts. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422615/">https://habr.com/ru/post/de422615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422603/index.html">Ein bisschen n√§her an der Perfektion</a></li>
<li><a href="../de422605/index.html">Schon in jungen Jahren einen Safe aufbauen - Bildungsprogramm von Rostelecom und MIPT</a></li>
<li><a href="../de422609/index.html">Sprachbarriere und NLP. Warum verstehen uns Chatbots nicht?</a></li>
<li><a href="../de422611/index.html">Standard Error Handler in RxJava2 oder warum RxJava Anwendungsabst√ºrze verursacht, selbst wenn onError implementiert ist</a></li>
<li><a href="../de422613/index.html">PowerPool Cybergroup hat die Zero-Day-Sicherheitsanf√§lligkeit in Advanced Local Procedure Call gemeistert</a></li>
<li><a href="../de422617/index.html">Die ganze Wahrheit √ºber RTOS. Artikel 8. Nucleus SE: Internes Design und Bereitstellung</a></li>
<li><a href="../de422623/index.html">So sichern Sie C.</a></li>
<li><a href="../de422625/index.html">Wir haben mit Troy Miles gesprochen - dem Programmierer von "Neuromancer"</a></li>
<li><a href="../de422627/index.html">MongoDB und IT-Arbeitsmarktforschung</a></li>
<li><a href="../de422629/index.html">H√∂r auf, die Holzf√§ller zu f√ºttern! Gib mehr Modifikatoren! Lazy Static Final Fields. Entwurf einer Feature-Skizze</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>