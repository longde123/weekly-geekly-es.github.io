<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüíª üôÇ üë©üèΩ‚Äçüç≥ Verwendung des Verifizierers als Mittel zur schnellen Modellierung von RTL-Projekten. Einf√ºhrung in UVM üíÖ üåå üôå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel beschreibt die Installation und Verwendung von freier Software zur Modellierung digitaler Logikschaltungen in Verilog als Alternative z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwendung des Verifizierers als Mittel zur schnellen Modellierung von RTL-Projekten. Einf√ºhrung in UVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459338/">  Dieser Artikel beschreibt die Installation und Verwendung von freier Software zur Modellierung digitaler Logikschaltungen in Verilog als Alternative zu kommerziellen Produkten Incisve von Cadense und ModelSim von MentorGraphics.  Vergleich von Simulationen in ModelSim und Verilator.  Eine universelle Verifizierungsmethode, UVM, wird ebenfalls in Betracht gezogen. <br><br><h2>  Installation der SystemC UVM-Software </h2><br><h3>  1. Der Verilator </h3><br>  Eine der Hardwarebeschreibungssprachen ist Verilog.  Sie k√∂nnen ein Modul in dieser Sprache schreiben. <br><br>  Zum Beispiel gibt es ein Z√§hlerschema: <br><br><img src="https://habrastorage.org/webt/s6/a7/9i/s6a79i89t6vzfl-a6dqeiwi5fh8.png" alt="Bild"><br><br>  Der Code sieht folgenderma√üen aus: <br><br><pre><code class="cpp hljs">reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]counter; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset)    counter &lt;= <span class="hljs-number"><span class="hljs-number">4'</span></span>d0;   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>    counter &lt;= counter + <span class="hljs-number"><span class="hljs-number">1'</span></span>d1;</code> </pre> <br>  Nach der Simulation erhalten wir die Wellenformen: <br><br><img src="https://habrastorage.org/webt/m5/-o/mg/m5-omg9r-4_fzvo1momfxt7wq-8.png" alt="Bild"><br><br>  Es ist ersichtlich, dass der n√§chste Wert, einer mehr als der vorherige, in die Z√§hlerregister entlang der Taktfrequenzfront geschrieben wird. <br><br>  Ein geschriebenes Modul kann eine komplexere Struktur haben, bei der es schwierig ist, alle Zust√§nde von manuell zu √ºberpr√ºfen.  Wir brauchen automatisierte Tests.  Dazu ist es notwendig, eine Testumgebung in einer der Programmiersprachen zu entwickeln.  Die Testumgebung gibt uns die M√∂glichkeit, eine vollst√§ndige Funktionspr√ºfung des Ger√§ts durchzuf√ºhren. <br><br>  Zum Testen des Projektcodes k√∂nnen Sie zus√§tzlich zu Sprachen wie Verilog, SystemVerilog, Python (zum Schreiben von Modellen) die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SystemC-</a> Sprache verwenden.  SystemC ist eine Entwurfs- und √úberpr√ºfungssprache auf Systemebene f√ºr Modelle auf Systemebene, die als Open Source C ++ - Bibliothek implementiert sind. <br><br>  Eine M√∂glichkeit, Verilog-Module mit SystemC zu √ºberpr√ºfen, besteht darin, Verilog-Dateien in C ++ zu √ºbersetzen.  Helfen Sie uns mit diesem Verilator. <br><br>  Verilator ist der schnellste kostenlose Verilog HDL-Simulator, der die meisten kommerziellen Simulatoren √ºbertrifft.  Verilator kompiliert synthetisierten SystemVerilog (normalerweise ist dies kein Testbed-Code) sowie einige Anweisungen von SystemVerilog und Synthesis in C ++ - oder SystemC-Code mit einem oder mehreren Threads.  Verilator wurde f√ºr gro√üe Projekte entwickelt, bei denen die Simulationsleistung von gr√∂√üter Bedeutung ist, und eignet sich besonders gut zum Generieren ausf√ºhrbarer Prozessormodelle f√ºr eingebettete Softwareentwicklungsteams.  Verilator wird verwendet, um viele sehr gro√üe Gateway-Designs im Wert von mehreren Millionen Dollar mit Tausenden von Modulen zu simulieren. Es wird von vielen IP-Technologieanbietern unterst√ºtzt, darunter IP von Arm und allen renommierten RISC-V-IP-Anbietern. <br><a name="habracut"></a><br>  Verilator ist m√∂glicherweise nicht die beste Wahl, wenn Sie f√ºr ein sehr kleines Projekt einen voll ausgestatteten Ersatz f√ºr NC-Verilog, VCS oder einen anderen kommerziellen Verilog-Simulator oder Verilog-Verhaltenssimulator erwarten.  Wenn Sie jedoch nach einer M√∂glichkeit suchen, synthetisiertes Verilog nach C ++ oder SystemC zu portieren, und Ihr Team nur C ++ - Code schreiben kann, ist dies ein kostenloser Verilog-Compiler f√ºr Sie. <br><br>  So installieren Sie die neueste Version unter Ubuntu: Laden Sie das Archiv <a href="">√ºber den Link von der offiziellen Website</a> herunter. <br><br>  Installieren: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#sudo apt-get install make autoconf g++ flex bison # Prerequisites unsetenv VERILATOR_ROOT # For csh; ignore error if on bash unset VERILATOR_ROOT # For bash tar xvzf verilator*.t*gz cd verilator* ./configure make sudo make install</span></span></code> </pre> <br><h3>  2. GTK Wave </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/de9/6c3/adcde96c392048d083337f797505b1fc.gif" alt="Bild"><br>  GTKWave ist ein voll funktionsf√§higer Wellenform-Viewer, mit dem Sie Dateien bequemer und schneller vom VCD- in das FST-Format konvertieren k√∂nnen. <br><br>  Installieren: <br><br><pre> <code class="bash hljs">sudo apt-get install gtkwave</code> </pre> <br><h3>  3. SYSTEMC </h3><br>  Eine Sprache zum Entwerfen und √úberpr√ºfen von Modellen auf Systemebene, die in Form einer Open Source C ++ - Bibliothek implementiert sind. <br><br>  Wie bereits erw√§hnt, unterst√ºtzt Verilator systemc. Daher m√ºssen Sie ein Projekt erstellen, in dem der Testbenchmark in systemc und die Quelldateien in synthetisiertem verilog beschrieben werden.  Dazu ben√∂tigen wir die von Accelera bereitgestellten g ++ - Compiler-Bibliotheken.  Die Accellera Systems Initiative ist eine unabh√§ngige, gemeinn√ºtzige Organisation, die sich der Erstellung, Unterst√ºtzung, F√∂rderung und F√∂rderung von Design-, Simulations- und Verifizierungsstandards auf Systemebene f√ºr den Einsatz in der globalen Elektronikindustrie widmet. <br><br>  Laden Sie das Archiv herunter: <br>  <a href="">http://accellera.org/images/downloads/standards/systemc/systemc-2.3.1a.tar.gz</a> <br><br>  Installieren: <br><br><pre> <code class="bash hljs">tar -xvf systemc-2.3.1a.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> systemc-2.3.1a mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a/ sudo make sudo make install <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../</code> </pre> <br><h3>  4. UVM f√ºr SYSTEMC </h3><br>  In diesem Artikel wird ein Projekt beschrieben, das UVM-√úberpr√ºfungstools implementiert.  Die √úberpr√ºfung ist eine Best√§tigung der Konformit√§t des Endprodukts mit vordefinierten Referenzanforderungen.  Eines ihrer √úberpr√ºfungswerkzeuge k√∂nnen Tests sein.  Um Testsequenzen auf Modellen realer Ger√§te auf der Ebene der RTL-Beschreibungen auszuf√ºhren, muss eine Testumgebung entwickelt werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UVM</a> - (Universal Verification Methodology) ist eine universelle Verifizierungsmethode, ein Standard, der die effiziente Entwicklung und Wiederverwendung von IP-Blockvalidierungsumgebungen erm√∂glicht.  UVM ist eine Verifizierungsmethode, deren Aufgabe darin besteht, eine effektive Umgebung um das zu testende Ger√§t herum zu organisieren.  Seine Vorteile: <br><br><ul><li>  klare Struktur in Form von dedizierten Bl√∂cken, die spezifisch entscheiden </li><li>  Aufgaben </li><li>  die F√§higkeit, Bl√∂cke in nachfolgenden Projekten wiederzuverwenden; </li><li>  die maximal m√∂gliche Automatisierung der √úberpr√ºfung; </li><li>  Die umfassendsten Berichtsinformationen, die es erm√∂glichen, im Fehlerfall die Ursachen so schnell und genau wie m√∂glich zu identifizieren und L√∂sungen vorzuschlagen. </li></ul><br>  UVM-Methoden bestehen aus zwei Teilen: einem Regelwerk zum Erstellen einer Testumgebung und einer Bibliothek von Blockleerzeichen zur √úberpr√ºfung, z. B. einem Textgenerator, einem Statistiksammler usw.  Der Hauptvorteil von UVM ist seine Vielseitigkeit und Kompatibilit√§t mit Umgebungen von Drittanbietern. <br><br>  Da systemc die UVM-Methode unterst√ºtzt, fahren wir mit der Installation der erforderlichen Bibliotheken fort. <br><br>  Laden Sie das Archiv herunter: <br><br>  <a href="">https://www.accellera.org/images/downloads/drafts-review/uvm-systemc-1.0-beta2.tar.gz</a> <br><br>  Installieren: <br><br><pre> <code class="bash hljs">tar -xvf uvm-systemc-1.0-beta2.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> uvm-systemc-1.0-beta2/ mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc_uvm/ --with-systemc=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a sudo make sudo make install</code> </pre><br>  Wir bilden eine Allianz: <br><br><pre> <code class="bash hljs">sudo mkdir /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance</code> </pre> <br>  Kopieren Sie den Inhalt der Ordner / usr / local / uvm_systemc_aliance / und /usr/local/systemc-2.3.1/ in diesen Ordner <br><br>  Laden Sie das fertige Projekt unter folgendem Link herunter: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/paprikun/SYSTEMC/</a> <br><br>  √ñffnen Sie den Verilator-Beispielordner. <br>  Der Ordner rtl enth√§lt eine Beschreibung des Ger√§ts.  In diesem Beispiel handelt es sich um einen PWM-Controller. <br>  In der Makefile-Datei des Sim-Ordners zum Erstellen des Projekts. <br>  Im tb-Ordner befindet sich der Code f√ºr den Verifizierer.  Der Ordner tb / uvm enth√§lt ein Beispiel f√ºr eine uvm-Umgebung.  Die Hauptdatei ist ein Einstiegspunkt beim Testen und verbindet das zu testende Ger√§t mit der UVM-Umgebung. <br>  Wir versuchen, das Projekt mit dem Befehl make all aus dem Ordner sim zu erstellen.  Wir sehen einen Fehler: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/systemc.h:120:16: error: <span class="hljs-string"><span class="hljs-string">'std::gets'</span></span> has not been declared using std::gets;</code> </pre> <br>  Wir beheben das Problem, indem wir Zeile 120 ersetzen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__cplusplus) &amp;&amp; (__cplusplus &lt; 201103L) using std::gets; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Wir versuchen erneut, die Testbench auszuf√ºhren und sto√üen auf eine Warnung: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/sysc/packages/boost/get_pointer.hpp:21:40: warning: <span class="hljs-string"><span class="hljs-string">'template&lt;class&gt; class std::auto_ptr'</span></span> is deprecated [-Wdeprecated-declarations] template&lt;class T&gt; T * get_pointer(std::auto_ptr&lt;T&gt; const&amp; p)</code> </pre> <br>  √Ñndern Sie auto_ptr in unique_ptr. <br><br><h2>  Projektmontage und Simulation </h2><br>  Nachdem die Bibliotheken installiert sind und funktionieren, erstellen wir das Projekt: make all.  Die ausf√ºhrbare Datei von simu sollte im Ordner sim angezeigt werden.  Dies ist ein vom Compiler erstelltes Objekt.  Wir beginnen es mit dem ./simu Team.  Folgendes sollte angezeigt werden: <br><br><pre> <code class="bash hljs">SystemC 2.3.1-Accellera --- Jun 28 2019 11:39:29 Copyright (c) 1996-2014 by all Contributors, ALL RIGHTS RESERVED Universal Verification Methodology <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SystemC (UVM-SystemC) Version: 1.0-beta2 Date: 2018-10-24 Copyright (c) 2006 - 2018 by all Contributors See NOTICE file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> all Contributors ALL RIGHTS RESERVED Licensed under the Apache License, Version 2.0 UVM_INFO @ 0 s: reporter [RNTST] Running <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ... simulation real time = 9 sec UVM_INFO uvm_default_report_server.cpp(666) @ 179490249010 ps: reporter [UVM/REPORT/SERVER] --- UVM Report Summary --- ** Report counts by severity UVM_INFO : 1 UVM_WARNING : 0 UVM_ERROR : 0 UVM_FATAL : 0 ** Report counts by id [RNTST] 1 UVM_INFO @ 179490249010 ps: reporter [FINISH] UVM-SystemC phasing completed; simulation finished</code> </pre><br>  Wenn die Simulation beendet ist, endet die Aufzeichnung der Wafeform.  Die Datei simu.vcd kann mit gtkwave ge√∂ffnet werden: <br><br><img src="https://habrastorage.org/webt/xv/9m/ka/xv9mkaqsrcrvfczarjl5rz29i88.png"><br><br>  Um die Signale auf der linken Seite anzuzeigen, w√§hlen Sie SystemC, halten Sie die Umschalttaste gedr√ºckt, w√§hlen Sie alle Signale aus und klicken Sie auf Anh√§ngen.  QuickInfos werden in der Symbolleiste angezeigt, wenn Sie den Mauszeiger bewegen.  Der Mauslauf funktioniert, Sie m√ºssen Shift oder Cntrl gedr√ºckt halten. <br><br>  Es gibt auch M√∂glichkeiten, diese Datei in eine andere kleinere zu konvertieren. <br><br>  Wenn es Modelle gibt, wird die Konvertierung durchgef√ºhrt.  Geben Sie im Terminal den Befehl vsim ein.  In den Terminalmodellenim: <br><br><pre> <code class="bash hljs">vcd2wlf simu.vcd simu.wlf</code> </pre> <br>  Oder mit gtkwave im Linux-Terminal: <br><pre> <code class="bash hljs">vcd2lxt simu.vcd simu.lxt vcd2lxt2 simu.vcd simu.lxt2</code> </pre> <br>  Um die Simulationszeit zu vergleichen, wurde ein √§hnliches Projekt erstellt, jedoch bereits f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modelsim</a> .  Ordner modelsim_example.  √Ñhnlich erstellte UVM-Umgebung.  Die Syntax ist trotz der Tatsache, dass verschiedene Sprachen √§hnlich sind.  Wenn Sie Modelsim mit UVM-Unterst√ºtzung installiert haben, k√∂nnen Sie den Befehl make all ausf√ºhren. <br><br>  Zus√§tzlich zur Umgebung wurde in beiden Projekten eine Echtzeitsimulation von Messungen durchgef√ºhrt. <br><br>  Der Zeitunterschied ist: <br><div class="scrollable-table"><table><tbody><tr><td>  Mittwoch </td><td>  Wafeform </td><td>  Befehl zum Ausf√ºhren </td><td>  Simulationszeit (Sek.) </td></tr><tr><td>  Modelsim </td><td>  ja </td><td>  mache sim TRACE = 1 </td><td>  18 </td></tr><tr><td>  Verilator </td><td>  ja </td><td>  mache sim TRACE = 1 </td><td>  9 </td></tr><tr><td>  Modelsim </td><td>  Nein </td><td>  mache sim TRACE = 0 </td><td>  10 </td></tr><tr><td>  Verilator </td><td>  Nein </td><td>  mache sim TRACE = 0 </td><td>  4 </td></tr></tbody></table></div><br>  Wie Sie der Tabelle entnehmen k√∂nnen, hat der Verilator einen Vorteil.  Die Daten werden f√ºr einen PC mit 8 GB RAM, einem 8-Kern-Prozessor mit 800 MHz und einem Kern angezeigt. <br><br>  Vergleichen Sie die Dateigr√∂√üe: <br><div class="scrollable-table"><table><tbody><tr><td>  simu.vcd </td><td>  807,7 MB </td></tr><tr><td>  simu.wlf (in Verilator erstellte Konvertierung) </td><td>  41 MB </td></tr><tr><td>  simu.wlf (erstellt in modelsim) </td><td>  9,3 MB </td></tr><tr><td>  simu.lxt </td><td>  128 MB </td></tr><tr><td>  simu.lxt2 </td><td>  162 MB </td></tr></tbody></table></div><br>  Hier verliert der Verilator, aber Sie k√∂nnen mit dem Erstellen von Wellenformen und der Spurentiefe experimentieren, die Aufzeichnungsperiode (Beginn und Ende der Wellenformaufzeichnung k√∂nnen verschoben werden).  Mit welcher Datei Sie arbeiten m√∂chten, liegt bei Ihnen. <br><br>  W√§hrend des Testens wurde zus√§tzlich zum Zeitpunkt der Simulation selbst eine Diskrepanz beim Lesen der Eingabedaten vom In-Bus festgestellt.  Wenn sich die Daten vom In-Bus w√§hrend der Clk-Front √§ndern, liest Modelsim die Daten nach dem Front-Verilator vor: <br><br><pre> <code class="cpp hljs">input clk; input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in_last_ ; ... always @(posedge clk) begin ... in_last_ &lt;= in; ... end</code> </pre><br><img src="https://habrastorage.org/webt/nc/ky/9r/ncky9rwjfvckf6hetlogg-futqa.png" alt="Bild"><br><br>  Beim Testen muss dieser Punkt ber√ºcksichtigt werden, da ein Teil der Testumgebung f√ºr verschiedene Simulatoren unterschiedlich funktioniert. <br><br>  Au√üerdem ber√ºcksichtigt der Verilator nicht den "x" -Zustand des Signals und √ºbersetzt alles in "0"; <br><br><h2>  UVM TESTBENCH </h2><br>  Betrachten Sie die Testumgebung, den Ordner tb / uvm. <br><br>  UVM-Testbench ist die Umgebung √ºber dem Ger√§t.  In diesem Beispiel ist das Ger√§t ein PWM-Controller.  UVM-Umgebungsdiagramm: <br><br><img src="https://habrastorage.org/webt/94/tp/ox/94tpox5qii7r4qqaaakc_fbqrd4.png" alt="Bild"><br><br>  Wie Sie im Diagramm sehen k√∂nnen, besteht UVM aus Bl√∂cken (Klassen).  Jeder Block erf√ºllt seine Funktionen.  Das Beispiel zeigt eines der m√∂glichen Layouts der Testumgebung.  Der Name und die Funktionalit√§t jeder Klasse entsprechen der Klasse, von der sie geerbt wurde.  Lassen Sie uns jede Klasse genauer betrachten. <br><br>  Umgebungsdatei env.h oder env.svh.  Dies ist eine Klasse, die eine oder mehrere Agentenklassen enthalten kann, in denen drei Klassen verbunden sind: Sequenzer, Treiber, Monitor.  Das Beispiel enth√§lt keinen Agenten, aber seine Funktion ist in der env-Klasse implementiert.  F√ºr den Test m√ºssen wir eine Sequenz von Aktionen schreiben - Sequenzierung. <br><br>  Fahren wir mit dem Startcode f√ºr die Sequenzierung fort: <br><br><pre> <code class="cpp hljs">sequence_[n]-&gt;start(sqr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  Sequenzer (Sequenzer) - Datei sequncer.h.  In System Verilog wurde der Standard-Sequenzer verwendet.  Eine Klasse, die eine oder mehrere Sequenzen (Sequenz) enth√§lt (Dateien sequence_a.h, sequence_a.svh).  Jede Sequenz ist eine Kette von Aktionen.  Eine dieser Aktionen kann das Senden einer Transaktion sein.  Transaktion - √úbertragung von Daten von einer Klasse zu einer anderen.  Die Klasse, in der die Transaktionen beschrieben werden, ist bus_trans.  Nachfolgend finden Sie eine Beschreibung von zwei Klassen, von denen jede ideologisch ihre eigenen spezifischen Funktionen hat: Treiber und Monitor. <br><br>  Treiber - Datei drv.h, drv.svh.  Eine Klasse, die Transaktionen von einem Sequenzer empf√§ngt und in Signale √ºbersetzt.  Der Fahrer dient als Sequenzerassistent auf einer niedrigeren Ebene.  Ziehen Sie in Betracht, ein Paket zu senden. <br><br>  Die Sequenz √∂ffnet ein Transaktionsfenster, der Treiber erkennt dieses Ereignis und beginnt mit dem Empfang von Daten.  Die Sequenz wartet auf eine Antwort des Fahrers.  Der Treiber simuliert die Signale f√ºr das Ger√§t und signalisiert dem Sequenzer, dass das Fenster geschlossen werden kann.  Die Idee ist, dass der Sequenzer auf einem hohen Niveau und der Treiber auf einem niedrigeren Niveau arbeitet. <br><br>  Die Signale werden √ºber den Schnittstellenbus mit dem Ger√§t verbunden.  Die Schnittstelle ist in den Dateien vip_if.h, vip_if.svh beschrieben. <br><br>  Als n√§chstes m√ºssen Sie √ºberpr√ºfen, ob die Ausgangssignale mit den erwarteten √ºbereinstimmen.  Es gibt zwei L√∂sungen: <br><br><ul><li>  Schreiben eines Modells f√ºr ein Ger√§t </li><li>  Signal√ºberpr√ºfung durch UVM Agent </li></ul><br>  Im Beispiel wird die zweite Option ber√ºcksichtigt.  Um das Ger√§t auf Funktionsebene zu testen, muss die Ausgabe mit der erwarteten verglichen werden.  Die Anforderung an das Ger√§t war die Richtigkeit des gegebenen Arbeitszyklus des Signals und der Periode des Signals.  Um die Ausgangssignale zu √ºberwachen, wird eine neue Klasse geschrieben - Monitor (Datei monitor.h, monitor.svh).  Normalerweise √ºbertr√§gt der Monitor in einer Testumgebung die Signale in der Transaktion (auf eine h√∂here Ebene) und wird an die Vergleichsklasse - Anzeigetafel - gesendet. <br><br>  In diesem Beispiel werden die Signale sofort √ºberpr√ºft.  Bei Abweichungen zwischen dem erwarteten und dem gemessenen Wert stoppt der Test. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459338/">https://habr.com/ru/post/de459338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459326/index.html">Automatische Skalierung und Ressourcenverwaltung in Kubernetes (√úberpr√ºfung und Videobericht)</a></li>
<li><a href="../de459328/index.html">Best-in-Class-Preis-Leistungsverh√§ltnis - Mpow A5 (059)</a></li>
<li><a href="../de459330/index.html">Bitrix f√ºr Programmierer und Manager: Liebe und Hass</a></li>
<li><a href="../de459334/index.html">YouTrack 2019.2: ein systemweites Banner, Verbesserungen der Aufgabenlistenseite, neue Suchoptionen und mehr</a></li>
<li><a href="../de459336/index.html">Lebe und lerne. Teil 1. Schul- und Berufsberatung</a></li>
<li><a href="../de459340/index.html">Organisieren Sie ein ML-Projekt mit Ocean</a></li>
<li><a href="../de459342/index.html">Remote-Cache f√ºr iOS, Feature-Toggles, dunkle Themen und Entwicklerkarriere - Bericht mit Avito iOS Meetup # 7</a></li>
<li><a href="../de459344/index.html">DevOps-Metriken - Hier erhalten Sie Daten f√ºr Berechnungen</a></li>
<li><a href="../de459346/index.html">Mit einem E-Book um die Welt: ONYX BOOX James Cook 2 Review</a></li>
<li><a href="../de459348/index.html">Ein weiterer Authentifizierungsbypass in √∂ffentlichen Wi-Fi-Netzwerken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>