<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜîÔ∏è ‚ñ´Ô∏è üëÇüèø Volcanic Piglet, o SQL de bricolaje ‚¨áÔ∏è üë©üèº‚Äçü§ù‚Äçüë®üèæ üë®‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La recopilaci√≥n, almacenamiento, conversi√≥n y presentaci√≥n de datos son los principales desaf√≠os que enfrentan los ingenieros de datos. El departament...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Volcanic Piglet, o SQL de bricolaje</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/461699/"><p><img src="https://habrastorage.org/webt/sl/pt/ay/slptaynsfh2p62e4epxcf6_xfaw.jpeg"></p><br><p>  La recopilaci√≥n, almacenamiento, conversi√≥n y presentaci√≥n de datos son los principales desaf√≠os que enfrentan los ingenieros de datos.  El departamento de Business Intelligence Badoo recibe y procesa m√°s de 20 mil millones de eventos enviados desde dispositivos de usuario por d√≠a, o 2 TB de datos entrantes. </p><br><p>  El estudio e interpretaci√≥n de todos estos datos no siempre es una tarea trivial, a veces es necesario ir m√°s all√° de las capacidades de las bases de datos preparadas.  Y si tiene el coraje y decidi√≥ hacer algo nuevo, primero debe familiarizarse con los principios de funcionamiento de las soluciones existentes. </p><br><p>  En una palabra, desarrolladores curiosos y de mente fuerte, se aborda este art√≠culo.  En √©l encontrar√° una descripci√≥n del modelo tradicional de ejecuci√≥n de consultas en bases de datos relacionales utilizando el lenguaje de demostraci√≥n PigletQL como ejemplo. </p><a name="habracut"></a><br><h1 id="soderzhanie">  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Antecedentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructura de int√©rprete de SQL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelo de volc√°n y ejecuci√≥n de consultas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PigletQL</a> <br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">L√©xico y analizador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analizador sem√°ntico</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilaci√≥n de consultas en una vista intermedia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecuci√≥n de una presentaci√≥n provisional.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Operadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de trabajo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusiones</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Literatura</a> </li></ul><br><h1 id="predystoriya">  Antecedentes </h1><br><p>  Nuestro grupo de ingenieros se dedica a backends e interfaces, brindando oportunidades para el an√°lisis e investigaci√≥n de datos dentro de la empresa (por cierto, nos estamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">expandiendo</a> ).  Nuestras herramientas est√°ndar son una base de datos distribuida de docenas de servidores (Exasol) y un cl√∫ster Hadoop para cientos de m√°quinas (Hive y Presto). </p><br><p>  La mayor√≠a de las consultas a estas bases de datos son anal√≠ticas, es decir, afectan de cientos de miles a miles de millones de registros.  Su ejecuci√≥n lleva minutos, decenas de minutos o incluso horas, dependiendo de la soluci√≥n utilizada y la complejidad de la solicitud.  Con el trabajo manual del analista de usuario, dicho tiempo se considera aceptable, pero no es adecuado para la investigaci√≥n interactiva a trav√©s de la interfaz de usuario. </p><br><p>  Con el tiempo, destacamos las consultas y consultas anal√≠ticas populares, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que son dif√≠ciles de establecer en t√©rminos de</a> SQL, y desarrollamos peque√±as bases de datos especializadas para ellas.  Almacenan un subconjunto de datos en un formato adecuado para algoritmos de compresi√≥n livianos (por ejemplo, streamvbyte), que le permite almacenar datos en una sola m√°quina durante varios d√≠as y ejecutar consultas en segundos. </p><br><p>  Los primeros lenguajes de consulta para estos datos y sus int√©rpretes se implementaron en una corazonada, tuvimos que refinarlos constantemente, y cada vez tom√≥ un tiempo inaceptablemente largo. </p><br><p>  Los lenguajes de consulta no eran lo suficientemente flexibles, aunque no hab√≠a razones obvias para limitar sus capacidades.  Como resultado, recurrimos a la experiencia de los desarrolladores de int√©rpretes de SQL, gracias a los cuales pudimos resolver parcialmente los problemas que surgieron. </p><br><p>  A continuaci√≥n, hablar√© sobre el modelo de ejecuci√≥n de consultas m√°s com√∫n en bases de datos relacionales: Volcano.  El c√≥digo fuente del int√©rprete del dialecto SQL primitivo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PigletQL</a> , se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">adjunta al art√≠culo</a> , por lo que todos los interesados ‚Äã‚Äãpueden familiarizarse f√°cilmente con los detalles en el repositorio. </p><br><h1 id="struktura-interpretatora-sql">  Estructura de int√©rprete de SQL </h1><br><p> <a href=""><img src="https://habrastorage.org/webt/cw/gc/jr/cwgcjrjdybx4snxrzxqmyh4tu9c.jpeg" alt="Estructura del int√©rprete"></a> </p><br><p>  Las bases de datos m√°s populares proporcionan una interfaz para los datos en forma de un lenguaje de consulta SQL declarativo.  El analizador convierte una consulta en forma de cadena en una descripci√≥n de la consulta, similar a un √°rbol de sintaxis abstracta.  Es posible ejecutar consultas simples ya en esta etapa, sin embargo, para optimizar las transformaciones y la ejecuci√≥n posterior, esta representaci√≥n es inconveniente.  En las bases de datos que conozco, se presentan representaciones intermedias para estos fines. </p><br><p>  El √°lgebra relacional se convirti√≥ en un modelo para representaciones intermedias.  Este es un lenguaje donde las transformaciones ( <em>operadores</em> ) realizadas en los datos se describen expl√≠citamente: seleccionar un subconjunto de datos de acuerdo con un predicado, combinar datos de diferentes fuentes, etc. Adem√°s, el √°lgebra relacional es un √°lgebra en el sentido matem√°tico, es decir, un gran n√∫mero de equivalentes transformaciones  Por lo tanto, es conveniente llevar a cabo transformaciones de optimizaci√≥n sobre una consulta en forma de un √°rbol de operadores de √°lgebra relacional. </p><br><p>  Existen diferencias importantes entre las representaciones internas en las bases de datos y el √°lgebra relacional original, por lo que es m√°s correcto llamarlo <em>√°lgebra l√≥gica</em> . </p><br><p>  La validaci√≥n de una consulta generalmente se realiza al compilar la representaci√≥n inicial de la consulta en operadores de √°lgebra l√≥gica y corresponde a la etapa de an√°lisis sem√°ntico en compiladores convencionales.  El <em>directorio de la base de</em> datos desempe√±a <em>el</em> papel de la tabla de s√≠mbolos en las bases de <em>datos</em> , que almacena informaci√≥n sobre el esquema y los metadatos de la base de datos: tablas, columnas de tablas, √≠ndices, derechos de usuario, etc. </p><br><p>  En comparaci√≥n con los int√©rpretes de uso general, los int√©rpretes de bases de datos tienen una peculiaridad m√°s: diferencias en el volumen de datos y metainformaci√≥n sobre los datos a los que se supone que se deben realizar consultas.  En las tablas o relaciones en t√©rminos de √°lgebra relacional, puede haber una cantidad diferente de datos, en algunas columnas ( <em>atributos de</em> relaci√≥n) se pueden construir √≠ndices, etc. Es decir, dependiendo del esquema de la base de datos y la cantidad de datos en las tablas, la consulta debe ser realizada por diferentes algoritmos , y √∫selos en un orden diferente. </p><br><p>  Para resolver este problema, se introduce otra representaci√≥n intermedia: <em>el √°lgebra f√≠sica</em> .  Dependiendo de la disponibilidad de √≠ndices en las columnas, la cantidad de datos en las tablas y la estructura del √°rbol de √°lgebra l√≥gica, se ofrecen diferentes formas del √°rbol de √°lgebra f√≠sica, de las cuales se elige la mejor opci√≥n.  Es este √°rbol el que se muestra a la base de datos como un plan de consulta.  En los compiladores convencionales, esta etapa corresponde condicionalmente a las etapas de asignaci√≥n de registros, planificaci√≥n y selecci√≥n de instrucciones. </p><br><p>  El √∫ltimo paso en el trabajo del int√©rprete es directamente la ejecuci√≥n del √°rbol de operadores de √°lgebra f√≠sica. </p><br><h1 id="model-volcano-i-ispolnenie-zaprosov">  Modelo de volc√°n y ejecuci√≥n de consultas </h1><br><p>  Los int√©rpretes de √°rbol de √°lgebra f√≠sica siempre se han utilizado en bases de datos comerciales cerradas, pero la literatura acad√©mica generalmente se refiere al optimizador experimental Volcano, desarrollado a principios de los 90. </p><br><p>  En el modelo Volcano, cada operador de un √°rbol de √°lgebra f√≠sica se convierte en una estructura con tres funciones: abrir, luego, cerrar.  Adem√°s de las funciones, el operador contiene un estado operativo: estado.  La funci√≥n abierta inicia el estado de la declaraci√≥n, la siguiente funci√≥n devuelve la siguiente <em>tupla</em> (tupla en ingl√©s) o NULL, si no quedan tuplas, la funci√≥n de cierre termina la declaraci√≥n: </p><br><p><img src="https://habrastorage.org/webt/oj/rs/td/ojrstdsuwcja-qrhljipd3cooeu.jpeg"></p><br><p>  Los operadores se pueden anidar para formar un √°rbol de operadores de √°lgebra f√≠sica.  Cada operador, por lo tanto, itera sobre las tuplas de una relaci√≥n existente en un medio real o una relaci√≥n virtual formada al enumerar las tuplas de operadores anidados: </p><br><p><img src="https://habrastorage.org/webt/qv/pk/pj/qvpkpjoiusjmjxvxj6xlp_lci3y.jpeg"></p><br><p>  En t√©rminos de lenguajes modernos de alto nivel, el √°rbol de tales operadores es una cascada de iteradores. </p><br><p>  Incluso los int√©rpretes de consultas industriales en DBMS relacional son repelidos del modelo Volcano, por eso lo tom√© como la base del int√©rprete PigletQL. </p><br><h1 id="pigletql">  PigletQL </h1><br><p><img src="https://habrastorage.org/webt/j9/sq/4w/j9sq4wdaertiyjii_h-vnxihrak.jpeg"></p><br><p>  Para demostrar el modelo, desarroll√© el int√©rprete del lenguaje de consulta limitado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PigletQL</a> .  Est√° escrito en C, admite la creaci√≥n de tablas en el estilo de SQL, pero est√° limitado a un solo tipo: enteros positivos de 32 bits.  Todas las tablas est√°n en la memoria.  El sistema funciona en un solo hilo y no tiene un mecanismo de transacci√≥n. </p><br><p>  No hay optimizador en PigletQL, y las consultas SELECT se compilan directamente en el √°rbol de operadores de √°lgebra f√≠sica.  Las consultas restantes (CREATE TABLE e INSERT) funcionan directamente desde las vistas internas principales. </p><br><p>  Ejemplo de sesi√≥n de usuario en PigletQL: </p><br><pre><code class="plaintext hljs">&gt; ./pigletql &gt; CREATE TABLE tab1 (col1,col2,col3); &gt; INSERT INTO tab1 VALUES (1,2,3); &gt; INSERT INTO tab1 VALUES (4,5,6); &gt; SELECT col1,col2,col3 FROM tab1; col1 col2 col3 1 2 3 4 5 6 rows: 2 &gt; SELECT col1 FROM tab1 ORDER BY col1 DESC; col1 4 1 rows: 2</code> </pre> <br><h2 id="leksicheskiy-i-sintaksicheskiy-analizatory">  L√©xico y analizador </h2><br><p>  PigletQL es un lenguaje muy simple, y su implementaci√≥n no fue necesaria en las etapas del an√°lisis l√©xico y de an√°lisis. </p><br><p>  El analizador l√©xico est√° escrito a mano.  Se <a href="">crea</a> un objeto analizador ( <a href="">scanner_t</a> ) a partir de la cadena de consulta, que entrega tokens uno por uno: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scanner_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">token_t</span></span> scanner_next(<span class="hljs-keyword"><span class="hljs-keyword">scanner_t</span></span> *scanner);</code> </pre> <br><p>  El an√°lisis se realiza utilizando el m√©todo de descenso recursivo.  Primero, se <a href="">crea el</a> objeto <a href="">parser_t</a> , que, despu√©s de haber recibido el analizador l√©xico (scanner_t), llena el objeto query_t con informaci√≥n sobre la solicitud: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span> *query_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">parser_t</span></span> *parser_create(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">parser_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *parser, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">scanner_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *scanner, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span></span>;</code> </pre> <br><p>  El resultado del an√°lisis en query_t es uno de los tres tipos de consulta admitidos por PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> query_tag { QUERY_SELECT, QUERY_CREATE_TABLE, QUERY_INSERT, } query_tag; <span class="hljs-comment"><span class="hljs-comment">/* * ... query_select_t, query_create_table_t, query_insert_t definitions ... **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_t</span></span></span><span class="hljs-class"> {</span></span> query_tag tag; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> select; <span class="hljs-keyword"><span class="hljs-keyword">query_create_table_t</span></span> create_table; <span class="hljs-keyword"><span class="hljs-keyword">query_insert_t</span></span> insert; } as; } <span class="hljs-keyword"><span class="hljs-keyword">query_t</span></span>;</code> </pre> <br><p>  El tipo de consulta m√°s complejo en PigletQL es SELECT.  Corresponde a la <a href="">estructura de</a> datos <a href="">query_select_t</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">query_select_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Attributes to output */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> attr_names[MAX_ATTR_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> attr_num; <span class="hljs-comment"><span class="hljs-comment">/* Relations to get tuples from */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rel_name_t</span></span> rel_names[MAX_REL_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> rel_num; <span class="hljs-comment"><span class="hljs-comment">/* Predicates to apply to tuples */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicates[MAX_PRED_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pred_num; <span class="hljs-comment"><span class="hljs-comment">/* Pick an attribute to sort by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> has_order; <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> order_by_attr; <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> order_type; } <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span>;</code> </pre> <br><p>  La estructura contiene una descripci√≥n de la consulta (un conjunto de atributos solicitados por el usuario), una lista de fuentes de datos: relaciones, un conjunto de predicados que filtran tuplas e informaci√≥n sobre el atributo utilizado para ordenar los resultados. </p><br><h2 id="semanticheskiy-analizator">  Analizador sem√°ntico </h2><br><p>  La fase de an√°lisis sem√°ntico en SQL regular implica verificar la existencia de las tablas enumeradas, las columnas en las tablas y la comprobaci√≥n de tipos en las expresiones de consulta.  Para las comprobaciones relacionadas con tablas y columnas, se utiliza el directorio de la base de datos, donde se almacena toda la informaci√≥n sobre la estructura de datos. </p><br><p>  No hay expresiones complejas en PigletQL, por lo que la verificaci√≥n de consultas se reduce a la verificaci√≥n de metadatos del cat√°logo de tablas y columnas.  Las consultas SELECT, por ejemplo, son <a href="">validadas</a> por la funci√≥n <a href="">validate_select</a> .  Lo traer√© en forma abreviada: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* All the relations should exist */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; rel_i &lt; query-&gt;rel_num; rel_i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (catalogue_get_relation(cat, query-&gt;rel_names[rel_i])) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: relation '%s' does not exist\n"</span></span>, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* Relation names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rel_names_unique(query-&gt;rel_names, query-&gt;rel_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attribute names should be unique */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!attr_names_unique(query-&gt;attr_names, query-&gt;attr_num)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Attributes should be present in relations listed */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ORDER BY attribute should be available in the list of attributes chosen */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Predicate attributes should be available in the list of attributes projected */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  Si la solicitud es v√°lida, el siguiente paso es compilar el √°rbol de an√°lisis en un √°rbol de operador. </p><br><h2 id="kompilyaciya-zaprosov-v-promezhutochnoe-predstavlenie">  Compilaci√≥n de consultas en una vista intermedia </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/b3/7i/6a/b37i6a7mfq9z6adzpkmdpcuunls.jpeg"></a> </p><br><p>  En los int√©rpretes de SQL completos, generalmente hay dos representaciones intermedias: √°lgebra l√≥gica y f√≠sica. </p><br><p>  Un simple int√©rprete de PigletQL realiza consultas CREATE TABLE e INSERT directamente desde sus √°rboles de an√°lisis, es decir, las <a href="">estructuras</a> <a href="">query_create_table_t</a> y <a href="">query_insert_t</a> .  Las consultas SELECT m√°s complejas se compilan en una √∫nica representaci√≥n intermedia, que ser√° ejecutada por el int√©rprete. </p><br><p>  El √°rbol del operador se construye desde las hojas hasta la ra√≠z en la siguiente secuencia: </p><br><ol><li><p>  A partir de la parte derecha de la consulta ("... DESDE relaci√≥n1, relaci√≥n2, ..."), se obtienen los nombres de las relaciones deseadas, para cada una de las cuales se crea una instrucci√≥n de exploraci√≥n. </p><br></li><li><p>  Al extraer las tuplas de las relaciones, los operadores de exploraci√≥n se combinan en un √°rbol binario izquierdo a trav√©s del operador de uni√≥n. </p><br></li><li><p>  La declaraci√≥n del proyecto selecciona los atributos solicitados por el usuario ("SELECT attr1, attr2, ..."). </p><br></li><li><p>  Si se especifica alg√∫n predicado ("... DONDE a = 1 Y b&gt; 10 ..."), la instrucci√≥n de selecci√≥n se agrega al √°rbol de arriba. </p><br></li><li><p>  Si se especifica el m√©todo para ordenar el resultado ("... ORDER BY attr1 DESC"), el operador de clasificaci√≥n se agrega a la parte superior del √°rbol. </p><br></li></ol><br><p>  Compilaci√≥n en <a href="">c√≥digo</a> PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *compile_select(<span class="hljs-keyword"><span class="hljs-keyword">catalogue_t</span></span> *cat, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query_select_t</span></span> *query) { <span class="hljs-comment"><span class="hljs-comment">/* Current root operator */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 1. Scan ops */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* 2. Join ops*/</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rel_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); root_op = scan_op_create(rel); rel_i += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; rel_i &lt; query-&gt;rel_num; rel_i++) { rel = catalogue_get_relation(cat, query-&gt;rel_names[rel_i]); <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op = scan_op_create(rel); root_op = join_op_create(root_op, scan_op); } } <span class="hljs-comment"><span class="hljs-comment">/* 3. Project */</span></span> root_op = proj_op_create(root_op, query-&gt;attr_names, query-&gt;attr_num); <span class="hljs-comment"><span class="hljs-comment">/* 4. Select */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;pred_num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *select_op = select_op_create(root_op); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pred_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; pred_i &lt; query-&gt;pred_num; pred_i++) { <span class="hljs-keyword"><span class="hljs-keyword">query_predicate_t</span></span> predicate = query-&gt;predicates[pred_i]; <span class="hljs-comment"><span class="hljs-comment">/* Add a predicate to the select operator */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } root_op = select_op; } <span class="hljs-comment"><span class="hljs-comment">/* 5. Sort */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (query-&gt;has_order) root_op = sort_op_create(root_op, query-&gt;order_by_attr, query-&gt;order_type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root_op; }</code> </pre> <br><p>  Despu√©s de que se forma el √°rbol, las transformaciones de optimizaci√≥n generalmente se llevan a cabo, pero PigletQL inmediatamente pasa a la etapa de ejecuci√≥n de la representaci√≥n intermedia. </p><br><h2 id="ispolnenie-promezhutochnogo-predstavleniya">  Ejecuci√≥n de una presentaci√≥n provisional. </h2><br><p> <a href=""><img src="https://habrastorage.org/webt/q7/dj/xe/q7djxezm_g_dcjund49iztea5ec.jpeg"></a> </p><br><p>  El modelo Volcano implica una interfaz para trabajar con operadores a trav√©s de tres operaciones comunes de apertura / siguiente / cierre.  En esencia, cada declaraci√≥n de Volcano es un iterador del que las tuplas se "extraen" una por una, por lo que este enfoque de ejecuci√≥n tambi√©n se denomina modelo de extracci√≥n. </p><br><p>  Cada uno de estos iteradores puede invocar las mismas funciones que los iteradores anidados, crear tablas temporales con resultados intermedios y convertir las tuplas entrantes. </p><br><p>  Ejecutando <a href="">consultas SELECT</a> en PigletQL: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval_select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">catalogue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">query_select_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Compile the operator tree: */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *root_op = compile_select(cat, query); <span class="hljs-comment"><span class="hljs-comment">/* Eval the tree: */</span></span> { root_op-&gt;open(root_op-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> tuples_received = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = root_op-&gt;next(root_op-&gt;state))) { <span class="hljs-comment"><span class="hljs-comment">/* attribute list for the first row only */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tuples_received == <span class="hljs-number"><span class="hljs-number">0</span></span>) dump_tuple_header(tuple); <span class="hljs-comment"><span class="hljs-comment">/* A table of tuples */</span></span> dump_tuple(tuple); tuples_received++; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"rows: %zu\n"</span></span>, tuples_received); root_op-&gt;close(root_op-&gt;state); } root_op-&gt;destroy(root_op); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  La solicitud se compila primero mediante la funci√≥n compile_select, que devuelve la ra√≠z del √°rbol del operador, despu√©s de lo cual se invocan las mismas funciones de apertura / siguiente / cierre en el operador ra√≠z.  Cada llamada al siguiente devuelve la siguiente tupla o NULL.  En el √∫ltimo caso, esto significa que se han extra√≠do todas las tuplas y se debe llamar a la funci√≥n de iterador cerrado. </p><br><p>  Las tuplas resultantes son recalculadas y enviadas por la tabla a la secuencia de salida est√°ndar. </p><br><h2 id="operatory">  Operadores </h2><br><p>  Lo m√°s interesante de PigletQL es el √°rbol de operadores.  Mostrar√© el dispositivo de algunos de ellos. </p><br><p>  <a href="">Los</a> operadores tienen una <a href="">interfaz</a> com√∫n y consisten en punteros a la funci√≥n abrir / siguiente / cerrar y una funci√≥n adicional destruir destruir, que libera los recursos de todo el √°rbol de operadores a la vez: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_open)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *(*op_next)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_close)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*op_destroy)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *op)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/* The operator itself is just 4 pointers to related ops and operator state */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator_t</span></span></span><span class="hljs-class"> {</span></span> op_open open; op_next next; op_close close; op_destroy destroy; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state; } ;</code> </pre> <br><p>  Adem√°s de las funciones, el operador puede contener un estado interno arbitrario (puntero de estado). </p><br><p>  A continuaci√≥n analizar√© el dispositivo de dos operadores interesantes: el escaneo m√°s simple y la creaci√≥n de un tipo de relaci√≥n intermedia. </p><br><h3 id="operator-scan">  Declaraci√≥n de escaneo </h3><br><p>  La declaraci√≥n que inicia cualquier consulta es scan.  √âl solo pasa por todas las tuplas de la relaci√≥n.  <a href="">El estado interno de exploraci√≥n</a> es un puntero a la relaci√≥n desde donde se recuperar√°n las tuplas, el √≠ndice de la pr√≥xima tupla en la relaci√≥n y una estructura de enlace a la tupla actual que se pasa al usuario: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scan_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* A reference to the relation being scanned */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation; <span class="hljs-comment"><span class="hljs-comment">/* Next tuple index to retrieve from the relation */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> next_tuple_i; <span class="hljs-comment"><span class="hljs-comment">/* A structure to be filled with references to tuple data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> current_tuple; } <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>;</code> </pre> <br><p>  Para crear el estado de una instrucci√≥n de escaneo, necesita una relaci√≥n de origen;  todo lo dem√°s (punteros a las funciones correspondientes) ya se conoce: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *scan_op_create(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *relation) { <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *op = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*op)); assert(op); *op = (<span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span>) { .open = scan_op_open, .next = scan_op_next, .close = scan_op_close, .destroy = scan_op_destroy, }; <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *state = <span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*state)); assert(state); *state = (<span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span>) { .relation = relation, .next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.tag = TUPLE_SOURCE, .current_tuple.as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>, .current_tuple.as.source.relation = relation, }; op-&gt;state = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op; }</code> </pre> <br><p>  Operaciones de apertura / cierre en el caso de enlaces de restablecimiento de escaneo al primer elemento de la relaci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; op_state-&gt;next_tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *current_tuple = &amp;op_state-&gt;current_tuple; current_tuple-&gt;as.source.tuple_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  La siguiente llamada devuelve la siguiente tupla, o NULL si no hay m√°s tuplas en la relaci√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *scan_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">scan_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;next_tuple_i &gt;= op_state-&gt;relation-&gt;tuple_num) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">tuple_source_t</span></span> *source_tuple = &amp;op_state-&gt;current_tuple.as.source; source_tuple-&gt;tuple_i = op_state-&gt;next_tuple_i; op_state-&gt;next_tuple_i++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;op_state-&gt;current_tuple; }</code> </pre><br><h3 id="operator-sort">  Ordenar declaraci√≥n </h3><br><p>  La instrucci√≥n sort produce tuplas en el orden especificado por el usuario.  Para hacer esto, cree una relaci√≥n temporal con las tuplas obtenidas de operadores anidados y ord√©nela. </p><br><p>  <a href="">El estado interno del</a> operador: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sort_op_state_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source; <span class="hljs-comment"><span class="hljs-comment">/* Attribute to sort tuples by */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">attr_name_t</span></span> sort_attr_name; <span class="hljs-comment"><span class="hljs-comment">/* Sort order, descending or ascending */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sort_order_t</span></span> sort_order; <span class="hljs-comment"><span class="hljs-comment">/* Temporary relation to be used for sorting*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">relation_t</span></span> *tmp_relation; <span class="hljs-comment"><span class="hljs-comment">/* Relation scan op */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *tmp_relation_scan_op; } <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span>;</code> </pre> <br><p>  La clasificaci√≥n se realiza de acuerdo con los atributos especificados en la solicitud (sort_attr_name y sort_order) a lo largo de la relaci√≥n de tiempo (tmp_relation).  Todo esto sucede cuando se llama a la funci√≥n abierta: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_open</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">operator_t</span></span> *source = op_state-&gt;source; <span class="hljs-comment"><span class="hljs-comment">/* Materialize a table to be sorted */</span></span> source-&gt;open(source-&gt;state); <span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *tuple = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((tuple = source-&gt;next(source-&gt;state))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation = relation_create_for_tuple(tuple); assert(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation_scan_op = scan_op_create(op_state-&gt;tmp_relation); } relation_append_tuple(op_state-&gt;tmp_relation, tuple); } source-&gt;close(source-&gt;state); <span class="hljs-comment"><span class="hljs-comment">/* Sort it */</span></span> relation_order_by(op_state-&gt;tmp_relation, op_state-&gt;sort_attr_name, op_state-&gt;sort_order); <span class="hljs-comment"><span class="hljs-comment">/* Open a scan op on it */</span></span> op_state-&gt;tmp_relation_scan_op-&gt;open(op_state-&gt;tmp_relation_scan_op-&gt;state); }</code> </pre> <br><p>  El operador temporal tmp_relation_scan_op realiza la enumeraci√≥n de los elementos de la relaci√≥n temporal: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">tuple_t</span></span> *sort_op_next(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *state) { <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op_state-&gt;tmp_relation_scan_op-&gt;next(op_state-&gt;tmp_relation_scan_op-&gt;state);; }</code> </pre><br><p>  La relaci√≥n temporal se desasigna en la funci√≥n de cierre: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort_op_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sort_op_state_t</span></span> *op_state = (typeof(op_state)) state; <span class="hljs-comment"><span class="hljs-comment">/* If there was a tmp relation - destroy it */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (op_state-&gt;tmp_relation) { op_state-&gt;tmp_relation_scan_op-&gt;close(op_state-&gt;tmp_relation_scan_op-&gt;state); scan_op_destroy(op_state-&gt;tmp_relation_scan_op); relation_destroy(op_state-&gt;tmp_relation); op_state-&gt;tmp_relation = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre><br><p>  Aqu√≠ puede ver claramente por qu√© las operaciones de clasificaci√≥n en columnas sin √≠ndices pueden llevar tanto tiempo. </p><br><h2 id="primery-raboty">  Ejemplos de trabajo </h2><br><p>  Dar√© algunos ejemplos de consultas PigletQL y los √°rboles correspondientes de √°lgebra f√≠sica. </p><br><p>  El ejemplo m√°s simple donde se seleccionan todas las tuplas de una relaci√≥n: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1; a1 1 4 rows: 2 &gt;</code> </pre> <br><p>  Para las consultas m√°s simples, solo se utilizan las tuplas de recuperaci√≥n de la relaci√≥n de escaneo y se selecciona el √∫nico atributo del proyecto de las tuplas: </p><br><p><img src="https://habrastorage.org/webt/3n/63/oa/3n63oa4mcglybfftogb195rdxko.jpeg"></p><br><p>  Elegir tuplas con un predicado: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 where a1 &gt; 3; a1 4 rows: 1 &gt;</code> </pre> <br><p>  Los predicados se expresan mediante la instrucci√≥n select: </p><br><p><img src="https://habrastorage.org/webt/h8/82/r7/h882r7yfruh0orjlenqkb-o6lzk.jpeg"></p><br><p>  Selecci√≥n de tuplas con clasificaci√≥n: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; select a1 from rel1 order by a1 desc; a1 4 1 rows: 2</code> </pre> <br><p>  El operador de clasificaci√≥n de escaneo en la llamada abierta crea ( <em>materializa</em> ) una relaci√≥n temporal, coloca todas las tuplas entrantes all√≠ y clasifica el conjunto.  Despu√©s de eso, en las pr√≥ximas llamadas, infiere tuplas de la relaci√≥n temporal en el orden especificado por el usuario: </p><br><p><img src="https://habrastorage.org/webt/oq/ec/ap/oqecap_w6sdwv3-d7fckp2lfeyo.jpeg"></p><br><p>  Combinando tuplas de dos relaciones con un predicado: </p><br><pre> <code class="plaintext hljs">&gt; ./pigletql &gt; create table rel1 (a1,a2,a3); &gt; insert into rel1 values (1,2,3); &gt; insert into rel1 values (4,5,6); &gt; create table rel2 (a4,a5,a6); &gt; insert into rel2 values (7,8,6); &gt; insert into rel2 values (9,10,6); &gt; select a1,a2,a3,a4,a5,a6 from rel1, rel2 where a3=a6; a1 a2 a3 a4 a5 a6 4 5 6 7 8 6 4 5 6 9 10 6 rows: 2</code> </pre> <br><p>  El operador de uni√≥n en PigletQL no utiliza ning√∫n algoritmo complejo, sino que simplemente forma un producto cartesiano a partir de los conjuntos de tuplas de los sub√°rboles izquierdo y derecho.  Esto es muy ineficiente, pero para un int√©rprete de demostraci√≥n lo har√°: </p><br><p><img src="https://habrastorage.org/webt/if/ct/zp/ifctzpcu29dnns3ijm3bwlckzyk.jpeg"></p><br><h1 id="vyvody">  Conclusiones </h1><br><p>  En conclusi√≥n, noto que si est√° haciendo un int√©rprete de un lenguaje similar al SQL, entonces probablemente deber√≠a tomar cualquiera de las muchas bases de datos relacionales disponibles.  Se han invertido miles de a√±os-persona en optimizadores modernos e int√©rpretes de consultas de bases de datos populares, y lleva a√±os desarrollar incluso las bases de datos de prop√≥sito general m√°s simples. </p><br><p>  El lenguaje de demostraci√≥n PigletQL imita el trabajo del int√©rprete de SQL, pero en realidad usamos solo elementos individuales de la arquitectura Volcano y solo para esos (¬°raros!) Tipos de consultas que son dif√≠ciles de expresar en el marco del modelo relacional. </p><br><p>  Sin embargo, repito: incluso un conocimiento superficial de la arquitectura de tales int√©rpretes es √∫til en los casos en que es necesario trabajar de manera flexible con los flujos de datos. </p><br><h1 id="literatura">  Literatura </h1><br><p>  Si est√° interesado en los temas b√°sicos del desarrollo de la base de datos, entonces los libros son mejores que la "Implementaci√≥n del sistema de base de datos" (Garcia-Molina H., Ullman JD, Widom J., 2000), no encontrar√°. </p><br><p>  Su √∫nico inconveniente es una orientaci√≥n te√≥rica.  Personalmente, me gusta cuando se adjuntan al material ejemplos concretos de c√≥digo o incluso un proyecto de demostraci√≥n.  Para esto, puede consultar el libro "Dise√±o e implementaci√≥n de bases de datos" (Sciore E., 2008), que proporciona el c√≥digo completo para una base de datos relacional en Java. </p><br><p>  Las bases de datos relacionales m√°s populares todav√≠a usan variaciones sobre el tema de Volcano.  La publicaci√≥n original est√° escrita en un lenguaje muy accesible y se puede encontrar f√°cilmente en Google Scholar: "Volcano: un sistema de evaluaci√≥n de consultas extensible y paralelo" (Graefe G., 1994). </p><br><p>  Aunque los int√©rpretes de SQL han cambiado bastante en detalle en las √∫ltimas d√©cadas, la estructura muy general de estos sistemas no ha cambiado durante mucho tiempo.  Puede hacerse una idea en un art√≠culo de revisi√≥n del mismo autor, "T√©cnicas de evaluaci√≥n de consultas para grandes bases de datos" (Graefe G. 1993). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461699/">https://habr.com/ru/post/461699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461689/index.html">Identificaci√≥n de desarrollador de IoT</a></li>
<li><a href="../461691/index.html">C√≥mo cerramos las vulnerabilidades en el sistema operativo Astra Linux Special Edition</a></li>
<li><a href="../461693/index.html">Compilaci√≥n cruzada de OpenCV 4 para Raspberry Pi y BeagleBone Black</a></li>
<li><a href="../461695/index.html">Pasant√≠a VFX</a></li>
<li><a href="../461697/index.html">Cerveza inteligencia</a></li>
<li><a href="../461703/index.html">Informes de micropasos en el trabajo de un programador</a></li>
<li><a href="../461707/index.html">Las aventuras de los esquivos Malvari, Parte V: m√°s scripts de DDE y COM</a></li>
<li><a href="../461709/index.html">Qu√© esperar si quieres convertirte en desarrollador de iOS</a></li>
<li><a href="../461713/index.html">4 formas de ahorrar en copias de seguridad en la nube</a></li>
<li><a href="../461715/index.html">Miedo y asco como Techdir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>