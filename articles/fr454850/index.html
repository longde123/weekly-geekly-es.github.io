<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèæ üë®üèø üò† L'√©volution d'un algorithme unique ‚õ∞Ô∏è üç∞ üëñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelque temps, mon coll√®gue m'a demand√© de l'aider avec un probl√®me. J'ai r√©solu le probl√®me pour lui, mais en plus, il m'a sembl√© qu'en r√©solv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'√©volution d'un algorithme unique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454850/"><p>  Il y a quelque temps, mon coll√®gue m'a demand√© de l'aider avec un probl√®me.  J'ai r√©solu le probl√®me pour lui, mais en plus, il m'a sembl√© qu'en r√©solvant ce probl√®me, plusieurs algorithmes et techniques de programmation pouvaient √™tre expliqu√©s.  Et montrent √©galement l'acc√©l√©ration du temps d'ex√©cution de l'algorithme de 25 secondes √† 40 ms. </p><a name="habracut"></a><br><h1 id="postanovka-zadachi">  √ânonc√© du probl√®me </h1><br><p>  Pour un projet personnel, mon coll√®gue avait besoin d'un algorithme pour trouver cinquante vid√©os les plus similaires pour une vid√©o donn√©e.  La similitude √©tait cens√©e √™tre estim√©e par le nombre de balises expos√©es correspondantes.  Plus la vid√©o correspond √† des tags, plus ils sont similaires.  De cela, nous pouvons imm√©diatement tirer plusieurs conclusions: </p><br><ul><li>  Tous les tags sous la vid√©o peuvent √™tre combin√©s en un seul groupe; </li><li>  il n'y aura certainement pas plus de tels groupes que les vid√©os elles-m√™mes; </li><li>  si la vid√©o est similaire √† une autre vid√©o d'un certain groupe de balises, elle est √©galement similaire aux autres vid√©os de ce groupe; </li></ul><br><p>  Il s'av√®re qu'il suffit de travailler uniquement avec des groupes de balises.  Dans la premi√®re version, un coll√®gue a d√©cid√© de stocker les balises dans une table de balises: chaque vid√©o a un lien vers l'ID du groupe de balises, et les groupes eux-m√™mes sont une s√©quence de valeurs bool√©ennes qui indiquent si la balise correspondante est d√©finie.  En C #, un groupe de balises ressemble √† ceci: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre> <br><p>  Un coll√®gue a sugg√©r√© qu'il n'aurait pas plus d'un million de vid√©os sur le site et pas plus de 4 000 balises diff√©rentes, pour un compte rond, vous pouvez prendre 4096 = 2 ^ 12. <br>  Ensuite, la classe <code>TagsGroup</code> peut √™tre repr√©sent√©e comme ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = innerTags; } }</code> </pre> <br><p>  Vous devez maintenant v√©rifier la similitude entre les deux groupes de balises.  Dans les conditions actuelles, cela se transforme en une simple v√©rification de la v√©rit√© dans les √©l√©ments correspondants des tableaux <code>InnerTags</code> de deux groupes de balises: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Maintenant, il ne reste plus qu'√† calculer la similitude du groupe de balises souhait√© avec chaque groupe existant et √† s√©lectionner les cinquante plus similaires.  Je me fixe une autre condition pour assurer la stabilit√© de l'√©chantillon, √† savoir  dans l'√©chantillon final, il y aura cinquante groupes d'√©tiquettes pour lesquels <code>MeasureSimilarity</code> donn√© le r√©sultat le plus √©lev√©, tandis que les groupes d'√©tiquettes avec la m√™me <code>MeasureSimilarity</code> indice inf√©rieur pour ceux qui avaient un indice inf√©rieur dans le groupe existant d'origine.  Plus de d√©tails peuvent √™tre trouv√©s, par exemple, ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://ru.wikipedia.org/wiki/Sustainable_Sort</a> . <br>  Pour r√©soudre ce probl√®me, j'ai d√©cid√© de faire la classe <code>SimilarTagsCalculator</code> , voici son code: </p><br><div class="spoiler">  <b class="spoiler_title">SimilarTagsCalculator</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimilarTagsCalculator</span></span> { TagsGroup[] Groups { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimilarTagsCalculator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] groups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (groups == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(groups)); Groups = groups; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,          var list = new List&lt;TagsSimilarityInfo&gt;(resultLength); //      for (int groupIndex = 0; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; //      int similarityValue = TagsGroup.MeasureSimilarity(value, tagsGroup); // -  TagsSimilarityInfo newInfo = new TagsSimilarityInfo(groupIndex, similarityValue); //    ,     , if (list.Count == resultLength &amp;&amp; list[resultLength - 1].CompareTo(newInfo) == -1) { continue; //     } //   ,    -  int index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); // if (list.Count &gt; resultLength) { //    , //   , ..    list.RemoveAt(resultLength); } } // -   TagsGroup[] result = new TagsGroup[resultLength]; for (int i = 0; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } return result; } }</span></span></code> </pre> </div></div><br><p>  et la structure <code>TagsSimilarityInfo</code> : </p><br><div class="spoiler">  <b class="spoiler_title">TagsSimilarit√©Info</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> TagsSimilarityInfo : IComparable&lt;TagsSimilarityInfo&gt;, IComparable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Index { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Similarity { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsSimilarityInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> similarity</span></span></span><span class="hljs-function">)</span></span> { Index = index; Similarity = similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Index == other.Index &amp;&amp; Similarity == other.Similarity; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other &amp;&amp; Equals(other); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHashCode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">unchecked</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Index * <span class="hljs-number"><span class="hljs-number">397</span></span>) ^ Similarity; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsSimilarityInfo other</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityComparison = other.Similarity.CompareTo(Similarity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> similarityComparison != <span class="hljs-number"><span class="hljs-number">0</span></span> ? similarityComparison : Index.CompareTo(other.Index); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> obj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReferenceEquals(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, obj)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TagsSimilarityInfo other ? CompareTo(other) : <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-string"><span class="hljs-string">$"Object must be of type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">nameof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(TagsSimilarityInfo)}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> </div></div><br><p>  J'ai pr√©par√© trois rep√®res pour cet algorithme: </p><br><ul><li>  rep√®re compl√®tement al√©atoire, c.-√†-d.  le nombre de balises d√©finies dans les groupes est al√©atoire et le groupe de balises avec lequel nous comparerons est √©galement al√©atoire; </li><li>  le nombre de balises d√©finies dans les groupes augmente, nous comparerons avec le groupe dans lequel toutes les balises sont d√©finies.  Il s'av√®re que certains des derniers groupes de balises devraient √™tre les plus appropri√©s; </li><li>  comme ci-dessus, mais le nombre de balises expos√©es diminue.  Les 50 premiers groupes de balises seront les plus appropri√©s; </li></ul><br><p>  Voici les r√©sultats de r√©f√©rence pour un million de groupes: </p><br><p>  BenchmarkDotNet = v0.11.5, OS = Windows 10.0.17134.765 (1803 / April2018Update / Redstone4) <br>  Processeur Intel Core i7-6700 √† 3,40 GHz (Skylake), 1 processeur, 8 c≈ìurs logiques et 4 c≈ìurs physiques <br>  Fr√©quence = 3328126 Hz, r√©solution = 300,4694 ns, minuterie = TSC <br>  SDK .NET Core = 3.0.100-preview5-011568 <br>  [H√¥te]: .NET Core 3.0.0-preview5-27626-15 (CoreCLR 4.6.27622.75, CoreFX 4.700.19.22408), RyuJIT 64 bits </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  25.054 s </td><td>  0,1786 s </td><td>  0,1670 s </td><td>  1,53 Ko </td></tr><tr><td>  Ascendanttest </td><td>  4.180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 Ko </td></tr><tr><td>  DescendantTest </td><td>  4.147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 Ko </td></tr></tbody></table></div><br><p>  La r√©partition du temps d'ex√©cution est tr√®s grande, outre 25 secondes, c'est tr√®s long, mon coll√®gue n'accepte pas d'attendre aussi longtemps.  Faisons donc des optimisations.  Maintenant, il y a trois domaines principaux pour acc√©l√©rer le programme: </p><br><ul><li>  M√©thode <code>MeasureSimilarity</code> ; </li><li>  un algorithme dans le corps de la boucle dans <code>GetFiftyMostSimilarGroups</code> ; </li><li>  la boucle elle-m√™me dans <code>GetFiftyMostSimilarGroups</code> ; </li></ul><br><p>  Nous allons consid√©rer chacune des trois directions dans l'ordre. </p><br><h1 id="predskazanie-vetvleniy">  Pr√©diction de branche </h1><br><p>  Tout d'abord, consid√©rez la m√©thode <code>MeasureSimilarity</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.InnerTags[i] &amp;&amp; a.InnerTags[i] == b.InnerTags[i]) result++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Dans le pr√©c√©dent benchmark, il y avait une tr√®s grande variation de dur√©e d'ex√©cution entre le test al√©atoire et l'un des tests s√©quentiels.  Les groupes de balises pour les tests s√©quentiels ont √©t√© cr√©√©s selon le principe suivant: </p><br><ul><li>  le nombre requis de groupes a √©t√© divis√© en packages.  Nombre de paquets - le nombre maximum de balises dans le groupe; </li><li>  pour chaque groupe du i-√®me paquet, les premi√®res i balises ont √©t√© d√©finies; </li></ul><br><p>  Il s'av√®re que chaque groupe de balises dans ces tests se compose de deux parties cons√©cutives de balises expos√©es et non expos√©es.  <code>MeasureSimilarity</code> a toutes les conditions pr√©alables pour que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©diction de branche de</a> processeur ait un effet significatif dans les conditions actuelles.  Pour v√©rifier cela, √©crivez simplement un benchmark qui compare le temps d'ex√©cution de MeasureSimilarity pour les donn√©es al√©atoires et les donn√©es s√©quentielles: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSimilaritySum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup[] tagsGroups</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (TagsGroup tagsGroup <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tagsGroups) { result += TagsGroup.MeasureSimilarity(tagsGroup, etalon); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(sortedGroups); [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unsorted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GetSimilaritySum(unsortedGroups);</code> </pre> <br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Tri√©s </td><td>  3.704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Non tri√© </td><td>  8.211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div><br><p>  Un million de groupes d'√©tiquettes ont √©t√© test√©s, mais dans <code>Sorted</code> dans chaque groupe, il y avait d'abord plusieurs √©tiquettes expos√©es, puis des √©tiquettes non expos√©es, et dans <code>Unsorted</code> le m√™me nombre d'√©tiquettes expos√©es a √©t√© dispers√© au hasard dans tout le groupe. <br>  La diff√©rence de 5 secondes est impressionnante et quelque chose doit √™tre fait.  Pour se d√©barrasser de l'influence de la pr√©diction des branches et acc√©l√©rer g√©n√©ralement la m√©thode, vous devez vous d√©barrasser des branches elles-m√™mes.  Il n'y a qu'une seule branche dans <code>MeasureSimilarity</code> - v√©rifiant que les balises correspondantes sont d√©finies dans deux groupes.  Estimons dans quels cas la condition sera vraie, pour cela nous allons faire un tableau de la v√©rit√© de la condition: </p><br><div class="scrollable-table"><table><thead><tr><th>  a.InnerTags [i] </th><th>  b.InnerTags [i] </th><th>  R√©sultat </th></tr></thead><tbody><tr><td>  Faux </td><td>  Faux </td><td>  Faux </td></tr><tr><td>  Faux </td><td>  Vrai </td><td>  Faux </td></tr><tr><td>  Vrai </td><td>  Faux </td><td>  Faux </td></tr><tr><td>  Vrai </td><td>  Vrai </td><td>  Vrai </td></tr></tbody></table></div><br><p>  La table de v√©rit√© co√Øncide compl√®tement avec le "ET" logique, c'est-√†-dire  le r√©sultat est vrai si et seulement si les deux balises sont vraies, alors la condition peut √™tre r√©duite √†: <code>if (a.InnerTags[i] &amp;&amp; b.InnerTags[i])</code> .  Mais de cette fa√ßon, la condition demeure.  Dans l'√©tape suivante, nous nous assurerons que l'ajout au r√©sultat est toujours effectu√©, pour cela nous r√©√©crivons le corps de la boucle comme ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp;&amp; b.InnerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; result += t;</code> </pre> <br><p>  Nous ne nous sommes toujours pas d√©barrass√©s de la condition et avons m√™me ralenti la m√©thode.  Mais maintenant, il est devenu √©vident que si le type d' <code>InnerTags</code> chang√© de bool en octet (1 pour vrai et 0 pour faux), alors vous pouvez vous d√©barrasser de la condition dans l'op√©rateur ternaire.  Ensuite, la classe <code>TagsGroup</code> ressemblera √† ceci: </p><br><div class="spoiler">  <b class="spoiler_title">TagsGroup</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TagsGroup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TagsGroupLength = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } InnerTags = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[TagsGroupLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength; i++) { InnerTags[i] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) (innerTags[i] ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); } } }</code> </pre> </div></div><br><p>  Voici les r√©sultats de r√©f√©rence pour la mise √† jour de <code>MeasureSimilarity</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Tri√©s </td><td>  3.180 s </td><td>  0,0118 s </td><td>  0,0111 s </td></tr><tr><td>  Non tri√© </td><td>  3.236 s </td><td>  0,0622 s </td><td>  0,0764 s </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">√©tait:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Tri√©s </td><td>  3.704 s </td><td>  0,0411 s </td><td>  0,0364 s </td></tr><tr><td>  Non tri√© </td><td>  8.211 s </td><td>  0,0381 s </td><td>  0,0338 s </td></tr></tbody></table></div></div></div><br><p>  mais pour le bechmark principal mis √† jour: </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  3.219 s </td><td>  0,0492 s </td><td>  0,0436 s </td><td>  1,53 Ko </td></tr><tr><td>  Ascendanttest </td><td>  3.223 s </td><td>  0,0117 s </td><td>  0,0110 s </td><td>  1,53 Ko </td></tr><tr><td>  DescendantTest </td><td>  3.422 s </td><td>  0,0697 s </td><td>  0,0999 s </td><td>  1,53 Ko </td></tr></tbody></table></div><br><div class="spoiler">  <b class="spoiler_title">√©tait:</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  25.054 s </td><td>  0,1786 s </td><td>  0,1670 s </td><td>  1,53 Ko </td></tr><tr><td>  Ascendanttest </td><td>  4.180 s </td><td>  0,0174 s </td><td>  0,0162 s </td><td>  1,53 Ko </td></tr><tr><td>  DescendantTest </td><td>  4.147 s </td><td>  0,0118 s </td><td>  0,0104 s </td><td>  1,53 Ko </td></tr></tbody></table></div></div></div><br><p>  √Ä mon avis, c'√©tait d√©j√† super.  Pour ceux qui √©taient convaincus que toute l'acc√©l√©ration s'est produite uniquement parce que le type bool√©en a √©t√© remplac√© par un octet, j'ai lanc√© une r√©f√©rence pour un tel corps de boucle: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-number"><span class="hljs-number">1</span></span>) result += t;</code> </pre> <br><p>  et voici les r√©sultats: </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th></tr></thead><tbody><tr><td>  Tri√©s </td><td>  3.760 s </td><td>  0,0746 s </td><td>  0,1541 s </td></tr><tr><td>  Non tri√© </td><td>  8.628 s </td><td>  0,1699 s </td><td>  0,2382 s </td></tr></tbody></table></div><br><h1 id="upakovyvanie-dannyh">  Emballage de donn√©es </h1><br><p>  Chaque groupe a de nombreux tags, et leur nombre ne peut en aucun cas √™tre r√©duit.  De plus, vous devez comparer les balises avec le m√™me index et vous ne pouvez pas donner de r√©ponse finale sans v√©rifier toutes les balises.  Donc, dans tous les cas, nous devrons parcourir tout le groupe de balises.  Ce serait formidable de pouvoir parall√©liser cette t√¢che d'une mani√®re ou d'une autre, de sorte qu'il serait possible de traiter plusieurs balises en une seule op√©ration conditionnelle.  Vous pouvez le faire gr√¢ce √† une v√©ritable parall√©lisation, ou vous pouvez utiliser un emballage de donn√©es sp√©cial, que nous utiliserons.  Chaque balise repr√©sente d√©sormais 1 ou 0. Dans le <code>result</code> r√©sultat de l'op√©ration "ET" est simplement accumul√©.  Mais la m√™me op√©ration logique peut √™tre appliqu√©e non seulement aux nombres √† bit unique.  C # vous permet de le faire sans aucun probl√®me jusqu'√† 64 bits (vous pouvez en faire plus via <code>BitArray</code> , mais ce n'est pas √ßa).  Si nous repr√©sentons deux groupes d'√©tiquettes comme un ensemble de nombres de 64 bits avec le jeu de bits correspondant, alors il sera possible d'effectuer une op√©ration ¬´ET¬ª sur chacun de ces groupes de nombres de 64 bits.  On ne sait pas quoi faire du r√©sultat.  Regardons √† nouveau le corps de la boucle: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += t;</code> </pre> <br><p>  le r√©sultat augmente de 1 √† chaque fois que t == 1 et ne change pas lorsque t == 0. Par cons√©quent, le r√©sultat sera √©gal au nombre de fois o√π le r√©sultat de <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> √©tait √©gal √† un.  En cons√©quence, il serait possible de sauvegarder tous les r√©sultats des <code>a.InnerTags[i] &amp; b.InnerTags[i]</code> dans une sorte de tableau, et dans le r√©sultat d'√©crire uniquement le nombre d'unit√©s dans ce tableau.  Lors de l'ex√©cution de l'op√©ration ET sur plus de n nombres de bits, un r√©sultat de n bits sera et il suffira seulement de savoir combien de bits sont d√©finis parmi n.  Le nombre de bits d√©fini dans le nombre est inchang√©, ce qui signifie que vous pouvez compter ces nombres.  Il ne sert √† rien de compter pour 64 bits, car  on ne trouvera pas autant de RAM.  Pour 32 bits, vous pouvez d√©j√† trouver de l'espace sur les ordinateurs modernes, mais c'est encore beaucoup.  La m√©moire de moins de 16 bits n'est pas difficile √† trouver, mais le calcul sera relativement long.  Comme compromis, calculons pour les nombres √† 8 bits: </p><br><div class="spoiler">  <b class="spoiler_title">GenerateCountOfSettedBits</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] CountOfSettedBits = GenerateCountOfSettedBits(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateCountOfSettedBits</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  result   i      i- . byte[] result = new byte[256]; //  ,      i   , //        int[] b = new int[8]; //     for (int i = 1; i &lt; 256; i++) { //       int settedBitsCount = 0; //,       int m = 1; //   for (int j = 0; j &lt; 8; j++) { //     b[j] += m; //  ,       2. m = b[j] &gt;&gt; 1; //        b[j] = b[j] &amp; 1; //,        settedBitsCount += b[j]; } result[i] = (byte) settedBitsCount; //   } return result; }</span></span></code> </pre> </div></div><br><p>  maintenant le constructeur TagsGroup ressemble √† ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TagsGroup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] innerTags</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (innerTags.Length != TagsGroupLength) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(innerTags)); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    InnerTags = new byte[TagsGroupLength / BucketSize]; //   for (int i = 0; i &lt; TagsGroupLength / BucketSize; i++) { //     for (int j = 0; j &lt; BucketSize; j++, index++) { //    2,      InnerTags[i] &lt;&lt;= 1; //    InnerTags[i] += (byte) (innerTags[index] ? 1 : 0); } } }</span></span></code> </pre> <br><p>  Et <code>MeasureSimilarity</code> commenc√© √† ressembler √† ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Vous pouvez ex√©cuter une grande r√©f√©rence et vous assurer que tout va mieux: </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  560,5 ms </td><td>  8,285 ms </td><td>  7,344 ms </td><td>  1,53 Ko </td></tr><tr><td>  Ascendanttest </td><td>  570,1 ms </td><td>  4,108 ms </td><td>  3,431 ms </td><td>  1,53 Ko </td></tr><tr><td>  DescendantTest </td><td>  608,1 ms </td><td>  5,691 ms </td><td>  5,324 ms </td><td>  1,53 Ko </td></tr></tbody></table></div><br><p>  Est-il possible de rendre la m√©thode <code>MeasureSimilarity</code> encore plus rapide?  Bien s√ªr!  Pour ce faire, il suffit de se rendre compte que les registres √† usage g√©n√©ral sont d√©sormais majoritairement 64 bits, et que nous y enregistrons des donn√©es huit bits.  Pour ce faire, augmentez la taille de paquet dans laquelle les balises d'origine sont empaquet√©es, augmentez √† 64 bits et r√©√©crivez les m√©thodes n√©cessaires: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BucketSize = <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>[] InnerTags { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; BucketSize / <span class="hljs-number"><span class="hljs-number">8</span></span>; j++) { result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  et il s'av√®re: </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  533,3 ms </td><td>  4,802 ms </td><td>  4,492 ms </td><td>  1,53 Ko </td></tr><tr><td>  Ascendanttest </td><td>  550,9 ms </td><td>  5,435 ms </td><td>  5,084 ms </td><td>  1,53 Ko </td></tr><tr><td>  DescendantTest </td><td>  567,6 ms </td><td>  3,879 ms </td><td>  3,439 ms </td><td>  1,53 Ko </td></tr></tbody></table></div><br><p>  Ensuite, vous pouvez √©tendre la boucle int√©rieure: </p><br><div class="spoiler">  <b class="spoiler_title">MesurerSimilarit√©</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; t &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; result += CountOfSettedBits[t &amp; <span class="hljs-number"><span class="hljs-number">255</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  370,5 ms </td><td>  2,802 ms </td><td>  2,448 ms </td><td>  1,53 Ko </td></tr><tr><td>  Ascendanttest </td><td>  395,8 ms </td><td>  2,682 ms </td><td>  2,509 ms </td><td>  1,53 Ko </td></tr><tr><td>  DescendantTest </td><td>  419,5 ms </td><td>  3,352 ms </td><td>  2,971 ms </td><td>  1,53 Ko </td></tr></tbody></table></div><br><p>  Est-ce encore plus rapide?  Oui!  Si vous utilisez les innovations de .NET Core 3.0.  Bien que cette version soit toujours dans l'aper√ßu, mais d√®s le d√©but il y a une impl√©mentation de certains intrins√®ques.  Le Guide Intel Intrinsic a le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>_mm_popcnt_u64</code></a> intrins√®que.  Qui, comme d√©crit: " <em>Comptez le nombre de bits mis √† 1 dans un entier 64 bits non sign√© a, et renvoyez ce nombre en dst.</em> ".  C'est exactement ce que nous essayons de r√©aliser!  Dans .NET Core 3.0 Preview 5, cet intrins√®que est impl√©ment√© dans <code>System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount</code> (Comme indiqu√© correctement dans les commentaires de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">a-tk,</a> avant d'utiliser intrins√®que, vous devez v√©rifier que le processeur les prend en charge. Dans ce cas, v√©rifiez l'√©tat du <code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> . <code>System.Runtime.Intrinsics.X86.Popcnt.X64.IsSupported</code> ).  En l'utilisant, le code de la m√©thode <code>MeasureSimilarity</code> deviendra: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MeasureSimilarity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup a, TagsGroup b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TagsGroupLength / BucketSize; i++) { <span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span> t = a.InnerTags[i] &amp; b.InnerTags[i]; result += (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) System.Runtime.Intrinsics.X86.Popcnt.X64.PopCount(t); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  et temps d'ex√©cution: </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Moyenne </th><th>  Erreur </th><th>  Stddev </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  59,33 ms </td><td>  1,148 ms </td><td>  0,9585 ms </td><td>  1,53 Ko </td></tr><tr><td>  Ascendanttest </td><td>  74,87 ms </td><td>  1,479 ms </td><td>  1,9748 ms </td><td>  1,53 Ko </td></tr><tr><td>  DescendantTest </td><td>  119,46 ms </td><td>  2,321 ms </td><td>  2,8509 ms </td><td>  1,53 Ko </td></tr></tbody></table></div><br><p>  Impressionnant. <br>  Je ne connais pas les moyens qui peuvent acc√©l√©rer consid√©rablement la <code>MeasureSimilarity</code> et en m√™me temps ne pas g√¢cher consid√©rablement la lisibilit√©.  Je pense que vous pouvez mettre fin √† cette m√©thode. </p><br><h1 id="struktury-dannyh">  Structures de donn√©es </h1><br><p>  Nous allons maintenant <code>GetFiftyMostSimilarGroups</code> le corps de la boucle dans la m√©thode <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler">  <b class="spoiler_title">GetFiftyMostSimilarGroups</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroups</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(<span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; groupIndex &lt; Groups.Length; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { result[i] = Groups[list[i].Index]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><p>  Permettez-moi de rappeler bri√®vement ce qui se passe ici: </p><br><ul><li>  √† l'int√©rieur de la liste, une liste tri√©e des cinquante groupes de balises les plus appropri√©s est stock√©e, en fait du plus petit au plus grand, si vous comparez <code>TagsSimilarityInfo</code> ; </li><li>  ins√©rer le nouveau groupe en question dans la liste tout en conservant le tri; </li><li>  s'il y a plus de cinquante √©l√©ments dans la liste, supprimez le groupe le moins similaire (son objet info sera le plus grand et se trouvera √† la fin de la <code>list</code> ); </li></ul><br><p>  C'est-√†-dire  il s'av√®re que nous devons trouver tr√®s rapidement le plus grand √©l√©ment de la collection, pouvoir ins√©rer et supprimer rapidement.  Pour r√©soudre ces probl√®mes, il existe des structures de donn√©es sp√©ciales.  La premi√®re chose qui me vient √† l'esprit est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">groupe</a> .  Son insertion est r√©alis√©e en O (log N), obtenant le maximum en O (1), supprimant un √©l√©ment en O (log N).  Le seul probl√®me est que le tas ne peut pas √™tre it√©r√© par les √©l√©ments croissants sans le modifier.  Il n'y a pas de tas binaire dans BCL, donc je l'ai √©crit moi-m√™me: </p><br><div class="spoiler">  <b class="spoiler_title">Binaryheap</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryHeap</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;:<span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;T&gt; innerList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capacity</span></span></span><span class="hljs-function">)</span></span> { innerList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(capacity); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count =&gt; innerList.Count; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Max =&gt; innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { innerList.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; innerList[parent].CompareTo(innerList[i]) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { Swap(i, parent); i = parent; parent = (i - <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { T temp = innerList[a]; innerList[a] = innerList[b]; innerList[b] = temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Heapify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftChild = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) | <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightChild = (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> largestChild = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftChild &lt; Count &amp;&amp; innerList[leftChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = leftChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightChild &lt; Count &amp;&amp; innerList[rightChild].CompareTo(innerList[largestChild]) == <span class="hljs-number"><span class="hljs-number">1</span></span>) { largestChild = rightChild; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (largestChild == i) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Swap(i, largestChild); i = largestChild; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveMax</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { innerList[<span class="hljs-number"><span class="hljs-number">0</span></span>] = innerList[Count - <span class="hljs-number"><span class="hljs-number">1</span></span>]; innerList.RemoveAt(Count - <span class="hljs-number"><span class="hljs-number">1</span></span>); Heapify(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> innerList.GetEnumerator(); } IEnumerator IEnumerable.GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((IEnumerable) innerList).GetEnumerator(); } }</code> </pre> </div></div><br><p>  l'impl√©mentation correspondante de la m√©thode <code>GetFiftyMostSimilarGroups</code> se trouve dans le code source de l'article (lien ci-dessous). <br>  En plus du tas, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbre de recherche binaire</a> peut appara√Ætre.  Un arbre de recherche binaire √©quilibr√© peut fournir une insertion pour O (log N), obtenir un maximum pour O (log N), supprimer un √©l√©ment pour O (log N).  L'avantage de cette structure est qu'elle peut √™tre it√©r√©e dans l'ordre croissant et, en outre, l'arborescence de recherche rouge-noir dans BCL est impl√©ment√©e dans SortedSet (dans un grand cadre, l'obtention d'un maximum est beaucoup plus lente que dans .netcore 3.0 et alloue de la m√©moire).  L'impl√©mentation de <code>GetFiftyMostSimilarGroups</code> pour <code>GetFiftyMostSimilarGroups</code> peut √™tre trouv√©e dans le code source de l'article. <br>  R√©sultats de r√©f√©rence pour les trois impl√©mentations <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="scrollable-table"><table><thead><tr><th>  La m√©thode </th><th>  Algorithme de tri </th><th>  Moyenne </th><th>  Allou√© </th></tr></thead><tbody><tr><td>  Randomtest </td><td>  Liste </td><td>  60,06 ms </td><td>  1704 B </td></tr><tr><td>  Randomtest </td><td>  Sortedset </td><td>  65,46 ms </td><td>  24384 B </td></tr><tr><td>  Randomtest </td><td>  Tas </td><td>  60,55 ms </td><td>  2912 B </td></tr><tr><td>  Ascendanttest </td><td>  Liste </td><td>  75,42 ms </td><td>  1704 B </td></tr><tr><td>  Ascendanttest </td><td>  Sortedset </td><td>  161,12 ms </td><td>  9833424 B </td></tr><tr><td>  Ascendanttest </td><td>  Tas </td><td>  86,87 ms </td><td>  2912 B </td></tr><tr><td>  DescendantTest </td><td>  Liste </td><td>  119,23 ms </td><td>  880 B </td></tr><tr><td>  DescendantTest </td><td>  Sortedset </td><td>  125,03 ms </td><td>  3024 B </td></tr><tr><td>  DescendantTest </td><td>  Tas </td><td>  118,62 ms </td><td>  2088 B </td></tr></tbody></table></div><br><p>  L'impl√©mentation d'origine avec une feuille gagne presque partout dans le temps, et certainement partout dans la m√©moire.  Cela se produit du fait que pour un algorithme avec une feuille, l'insertion est effectu√©e dans O (log N) pour la recherche, et presque O (1) pour l'insertion, car  la copie d'un si petit nombre d'√©l√©ments se produit tr√®s rapidement, obtenant un maximum pour O (1), supprimant un √©l√©ment √©galement pour O (1), car  dans .net, la suppression du dernier √©l√©ment de la feuille est remplac√©e par l'√©criture dans le dernier √©l√©ment d'une valeur vide (dans le noyau .net, rien n'est √©crit dans les structures).  S'il fallait donner non pas 50, mais disons 1000 des groupes les plus similaires, alors tr√®s probablement, un algorithme avec une feuille ne fonctionnerait pas.  En fait, tout cela est un petit raisonnement sp√©culatif, car  Vous pouvez toujours ajuster chacun des algorithmes. </p><br><h1 id="mnogopotochnost">  Multithreading </h1><br><p>  Il reste maintenant √† essayer d'am√©liorer la boucle elle-m√™me dans <code>GetFiftyMostSimilarGroups</code> .  Seul le multithreading vient √† l'esprit.  L'id√©e est de diviser la liste compl√®te des groupes en plusieurs packages.  Dans chaque package, trouvez les 50 groupes de balises les plus similaires, puis parmi eux, trouvez les 50 derniers groupes les plus similaires. <br>  La version multithread de <code>GetFiftyMostSimilarGroups</code> ressemble √† ceci: </p><br><div class="spoiler"> <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThread</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,     const int threadsCount = 4; //   int bucketSize = Groups.Length / threadsCount; var tasks = new Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { int leftIndex = i * bucketSize; //    int rightIndex = (i + 1) * bucketSize; //    //    tasks[i] = Task&lt;List&lt;TagsSimilarityInfo&gt;&gt;.Factory.StartNew(() =&gt; GetFiftyMostSimilarGroupsMultiThreadCore(value, leftIndex, rightIndex)); } Task.WaitAll(tasks); //    var taskResults = new List&lt;TagsSimilarityInfo&gt;[threadsCount]; for (int i = 0; i &lt; threadsCount; i++) { taskResults[i] = tasks[i].Result; } //      return MergeTaskResults(resultLength, threadsCount, taskResults); }</span></span></code> </pre> </div></div><br><p>  <code>GetFiftyMostSimilarGroupsMultiThreadCore</code>       <code>GetFiftyMostSimilarGroups</code> : </p><br><div class="spoiler"> <b class="spoiler_title">GetFiftyMostSimilarGroupsMultiThreadCore</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">List&lt;TagsSimilarityInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFiftyMostSimilarGroupsMultiThreadCore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TagsGroup </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> leftIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rightIndex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultLength = <span class="hljs-number"><span class="hljs-number">50</span></span>; List&lt;TagsSimilarityInfo&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;TagsSimilarityInfo&gt;(resultLength); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = leftIndex; groupIndex &lt; rightIndex; groupIndex++) { TagsGroup tagsGroup = Groups[groupIndex]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> similarityValue = TagsGroup.MeasureSimilarity(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, tagsGroup); TagsSimilarityInfo newInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsSimilarityInfo(groupIndex, similarityValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count == resultLength &amp;&amp; list[resultLength - <span class="hljs-number"><span class="hljs-number">1</span></span>].CompareTo(newInfo) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = ~list.BinarySearch(newInfo); list.Insert(index, newInfo); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list.Count &gt; resultLength) { list.RemoveAt(resultLength); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list; }</code> </pre> </div></div><br><p>     <code>MergeTaskResults</code> .   -    taskResults    . ,  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> .     ,  <code>threadsCount</code> ,     :         ,     ,    ,    : </p><br><div class="spoiler"> <b class="spoiler_title">MergeTaskResults</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-function">TagsGroup[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MergeTaskResults</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resultLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsCount, List&lt;TagsSimilarityInfo&gt;[] taskResults</span></span></span><span class="hljs-function">)</span></span> { TagsGroup[] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TagsGroup[resultLength]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] indices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[threadsCount]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; resultLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; TagsSimilarityInfo currentBest = taskResults[minIndex][indices[minIndex]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; threadsCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = taskResults[j][indices[j]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current.CompareTo(currentBest) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { minIndex = j; currentBest = taskResults[minIndex][indices[minIndex]]; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> groupIndex = currentBest.Index; result[i] = Groups[groupIndex]; indices[minIndex]++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><ul><li>  <code>indices</code>      <code>taskResults</code> ; </li><li> <code>minIndex</code> ‚Äî   <code>taskResults</code> ,         ; </li><li> <code>currentBest</code> ‚Äî -      ; </li><li> <code>current</code> ‚Äî -    ; </li></ul><br><p>    : </p><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 28.76 ms </td><td> 0.5677 ms </td><td> 1.414 ms </td><td> 1.4 KB </td></tr><tr><td> AscendantTest </td><td> 32.36 ms </td><td> 0.8930 ms </td><td> 2.591 ms </td><td> 1.4 KB </td></tr><tr><td> DescendantTest </td><td> 41.36 ms </td><td> 0.8908 ms </td><td> 2.626 ms </td><td> 1.4 KB </td></tr></tbody></table></div><br><div class="spoiler"> <b class="spoiler_title">     :</b> <div class="spoiler_text"><div class="scrollable-table"><table><thead><tr><th> Method </th><th> Mean </th><th> Error </th><th> StdDev </th><th> Allocated </th></tr></thead><tbody><tr><td> RandomTest </td><td> 25054 ms </td><td> 1786 ms </td><td> 1670 ms </td><td> 1.53 KB </td></tr><tr><td> AscendantTest </td><td> 4180 ms </td><td> 174 ms </td><td> 162 ms </td><td> 1.53 KB </td></tr><tr><td> DescendantTest </td><td> 4147 ms </td><td> 118 ms </td><td> 104 ms </td><td> 1.53 KB </td></tr></tbody></table></div></div></div><br><p>            .   .    ,    ,       4  50. , ,   . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    </a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454850/">https://habr.com/ru/post/fr454850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454830/index.html">3 qualit√©s cl√©s pour un chef de produit r√©ussi: Alexander Belyaev</a></li>
<li><a href="../fr454832/index.html">Pourquoi une semaine de travail de quatre jours est une mauvaise histoire</a></li>
<li><a href="../fr454834/index.html">Les termes r√©els de l'√©tude de l'impression tactile √† faible motivation</a></li>
<li><a href="../fr454840/index.html">D√©m√©nagement prudent aux Pays-Bas avec sa femme et son hypoth√®que. Partie 2: pr√©parer des documents et d√©m√©nager</a></li>
<li><a href="../fr454844/index.html">Odigest: int√©ressant pour les cr√©ateurs de la semaine</a></li>
<li><a href="../fr454856/index.html">Nous analysons les vuln√©rabilit√©s de validation de certificat SSL / TLS dans un logiciel non navigateur</a></li>
<li><a href="../fr454860/index.html">Aidons QueryProvider √† g√©rer les cha√Ænes interpol√©es</a></li>
<li><a href="../fr454864/index.html">Comment sont les processus de d√©veloppement dans diff√©rentes entreprises</a></li>
<li><a href="../fr454868/index.html">Compilation de C dans WebAssembly sans Emscripten</a></li>
<li><a href="../fr454872/index.html">Space Invaders: maintenant en 512 octets (assembleur x86)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>