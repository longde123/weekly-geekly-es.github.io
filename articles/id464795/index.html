<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👨 🎦 👩‍🎓 Merry Quartusel, atau bagaimana prosesor telah hidup seperti itu 😿 🛎️ 👌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat men-debug program reguler, breakpoints dapat diatur hampir di mana-mana dan dalam jumlah yang cukup besar. Sayang Ketika suatu program dieksekusi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Merry Quartusel, atau bagaimana prosesor telah hidup seperti itu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464795/"><img src="https://habrastorage.org/webt/ws/5w/vc/ws5wvcsjeh19phozcqcximmvjbo.jpeg"><br><br>  Saat men-debug program reguler, breakpoints dapat diatur hampir di mana-mana dan dalam jumlah yang cukup besar.  Sayang  Ketika suatu program dieksekusi pada controller, aturan ini tidak berlaku.  Jika ada bagian di mana diagram waktu terbentuk, maka berhenti akan merusak segalanya.  Dan bagian pada frekuensi rendah dan tinggi bukanlah hal yang sama.  Kondisi batas adalah momok bagi pengembang.  Atau, katakanlah, bus USB.  Di NIOS II, saya tidak bekerja dengannya, tetapi pada STM32 itu mengerikan.  Dan saya ingin melihat sesuatu, dan ketika Anda berhenti, Anda menangkap batas waktu.  Secara umum, sangat sering, meskipun ada debugging JTAG tingkat lanjut, perilaku program di area kritis waktu dikaburkan.  Akan bagus untuk melihat, setidaknya setelah eksekusi, rantai apa yang dilalui program, cabang mana yang bekerja, dan mana yang tidak! <br><br>  Lebih penting untuk mengetahui sejarah pengecualian.  Pada NIOS II, saya tidak melakukan ini, tetapi pada Cyclone V SoC di inti ARM - sepenuhnya.  Saat debugging, semuanya berfungsi, dan jika Anda memulai program dari ROM, Anda mendapatkan pengecualian.  Jelas bagaimana mereka memasukinya, dan perkembangan seperti apa yang menyebabkan hal ini tidak terjadi.  Menelusuri juga merusak semua penutup. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd, dan debugging menggunakan tes memori sebagai contoh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan "firmware" paling sederhana untuk FPGA yang dipasang di Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2. Kode program</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan intinya sendiri untuk ditanamkan dalam sistem prosesor berbasis FPGA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan program untuk prosesor pusat Redd pada contoh akses ke FPGA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Eksperimen pertama menggunakan protokol streaming pada contoh CPU dan komunikasi prosesor di Redd FPGA</a> </li></ol><br><h2>  Pendahuluan </h2><br>  Merupakan kebiasaan untuk menulis artikel pendidikan dengan wajah serius, mengedepankan materi dengan tenang dan tidak memihak.  Namun sayang, ini tidak selalu berhasil.  Sekarang, sesuai dengan rencana, harus ada artikel tentang optimalisasi prosesor yang disintesis di kompleks Redd, di mana kita perlu berbicara tentang fitur-fitur bekerja dengan cache.  Berikutnya adalah artikel tentang keterlambatan saat mengakses bus.  Secara umum, semua ini dapat ditampilkan pada osiloskop.  Saya sudah melakukan ini dalam sebuah artikel tentang DMA (" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DMA: Myths and Reality</a> ").  Tapi saya ingin menunjukkan semuanya menggunakan prosesor itu sendiri, saya melakukan pemeriksaan untuk inti ARM di FPGA Cyclone V SoC.  Sangat nyaman (meskipun hasilnya tidak dipublikasikan).  Untuk alasan ini, saya memutuskan untuk berurusan dengan mekanisme penelusuran yang melekat pada blok JTAG.  Sangat disayangkan bahwa sejauh ini saya belum dapat menampilkan dengan sumber daya yang dapat diunduh gratis berapa banyak ketukan yang dimainkan perintah ini, tetapi ada materi yang dengannya program selalu dapat ditanya bagaimana itu bisa sampai pada kehidupan seperti itu.  Yah, dan di samping itu, sementara ingatan akan badai malam masih segar di ingatanku, aku akan membuangnya dengan cara yang agak emosional.  Jadi hari ini akan ada banyak memoar dan sedikit teori yang berguna. <br><br><h2>  Perangkat keras </h2><br>  Jadi, sangat sering ketika men-debug suatu program untuk mikrokontroler, diinginkan untuk mengetahui jalur yang telah dilalui, dan ia harus melewatinya dengan kecepatan penuh.  Untuk kasus NIOS II, mekanisme ini tersedia dan disertakan di sini pada tab ini dari properti inti prosesor: <br><br><img src="https://habrastorage.org/webt/aw/b5/cq/awb5cqb6qtp8es-_vm_xo1dwuok.png"><br><br>  Jenis Jejak mengatur jenis informasi yang akan disimpan.  Anda tidak dapat menyimpan apa pun (ini akan menghemat memori chip), Anda hanya dapat menyimpan riwayat perintah (paling sering ini sudah cukup), baik, atau menyimpan riwayat baik perintah maupun data.  Perlu dicatat bahwa dokumentasi mengatakan bahwa dalam mode terakhir, menyimpan informasi entah bagaimana sulit, sementara overlay dengan riwayat perintah dimungkinkan, dan lebih banyak memori dikonsumsi.  Jadi gunakan mode ini hanya ketika itu benar-benar diperlukan. <br><br>  Parameter Trace Storage menetapkan jenis memori yang akan disimpan jejaknya.  Dokumentasi mengatakan bahwa memori eksternal tidak didukung oleh lingkungan pengembangan standar.  Karena itu, lebih baik memilih bagian dalam saja. <br><br><img src="https://habrastorage.org/webt/vy/bw/ef/vybwef9zoeklef_gcevjoeihy6y.png"><br><br>  Nah, Onchip Trace Frame Size menentukan ukuran buffer.  Semakin besar penyangga, semakin banyak peristiwa dapat ditempatkan di dalamnya, semakin besar sejarah dapat dipertimbangkan.  Tetapi semakin sedikit akan menjadi memori kristal untuk kebutuhan lain. <br><br><img src="https://habrastorage.org/webt/_f/l5/u0/_fl5u0ax87tjg6jqriqa6ksg6ic.png"><br><br>  Tidak perlu mengaktifkan kotak centang membuat port JTAG terpisah.  Biarkan semuanya taksi secara teratur. <br><br><h2>  Dukungan perangkat lunak </h2><br>  Bagus  Jadi kami mengatur inti prosesor, bagaimana selanjutnya?  Ohhhh!  Kemudian kisah detektif dimulai.  Jika angka-angka di atas harus ditafsirkan sebagai panduan untuk bertindak, maka ilustrasi yang menunjukkan kekacauan dan penyumbatan akan mengikuti.  Sejumlah dokumen mengatakan bahwa untuk bekerja dengan pelacakan, Anda harus menggunakan program mahal pihak ketiga dan bahkan peralatan JTAG khusus.  Tetapi dalam beberapa dokumen tergelincir bahwa Anda dapat mengambil sesuatu penuh waktu. <br><br><h3>  Eksperimen Gerhana </h3><br>  Bagus  Mari kita melihat-lihat Eclipse.  Saya mengingatkan Anda bahwa saya menggunakan lingkungan pengembangan Quartus Prime 17.1.  Yah, itu terjadi.  Kami memulai program untuk debugging dan pergi ke item menu yang memungkinkan Anda untuk membuka berbagai jendela: <br><br><img src="https://habrastorage.org/webt/eu/yc/2z/euyc2ztgrga0uxh606lat4tu3kw.png"><br><br>  Di sana kami memilih Debug-&gt; Trace Control window: <br><br><img src="https://habrastorage.org/webt/6w/qu/wz/6wquwzygaqz4ozivccboxsyvuey.png"><br><br>  Dan kita mendapatkan boneka seperti itu: <br><br><img src="https://habrastorage.org/webt/hv/qb/hd/hvqbhdjpwryfpsbhprwh7ehbobq.png"><br><br>  Tetapi sesi debug dimulai.  Selain itu, item menu Mulai Tracing dan Stop Tracing bahkan muncul di dalamnya (sebelum membuka jendela ini, mereka tidak).  Tetapi mereka diblokir.  Dan saya tidak bisa mengaktifkannya. <br><br><img src="https://habrastorage.org/webt/mk/xp/ir/mkxpiratj9qrxtpee0hz91tx3uc.png"><br><br>  Sia-sia saya mengisi Google dengan berbagai permintaan.  Dalam dokumen-dokumen lama, barang-barang ini digambarkan berfungsi dengan baik, tetapi dalam dokumen modern tidak disebutkan.  Tidak ada yang menyebut mereka di forum.  Mungkin seseorang di komentar akan memberi tahu Anda sesuatu? <br><br><h3>  Masalah dengan versi terbaru Eclipse </h3><br>  Bagus  Bagaimana dengan versi terbaru dari lingkungan pengembangan?  Mungkin semuanya bekerja di sana?  Yyyyyy!  Ini adalah topik untuk bab terpisah.  Versi terbaru untuk Siklon keempat dan kelima adalah 18.1.1.  Artinya, Anda harus mengunduh versi 18.1 terlebih dahulu, dan kemudian menginstal pembaruan 18.1.1.  Jika seseorang memutuskan bahwa saya memiliki terlalu banyak waktu luang, bahwa saya mengatur ulang perangkat lunak demi setiap hal kecil, maka semuanya baik-baik saja.  Pemeriksaan utama adalah tentang masalah cache.  Mereka lebih serius, saya ingin memeriksanya di versi baru, saya hanya tidak menulis tentang mereka di sini. <br><br>  Jadi, saya mengunduhnya.  Diinstal  Pertama, versi 18.1 di bawah Win7 diluncurkan, tetapi 18.1.1 tidak menemukan DLL.  Bagus  Saya mengetahui bahwa saya perlu mengunduh Redist dari Visual Studio 2015. Saya menginstalnya.  Itu mulai berjalan.  Membuat proyek dengan sistem prosesor.  Dia bahkan bersiap-siap.  Saya akan ke Eclipse, membuat program dengan BSP berdasarkan itu, semuanya, seperti yang telah kami lakukan berkali-kali ... Dan saya mendapatkan hal semacam ini ... <br><br><img src="https://habrastorage.org/webt/dz/ge/wm/dzgewmffjurbmrm7q9gzziiok5i.png"><br><br>  Proyek ini tidak akan.  Jika Anda keluar dan masuk, itu hanya terbuka sebagian. <br><br><img src="https://habrastorage.org/webt/hw/_p/85/hw_p85rarlvryo3rvmuu_zoqa7k.png"><br><br>  Lihat folder ditutup?  Itu dia.  Mengapa  Ohhhh!  Tiga file memiliki: <br><br><img src="https://habrastorage.org/webt/08/ca/fu/08cafumzaksxsqe9tquadzuckwa.png"><br><br>  Ini adalah atribut perlindungan yang luar biasa: <br><br><img src="https://habrastorage.org/webt/zj/zy/db/zjzydbav2mjwdppsuq6y5mp3uay.png"><br><br>  Jadi mereka tidak dapat dibuka atau diubah ... Jika Anda memberi lebih banyak hak, proyek akan terbuka, tetapi file tidak sepenuhnya dibuat, sehingga tidak akan berfungsi untuk mengumpulkannya.  Mencoba memberi hak sampai Eclipse ditutup, dan kemudian menyimpan proyek.  Hasilnya sama. <br><br>  Mungkinkah Windows 7 yang cepat menua menjadi penyebabnya?  Tidak heran saya kekurangan perpustakaan!  Saya menaruh Quartus baru pada WIN10, saya mendapatkan hasil yang sama persis dengan membuat proyek!  Saya punya teman.  Berdasarkan tempat kerjanya, ia terkadang menemukan produk-produk dari produsen dalam negeri.  Dan dia mengungkapkan serangkaian pemikiran tentang diri mereka sendiri dan tentang kerabat mereka.  Nah, tentang fakta bahwa "siapa yang membangun ini?"  Anda tahu, melihat kegembiraan dalam perangkat lunak Intel, saya mulai berpikir bahwa itu jauh dari negara asal ... Sebenarnya, ini tidak terjadi di bawah Alter ... Apa pun telah terjadi, tetapi saya tidak ingat itu. <br><br>  Saya baru saja keluar.  Saya menyalin proyek ke USB flash drive dengan sistem file FAT32.  Tidak ada atribut keamanan.  Saya membuka proyek dari sana, masuk ke Eclipse dan membuat kode.  Tidak ada atribut keamanan - tidak ada masalah.  Lalu saya menyalinnya kembali ke hard drive dan ... Yah, tentu saja, saya mendapat masalah dalam menghasilkan BSP.  Karena file * .bsp berisi banyak path relatif dan satu absolut.  Ada baiknya saya mengeluarkan flash drive.  Kalau tidak, saya tidak akan memperhatikan bahwa BSP turun di atasnya (karena ini adalah tempat kelahiran proyek), dan proyek dikumpulkan pada hard drive.  Berikut adalah contoh dari jalur seperti itu (sudah diperbaiki): <br><br><img src="https://habrastorage.org/webt/ba/qw/c3/baqwc3vz7g4xtyxou9lzaydkaf0.png"><br><br>  Baiklah, baiklah ... Semuanya dihasilkan, dirakit ... Dan berfungsi persis sama seperti pada versi 17.1 ... Dan untuk pengontrol SoC di lingkungan baru, Anda juga harus membuat ulang rantai JTAG setiap kali di pemrogram.  Dalam versi 17.1, itu sudah cukup untuk melakukan ini sekali dan menyelamatkan ... Eeeeeh.  Baiklah oh baiklah ... <br><br><h3>  Altera Monitor dan masalahnya </h3><br>  Dengan satu atau lain cara, pencarian jaringan untuk kata Mulai Tracing dan Stop Tracing menuntun saya ke dokumen yang menarik.  Mereka menggambarkan berbagai versi program lucu yang disebut <b>Altera Monitor</b> hari ini (namanya berbeda dalam dokumen lama).  Menemukannya relatif mudah.  Anda perlu mengunduh paket <b>Program Universitas</b> untuk versi lingkungan pengembangan Anda.  Perhatikan batasan lisensi.  Tetapi karena kita belajar sekarang, kita tidak takut akan itu.  Tetapi untuk pekerjaan komersial - semuanya buruk di sana.  Detail di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.intel.com/content/www/id/id/programmable/support/training/university/materials-software.html</a> <br><br>  Unduh, masukkan ... Ada dokumen yang dilampirkan ke versi saat ini (karena versi yang tersebar di Internet sangat bervariasi).  Saya bahkan mencoba menjalankan contoh untuk papan tempat memotong roti DE0-Nano-SoC saya.  Dia sedang bekerja.  Tetapi ketika saya mencoba membuat proyek saya, itu tidak berhasil.  File * .sof dimuat ke dalam FPGA, setelah itu, setelah beberapa saat, sebuah pesan ditampilkan: <br><br><img src="https://habrastorage.org/webt/h-/v9/8-/h-v98-afyfovvykexwt8piekhdu.png"><br><br>  Hanya tidak ada informasi di jendela yang ditentukan.  Jika Anda mencoba mengunduh lagi: well, teks akan muncul tepat di jendela itu: <br>  <b>Tidak dapat meminta ID Instansi JTAG.</b> <b><br><br></b>  <b>Harap pastikan FPGA telah dikonfigurasi menggunakan file .sof yang benar.</b> <br><br>  Masalah apa ini?  Saya mencari di Google.  Menemukan beberapa forum dengan masalah yang sama.  Pada satu kesempatan, seorang karyawan Intel menanyakan frekuensi penulis di JTAG dan menyarankan untuk menetapkan yang standar.  Meskipun, pada saat itu saya sudah mengerti bahwa itu bukan masalah frekuensi: contoh perusahaan berhasil, dan bagaimana mengaturnya?  Di satu forum, penulis menulis bahwa entah bagaimana itu telah berlalu.  Dia tidak mengerti caranya.  Dan dia mengatakan bahwa jika Anda melakukan semuanya dengan hati-hati sesuai instruksi, semuanya akan berhasil.  Sisa gambar itu sama.  Pria itu bertanya.  Mereka tidak menjawabnya.  Setelah enam bulan atau satu tahun, seseorang menulis bahwa ia memiliki situasi yang sama, adakah solusi?  Dan diam aaaaaaaa ... <br><br><h3>  Upaya solusi berpengalaman </h3><br>  Bagus  Apa yang bisa menjadi alasannya?  Pada awalnya saya memutuskan untuk melihat-lihat dalam contoh kerja.  ID JTAG misterius apa?  Mungkinkah ini disebabkan oleh keberadaan sistem ID Sistem yang berfungsi? <br><br><img src="https://habrastorage.org/webt/jo/an/be/joanbea7ptsikwoxwrio-xjcfta.png"><br><br>  Ditambahkan pada dirinya sendiri, tidak membantu.  Mungkin JTAG ke jembatan Avalon, yang semua perangkat periferal terhubung, yang harus disalahkan? <br><br><img src="https://habrastorage.org/webt/to/al/dr/toaldrafp5anp22mp7f-b0kfv6o.png"><br><br>  Ditambahkan - tidak membantu.  Saya mencoba beberapa hipotesis lagi, tetapi saya menyadari bahwa Anda dapat menebak selamanya.  Dengan sedih, saya bahkan bertanya pada Yandex, Bing, dan bahkan BaiDu.  Mereka semua tahu kurang dari Google.  Menjadi jelas bahwa kami harus berurusan dengan dekompilasi untuk mengekstrak dari program itu sendiri apa yang diperlukan.  Diperiksa dalam bahasa apa program ditulis.  Ternyata di Jawa.  Bytecode disimpan dalam file Altera_Monitor_Program.jar.  Yah, ini aneh.  Kecuali fakta bahwa saya tidak tahu Jawa ini sama sekali.  Pada Java Script, ada sebuah kasus, mencoba-coba Internet of Things, tetapi saya tidak menemukan Jawa yang sebenarnya.  Tapi di mana milik kita tidak hilang! <br><br><h3>  Analisis bytecode JAVA untuk menemukan masalah </h3><br>  Bagaimana cara membuka kode byte?  Google menghasilkan sebuah artikel tentang Habré, yang mengatakan bahwa untuk ini Anda perlu menggunakan JD-GUI.  Ditemukan di github, unduh.  Saya mengidentifikasi area masalah dengan cukup cepat, karena JD-GUI memiliki navigasi interaktif yang luar biasa.  Dari pesan ke situs, saya keluar dalam 10 menit.  Bagian ini memanggil program pihak ketiga, setelah itu menganalisis responsnya.  Panggilannya terlihat seperti ini: <br><pre><code class="plaintext hljs">systemConsoleCommand[index] = "system-console"; systemConsoleCommand[var24++] = "--script=" + Globals.gHost.getMonitorProgramRootDir("bin/jtag_instance_check.tcl", true); systemConsoleCommand[var24++] = cable; systemConsoleCommand[var24++] = Globals.gProject.system.sofFilename; try { Process sysConsoleProc = NiosIIShell.executeCommand(systemConsoleCommand).start(); BufferedReader gdbIn = new BufferedReader(new InputStreamReader(sysConsoleProc.getInputStream()));</code> </pre> <br>  Nah, dan selanjutnya - analisis jawaban yang belum kita pertimbangkan. <br><br>  Dengan kode ini, saya mencoba membuka konsol NIOS II: <br><br><img src="https://habrastorage.org/webt/s4/u8/tl/s4u8tl-vtf3qn8x0ckrughrfjey.png"><br><br>  Di sana saya pergi ke direktori tempat file sof berada dan mengarahkan baris perintah: <br>  <b>system-console --script = jtag_instance_check.tcl USB-0 test.sof</b> <br><br>  Benar, untuk ini saya harus menyalin file C: \ intelFPGALite \ 17.1 \ University_Program \ Monitor_Program \ bin \ jtag_instance_check.tcl ke tempat yang sama dengan sof, agar tidak menderita dengan path.  Pada akhirnya, saya mendapat respons yang lumayan: <br><br>  <b>TYPE_NAME altera_avalon_jtag_uart.jtag FULL_HPATH jtag_uart_0 (INSTANCE_ID: 0)</b> <b><br><br></b>  <b>TYPE_NAME altera_nios2_gen2.data_master FULL_HPATH nios2_gen2_0 (INSTANCE_ID: 0)</b> <b><br></b> <br><br>  Segalanya tampak indah ... <br><br><h3>  Pelacakan Bytecode JAVA </h3><br>  Jika kasus ini terjadi hari ini, bagian ini tidak akan ada.  Tapi itu terjadi kemarin.  Saya masih mengerti Java dengan sangat buruk.  Apa yang ditulis di sana sambil menguraikan teks adalah hutan yang gelap bagiku.  Benar, selama dua tahun anak saya menghadiri kursus pemrograman olimpiade di 1 franchisee Soviet (sertifikat dan handout adalah 1 Soviet).  Uang gila diberikan untuk kursus-kursus ini.  Dan mereka mengajar mereka di sana hanya di Jawa.  Jadi, dia juga tidak mengerti apa yang ditulis lebih lanjut dalam kode (menjaga intrik, saya akan mempublikasikan kode sedikit lebih rendah, tidak sekarang).  Secara umum, ada perasaan gigih bahwa sudah waktunya untuk dilacak.  Saya tahu bagian yang buruk, saya melihat bahwa garis diterima di sana dan program tidak menyukai mereka dengan sesuatu.  Jadi apa <br><br>  Anak itu menemukan saya artikel yang sangat bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.crowdstrike.com/blog/native-java-bytecode-debugging-without-source-code</a> <br><br>  Ini berbicara tentang plugin yang sangat berguna untuk Eclipse, yang memungkinkan Anda untuk bekerja dengan JAR, mengatur breakpoint di dalamnya.  Tempat pengunduhan, saya temukan di sini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">marketplace.eclipse.org/content/bytecode-visualizer/help</a> <br><br>  Saya mengunduh Eclipse, mengunduh plug-in untuk instalasi offline dengan setengah sedih ... Saya mulai menginstal - tidak ada cukup perpustakaan.  Saya mulai membaca.  Ternyata ada tiga versi plugin.  Di bawah Eslipse 4.5 (Mars), 4.4 (Luna) dan 4.3 (Saya tidak ingat namanya).  Yah, semuanya sederhana.  Kami pergi ke situs web Eclipse, kami melihat tautan untuk mengunduh versi Mars untuk Java ... Dan ... Sudah mati.  Tidak masalah!  Ada sekitar selusin cermin! .. Dan semua tautan ke sana sudah mati.  Kami mencoba Luna untuk Java, ada tautan ke x64 sudah mati, ke x86 ada satu yang hidup ... Seperti yang dikatakan salah seorang teman saya: "Wasir, itu komprehensif."  Secara umum, Google mengalami kesulitan, tetapi menemukan saya perakitan Java 64-bit versi Mars di beberapa server tidak resmi.  Saya mengunduhnya selama setengah jam, tetapi mengunduhnya. <br><br>  Menerapkan plugin, membuat proyek ... Horor!  Di sana, jejaknya tidak pada tingkat kode sumber, tetapi pada tingkat ala assembler.  Singkatnya, kode byte yang didekode dilacak.  Namun faktanya, itu tidak masalah!  Setelah semua, Anda selalu dapat memeriksa dengan sumber yang telah dikompilasi dibuka di jendela lain, ditambah bahwa plugin menunjukkan komentar yang sangat bagus ... Juga ternyata breakpoint dapat diatur tidak di sembarang tempat, tetapi hanya di pintu masuk ke fungsi.  Tapi saya tidak bisa berhenti!  Tidak ada banyak di sana dan Anda harus berjalan dari pintu masuk ke area masalah. <br><br>  Biarkan saya mengingatkan Anda bahwa baris yang diproses terlihat seperti ini: <br>  <b>TYPE_NAME altera_avalon_jtag_uart.jtag FULL_HPATH jtag_uart_0 (INSTANCE_ID: 0)</b> <b><br><br></b>  <b>TYPE_NAME altera_nios2_gen2.data_master FULL_HPATH nios2_gen2_0 (INSTANCE_ID: 0)</b> <br><br>  Dan di sini adalah kode Java: <br><pre> <code class="plaintext hljs">if (str.contains("(INSTANCE_ID:")) { Pattern getInstance = Pattern.compile("\\(INSTANCE_ID:(\\d+)\\)"); Matcher idMatcher = getInstance.matcher(str); if (idMatcher.find()) { String foundstr = idMatcher.group(1); instance = Integer.parseInt(foundstr); }</code> </pre><br>  mengisolasi ID Instance dengan sempurna.  Dan ini kodenya: <br><pre> <code class="plaintext hljs"> Pattern getHPath = Pattern.compile("FULL_HPATH (.+?)\\|(.+?) \\("); Matcher hpathMatcher = getHPath.matcher(str); if (hpathMatcher.find()) { hpath = hpathMatcher.group(2).replace("|", "."); }</code> </pre><br>  variabel hpath tidak mengisi.  Hari ini saya sudah tahu bahwa ungkapan biasa: <br><pre> <code class="plaintext hljs">"FULL_HPATH (.+?)\\|(.+?) \\("</code> </pre> <br>  membutuhkan dua kata yang dipisahkan oleh bilah vertikal.  Nah, maka hanya apa yang setelah garis diambil.  Saya tidak tahu kemarin.  Lebih menarik adalah hal lain.  Anak itu belajar pekerjaan di Jawa selama dua tahun dan tidak belajar ekspresi reguler!  Tidak, jelas bahwa mereka diajarkan bukan bahasa, tetapi pemrograman Olimpiade melalui bahasa, tetapi seperti yang saya pahami, ekspresi reguler di Jawa berada di urutan hal.  Mereka mengambil uang seperti itu, mereka mengocok sertifikat dari perusahaan terkemuka, tetapi mereka tidak mengajarkan hal-hal penting ... Tapi saya ngelantur. <br><br><h3>  Cahaya di ujung terowongan </h3><br>  Apa itu garis vertikal?  Kami mengambil proyek yang berhasil, memberikannya tim yang sama dan mendapatkan jawaban ini: <br><br>  <b>TYPE_NAME altera_avalon_jtag_uart.jtag FULL_HPATH Computer_System: The_System | JTAG_UART (INSTANCE_ID: 0)</b> <b><br><br></b>  <b>TYPE_NAME altera_avalon_jtag_uart.jtag FULL_HPATH Computer_System: The_System | JTAG_UART_2nd_Core (INSTANCE_ID: 1)</b> <b><br><br></b>  <b>TYPE_NAME altera_avalon_jtag_uart.jtag FULL_HPATH Computer_System: The_System | JTAG_UART_for_ARM_0 (INSTANCE_ID: 2)</b> <b><br><br></b>  <b>TYPE_NAME altera_avalon_jtag_uart.jtag FULL_HPATH Computer_System: The_System | JTAG_UART_for_ARM_1 (INSTANCE_ID: 3)</b> <b><br><br></b>  <b>TYPE_NAME altera_nios2_gen2.data_master FULL_HPATH Computer_System: The_System | Nios2 (INSTANCE_ID: 0)</b> <b><br><br></b>  <b>TYPE_NAME altera_nios2_gen2.data_master FULL_HPATH Computer_System: The_System | Nios2_2nd_Core (INSTANCE_ID: 1)</b> <br><br>  Apa itu Computer_System: The_System?  Semuanya sederhana di sini.  Dalam seri artikel ini saya mempromosikan ide lanjutan di mana sistem komputer berada di tingkat atas hierarki. <div class="spoiler">  <b class="spoiler_title">Dan contoh ini memiliki lapisan Verilog ini:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module DE0_Nano_SoC_Computer ( //////////////////////////////////// // FPGA Pins //////////////////////////////////// // Clock pins input CLOCK_50, input CLOCK2_50, input CLOCK3_50, // ADC output ADC_CONVST, output ADC_SCLK, output ADC_SDI, input ADC_SDO, // ARDUINO inout [15:0] ARDUINO_IO, inout ARDUINO_RESET_N, // GPIO inout [35:0] GPIO_0, inout [35:0] GPIO_1, // KEY input [1:0] KEY, // LED output [7:0] LED, // SW input [3:0] SW, //////////////////////////////////// // HPS Pins //////////////////////////////////// // DDR3 SDRAM output [14:0] HPS_DDR3_ADDR, output [2:0] HPS_DDR3_BA, output HPS_DDR3_CAS_N, output HPS_DDR3_CKE, output HPS_DDR3_CK_N, output HPS_DDR3_CK_P, output HPS_DDR3_CS_N, output [3:0] HPS_DDR3_DM, inout [31:0] HPS_DDR3_DQ, inout [3:0] HPS_DDR3_DQS_N, inout [3:0] HPS_DDR3_DQS_P, output HPS_DDR3_ODT, output HPS_DDR3_RAS_N, output HPS_DDR3_RESET_N, input HPS_DDR3_RZQ, output HPS_DDR3_WE_N, // Ethernet output HPS_ENET_GTX_CLK, inout HPS_ENET_INT_N, output HPS_ENET_MDC, inout HPS_ENET_MDIO, input HPS_ENET_RX_CLK, input [3:0] HPS_ENET_RX_DATA, input HPS_ENET_RX_DV, output [3:0] HPS_ENET_TX_DATA, output HPS_ENET_TX_EN, // Accelerometer inout HPS_GSENSOR_INT, // I2C inout HPS_I2C0_SCLK, inout HPS_I2C0_SDAT, inout HPS_I2C1_SCLK, inout HPS_I2C1_SDAT, // Pushbutton inout HPS_KEY, // LED inout HPS_LED, // LTC inout HPS_LTC_GPIO, // SD Card output HPS_SD_CLK, inout HPS_SD_CMD, inout [3:0] HPS_SD_DATA, // SPI output HPS_SPIM_CLK, input HPS_SPIM_MISO, output HPS_SPIM_MOSI, inout HPS_SPIM_SS, // UART input HPS_UART_RX, output HPS_UART_TX, // USB inout HPS_CONV_USB_N, input HPS_USB_CLKOUT, inout [7:0] HPS_USB_DATA, input HPS_USB_DIR, input HPS_USB_NXT, output HPS_USB_STP ); //======================================================= // REG/WIRE declarations //======================================================= wire hps_fpga_reset_n; //======================================================= // Structural coding //======================================================= Computer_System The_System ( //////////////////////////////////// // FPGA Side //////////////////////////////////// // Global signals .system_pll_ref_clk_clk (CLOCK_50), .system_pll_ref_reset_reset (1'b0), // ADC .adc_sclk (ADC_SCLK), .adc_cs_n (ADC_CONVST), .adc_dout (ADC_SDO), .adc_din (ADC_SDI), // Arduino GPIO .arduino_gpio_export (ARDUINO_IO), // Arduino Reset_n .arduino_reset_n_export (ARDUINO_RESET_N), // Slider Switches .slider_switches_export (SW), // Pushbuttons .pushbuttons_export (~KEY), // Expansion JP1 .expansion_jp1_export ({GPIO_0[35:19], GPIO_0[17], GPIO_0[15:3], GPIO_0[1]}), // Expansion JP7 .expansion_jp7_export ({GPIO_1[35:19], GPIO_1[17], GPIO_1[15:3], GPIO_1[1]}), // LEDs .leds_export (LED), //////////////////////////////////// // HPS Side //////////////////////////////////// // DDR3 SDRAM .memory_mem_a (HPS_DDR3_ADDR), .memory_mem_ba (HPS_DDR3_BA), .memory_mem_ck (HPS_DDR3_CK_P), .memory_mem_ck_n (HPS_DDR3_CK_N), .memory_mem_cke (HPS_DDR3_CKE), .memory_mem_cs_n (HPS_DDR3_CS_N), .memory_mem_ras_n (HPS_DDR3_RAS_N), .memory_mem_cas_n (HPS_DDR3_CAS_N), .memory_mem_we_n (HPS_DDR3_WE_N), .memory_mem_reset_n (HPS_DDR3_RESET_N), .memory_mem_dq (HPS_DDR3_DQ), .memory_mem_dqs (HPS_DDR3_DQS_P), .memory_mem_dqs_n (HPS_DDR3_DQS_N), .memory_mem_odt (HPS_DDR3_ODT), .memory_mem_dm (HPS_DDR3_DM), .memory_oct_rzqin (HPS_DDR3_RZQ), // Accelerometer .hps_io_hps_io_gpio_inst_GPIO61 (HPS_GSENSOR_INT), // Ethernet .hps_io_hps_io_gpio_inst_GPIO35 (HPS_ENET_INT_N), .hps_io_hps_io_emac1_inst_TX_CLK (HPS_ENET_GTX_CLK), .hps_io_hps_io_emac1_inst_TXD0 (HPS_ENET_TX_DATA[0]), .hps_io_hps_io_emac1_inst_TXD1 (HPS_ENET_TX_DATA[1]), .hps_io_hps_io_emac1_inst_TXD2 (HPS_ENET_TX_DATA[2]), .hps_io_hps_io_emac1_inst_TXD3 (HPS_ENET_TX_DATA[3]), .hps_io_hps_io_emac1_inst_RXD0 (HPS_ENET_RX_DATA[0]), .hps_io_hps_io_emac1_inst_MDIO (HPS_ENET_MDIO), .hps_io_hps_io_emac1_inst_MDC (HPS_ENET_MDC), .hps_io_hps_io_emac1_inst_RX_CTL (HPS_ENET_RX_DV), .hps_io_hps_io_emac1_inst_TX_CTL (HPS_ENET_TX_EN), .hps_io_hps_io_emac1_inst_RX_CLK (HPS_ENET_RX_CLK), .hps_io_hps_io_emac1_inst_RXD1 (HPS_ENET_RX_DATA[1]), .hps_io_hps_io_emac1_inst_RXD2 (HPS_ENET_RX_DATA[2]), .hps_io_hps_io_emac1_inst_RXD3 (HPS_ENET_RX_DATA[3]), // I2C .hps_io_hps_io_i2c0_inst_SDA (HPS_I2C0_SDAT), .hps_io_hps_io_i2c0_inst_SCL (HPS_I2C0_SCLK), .hps_io_hps_io_i2c1_inst_SDA (HPS_I2C1_SDAT), .hps_io_hps_io_i2c1_inst_SCL (HPS_I2C1_SCLK), // Pushbutton .hps_io_hps_io_gpio_inst_GPIO54 (HPS_KEY), // LED .hps_io_hps_io_gpio_inst_GPIO53 (HPS_LED), // LTC .hps_io_hps_io_gpio_inst_GPIO40 (HPS_LTC_GPIO), // SD Card .hps_io_hps_io_sdio_inst_CMD (HPS_SD_CMD), .hps_io_hps_io_sdio_inst_D0 (HPS_SD_DATA[0]), .hps_io_hps_io_sdio_inst_D1 (HPS_SD_DATA[1]), .hps_io_hps_io_sdio_inst_CLK (HPS_SD_CLK), .hps_io_hps_io_sdio_inst_D2 (HPS_SD_DATA[2]), .hps_io_hps_io_sdio_inst_D3 (HPS_SD_DATA[3]), // SPI .hps_io_hps_io_spim1_inst_CLK (HPS_SPIM_CLK), .hps_io_hps_io_spim1_inst_MOSI (HPS_SPIM_MOSI), .hps_io_hps_io_spim1_inst_MISO (HPS_SPIM_MISO), .hps_io_hps_io_spim1_inst_SS0 (HPS_SPIM_SS), // UART .hps_io_hps_io_uart0_inst_RX (HPS_UART_RX), .hps_io_hps_io_uart0_inst_TX (HPS_UART_TX), // USB .hps_io_hps_io_gpio_inst_GPIO09 (HPS_CONV_USB_N), .hps_io_hps_io_usb1_inst_D0 (HPS_USB_DATA[0]), .hps_io_hps_io_usb1_inst_D1 (HPS_USB_DATA[1]), .hps_io_hps_io_usb1_inst_D2 (HPS_USB_DATA[2]), .hps_io_hps_io_usb1_inst_D3 (HPS_USB_DATA[3]), .hps_io_hps_io_usb1_inst_D4 (HPS_USB_DATA[4]), .hps_io_hps_io_usb1_inst_D5 (HPS_USB_DATA[5]), .hps_io_hps_io_usb1_inst_D6 (HPS_USB_DATA[6]), .hps_io_hps_io_usb1_inst_D7 (HPS_USB_DATA[7]), .hps_io_hps_io_usb1_inst_CLK (HPS_USB_CLKOUT), .hps_io_hps_io_usb1_inst_STP (HPS_USB_STP), .hps_io_hps_io_usb1_inst_DIR (HPS_USB_DIR), .hps_io_hps_io_usb1_inst_NXT (HPS_USB_NXT) ); endmodule</code> </pre><br></div></div><br>  Saya secara khusus membawanya secara penuh untuk menekankan berapa banyak kode yang sama sekali tidak perlu Anda harus tulis dalam kasus ini.  Dan jika kaki ditambahkan atau dihapus, kode ini juga harus diedit.  Sebenarnya, garis <br><br><img src="https://habrastorage.org/webt/gg/_n/b3/gg_nb3rvplsmdkewhuqiqgctyqa.png"><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">... Computer_System The_System ( //////////////////////////////////// // FPGA Side //////////////////////////////////// // Global signals .system_pll_ref_clk_clk (CLOCK_50), ...</code> </pre><br></div></div><br>  dan berikan awalan ini.  Para penulis percaya bahwa hierarki harus seperti itu, hanya ini dan bukan yang lain.  Sistem prosesor tidak dapat dilepas lebih dalam dan tidak dapat dijalankan. <br><br><h3>  Kita seharusnya tidak menunggu belas kasihan dari alam, ambillah - tugas kita! </h3><br>  Apakah kita benar-benar melakukan pekerjaan seperti itu murni untuk menghadapi masalah ini?  Seperti yang seorang teman saya suka mengatakan: "pekerjaan yang tidak perlu lebih buruk daripada mabuk," dan penciptaan lapisan seperti itu adalah kasus khas dari pekerjaan yang tidak perlu.  Oleh karena itu, kami akan berusaha menghindari batasan ini.  Ingat, ketika memanggil program JAVA pihak ketiga, kode tersebut menggantikan beberapa skrip tcl, saya juga menyalinnya ke direktori di sebelah file sof?  Itu adalah keselamatan kita!  Dialah yang memberi tahu konsol sistem tindakan apa yang harus diambil dan dialah yang memformat respons.  pemformatan berjalan seperti ini: <br><img src="https://habrastorage.org/webt/6a/si/cq/6asicqpxflldfmtmq1qveh_6c4q.png"><br><div class="spoiler">  <b class="spoiler_title">Teks yang sama:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># PRINT OUT INSTANCE ID INFO FOR EVERYTHING: set i 0 foreach path [lsort -command compare_node_number [get_service_paths bytestream]] { # If this path corresponds to a JTAG UART, incr i if {[string match *$cable_name* $path ] &amp;&amp; [string match *jtag_uart* [marker_get_type $path] ]} { puts "[marker_get_info $path] (INSTANCE_ID:$i)" incr i } } set i 0 foreach path [lsort -command compare_node_number [get_service_paths processor]] { # If this path corresponds to a NiosII, incr i if {[string match *$cable_name* $path ] &amp;&amp; [string match *nios2* [marker_get_type $path] ]} { puts "[marker_get_info $path] (INSTANCE_ID:$i)" incr i } }</code> </pre><br></div></div><br>  Blok pertama memformat informasi tentang JTAG_UART blok, yang kedua - tentang inti prosesor.  Sekarang, jika di sini kita tambahkan garis vertikal ke aliran output!  Rekan saya memperbaiki bagian ini sebagai berikut: <br><pre> <code class="plaintext hljs"># PRINT OUT INSTANCE ID INFO FOR EVERYTHING: set i 0 foreach path [lsort -command compare_node_number [get_service_paths bytestream]] { # If this path corresponds to a JTAG UART, incr i if {[string match *$cable_name* $path ] &amp;&amp; [string match *jtag_uart* [marker_get_type $path] ]} { set info [marker_get_info $path] if {[string first "|" $info] == -1} { set info [string map {"FULL_HPATH " "FULL_HPATH a:b|"} $info] } puts "$info (INSTANCE_ID:$i)" incr i } } set i 0 foreach path [lsort -command compare_node_number [get_service_paths processor]] { # If this path corresponds to a NiosII, incr i if {[string match *$cable_name* $path ] &amp;&amp; [string match *nios2* [marker_get_type $path] ]} { set info [marker_get_info $path] if {[string first "|" $info] == -1} { set info [string map {"FULL_HPATH " "FULL_HPATH a:b|"} $info] } puts "$info (INSTANCE_ID:$i)" incr i } }</code> </pre><br>  Sekarang, jika tidak ada tanda hubung, mereka akan ditambahkan.  Dan akhirnya, program ini akan bekerja tidak hanya dengan yang mengerikan, tetapi juga dengan sistem prosesor yang ditulis secara optimal! <br><br><h2>  Menyiapkan proyek di Monitor Altera </h2><br>  Uffff.  Itu saja.  Akhir untuk mencungkil, off-road dan kecerobohan (meskipun, tentang off-road - ini tidak akurat).  Sekarang lagi, gambar-gambar dalam artikel mencerminkan instruksi untuk bekerja!  Kami memiliki proyek untuk FPGA, serta program yang membangun dan berjalan di Eclipse.  Sekarang luncurkan Altera Monitor dan buat proyek. <br><br><img src="https://habrastorage.org/webt/zy/kc/b0/zykcb02zebkc-u6wknzbnnqozew.png"><br><br>  Kami membuat katalog dengan proyek (saya meletakkannya secara terpisah dari proyek untuk FPGA) dan memberikan nama proyek.  Juga pilih arsitektur prosesor <br><br><img src="https://habrastorage.org/webt/md/8c/sg/md8csgrftsf_j0mt8vyjrcaaaua.png"><br><br>  Sistem yang saya pilih adalah Sistem Kustom.  Anda harus menentukan file * .sof dan * .sopcinfo saya.  Saya memilih mereka di direktori kerja.  Sistem kami tidak membutuhkan preloader. <br><br><img src="https://habrastorage.org/webt/ej/zb/ad/ejzbad_u22w-hczkkgluen36nfa.png"><br><br>  Pilih jenis program Program dengan Dukungan Driver Perangkat, maka pustaka BSP akan dibangun: <br><br><img src="https://habrastorage.org/webt/td/dw/ew/tddwewush_a8-srgsrrnpbcmbo4.png"><br><br>  Hanya ada satu file yang berfungsi sejauh ini (dibuat di Eclipse).  Di sini saya tambahkan: <br><br><img src="https://habrastorage.org/webt/f9/pt/mk/f9ptmk-t78ilnla5-7hm4mlnpno.png"><br><br>  Di jendela terakhir, saya tidak mengubah apa pun: <br><br><img src="https://habrastorage.org/webt/sm/lf/e_/smlfe__fqs5gt3ieiuhcryd0fso.png"><br><br>  Kami setuju untuk mengunduh file sof: <br><br><img src="https://habrastorage.org/webt/yl/x6/qx/ylx6qxkmhkql0hbxgdqgakxek4c.png"><br><br>  Jika kami baru saja menginstal perangkat lunak, kami beralih ke mode sumber.  Maka itu sudah akan dihidupkan (saya akan menunjukkan kepada Anda seperti apa menu itu ketika semuanya sudah dihidupkan, juga akan ada item untuk dimasukkan). <br><br><img src="https://habrastorage.org/webt/nj/jo/4p/njjo4pxzvs87ygedajsdkh8gx_u.png"><br><br>  Saya memiliki program C paling sederhana: <br><pre> <code class="plaintext hljs">#include "sys/alt_stdio.h" int main() { alt_putstr("Hello from Nios II!\n"); volatile int i=0; i += 1; i += 2; i += 3; i += 4; i += 5; i += 6; i += 7; i += 8; i += 9; i += 10; i += 11; i += 12; /* Event loop never exits. */ while (1); return 0; }</code> </pre><br>  Saya mencoba untuk mengumpulkannya: <br><br><img src="https://habrastorage.org/webt/d_/2q/pq/d_2qpq5wlpcikhp1sqfzfn4qfxq.png"><br><br>  Saya mendapatkan kesalahan: <br>  <b>c: /intelfpga/17.1/nios2eds/bin/gnu/h-x86_64-mingw32/bin /../ lib / gcc / nios2-elf / 5.3.0 /../../../../../ .. /H-x86_64-mingw32/nios2-elf/bin/ld.exe: region `Code 'dilampaui oleh 15888 bytes</b> <br><br>  Ini karena saya tidak menambahkan SDRAM ke sistem, saya membatasinya pada memori FPGA internal.  Tapi mengapa semuanya cocok di Eclipse, tetapi tidak di sini?  Karena saya memilih BSP di sana dengan akhiran Small, tetapi di sini saya secara otomatis membuat paket reguler.  Oleh karena itu, buka file: C: \ Work \ Play2 \ BSP \ settings.bsp <br><br>  Dan kami mulai penyetelan manual. <br><br><img src="https://habrastorage.org/webt/bu/tv/vn/butvvng3etvwox28euel6mvggyq.png"><br><br><img src="https://habrastorage.org/webt/sq/ei/kk/sqeikkntwrn4ju8qtve_yybvgxw.png"><br><br>  Membangun kembali BSP: <br><br><img src="https://habrastorage.org/webt/a0/sf/0_/a0sf0_tbaegc9-cusl2bfa-xova.png"><br><br>  Dan lagi kami mengumpulkan proyek.  Kali ini berhasil.  Sekarang muat: <br><br><img src="https://habrastorage.org/webt/sm/kg/rl/smkgrlr9croftl0y-fagdqqhr1a.png"><br><br><h2>  Akhirnya, jejak yang sebenarnya </h2><br>  Anda belum lupa mengapa saya melakukan semua ini?  Saya melakukan ini untuk melacak.  Itu harus diaktifkan.  Untuk melakukannya, buka tab Lacak dan pilih Aktifkan Lacak di menu konteks: <br><br><img src="https://habrastorage.org/webt/nv/bo/pp/nvboppbqx8ihyhh6qlxmbxjgfq0.png"><br><br>  Saya akan meletakkan breakpoint di akhir fungsi main () pada tab Disassembly (alangkah bagusnya assembler RISC setelah assembler stack yang mengerikan di mana kode Java dikonversi!) <br><br>  Inilah awal dari fungsi utama: <br><br><img src="https://habrastorage.org/webt/ue/m2/-q/uem2-qdgcpj7stuobbouowscfkw.png"><br><br>  Gulirkan sedikit ke bawah dan letakkan breakpoint di sini: <br><br><img src="https://habrastorage.org/webt/ev/zf/ot/evzfotqiwhr4w0j2f-xrilmfooe.png"><br><br>  Kami mulai, menunggu berhenti dan pergi ke tab Jejak. <br><br>  Secara umum, semuanya tidak terlalu baik.  Pada awalnya, jelas ada semacam harapan (kami memiliki kesimpulan di JTAG di sana, jadi itu adalah hal yang sah): <br><br><img src="https://habrastorage.org/webt/yd/fo/jf/ydfojfs41-yysqn8kqndisvaguw.png"><br><br>  Pada akhirnya - beberapa kode lain ... Tapi saya tidak melihat kode fungsi utama!  Inilah akhirnya: <br><br><img src="https://habrastorage.org/webt/ww/eb/ky/wwebkyjc8nj3nrdnxrpfqoosbc0.png"><br><br>  Saya bahkan tidak tahu harus berkata apa.  Tapi bagaimanapun, jika Anda tidak menempatkan satu, tetapi dua breakpoints (di awal dan akhir fungsi utama), maka setelah menjalankan dari yang pertama ke yang kedua, gambar akan layak: <br><br><img src="https://habrastorage.org/webt/kq/pr/en/kqprenc25bb2vbucdmxq_49vzqy.png"><br><br><h2>  Kesimpulan singkat </h2><br>  Jadi, kami mengetahui bahwa sangat mungkin untuk mengetahui cara kerja situs tertentu.  Jadi, topik artikel ("... bagaimana prosesor telah sampai pada kehidupan seperti itu") diungkapkan.  Lebih menarik bagaimana semua orang yang masalah-masalahnya harus diselesaikan untuk mendapatkan hasil telah datang ke kehidupan seperti itu?  Dan sangat disayangkan bahwa sejauh ini saya belum dapat menentukan berapa banyak bar yang diselesaikan oleh tim tertentu.  Dari potongan dokumentasi jelas bahwa ini tampaknya secara teknis memungkinkan, tetapi perangkat lunak apa yang memungkinkan ini dilakukan tidak jelas.  Ada pendapat bahwa dokumen <b>Menganalisis dan Desain Debugging dengan System Console</b> , yang harus saya baca ketika menganalisis skrip tcl, akan membantu kami.  Ini memiliki tablet yang menarik <b>Tabel 10-15: Trace System Commands</b> , tetapi secara pribadi, saya hanya tidak punya waktu untuk studi rinci tentang masalah ini.  Tapi mungkin itu akan sangat penting bagi seseorang sehingga dia mengimplementasikan semuanya.  Perintah-perintah ini termasuk dalam skrip tcl. <br><br>  Nah, dalam artikel berikut, pengukuran harus dilakukan dengan cara lama, dengan osiloskop. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464795/">https://habr.com/ru/post/id464795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464779/index.html">Tentang lebah hedonis, cara orang membuatnya bekerja dan drone</a></li>
<li><a href="../id464781/index.html">Smart TV: CRT ke HDR</a></li>
<li><a href="../id464785/index.html">Manfaat Langsung Menuju Yang Tidak Kompetitif</a></li>
<li><a href="../id464787/index.html">Saya yakin pengembang senior ponsel hanya akan datang berdasarkan rekomendasi</a></li>
<li><a href="../id464791/index.html">Kubernetes untuk mobil: cara membuka akses pengembang ke komputer yang terpasang dan membuatnya aman</a></li>
<li><a href="../id464803/index.html">"Sembunyikan www": mengapa pengembang browser utama kembali menolak untuk menampilkan subdomain</a></li>
<li><a href="../id464805/index.html">Menulis ular di iPad (pythonista)</a></li>
<li><a href="../id464809/index.html">Bagaimana kami menguji teknologi pengenalan wajah dan apa yang terjadi</a></li>
<li><a href="../id464811/index.html">Apple Music untuk pengembang</a></li>
<li><a href="../id464813/index.html">Mengganti Punto Switcher, tata letak Birman dengan skrip autohotkey</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>