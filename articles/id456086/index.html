<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📑 👎🏻 🚹 iOS Storyboards: analisis pro dan kontra, praktik terbaik 🦑 👩🏻‍🍳 ♐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apple menciptakan Storyboards sehingga pengembang dapat memvisualisasikan layar aplikasi iOS dan hubungan di antara mereka. Tidak semua orang menyukai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Storyboards: analisis pro dan kontra, praktik terbaik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/456086/"><img src="https://habrastorage.org/webt/xx/gq/7w/xxgq7wvcgxjuew_bku55csqqvlu.png"><br><br>  Apple menciptakan Storyboards sehingga pengembang dapat memvisualisasikan layar aplikasi iOS dan hubungan di antara mereka.  Tidak semua orang menyukai alat ini, dan untuk alasan yang bagus.  Saya telah bertemu banyak artikel yang mengkritik Storyboards, tetapi saya belum menemukan analisis terperinci dan tidak memihak dari semua pro dan kontra, dengan mempertimbangkan praktik terbaik.  Pada akhirnya, saya memutuskan untuk menulis artikel seperti itu sendiri. <br><a name="habracut"></a><br>  Saya akan mencoba menganalisis secara rinci kerugian dan keuntungan menggunakan Storyboard.  Setelah menimbang mereka, Anda dapat membuat keputusan yang berarti apakah mereka dibutuhkan dalam proyek atau tidak.  Keputusan ini tidak harus radikal.  Jika dalam beberapa situasi Storyboard menimbulkan masalah, di lain penggunaannya dibenarkan: itu membantu untuk menyelesaikan tugas secara efektif dan menulis kode sederhana, mudah dipelihara. <br><br>  Mari kita mulai dengan kekurangan dan menganalisis apakah semuanya masih relevan. <br><br><h2>  Kekurangan </h2><br><h3>  1. Storyboard mengalami kesulitan mengelola konflik saat menggabungkan perubahan </h3><br>  Storyboard adalah file XML.  Itu kurang mudah dibaca daripada kode, sehingga menyelesaikan konflik di dalamnya lebih sulit.  Tetapi kompleksitas ini juga tergantung pada bagaimana kita bekerja dengan Storyboard.  Anda dapat sangat menyederhanakan tugas Anda jika Anda mengikuti aturan di bawah ini: <br><br><ul><li> Jangan menaruh seluruh UI dalam satu Storyboard tunggal, membaginya menjadi beberapa yang lebih kecil.  Ini akan memungkinkan mendistribusikan karya pada Storyboard di antara para pengembang tanpa risiko konflik, dan jika terjadi keniscayaan mereka akan menyederhanakan tugas untuk menyelesaikannya. <br></li><li>  Jika Anda perlu menggunakan Tampilan yang sama di beberapa tempat, pilih di subclass terpisah dengan file Xib sendiri. <br></li><li>  Buat komitmen lebih sering, karena jauh lebih mudah untuk bekerja dengan perubahan yang datang dalam potongan kecil. <br></li></ul><br>  Menggunakan beberapa Storyboard alih-alih satu membuatnya tidak mungkin bagi kita untuk melihat seluruh peta aplikasi dalam satu file.  Tetapi seringkali ini tidak perlu - hanya bagian spesifik yang sedang kita kerjakan saat ini sudah cukup. <br><br><h3>  2. Storyboard mencegah penggunaan kembali kode </h3><br>  Jika kita berbicara tentang menggunakan Storyboards saja tanpa Xibs dalam proyek, maka masalah pasti akan muncul.  Namun, Xibs, menurut saya, adalah elemen yang diperlukan ketika bekerja dengan Storyboards.  Berkat mereka, Anda dapat dengan mudah membuat Tampilan yang dapat digunakan kembali, yang juga nyaman digunakan dalam kode. <br><br>  Pertama, buat kelas <code>XibView</code> dasar, yang bertanggung jawab untuk merender <code>UIView</code> dibuat di Xib di Storyboard: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBDesignable</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentView: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  <code>XibView</code> akan memuat <code>UIView</code> dari Xib ke <code>contentView</code> dan menambahkannya sebagai subview.  Kami melakukan ini dalam metode <code>setup()</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = loadViewFromNib() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.frame = bounds view.autoresizingMask = [.flexibleWidth, .flexibleHeight] addSubview(view) contentView = view }</code> </pre> <br>  Metode <code>loadViewFromNib()</code> terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadViewFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nibName = <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: type(of: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nib = <span class="hljs-type"><span class="hljs-type">UINib</span></span>(nibName: nibName, bundle: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">XibView</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nib.instantiate(withOwner: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, options: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIView</span></span> }</code> </pre> <br>  Metode <code>setup()</code> harus dipanggil dalam inisialisasi: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) setup() } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(coder: aDecoder) setup() }</code> </pre> <br>  Kelas <code>XibView</code> siap.  Tampilan yang Digunakan Kembali, yang penampilannya dirender dalam file Xib, akan diwarisi dari <code>XibView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><img src="https://habrastorage.org/webt/j8/ak/ny/j8aknyaa51sdpr6y8kbh7yjfwvs.png"><br>  Jika sekarang Anda menambahkan <code>UIView</code> baru ke Storyboard dan mengatur kelasnya ke <code>RedView</code> , maka semuanya akan ditampilkan dengan sukses: <br><img src="https://habrastorage.org/webt/0l/a-/wa/0la-waqvswrxya3gc8clxvro2iw.png"><br>  Membuat instance <code>RedView</code> dalam kode terjadi dengan cara biasa: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> redView = <span class="hljs-type"><span class="hljs-type">RedView</span></span>()</code> </pre> <br>  Detail berguna lainnya yang tidak semua orang bisa tahu adalah kemampuan untuk menambahkan warna ke direktori <b>.xcassets</b> .  Ini memungkinkan Anda untuk mengubahnya secara global di semua Storyboard dan Xibs tempat mereka digunakan. <br><br>  Untuk menambahkan warna, klik "+" di kiri bawah dan pilih "Set Warna Baru": <br><img src="https://habrastorage.org/webt/zm/3u/qi/zm3uqiunozwu020zpfckzd_slbo.png"><br>  Tentukan nama dan warna yang diinginkan: <br><img src="https://habrastorage.org/webt/4j/ve/lt/4jveltbjt7fiqalngh6zzg1otr4.png"><br>  Warna yang dibuat akan muncul di bagian "Named Colors": <br><img src="https://habrastorage.org/webt/km/cl/ak/kmclakpy0pduyyudog1_daxmx8o.png"><br>  Selain itu, dapat diperoleh dalam kode: <br><br><pre> <code class="swift hljs">innerView.backgroundColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(named: <span class="hljs-string"><span class="hljs-string">"BackgroundColor"</span></span>)</code> </pre><br><h3>  3. Anda tidak dapat menggunakan inisialisasi khusus untuk <code>UIViewControllers</code> dibuat di Storyboard </h3><br>  Dalam hal Storyboard, kami tidak dapat melewatkan dependensi pada inisialisasi dari <code>UIViewControllers</code> .  Biasanya terlihat seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"detail"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> detailVC = segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-type"><span class="hljs-type">Object</span></span>() detailVC.object = object }</code> </pre> <br>  Kode ini dapat lebih baik dilakukan menggunakan semacam konstanta untuk mewakili pengidentifikasi atau alat seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SwiftGen</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">R.swift</a> , atau bahkan mungkin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perform</a> .  Tetapi dengan cara ini kita hanya menyingkirkan string literal dan menambahkan gula sintaksis, dan tidak memecahkan masalah yang muncul: <br><br><ul><li>  Bagaimana saya tahu bagaimana <code>DetailViewController</code> dikonfigurasi dalam contoh di atas?  Jika Anda baru mengenal proyek dan tidak memiliki pengetahuan ini, Anda harus membuka file dengan deskripsi controller ini dan mempelajarinya. <br></li><li>  Properti <code>DetailViewController</code> diatur setelah inisialisasi, yang berarti mereka harus opsional.  Hal ini diperlukan untuk menangani kasus ketika properti apa pun adalah <code>nil</code> , jika tidak, aplikasi dapat macet pada saat yang paling tidak tepat.  Anda dapat menandai properti sebagai diperluas secara implisit opsional ( <code>var object: Object!</code> ), Tetapi esensi tidak akan berubah. <br></li><li>  Properti harus ditandai sebagai <code>var</code> , jangan <code>let</code> .  Jadi suatu situasi mungkin terjadi ketika seseorang dari luar ingin mengubahnya.  <code>DetailViewController</code> harus menangani situasi seperti itu. <br></li></ul><br>  Satu solusi dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> . <br><br><h3>  4. Ketika Storyboard tumbuh, navigasi di dalamnya menjadi lebih sulit </h3><br>  Seperti yang kami sebutkan sebelumnya, Anda tidak perlu meletakkan semuanya dalam satu Storyboard, lebih baik memecahnya menjadi beberapa yang lebih kecil.  Dengan munculnya <b>Referensi Storyboard,</b> itu menjadi sangat sederhana. <br>  Tambahkan Referensi Storyboard dari perpustakaan objek ke Storyboard: <br><img src="https://habrastorage.org/webt/m7/v4/wc/m7v4wcm7xu_chbm7n6j_mmy1ssq.png"><br>  Kami menetapkan nilai-nilai bidang yang diperlukan dalam <b>Inspektur Atribut</b> - ini adalah nama file Storyboard dan, jika perlu, <b>ID Dirujuk</b> , yang sesuai dengan <b>ID Storyboard</b> layar yang diinginkan.  Secara default, <b>Pengendali Tampilan Awal</b> akan memuat: <br><img src="https://habrastorage.org/webt/0j/2a/ee/0j2aeevobxwbcwd4impkwryj1ye.png"><br>  Jika Anda menentukan nama yang tidak valid di bidang Storyboard atau merujuk ke ID Storyboard yang tidak ada, Xcode akan memperingatkan Anda tentang hal ini pada tahap kompilasi. <br><br><h3>  5. Xcode melambat saat memuat storyboard </h3><br>  Jika Storyboard berisi sejumlah besar layar dengan banyak kendala, maka memuatnya akan sangat memakan waktu.  Tapi sekali lagi, lebih baik untuk membagi Storyboard besar menjadi yang lebih kecil.  Secara terpisah, mereka memuat lebih cepat dan menjadi lebih nyaman untuk bekerja dengan mereka. <br><br><h3>  6. Storyboard rapuh, bug dapat menyebabkan aplikasi mogok saat runtime </h3><br>  Poin kelemahan utama: <br><br><ul><li>  Kesalahan dalam <code>UICollectionViewCell</code> <code>UITableViewCell</code> dan <code>UICollectionViewCell</code> . <br></li><li>  Kesalahan dalam pengidentifikasi segues. <br></li><li>  Menggunakan subkelas <code>UIView</code> yang sudah tidak ada lagi. <br></li><li>  Sinkronisasi <code>IBActions</code> dan <code>IBOutlets</code> dengan kode. <br></li></ul><br>  Semua ini dan beberapa masalah lain dapat menyebabkan crash aplikasi pada saat runtime, yang berarti kemungkinan kesalahan tersebut akan jatuh ke dalam rilis rilis.  Misalnya, ketika kita menetapkan pengidentifikasi sel atau segues di Storyboard, mereka harus disalin ke kode di mana pun mereka digunakan.  Dengan mengubah pengidentifikasi di satu tempat, itu harus diubah di semua tempat.  Ada kemungkinan Anda hanya akan melupakannya atau membuat kesalahan ketik, tetapi hanya belajar tentang kesalahan saat aplikasi sedang berjalan. <br><br>  Anda dapat mengurangi kemungkinan kesalahan dengan menyingkirkan string literal dalam kode Anda.  Untuk ini, <code>UICollectionViewCell</code> <code>UITableViewCell</code> dan <code>UICollectionViewCell</code> dapat diberi nama kelas sel itu sendiri: misalnya, pengidentifikasi <code>ItemTableViewCell</code> akan menjadi string “ItemTableViewCell”.  Dalam kode, kita mendapatkan sel seperti ini: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span></code> </pre> <br>  Anda dapat menambahkan fungsi generik yang sesuai ke <code>UITableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dequeueReusableCell</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">T</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">T</span></span> } }</code> </pre> <br>  Dan kemudian menjadi lebih mudah untuk mendapatkan sel: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span> = tableView.dequeueReusableCell()</code> </pre> <br>  Jika Anda tiba-tiba lupa menentukan nilai pengenal sel di Storyboard, Xcode akan menampilkan peringatan, jadi jangan abaikan. <br><br>  Sedangkan untuk pengidentifikasi segues, Anda dapat menggunakan enumerasi untuk mereka.  Mari kita buat protokol khusus: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>: <span class="hljs-type"><span class="hljs-type">RawRepresentable</span></span> }</code> </pre> <br>  <code>UIViewController</code> yang mendukung protokol ini perlu mendefinisikan tipe bersarang dengan nama yang sama.  Ini mencantumkan semua pengidentifikasi <code>UIViewController</code> dapat diproses oleh <code>UIViewController</code> ini: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } }</code> </pre> <br>  Selain itu, dalam ekstensi protokol <code>SegueHandler</code> , <code>SegueHandler</code> mendefinisikan dua fungsi: satu menerima <code>UIStoryboardSegue</code> dan mengembalikan nilai <code>SegueIdentifier</code> sesuai, dan yang lainnya hanya memanggil <code>performSegue</code> , mengambil input <code>SegueIdentifier</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawValue</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performSegue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withIdentifier segueIdentifier: SegueIdentifier, sender: AnyObject?)</span></span></span></span> { performSegue(withIdentifier: segueIdentifier.rawValue, sender: sender) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">segueIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifier = segue.identifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifierCase = <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>(rawValue: identifier) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid segue identifier \(String(describing: segue.identifier))."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> identifierCase } }</code> </pre> <br>  Dan sekarang di <code>UIViewController</code> yang mendukung protokol baru, Anda dapat bekerja dengan <code>prepare(for:sender:)</code> sebagai berikut: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segueIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: segue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signIn: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signIn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signUp: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signUp"</span></span>) } } }</code> </pre> <br>  Dan jalankan segue seperti ini: <br><br><pre> <code class="swift hljs">performSegue(withIdentifier: .signIn, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Jika Anda menambahkan pengenal baru ke <code>SegueIdentifier</code> , maka Xcode pasti akan memaksanya untuk memproses di <code>switch/case</code> . <br><br>  Pilihan lain untuk menghilangkan string literal seperti pengidentifikasi segues dan lainnya adalah dengan menggunakan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembuat</a> kode seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">R.swift</a> . <br><br><h3>  7. Storyboard kurang fleksibel daripada kode. </h3><br>  Ya ini benar.  Jika tugasnya adalah membuat layar kompleks dengan animasi dan efek yang tidak bisa ditangani Storyboard, maka Anda perlu menggunakan kode! <br><br><h3>  8. Storyboard tidak memungkinkan untuk mengubah jenis <code>UIViewControllers</code> khusus </h3><br>  Misalnya, ketika Anda perlu mengubah jenis <code>UITableViewController</code> ke <code>UICollectionViewController</code> , Anda harus menghapus objek, menambahkan yang baru dengan jenis lain dan mengkonfigurasi ulang.  Meskipun ini bukan kasus yang sering, perlu dicatat bahwa perubahan tersebut dibuat lebih cepat dalam kode. <br><br><h3>  9. Storyboard menambahkan dua dependensi tambahan ke proyek.  Mereka mungkin mengandung kesalahan yang tidak bisa diperbaiki pengembang. </h3><br>  Ini adalah Interface Builder dan pengurai Storyboards.  Kasus-kasus seperti itu jarang terjadi dan seringkali dapat dihindari dengan solusi lain. <br><br><h3>  10. Ulasan kode canggih </h3><br>  Perlu diingat bahwa tinjauan kode bukanlah pencarian bug.  Ya, mereka ditemukan dalam proses melihat kode, tetapi tujuan utamanya adalah untuk mengidentifikasi kelemahan yang dapat menciptakan masalah dalam jangka panjang.  Untuk Storyboard, ini terutama pekerjaan <b>Tata Letak Otomatis</b> .  Seharusnya tidak ada <b>ambigu</b> dan <b>salah tempat</b> .  Untuk menemukannya, cukup gunakan pencarian di Storyboard XML untuk baris “ambiguous =“ YES ”” dan “misplaced =“ YES ”” atau cukup buka Storyboard di Interface Builder dan cari titik-titik merah dan kuning: <br><img src="https://habrastorage.org/webt/u4/bw/l5/u4bwl5psqejad5ziovb2bjxy1eq.png"><br>  Namun, ini mungkin tidak cukup.  Konflik antar kendala juga dapat dideteksi saat aplikasi sedang berjalan.  Jika situasi serupa terjadi, informasi tentang ini ditampilkan di konsol.  Kasus-kasus seperti itu tidak biasa, oleh karena itu, pencarian mereka juga harus ditanggapi dengan serius. <br><br>  Segala sesuatu yang lain - mencocokkan posisi dan ukuran elemen dengan desain, pengikatan <code>IBOutlets</code> dan <code>IBActions</code> - bukan untuk peninjauan kode. <br><br>  Selain itu, penting untuk membuat komitmen lebih sering, maka akan lebih mudah bagi pengulas untuk melihat perubahan dalam potongan kecil.  Dia akan lebih bisa menggali detail tanpa melewatkan apa pun.  Ini, pada gilirannya, akan berdampak positif pada kualitas ulasan kode. <br><br><h3>  Ringkasan </h3><br>  Dalam daftar kekurangan Storyboards, saya meninggalkan 4 item (dalam urutan nilainya): <br><br><ol><li>  Storyboard mengalami kesulitan mengelola konflik saat menggabungkan perubahan. <br></li><li>  Storyboard kurang fleksibel daripada kode. <br></li><li>  Storyboard rapuh, kesalahan dapat menyebabkan crash saat runtime. <br></li><li>  Anda tidak dapat menggunakan inisialisasi khusus untuk <code>UIViewControllers</code> dibuat di Storyboard. <br></li></ol><br><h2>  Manfaatnya </h2><br><h3>  1. Visualisasi antarmuka dan batasan pengguna </h3><br>  Bahkan jika Anda seorang pemula dan baru memulai proyek yang tidak dikenal, Anda dapat dengan mudah menemukan titik masuk ke aplikasi dan cara mendapatkan ke layar yang diinginkan dari itu.  Anda tahu seperti apa masing-masing tombol, label, atau bidang teks akan terlihat, posisi apa yang akan diambil, bagaimana kendala memengaruhi mereka, bagaimana mereka berinteraksi dengan elemen lain.  Dengan beberapa klik, Anda dapat dengan mudah membuat <code>UIView</code> baru, menyesuaikan penampilan dan perilakunya.  Tata Letak Otomatis memungkinkan kita untuk bekerja dengan <code>UIView</code> secara alami, seolah-olah kita berkata: "Tombol ini harus di sebelah kiri label itu dan memiliki ketinggian yang sama dengannya."  Pengalaman antarmuka pengguna ini intuitif dan efektif.  Anda dapat mencoba memberikan contoh di mana kode yang ditulis dengan baik menghemat lebih banyak waktu ketika membuat beberapa elemen UI, tetapi secara global ini tidak banyak berubah.  Storyboard melakukan tugasnya dengan baik. <br><br>  Secara terpisah, perhatikan Tata Letak Otomatis.  Ini adalah alat yang sangat kuat dan berguna, tanpanya akan sulit untuk membuat aplikasi yang mendukung semua ukuran layar yang berbeda.  Interface Builder memungkinkan Anda untuk melihat hasil bekerja dengan Tata Letak Otomatis tanpa meluncurkan aplikasi, dan jika beberapa kendala tidak sesuai dengan skema umum, Xcode akan segera memperingatkan Anda tentang hal itu.  Tentu saja, ada beberapa kasus ketika Interface Builder tidak dapat memberikan perilaku yang diperlukan dari beberapa antarmuka yang sangat dinamis dan kompleks, maka Anda harus bergantung pada kode.  Tetapi bahkan dalam situasi seperti itu, Anda dapat melakukan sebagian besar di Interface Builder dan menambahkannya hanya dengan beberapa baris kode. <br><br>  Mari kita lihat beberapa contoh yang menunjukkan fitur berguna dari Interface Builder. <br><br><h4>  Tabel dinamis berdasarkan <code>UIStackView</code> </h4><br>  Buat <code>UIViewController</code> baru, tambahkan layar penuh <code>UIScrollView</code> : <br><img src="https://habrastorage.org/webt/oh/-g/c8/oh-gc88tyx_mhu5zm6iehrnpvrk.png"><br>  Di <code>UIScrollView</code> tambahkan <code>UIStackView</code> vertikal, pasang ke tepi dan atur tinggi dan lebar sama dengan <code>UIScrollView</code> .  Pada ketinggian ini, tetapkan <b>prioritas = Rendah (250)</b> : <br><img src="https://habrastorage.org/webt/hp/dv/v-/hpdvv-gg-hkeh_xy5k2vbbcznr0.png"><br>  Selanjutnya, buat semua sel yang diperlukan dan tambahkan ke <code>UIStackView</code> .  Mungkin itu akan menjadi <code>UIView</code> biasa dalam satu salinan, atau mungkin <code>UIView</code> , yang untuknya kami membuat file Xib kami sendiri.  Bagaimanapun, seluruh UI layar ini ada di Storyboard, dan berkat Tata Letak Otomatis yang dikonfigurasi dengan benar, gulir akan bekerja dengan sempurna, beradaptasi dengan konten: <br><br><img src="https://habrastorage.org/webt/vg/pr/dl/vgprdl652o0neubp6d87fvcyupk.gif" width="320" height="588"><br><br>  Kami juga dapat membuat sel beradaptasi dengan ukuran kontennya.  Tambahkan <code>UILabel</code> ke setiap sel, ikat ke tepi: <br><img src="https://habrastorage.org/webt/ei/u0/if/eiu0ifpkzcudjmimrknducpg5f4.png"><br>  Sudah jelas bagaimana ini semua akan terlihat pada waktu berjalan.  Anda dapat melampirkan tindakan apa pun ke sel, misalnya, beralih ke layar lain.  Dan semua ini tanpa satu baris kode. <br>  Selain itu, jika Anda menetapkan <code>hidden = true</code> untuk <code>UIView</code> dari <code>UIStackView</code> , itu tidak hanya akan disembunyikan, tetapi juga tidak akan memakan tempat.  <code>UIStackView</code> akan secara otomatis menghitung ulang ukurannya: <br><br><img src="https://habrastorage.org/webt/b8/cs/ch/b8cschy8jwotcb1fge4ew2ip43s.gif"><br><br><h4>  Sel sizing diri </h4><br>  Di <b>pemeriksa ukuran</b> tabel, atur <b>Tinggi Baris = Otomatis</b> , dan <b>Perkirakan</b> - untuk beberapa nilai rata-rata: <br><img src="https://habrastorage.org/webt/p2/tp/de/p2tpdecyxveakvtukce9maxkrbq.png"><br>  Agar ini berfungsi, kendala harus dikonfigurasikan dengan benar di dalam sel itu sendiri dan memungkinkan penghitungan tinggi sel yang akurat berdasarkan konten pada waktu berjalan.  Jika tidak jelas apa yang dipertaruhkan, ada penjelasan yang sangat bagus dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi</a> . <br><br>  Akibatnya, memulai aplikasi, kita akan melihat bahwa semuanya ditampilkan dengan benar: <br><img src="https://habrastorage.org/webt/yi/mb/4q/yimb4q-qt5ydm3_3ynqavuvr4ga.png" width="432" height="702"><br><h4>  Tabel ukuran sendiri </h4><br>  Anda perlu menerapkan perilaku tabel ini: <br><br><img src="https://habrastorage.org/webt/6g/pp/bf/6gppbf-ma4zin0czafyjn3wfj08.gif" width="320" height="588"><br><br>  Bagaimana cara mencapai perubahan dinamis yang sama tingginya?  Tidak seperti <code>UILabel</code> , <code>UIButton</code> dan subkelas lain dari <code>UIView</code> , ini sedikit lebih sulit dilakukan dengan tabel, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ukuran Konten Intrinsik</a> tidak tergantung pada ukuran sel di dalamnya.  Dia tidak dapat menghitung tinggi badannya berdasarkan konten, tetapi ada peluang untuk membantunya dalam hal ini. <br><br>  Perhatikan bahwa pada titik tertentu dalam video, ketinggian tabel berhenti berubah, mencapai nilai maksimum tertentu.  Ini dapat dicapai dengan menetapkan <b>batasan tinggi</b> tabel dengan nilai <b>Relation = Less Than Or Equal</b> : <br><img src="https://habrastorage.org/webt/xk/47/rc/xk47rcebixtr42k1ka4wqagftyy.png"><br>  Pada tahap ini, Interface Builder belum tahu berapa tinggi tabelnya, ia hanya tahu nilai maksimumnya sama dengan 200 (dari batasan ketinggian).  Seperti disebutkan sebelumnya, Ukuran Konten Intrinsik tidak sama dengan isi tabel.  Namun, kami memiliki kemampuan untuk menetapkan placeholder di bidang <b>Ukuran Intrinsik</b> : <br><img src="https://habrastorage.org/webt/tb/i7/eu/tbi7eut1jafonqjknoyabqyev_q.png"><br>  Nilai ini hanya valid saat bekerja dengan Interface Builder.  Tentu saja, Ukuran Konten Intrinsik tidak harus sama dengan nilai ini saat runtime.  Kami baru saja mengatakan Interface Builder bahwa semuanya terkendali. <br><br>  Selanjutnya, buat subkelas baru dari tabel <code>CustomTableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTableView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { invalidateIntrinsicContentSize() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intrinsicContentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentSize } }</code> </pre> <br>  Salah satu kasus ketika kode diperlukan.  Di sini kita panggil <code>invalidateIntrinsicContentSize</code> setiap kali <code>contentSize</code> berubah.  Ini akan memungkinkan sistem untuk menerima Ukuran Konten Intrinsik yang baru.  Ini, pada gilirannya, mengembalikan <code>contentSize</code> , memaksa tabel untuk secara dinamis menyesuaikan ketinggiannya dan menampilkan sejumlah sel tanpa menggulir.  Pengguliran muncul pada saat kita mencapai batas batasan ketinggian. <br><br>  Ketiga fitur Interface Builder ini dapat digabungkan satu sama lain.  Mereka menambahkan lebih banyak fleksibilitas untuk opsi organisasi konten tanpa perlu kendala tambahan atau <code>UIView</code> . <br><br><h3>  2. Kemampuan untuk langsung melihat hasil dari tindakan mereka </h3><br>  Jika Anda mengubah ukuran <code>UIView</code> , memindahkannya beberapa titik ke samping, atau mengubah warna latar belakang, Anda akan segera melihat bagaimana tampilannya saat runtime tanpa harus meluncurkan aplikasi.  Tidak perlu heran mengapa beberapa tombol tidak muncul di layar atau mengapa perilaku <code>UIView</code> tidak seperti yang diinginkan. <br><br>  Menggunakan <code>@IBInspectable</code> mengungkapkan manfaat ini bahkan lebih menarik.  Tambahkan dua <code>UILabel</code> dan dua properti ke <code>RedView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { titleLabel.text = title } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { subtitleLabel.text = subtitle } } }</code> </pre> <br>  Dua bidang baru akan muncul di <b>Inspektur Atribut</b> untuk <code>RedView</code> - <code>Title</code> dan Terjemahan, yang kami <code>@IBInspectable</code> tanda <code>@IBInspectable</code> : <br><img src="https://habrastorage.org/webt/wv/rh/nn/wvrhnnegpjpyo7zrj7857dlujom.png"><br>  Jika kami mencoba memasukkan nilai di bidang ini, kami akan segera melihat bagaimana semuanya akan terlihat pada runtime: <br><br><img src="https://habrastorage.org/webt/hn/bd/6u/hnbd6urq0ebbpghnuiaueovz38i.gif"><br><br>  Anda dapat mengontrol apa saja: <code>cornerRadius</code> , <code>borderWidth</code> , <code>borderColor</code> .  Sebagai contoh, kami memperluas kelas dasar <code>UIView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.cornerRadius = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.cornerRadius } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderWidth = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderWidth } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: <span class="hljs-type"><span class="hljs-type">UIColor?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderColor = newValue?.cgColor } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderColor != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(cgColor: layer.borderColor!) : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotate: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: newValue * .pi/<span class="hljs-number"><span class="hljs-number">180</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br>  Kami melihat bahwa Inspektur Atribut objek <code>RedView</code> memperoleh 4 bidang baru lagi, yang sekarang dapat Anda mainkan juga: <br><br><img src="https://habrastorage.org/webt/gq/ib/bm/gqibbmd2an0a4zezig2iuifx5tm.gif"><br><br><h3>  3. Pratinjau semua ukuran layar sekaligus </h3><br>  Jadi kami melempar elemen yang diperlukan di layar, menyesuaikan penampilan mereka dan menambahkan kendala yang diperlukan.  Bagaimana cara mengetahui apakah konten akan ditampilkan dengan benar pada ukuran layar yang berbeda?  Tentu saja, Anda dapat menjalankan aplikasi pada setiap simulator, tetapi itu akan memakan banyak waktu.  Ada opsi yang lebih baik: Xcode memiliki mode pratinjau, memungkinkan Anda untuk melihat beberapa ukuran layar sekaligus tanpa meluncurkan aplikasi. <br><br>  Kami memanggil <b>editor Asisten</b> , di dalamnya klik pada segmen pertama dari bar transisi, pilih <b>Preview -&gt; Settings.storyboard</b> (sebagai contoh): <br><img src="https://habrastorage.org/webt/aw/mg/nr/awmgnrb4ajxr49hrygbe70fz5is.png"><br>  Pada awalnya kita hanya melihat satu layar, tetapi kita dapat menambahkan sebanyak yang dibutuhkan dengan mengklik "+" di sudut kiri bawah dan memilih perangkat yang diperlukan dari daftar: <br><img src="https://habrastorage.org/webt/18/3f/eo/183feokkgdpycsxlcr3a1upo8jk.png"><br>  Selain itu, jika Storyboard mendukung beberapa bahasa, Anda dapat melihat bagaimana tampilan layar yang dipilih dengan masing-masing bahasa: <br><img src="https://habrastorage.org/webt/hy/nf/6g/hynf6gc-nzhc30fxq0ir2a2uzcc.png"><br>  Bahasa dapat dipilih untuk semua layar sekaligus, dan untuk masing-masing secara individual. <br><br><h3>  4. Menghapus kode UI templat </h3><br>  Membuat antarmuka pengguna tanpa Interface Builder disertai dengan sejumlah besar kode boilerplate, atau superclasses dan ekstensi yang memerlukan pekerjaan pemeliharaan tambahan.  Kode ini dapat menyusup ke bagian lain aplikasi, sehingga sulit dibaca dan dicari.  Menggunakan Storyboards dan Xibs dapat mengeluarkan kode, membuatnya lebih fokus pada logika. <br><br><h3>  5. Kelas ukuran </h3><br>  Setiap tahun, perangkat baru muncul, untuk itu Anda perlu menyesuaikan antarmuka pengguna.  Konsep <b>variasi sifat</b> dan, khususnya, <b>kelas ukuran</b> , yang memungkinkan Anda membuat UI untuk berbagai ukuran dan orientasi layar, membantu dalam hal ini. <br><br>  Kelas ukuran mengklasifikasikan tinggi (h) dan lebar (w) layar perangkat dalam hal <b>kompak</b> dan <b>reguler</b> ( <b>C</b> dan <b>R</b> ).  Misalnya, iPhone 8 memiliki kelas ukuran <b>(wC hR)</b> dalam orientasi potret dan <b>(wC hC)</b> dalam lanskap, dan iPhone 8 Plus memiliki <b>(wC hR)</b> dan <b>(wR hC)</b> masing-masing.  Sisa perangkat dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam satu Storyboard atau Xib untuk masing-masing kelas ukuran, Anda dapat menyimpan kumpulan data Anda sendiri, dan aplikasi akan menggunakan yang sesuai tergantung pada perangkat dan orientasi layar saat runtime, sehingga mengidentifikasi kelas ukuran saat ini. Jika beberapa parameter tata letak sama untuk semua kelas ukuran, maka mereka dapat dikonfigurasi dalam kategori " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", yang sudah dipilih secara default. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai contoh, konfigurasikan ukuran font tergantung pada kelas ukuran. Kami memilih perangkat iPhone 8 Plus untuk dilihat di Storyboard dalam orientasi potret dan menambahkan kondisi baru untuk </font></font><code>font</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: jika </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebar adalah Regular</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (atur sisanya ke "Any"), maka ukuran font harus 37:</font></font><br><img src="https://habrastorage.org/webt/bd/bs/-7/bdbs-7i602wtlxemns-hm3jz3ps.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, jika kita mengubah orientasi layar, ukuran font akan meningkat - kondisi baru akan berfungsi, karena iPhone 8 Plus memiliki kelas ukuran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam orientasi lanskap </font><font style="vertical-align: inherit;">. Di Storyboard, tergantung pada kelas ukuran, Anda juga dapat menyembunyikan Tampilan, mengaktifkan / menonaktifkan kendala, mengubah nilainya </font></font><code>constant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan banyak lagi. Baca lebih lanjut tentang cara melakukan semua ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tangkapan layar di atas, perlu dicatat panel bawah dengan pilihan perangkat untuk menampilkan tata letak. Ini memungkinkan Anda untuk dengan cepat memeriksa kemampuan UI pada perangkat apa pun dan dengan orientasi layar apa pun, dan juga menunjukkan kelas ukuran konfigurasi saat ini (di sebelah nama perangkat). Antara lain, di sebelah kanan ada tombol « </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vary for Traits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Tujuannya adalah untuk mengaktifkan variasi sifat hanya untuk kategori lebar, tinggi atau lebar dan tinggi secara bersamaan. </font><font style="vertical-align: inherit;">Misalnya, memilih iPad dengan kelas ukuran </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , klik "Vary for Traits" dan centang kotak di sebelah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lebar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tinggi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sekarang, semua perubahan tata letak berikutnya hanya akan berlaku untuk perangkat dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hingga kami mengklik </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selesai</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Kesimpulan </h2><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> # </font></font><br></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kekurangan </font></font><br></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manfaatnya </font></font><br></th></tr><tr><td>  1 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sulit untuk mengatasi konflik </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisasi dan kendala UI </font></font><br></td></tr><tr><td>  2 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak sefleksibel kode </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemampuan untuk langsung melihat hasil tindakan Anda </font></font><br></td></tr><tr><td>  3 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesalahan dapat menyebabkan kerusakan saat runtime. </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pratinjau semua ukuran layar sekaligus </font></font><br></td></tr><tr><td>  4 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda tidak dapat menggunakan inisialisasi khusus untuk </font></font><code>UIViewControllers</code> <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menghapus kode UI templat </font></font><br></td></tr><tr><td>  5 <br></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kelas ukuran </font></font><br></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melihat bahwa Storyboard memiliki kekuatan dan kelemahan mereka. </font><font style="vertical-align: inherit;">Pendapat saya adalah bahwa Anda seharusnya tidak sepenuhnya menolak untuk menggunakannya. </font><font style="vertical-align: inherit;">Ketika digunakan dengan benar, mereka membawa manfaat besar dan membantu menyelesaikan tugas secara efektif. </font><font style="vertical-align: inherit;">Anda hanya perlu belajar bagaimana memprioritaskan dan melupakan argumen seperti "Saya tidak suka Storyboards" atau "Saya sudah terbiasa melakukan ini."</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456086/">https://habr.com/ru/post/id456086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456068/index.html">5 kesalahan memimpin pemula</a></li>
<li><a href="../id456070/index.html">Cara menarik pengguna ke portal swalayan</a></li>
<li><a href="../id456072/index.html">Dav1d - dekoder AV1 tercepat sekarang di Firefox secara default</a></li>
<li><a href="../id456078/index.html">Proyeksi konflik perusahaan pada konektivitas jaringan</a></li>
<li><a href="../id456084/index.html">Kubernet 1.15: Ikhtisar Sorotan</a></li>
<li><a href="../id456088/index.html">Masalah Analisis Data Besar</a></li>
<li><a href="../id456090/index.html">Pengantar Unit Testing in Unity</a></li>
<li><a href="../id456092/index.html">Tujuh tanda yang merisaukan bahwa Anda bergantung pada cuaca, meskipun Anda tidak mengira begitu</a></li>
<li><a href="../id456094/index.html">Kami membaca lembar data 2: SPI pada STM32; Pengatur waktu PWM dan interupsi pada STM8</a></li>
<li><a href="../id456096/index.html">Apa yang pembaca geektimes rata-rata lakukan sambil melayang di awan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>