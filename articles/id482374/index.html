<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏳️‍🌈 👩🏽‍🎨 🏴󠁧󠁢󠁳󠁣󠁴󠁿 Mengembangkan game di LibGDX menggunakan templat Sistem Entitas Komponen 👩🏿‍⚕️ ☺️ 📺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Habr! Nama saya Andrey Shilo, saya adalah pengembang android di FINCH . Hari ini saya akan memberi tahu Anda tentang kesalahan apa yang tidak bole...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengembangkan game di LibGDX menggunakan templat Sistem Entitas Komponen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482374/">  Hai Habr!  Nama saya Andrey Shilo, saya adalah pengembang android di <a href="https://www.facebook.com/FinchMoscow">FINCH</a> .  Hari ini saya akan memberi tahu Anda tentang kesalahan apa yang tidak boleh dilakukan saat menulis bahkan game paling sederhana dan mengapa pendekatan arsitektur <a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity Component System</a> (ECS) keren. <br><a name="habracut"></a><br><h2>  Pertama kali selalu menyakitkan </h2><br>  Kami memiliki satu proyek menyenangkan untuk memegang media besar, yang merupakan sosial non-standar.  jaringan dengan posting, komentar, suka dan video.  Suatu kali, mereka memberi kami tugas - untuk memperkenalkan mekanik permainan sebagai promosi.  Permainan tampak seperti balapan mini sederhana, di mana dengan ketukan di kiri / kanan, mobil bergerak ke jalur kiri / kanan.  Jadi, menghindari rintangan dan mengumpulkan booster Anda harus sampai ke garis finish, semuanya, pemain memiliki tiga nyawa. <br><br>  Permainan itu seharusnya dilaksanakan tepat di dalam aplikasi, tentu saja, pada layar yang terpisah.  Kami memilih <a href="https://libgdx.badlogicgames.com/">LibGDX</a> tanpa syarat sebagai mesin, karena Anda dapat membuat kode game di kotiln, dan men-debug di desktop, meluncurkan game sebagai <a href="https://libgdx.badlogicgames.com/documentation/gettingstarted/Running%2520and%2520Debugging.html">aplikasi java</a> .  Pada saat yang sama, kami tidak memiliki orang yang tahu mesin lain yang dapat diimplementasikan dalam aplikasi (jika Anda tahu, maka bagikan). <br><br>  Permainan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/le/xy/z0/lexyz0syrcyj6czcecctxnw0kh8.jpeg"><br><br>  Karena permainan menurut TK asli tampak sederhana, kami tidak mempelajari pendekatan arsitektur.  Selain itu, promosi itu sendiri berlalu dengan cepat - rata-rata, satu bagian memakan waktu satu setengah bulan.  Dengan demikian, nanti, kode permainan hanya akan dipotong dan tidak akan diperlukan sampai promo berikutnya, asalkan seseorang ingin mengulang sesuatu seperti itu. <br><br>  Semua faktor yang dijelaskan di atas dan para manajer tercinta yang mendesak mendorong kami untuk menulis mekanik permainan tanpa arsitektur apa pun. <br><br><h2>  Deskripsi game yang dihasilkan </h2><br>  Sebagian besar kode dikompilasi di kelas: MyGdxGame: <a href="https://libgdx.badlogicgames.com/ci/nightlies/docs/api/com/badlogic/gdx/Game.html">Game</a> , GameScreen: <a href="https://libgdx.badlogicgames.com/ci/nightlies/docs/api/com/badlogic/gdx/Screen.html">Screen</a> dan TrafficGame: <a href="https://libgdx.badlogicgames.com/ci/nightlies/docs/api/com/badlogic/gdx/scenes/scene2d/Actor.html">Actor</a> . <br><br>  MyGdxGame - adalah titik masuk pada awal permainan, di sini parameter ditransfer ke konstruktor dalam bentuk string.  GameScreen dan parameter game juga dibuat di sini, yang diteruskan ke kelas ini, tetapi dalam bentuk yang berbeda. <br><br>  GameScreen - menciptakan aktor dari game TrafficGame, menambahkannya ke adegan, memberikannya parameter yang telah disebutkan, dan juga "mendengarkan" klik pengguna di layar dan memanggil metode yang sesuai dari aktor TrafficGame. <br><br>  TrafficGame - aktor utama adegan di mana semua gerakan permainan terjadi: rendering dan logika kerja. <br><br>  Meskipun menggunakan <a href="https://github.com/libgdx/libgdx/wiki/Scene2d">scene2d</a> memungkinkan untuk membangun pohon aktor bersarang, ini bukan solusi arsitektur terbaik.  Namun, untuk mengimplementasikan game UI / UX (di LibGDX), scene2d adalah pilihan yang bagus. <br><br>  Dalam kasus kami, TrafficGame memiliki banyak koleksi instance campuran dan semua jenis panji perilaku yang diizinkan dalam metode dengan konstruksi besar <i>saat</i> membangun.  Contoh: <br><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isGameActive: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(value) { backgroundActor?.isGameActive = value boostersMap.values.filterNotNull().forEach { it.isGameActive = value } obstaclesMap.values.filterNotNull().forEach { it.isGameActive = value } finishActor.isGameActive = value field = value } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> backgroundActoolbarActor <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pauseButtonActor: PauseButtonActor <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> finishActor: FinishActor <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isQuizWon = falser: BackgroundActor? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> playerCarActor: PlayerCarActor <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toolbarActor: To <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pointsTime = <span class="hljs-number"><span class="hljs-number">0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalTimeElapsed = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeToFinishTheGame = <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastQuizBoosterTime = <span class="hljs-number"><span class="hljs-number">0.0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastBoosterTime = <span class="hljs-number"><span class="hljs-number">0.0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boostersMap = hashMapOf&lt;<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>?, BoosterActor?&gt;() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boosterSpawnedCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalBoostersEatenCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boosterLimit = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastBoosterYPos = <span class="hljs-number"><span class="hljs-number">0.0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toGenerateBooster = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastObstacleTime = <span class="hljs-number"><span class="hljs-number">0.0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obstaclesMap = hashMapOf&lt;<span class="hljs-built_in"><span class="hljs-built_in">Long</span></span>?, ObstacleActor?&gt;()</code> </pre> <br>  Tentu, Anda tidak boleh menulis seperti itu.  Tetapi dalam pembelaan saya akan mengatakan bahwa itu terjadi karena: <br><br><ul><li>  Anda harus mulai sekarang, baik, dan kami akan menunjukkan TK terakhir dengan desain nanti.  Klasik </li><li>  Arsitektur yang sudah dikenal (MVP / MVC / MVVM, dll.) Tidak cocok untuk implementasi proses game, karena mereka dirancang murni untuk antarmuka pengguna, dalam game semuanya terjadi secara real time. </li><li>  Awalnya, permainan ini tampak sederhana, tetapi sebenarnya membutuhkan banyak kode, dengan mempertimbangkan sejumlah besar nuansa, yang sebagian besar muncul selama penulisan permainan. </li></ul><br><img src="https://habrastorage.org/webt/8e/cg/sn/8ecgsncl5hmmhmzw8unltjyqgh0.jpeg"><br><br>  Selain semua kesulitan ini, ada masalah umum lainnya dengan warisan.  Jika Anda membuat game lebih sulit, misalnya platformer, maka muncul pertanyaan - "Bagaimana cara mendistribusikan kode yang dapat digunakan kembali antara objek-objek game?"  Opsi yang paling umum dipilih adalah pewarisan, di mana kode yang dapat digunakan kembali ditempatkan di kelas induk.  Tetapi solusi ini menciptakan banyak masalah jika kondisi yang muncul tidak sesuai dengan pohon warisan: <br><br><img src="https://habrastorage.org/webt/xg/tw/_6/xgtw_64w3v31if0kfnwoy9yemlg.png"><br><br>  Dan mereka biasanya memecahkan masalah seperti itu dengan menulis ulang struktur pohon warisan dari awal (well, kali ini tentu akan lebih baik), atau kelas induknya dipatahkan dengan kruk. <br><br><img src="https://habrastorage.org/webt/af/8-/4o/af8-4ovkeruwatlo--agakilupm.gif"><br><br><h2>  ECS adalah segalanya bagi kami </h2><br>  Cerita yang sama sekali berbeda adalah game promo kami yang kedua.  Dia seperti <a href="https://ru.wikipedia.org/wiki/Flappy_Bird">Flappy Bird</a> , tetapi dengan perbedaan: karakternya dikendalikan oleh suara, dan langit-langit dan lantai bukanlah hambatan - Anda bisa meluncur di atasnya. <br>  Contoh gameplay dan untuk perbandingan, proses bermain Flappy Bird: <br><br><img src="https://habrastorage.org/webt/9k/sv/ao/9ksvaojzedwbnyd0nm602f2n90e.gif"><br><img src="https://habrastorage.org/webt/gr/sq/3t/grsq3twwn7aorv6utrvdvgnwldw.gif"><br><br>  Untuk kejelasan, dalam contoh, kamera dilepas untuk melihat bagian belakang permainan.  Lantai dan langit-langit adalah blok persegi yang, mencapai tepi, disusun kembali ke awal, dan hambatan dihasilkan sesuai dengan pola yang diberikan yang datang dari belakang.  Desain game dipilih oleh pelanggan, jadi jangan kaget. <br><br>  Saya suka pengembangan game untuk perangkat seluler dan pada jam-jam libur, demi percobaan, saya akan mengeksplorasi pola permainan dan segala sesuatu yang terkait dengan pengembangan game.  Saya membaca buku tentang <a href="https://gameprogrammingpatterns.com/">pola desain game</a> , tetapi tidak mengerti apa yang sebenarnya menjadi arsitektur logika gameplay yang sebenarnya, sampai saya menemukan ECS. <br><br>  Sistem Komponen Entitas - pola desain yang paling sering digunakan dalam pengembangan game.  Gagasan utama polanya adalah <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">komposisi alih-alih warisan</a> .  Komposisi ini memungkinkan Anda untuk mencampur mekanisme yang berbeda pada objek game, ini, di masa depan, memungkinkan Anda untuk mendelegasikan pengaturan properti objek ke desainer game, misalnya, melalui konstruktor tertulis.  Karena saya sudah terbiasa dengan pola ini, kami memutuskan untuk menerapkannya di game kedua. <br><br>  Pertimbangkan komponen-komponen dari pola: <br><br><ul><li>  <i>Komponen</i> - objek dengan <b>struktur data sederhana yang</b> tidak mengandung logika apa pun, atau bertindak sebagai pintasan.  Komponen dibagi berdasarkan tujuan dan menentukan semua properti dari objek game.  Kecepatan, posisi, tekstur, tubuh, dll.  dll.  semua ini dijelaskan dalam komponen dan kemudian ditambahkan ke objek game. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VelocityComponent</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Component { val velocity = Vector2</span></span></span></span>() }</code> </pre> </li><li>  <i>Entitas</i> - objek game: penghalang / penguat / pahlawan yang dikontrol dan bahkan latar belakang.  Mereka tidak memiliki kelas khusus berdasarkan tipe: UltraMegaSuperman: GameUnit, tetapi hanya <b>merupakan wadah</b> untuk set Komponen.  Fakta bahwa entitas tertentu dengan demikian UltraMegaSuperman mendefinisikan set komponen dan parameternya. <br>  Misalnya, dalam kasus kami, karakter utama memiliki komponen berikut: <br><br><ul><li>  TextureComponent - menentukan apa yang harus digambar di layar </li><li>  TransformComponent - posisi objek di ruang permainan </li><li>  VelocityComponent - kecepatan objek di ruang permainan </li><li>  HeroControllerComponent - berisi nilai-nilai yang mempengaruhi pergerakan pahlawan </li><li>  ImmortalityTimeComponent - berisi sisa waktu keabadian </li><li>  DynamicComponent - menunjukkan bahwa objek tidak statis dan tunduk pada gravitasi </li><li>  BodyComponent - mendefinisikan tubuh fisik pahlawan 2d yang diperlukan untuk menghitung tabrakan </li></ul></li><li>  <i>Sistem</i> - berisi kode untuk memproses data dari komponen masing-masing entitas.  Mereka <b>tidak</b> boleh <b>menyimpan objek Entitas dan / atau Komponen</b> , karena ini akan bertentangan dengan pola.  Idealnya, mereka harus bersih sama sekali. <br><br>  Sistem melakukan semua pekerjaan kotor: menggambar semua objek dalam game, memindahkan objek dengan kecepatannya, memeriksa tabrakan, mengubah kecepatan dari kontrol yang masuk, dan sebagainya.  Misalnya, efek gravitasi terlihat seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(entity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Entity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, deltaTime: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { entity.getComponent(VelocityComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">velocity</span></span></span><span class="hljs-class"> .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-number"><span class="hljs-number">0f</span></span>, -GRAVITY * deltaTime) }</code> </pre> <br>  Spesialisasi masing-masing sistem menentukan persyaratan untuk entitas yang harus diproses.  Yaitu, dalam contoh di atas, entitas harus memiliki komponen kecepatan VelocityComponent dan DynamicComponent sehingga entitas ini dapat diproses, jika tidak entitas ini tidak menarik bagi sistem, dan begitu pula dengan yang lain.  Untuk menggambar tekstur, misalnya, Anda perlu tahu apa tekstur TextureComponent dan di mana menggambar TransformComponent.  Untuk menentukan persyaratan dalam setiap sistem, Keluarga ditulis dalam konstruktor di mana kelas komponen ditunjukkan. <br><br><pre> <code class="kotlin hljs">Family.all(TransformComponent::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TextureComponent::class.java).get</span></span></span></span>()</code> </pre> <br>  Juga, urutan entitas pemrosesan dalam sistem dapat disesuaikan oleh pembanding.  Selain itu, urutan pelaksanaan sistem di mesin juga diatur oleh nilai prioritas. <br></li></ul><br>  Mesin menggabungkan tiga komponen.  Ini berisi semua sistem dan semua entitas dalam game.  Di awal permainan, semua sistem yang diperlukan dalam permainan <br><br><pre> <code class="kotlin hljs">engine.apply { addSystem(ControlSystem()) addSystem(GravitySystem()) addSystem(renderingSystem) addSystem(MovementSystem()) addSystem(EnemyGeneratorSystem()) }</code> </pre>  serta entitas awal ditambahkan ke mesin, <br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hero: Entity = engine.createEntity() engine.addEntity(hero)</code> </pre> <br>  <a href="https://libgdx.badlogicgames.com/ci/ashley/docs/com/badlogic/ashley/core/PooledEngine.html">PooledEngine :: createEntity</a> - mendapatkan objek entitas dari <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BF%25D1%2583%25D0%25BB">pool</a> , karena entitas dapat dibuat selama permainan, agar tidak membuang sampah di memori.  Jika perlu, mereka diambil dari kumpulan objek, dan ketika dihapus, mereka ditempatkan kembali.  Demikian pula yang dilakukan untuk komponen.  Saat menerima komponen dari kumpulan, perlu menginisialisasi semua bidang, karena mungkin berisi informasi tentang penggunaan sebelumnya dari komponen ini. <br><br>  Hubungan antara bagian-bagian utama dari pola disajikan di bawah ini: <br><br><img src="https://habrastorage.org/webt/gk/tj/ak/gktjakst_gxpnuikd_bbgpnfv2a.png"><br><br>  Mesin berisi kumpulan sistem dan kumpulan entitas.  Setiap sistem menerima tautan dari mesin ke kumpulan entitas, yang merupakan seleksi dari koleksi umum sesuai dengan persyaratan sistem, itu akan diperbarui selama pertandingan ketika entitas dan komponen berubah.  Setiap entitas berisi kumpulan komponennya yang mendefinisikannya dalam game. <br><br>  Siklus permainan disusun sebagai berikut: <br><br><ol><li>  Menggunakan penerapan pola <a href="https://habr.com/ru/post/271315/">"Game cycle"</a> dari LibGDX, dalam metode pembaruan kami mendapatkan kenaikannya di setiap langkah waktu - deltaTime. </li><li>  Selanjutnya, kita melewatkan waktu untuk mesin.  Dan dia, pada gilirannya, beralih melalui sistem dalam satu siklus, mendistribusikannya deltaTime. <pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> until systems.size()) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> system = systems[i] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (system.checkProcessing()) { system.update(deltaTime) } }</code> </pre> </li><li>  Sistem yang menerima deltaTime menyortir entitas mereka dan menerapkan perubahan pada mereka dengan mempertimbangkan deltaTime akun. <pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> until entities.size()) { processEntity(entities[i], deltaTime) }</code> </pre> </li></ol><br>  Ini terjadi setiap ukuran permainan. <br><br><h2>  Manfaat ECS </h2><br><ol><li>  <b>Data lebih dulu</b> .  Karena sistem hanya memproses entitas yang sesuai dengan mereka, jika tidak ada entitas seperti itu, sistem tidak akan melakukan apa pun, ini memungkinkan untuk menguji dan men-debug fitur baru, hanya membuat entitas yang diperlukan untuk ini. <br><br>  Misalnya, Anda membuat game "Tanks".  Setelah beberapa waktu, Anda memutuskan untuk menambahkan jenis medan baru - "lava".  Jika tangki mencoba melewatinya, maka itu akan berakhir dengan kegagalan.  Tetapi teknologi futuristik datang untuk menyelamatkan, dengan menginstal yang Anda dapat menyeberangi lahar. <br><br>  Untuk men-debug kasus seperti itu, Anda tidak perlu membuat model penuh tank dan membangun peta lengkap dengan lokasi lava tambahan - cukup pikirkan komponen minimum yang diperlukan pada tangki dan tambahkan entitas ke mesin game untuk diuji.  Semua ini terdengar jelas, tetapi pada kenyataannya Anda menemukan kelas TheTank yang di konstruktor meminta daftar parameter: kaliber, kecepatan, sprite, kecepatan tembakan, nama kru, dll.  meskipun ini tidak perlu untuk menguji persimpangan lava. <br></li><li>  Juga, mengikuti contoh dari paragraf sebelumnya, kami mencatat <b>fleksibilitas yang sangat besar</b> , karena dengan pendekatan ini lebih mudah untuk menambah dan menghapus fitur. <br><br>  Contoh nyata.  Skenario permainan dari promo kedua kami adalah bahwa pengguna, setelah mengeksekusi lagu selama ~ 2 menit, menabrak garis finish, dan permainan memulai hitungan mundur dengan memulai kembali level lagi, tetapi dengan menyimpan poin, sehingga memberikan istirahat bagi pemain. <br><br>  Beberapa hari sebelum rilis yang diharapkan datang tugas "untuk menghapus garis finish dan membuat laporan selama setengah jam bermain terus menerus dengan rintangan dan lagu looping."  Perubahan global, tapi itu sangat mudah dilakukan - itu cukup untuk menghilangkan esensi dari garis finish dan menambahkan sistem referensi untuk akhir permainan. </li><li>  Semua perkembangan <b>mudah untuk diuji</b> .  Mengetahui bahwa data ada di tempat pertama, Anda dapat mensimulasikan kasus uji, menjalankannya dan melihat hasilnya. </li><li>  Di masa depan, untuk <b>memvalidasi keadaan game</b> , Anda dapat menghubungkan server ke proses game.  Dia akan menjalankan kode yang sama dengan input klien yang sama dan membandingkan hasilnya dengan hasil pada klien.  Jika data tidak konvergen, maka klien adalah penipu atau kami memiliki kesalahan dalam permainan. </li></ol><br><br><h2>  ECS di dunia besar gamedev </h2><br>  Perusahaan-perusahaan besar seperti Unity, Epic atau Crytek menggunakan templat ini dalam kerangka mereka untuk menyediakan alat dengan satu ton fitur kepada pengembang.  Saya menyarankan Anda untuk melihat laporan tentang bagaimana <a href="https://www.youtube.com/watch%3Fv%3D2Hi3GeCBpd0">logika gameplay</a> diimplementasikan <a href="https://www.youtube.com/watch%3Fv%3D2Hi3GeCBpd0">di Overwatch</a> <br><br>  Untuk pemahaman yang lebih baik, saya membuat <a href="https://github.com/AndrewMisterio/examples">contoh</a> kecil <a href="https://github.com/AndrewMisterio/examples">di github</a> . <br>  Terima kasih atas perhatian anda! <br><br><h2>  Juga pada topik: </h2><br><ul><li>  <a href="https://habr.com/ru/post/343778/">Implementasi dan contoh permainan</a> </li><li>  <a href="https://habr.com/ru/post/358108/">ECS dan semuanya</a> </li><li>  <a href="https://leopotam.com/2/">Dasar-Dasar ECS</a> </li><li>  <a href="https://fateev.pro/ru/gamedev/entity-component-system">Komponen dan Sistem Entitas</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482374/">https://habr.com/ru/post/id482374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482362/index.html">Nearly Anarchy: Sejarah Singkat Fidonet, Proyek yang Tidak Peduli Menang Melalui Internet</a></li>
<li><a href="../id482364/index.html">Hal-hal yang [Mungkin] Tidak Anda Ketahui tentang Java</a></li>
<li><a href="../id482366/index.html">Apa pendapat ahli mobil robot tentang Tesla Autopilot</a></li>
<li><a href="../id482370/index.html">nodejs: manajer proses dan modul ES6</a></li>
<li><a href="../id482372/index.html">Aktifkan Mode Sesi yang Ditingkatkan untuk Tamu Arch Linux di Hyper-V</a></li>
<li><a href="../id482378/index.html">Sejarah singkat Wacom: bagaimana teknologi tablet grafis sampai pada pembaca elektronik</a></li>
<li><a href="../id482382/index.html">Empat prinsip terjemahan, atau dengan cara apa seseorang tidak akan menyerah pada penerjemah mesin?</a></li>
<li><a href="../id482384/index.html">Proyek saya yang belum direalisasi. Jaringan 200 MikroTik Router</a></li>
<li><a href="../id482386/index.html">Visual Studio untuk Mac: Kendalikan IDE Anda dengan Keybindings</a></li>
<li><a href="../id482390/index.html">Tutorial dari tutorial Ember.js. Aplikasi Super Rentals. Bagian 1.2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>