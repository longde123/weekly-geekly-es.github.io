<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚öïÔ∏è üë®üèº‚Äçüé® üö© Komunikasi antara driver dan perangkat dengan metode _HID ACPI menggunakan GPIO dari pengontrol Lynxpoint sebagai contoh üç≥ üëàüèΩ üëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernyataan masalah 
 Linux memiliki antarmuka standar untuk bekerja dengan GPIO melalui sysfs. Dokumentasi untuk itu dapat ditemukan di sini . 

 Sing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komunikasi antara driver dan perangkat dengan metode _HID ACPI menggunakan GPIO dari pengontrol Lynxpoint sebagai contoh</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429336/"><h3>  Pernyataan masalah </h3><br>  Linux memiliki antarmuka standar untuk bekerja dengan GPIO melalui sysfs.  Dokumentasi untuk itu dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Singkatnya, ada file "ekspor" dan "tidak ekspor" di folder "/ sys / class / gpio".  Dengan menulis angka X ke file ekspor, Anda dapat membuka antarmuka di ruang pengguna untuk mengontrol GPIOX <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    user space   GPIO12 $ echo 12 &gt; /sys/class/gpio/export</span></span></code> </pre> <br>  Setelah membuka antarmuka, folder / sys / class / gpio / gpioX / akan muncul di mana akan ada file seperti "nilai" atau "arah", dan dengan menulis "dalam" atau "keluar" ke file "arah" dan menulis 1 atau 0 ke file "Nilai" dapat mengontrol keluaran GPIO langsung dari baris perintah. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  GPIO   $ echo "out" &gt; /sys/class/gpio/gpio12/direction #  1   GPIO $ echo 1 &gt; /sys/class/gpio/gpio12/value</span></span></code> </pre> <br>  Agar perintah "echo X&gt; / sys / class / gpio / export" untuk membuat folder "gpioX", driver pengontrol GPIO harus terdaftar di kernel, yang membuka antarmuka ke jalur GPIO. <br><br>  Kebetulan saya sedang mengerjakan porting coreboot untuk custom board berdasarkan prosesor Intel Haswell i7 [Bagi mereka yang tidak tahu, coreboot adalah open source proyek open source proyek BIOS ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://www.coreboot.org/</a> ) ]  Jembatan selatan LynxpointLP di mana terdapat 94 garis GPIO dibangun ke prosesor saya.  Dan saya ingin membukanya di sysfs ... <br><a name="habracut"></a><br><h3>  Pemecahan masalah (komunikasi driver dan perangkat di Linux) </h3><br>  Setelah pencarian singkat pada kode kernel, saya menemukan bahwa driver ini telah ditulis, terletak di file "drivers \ gpio \ gpio-lynxpoint.c" dan diaktifkan menggunakan Kconfig <br><br><pre> <code class="hljs pgsql">config GPIO_LYNXPOINT tristate "Intel Lynxpoint GPIO support" <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ACPI &amp;&amp; X86 <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> GPIOLIB_IRQCHIP help driver <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GPIO functionality <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> Intel Lynxpoint PCH chipset Requires ACPI device enumeration code <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> up a platform device.</code> </pre> <br>  Opsi GPIO_LYNXPOINT diaktifkan di kernel yang saya kerjakan, namun, tidak ada folder "gpiochipN" tunggal untuk pengontrol GPIO di folder "/ sys / class / gpio /" (yang seharusnya), dan bahkan skrip seperti itu tidak mengarah ke ekspor semua garis. <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {0..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Melihat kode coreboot atau melihat dokumentasi untuk jembatan selatan ini, Anda dapat melihat bahwa pengontrol GPIO bukan perangkat PCI yang terpisah.  Ini adalah bagian dari perangkat PCI lain: LPC Interface Bridge.  Menggunakan register ruang konfigurasi PCI pada perangkat ini, Anda harus mengaktifkan pengendali GPIO dan menetapkannya BASE_ADDRESS di ruang I / O.  Ini akan membuka jendela dalam ruang I / O 1KV.  Dengan menulis / membaca byte di jendela ini, Anda dapat mengontrol baris GPIO. <br><br>  Apa yang bisa kita lihat dalam kode coreboot: <br><br>  southbridge \ intel \ lynxpoint \ pch.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOBASE 0x1400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_GPIOSIZE 0x400 ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_BASE 0x48 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Base Address Register */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GPIO_CNTL 0x4C </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* LPC GPIO Control Register */</span></span></span><span class="hljs-meta"> ... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PCI Configuration Space (D31:F0): LPC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCH_LPC_DEV PCI_DEV(0, 0x1f, 0)</span></span></code> </pre><br>  southbridge \ intel \ lynxpoint \ early_pch.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Setup GPIO Base Address */</span></span> pci_write_config32(PCH_LPC_DEV, GPIO_BASE, DEFAULT_GPIOBASE|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIO functionality. */</span></span> pci_write_config8(PCH_LPC_DEV, GPIO_CNTL, <span class="hljs-number"><span class="hljs-number">0x10</span></span>);</code> </pre> <br>  Jika kita melihat register perangkat LPC di Linux melalui "lspci -xxx", kita akan melihat bahwa data yang direkam oleh kita ada dalam register ini.  Jadi semuanya tampaknya sudah diatur sebagaimana mestinya. <br><br>  Melanjutkan melihat kode driver, saya perhatikan bahwa driver Linux berkomunikasi dengan perangkat melalui bidang .acpi_match_table.  Karena perangkat kami tidak dapat disebutkan (tidak terletak pada PCI atau bus USB), driver platform diperlukan untuk itu, dan koneksi driver ini dengan perangkat adalah melalui tabel ACPI.  Kasus biasa untuk x86, dalam kasus ARM, kami akan mendaftarkan perangkat kami di DeviceTree, atau menggunakan kode lama di kernel. <br><br>  driver \ gpio \ gpio-lynxpoint.c: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">acpi_device_id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lynxpoint_gpio_acpi_match</span></span></span><span class="hljs-class">[] = {</span></span> { <span class="hljs-string"><span class="hljs-string">"INT33C7"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"INT3437"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { } }; MODULE_DEVICE_TABLE(acpi, lynxpoint_gpio_acpi_match); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">platform_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lp_gpio_driver</span></span></span><span class="hljs-class"> = {</span></span> .probe = lp_gpio_probe, .remove = lp_gpio_remove, .driver = { .name = <span class="hljs-string"><span class="hljs-string">"lp_gpio"</span></span>, .pm = &amp;lp_gpio_pm_ops, .acpi_match_table = ACPI_PTR(lynxpoint_gpio_acpi_match), }, };</code> </pre><br>  Ia bekerja seperti ini: jika kernel, ketika mem-parsing tabel ACPI, melihat perangkat dengan pengenal _HID "INT33C7" di dalamnya, maka itu akan mencoba untuk menemukan driver platform untuk itu dengan pengidentifikasi yang cocok di bidang struktur ".driver-&gt; acpi_match_table". <br><br>  Ketika kecocokan ditemukan, Linux akan menjalankan fungsi driver .probe. <br><br>  Ternyata, kode ACPI untuk perangkat ini disajikan dalam coreboot, saya hanya berkomentar.  Mengomentari karena fakta bahwa untuk perangkat ini Windows tidak dapat menemukan driver dan menampilkan "Perangkat tidak dikenal" di manajer perangkat.  Lebih lanjut tentang ini di bawah ini. <br><br>  Jadi kami tertarik pada informasi dari file tersebut <br>  src \ southbridge \ intel \ lynxpoint \ acpi \ serialio.asl (kode ini sedikit disederhanakan): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     * src\southbridge\intel\lynxpoint\pch.h * #define DEFAULT_GPIOBASE 0x1400 * #define DEFAULT_GPIOSIZE 0x400 */</span></span> Scope (\_SB) { Device (PCI0) { ... Device (GPIO) { <span class="hljs-comment"><span class="hljs-comment">// GPIO Controller Name (_HID, "INT33C7") Name (_CID, "INT33C7") Name (_UID, 1) Name (RBUF, ResourceTemplate() { DWordIo (ResourceProducer, MinFixed, // IsMinFixed MaxFixed, // IsMaxFixed PosDecode, // Decode EntireRange, // ISARanges 0x00000000, // AddressGranularity 0x00000000, // AddressMinimum 0x00000000, // AddressMaximum 0x00000000, // AddressTranslation 0x00000001, // RangeLength , // ResourceSourceIndex , // ResourceSource BAR0) Interrupt (ResourceConsumer, Level, ActiveHigh, Shared, , , ) {14} }) Method (_CRS, 0, NotSerialized) { CreateDwordField (^RBUF, ^BAR0._MIN, BMIN) CreateDwordField (^RBUF, ^BAR0._MAX, BMAX) CreateDwordField (^RBUF, ^BAR0._LEN, BLEN) Store (DEFAULT_GPIOSIZE, BLEN) Store (DEFAULT_GPIOBASE, BMIN) Store (Subtract (Add (DEFAULT_GPIOBASE, DEFAULT_GPIOSIZE), 1), BMAX) Return (RBUF) } Method (_STA, 0, NotSerialized) { Return (0xF) } } ... } }</span></span></code> </pre><br>  Untuk memahami kode ini secara terperinci, Anda harus membiasakan diri dengan sintaks ASL dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi ACPI</a> . <br><br>  Namun singkatnya, kode ini menciptakan perangkat dengan pengenal "INT33C7" yang memiliki 2 sumber daya: <br><br><pre> <code class="hljs mel">I/O <span class="hljs-keyword"><span class="hljs-keyword">memory</span></span>: <span class="hljs-number"><span class="hljs-number">1400</span></span><span class="hljs-number"><span class="hljs-number">-17</span></span>ff; IRQ: <span class="hljs-number"><span class="hljs-number">14</span></span>;</code> </pre> <br>  Di dalam fungsi .probe Linux, driver menerima sumber daya perangkat di atas sebagai berikut: <br><br><pre> <code class="cpp hljs">io_rc = platform_get_resource(pdev, IORESOURCE_IO, <span class="hljs-number"><span class="hljs-number">0</span></span>); irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Berdasarkan data ini, kode driver akan mengisi struktur gpio_chip dan mendaftarkan pengendali gpio dalam sistem, yang akan membuatnya dapat diakses melalui antarmuka sysfs. <br><br>  Setelah mengembalikan kode ASL perangkat dan mengkompilasi ulang citra BIOS, sistem berhasil mengakses GPIO melalui sysfs. <br><br>  Untuk memulai, folder "gpiochip162" muncul di / sys / class / gpio.  Folder ini berisi file "base" dan "ngpio".  File dasar bertanggung jawab untuk jumlah GPIO pertama dari kontroler ini, ngpio untuk nomor mereka. <br><br><pre> <code class="bash hljs">$ cat /sys/class/gpio/gpiochip162/base 162 $ cat /sys/class/gpio/gpiochip162/ngpio 94</code> </pre> <br>  Dengan demikian, semuanya diekspor sebagaimana mestinya.  Kami menjalankan skrip: <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {162..255}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$i</span></span> &gt; /sys/class/gpio/<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Setelah itu, subfolder gpioN akan muncul di folder / sys / class / gpio /, di dalamnya akan terdapat file untuk mengontrol status baris. <br><br>  Beberapa komentar: <br><br><ul><li>  Folder / sys / class / gpio162 / bertanggung jawab untuk mengelola GPIO0, folder / sys / class / gpio163 / folder bertanggung jawab atas GPIO1  Pergeseran ini terjadi karena fakta bahwa driver selama inisialisasi struktur kontrol "struct gpio_chip" ditugaskan "gc-&gt; base = -1;".  Yaitu, saya meninggalkan kernel untuk memilih angka sendiri.  Ini umumnya tidak kritis, tetapi perlu diingat tentang hal itu. </li><li>  Akses diberikan hanya ke jalur GPIO yang dikonfigurasi sebagai GPIO, dan bukan sebagai fitur Southbridge asli.  Untuk jalur seperti itu, driver menampilkan informasi dalam dmesg: "gpio% d dicadangkan untuk ACPI".  Dalam kasus coreboot, GPIO dikonfigurasi dalam file "gpio.h" di folder dengan motherboard. </li><li>  Perangkat dan driver juga dapat dipetakan menggunakan metode _CID (Compatible ID), dan dokumentasi untuk topik kami di kernel disajikan dalam dokumen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">‚Äúenumerasi perangkat berbasis ACPI‚Äù</a> </li></ul><br>  Perlu dicatat bahwa perangkat INT33C7 tidak memiliki 2 motherboard berpemilik pada chipset yang sama dalam tabel ACPI (dari IBASE dan DFI).  Benar, ada kemungkinan garis GPIO tidak keluaran (saya tidak melihat dokumentasi pada saat itu secara rinci). <br><br><h3>  Identifier "INT33C7" </h3><br>  Setelah meningkatkan fungsionalitas sysfs, saya punya pertanyaan, dari mana nomor identifikasi "INT33C7" berasal? <br><br>  Setelah melihat dokumentasi untuk metode _HID, menjadi jelas bahwa itu layak dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br><br><div class="spoiler">  <b class="spoiler_title">_HID (ID Perangkat Keras)</b> <div class="spoiler_text">  <b>_HID (ID Perangkat Keras)</b> <br>  Objek ini digunakan untuk memasok OSPM dengan ID PNP perangkat atau ID ACPI * <br>  Saat mendeskripsikan platform, penggunaan objek _HID apa pun adalah opsional.  Namun, objek _HID harus <br>  digunakan untuk menggambarkan perangkat apa pun yang akan disebutkan oleh OSPM.  OSPM hanya menyebutkan perangkat <br>  ketika tidak ada enumerator bus yang dapat mendeteksi ID perangkat.  Misalnya, perangkat pada bus ISA <br>  disebutkan oleh OSPM.  Gunakan objek _ADR untuk menggambarkan perangkat yang disebutkan oleh enumerator bus <br>  selain OSPM. <br><br>  <b>Argumen:</b> <br>  Tidak ada <br><br>  <b>Nilai Pengembalian:</b> <br>  Integer atau String yang berisi HID <br>  Objek _HID mengevaluasi baik ID jenis EISA numerik terkompresi 32-bit atau string.  Jika a <br>  string, format harus berupa PNP alfanumerik atau ACPI ID tanpa tanda bintang atau terkemuka lainnya <br>  karakter. <br><br>  ID PNP yang valid harus dalam bentuk "AAA ####" di mana A adalah huruf besar dan # adalah hex <br>  digit.  ID ACPI yang valid harus dalam bentuk "NNNN ####" di mana N adalah huruf besar atau <br>  digit ('0' - '9') dan # adalah digit hex.  Spesifikasi ini mencadangkan string "ACPI" hanya untuk digunakan <br>  dengan daftar perangkat yang ditentukan.  Selanjutnya cadangan semua string yang mewakili 4 digit HEX untuk <br>  penggunaan eksklusif dengan ID Vendor yang ditetapkan PCI. <br><br>  * -PPN ID dan ACPI ID Registry ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.uefi.org/PNP_ACPI_Registry</a> <br></div></div><br>  Ada 3 poin di tautan ini: <br><br><ul><li>  semua jenis pengidentifikasi 3 huruf (PNP ID) ditunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </li><li>  ID PNP dimulai dengan "PNP" yang disediakan oleh Microsoft ditunjukkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br></li><li>  semua jenis pengidentifikasi 4 huruf (ACPI ID) ditunjukkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </li></ul><br>  Tidak terlalu jelas mengapa, tetapi dari daftar ID PNP Anda dapat menemukan bahwa pengidentifikasi ‚ÄúINT‚Äù dicadangkan di INTERPHASE CORPORATION: <br><br><pre> <code class="hljs pgsql">INTERPHASE CORPORATION <span class="hljs-type"><span class="hljs-type">INT</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>/<span class="hljs-number"><span class="hljs-number">29</span></span>/<span class="hljs-number"><span class="hljs-number">1996</span></span></code> </pre> <br>  Rupanya, satu daftar pengidentifikasi perangkat lengkap (bagian huruf + digital) tidak dipublikasikan.  Tetapi dengan bantuan Google adalah mungkin untuk menemukan daftar perangkat dan _HID mereka misalnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau di <a href="">sini</a> . <br><br>  Mereka mengindikasikan: <br><br><pre> <code class="hljs pgsql">INT33C7=Intel <span class="hljs-type"><span class="hljs-type">Serial</span></span> I/O GPIO Host Controller</code> </pre> <br>  Dan dilihat dari sisa baris dari daftar ini, semua perangkat INTxxxx adalah perangkat Intel (sekarang kedengarannya cukup jelas, tetapi koneksi dengan INTERPHASE CORPORATION masih belum jelas; itu juga tidak terlalu jelas mengapa penomoran dimulai dengan jumlah yang begitu besar, tetapi terlihat pada Kebijaksanaan Intel). <br><br><h3>  Driver komunikasi dan perangkat di Windows </h3><br>  Setelah memuaskan rasa ingin tahu saya, saya memutuskan untuk mengunduh Windows di papan tulis saya.  Seperti yang diharapkan, sistem tidak dapat menemukan driver untuk perangkat.  Tidak ada bantuan dari driver untuk papan IBASE dan DFI, yang dapat dimengerti, karena di BIOS papan ini perangkat ini tidak ditunjukkan. <br><br>  Saya berhasil menemukan driver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web Microsoft</a> <br><br>  Namun, di sana driver ini hanya disajikan untuk Windows 8.1 dan lebih tinggi.  Saya masih bekerja dengan Windows 7. <br><br>  Namun demikian, saya mencoba mengunduh salah satu driver dan menentukan foldernya ketika mencari driver untuk perangkat saya yang tidak dikenal. <br><br>  Namun, operator tidak dapat memetakan driver ke perangkat.  Meskipun file inf jelas berisi informasi tentang perangkat INT33C7. <br><br><pre> <code class="hljs mel">[Manufacturer] %INTEL%=Intel,NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> [Intel.NTamd64<span class="hljs-number"><span class="hljs-number">.6</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>] %iaLPSS_GPIO.DeviceDesc_LPT%=iaLPSS_GPIO_Device, ACPI\INT33C7 %iaLPSS_GPIO.DeviceDesc_WPT%=iaLPSS_GPIO_Device, ACPI\INT3437</code> </pre> <br>  Dalam proses penguraian file INF, ternyata bagian [Pabrikan] dengan jelas menunjukkan bahwa itu tidak dimaksudkan untuk sistem saya: <br><br>  Apa yang dimaksud Intel.NTamd64.6.3 dapat dipahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari deskripsi</a> : <br><br><pre> <code class="hljs powershell">nt[<span class="hljs-type"><span class="hljs-type">Architecture</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>][<span class="hljs-type"><span class="hljs-type">.</span></span>[<span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>] <span class="hljs-type"><span class="hljs-type">OSMajorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span>/<span class="hljs-type"><span class="hljs-type">...</span></span> <span class="hljs-type"><span class="hljs-type">OSMinorVersion</span></span>=<span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-number"><span class="hljs-number">8.1</span></span>/<span class="hljs-type"><span class="hljs-type">Windows</span></span> <span class="hljs-type"><span class="hljs-type">Server</span></span> <span class="hljs-number"><span class="hljs-number">2012</span></span> <span class="hljs-type"><span class="hljs-type">R2</span></span></code> </pre> <br>  Mencoba untuk mendorong driver Windows 7 dengan mengganti Intel.NTamd64.6.3 dengan Intel.NTamd64.6.1, untuk membuatnya lebih ringan, gagal, karena memberi saya layar biru kematian dan OS yang tidak dapat di-boot, jadi saya harus melakukan pemulihan. <br><br>  Driver untuk Win7 hanya ditemukan di situs web yang tidak dapat dipahami di Internet, dan kemudian setelah itu perangkat di manajer perangkat ditampilkan dengan tanda seru. <br><br>  Menyadari ketidakberdayaannya, saya memutuskan untuk menguji fungsionalitas pada Windows 10. Ada kejutan yang menyenangkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perangkat Lunak Intel Chipset Device (INF Update Utility)</a> menginstal driver untuk controller saya tanpa masalah. <br><br><img src="https://habrastorage.org/webt/xb/28/jq/xb28jqet9w3tieq0atau1f2aoum.png"><br><br>  Seperti yang Anda lihat, perangkat ini memiliki sumber daya yang ditunjukkan oleh kami. <br><br><img src="https://habrastorage.org/webt/2o/fs/p0/2ofsp055fsxm4smnghgxc3eye8u.png"><br><br>  Secara teori, setelah menginstal driver dengan pengontrol GPIO, kemungkinan besar akan memungkinkan untuk bekerja melalui fungsi IOCTL ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti dalam dokumen ini)</a> . <br><br>  Namun, tidak ada tugas pemrograman GPIO dari Windows, jadi pencarian dokumen yang sama untuk chipset saya ditunda. <br><br><hr><br><h3>  Kesimpulan: </h3><br>  Artikel ini memeriksa koneksi antara driver dan perangkat menggunakan metode _HID ACPI.  Komunikasi semacam itu mungkin diperlukan pada sistem x86 untuk perangkat yang tidak dapat disebutkan. <br><br><ul><li>  Dalam hal Linux, komunikasi dengan driver adalah via .acpi_match_table </li><li>  Dalam kasus Windows, komunikasi dengan pengemudi adalah melalui file INF </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429336/">https://habr.com/ru/post/id429336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429322/index.html">nanoCAD Mechanics 9.0: dasar-dasar desain modern</a></li>
<li><a href="../id429324/index.html">Unreal Engine 4.21 Release</a></li>
<li><a href="../id429326/index.html">App Store tidak akan menelepon. Atau bagaimana saya membuat aplikasi saya, tetapi itu tidak akan menjangkau pengguna</a></li>
<li><a href="../id429328/index.html">Modul perangkat lunak untuk mendigitalkan dokumen yang rusak</a></li>
<li><a href="../id429330/index.html">Mitos dan legenda Agile - dari Firaun hingga saat ini</a></li>
<li><a href="../id429338/index.html">Penyimpanan Android: Internal, Eksternal, Dapat Dilepas. Bagian 1/3</a></li>
<li><a href="../id429340/index.html">Berpikir dua kali sebelum menggunakan Helm.</a></li>
<li><a href="../id429342/index.html">Angular 6+ adalah panduan injeksi ketergantungan lengkap. penyedia yang disediakan vs vs: []</a></li>
<li><a href="../id429344/index.html">Membaca Akhir Pekan: Sumber Daya Tuning Audio dan Desain Speaker</a></li>
<li><a href="../id429346/index.html">Untuk program master tanpa ujian: arah baru "Big Data" di Olimpiade "I am a Professional"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>