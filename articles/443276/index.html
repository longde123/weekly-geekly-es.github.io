<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèº üìã üêøÔ∏è Programador de consultas sorpresa en la base de datos PostgreSQL üê∞ üôçüèæ üòÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gr√°ficos, informes y an√°lisis: todo esto est√° de alguna manera presente en el back-office de cualquier empresa, incluso muy peque√±a. Cuando se llena e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programador de consultas sorpresa en la base de datos PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/okko/blog/443276/">  Gr√°ficos, informes y an√°lisis: todo esto est√° de alguna manera presente en el back-office de cualquier empresa, incluso muy peque√±a.  Cuando se llena en tablas regulares en Excel / Numbers / Libre, pero los datos a√∫n no son muy grandes, las soluciones tradicionales para las necesidades internas de la empresa a menudo se crean utilizando bases de datos relacionales como PostgreSQL, MySQL o MariaDB. <br><br>  Estas bases de datos son gratuitas, gracias a SQL pueden integrarse convenientemente con otros componentes del sistema, son populares y la mayor√≠a de los desarrolladores y analistas pueden trabajar con ellas.  Pueden digerir la carga (tr√°fico y vol√∫menes) lo suficientemente voluminosa como para aguantar con calma hasta que la empresa pueda permitirse soluciones m√°s complejas (y costosas) para an√°lisis e informes. <br><a name="habracut"></a><br><h4>  Posici√≥n inicial </h4><br>  Sin embargo, incluso en una tecnolog√≠a que se ha estudiado repetidamente, siempre hay diferentes matices que pueden aumentar repentinamente las preocupaciones de los ingenieros.  Adem√°s de la confiabilidad, el problema m√°s mencionado con las bases de datos es su rendimiento.  Obviamente, con un aumento en la cantidad de datos, la tasa de respuesta de DB disminuye, pero si esto ocurre de manera predecible y es consistente con el aumento de la carga, entonces esto no es tan malo.  Siempre puede ver de antemano cuando la base de datos comienza a exigir atenci√≥n y planificar una actualizaci√≥n o transici√≥n a una base de datos fundamentalmente diferente.  Mucho peor si el rendimiento de la base de datos se degrada de manera impredecible. <br><br>  El tema de mejorar el rendimiento de la base de datos es tan antiguo como el mundo y muy extenso, y en este art√≠culo me gustar√≠a centrarme en una sola direcci√≥n.  Es decir, al evaluar la efectividad de los planes de consulta en una base de datos PostgreSQL, as√≠ como al cambiar esta eficiencia con el tiempo para hacer que el comportamiento del planificador de la base de datos sea m√°s predecible. <br><br>  A pesar del hecho de que muchas de las cosas que se discutir√°n son aplicables a todas las versiones recientes de esta base de datos, los ejemplos a continuaci√≥n significan la versi√≥n 11.2, la √∫ltima en este momento. <br>  Antes de profundizar en los detalles, tiene sentido desviarnos y decir algunas palabras acerca de d√≥nde pueden surgir los problemas de rendimiento en las bases de datos relacionales.  ¬øCon qu√© est√° ocupada exactamente la base de datos cuando se "ralentiza"?  Falta de memoria (un gran n√∫mero de accesos de disco o red), un procesador d√©bil, todos estos son problemas obvios con soluciones claras, pero ¬øqu√© m√°s puede afectar la velocidad de ejecuci√≥n de la consulta? <br><br><h4>  Refrescar recuerdos </h4><br>  Para que la base de datos responda a la consulta SQL, necesita construir un plan de consulta (en qu√© tablas y columnas ver qu√© √≠ndices se necesitan, qu√© elegir de all√≠, con qu√© comparar, cu√°nta memoria se requiere, etc.).  Este plan se forma en forma de √°rbol, cuyos nodos son solo algunas operaciones t√≠picas, con diferente complejidad computacional.  Aqu√≠ hay algunos de ellos, por ejemplo (N es el n√∫mero de l√≠neas con las que realizar la operaci√≥n): <br><br><table><thead><tr><th>  <nobr>Operaci√≥n</nobr> </th><th>  Que se hace </th><th>  Costo </th></tr></thead><tbody><tr><td colspan="3">  <i><font color="#999">SELECCIONE ... DONDE ... operaciones de recuperaci√≥n de datos</font></i> </td></tr><tr><td>  <nobr>Exploraci√≥n secuencial</nobr> </td><td>  Cargamos cada fila de la tabla y verificamos la condici√≥n. </td><td>  O (N) </td></tr><tr><td>  <nobr>Exploraci√≥n de √≠ndice</nobr> <br>  (√≠ndice b-tree) </td><td>  Los datos est√°n directamente en el √≠ndice, por lo que buscamos por condici√≥n los elementos necesarios del √≠ndice y tomamos los datos desde all√≠. </td><td>  O (log (N)), busca un elemento en un √°rbol ordenado. </td></tr><tr><td>  <nobr>Exploraci√≥n de √≠ndice</nobr> <br>  (√≠ndice hash) </td><td>  Los datos est√°n directamente en el √≠ndice, por lo que buscamos por condici√≥n los elementos necesarios del √≠ndice y tomamos los datos desde all√≠. </td><td>  O (1), buscando un elemento en una tabla hash, excluyendo el costo de crear hashes </td></tr><tr><td>  An√°lisis de mont√≥n de mapa de bits </td><td>  Seleccionamos los n√∫meros de las l√≠neas necesarias por √≠ndice, luego cargamos solo las l√≠neas necesarias y realizamos verificaciones adicionales con ellas. </td><td>  Escaneo de √≠ndice + Escaneo de secuencia (M), <br>  Donde M es el n√∫mero de filas encontradas despu√©s de la exploraci√≥n de √≠ndice.  Se supone que M &lt;&lt; N, es decir  index es m√°s √∫til que Seq Scan. </td></tr><tr><td colspan="3">  <i><font color="#999">Operaciones de uni√≥n (UNIRSE, SELECCIONAR desde varias tablas)</font></i> </td></tr><tr><td>  Bucle anidado </td><td>  Para cada fila de la tabla izquierda, busque una fila adecuada en la tabla derecha. </td><td>  O (N2). <br>  Pero si una de las tablas es mucho m√°s peque√±a que la otra (diccionario) y pr√°cticamente no crece con el tiempo, entonces el costo real puede disminuir a O (N). </td></tr><tr><td>  Hash unirse </td><td>  Para cada fila de las tablas izquierda y derecha, consideramos el hash, que reduce el n√∫mero de b√∫squedas de posibles opciones de conexi√≥n. </td><td>  O (N), pero en el caso de una funci√≥n hash muy ineficiente o un gran n√∫mero de campos id√©nticos para la conexi√≥n, puede haber O (N <sup>2</sup> ) </td></tr><tr><td>  Fusionar unirse </td><td>  Por condici√≥n, clasificamos las tablas izquierda y derecha, despu√©s de lo cual combinamos las dos listas ordenadas </td><td>  O (N * log (N)) <br>  Ordenando costos + revisando la lista. </td></tr><tr><td colspan="3">  <i><font color="#999">Operaciones de agregaci√≥n (GROUP BY, DISTINCT)</font></i> </td></tr><tr><td>  Grupo agregado </td><td>  Ordenamos la tabla de acuerdo con la condici√≥n de agregaci√≥n y luego en la lista ordenada agrupamos las filas adyacentes. </td><td>  O (N * log (N)) </td></tr><tr><td>  Agregado de hash </td><td>  Consideramos el hash para la condici√≥n de agregaci√≥n de cada fila.  Para las filas con el mismo hash, realizamos la agregaci√≥n. </td><td>  O (N) </td></tr></tbody></table><br>  Como puede ver, el costo de una consulta depende en gran medida de c√≥mo se ubican los datos en las tablas y de c√≥mo este orden corresponde a las operaciones hash utilizadas.  Nested Loop, a pesar de su costo en O (N <sup>2</sup> ), puede ser m√°s rentable que Hash Join o Merge Join cuando una de las tablas unidas degenera en una o varias filas. <br><br>  Adem√°s de los recursos de la CPU, el costo tambi√©n incluye el uso de memoria.  Ambos son recursos limitados, por lo que el planificador de consultas debe encontrar un compromiso.  Si dos tablas son matem√°ticamente m√°s rentables para conectarse a trav√©s de Hash Join, pero simplemente no hay espacio para una tabla hash tan grande en la memoria, la base de datos puede verse obligada a usar Merge Join, por ejemplo.  Un bucle anidado "lento" generalmente no requiere memoria adicional y est√° listo para producir resultados justo despu√©s del lanzamiento. <br><br>  El costo relativo de estas operaciones se muestra m√°s claramente en el gr√°fico.  Estos no son n√∫meros absolutos, solo una relaci√≥n aproximada de diferentes operaciones. <br><br><img src="https://habrastorage.org/webt/9f/p_/mx/9fp_mx7mhhd5kgokxbqeu-kxpfa.png"><br><br>  La tabla de bucles anidados "comienza" a continuaci√≥n, porque  no requiere c√°lculos adicionales o asignaci√≥n de memoria o copia de datos intermedios, pero tiene un costo de O (N <sup>2</sup> ).  Merge Join y Hash Join tienen costos iniciales m√°s altos, sin embargo, despu√©s de algunos valores de N, comienzan a vencer a Nested Loop a tiempo.  El planificador intenta elegir el plan con el costo m√°s bajo y en el cuadro anterior se adhiere a diferentes operaciones con diferentes N (flecha verde discontinua).  Con el n√∫mero de l√≠neas hasta N1, es m√°s rentable usar Nested Loop, de N1 a N2 es m√°s rentable Fusionar combinaci√≥n, luego despu√©s de N2 se vuelve m√°s rentable Hash Join, sin embargo, Hash Join requiere memoria para crear tablas hash.  Y al llegar a N3, esta memoria se vuelve insuficiente, lo que conduce al uso forzado de Merge Join. <br><br>  Al elegir un plan, el planificador estima el costo de cada operaci√≥n en el plan utilizando un conjunto de costos relativos de algunas operaciones "at√≥micas" en la base de datos.  Como, por ejemplo, c√°lculos, comparaciones, cargar una p√°gina en la memoria, etc.  Aqu√≠ hay una lista de algunos de estos par√°metros de la configuraci√≥n predeterminada, no hay muchos de ellos: <br><br><table><thead><tr><th>  Costo relativo constante </th><th>  Valor por defecto </th></tr></thead><tbody><tr><td>  seq_page_cost </td><td>  1.0 </td></tr><tr><td>  random_page_cost </td><td>  4.0 4.0 </td></tr><tr><td>  cpu_tuple_cost </td><td>  0,01 </td></tr><tr><td>  cpu_index_tuple_cost </td><td>  0.005 </td></tr><tr><td>  cpu_operator_cost </td><td>  0.0025 </td></tr><tr><td>  paralela_tupla_cost </td><td>  0.1 </td></tr><tr><td>  paralelo_setup_cost </td><td>  1000,0 </td></tr></tbody></table><br>  Es cierto que estas constantes son pocas, a√∫n necesita saber la misma "N", es decir, exactamente cu√°ntas filas de los resultados anteriores tendr√°n que procesarse en cada operaci√≥n.  El l√≠mite superior es obvio aqu√≠: la base de datos "sabe" cu√°ntos datos hay en cualquier tabla y siempre puede calcular "al m√°ximo".  Por ejemplo, si tiene dos tablas de 100 filas cada una, unirlas puede producir de 0 a 10,000 filas en la salida.  En consecuencia, la siguiente operaci√≥n de entrada puede tener hasta 10.000 l√≠neas. <br><br>  Pero si conoce al menos un poco sobre la naturaleza de los datos en las tablas, este n√∫mero de filas se puede predecir con mayor precisi√≥n.  Por ejemplo, para dos tablas de 100 filas del ejemplo anterior, si sabe de antemano que la uni√≥n no producir√° 10 mil filas, pero las mismas 100, el costo estimado de la pr√≥xima operaci√≥n se reduce considerablemente.  En este caso, este plan podr√≠a ser m√°s efectivo que otros. <br><br><h4>  Optimizaci√≥n lista para usar </h4><br>  Para que el planificador pueda predecir con mayor precisi√≥n el tama√±o de los resultados intermedios, PostgreSQL utiliza la recopilaci√≥n de estad√≠sticas en tablas, que se acumula en pg_statistic, o en su versi√≥n m√°s legible, en pg_stats.  Se actualiza autom√°ticamente cuando se inicia el vac√≠o, o expl√≠citamente con el comando ANALIZAR.  Esta tabla almacena una variedad de informaci√≥n sobre qu√© datos y qu√© tipo de naturaleza hay en las tablas.  En particular, histogramas de valores, porcentaje de campos vac√≠os y otra informaci√≥n.  El planificador utiliza todo esto para predecir con mayor precisi√≥n la cantidad de datos para cada operaci√≥n en el √°rbol del plan y, por lo tanto, calcular con mayor precisi√≥n el costo de las operaciones y el plan en su conjunto. <br><br>  Tome por ejemplo la consulta: <br><pre><code class="plaintext hljs">SELECT t1.important_value FROM t1 WHERE t1.a &gt; 100</code> </pre> <br><br>  Suponga que el histograma de los valores en la columna "t1.a" revel√≥ que valores superiores a 100 se encuentran en aproximadamente el 1% de las filas de la tabla.  Entonces podemos predecir que dicha muestra devolver√° aproximadamente una cent√©sima parte de todas las filas de la tabla "t1". <br>  La base de datos le brinda la oportunidad de ver el costo previsto del plan a trav√©s del comando EXPLICAR y el tiempo real de su operaci√≥n, utilizando EXPLAIN ANALYZE. <br><br>  Parece que con las estad√≠sticas autom√°ticas todo deber√≠a estar bien ahora, pero puede haber dificultades.  Hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">buen art√≠culo</a> sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Citus Data</a> , con un ejemplo de la ineficiencia de las estad√≠sticas autom√°ticas y la recopilaci√≥n de estad√≠sticas adicionales usando CREATE STATISTICS (disponible con PG 10.0). <br><br>  Entonces, para el planificador, hay dos fuentes de errores en el c√°lculo de costos: <br><br><ol><li>  El costo relativo de las operaciones primitivas (seq_page_cost, cpu_operator_cost, etc.) de manera predeterminada puede ser muy diferente de la realidad (costo de la CPU 0.01, costo de carga de la p√°gina srq - 1 o 4 para carga de p√°gina aleatoria).  Lejos del hecho de que 100 comparaciones equivalen a 1 carga de p√°gina. </li><li>  Error al predecir el n√∫mero de filas en operaciones intermedias.  El costo real de la operaci√≥n en este caso puede ser muy diferente del pron√≥stico. </li></ol><br>  En consultas complejas, elaborar y pronosticar todos los planes posibles puede llevar mucho tiempo por s√≠ solo.  ¬øDe qu√© sirve devolver datos en 1 segundo si la base de datos solo estaba planeando una solicitud de un minuto?  PostgreSQL tiene un optimizador Geqo para esta situaci√≥n, es un programador que no crea todas las opciones posibles para los planes, pero comienza con algunas al azar y completa las mejores, prediciendo formas de reducir costos.  Todo esto tampoco mejora la precisi√≥n del pron√≥stico, aunque acelera la b√∫squeda de al menos un plan m√°s o menos √≥ptimo. <br><br><h4>  Planes repentinos - competidores </h4><br>  Si todo va bien, su solicitud se cumple lo m√°s r√°pido posible.  A medida que aumenta la cantidad de datos, la velocidad de ejecuci√≥n de la consulta en la base de datos aumenta gradualmente y, despu√©s de un tiempo, observ√°ndola, puede predecir aproximadamente cu√°ndo ser√° necesario aumentar la memoria o la cantidad de n√∫cleos de CPU o expandir el cl√∫ster, etc. <br><br>  Pero debemos tener en cuenta el hecho de que el plan √≥ptimo tiene competidores con costos de ejecuci√≥n cercanos, lo que no vemos.  Y si la base de datos cambia repentinamente el plan de consulta a otro, esto es una sorpresa.  Es bueno que la base de datos salte a un plan m√°s eficiente.  Y si no?  Veamos la imagen, por ejemplo.  Este es el costo previsto y el tiempo real de la implementaci√≥n de dos planes (rojo y verde): <br><br><img src="https://habrastorage.org/webt/an/0e/t1/an0et1smgdhh60caqa4yltzgiu4.png"><br><br>  Aqu√≠, un plan se muestra en verde y su "competidor" m√°s cercano en rojo.  La l√≠nea punteada muestra un gr√°fico de los costos proyectados, la l√≠nea continua es el tiempo real.  La flecha gris discontinua muestra la selecci√≥n del planificador. <br><br>  Suponga que un buen viernes por la noche el n√∫mero previsto de filas en alguna operaci√≥n intermedia alcanza N1 y el pron√≥stico "rojo" comienza a superar al "verde".  El planificador comienza a usarlo.  El tiempo real de ejecuci√≥n de la consulta salta inmediatamente (cambiando de una l√≠nea s√≥lida verde a una roja), es decir, el programa de degradaci√≥n de la base de datos toma la forma de un paso (o tal vez un "muro").  En la pr√°ctica, este "muro" puede aumentar el tiempo de ejecuci√≥n de la consulta en un orden de magnitud o m√°s. <br><br>  Vale la pena se√±alar que esta situaci√≥n es probablemente m√°s t√≠pica para el back office y el an√°lisis que para el front end, ya que este √∫ltimo generalmente se adapta a consultas m√°s simult√°neas y, por lo tanto, utiliza consultas m√°s simples en la base de datos, donde el error en los pron√≥sticos del plan es menor.  Si se trata de una base de datos para informes o an√°lisis, las consultas pueden ser arbitrariamente complejas. <br><br><h4>  ¬øC√≥mo vivir con eso? </h4><br>  Surge la pregunta: ¬øera posible de alguna manera prever tales planes invisibles "bajo el agua"?  Despu√©s de todo, el problema no es que no sean √≥ptimos, sino que el cambio a otro plan puede ocurrir de manera impredecible y, seg√∫n la ley de la mezquindad, en el momento m√°s desafortunado para esto. <br><br>  Desafortunadamente, no puede verlos directamente, pero puede buscar planes alternativos cambiando los pesos reales por los que se seleccionan.  El significado de este enfoque es eliminar de la vista el plan actual, que el planificador considera √≥ptimo, para que uno de sus competidores m√°s cercanos se vuelva √≥ptimo y, por lo tanto, pueda ser visto a trav√©s del equipo EXPLAIN.  Revisando peri√≥dicamente los cambios en los costos en tales "competidores" y en el plan principal, puede evaluar la probabilidad de que la base de datos pronto "salte" a otro plan. <br><br>  Adem√°s de recopilar datos sobre pron√≥sticos de planes alternativos, puede ejecutarlos y medir su rendimiento, lo que tambi√©n da una idea del "bienestar" interno de la base de datos. <br>  Veamos qu√© herramientas tenemos para tales experimentos. <br><br>  Primero, puede "prohibir" expl√≠citamente operaciones espec√≠ficas utilizando variables de sesi√≥n.  Convenientemente, no es necesario cambiarlos en la configuraci√≥n y volver a cargar la base de datos, su valor cambia solo en la sesi√≥n abierta actual y no afecta a otras sesiones, por lo que puede experimentar directamente con datos reales.  Aqu√≠ hay una lista de ellos con valores predeterminados.  Casi todas las operaciones est√°n incluidas: <br><table><thead><tr><th>  Operaciones utilizadas </th><th>  Valor por defecto </th></tr></thead><tbody><tr><td>  enable_bitmapscan <br>  enable_hashagg <br>  enable_hashjoin <br>  enable_indexscan <br>  enable_indexonlyscan <br>  enable_material <br>  enable_mergejoin <br>  enable_nestloop <br>  enable_parallel_append <br>  enable_seqscan <br>  enable_sort <br>  enable_tidscan <br>  enable_parallel_hash <br>  enable_partition_pruning </td><td>  en </td></tr><tr><td>  enable_partitionwise_join <br>  enable_partitionwise_aggregate </td><td>  fuera </td></tr></tbody></table><br>  Al prohibir o permitir ciertas operaciones, forzamos al planificador a seleccionar otros planes que podamos ver con el mismo comando EXPLAIN.  De hecho, la "prohibici√≥n" de las operaciones no proh√≠be su uso, sino que simplemente aumenta enormemente su costo.  En PostgreSQL, cada operaci√≥n "prohibida" acumula autom√°ticamente un costo igual a 10 mil millones de unidades convencionales.  Adem√°s, en EXPLICAR, el peso total del plan puede resultar prohibitivamente alto, pero en el contexto de estas decenas de miles de millones, el peso de las operaciones restantes es claramente visible, ya que generalmente se ajusta a pedidos m√°s peque√±os. <br><br>  De particular inter√©s son dos de las siguientes operaciones: <br><br><ul><li>  <strong>Hash Join.</strong>  Su complejidad es O (N), pero con un error con un pron√≥stico en la cantidad del resultado, no puede caber en la memoria y tendr√° que hacer Merge Join, con un costo de O (N * log (N)). </li><li>  <strong>Bucle anidado.</strong>  Su complejidad es O (N <sup>2</sup> ), por lo tanto, el error en el pron√≥stico del tama√±o afecta de manera cuadr√°tica la velocidad de dicha conexi√≥n. </li></ul><br>  Por ejemplo, tomemos algunos n√∫meros reales de las consultas, cuya optimizaci√≥n est√°bamos involucrados en nuestra empresa. <br><br>  <strong><u>Plan 1.</u></strong> Con todas las operaciones permitidas, el costo total del plan m√°s √≥ptimo fue de 274962.09 unidades. <br><br>  <strong><u>Plan 2.</u></strong> Con el bucle anidado "prohibido", el costo aument√≥ a 40000534153.85.  A pesar de la prohibici√≥n, estos 40 mil millones que representan la mayor parte del costo son 4 veces el Nested Loop utilizado.  Y los 534153.85 restantes: este es precisamente el pron√≥stico del costo de todas las dem√°s operaciones del plan.  Como vemos, es aproximadamente 2 veces m√°s alto que el costo del plan √≥ptimo, es decir, est√° lo suficientemente cerca de √©l. <br><br>  <strong><u>Plan 3.</u></strong> Con la Hash Join "prohibida", el costo fue de 383253.77.  El plan se hizo realmente sin utilizar la operaci√≥n Hash Join, ya que no vemos miles de millones.  Sin embargo, su costo es 30% m√°s alto que el √≥ptimo, que tambi√©n est√° muy cerca. <br><br>  En realidad, los tiempos de ejecuci√≥n de la consulta fueron los siguientes: <br><br>  <strong><u>Plan 1</u></strong> (todas las operaciones permitidas) completado en ~ 9 minutos. <br>  <strong><u>El plan 2</u></strong> (con el bucle anidado "prohibido") se completa en 1,5 segundos. <br>  <strong><u>El plan 3</u></strong> (con una combinaci√≥n de hash "prohibida") se complet√≥ en ~ 5 minutos. <br><br>  La raz√≥n, como puede ver, es la predicci√≥n err√≥nea del costo de Nested Loop.  De hecho, cuando se compara EXPLAIN con EXPLAIN ANALYZE, se detecta un error con la definici√≥n de ese N desafortunado en la operaci√≥n intermedia.  En lugar de una sola fila predicha, el bucle anidado encontr√≥ varios miles de filas, lo que provoc√≥ que el tiempo de ejecuci√≥n de la consulta aumentara en un par de √≥rdenes de magnitud. <br><br>  Los ahorros con la combinaci√≥n de hash "prohibida" se asocian con el reemplazo de hashing con clasificaci√≥n y combinaci√≥n de combinaci√≥n, que funcion√≥ m√°s r√°pido en este caso que la combinaci√≥n de hash.  Tenga en cuenta que este plan 2 en realidad es casi dos veces m√°s r√°pido que el plan "√≥ptimo" 1. Aunque se predijo que ser√° m√°s lento. <br><br>  En la pr√°ctica, si su solicitud de repente (despu√©s de una actualizaci√≥n de la base de datos o solo) comenz√≥ a ejecutarse mucho m√°s tiempo que antes, primero intente negar Hash Join o Nested Loop y vea c√≥mo esto afecta la velocidad de la consulta.  En un caso exitoso, podr√° al menos prohibir un nuevo plan no √≥ptimo y volver al anterior r√°pido. <br><br>  Para hacer esto, no necesita cambiar los archivos de configuraci√≥n de PostgreSQL con un reinicio de la base de datos, es bastante simple en cualquier consola cambiar el valor de la variable deseada para una sesi√≥n abierta desde la base de datos.  Las sesiones restantes no se ver√°n afectadas, la configuraci√≥n cambiar√° solo para su sesi√≥n actual.  Por ejemplo, as√≠: <br><br><pre> <code class="plaintext hljs">SET enable_hashjoin='on'; SET enable_nestloop='off'; SELECT ‚Ä¶ FROM ‚Ä¶ (    )</code> </pre><br>  La segunda forma de influir en la elecci√≥n del plan es cambiar los pesos de las operaciones de bajo nivel.  No existe una receta universal aqu√≠, pero, por ejemplo, si tiene una base de datos con un cach√© "calentado" y todos los datos se almacenan en la memoria, es probable que el costo de la carga secuencial de p√°ginas no difiera del costo de cargar una p√°gina aleatoria.  Mientras que en la configuraci√≥n predeterminada, aleatorio es 4 veces m√°s costoso que secuencial. <br><br>  O, otro ejemplo, el costo condicional de ejecutar el procesamiento paralelo es 1000 por defecto, mientras que el costo de cargar una p√°gina es 1.0.  Tiene sentido comenzar cambiando solo uno de los par√°metros a la vez para determinar si afecta la elecci√≥n del plan.  Las formas m√°s f√°ciles son comenzar configurando el par√°metro en 0 o en alg√∫n valor alto (1 mill√≥n). <br><br>  Sin embargo, tenga en cuenta que al mejorar el rendimiento en una solicitud, puede degradarlo en otra.  En general, hay un amplio campo para los experimentos.  Es mejor intentar cambiarlos uno a la vez, uno a la vez. <br><br><h4>  Opciones de tratamiento alternativas </h4><br>  Una historia sobre un planificador estar√≠a incompleta sin mencionar al menos dos extensiones de PostgreSQL. <br><br>  El primero es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SR_PLAN</a> , para guardar el plan calculado y forzar su uso posterior.  Esto ayuda a hacer que el comportamiento de la base de datos sea m√°s predecible en t√©rminos de opciones de planes. <br><br>  El segundo es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Adaptive Query Optimizer</a> , que implementa retroalimentaci√≥n al planificador desde la ejecuci√≥n en tiempo real de la consulta, es decir, el planificador mide los resultados reales de la consulta ejecutada y ajusta sus planes en el futuro con esto en mente.  Por lo tanto, la base de datos se "autoajusta" para datos y consultas espec√≠ficos. <br><br><h4>  ¬øQu√© m√°s hace la base de datos cuando se ralentiza? </h4><br>  Ahora que hemos ordenado m√°s o menos la planificaci√≥n de la consulta, veamos qu√© m√°s se puede mejorar tanto en la base de datos como en las aplicaciones que la utilizan para obtener el m√°ximo rendimiento. <br><br>  Supongamos que el plan de consulta ya es √≥ptimo.  Si excluimos los problemas m√°s obvios (poca memoria o un disco / red lento), entonces todav√≠a hay costos para calcular los hashes.  Probablemente haya grandes oportunidades para futuras mejoras en PostgreSQL (usando la GPU o incluso las instrucciones SSE2 / SSE3 / AVX de la CPU), pero hasta ahora esto no se ha hecho y los c√°lculos hash apenas utilizan las capacidades de hardware del hardware.  Puedes ayudar un poco en esta base de datos. <br><br>  Si observa, por defecto, los √≠ndices en PostgreSQL se crean como b-tree.  Su utilidad es que son bastante vers√°tiles.  Dicho √≠ndice puede usarse tanto con condiciones de igualdad como con condiciones de comparaci√≥n (m√°s o menos).  Encontrar un art√≠culo en dicho √≠ndice es un costo logar√≠tmico.  Pero si su consulta contiene solo una condici√≥n de igualdad, los √≠ndices tambi√©n se pueden crear como un √≠ndice hash, cuyo costo es constante. <br><br>  Adem√°s, a√∫n puede intentar modificar la solicitud para utilizar su ejecuci√≥n paralela.  Para comprender exactamente c√≥mo reescribirlo, es mejor familiarizarse con la lista de casos en los que el planificador proh√≠be autom√°ticamente el paralelismo y evitar tales situaciones.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El manual</a> sobre este tema describe brevemente todas las situaciones, por lo que no tiene sentido repetirlas aqu√≠. <br><br>  ¬øQu√© hacer si la solicitud a√∫n no es buena para hacer paralelo?  Es muy triste ver c√≥mo en su poderosa base de datos multin√∫cleo, donde usted es el √∫nico cliente, un n√∫cleo est√° 100% ocupado y todos los dem√°s n√∫cleos solo lo miran.  En este caso, debe ayudar a la base de datos desde el lado de la aplicaci√≥n.  Dado que a cada sesi√≥n se le asigna su propio n√∫cleo, puede abrir varias de ellas y dividir la consulta general en partes, haciendo selecciones m√°s cortas y r√°pidas, combin√°ndolas en un resultado com√∫n que ya est√° en la aplicaci√≥n.  Esto ocupar√° los recursos de CPU m√°ximos disponibles en la base de datos PostgreSQL. <br><br>  En conclusi√≥n, me gustar√≠a se√±alar que las opciones de diagn√≥stico y optimizaci√≥n anteriores son solo la punta del iceberg, sin embargo, son bastante f√°ciles de usar y pueden ayudar a identificar r√°pidamente el problema directamente en los datos operativos sin correr el riesgo de estropear la configuraci√≥n o interrumpir el funcionamiento de otras aplicaciones. <br><br>  Consultas exitosas, con planes precisos y cortos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443276/">https://habr.com/ru/post/443276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443266/index.html">C√≥mo ayudamos a transformar el trabajo de contabilidad en una gran empresa energ√©tica</a></li>
<li><a href="../443268/index.html">Post mortem: siga el middleware o c√≥mo rompimos los comentarios</a></li>
<li><a href="../443270/index.html">El anuncio de Sony Xperia 1: un nuevo concepto insignia</a></li>
<li><a href="../443272/index.html">El mito de las plagas de nicromo</a></li>
<li><a href="../443274/index.html">Recopilaci√≥n de noticias de la industria del juego del 8 de marzo al domingo</a></li>
<li><a href="../443278/index.html">Coinbase crypto-exchange est√° perdiendo usuarios debido a la compra de una startup para los creadores de spyware del Hacking Team</a></li>
<li><a href="../443280/index.html">La historia de c√≥mo ensambl√© un cine en casa de 120 pulgadas con tubos, cuerdas, una pantalla plegable y terciopelo negro</a></li>
<li><a href="../443282/index.html">¬øQu√© debemos construir una blockchain?</a></li>
<li><a href="../443284/index.html">√çndices en PostgreSQL - 4 (Btree)</a></li>
<li><a href="../443286/index.html">TDMS Fairway. Mecanismo de autocompletar para las principales inscripciones en los dibujos y detalles de los documentos.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>