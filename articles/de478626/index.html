<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèº üïå üìõ Debuggen der Softwarebereitstellung mit strace üë©üèæ‚Äç‚öñÔ∏è üë©üèº‚Äçüè´ üíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meine Hauptaufgabe ist zum gr√∂√üten Teil die Bereitstellung von Softwaresystemen, das hei√üt, ich verbringe viel Zeit damit, die folgenden Fragen zu bea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Debuggen der Softwarebereitstellung mit strace</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/478626/"><p><img src="https://habrastorage.org/webt/zi/se/d3/zised39h1shd8invmnqtcvxxdgu.jpeg"></p><br><p>  Meine Hauptaufgabe ist zum gr√∂√üten Teil die Bereitstellung von Softwaresystemen, das hei√üt, ich verbringe viel Zeit damit, die folgenden Fragen zu beantworten: </p><br><ul><li>  Diese Software funktioniert f√ºr den Entwickler, aber nicht f√ºr mich.  Warum? </li><li>  Gestern hat diese Software f√ºr mich funktioniert, aber heute nicht.  Warum? </li></ul><br><p>  Dies ist eine Art von Debugging, die sich geringf√ºgig vom regul√§ren Software-Debugging unterscheidet.  Beim normalen Debugging geht es um Codelogik, beim Deployment-Debugging jedoch um die Interaktion von Code und Umgebung.  Auch wenn die Ursache des Problems ein logischer Fehler ist, bedeutet die Tatsache, dass alles auf einer Maschine und nicht auf einer anderen Maschine funktioniert, dass die Angelegenheit irgendwie in der Umgebung liegt. </p><br><p>  Anstelle der √ºblichen Debugging-Tools wie <strong>gdb habe</strong> ich ein anderes Set von Tools zum Debuggen der Bereitstellung.  Und mein Lieblingstool f√ºr ein Problem wie "Warum pfl√ºgt es diese Software nicht?"  genannt <strong>strace</strong> . </p><a name="habracut"></a><br><h3 id="chto-zhe-takoe-strace">  Was ist Strace? </h3><br><p>  <a href="https://strace.io/">strace</a> ist ein Tool zum Verfolgen eines Systemaufrufs.  Urspr√ºnglich unter Linux erstellt, k√∂nnen jedoch dieselben Debugging-Chips mit Tools f√ºr andere Systeme ( <a href="http://dtrace.org/blogs/about/">DTrace</a> oder <a href="https://man.openbsd.org/ktrace">ktrace</a> ) gedreht werden. </p><br><p>  Die Hauptanwendung ist sehr einfach.  Sie m√ºssen nur strace mit einem beliebigen Befehl ausf√ºhren und es werden alle Systemaufrufe an den Dump <strong>gesendet</strong> (obwohl Sie wahrscheinlich zuerst <strong>strace</strong> selbst installieren <strong>m√ºssen</strong> ): </p><br><pre><code class="plaintext hljs">$ strace echo Hello ...Snip lots of stuff... write(1, "Hello\n", 6) = 6 close(1) = 0 close(2) = 0 exit_group(0) = ? +++ exited with 0 +++</code> </pre> <br><p>  Was sind diese Systemaufrufe?  Es ist eine Art API f√ºr den Kern des Betriebssystems.  Es war einmal, als die Software direkten Zugriff auf die Hardware hatte, auf der sie arbeitete.  Wenn Sie beispielsweise etwas auf dem Bildschirm anzeigen m√∂chten, wird es mit Anschl√ºssen und / oder Speicherregistern f√ºr Videoger√§te wiedergegeben.  Als Multitasking-Computersysteme popul√§r wurden, herrschte Chaos, weil verschiedene Anwendungen um Hardware k√§mpften.  Fehler in einer Anwendung k√∂nnen die Arbeit anderer beeintr√§chtigen, wenn nicht des gesamten Systems.  Dann erschienen in der CPU Privileg-Modi (oder "Ring Protection").  Der Kernel wurde zum privilegiertesten: Er erlangte vollen Zugriff auf die Hardware und schuf weniger privilegierte Anwendungen, die bereits Zugriff vom Kernel anfordern mussten, um mit der Hardware zu interagieren - √ºber Systemaufrufe. </p><br><p>  Auf der Bin√§rebene unterscheidet sich ein Systemaufruf geringf√ºgig von einem einfachen Funktionsaufruf, die meisten Programme verwenden jedoch einen Wrapper in der Standardbibliothek.  Das hei√üt  Die POSIX C-Standardbibliothek enth√§lt einen Aufruf der Funktion <strong>write ()</strong> , die den gesamten architekturspezifischen Code f√ºr den Systemaufruf <strong>write</strong> enth√§lt. </p><br><p><img src="https://habrastorage.org/webt/cr/qx/_-/crqx_-ucgqzecn4942nlgmuhaek.png"></p><br><p>  Kurz gesagt, jede Interaktion zwischen der Anwendung und ihrer Umgebung (Computersystemen) erfolgt √ºber Systemaufrufe.  Wenn die Software auf einem Computer und nicht auf einem anderen Computer ausgef√ºhrt wird, ist es daher hilfreich, die Ergebnisse der Verfolgung von Systemaufrufen zu betrachten.  Im Folgenden finden Sie eine Liste typischer Punkte, die mithilfe der Systemaufrufverfolgung analysiert werden k√∂nnen: </p><br><ul><li>  Konsolen-E / A </li><li>  Netzwerk Ein- / Ausgang </li><li>  Dateisystemzugriff und Datei-E / A </li><li>  Prozess- / Thread-Lebensdauermanagement </li><li>  Low Level Memory Management </li><li>  Zugriff auf bestimmte Ger√§tetreiber </li></ul><br><h3 id="kogda-ispolzovat-strace">  Wann Strace verwenden? </h3><br><p>  Theoretisch wird <strong>strace</strong> f√ºr alle Programme im User Space verwendet, da jedes Programm im User Space Systemaufrufe <strong>ausf√ºhren</strong> sollte.  Es funktioniert effizienter mit kompilierten, einfachen Programmen, aber es funktioniert auch mit h√∂heren Sprachen wie Python, wenn Sie das zus√§tzliche Rauschen der Laufzeitumgebung und des Interpreters √ºberwinden k√∂nnen. </p><br><p>  In seiner ganzen Pracht manifestiert sich <strong>strace</strong> beim Debuggen von Software, die auf einem Computer <strong>einwandfrei</strong> funktioniert, und h√∂rt pl√∂tzlich auf, an einem anderen zu arbeiten, und gibt verwaschene Nachrichten √ºber Dateien, Berechtigungen oder erfolglose Versuche, einige Befehle oder etwas auszuf√ºhren ... Es ist schade, aber nicht so gut Es ist mit allgemeinen Problemen wie Zertifikatverifizierungsfehlern verbunden.  Dies erfordert normalerweise eine Kombination aus <strong>strace</strong> , manchmal <a href="https://linux.die.net/man/1/ltrace">ltrace</a> und Tools h√∂herer Ebene (wie das Befehlszeilentool <a href="https://linux.die.net/man/1/ltrace">openssl</a> zum Debuggen eines Zertifikats). </p><br><p>  Wir arbeiten zum Beispiel an einem eigenst√§ndigen Server, die Verfolgung von Systemaufrufen kann jedoch h√§ufig auf komplexeren Bereitstellungsplattformen durchgef√ºhrt werden.  Sie m√ºssen nur das richtige Toolkit ausw√§hlen. </p><br><h3 id="primer-prostoy-otladki">  Einfaches Debugging-Beispiel </h3><br><p>  Nehmen wir an, Sie m√∂chten die gro√üartige foo-Server-Anwendung ausf√ºhren, aber es stellt sich heraus, dass: </p><br><pre> <code class="plaintext hljs">$ foo Error opening configuration file: No such file or directory</code> </pre> <br><p>  Offensichtlich konnte er die von Ihnen geschriebene Konfigurationsdatei nicht finden.  Dies liegt daran, dass Paketmanager beim Kompilieren einer Anwendung manchmal den erwarteten Speicherort der Dateien √ºberschreiben.  Und wenn Sie die Installationsanleitung f√ºr eine Distribution befolgen, finden Sie die Dateien in einer anderen v√∂llig anders, als ich erwartet hatte.  Das Problem kann in wenigen Sekunden behoben werden, wenn in der Fehlermeldung angegeben wird, wo nach der Konfigurationsdatei gesucht werden soll, dies jedoch nicht angegeben wird.  Also, wo soll man suchen? </p><br><p>  Wenn Sie Zugriff auf den Quellcode haben, k√∂nnen Sie ihn lesen und herausfinden.  Ein guter Backup-Plan, aber nicht die schnellste L√∂sung.  Sie k√∂nnen auf einen schrittweisen Debugger wie <strong>gdb</strong> zur√ºckgreifen und sehen, was das Programm tut. Es ist jedoch viel effizienter, ein Tool zu verwenden, das speziell f√ºr die Interaktion mit der Umgebung entwickelt wurde: <strong>strace</strong> . </p><br><p>  Die Schlussfolgerung von <strong>strace</strong> mag √ºberfl√ºssig erscheinen, aber die gute Nachricht ist, dass das meiste davon sicher ignoriert werden kann.  Es ist oft n√ºtzlich, den Operator -o zu verwenden, um Trace-Ergebnisse in einer separaten Datei zu speichern: </p><br><pre> <code class="plaintext hljs">$ strace -o /tmp/trace foo Error opening configuration file: No such file or directory $ cat /tmp/trace execve("foo", ["foo"], 0x7ffce98dc010 /* 16 vars */) = 0 brk(NULL) = 0x56363b3fb000 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory) openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3 fstat(3, {st_mode=S_IFREG|0644, st_size=25186, ...}) = 0 mmap(NULL, 25186, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f2f12cf1000 close(3) = 0 openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3 read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\260A\2\0\0\0\0\0"..., 832) = 832 fstat(3, {st_mode=S_IFREG|0755, st_size=1824496, ...}) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f2f12cef000 mmap(NULL, 1837056, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f2f12b2e000 mprotect(0x7f2f12b50000, 1658880, PROT_NONE) = 0 mmap(0x7f2f12b50000, 1343488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7f2f12b50000 mmap(0x7f2f12c98000, 311296, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x16a000) = 0x7f2f12c98000 mmap(0x7f2f12ce5000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b6000) = 0x7f2f12ce5000 mmap(0x7f2f12ceb000, 14336, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f2f12ceb000 close(3) = 0 arch_prctl(ARCH_SET_FS, 0x7f2f12cf0500) = 0 mprotect(0x7f2f12ce5000, 16384, PROT_READ) = 0 mprotect(0x56363b08b000, 4096, PROT_READ) = 0 mprotect(0x7f2f12d1f000, 4096, PROT_READ) = 0 munmap(0x7f2f12cf1000, 25186) = 0 openat(AT_FDCWD, "/etc/foo/config.json", O_RDONLY) = -1 ENOENT (No such file or directory) dup(2) = 3 fcntl(3, F_GETFL) = 0x2 (flags O_RDWR) brk(NULL) = 0x56363b3fb000 brk(0x56363b41c000) = 0x56363b41c000 fstat(3, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x8), ...}) = 0 write(3, "Error opening configuration file"..., 60) = 60 close(3) = 0 exit_group(1) = ? +++ exited with 1 +++</code> </pre> <br><p>  √úber die gesamte erste Seite der <strong>Strace-</strong> Ausgabe wird in der Regel ein Low-Level-Start vorbereitet.  (Es gibt viele Aufrufe f√ºr <strong>mmap</strong> , <strong>mprotect</strong> und <strong>brk</strong> , z. B. das Erkennen von Arbeitsspeicher auf niedriger Ebene und das Anzeigen dynamischer Bibliotheken.) W√§hrend des Debuggens werden die <strong>strace-</strong> Ausgaben am besten von Anfang an gelesen.  Unten befindet sich ein Aufruf zum <strong>Schreiben</strong> , der eine Fehlermeldung anzeigt.  Wir schauen oben und sehen den ersten fehlerhaften Systemaufruf - einen <strong>openat-</strong> Aufruf, <strong>der</strong> einen <strong>ENOENT-</strong> Fehler ("Datei oder Verzeichnis nicht gefunden") <strong>ausl√∂st</strong> und versucht, <strong>/etc/foo/config.json</strong> zu √∂ffnen.  Hier sollte hier die Konfigurationsdatei liegen. </p><br><p>  Es war nur ein Beispiel, aber ich w√ºrde sagen, dass 90% der Zeit, in der ich <strong>Strace benutze</strong> , nichts viel schwieriger ist und nicht muss.  Nachfolgend finden Sie eine vollst√§ndige schrittweise Anleitung zum Debuggen: </p><br><ul><li>  Frustriert von einer verwaschenen System-Fehlermeldung aus einem Programm </li><li>  <strong>Starten Sie</strong> das Programm mit <strong>strace neu</strong> </li><li>  Finden Sie eine Fehlermeldung in den Trace-Ergebnissen </li><li>  Gehen Sie nach oben, bis Sie auf den ersten fehlgeschlagenen Systemaufruf sto√üen </li></ul><br><p>  Es ist sehr wahrscheinlich, dass der Systemaufruf in Schritt 4 zeigt, was falsch gelaufen ist. </p><br><h3 id="podskazki">  Tipps </h3><br><p>  Bevor ich ein Beispiel f√ºr ein komplexeres Debugging <strong>zeige</strong> , <strong>m√∂chte</strong> ich Ihnen einige Tricks <strong>erl√§utern</strong> , wie Sie <strong>strace</strong> effektiv <strong>einsetzen</strong> k√∂nnen: </p><br><p>  <strong>Mann ist dein Freund</strong> </p><br><p>  Auf vielen * nix-Systemen kann eine vollst√§ndige Liste der Kernel-Systemaufrufe durch Ausf√ºhren von <strong>man-syscalls</strong> abgerufen werden.  Sie werden Dinge wie <strong>brk (2) sehen</strong> , was bedeutet, dass Sie mehr Informationen erhalten k√∂nnen, indem Sie <strong>man 2 brk ausf√ºhren</strong> . </p><br><p>  Ein kleiner Fehler: <strong>man 2 fork</strong> zeigt mir eine Seite f√ºr die <strong>fork () -</strong> Shell in <strong>GNU libc</strong> , die mithilfe des <strong>clone ()</strong> -Aufrufs implementiert wird.  Die Semantik des <strong>Fork-</strong> Aufrufs bleibt gleich, wenn Sie ein Programm schreiben, das <strong>Fork () verwendet</strong> und die Ablaufverfolgung startet - ich finde keine <strong>Fork-</strong> Aufrufe, stattdessen wird es <strong>Clone () geben</strong> .  Solch ein Rechen ist nur verwirrt, wenn Sie damit beginnen, die Quelle mit der Ausgabe von <strong>strace zu vergleichen</strong> . </p><br><p>  <strong>Verwenden Sie -o, um die Ausgabe in einer Datei zu speichern</strong> </p><br><p>  <strong>strace</strong> kann umfangreiche Ausgaben generieren, daher ist es oft n√ºtzlich, Trace-Ergebnisse in separaten Dateien zu speichern (wie im obigen Beispiel).  Und es hilft, die Programmausgabe nicht mit der Ausgabe von <strong>strace</strong> in der Konsole zu verwechseln. </p><br><p>  <strong>Verwenden Sie -s, um weitere Argumentdaten anzuzeigen</strong> </p><br><p>  Sie haben wahrscheinlich bemerkt, dass die zweite H√§lfte der Fehlermeldung im obigen Trace-Beispiel nicht angezeigt wird.  Dies liegt daran, dass <strong>strace standardm√§√üig</strong> nur die ersten 32 Bytes des String-Arguments <strong>anzeigt</strong> .  Wenn Sie mehr sehen m√∂chten, f√ºgen Sie dem <strong>strace-</strong> Aufruf etwas wie <strong>-s 128</strong> <strong>hinzu</strong> . </p><br><p>  <strong>-y erleichtert das Verfolgen von Dateien \ sockets \ und so weiter.</strong> </p><br><p>  "Alles ist eine Datei" bedeutet, dass * nix-Systeme alle E / A-Vorg√§nge mithilfe von Dateideskriptoren ausf√ºhren, unabh√§ngig davon, ob dies f√ºr eine Datei oder ein Netzwerk oder f√ºr die Interprozessierung von Kan√§len gilt.  Dies ist praktisch f√ºr die Programmierung, macht es jedoch schwierig, den √úberblick dar√ºber zu behalten, was tats√§chlich passiert, wenn Sie das allgemeine <strong>Lesen</strong> und <strong>Schreiben</strong> in den Ablaufverfolgungsergebnissen eines Systemaufrufs sehen. </p><br><p>  Durch Hinzuf√ºgen des Operators -u erzwingen Sie, dass <strong>strace</strong> jeden Dateideskriptor in der Ausgabe mit einem Vermerk versehen muss, auf den er verweist. </p><br><p>  Mit -p ** an einen bereits laufenden Prozess anh√§ngen </p><br><p>  Wie aus dem folgenden Beispiel hervorgeht, m√ºssen Sie manchmal ein bereits ausgef√ºhrtes Programm verfolgen.  Wenn Sie wissen, dass es als Prozess 1337 ausgef√ºhrt wird (etwa aus den Schlussfolgerungen von <strong>ps</strong> ), k√∂nnen Sie es folgenderma√üen verfolgen: </p><br><pre> <code class="plaintext hljs">$ strace -p 1337 ...system call trace output...</code> </pre> <br><p>  M√∂glicherweise ben√∂tigen Sie Root-Rechte. </p><br><p>  <strong>Verwenden Sie -f, um untergeordnete Prozesse zu √ºberwachen</strong> </p><br><p>  <strong>strace verfolgt</strong> standardm√§√üig nur einen Prozess.  Wenn dieser Prozess untergeordnete Prozesse erzeugt, wird der Systemaufruf zum Erzeugen des untergeordneten Prozesses angezeigt, die Systemaufrufe des untergeordneten Prozesses werden jedoch nicht angezeigt. </p><br><p>  Wenn Sie der Meinung sind, dass der Fehler im untergeordneten Prozess liegt, verwenden Sie den Operator <strong>-f. Dadurch</strong> wird die Ablaufverfolgung aktiviert.  Der Nachteil dabei ist, dass Sie die Schlussfolgerung noch mehr verwirren wird.  Wenn <strong>strace</strong> einen Prozess oder einen Thread verfolgt, wird ein einzelner Stream von <strong>Aufrufereignissen angezeigt</strong> .  Wenn mehrere Prozesse gleichzeitig verfolgt werden, wird wahrscheinlich der Beginn des Aufrufs durch die Meldung <strong>&lt;unfinished ...&gt;</strong> unterbrochen, dann eine Reihe von Aufrufen f√ºr andere Ausf√ºhrungszweige und erst dann das Ende des ersten mit <strong>&lt;... foocall resumed&gt;</strong> .  <strong>Alternativ</strong> k√∂nnen Sie alle Trace-Ergebnisse auch mit dem Operator <strong>-ff</strong> in verschiedene Dateien <strong>aufteilen</strong> (Einzelheiten finden <strong>Sie im</strong> <strong>Strace-</strong> <a href="https://linux.die.net/man/1/strace">Handbuch</a> ). </p><br><p>  <strong>Filtern Sie den Trace mit -e</strong> </p><br><p>  Wie Sie sehen, ist das Trace-Ergebnis eine Menge aller m√∂glichen Systemaufrufe.  Mit dem Flag <strong>-e</strong> k√∂nnen Sie den Trace filtern (siehe <strong>Strace-</strong> <a href="https://linux.die.net/man/1/strace">Handbuch</a> ).  Der Hauptvorteil ist, dass das Ausf√ºhren eines Traces mit Filterung schneller ist als das Ausf√ºhren eines vollst√§ndigen Traces und dann <strong>grep</strong> .  Ehrlich gesagt ist es mir fast immer egal. </p><br><p>  <strong>Nicht alle Fehler sind schlecht</strong> </p><br><p>  Ein einfaches und weit verbreitetes Beispiel ist ein Programm, das an mehreren Stellen gleichzeitig nach einer Datei sucht, beispielsweise nach einer Shell, in der das Verzeichnis basket / eine ausf√ºhrbare Datei enth√§lt: </p><br><pre> <code class="plaintext hljs">$ strace sh -c uname ... stat("/home/user/bin/uname", 0x7ffceb817820) = -1 ENOENT (No such file or directory) stat("/usr/local/bin/uname", 0x7ffceb817820) = -1 ENOENT (No such file or directory) stat("/usr/bin/uname", {st_mode=S_IFREG|0755, st_size=39584, ...}) = 0 ...</code> </pre> <br><p>  Eine Heuristik "Letzte fehlgeschlagene Anforderung vor Fehlermeldung" kann relevante Fehler gut finden.  Wie dem auch sei, es ist logisch, ganz am Ende anzufangen. </p><br><p>  <strong>C Programmierhandb√ºcher helfen beim Verstehen von Systemaufrufen</strong> </p><br><p>  Standardaufrufe an C-Bibliotheken sind keine Systemaufrufe, sondern nur eine d√ºnne Oberfl√§chenschicht.  Wenn Sie also zumindest ein wenig verstehen, wie und was in C zu tun ist, ist es f√ºr Sie einfacher, die Ergebnisse der Verfolgung eines Systemaufrufs zu verstehen.  Wenn Sie beispielsweise Probleme beim Debuggen von Anrufen an vernetzte Systeme haben, <a href="https://beej.us/guide/bgnet/html/index.html">lesen Sie den "Network Programming Guide" von Bija</a> . </p><br><h3 id="primer-otladki-poslozhnee">  Komplizierteres Debugging-Beispiel </h3><br><p>  Ich habe bereits gesagt, dass ein Beispiel f√ºr einfaches Debuggen ein Beispiel f√ºr etwas ist, mit dem ich mich <strong>gr√∂√ütenteils</strong> mit <strong>Stress auseinandersetzen muss</strong> .  Manchmal ist jedoch eine echte Untersuchung erforderlich. Hier ist ein echtes Beispiel f√ºr ein komplizierteres Debuggen. </p><br><p>  <a href="https://untroubled.org/bcron/">bcron</a> ist ein Task Processing Scheduler, eine weitere Implementierung des * nix <strong>cron Daemons</strong> .  Es ist auf dem Server installiert, aber wenn jemand versucht, den Zeitplan zu bearbeiten, geschieht Folgendes: </p><br><pre> <code class="plaintext hljs"># crontab -e -u logs bcrontab: Fatal: Could not create temporary file</code> </pre> <br><p>  Okay, also hat <strong>bcron</strong> versucht, eine bestimmte Datei zu schreiben, aber es hat nicht <strong>geklappt</strong> und er gibt nicht zu, warum.  <strong>Strace aufdecken</strong> : </p><br><pre> <code class="plaintext hljs"># strace -o /tmp/trace crontab -e -u logs bcrontab: Fatal: Could not create temporary file # cat /tmp/trace ... openat(AT_FDCWD, "bcrontab.14779.1573691864.847933", O_RDONLY) = 3 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f82049b4000 read(3, "#Ansible: logsagg\n20 14 * * * lo"..., 8192) = 150 read(3, "", 8192) = 0 munmap(0x7f82049b4000, 8192) = 0 close(3) = 0 socket(AF_UNIX, SOCK_STREAM, 0) = 3 connect(3, {sa_family=AF_UNIX, sun_path="/var/run/bcron-spool"}, 110) = 0 mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f82049b4000 write(3, "156:Slogs\0#Ansible: logsagg\n20 1"..., 161) = 161 read(3, "32:ZCould not create temporary f"..., 8192) = 36 munmap(0x7f82049b4000, 8192) = 0 close(3) = 0 write(2, "bcrontab: Fatal: Could not creat"..., 49) = 49 unlink("bcrontab.14779.1573691864.847933") = 0 exit_group(111) = ? +++ exited with 111 +++</code> </pre> <br><p>  Ganz am Ende gibt es eine Schreibfehler-Meldung, aber diesmal ist etwas anders.  Erstens gibt es keinen relevanten Systemaufruffehler, der normalerweise vorher auftritt.  Zweitens ist klar, dass irgendwo schon jemand die Fehlermeldung gelesen hat.  Es scheint, dass das eigentliche Problem woanders liegt und <strong>bcrontab</strong> spielt einfach die Nachricht ab. </p><br><p>  Wenn Sie sich <strong>man 2 read</strong> ansehen, sehen Sie, dass das erste Argument (3) der Dateideskriptor ist, den * nix f√ºr die gesamte E / A-Verarbeitung verwendet.  Wie kann man herausfinden, f√ºr welchen Dateideskriptor 3 steht?  In diesem speziellen Fall k√∂nnen Sie <strong>strace</strong> mit dem Operator <strong>-u ausf√ºhren</strong> (siehe oben), und es wird Ihnen automatisch <strong>mitgeteilt</strong> , dass es f√ºr die Berechnung solcher Dinge n√ºtzlich ist, zu wissen, wie die Trace-Ergebnisse gelesen und analysiert werden. </p><br><p>  Die Quelle des Dateideskriptors kann einer von vielen Systemaufrufen sein (alles h√§ngt davon ab, was der Deskriptor f√ºr die Konsole, den Netzwerk-Socket, die Datei selbst oder etwas anderes ist) Suchen Sie in den Trace-Ergebnissen nach "= 3".  Infolgedessen gibt es 2 davon: <strong>openat</strong> ganz oben und <strong>socket</strong> in der Mitte.  <strong>openat</strong> √∂ffnet die Datei, aber <strong>close</strong> (3) zeigt an, dass sie wieder geschlossen wird.  (Rake: Dateideskriptoren k√∂nnen beim √ñffnen und Schlie√üen wiederverwendet werden.)  Der Aufruf <strong>socket ()</strong> ist geeignet, da es sich um den letzten Aufruf vor <strong>read ()</strong> handelt und sich herausstellt, dass bcrontab mit etwas √ºber den Socket funktioniert.  Die n√§chste Zeile zeigt, dass der Dateideskriptor dem <strong>Unix-Domain-Socket</strong> im Pfad <strong>/ var / run / bcron-spool zugeordnet ist</strong> . </p><br><p>  Sie m√ºssen also den Prozess finden, der an den <strong>Unix-Socket angeschlossen</strong> ist.  Zu diesem Zweck gibt es ein paar n√ºtzliche Tricks, die sich beide zum Debuggen von Server-Bereitstellungen eignen.  Das erste ist, <strong>netstat</strong> oder neuere <strong>ss</strong> (Socket-Status) zu verwenden.  Beide Befehle zeigen die aktiven Netzwerkverbindungen des Systems an und verwenden den Operator <strong>-l</strong> , um Listening-Sockets zu beschreiben, und den Operator <strong>-p</strong> , um mit dem Socket verbundene Programme als Client anzuzeigen.  (Es gibt viele weitere n√ºtzliche Optionen, aber diese beiden reichen f√ºr diese Aufgabe aus.) </p><br><pre> <code class="plaintext hljs"># ss -pl | grep /var/run/bcron-spool u_str LISTEN 0 128 /var/run/bcron-spool 1466637 * 0 users:(("unixserver",pid=20629,fd=3))</code> </pre> <br><p>  Dies deutet darauf hin, dass es sich bei dem Listener um einen <strong>Inixserver-</strong> Befehl handelt, der mit der Prozess-ID 20629 arbeitet. (Und zuf√§llig wird der Dateideskriptor 3 als Socket verwendet.) </p><br><p>  Das zweite wirklich n√ºtzliche Werkzeug, um die gleichen Informationen zu finden, hei√üt <strong>lsof</strong> .  Es listet alle offenen Dateien (oder Dateideskriptoren) im System auf.  Oder Sie k√∂nnen Informationen zu einer bestimmten Datei abrufen: </p><br><pre> <code class="plaintext hljs"># lsof /var/run/bcron-spool COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME unixserve 20629 cron 3u unix 0x000000005ac4bd83 0t0 1466637 /var/run/bcron-spool type=STREAM</code> </pre> <br><p>  Der 20629-Prozess ist ein langlebiger Server, daher k√∂nnen <strong>Sie</strong> ihn mit <strong>strace -o / tmp / trace -p 20629 verkn√ºpfen</strong> .  Wenn wir die Cron-Task in einem anderen Terminal bearbeiten, erhalten wir die Ausgabe der Trace-Ergebnisse mit einem Fehler.  Und hier ist das Ergebnis: </p><br><pre> <code class="plaintext hljs">accept(3, NULL, NULL) = 4 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21181 close(4) = 0 accept(3, NULL, NULL) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=21181, si_uid=998, si_status=0, si_utime=0, si_stime=0} --- wait4(0, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], WNOHANG|WSTOPPED, NULL) = 21181 wait4(0, 0x7ffe6bc36764, WNOHANG|WSTOPPED, NULL) = -1 ECHILD (No child processes) rt_sigaction(SIGCHLD, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, 8) = 0 rt_sigreturn({mask=[]}) = 43 accept(3, NULL, NULL) = 4 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21200 close(4) = 0 accept(3, NULL, NULL) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=21200, si_uid=998, si_status=111, si_utime=0, si_stime=0} --- wait4(0, [{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 111}], WNOHANG|WSTOPPED, NULL) = 21200 wait4(0, 0x7ffe6bc36764, WNOHANG|WSTOPPED, NULL) = -1 ECHILD (No child processes) rt_sigaction(SIGCHLD, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, {sa_handler=0x55d244bdb690, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7faa47ab9840}, 8) = 0 rt_sigreturn({mask=[]}) = 43 accept(3, NULL, NULL</code> </pre> <br><p>  (Das letzte <strong>accept ()</strong> wird beim Verfolgen nicht abgeschlossen.) Leider enth√§lt dieses Ergebnis auch nicht den gesuchten Fehler.  Es werden keine Nachrichten angezeigt, die bcrontag an einen Socket senden oder von diesem empfangen w√ºrde.  Stattdessen vollst√§ndige Kontrolle √ºber den Prozess ( <strong>clone</strong> , <strong>wait4</strong> , <strong>SIGCHLD</strong> usw.). Dieser Prozess erzeugt einen <strong>untergeordneten</strong> Prozess, der, wie Sie sich vorstellen k√∂nnen, die eigentliche Arbeit leistet.  Und wenn Sie ihre Spur abfangen m√ºssen, f√ºgen <strong>Sie</strong> dem Aufruf <strong>strace -f hinzu</strong> .  Folgendes finden wir, wenn wir nach der Fehlermeldung im neuen Ergebnis mit strace <strong>-f -o / tmp / trace -p 20629 suchen</strong> : </p><br><pre> <code class="plaintext hljs">21470 openat(AT_FDCWD, "tmp/spool.21470.1573692319.854640", O_RDWR|O_CREAT|O_EXCL, 0600) = -1 EACCES (Permission denied) 21470 write(1, "32:ZCould not create temporary f"..., 36) = 36 21470 write(2, "bcron-spool[21470]: Fatal: logs:"..., 84) = 84 21470 unlink("tmp/spool.21470.1573692319.854640") = -1 ENOENT (No such file or directory) 21470 exit_group(111) = ? 21470 +++ exited with 111 +++</code> </pre> <br><p>  Das ist etwas.  Der Prozess 21470 erh√§lt den Fehler "Zugriff verweigert", wenn versucht wird, eine Datei im Pfad <strong>tmp / spool.21470.1573692319.854640</strong> (bezogen auf das aktuelle Arbeitsverzeichnis) zu erstellen.  Wenn wir einfach das aktuelle Arbeitsverzeichnis kennen w√ºrden, w√ºrden wir den vollst√§ndigen Pfad kennen und k√∂nnten herausfinden, warum der Prozess keine eigene tempor√§re Datei darin erstellen kann.  Leider wurde der Prozess bereits beendet, sodass Sie nicht nur mit <strong>lsof -p 21470</strong> das aktuelle Verzeichnis finden, sondern auch in umgekehrter Richtung arbeiten k√∂nnen. Suchen Sie nach PID 21470-Systemaufrufen, die das Verzeichnis √§ndern.  (Wenn es keine gibt, muss PID 21470 sie vom √ºbergeordneten Element geerbt haben, und dies kann nicht √ºber <strong>lsof -p herausgefunden werden</strong> .) Dieser Systemaufruf lautet <strong>chdir</strong> (was mit Hilfe moderner Netzwerksuchmaschinen leicht herauszufinden ist).  Und hier ist das Ergebnis von R√ºckw√§rtssuchen basierend auf den Trace-Ergebnissen bis zum PID 20629-Server selbst: </p><br><pre> <code class="plaintext hljs">20629 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7faa47c44810) = 21470 ... 21470 execve("/usr/sbin/bcron-spool", ["bcron-spool"], 0x55d2460807e0 /* 27 vars */) = 0 ... 21470 chdir("/var/spool/cron") = 0 ... 21470 openat(AT_FDCWD, "tmp/spool.21470.1573692319.854640", O_RDWR|O_CREAT|O_EXCL, 0600) = -1 EACCES (Permission denied) 21470 write(1, "32:ZCould not create temporary f"..., 36) = 36 21470 write(2, "bcron-spool[21470]: Fatal: logs:"..., 84) = 84 21470 unlink("tmp/spool.21470.1573692319.854640") = -1 ENOENT (No such file or directory) 21470 exit_group(111) = ? 21470 +++ exited with 111 +++</code> </pre> <br><p>  (Wenn Sie sich verlaufen, m√∂chten Sie m√∂glicherweise meinen vorherigen Beitrag <a href="https://theartofmachinery.com/2018/11/07/writing_a_nix_shell.html">zu * nix process control and shells</a> lesen.) Der PID 20629-Server hat daher keine Berechtigung zum Erstellen einer Datei im Pfad <strong>/var/spool/cron/tmp/spool.21470.1573692319.854640 erhalten</strong> .  ,   ‚Äî     . : </p><br><pre> <code class="plaintext hljs"># ls -ld /var/spool/cron/tmp/ drwxr-xr-x 2 root root 4096 Nov 6 05:33 /var/spool/cron/tmp/ # ps u -p 20629 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND cron 20629 0.0 0.0 2276 752 ? Ss Nov14 0:00 unixserver -U /var/run/bcron-spool -- bcron-spool</code> </pre> <br><p>    !     cron,    root      <strong>/var/spool/cron/tmp/</strong> .   <strong>chown cron /var/spool/cron/tmp/</strong>  <strong>bcron</strong>  . (     ,      ‚Äî     SELinux  AppArmor,           <strong>dmesg</strong> .) </p><br><h3 id="itogo">  Total </h3><br><p>        ,  , , ,   ‚Äî         . ,     <strong>bcron</strong> ,   . </p><br><p>            ,     ,  ,  <strong>strace</strong> ,        ,   .   , <strong>strace</strong>       . ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478626/">https://habr.com/ru/post/de478626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478604/index.html">Von Arbeitern zu PHP-Programmierern. Ungew√∂hnliche Entwicklungskarriere</a></li>
<li><a href="../de478606/index.html">‚ÄûGute Nacht‚Äú - wie intelligente Ger√§te Menschen den Schlaf rauben</a></li>
<li><a href="../de478616/index.html">Windows UAC h√∂rt nie auf zu √ºberraschen, oder wie man einen Insider erkennt</a></li>
<li><a href="../de478618/index.html">Schule der Magie PHP</a></li>
<li><a href="../de478620/index.html">Warum sollten Sie FastAPI ausprobieren?</a></li>
<li><a href="../de478628/index.html">Hoher CRI auf Chinesisch</a></li>
<li><a href="../de478634/index.html">Fallstricke im Projektmanagement f√ºr maschinelles Lernen</a></li>
<li><a href="../de478636/index.html">Wie Textcodierungen funktionieren. Woher kommen die "Krokodile"? Die Prinzipien der Kodierung. Verallgemeinerung und detaillierte Analyse</a></li>
<li><a href="../de478638/index.html">db-tree: Durchsucht und navigiert die Datenbank</a></li>
<li><a href="../de478640/index.html">Autonome Autos auf Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>