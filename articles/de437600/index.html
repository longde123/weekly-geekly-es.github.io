<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕚 🙏🏾 🚺 opencv4arts: Zeichne meine Stadt, Vincent 🕴️ 👩‍🔬 🧔🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenCV ist eine Bibliothek mit einer Geschichte der kontinuierlichen Entwicklung in 20 Jahren. Das Alter, in dem Sie anfangen, in sich selbst zu grabe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>opencv4arts: Zeichne meine Stadt, Vincent</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intel/blog/437600/"><p>  OpenCV ist eine Bibliothek mit einer Geschichte der kontinuierlichen Entwicklung in 20 Jahren.  Das Alter, in dem Sie anfangen, in sich selbst zu graben und nach einem Ziel zu suchen.  Gibt es darauf basierende Projekte, die jemandes Leben besser und glücklicher gemacht haben?  Schaffst du es selbst?  Auf der Suche nach Antworten und dem Wunsch, bisher unbekannte OpenCV-Module zu entdecken, möchte ich Anwendungen erstellen, die „wunderbar funktionieren“ - so dass es zunächst „wow“ gibt und erst dann „oh ja, es ist Computer Vision“. </p><br><p>  Das Recht des ersten Artikels war ein Experiment mit der Übertragung von Stilen von Weltkünstlern in die Fotografie.  Aus dem Artikel erfahren Sie, was das Herzstück der Prozedur und die relativ neue OpenCV.js - JavaScript-Version der OpenCV-Bibliothek ist. </p><br><p><img src="https://habrastorage.org/webt/bd/gi/zx/bdgizx8meb6hqmshphkkpsonuee.jpeg"></p><a name="habracut"></a><br><h2 id="style-transfer">  Stilübertragung </h2><br><p> Gegner des maschinellen Lernens werden mir vergeben, aber die Hauptkomponente im heutigen Artikel wird ein tiefes Faltungsnetzwerk sein.  Weil es funktioniert.  Es gibt keine Möglichkeit, neuronale Netze in OpenCV zu trainieren, aber Sie können vorhandene Modelle ausführen.  Wir werden das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorgefertigte CycleGAN-</a> Netzwerk verwenden.  Die Autoren, für die sie sehr dankbar sind, bieten völlig kostenlose Download-Netzwerke an, die Bilder von Äpfeln in Orangen, Pferde in Zebras, Satellitenbilder in Karten, Winterfotos in Sommerfotos und vieles mehr konvertieren.  Darüber hinaus können Sie mit dem Netzwerktrainingsverfahren zwei Generatormodelle gleichzeitig in beide Richtungen arbeiten lassen.  Das heißt, wenn Sie die Umwandlung von Winter in Sommer lehren, erhalten Sie ein Modell für das Malen von Winterlandschaften in Sommerfotos.  Ein einzigartiges Angebot, das man nicht ablehnen kann. </p><br><p>  In unserem Beispiel nehmen wir Modelle, die Fotos in Gemälde von Künstlern verwandeln.  Nämlich Vincent Van Gogh, Claude Monet, Paul Cezanne oder im gesamten Genre der japanischen Drucke Ukiyo-e.  Das heißt, wir werden vier separate Netzwerke zur Verfügung haben.  Es ist erwähnenswert, dass für die Ausbildung eines jeden nicht ein Bild des Künstlers verwendet wurde, sondern eine ganze Menge, wodurch die Autoren versuchten, das neuronale Netzwerk zu trainieren, um den Stil eines Werks nicht zu verändern, sondern sozusagen den Schreibstil zu übernehmen. </p><br><h2 id="opencvjs">  Opencv.js </h2><br><p>  OpenCV ist eine in C ++ entwickelte Bibliothek, während für die meisten Funktionen die Möglichkeit besteht, automatische Wrapper zu erstellen, die native Methoden aufrufen.  Offiziell werden Wrapper für die Sprachen Python und Java unterstützt.  Darüber hinaus gibt es kundenspezifische Lösungen für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP</a> .  Wenn Sie Erfahrung mit anderen Sprachen haben, wäre es großartig zu wissen, in welchen und dank wessen Bemühungen. </p><br><p> OpenCV.js ist ein Projekt, das dank des Google Summer of Code-Programms im Jahr 2017 das Recht auf Leben erhalten hat.  Übrigens, sobald das Deep-Learning-Modul OpenCV selbst erstellt und in seinem Framework deutlich verbessert wurde.  Im Gegensatz zu anderen Sprachen ist OpenCV.js derzeit kein Wrapper nativer Methoden in JavaScript, sondern eine vollständige Kompilierung mit Emscripten mit LLVM und Clang.  Sie können damit eine Datei aus Ihrer C- und C ++ - Anwendung oder Bibliothek <code>.js</code> , die beispielsweise in einem Browser ausgeführt werden kann. </p><br><p>  Beispielsweise, </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main(int argc, char** argv) { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br><p>  Kompilieren in <code>asm.js</code> </p><br><pre> <code class="plaintext hljs">emcc main.cpp -s WASM=0 -o main.js</code> </pre> <br><p>  Und laden: </p><br><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><blockquote><img src="https://habrastorage.org/webt/pt/pp/bx/ptppbxsjtgxqe48qlfpxho0umaa.png"></blockquote><p>  Sie können OpenCV.js wie folgt mit Ihrem Projekt verbinden (nächtliche Erstellung): </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/opencv.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Eine zusätzliche Bibliothek zum Lesen von Bildern, Arbeiten mit der Kamera und anderen Dingen, die manuell in JavaScript geschrieben wurde, kann ebenfalls nützlich sein: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://docs.opencv.org/master/utils.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2 id="zagruzka-izobrazheniy">  Bilder hochladen </h2><br><p>  Bilder in OpenCV.js können aus Elementen wie <code>canvas</code> oder IMG gelesen werden.  Dies bedeutet, dass das direkte Herunterladen von Bilddateien die Aufgabe des Benutzers bleibt.  Der <code>addFileInputHandler</code> lädt die Zusatzfunktion <code>addFileInputHandler</code> das Bild automatisch in das gewünschte <code>canvas</code> Element, wenn ein Bild auf Knopfdruck von der Festplatte ausgewählt wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> utils = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Utils(<span class="hljs-string"><span class="hljs-string">''</span></span>); utils.addFileInputHandler(<span class="hljs-string"><span class="hljs-string">'fileInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>);</code> </pre> <br><p>  wo </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"fileInput"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">accept</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"image/*"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"canvasInput"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Der wichtige Punkt ist, dass <code>img</code> ein 4-Kanal-RGBA-Image ist, das sich vom üblichen <code>cv::imread</code> , bei dem ein BGR-Image erstellt wird.  Dies sollte beispielsweise bei der Portierung von Algorithmen aus anderen Sprachen berücksichtigt werden. </p><br><p>  Beim Rendern ist alles einfach - rufen <code>imshow</code> einfach <code>imshow</code> mit der <code>id</code> gewünschten <code>imshow</code> (erwartet RGB oder RGBA). </p><br><pre> <code class="javascript hljs">cv.imshow(<span class="hljs-string"><span class="hljs-string">"canvasOutput"</span></span>, img);</code> </pre> <br><h3 id="algoritm">  Algorithmus </h3><br><p>  Der gesamte Bildverarbeitungsalgorithmus ist der Start eines neuronalen Netzwerks.  Angenommen, was im Inneren passiert, bleibt magisch. Wir müssen nur die richtige Eingabe vorbereiten und die Vorhersage richtig interpretieren (Netzwerkausgabe). </p><br><p>  Das in diesem Beispiel betrachtete Netzwerk empfängt einen vierdimensionalen Tensor mit <code>float</code> im Intervall <code>[-1, 1]</code> .  Jede der Dimensionen ist in der Reihenfolge der Änderungsgeschwindigkeit der Index des Bildes, der Kanäle, der Höhe und der Breite.  Dieses Styling wird als NCHW bezeichnet, und der Tensor selbst wird als blobiges, binäres großes Objekt bezeichnet.  Die Vorverarbeitungsaufgabe besteht darin, ein OpenCV-Bild zu konvertieren, dessen Intensitäten verschachtelt sind und ein Intervall von Werten <code>[0, 255]</code> Typ <code>unsigned char</code> Zeichen in einem NCHW-Blob mit einem Wertebereich <code>[-1, 1]</code> . </p><br><p><img src="https://habrastorage.org/webt/bi/yi/yo/biyiyoyp35oyopnpk3zb3yzohzm.jpeg"><br>  <em>ein Stück des Nischni Nowgorod Kremls (wie eine Person sieht)</em> </p><br><p><img src="https://habrastorage.org/webt/qq/ju/nf/qqjunf_3hmkujx9ano4ordvwdtc.jpeg"><br>  <em>verschachtelte Ansicht (wie OpenCV speichert)</em> </p><br><p><img src="https://habrastorage.org/webt/cc/z3/ln/ccz3lnfgrpn-tju9bbtk3qvlhdg.jpeg"><br>  <em>Planaransicht (was das Netzwerk benötigt)</em> </p><br><p>  Als Nachbearbeitung müssen die inversen Transformationen durchgeführt werden: Das Netzwerk gibt einen NCHW-Blob mit Werten im Intervall <code>[-1, 1]</code> , der in das Bild umgepackt, auf <code>[0, 255]</code> normalisiert und in <code>unsigned char</code> konvertiert werden muss. </p><br><p>  Unter Berücksichtigung aller Funktionen zum Lesen und Schreiben von OpenCV.js-Bildern nehmen die folgenden Schritte Gestalt an: </p><br><pre> <code class="plaintext hljs">imread -&gt; RGBA -&gt; BGR [0, 255] -&gt; NCHW [-1, 1] -&gt; [] [] -&gt; NCHW [-1, 1] -&gt; RGB [0, 255] -&gt; imshow</code> </pre> <br><p>  Bei Betrachtung der resultierenden Pipeline stellen sich Fragen, warum das Netzwerk nicht sofort mit verschachteltem RGBA arbeiten und verschachteltes RGB zurückgeben kann.  Warum sind zusätzliche Transformationen für die Pixelpermutation und -normalisierung erforderlich?  Die Antwort ist, dass ein neuronales Netzwerk ein mathematisches Objekt ist, das Transformationen an den Eingabedaten einer bestimmten Verteilung durchführt.  In unserem Fall wurde sie geschult, um Daten in dieser Form zu erhalten. Um die gewünschten Ergebnisse zu erzielen, ist es daher erforderlich, die Vorverarbeitung zu reproduzieren, die die Autoren in der Schulung verwendet haben. </p><br><h3 id="realizaciya">  Implementierung </h3><br><p>  Das neuronale Netzwerk, das wir ausführen, wird in Form einer Binärdatei gespeichert, die zuerst in das lokale Dateisystem geladen werden muss. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> net; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>; utils.createFileFromUrl(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>, url, () =&gt; { net = cv.readNet(<span class="hljs-string"><span class="hljs-string">'style_vangogh.t7'</span></span>); });</code> </pre> <br><p>  <code>url</code> ist übrigens ein vollständiger Link zur Datei.  In diesem Fall laden wir die Datei einfach neben der aktuellen HTML-Seite hoch, aber Sie können sie durch die <a href="">Originalquelle</a> ersetzen (in diesem Fall kann die Downloadzeit länger sein). </p><br><p>  Ein Bild von der <code>canvas</code> lesen und von RGBA zu BGR konvertieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgRGBA = cv.imread(<span class="hljs-string"><span class="hljs-string">'canvasInput'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgBGR = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cv.Mat(imgRGBA.rows, imgRGBA.cols, cv.CV_8UC3); cv.cvtColor(imgRGBA, imgBGR, cv.COLOR_RGBA2BGR);</code> </pre> <br><p>  Erstellen eines 4D-Blobs, bei dem die Funktion <code>blobFromImage</code> mithilfe von Normalisierungskonstanten in einen <code>float</code> Datentyp konvertiert wird.  Dann - starten Sie das Netzwerk. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blob = cv.blobFromImage(imgBGR, <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">127.5</span></span>, <span class="hljs-comment"><span class="hljs-comment">//  {width: imgBGR.cols, height: imgBGR.rows}, //  [127.5, 127.5, 127.5, 0]); //   net.setInput(blob); var out = net.forward();</span></span></code> </pre> <br><p>  Das Ergebnis wird zurück in das Bild des gewünschten Typs und das Werteintervall konvertiert <code>[0, 255]</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     [-1, 1]  [0, 255] var outNorm = new cv.Mat(); out.convertTo(outNorm, cv.CV_8U, 127.5, 127.5); //  interleaved   planar  var outHeight = out.matSize[2]; var outWidth = out.matSize[3]; var planeSize = outHeight * outWidth; var data = outNorm.data; var b = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(0, planeSize)); var g = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(planeSize, 2 * planeSize)); var r = cv.matFromArray(outHeight, outWidth, cv.CV_8UC1, data.slice(2 * planeSize, 3 * planeSize)); var vec = new cv.MatVector(); vec.push_back(r); vec.push_back(g); vec.push_back(b); var rgb = new cv.Mat(); cv.merge(vec, rgb); //   cv.imshow("canvasOutput", rgb);</span></span></code> </pre> <br><p>  Derzeit wird OpenCV.js im halbautomatischen Modus erstellt.  In dem Sinne, dass nicht alle Module und Methoden von ihnen die entsprechenden Signaturen in JavaScript erhalten.  Für ein dnn-Modul ist die Liste der gültigen Funktionen beispielsweise wie folgt definiert: </p><br><pre> <code class="python hljs">dnn = {<span class="hljs-string"><span class="hljs-string">'dnn_Net'</span></span>: [<span class="hljs-string"><span class="hljs-string">'setInput'</span></span>, <span class="hljs-string"><span class="hljs-string">'forward'</span></span>], <span class="hljs-string"><span class="hljs-string">''</span></span>: [<span class="hljs-string"><span class="hljs-string">'readNetFromCaffe'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTensorflow'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromTorch'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromDarknet'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNetFromONNX'</span></span>, <span class="hljs-string"><span class="hljs-string">'readNet'</span></span>, <span class="hljs-string"><span class="hljs-string">'blobFromImage'</span></span>]}</code> </pre> <br><p>  Die letzte Konvertierung, bei der der Blob in drei Kanäle aufgeteilt und dann zu einem Bild gemischt wird, kann <code>imagesFromBlob</code> Methode durchgeführt werden, die der obigen Liste einfach noch nicht hinzugefügt wurde.  Vielleicht ist dies Ihr erster Beitrag zur Entwicklung von OpenCV?  ;) </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Als Demonstration habe ich eine Seite auf GitHub vorbereitet, auf der Sie den resultierenden Code testen können: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dkurtaev.github.io/opencv4arts</a> (Achtung! Wenn Sie ein Netzwerk von ca. 22 MB herunterladen, sparen Sie Ihren Datenverkehr. Andernfalls wird empfohlen, die Seite für jedes neue Bild neu zu laden, andernfalls die Qualität nachfolgende Verarbeitung ist irgendwie stark verzerrt).  Bereiten Sie sich auf einen langen Verarbeitungsprozess vor oder versuchen Sie, die Bildgröße zu ändern. Das Ergebnis ist ein Schieberegler. </p><br><p>  Während ich an dem Artikel arbeitete und genau das Bild auswählte, das ihr Gesicht werden soll, fand ich versehentlich ein Foto meiner Freundin, das den Kreml unserer Stadt zeigt, und alles kam zusammen - kam auf den Namen des Artikels und fand erst dann, dass es so sein sollte.  Ich schlage vor, Sie probieren die Anwendung auf Fotos Ihres Lieblingsortes aus und erzählen vielleicht in den Kommentaren oder in einem persönlichen Brief etwas Interessantes darüber. </p><br><p>  Von mir - eine lustige Tatsache.  Die meisten Einwohner von Nischni Nowgorod und der Region Nischni Nowgorod verwenden das Wort „raus“ im Sinne des Wortes „fit in“ (einen freien Platz finden).  Zum Beispiel die Frage "Werden wir Ihr Auto reinigen?"  bedeutet "Haben wir genug Platz in Ihrem Auto?", aber nicht "Können wir Ihr Auto aufräumen?".  Wenn Studenten aus anderen Bereichen zu Sommerpraktika zu uns kommen, erzählen wir diese Tatsache gerne - viele sind aufrichtig überrascht. </p><br><h2 id="poleznye-ssylki">  Nützliche Links </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCV.js Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CycleGAN-Modelle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere Stilübertragungsmodelle</a> (unterscheiden sich in der Normalisierung) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437600/">https://habr.com/ru/post/de437600/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437590/index.html">Latenzzahlen auf dem iPhone</a></li>
<li><a href="../de437592/index.html">Asynchrone Task Execution Layer-Architektur</a></li>
<li><a href="../de437594/index.html">Wie ich die Ursache für Stottern und Frame-Skipping in allen Spielen beseitigt und versehentlich die Temperatur um 15 Grad gesenkt habe</a></li>
<li><a href="../de437596/index.html">OTRS: LDAP-Authentifizierung, Autorisierung und Synchronisation (FreeIPA, AD)</a></li>
<li><a href="../de437598/index.html">So speichern Sie das Spielsystem mithilfe der Virtualisierung vom Heim-PC</a></li>
<li><a href="../de437602/index.html">Profilieren Sie ein Unity-Projekt mit Android Studio</a></li>
<li><a href="../de437604/index.html">Wellenfunktionskollaps: Ein von der Quantenmechanik inspirierter Algorithmus</a></li>
<li><a href="../de437606/index.html">Wer isst die Erinnerung an unser iPhone? Äpfel schälen</a></li>
<li><a href="../de437610/index.html">[longrid] 20 Jahre Programmierkarriere in einer großen Kleinstadt</a></li>
<li><a href="../de437612/index.html">Der IT-Riese wird sich mit Siliziumphotonik befassen - wie sich dies auf den Markt für Netzwerkgeräte auswirken wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>