<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍣 ✊🏿 👰🏻 Rekonstruksi wajah 3D dari foto dan animasinya menggunakan video. Kuliah di Yandex 🧚🏼 🤹🏻 🌥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam film Mission Impossible 3, proses pembuatan topeng mata-mata terkenal ditampilkan, berkat beberapa karakter yang tidak dapat dibedakan dari yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rekonstruksi wajah 3D dari foto dan animasinya menggunakan video. Kuliah di Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/421353/"> Dalam film Mission Impossible 3, proses pembuatan topeng mata-mata terkenal ditampilkan, berkat beberapa karakter yang tidak dapat dibedakan dari yang lain.  Menurut plot, pada awalnya itu diperlukan untuk memotret orang yang ingin menjadi pahlawan dari beberapa sudut.  Pada tahun 2018, model wajah 3D yang sederhana bahkan mungkin tidak dicetak, tetapi setidaknya dibuat dalam bentuk digital - dan didasarkan hanya pada satu foto.  Seorang peneliti VisionLabs menjelaskan secara terperinci proses di acara Yandex " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dunia melalui mata robot</a> " dari seri Data &amp; Sains, dengan perincian tentang metode dan formula spesifik. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zy9fxYDgUQw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Selamat sore.  Nama saya Nikolai, saya bekerja untuk VisionLabs, sebuah perusahaan visi komputer.  Profil utama kami adalah pengenalan wajah, tetapi kami juga memiliki teknologi yang dapat diterapkan dalam augmented reality dan virtual.  Secara khusus, kami memiliki teknologi untuk membangun wajah 3D dari satu foto, dan hari ini saya akan membicarakannya. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/hi/ks/fu/hiksfukx8cknqrbhf5kv-c9xwbs.jpeg"><br><br>  Mari kita mulai dengan cerita tentang apa itu.  Pada slide Anda melihat foto asli Jack Ma dan model 3D yang dibangun dari foto ini dalam dua variasi: dengan dan tanpa tekstur, hanya geometri.  Ini adalah tugas yang sedang kami selesaikan. <br><br><img src="https://habrastorage.org/webt/qo/sy/10/qosy10ijsqqmfgyqiemsloakdqg.jpeg"><br><br>  Kami juga ingin dapat menghidupkan model ini, mengubah arah pandangan kami, ekspresi wajah, menambahkan ekspresi wajah, dll. <br><br>  Aplikasi ini berada di area yang berbeda.  Yang paling jelas adalah game, termasuk VR.  Anda juga dapat melakukan ruang pas virtual - coba kacamata, jenggot dan gaya rambut.  Anda dapat melakukan pencetakan 3D, karena beberapa orang tertarik pada aksesori yang dipersonalisasi untuk wajah mereka.  Dan Anda dapat membuat wajah untuk robot: cetak dan tampilkan pada beberapa tampilan pada robot. <br><br><img src="https://habrastorage.org/webt/uh/d4/1b/uhd41bqzarsfib5oao3zven7gxk.jpeg"><br><br>  Saya akan mulai dengan memberi tahu Anda cara membuat wajah 3D secara umum, dan kemudian kita akan beralih ke tugas rekonstruksi 3D sebagai tugas membuat generasi terbalik.  Setelah itu, kami akan fokus pada animasi dan beralih ke tantangan yang muncul di area ini. <br><br><img src="https://habrastorage.org/webt/bk/yb/sj/bkybsja0tr11pleorczx4okgk3g.jpeg"><br><br>  Apa tugas menghasilkan wajah?  Kami ingin memiliki beberapa cara untuk menghasilkan wajah tiga dimensi yang berbeda dalam bentuk dan ekspresi.  Berikut adalah dua baris dengan contoh.  Baris pertama menunjukkan wajah dengan bentuk yang berbeda, milik seolah-olah orang yang berbeda.  Dan di bawah ini adalah wajah yang sama dengan ekspresi berbeda. <br><br><img src="https://habrastorage.org/webt/_s/md/94/_smd94kpe-kgilpu8c2ncguhgve.jpeg"><br><br>  Salah satu cara untuk menyelesaikan masalah pembangkitan adalah model yang dapat dideformasi.  Wajah paling kiri pada slide adalah jenis model rata-rata yang kita dapat menerapkan deformasi dengan menyesuaikan slider.  Inilah tiga slider.  Di baris atas ada wajah ke arah peningkatan intensitas slider, di baris bawah - ke arah penurunan.  Dengan demikian, kita akan memiliki beberapa parameter yang dapat disesuaikan.  Dengan menginstalnya, Anda dapat memberi orang bentuk yang berbeda. <br><br><img src="https://habrastorage.org/webt/rs/gj/bd/rsgjbdm2ekfclog-l9r24yj05zq.jpeg"><br><br>  Contoh dari model yang dapat dideformasi adalah Basel Face Model yang terkenal, dibangun dari pemindaian wajah.  Untuk membuat model yang cacat, pertama-tama Anda perlu membawa beberapa orang, membawanya ke laboratorium khusus dan memotret wajah mereka dengan peralatan khusus, menerjemahkannya menjadi 3D.  Kemudian, berdasarkan ini, Anda dapat membuat wajah baru. <br><br><img src="https://habrastorage.org/webt/da/lm/zi/dalmziafwox1_wosdsp25pjphiu.jpeg"><br><br>  Bagaimana cara mengaturnya secara matematis?  Kita dapat membayangkan model wajah tiga dimensi sebagai vektor dalam ruang 3n dimensi.  Di sini n adalah jumlah simpul dalam model, masing-masing simpul sesuai dengan tiga koordinat dalam 3D, dan dengan demikian kita mendapatkan koordinat 3n. <br><br><img src="https://habrastorage.org/webt/fr/h2/ek/frh2ekb0ts7xoeymvoxdthm7_ak.jpeg"><br><br>  Jika kita memiliki satu set pemindaian, maka setiap pemindaian diwakili oleh vektor seperti itu, dan kita memiliki satu set n vektor seperti itu. <br><br>  Selanjutnya, kita dapat membangun wajah baru sebagai kombinasi linear dari vektor dari basis data kita.  Pada saat yang sama, kami ingin koefisien menjadi bermakna.  Jelas, mereka tidak bisa sepenuhnya sewenang-wenang, dan saya akan segera menunjukkan alasannya.  Salah satu batasan dapat diatur sehingga semua koefisien berada dalam kisaran dari 0 hingga 1. Ini harus dilakukan, karena jika koefisien sepenuhnya arbitrer, maka wajah akan berubah menjadi tidak masuk akal. <br><br><img src="https://habrastorage.org/webt/43/x3/m_/43x3m_fwzwj8xcsvywqjusbijmm.jpeg"><br><br>  Di sini saya ingin memberikan parameter beberapa arti probabilistik.  Artinya, kami ingin melihat serangkaian parameter dan memahami apakah seseorang akan berubah atau tidak.  Dengan ini kami ingin distorsi rendah sesuai dengan wajah yang terdistorsi. <br><br><img src="https://habrastorage.org/webt/ge/m4/yb/gem4ybi9ha0puz8tcjv3nomiwiy.jpeg"><br><br>  Begini cara melakukannya.  Kita dapat menerapkan metode komponen utama ke satu set pemindaian.  Pada output, kita mendapatkan rata-rata wajah S0, mendapatkan matriks V, satu set komponen utama, dan juga mendapatkan variasi data sepanjang komponen utama.  Kemudian kita bisa melihat segar pada generasi wajah, kita akan mewakili wajah-wajah sebagai beberapa wajah rata-rata, ditambah matriks komponen utama, dikalikan dengan vektor parameter. <br><br>  Nilai parameter adalah intensitas slider yang saya bicarakan di salah satu slide sebelumnya.  Dan juga kita dapat menetapkan beberapa nilai probabilistik ke vektor parameter.  Secara khusus, kami dapat setuju bahwa vektor ini adalah Gaussian. <br><br><img src="https://habrastorage.org/webt/pv/bk/qq/pvbkqqdess7l175ginfuz9vkzmw.jpeg"><br><br>  Dengan demikian, kami mendapatkan metode yang memungkinkan Anda untuk menghasilkan wajah 3D, dan generasi ini dikendalikan oleh parameter berikut.  Seperti pada slide sebelumnya, kami memiliki dua set parameter, dua vektor α id dan α exp, mereka sama seperti pada slide sebelumnya, tetapi α id bertanggung jawab atas bentuk wajah, dan α exp akan bertanggung jawab untuk emosi. <br><br>  T vektor baru juga muncul - vektor tekstur.  Ini memiliki dimensi yang sama dengan vektor bentuk, dan setiap simpul dalam vektor ini memiliki tiga nilai RGB.  Demikian pula, vektor tekstur dihasilkan menggunakan vektor parameter β.  Di sini parameter tidak diformalkan yang akan bertanggung jawab untuk pencahayaan wajah dan posisinya, tetapi mereka juga ada. <br><br><img src="https://habrastorage.org/webt/ab/bx/23/abbx2327nyov76ewuzl_s_fa9qo.jpeg"><br><br>  Berikut adalah contoh wajah yang dapat dihasilkan menggunakan model cacat.  Harap dicatat bahwa mereka berbeda dalam bentuk, warna kulit, dan juga digambar dalam kondisi pencahayaan yang berbeda. <br><br><img src="https://habrastorage.org/webt/-n/ht/eu/-nhteuzhzcomppfvup80sevyhhc.jpeg"><br><br>  Sekarang kita dapat beralih ke rekonstruksi 3D.  Ini disebut masalah terbalik, karena kami ingin memilih parameter seperti itu untuk model yang dapat dideformasi sehingga wajah yang kita gambar darinya akan sebanyak mungkin mirip dengan aslinya.  Slide ini berbeda dari yang pertama di sini, di sebelah kanan, wajah sepenuhnya sintetis.  Jika pada slide pertama tekstur kita diambil dari foto, maka di sini tekstur diambil dari model yang dapat dideformasi. <br><br>  Pada output, kita akan memiliki semua parameter, pada slide α id dan α exp disajikan, dan kita juga akan memiliki pencahayaan, parameter tekstur, dll. <br><br><img src="https://habrastorage.org/webt/qa/ci/ql/qaciqlkbflxmqo1a1pzzn01g4d8.jpeg"><br><br>  Kami mengatakan bahwa kami ingin memastikan bahwa model yang dihasilkan terlihat seperti foto.  Kesamaan ini ditentukan dengan menggunakan fungsi energi.  Di sini kita hanya mengambil perbedaan piksel-demi-piksel dari gambar dalam piksel tersebut di mana kami pikir wajahnya terlihat.  Misalnya, jika wajah diputar, maka tumpang tindih akan terjadi.  Misalnya, bagian tulang pipi akan tertutup hidung.  Dan matriks visibilitas M harus menampilkan tumpang tindih seperti itu. <br><br>  Intinya, rekonstruksi 3D adalah untuk meminimalkan fungsi energi ini.  Tetapi untuk mengatasi masalah minimisasi ini, alangkah baiknya memiliki inisialisasi dan regularisasi.  Regularisasi diperlukan untuk alasan yang jelas, seperti yang kami katakan bahwa jika kami tidak mengatur parameter dan membuatnya benar-benar sewenang-wenang, kami bisa mendapatkan wajah yang terdistorsi.  Inisialisasi diperlukan karena tugas secara keseluruhan kompleks, memiliki minimum lokal, dan Anda tidak ingin berurusan dengan mereka. <br><br><img src="https://habrastorage.org/webt/jq/i-/ns/jqi-nskft-v7pvl8tadsmrldaco.jpeg"><br><br>  Bagaimana inisialisasi dapat dilakukan?  Untuk ini, Anda dapat menggunakan 68 poin kunci wajah.  Sejak 2013-2014, banyak algoritma telah muncul yang memungkinkan 68 poin terdeteksi dengan akurasi yang cukup baik, dan sekarang mereka mendekati saturasi keakuratannya.  Karena itu, kami memiliki cara untuk mendeteksi 68 titik wajah dengan andal. <br><br>  Kita dapat menambahkan istilah baru pada fungsi energi kita, yang akan mengatakan bahwa kita ingin proyeksi 68 poin model yang sama bertepatan dengan titik-titik kunci wajah.  Kami menandai titik-titik ini pada model, lalu kami entah bagaimana mengubah bentuk model, memelintirnya, memproyeksikan poin, dan memastikan bahwa posisi titik-titik tersebut bertepatan.  Di foto kiri ada titik-titik dua warna, ungu dan kuning.  Beberapa titik terdeteksi oleh algoritma, sementara yang lain diproyeksikan dari model.  Menandai titik pada model di sebelah kanan, tetapi untuk titik di sepanjang tepi wajah, tidak ada satu titik yang ditandai, tetapi seluruh garis.  Ini dilakukan karena ketika wajah diputar, tanda titik-titik ini harus berubah, dan titik dipilih dengan garis. <br><br><img src="https://habrastorage.org/webt/sb/kg/n0/sbkgn0oajeqf_z-bleo0qfhzguy.jpeg"><br><br>  Berikut adalah istilah yang saya bicarakan, itu adalah perbedaan koordinat-bijaksana dari dua vektor yang menggambarkan poin-poin kunci dari wajah dan poin-poin utama yang diproyeksikan dari model. <br><br><img src="https://habrastorage.org/webt/wj/ku/eq/wjkueqaneclilvcxhbdsimu-gik.jpeg"><br><br>  Mari kita kembali ke regularisasi dan mempertimbangkan seluruh masalah dari perspektif kesimpulan Bayesian.  Probabilitas bahwa vektor α sama dengan sesuatu yang diberikan dalam gambar yang diketahui sebanding dengan produk dari probabilitas mengamati gambar untuk α yang diberikan, dikalikan dengan probabilitas α.  Jika kita mengambil logaritma negatif dari ungkapan ini, yang harus kita kurangi, kita akan melihat bahwa istilah yang bertanggung jawab untuk regularisasi akan memiliki bentuk khusus di sini.  Secara khusus, ini adalah istilah kedua.  Mengingat bahwa kita sebelumnya membuat asumsi bahwa vektor α adalah Gaussian, kita melihat bahwa istilah yang bertanggung jawab untuk regularisasi adalah jumlah kuadrat dari parameter yang direduksi menjadi variasi di sepanjang komponen utama. <br><br><img src="https://habrastorage.org/webt/9t/hj/y2/9thjy2x8qmvgcqxayk7rrddusra.jpeg"><br><br>  Jadi, kita bisa menuliskan fungsi energi penuh, yang berisi tiga istilah.  Istilah pertama bertanggung jawab untuk tekstur, untuk perbedaan piksel antara gambar yang dihasilkan dan gambar target.  Istilah kedua bertanggung jawab untuk poin-poin utama, dan yang ketiga bertanggung jawab untuk regularisasi. <br><br>  Koefisien persyaratan dalam proses minimalisasi tidak dioptimalkan, mereka hanya ditetapkan. <br>  Di sini, fungsi energi direpresentasikan sebagai fungsi dari semua parameter.  α parameter bentuk wajah id, parameter ekspresi ekspresi, parameter tekstur β, parameter lain yang kita bicarakan tetapi tidak diformalkan, ini adalah parameter posisi dan pencahayaan. <br><br><img src="https://habrastorage.org/webt/tn/ki/np/tnkinpazftdmbqj3cyiij4vxn8s.jpeg"><br><br>  Marilah kita memikirkan komentar ini.  Fungsi energi ini dapat disederhanakan.  Dari situ, Anda dapat membuang istilah yang bertanggung jawab untuk tekstur, dan hanya menggunakan informasi yang dikirim oleh 68 poin.  Dan ini akan memungkinkan Anda untuk membangun semacam model 3D.  Namun, perhatikan profil model.  Di sebelah kiri adalah model yang dibangun hanya pada titik-titik kunci.  Di sebelah kanan adalah model yang menggunakan tekstur saat membangun.  Perhatikan bahwa profil di sebelah kanan lebih konsisten dengan foto pusat, yang mewakili tampilan depan wajah. <br><br><img src="https://habrastorage.org/webt/r2/kp/p9/r2kpp94wnxg7vhfz1nha-ewl4xg.jpeg"><br><br>  Animasi dengan algoritma yang ada untuk membangun model wajah 3D bekerja cukup sederhana.  Ingatlah bahwa ketika membangun model 3D, kita mendapatkan dua vektor parameter, satu bertanggung jawab untuk bentuk, yang lain untuk ekspresi.  Vektor parameter ini untuk pengguna dan avatar akan selalu memiliki sendiri.  Pengguna memiliki satu vektor parameter formulir, avatar memiliki yang berbeda.  Namun, kita dapat membuat vektor yang bertanggung jawab atas ekspresi menjadi sama untuk mereka.  Kami akan mengambil parameter yang bertanggung jawab untuk ekspresi wajah pengguna, dan cukup menggantinya ke dalam model avatar.  Dengan demikian kami akan mentransfer ekspresi wajah pengguna ke avatar. <br><br>  Mari kita bicara tentang dua tantangan di bidang ini: kecepatan kerja dan model cacat yang terbatas. <br><br><img src="https://habrastorage.org/webt/d8/s6/q8/d8s6q8yjlm76pcdoa2p4pavf-vw.jpeg"><br><br>  Kecepatan benar-benar masalah.  Meminimalkan fungsi energi total adalah tugas yang sangat intensif secara komputasi.  Secara khusus, dapat berlangsung dari 20 hingga 40, rata-rata 30 detik.  Ini sudah cukup lama.  Jika kita membangun model tiga dimensi hanya pada titik-titik kunci, itu akan menjadi jauh lebih cepat, tetapi kualitas akan menderita karenanya. <br><br><img src="https://habrastorage.org/webt/wk/se/zq/wksezqkjmdzs3v25feuanneaf84.jpeg"><br><br>  Bagaimana cara mengatasi masalah ini?  Anda dapat menggunakan lebih banyak sumber daya, beberapa orang menyelesaikan masalah ini pada GPU.  Hanya poin-poin kunci yang dapat digunakan, tetapi kualitas akan menurun.  Dan Anda dapat menggunakan metode pembelajaran mesin. <br><br><img src="https://habrastorage.org/webt/p2/8m/fa/p28mfavfwitizfwss5fhreauviq.jpeg"><br><br>  Mari kita lihat secara berurutan.  Ini adalah karya tahun 2016, di mana ekspresi wajah pengguna ditransfer ke video tertentu, Anda dapat mengontrol video menggunakan wajah Anda.  Di sini, konstruksi model 3D dilakukan secara real time menggunakan GPU. <br><br><img src="https://habrastorage.org/webt/dn/qx/yj/dnqxyjywcjbx5yus2v7pvcyq8vm.jpeg"><br><br>  Berikut adalah metode yang menggunakan pembelajaran mesin.  Idenya adalah kita pertama-tama dapat mengambil basis wajah yang besar, untuk setiap wajah menggunakan algoritma yang panjang namun akurat untuk membangun model 3D, menampilkan setiap model sebagai satu set parameter, dan kemudian melatih grid untuk memprediksi parameter ini.  Secara khusus, dalam karya ini tahun 2016, ResNet digunakan, yang mengambil gambar ke input, dan memberikan parameter model ke output. <br><br><img src="https://habrastorage.org/webt/p6/ng/t6/p6ngt6gzn-4mps27709zhmeuzwk.jpeg"><br><br>  Model tiga dimensi dapat direpresentasikan dengan cara lain.  Dalam karya 2017 ini, model 3D disajikan bukan sebagai satu set parameter, tetapi sebagai satu set voxel.  Jaringan memprediksi voxel, mengubah gambar menjadi representasi tiga dimensi.  Perlu dicatat bahwa opsi pelatihan jaringan dimungkinkan untuk mana model 3D tidak diperlukan sama sekali. <br><br><img src="https://habrastorage.org/webt/yw/__/ot/yw__otysknuehp7kdjgikvziijc.jpeg"><br><br>  Ini berfungsi sebagai berikut.  Di sini bagian yang paling penting adalah layer, yang dapat mengambil parameter model yang dapat dideformasi sebagai input dan membuat gambar.  Ini memiliki properti yang luar biasa sehingga Anda dapat melakukan propagasi kesalahan kembali.  Jaringan menerima gambar sebagai input, memprediksi parameter, mengumpankan parameter ini ke lapisan yang membuat gambar, membandingkan gambar ini dengan input, menerima kesalahan, menyebarkan kembali kesalahan dan terus belajar.  Dengan demikian, jaringan belajar untuk memprediksi parameter model tiga dimensi, hanya memiliki gambar sebagai data pelatihan.  Dan itu sangat menarik. <br><br><img src="https://habrastorage.org/webt/m_/kx/vc/m_kxvcoekvrrgp41k410ikd_viu.jpeg"><br><br>  Kami berbicara banyak tentang akurasi - khususnya, bahwa itu menderita jika kita membuang beberapa istilah dari fungsi energi.  Mari memformalkan apa artinya ini, bagaimana Anda dapat mengevaluasi akurasi rekonstruksi wajah 3D.  Untuk melakukan ini, kita membutuhkan pindaian kebenaran kebenaran yang diperoleh dengan menggunakan peralatan khusus, menggunakan metode sehubungan dengan yang ada beberapa jaminan keakuratan.  Jika pangkalan seperti itu ada, maka kita dapat membandingkan model yang direkonstruksi dengan kebenaran dasar.  Ini dilakukan dengan sederhana: kami menghitung jarak rata-rata dari simpul model kami, yang kami bangun, ke simpul-simpul dalam kebenaran dasar, dan menormalkan kembali ukuran pemindaian.  Ini harus dilakukan karena wajah berbeda, ada yang lebih besar, ada yang lebih kecil, dan kesalahan pada wajah kecil akan lebih kecil, hanya karena wajah itu sendiri lebih kecil.  Oleh karena itu, diperlukan normalisasi. <br><br><img src="https://habrastorage.org/webt/a0/us/rq/a0usrqlogscnks2yygnrestgf9o.jpeg"><br><br>  Saya ingin berbicara tentang pekerjaan kami, itu akan ada di bengkel, ada ECCV.  Kami melakukan hal serupa, kami mengajarkan MobileNet untuk memprediksi parameter model yang dapat dideformasi.  Sebagai data pelatihan, kami menggunakan model 3D yang dibuat untuk foto-foto dari dataset 300W.  Mengevaluasi akurasi berdasarkan pemindaian BU4DFE. <br><br><img src="https://habrastorage.org/webt/oa/db/ha/oadbhaivdnukffi7vcdwye8vsmu.jpeg"><br><br>  Inilah hasilnya.  Kami membandingkan dua algoritma kami dengan yang paling canggih.  Kurva kuning pada grafik ini adalah algoritma yang membutuhkan waktu 30 detik dan terdiri dari meminimalkan fungsi energi total.  Di sini sepanjang sumbu X adalah kesalahan yang baru saja kita bicarakan, jarak rata-rata antara simpul.  Sumbu Y adalah sebagian kecil dari gambar di mana kesalahan ini lebih kecil dari pada sumbu X. Dalam grafik ini, semakin tinggi kurva, semakin baik.  Kurva berikutnya adalah jaringan berbasis MobileNet kami.  Selanjutnya, tiga karya yang kami bicarakan.  Parameter jaringan prediksi dan jaringan prediksi voxel. <br><br><img src="https://habrastorage.org/webt/p3/ku/82/p3ku82pa5bgvee5_k7mj2w5bfne.jpeg"><br><br>  Kami juga membandingkan jaringan kami dengan rekan-rekan dalam hal ukuran dan kecepatan model.  Ini adalah kemenangan karena kami menggunakan MobileNet, yang cukup mudah. <br><br>  Tantangan kedua adalah keterbatasan model yang dapat dideformasi. <br><br><img src="https://habrastorage.org/webt/u1/6a/9j/u16a9jeq3vc6lvwvc0hu82ymqd8.jpeg"><br><br>  Perhatikan wajah kiri, lihat sayap hidung.  Ada bayangan di sayap hidung.  Batas-batas bayangan tidak sesuai dengan batas hidung pada foto, sehingga diperoleh cacat.  Alasan untuk ini adalah bahwa model yang dapat dideformasi, pada prinsipnya, tidak dapat membangun hidung dari bentuk yang diperlukan, karena model yang dapat dideformasi ini diperoleh dari pemindaian hanya 200 wajah.  Kami ingin hidungnya benar, seperti pada foto yang tepat.  Dengan demikian, kita perlu entah bagaimana melampaui kerangka model yang dapat dideformasi. <br><br><img src="https://habrastorage.org/webt/eh/83/a5/eh83a5w3ovjb0t3v0d3slmazsgc.jpeg"><br><br>  Ini dapat dilakukan dengan menggunakan deformasi mesh nonparametrik.  Berikut adalah tiga tugas yang ingin kami selesaikan: memodifikasi bagian lokal wajah, seperti hidung, lalu mengintegrasikannya ke dalam model asli wajah, dan meskipun begitu segala sesuatu yang lain tetap tidak berubah. <br><br><img src="https://habrastorage.org/webt/kr/dt/j5/krdtj5freppwfivlapbiqtlyz-y.jpeg"><br><br>  Ini bisa dilakukan sebagai berikut.  Mari kita kembali ke penunjukan mesh sebagai vektor dalam ruang 3n-dimensi dan melihat operator rata-rata.  Ini adalah operator yang di S dengan header menggantikan setiap titik dengan rata-rata tetangganya.  Tetangga puncak adalah mereka yang terhubung ke tepi. <br><br>  Kami akan mendefinisikan fungsi energi tertentu yang menggambarkan posisi simpul relatif terhadap tetangganya.  Kami ingin posisi puncak relatif terhadap tetangganya tetap tidak berubah, atau setidaknya tidak banyak berubah.  Tetapi pada saat yang sama, kita akan entah bagaimana memodifikasi S. Fungsi energi ini disebut internal, karena juga akan ada beberapa istilah eksternal, yang akan mengatakan bahwa, misalnya, hidung harus mengambil bentuk tertentu. <br><br><img src="https://habrastorage.org/webt/9r/0g/-o/9r0g-o4tyxpzkzgfl_3bx7_xjue.jpeg"><br><br>  Teknik-teknik tersebut digunakan, misalnya, dalam karya 2015.  Mereka melakukan rekonstruksi wajah 3D dari beberapa foto.  Kami mengambil beberapa foto dari telepon, menerima point cloud, dan kemudian mengadaptasi model wajah ke cloud ini menggunakan modifikasi non-parametrik. <br><br><img src="https://habrastorage.org/webt/1q/9c/yh/1q9cyhw6dspqkz57ese7dwbezyc.jpeg"><br><br>  Anda dapat melampaui model terdeformasi dengan cara lain.  Mari kita memikirkan tindakan operator smoothing.  Di sini, untuk kesederhanaan, mesh dua dimensi disajikan dimana operator ini telah diterapkan.  Ada banyak detail pada model di sebelah kiri, pada model di sebelah kanan, detail ini telah dihaluskan.  Tetapi bisakah kita melakukan sesuatu untuk menambahkan detail daripada menghapusnya? <br><br><img src="https://habrastorage.org/webt/5k/je/ir/5kjeirpdi5wtjeapi2v6h7tsxm8.jpeg"><br><br>          .          . <br><br>      ?    -:     -  .                   .      ,     2016 .     ,  . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421353/">https://habr.com/ru/post/id421353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421341/index.html">Valve ingin memastikan bahwa semua game Windows berjalan di Linux</a></li>
<li><a href="../id421343/index.html">Melindungi Data Cloud Microsoft Office 365 dengan Veeam</a></li>
<li><a href="../id421345/index.html">Angular: fitur penyeleksi direktif yang tidak jelas</a></li>
<li><a href="../id421347/index.html">CORS, CSP, HTTPS, HSTS: Tentang Teknologi Keamanan Web</a></li>
<li><a href="../id421349/index.html">Mengembangkan Aplikasi Web Nothing Progressive dalam 15 Menit</a></li>
<li><a href="../id421355/index.html">Go 1.11 Diluncurkan - Modul WebAssembly dan Asli</a></li>
<li><a href="../id421357/index.html">Untuk pertanyaan yang tidak mungkin. Bagian 3</a></li>
<li><a href="../id421359/index.html">Festival itu seperti permainan. Taksonomi orang TI</a></li>
<li><a href="../id421361/index.html">AMD telah membuka kode sumber untuk V-EZ, sebuah lintas-platform, shell Vulkan level rendah</a></li>
<li><a href="../id421365/index.html">Evolusi satu startup. Agile dari Yaytselov ke Chiken Invaders</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>