<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíß üåπ üßîüèª Pemrograman Berorientasi Protokol, Bagian 3 üöº üë©üèæ‚Äçüîß üê†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel terakhir tentang pemrograman berorientasi protokol. 


 Pada bagian ini, kita akan melihat bagaimana variabel tipe umum disimpan dan disalin d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman Berorientasi Protokol, Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474830/"><p>  Artikel terakhir tentang pemrograman berorientasi protokol. </p><br><p>  Pada bagian ini, kita akan melihat bagaimana variabel tipe umum disimpan dan disalin dan bagaimana metode pengiriman bekerja dengannya. </p><a name="habracut"></a><br><h2 id="neobobschennaya-versiya">  Versi tidak dibagi </h2><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line = <span class="hljs-type"><span class="hljs-type">Line</span></span>() drawACopy(line) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>() drawACopy(point)</code> </pre> <br><p>  Kode yang sangat sederhana.  <code>drawACopy</code> mengambil parameter tipe Drawable dan memanggil metode <code>drawACopy</code> - itu saja. </p><br><h2 id="obobschennaya-versiya">  Versi umum </h2><br><p>  Mari kita lihat versi umum dari kode di atas: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } ...</code> </pre> <br><p>  Sepertinya tidak ada yang berubah.  Kita masih bisa memanggil fungsi <code>drawACopy</code> , sebagai versi <code>drawACopy</code> , dan tidak lebih, tetapi yang paling menarik seperti biasa di bawah tenda. <br>  Kode umum memiliki dua fitur penting: </p><br><ol><li>  polimorfisme statis (juga dikenal sebagai parametrik) </li><li>  tipe yang didefinisikan dan unik dalam konteks panggilan (tipe T umum didefinisikan pada waktu kompilasi) </li></ol><br><p>  Pertimbangkan ini dengan sebuah contoh: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { bar(local) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo(point)</code> </pre> <br><p>  Bagian yang paling menarik dimulai ketika kita memanggil fungsi <code>foo</code> .  Kompiler tahu persis jenis <code>point</code> variabel - itu hanya Point.  Selain itu, T: tipe Drawable dalam fungsi <code>foo</code> dapat disimpulkan secara bebas oleh kompiler sejak kita melewati variabel tipe Point yang diketahui ke fungsi ini: T = Point.  Semua tipe diketahui pada waktu kompilasi dan kompiler dapat melakukan semua optimasinya yang luar biasa - hal yang paling penting adalah mengatur panggilan <code>foo</code> . </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">This</span></span>: ```swift <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) foo&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point) <span class="hljs-type"><span class="hljs-type">Becomes</span></span> this: ```swift bar&lt;<span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;(point)</code> </pre> <br><p>  Kompiler hanya menyematkan <code>foo</code> call dengan implementasinya dan menampilkan tipe generik T: Drawable bar juga.  Dengan kata lain, kompiler pertama-tama menyematkan panggilan ke metode foo dengan tipe T = Point, kemudian menyematkan hasil dari embedding sebelumnya - metode bar dengan tipe T = Point. </p><br><h2 id="realizaciya-obobschennyh-metodov">  Penerapan metode generik </h2><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  Secara internal, <code>drawACopy</code> Swift menggunakan tabel metode protokol (yang berisi semua implementasi metode T) dan tabel siklus hidup (yang berisi semua metode siklus hidup untuk instance T).  Dalam pseudocode, tampilannya seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T, pwt: T.PWT, vwt: T.VWT)</span></span></span></span> {...} drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>.pwt, <span class="hljs-type"><span class="hljs-type">Point</span></span>.vwt)</code> </pre> <br><p>  VWT dan PWT adalah tipe terkait (tipe terkait) dalam T - sebagai tipe alias (typealias), hanya lebih baik.  Point.pwt dan Point.vwt adalah properti statis. </p><br><p>  Karena dalam contoh kita T adalah Point, T didefinisikan dengan baik, oleh karena itu, pembuatan wadah tidak diperlukan.  Dalam versi <code>drawACopy</code> (lokal: Drawable), pembuatan wadah eksistensial dilakukan seperlunya - kami memeriksa ini di bagian kedua artikel. </p><br><p>  Tabel siklus hidup diperlukan dalam fungsi karena pembuatan argumen.  Seperti yang kita ketahui, argumen dalam Swift dikirimkan melalui nilai, bukan melalui tautan, oleh karena itu, mereka harus disalin, dan metode salin untuk argumen ini milik tabel siklus hidup seperti argumen ini.  Ada juga metode siklus hidup lainnya di sana: mengalokasikan, merusak dan membatalkan alokasi. </p><br><p>  Tabel siklus hidup diperlukan dalam fungsi generik karena penggunaan metode untuk parameter kode generik. </p><br><h2 id="obobschennyy-ili-neobobschennyy">  Disamaratakan atau tidak digeneralisasikan? </h2><br><p>  Benarkah menggunakan tipe generik membuat eksekusi kode lebih cepat daripada hanya menggunakan tipe protokol?  Apakah fungsi yang digeneralisasi <code>func foo&lt;T: Drawable&gt;(arg: T)</code> lebih cepat dari pada protokol-like <code>fun foo(arg: Drawable)</code> ? </p><br><p>  Kami memperhatikan bahwa kode generik memberikan bentuk polimorfisme yang lebih statis.  Ini juga termasuk optimisasi kompiler yang disebut "Generic Code Specialization."  Mari kita lihat: </p><br><p>  Sekali lagi kami memiliki kode yang sama: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-function">&lt;T: Drawable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: T)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Spesialisasi fungsi generik membuat salinan dengan tipe generik khusus dari fungsi ini.  Misalnya, jika kita memanggil <code>drawACopy</code> dengan variabel tipe Point, maka kompiler akan membuat versi khusus dari fungsi ini - <code>drawACopyOfPoint</code> (lokal: Point), dan kita mendapatkan: </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Point)</span></span></span></span> { local.draw() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopyOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Line)</span></span></span></span> { local.draw() } drawACopy(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...)) drawACopt(<span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Apa yang bisa dikurangi dengan optimasi penyusun mentah sebelum ini: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Point</span></span>(...).draw() <span class="hljs-type"><span class="hljs-type">Line</span></span>(...).draw()</code> </pre> <br><p>  Semua trik ini tersedia karena fungsi generik hanya dapat dipanggil jika semua tipe generik didefinisikan - dalam metode <code>drawACopy</code> tipe generik (T) didefinisikan dengan baik. </p><br><h2 id="obobschennye-hranimye-svoystva">  Properti Tersimpan Generik </h2><br><p>  Pertimbangkan pasangan struct sederhana: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(fst: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...), snd: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...))</code> </pre> <br><p>  Ketika kita menggunakan ini dengan cara ini, kita mendapatkan 2 alokasi pada heap (kondisi memori yang tepat dalam skenario ini dijelaskan di bagian kedua), tetapi kita dapat menghindari ini dengan bantuan kode umum. </p><br><p>  Versi generik Pair terlihat seperti ini: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fst: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> snd: <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre> <br><p>  Dari saat tipe T didefinisikan dalam versi umum, tipe properti <code>fst</code> dan <code>snd</code> sama dan juga didefinisikan.  Karena jenisnya didefinisikan, kompiler dapat mengalokasikan sejumlah memori khusus untuk dua properti ini - <code>fst</code> dan <code>snd</code> . </p><br><p>  Secara lebih rinci tentang jumlah memori khusus: </p><br><p>  ketika kami bekerja dengan <code>Pair</code> versi <code>fst</code> , tipe properti <code>fst</code> dan <code>snd</code> dapat ditarik.  Semua jenis dapat berhubungan dengan Drawable, bahkan jika itu membutuhkan memori 10 KB.  Artinya, Swift tidak akan dapat menarik kesimpulan tentang ukuran jenis ini dan akan menggunakan lokasi memori universal, misalnya, wadah eksistensial.  Jenis apa pun dapat disimpan dalam wadah ini.  Dalam kasus kode generik, jenisnya dikenali dengan baik, ukuran sebenarnya dari properti juga dapat dikenali, dan Swift dapat membuat lokasi memori khusus.  Misalnya (versi umum): </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Point</span></span>(...), <span class="hljs-type"><span class="hljs-type">Point</span></span>(...))</code> </pre> <br><p>  Tipe T sekarang Point.  Point mengambil N byte dari memori dan di Pair kita dapatkan dua di antaranya.  Swift akan mengalokasikan 2 * N jumlah memori dan menempatkan <code>pair</code> sana. </p><br><p>  Jadi, dengan versi umum Pair, kami membuang alokasi yang tidak perlu pada heap, karena tipe mudah dikenali dan dapat ditemukan secara khusus - tanpa perlu membuat templat memori universal, karena semuanya diketahui. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><h3 id="1-specializirovannyy-obobschennyy-kod---tipy-znacheniy">  1. Kode Generik Khusus - Jenis Nilai </h3><br><p>  memiliki kecepatan eksekusi terbaik, karena: </p><br><ul><li>  tidak ada alokasi tumpukan saat menyalin </li><li>  kode generik - Anda menulis fungsi untuk jenis khusus </li><li>  tidak ada penghitungan referensi </li><li>  metode pengiriman statis </li></ul><br><h3 id="2-specializirovannyy-obobschennyy-kod---ssylochnye-tipy">  2. Kode generalisasi khusus - tipe referensi </h3><br><p>  Ini memiliki kecepatan eksekusi rata-rata, karena: </p><br><ul><li>  alokasi per heap saat instantiating </li><li>  ada hitungan referensi </li><li>  pengiriman metode dinamis melalui tabel virtual </li></ul><br><h3 id="3-nespecializirovannyy-obobschennyy-kod---malenkie-znacheniya">  3. Kode umum non-khusus - nilai kecil </h3><br><ul><li>  tidak ada alokasi tumpukan - nilai ditempatkan di buffer nilai penampung eksistensial </li><li>  tidak ada penghitungan referensi (karena tidak ada yang ditempatkan di heap) </li><li>  metode dinamis mengirim melalui tabel protokol-metode </li></ul><br><h3 id="4-nespecializirovannyy-obobschennyy-kod---bolshie-znacheniya">  4. Kode umum non-khusus - nilai besar </h3><br><ul><li>  penempatan di heap - nilai ditempatkan di buffer nilai </li><li>  ada hitungan referensi </li><li>  pengiriman dinamis melalui tabel protokol-metode </li></ul><br><p>  Materi ini tidak berarti bahwa kelas buruk, struktur baik, dan struktur dalam kombinasi dengan kode umum adalah yang terbaik.  Kami ingin mengatakan bahwa sebagai seorang programmer, Anda memiliki tanggung jawab untuk memilih alat untuk tugas-tugas Anda.  Kelas benar-benar baik ketika Anda perlu menyimpan nilai-nilai besar dan ada semantik tautan.  Struktur adalah yang terbaik untuk nilai-nilai kecil dan ketika Anda membutuhkan semantiknya.  Protokol paling cocok untuk kode dan struktur generik, dan sebagainya.  Semua alat khusus untuk tugas yang Anda selesaikan, dan memiliki sisi positif dan negatif. </p><br><p>  Dan juga <strong>jangan membayar dinamisme saat Anda tidak membutuhkannya</strong> .  Temukan abstraksi yang tepat dengan persyaratan runtime minimum. </p><br><ul><li>  tipe struktural - semantik makna </li><li>  tipe kelas - identitas </li><li>  kode umum - polimorfisme statis </li><li>  tipe protokol - polimorfisme dinamis </li></ul><br><p>  Gunakan penyimpanan tidak langsung untuk bekerja dengan nilai besar. </p><br><p>  Dan jangan lupa - itu adalah tanggung jawab Anda untuk memilih alat yang tepat. <br>  Terima kasih atas perhatian Anda pada topik ini.  Kami harap artikel ini membantu Anda dan menarik. </p><br><p>  <strong>Semoga beruntung</strong> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474830/">https://habr.com/ru/post/id474830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474814/index.html">Antiquities: messenger dari pembusukan atau keusangan yang tidak direncanakan</a></li>
<li><a href="../id474816/index.html">Proyek kesayangan - kehidupan kecil</a></li>
<li><a href="../id474818/index.html">Apakah ada angka acak di CSS?</a></li>
<li><a href="../id474822/index.html">WISE-PaaS - platform cloud untuk berbagai hal industri Internet</a></li>
<li><a href="../id474826/index.html">Tabel normal dalam penurunan harga</a></li>
<li><a href="../id474832/index.html">Bagaimana kriptografi kurva eliptik bekerja di TLS 1.3</a></li>
<li><a href="../id474838/index.html">SIBUR Challenge 2019 - Kompetisi Analisis Data Industri</a></li>
<li><a href="../id474840/index.html">Apa yang mereka pelajari dalam kekhususan Ilmu Data di universitas asing</a></li>
<li><a href="../id474842/index.html">Kasus: Layanan mobil. Pengembangan kampanye iklan dan implementasi Bitrix24</a></li>
<li><a href="../id474844/index.html">Dell XPS 13 7390: laptop yang sangat ringkas bagi mereka yang sering bekerja di luar kantor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>