<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏽 👩🏾‍🎤 🎒 Pelajari OpenGL. Pelajaran 5.7 - HDR 🕥 👧🏽 🌳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat menulis ke framebuffer, nilai-nilai kecerahan warna dikurangi ke interval dari 0,0 ke 1,0. Karena itu, pada pandangan pertama tidak berbahaya, ki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelajari OpenGL. Pelajaran 5.7 - HDR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420409/"><img src="https://habrastorage.org/getpro/habr/post_images/20f/e6a/5f3/20fe6a5f38cfacad9ea8355ca097e8f4.png" width="200" align="left"><br><p>  Saat menulis ke framebuffer, nilai-nilai kecerahan warna dikurangi ke interval dari 0,0 ke 1,0.  Karena itu, pada pandangan pertama tidak berbahaya, kita harus selalu memilih nilai untuk pencahayaan dan warna yang sesuai dengan batasan ini.  Pendekatan ini bekerja dan memberikan hasil yang layak, tetapi apa yang terjadi jika kita bertemu daerah yang sangat terang dengan banyak sumber cahaya terang, dan total kecerahan melebihi 1,0?  Akibatnya, semua nilai yang lebih besar dari 1.0 akan dikonversi ke 1.0, yang tidak terlihat bagus: </p><br><p><img src="https://habrastorage.org/webt/cd/0m/ir/cd0mir8t9qcbakfwldnjibj3ay0.png"></p><br><p>  Karena nilai warna dikurangi menjadi 1,0 untuk sejumlah besar fragmen, area besar gambar diisi dengan warna putih yang sama, sejumlah besar detail gambar hilang, dan gambar itu sendiri mulai terlihat tidak wajar. </p><br><p>  Solusi untuk masalah ini mungkin dengan mengurangi kecerahan sumber cahaya sehingga tidak ada fragmen yang lebih terang dari 1,0 di atas panggung: ini bukan solusi terbaik, yang memaksa penggunaan nilai pencahayaan yang tidak realistis.  Pendekatan terbaik adalah untuk memungkinkan nilai kecerahan untuk sementara melebihi kecerahan 1,0 dan pada langkah terakhir mengubah warna sehingga kecerahan kembali ke kisaran 0,0 hingga 1,0, tetapi tanpa kehilangan detail gambar. </p><br><p>  Layar komputer mampu menampilkan warna dengan kecerahan mulai dari 0,0 hingga 1,0, tetapi kami tidak memiliki batasan seperti itu saat menghitung pencahayaan.  Dengan memungkinkan warna fragmen menjadi lebih terang daripada satu kesatuan, kami mendapatkan rentang kecerahan yang jauh lebih tinggi untuk bekerja - HDR <em>(rentang dinamis tinggi)</em> .  Dengan hdr, hal-hal yang cerah terlihat cerah, hal-hal yang gelap dapat menjadi sangat gelap, dan dengan melakukan itu kita akan melihat detailnya. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text"><p>  Bagian 1. Memulai <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo segitiga</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transformasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem koordinat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kamera</a> </li></ol><br><p>  Bagian 2. Pencahayaan dasar <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-dasar pencahayaan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber cahaya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berbagai Sumber Penerangan</a> </li></ol><br><p>  Bagian 3. Unduh model 3D <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Polygon Mesh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Model 3D</a> </li></ol><br><p>  Bagian 4. Fitur OpenGL Lanjutan <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes kedalaman</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes stensil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencampuran warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memotong wajah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buffer bingkai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu kubik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan data tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLSL tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader geometris</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instancing</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghaluskan</a> </li></ol><br><p>  Bagian 5. Pencahayaan Lanjut <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencahayaan tingkat lanjut.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koreksi gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu bayangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta bayangan omnidirectional</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan paralaks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Render yang ditangguhkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSAO</a> </li></ol><br><p>  Bagian 6. PBR <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber Cahaya Analitik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iradiasi difus.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paparan cermin.</a> </li></ol></div></div><br><p>  Awalnya, rentang dinamis tinggi digunakan dalam fotografi: fotografer mengambil beberapa foto identik adegan dengan eksposur berbeda, menangkap warna dari hampir semua kecerahan.  Kombinasi dari foto-foto ini membentuk gambar HDR di mana sebagian besar detail menjadi terlihat karena kombinasi gambar dengan kehilangan eksposur yang berbeda.  Misalnya, di bawah ini di gambar kiri fragmen gambar yang sangat terang terlihat jelas (lihat jendela), tetapi detail ini hilang saat menggunakan eksposur tinggi.  Namun, pencahayaan yang tinggi membuat detail pada area gelap gambar yang tidak terlihat sebelumnya. </p><br><p><img src="https://habrastorage.org/webt/hh/-0/0h/hh-00hpoeday-yolbntasroul14.png"></p><br><p>  Ini mirip dengan cara kerja mata manusia.  Dengan kurangnya cahaya, mata beradaptasi, sehingga detail gelap menjadi terlihat jelas, dan juga untuk area terang.  Dapat dikatakan bahwa mata manusia memiliki kontrol eksposur otomatis, tergantung pada kecerahan pemandangan. </p><br><p>  Render HDR bekerja dengan cara yang hampir sama.  Kami mengizinkan ketika rendering menggunakan rentang besar nilai kecerahan untuk mengumpulkan informasi tentang detail terang dan gelap adegan, dan pada akhirnya kami akan mengonversi nilai dari rentang HDR kembali ke LDR (rentang dinamis rendah, berkisar dari 0 hingga 1).  Transformasi ini disebut <em>pemetaan nada</em> , ada sejumlah besar algoritma yang bertujuan untuk mempertahankan sebagian besar detail gambar ketika mengkonversi ke LDR.  Algoritma ini sering memiliki pengaturan pencahayaan yang memungkinkan mereka untuk menampilkan area gambar yang terang atau gelap dengan lebih baik. </p><br><p>  Menggunakan HDR saat rendering memungkinkan kita tidak hanya melebihi rentang LDR dari 0 hingga 1 dan menyimpan lebih banyak detail gambar, tetapi juga memungkinkan untuk menunjukkan kecerahan nyata dari sumber cahaya.  Misalnya, matahari memiliki kecerahan cahaya yang jauh lebih besar daripada sesuatu seperti senter, jadi mengapa tidak mengatur matahari untuk ini (misalnya, berikan kecerahan 10,0)?  Ini akan memungkinkan kita untuk menyesuaikan pencahayaan pemandangan dengan lebih baik dengan parameter kecerahan yang lebih realistis, yang tidak mungkin dilakukan dengan rendering LDR dan rentang kecerahan dari 0 hingga 1. </p><br><p>  Karena layar hanya menampilkan kecerahan dari 0 hingga 1, kami dipaksa untuk mengubah rentang nilai HDR yang digunakan kembali ke kisaran monitor.  Cukup dengan menskalakan rentang tidak akan menjadi solusi yang baik, karena area terang akan mulai mendominasi gambar.  Namun, kita dapat menggunakan berbagai persamaan atau kurva untuk mengubah nilai HDR ke LDR, yang akan memberi kita kendali penuh atas kecerahan pemandangan.  Transformasi ini disebut <em>pemetaan nada</em> dan merupakan langkah terakhir dalam rendering HDR. </p><br><h3 id="freymbufery-s-plavayuschey-tochkoy">  Framebuffer titik mengambang </h3><br><p>  Untuk menerapkan rendering HDR, kita perlu cara untuk mencegah nilai dibawa ke rentang dari 0 hingga 1 dari shader fragmen.  Jika framebuffer menggunakan format titik tetap (GL_RGB) yang dinormalisasi untuk buffer warna, maka OpenGL secara otomatis membatasi nilai-nilai sebelum menyimpan ke framebuffer.  Pembatasan ini berlaku untuk sebagian besar format framebuffer kecuali format floating point. </p><br><p> Untuk menyimpan nilai yang berada di luar rentang [0.0..1.0], kita dapat menggunakan buffer warna dengan format berikut: <code>GL_RGB16F, GL_RGBA16F, GL_RGB32F or GL_RGBA32F</code> .  Ini bagus untuk rendering hdr.  Buffer semacam itu akan disebut framebuffer floating point. </p><br><p>  Membuat buffer titik mengambang berbeda dari buffer biasa hanya karena menggunakan format internal yang berbeda: </p><br><pre> <code class="plaintext hljs">glBindTexture(GL_TEXTURE_2D, colorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);</code> </pre> <br><p>  Framebuffer OpenGL secara default hanya menggunakan 8 bit untuk menyimpan setiap warna.  Dalam framebuffer floating point dengan format <code>GL_RGBA32F</code> atau <code>GL_RGBA32F</code> , 32 bit digunakan untuk menyimpan setiap warna - 4 kali lebih banyak.  Jika akurasi sangat tinggi tidak diperlukan, maka format <code>GL_RGBA16F</code> akan cukup memadai. </p><br><p>  Jika buffer titik mengambang dilampirkan ke framebuffer untuk warna, kita dapat membuat adegan ke dalamnya dengan mempertimbangkan bahwa nilai warna tidak akan terbatas pada rentang dari 0 hingga 1. Dalam kode untuk artikel ini, pertama-tama kita membuat adegan ke framebuffer titik mengambang dan kemudian menampilkan konten buffer warna pada persegi panjang setengah layar.  Itu terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // [...]    hdr glBindFramebuffer(GL_FRAMEBUFFER, 0); //  hdr    2     hdrShader.use(); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, hdrColorBufferTexture); RenderQuad();</code> </pre> <br><p>  Di sini nilai warna yang terkandung dalam buffer warna mungkin lebih besar dari 1. Untuk artikel ini, sebuah adegan dibuat dengan kubus memanjang besar yang terlihat seperti terowongan dengan empat titik sumber cahaya, salah satunya terletak di ujung terowongan dan memiliki kecerahan yang sangat baik. </p><br><pre> <code class="plaintext hljs">std::vector&lt;glm::vec3&gt; lightColors; lightColors.push_back(glm::vec3(200.0f, 200.0f, 200.0f)); lightColors.push_back(glm::vec3(0.1f, 0.0f, 0.0f)); lightColors.push_back(glm::vec3(0.0f, 0.0f, 0.2f)); lightColors.push_back(glm::vec3(0.0f, 0.1f, 0.0f));</code> </pre> <br><p>  Render ke buffer floating point persis sama seperti jika kami rendering adegan ke framebuffer biasa.  Satu-satunya hal baru adalah shader hdr terfragmentasi, yang berkaitan dengan shading sederhana persegi panjang layar penuh dengan nilai-nilai dari tekstur, yang merupakan buffer warna titik-mengambang.  Untuk memulai, mari menulis shader sederhana yang mentransfer data input tidak berubah: </p><br><pre> <code class="plaintext hljs">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D hdrBuffer; void main() { vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; FragColor = vec4(hdrColor, 1.0); }</code> </pre> <br><p>  Kami mengambil input dari titik mengambang buffer warna dan menggunakannya sebagai nilai output shader.  Namun, karena persegi panjang 2D dirender ke dalam framebuffer secara default, nilai-nilai output dari shader akan terbatas pada interval dari 0 hingga 1, meskipun pada kenyataannya beberapa nilai lebih besar dari 1 di beberapa tempat. </p><br><p><img src="https://habrastorage.org/webt/rw/mb/ds/rwmbdsi_qc8fjdssulhqwwzk3rg.png"></p><br><p>  Menjadi jelas bahwa nilai warna yang terlalu besar di ujung terowongan terbatas pada kesatuan, karena sebagian besar gambar benar-benar putih, dan kami kehilangan detail gambar yang lebih terang daripada kesatuan.  Karena kami menggunakan nilai HDR secara langsung sebagai LDR, ini setara dengan tidak memiliki HDR.  Untuk memperbaikinya, kita harus menampilkan nilai warna yang berbeda kembali dari 0 hingga 1 tanpa kehilangan detail dalam gambar.  Untuk melakukan ini, terapkan kompresi tonal. </p><br><h3 id="tonalnaya-kompressiya">  Kompresi nada </h3><br><p>  Kompresi nada adalah konversi nilai warna agar sesuai dengan kisaran 0 hingga 1 tanpa kehilangan detail gambar, sering kali dikombinasikan dengan memberikan gambar white balance yang diinginkan. </p><br><p>  Algoritma <em>pemetaan nada</em> paling sederhana dikenal sebagai algoritma <em>pemetaan nada Reinhard</em> .  Ini menampilkan nilai HDR dalam rentang LDR.  Tambahkan algoritma ini ke shader fragmen sebelumnya, dan juga terapkan koreksi gamma (dan penggunaan tekstur SRGB). </p><br><pre> <code class="plaintext hljs">void main() { const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; //   vec3 mapped = hdrColor / (hdrColor + vec3(1.0)); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</code> </pre> <br><blockquote>  Catatan  trans.  - untuk nilai x yang kecil, fungsi x / (1 + x) berperilaku kira-kira seperti x, untuk x besar cenderung menyatu.  Grafik fungsi: </blockquote><p><img src="https://habrastorage.org/webt/sz/oq/ao/szoqaojobtfzh5_m5htgu_nh2_y.png"></p><br><p>  Dengan kompresi nada Reinhardt, kami tidak lagi kehilangan detail di area gambar yang terang.  Algoritma lebih memilih area yang terang, membuat area yang gelap menjadi kurang berbeda. </p><br><p><img src="https://habrastorage.org/webt/jm/um/3c/jmum3cplqvaaqwhh96nzrrlhuc4.png"></p><br><p>  Di sini Anda dapat kembali melihat detail di akhir gambar, seperti tekstur kayu.  Dengan algoritma yang relatif sederhana ini, kita dapat dengan jelas melihat warna dari rentang HDR dan dapat mengontrol pencahayaan adegan tanpa kehilangan detail gambar. </p><br><blockquote>  Perlu dicatat bahwa kita dapat menggunakan kompresi tonal langsung di akhir shader untuk menghitung pencahayaan, dan kemudian kita tidak memerlukan framebuffer floating point sama sekali.  Namun, dalam adegan yang lebih kompleks, Anda akan sering menghadapi kebutuhan untuk menyimpan nilai-nilai HDR menengah dalam buffer floating point, jadi ini akan berguna. </blockquote><p>  Fitur lain yang menarik dari kompresi nada adalah penggunaan parameter eksposur.  Anda mungkin ingat bahwa dalam gambar di awal artikel berbagai detail terlihat pada nilai eksposur yang berbeda.  Jika kita memiliki pemandangan di mana siang dan malam berubah, masuk akal untuk menggunakan pencahayaan rendah di siang hari dan tinggi di malam hari, yang mirip dengan adaptasi mata manusia.  Dengan parameter pencahayaan ini, kami dapat mengonfigurasi parameter pencahayaan yang akan berfungsi siang dan malam di bawah kondisi pencahayaan yang berbeda. </p><br><p>  Algoritma kompresi tonal yang relatif sederhana dengan paparan seperti ini: </p><br><pre> <code class="plaintext hljs">uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; //     vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</code> </pre> <br><blockquote>  Catatan  per: tambahkan grafik untuk fungsi ini dengan eksposur 1 dan 2: </blockquote><p><img src="https://habrastorage.org/webt/3j/fj/zi/3jfjzibpldumgonxyhin6ydi-ao.png"></p><br><p>  Di sini kami mendefinisikan variabel untuk pencahayaan, yaitu 1 secara default dan memungkinkan kami untuk lebih akurat memilih keseimbangan antara kualitas tampilan area gelap dan terang pada gambar.  Misalnya, dengan eksposur besar, kita melihat lebih detail di area gelap gambar.  Sebaliknya, eksposur rendah membuat area gelap tidak dapat dibedakan, tetapi memungkinkan Anda untuk lebih baik melihat area terang pada gambar.  Di bawah ini adalah gambar sebuah terowongan dengan tingkat eksposur yang berbeda. </p><br><p><img src="https://habrastorage.org/webt/ae/kx/vf/aekxvfxdggv34kzeqcoxy9tjdps.png"></p><br><p>  Gambar-gambar ini jelas menunjukkan manfaat rendering hdr.  Saat level eksposur berubah, kita melihat lebih detail dari adegan yang akan hilang dalam rendering normal.  Ambil ujung terowongan sebagai contoh - dengan eksposur normal, tekstur pohon hampir tidak terlihat, tetapi dengan eksposur rendah, tekstur terlihat sempurna.  Demikian pula, pada paparan tinggi, detail di area gelap sangat jelas terlihat. </p><br><p>  Kode sumber untuk demo ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </p><br><h3 id="bolshe-hdr">  Lebih banyak HDR </h3><br><p>  Kedua algoritma kompresi nada yang telah ditampilkan hanya sebagian kecil di antara sejumlah besar algoritma yang lebih maju, yang masing-masing memiliki kekuatan dan kelemahannya sendiri.  Beberapa algoritma lebih baik menekankan warna / kecerahan tertentu, beberapa algoritma menunjukkan area gelap dan terang pada saat yang sama, memberikan gambar yang lebih penuh warna dan detail.  Ada juga banyak metode yang dikenal sebagai <em>penyesuaian eksposur otomatis</em> atau <em>adaptasi mata</em> .  Mereka menentukan kecerahan adegan di bingkai sebelumnya dan (perlahan) mengubah parameter pencahayaan, sehingga adegan gelap perlahan menjadi lebih terang, dan terang - gelap: mirip dengan pembiasaan mata manusia. </p><br><p>  Manfaat nyata HDR paling baik dilihat pada adegan besar dan kompleks dengan algoritma pencahayaan yang serius.  Untuk tujuan pelatihan, artikel ini menggunakan adegan sesederhana mungkin, karena membuat adegan besar mungkin sulit.  Meskipun kesederhanaan adegan, beberapa keuntungan dari rendering hdr terlihat di sana: di area gelap dan terang gambar, detail tidak hilang, karena mereka disimpan menggunakan kompresi nada, penambahan beberapa sumber cahaya tidak mengarah pada tampilan area putih, dan nilainya tidak harus sesuai dengan LDR jangkauan. </p><br><p>  Selain itu, rendering HDR juga membuat beberapa efek menarik lebih dapat dipercaya dan realistis.  Salah satu efek ini adalah mekar, yang akan kita bahas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> mendatang. </p><br><h3 id="dopolnitelnye-resursy">  Sumber daya tambahan: </h3><br><ul><li>  Sebuah pertanyaan stackexchange dengan jawaban panjang yang menggambarkan beberapa manfaat rendering HDR: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah rendering HDR memiliki manfaat jika bloom tidak diterapkan?</a> </li><li>  Jawaban menarik lainnya dengan gambar yang bagus sebagai contoh kompresi nada.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu pemetaan nada?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana hubungannya dengan HDR?</a> </li></ul><br><p>  <strong>PS</strong> Kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telegram conf</a> untuk koordinasi transfer.  Jika Anda memiliki keinginan serius untuk membantu penerjemahan, maka Anda dipersilakan! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420409/">https://habr.com/ru/post/id420409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420393/index.html">PHP, YII2 dan pembentukan file excel besar</a></li>
<li><a href="../id420395/index.html">Tablet "gratis" untuk tahanan - sama sekali tidak gratis</a></li>
<li><a href="../id420397/index.html">Para ilmuwan telah menemukan cara untuk membalikkan proses penuaan sel</a></li>
<li><a href="../id420405/index.html">Meneliti Proses Penjualan TI</a></li>
<li><a href="../id420407/index.html">C bukan bahasa tingkat rendah</a></li>
<li><a href="../id420413/index.html">SQLite dan NW.js - petunjuk langkah demi langkah untuk menciptakan persahabatan yang kuat</a></li>
<li><a href="../id420415/index.html">Segala sesuatu yang ingin Anda ketahui tentang pengujian adaptor Wi-Fi, tetapi takut untuk bertanya</a></li>
<li><a href="../id420419/index.html">Pelari untuk mereka yang suka penghinaan atau bagaimana kami mengubah dan memodifikasi PixJam</a></li>
<li><a href="../id420423/index.html">Masalah antarmuka crossing darat</a></li>
<li><a href="../id420425/index.html">Teori dan praktik menggunakan HBase</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>