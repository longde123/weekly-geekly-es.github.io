<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐴 🗽 🧝🏻 Zeiger sind komplex oder was ist in einem Byte gespeichert? ➕ 🥨 🖕🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "Zeiger sind kompliziert oder: Was ist in einem Byte?" Urheberschaft von Ralf Jung. 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeiger sind komplex oder was ist in einem Byte gespeichert?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460953/"><p>  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels "Zeiger sind kompliziert oder: Was ist in einem Byte?"  Urheberschaft von Ralf Jung. </p><br><p>  Diesen Sommer arbeite ich wieder ganztägig an Rust und werde (unter anderem) wieder an einem „Speichermodell“ für Rust / MIR arbeiten.  Bevor ich jedoch über meine Ideen spreche, muss ich endlich den Mythos zerstreuen, dass "Zeiger einfach sind: Sie sind nur Zahlen".  Beide Teile dieser Aussage sind fehlerhaft, zumindest in Sprachen mit unsicheren Merkmalen wie Rust oder C: Zeiger können weder als Primzahlen noch als (gewöhnliche) Zahlen bezeichnet werden. </p><br><p>  Ich möchte auch den Teil des Speichermodells diskutieren, der angesprochen werden muss, bevor wir über die komplexeren Teile sprechen können: In <em>welcher Form werden die</em> Daten im Speicher gespeichert?  Ein Speicher besteht aus Bytes, minimal adressierbaren Einheiten und den kleinsten Elementen, auf die zugegriffen werden kann (zumindest auf den meisten Plattformen). Was sind jedoch die möglichen Bytewerte?  Wieder stellt sich heraus, dass "es ist nur eine 8-Bit-Zahl" nicht als Antwort geeignet ist. <a name="habracut"></a></p><br><p>  Ich hoffe, dass Sie mir nach dem Lesen dieses Beitrags in Bezug auf beide Aussagen zustimmen. </p><br><h1 id="ukazateli-slozhny">  Zeiger sind kompliziert </h1><br><p>  Was ist das Problem mit "Zeiger sind reguläre Zahlen"?  Schauen wir uns das folgende Beispiel an: (Ich verwende hier C ++, da das Schreiben von unsicherem Code in C ++ einfacher ist als das Schreiben in Rust, und unsicherer Code nur der Ort ist, an dem die Probleme auftreten. Unsicheres Rust und C haben dieselben Probleme wie das und C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Die Optimierung des letzten Lesevorgangs von y [0] mit einer Rückgabe von 42 ist immer sehr vorteilhaft.  Der Grund für diese Optimierung ist, dass das Ändern von x_ptr, das auf x zeigt, y nicht ändern kann. </p><br><p>  Wenn wir uns jedoch mit einfachen Sprachen wie C ++ befassen, können wir diese Annahme verletzen, indem wir i den Wert yx zuweisen.  Da &amp; x [i] dasselbe ist wie x + i, schreiben wir 23 in &amp; y [0]. </p><br><p>  Dies hindert C ++ - Compiler natürlich nicht daran, solche Optimierungen vorzunehmen.  Um dies zu beheben, sagt der Standard, dass unser Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB hat</a> . </p><br><p>  Erstens ist es nicht zulässig, arithmetische Operationen an Zeigern durchzuführen (wie im Fall von &amp; x [i]), wenn in diesem Fall der Zeiger <a href="">eine der Grenzen des Arrays überschreitet</a> .  Unser Programm verstößt gegen diese Regel: x [i] geht über x hinaus, es ist also UB.  Mit anderen Worten, selbst die <em>Berechnung</em> des x_ptr-Werts ist UB, sodass wir nicht einmal an die Stelle gelangen, an der wir diesen Zeiger verwenden möchten. </p><br><p>  (Es stellt sich heraus, dass i = yx auch UB ist, da <a href="">nur Zeiger, die auf dieselbe Speicherzuordnung</a> zeigen <a href="">, subtrahiert</a> werden <a href="">dürfen</a> . Wir könnten jedoch i = ((size_t) y - (size_t) x) / sizeof (int) schreiben, um zu umgehen Dies ist eine Einschränkung.) </p><br><p>  Aber wir sind noch nicht fertig: Diese Regel hat die einzige Ausnahme, die wir zu unserem Vorteil nutzen können.  Wenn die arithmetische Operation den Wert des Zeigers auf die Adresse <em>genau nach dem</em> Ende des Arrays berechnet, ist alles in Ordnung.  (Diese Ausnahme wird benötigt, um vec.end () für die häufigsten Schleifen in C ++ 98 zu berechnen.) </p><br><p>  Lassen Sie uns das Beispiel ein wenig ändern: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Stellen Sie sich nun vor, dass x und y <em>nacheinander</em> zugewiesen wurden, wobei y eine größere Adresse hat.  Dann zeigt x_ptr <em>auf den Anfang von</em> y!  Dann ist die Bedingung wahr und die Zuordnung erfolgt.  Gleichzeitig gibt es keine UB aufgrund des Austritts des Zeigers ins Ausland. </p><br><p>  Dies scheint keine Optimierung zu ermöglichen.  Der C ++ - Standard hat jedoch ein weiteres Ass im Ärmel, um Compiler-Erstellern zu helfen: Tatsächlich erlaubt es uns nicht, x_ptr zu verwenden.  Gemäß den Angaben des Standards zum <a href="">Hinzufügen von Zahlen zu Zeigern</a> zeigt x_ptr auf die Adresse nach dem letzten Element des Arrays.  Es <em>zeigt nicht</em> auf ein bestimmtes Element eines anderen Objekts, <em>selbst wenn diese dieselbe Adresse haben</em> .  (Zumindest ist dies eine gängige Interpretation des Standards, auf dessen Grundlage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM diesen Code optimiert</a> .) </p><br><p>  Und obwohl x_ptr und &amp; y [0] auf dieselbe <em>Adresse zeigen</em> , werden sie dadurch nicht zum <em>selben Zeiger</em> , dh sie können nicht austauschbar verwendet werden: &amp; y [0] zeigt auf das erste Element von y;  x_ptr zeigt auf die Adresse nach x.  Wenn wir * x_ptr = 23 durch die Zeichenfolge * &amp; y [0] = 0 ersetzen, ändern wir den Wert des Programms, obwohl die beiden Zeiger auf Gleichheit überprüft wurden. </p><br><p>  Dies ist es wert, wiederholt zu werden: </p><br><blockquote>  Nur weil zwei Zeiger auf dieselbe Adresse zeigen, bedeutet dies nicht, dass sie gleich sind und austauschbar verwendet werden können. </blockquote><p>  Ja, dieser Unterschied ist schwer zu fassen.  Tatsächlich führt dies immer noch zu Unterschieden bei Programmen, die mit LLVM und GCC kompiliert wurden. </p><br><p>  Beachten Sie auch, dass diese One-After-Regel nicht der einzige Ort in C / C ++ ist, an dem wir einen solchen Effekt beobachten können.  Ein weiteres Beispiel ist das Schlüsselwort "Einschränken" in C, mit dem ausgedrückt werden kann, dass sich Zeiger nicht überlappen (nicht gleich sind): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  Der Aufruf test () ruft UB auf, da zwei Speicherzugriffe in foo nicht an derselben Adresse erfolgen sollten.  Wenn Sie * y durch * x in foo ersetzen, ändern wir den Wert des Programms und es wird UB nicht mehr aufgerufen.  Noch einmal: Obwohl x und y dieselbe Adresse haben, können sie nicht austauschbar verwendet werden. </p><br><p>  Zeiger sind definitiv nicht nur Zahlen. </p><br><h1 id="prostaya-model-ukazateley">  Einfaches Zeigermodell </h1><br><p>  Was ist ein Zeiger?  Ich kenne die vollständige Antwort nicht.  In der Tat ist dies ein offener Bereich für die Forschung. </p><br><p>  Ein wichtiger Punkt: Hier betrachten wir ein <em>abstraktes</em> Zeigermodell.  Auf einem echten Computer sind Zeiger natürlich Zahlen.  Ein echter Computer führt jedoch nicht die Optimierungen durch, die moderne C ++ - Compiler vornehmen.  Wenn wir die obigen Programme in Assembler schreiben würden, gäbe es keine UB, keine Optimierungen.  C ++ und Rust verfolgen einen "übergeordneten" Ansatz für Speicher und Zeiger und beschränken den Programmierer auf den Compiler.  Wenn Sie formal beschreiben müssen, was ein Programmierer in diesen Sprachen tun kann und was nicht, ist das Modell der Zeiger als Zahlen zerbrochen, sodass wir etwas anderes finden müssen.  Dies ist ein weiteres Beispiel für die Verwendung einer "virtuellen Maschine", die sich von einem realen Computer für Spezifikationszwecke unterscheidet - eine Idee, über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich zuvor geschrieben habe</a> . </p><br><p>  Hier ist ein einfacher Satz (tatsächlich wird dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeigermodell</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompCert</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meiner Arbeit von RustBelt verwendet</a> sowie die Art und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weise</a> , wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Miri-Interpreter</a> <a href="">Zeiger</a> implementiert): Ein Zeiger ist ein Paar einer ID, die einen Speicherbereich eindeutig identifiziert (Zuordnung), und der Versatz ist relativ zu dieser Bereich.  Wenn Sie dies in Rust schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  Die Operationen zum Hinzufügen (Subtrahieren) einer Zahl zu einem Zeiger (von einem Zeiger) wirken sich nur auf den Versatz aus, und daher kann der Zeiger den Speicherbereich niemals verlassen.  Das Subtrahieren von Zeigern ist nur möglich, wenn sie zum selben Speicherbereich gehören (gemäß <a href="">C ++</a> ). </p><br><p>  (Wie wir sehen können, wendet der C ++ - Standard diese Regeln auf Arrays an, nicht auf Speicherbereiche. LLVM wendet sie jedoch auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereichsebene an</a> .) </p><br><p>  Es stellt sich heraus (und Miri zeigt dasselbe), dass dieses Modell uns gute Dienste leisten kann.  Wir erinnern uns immer daran, zu welchem ​​Speicherbereich der Zeiger gehört, sodass wir den nachfolgenden Zeiger eines Speicherbereichs vom Zeiger auf den Anfang eines anderen Bereichs unterscheiden können.  So kann miri feststellen, dass unser zweites Beispiel (mit &amp; x [8]) UB hat. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Unser Modell fällt auseinander </h1><br><p>  In unserem Modell sind Zeiger, obwohl sie keine Zahlen sind, zumindest einfach.  Dieses Modell wird jedoch vor unseren Augen auseinanderfallen, sobald Sie sich an die Umwandlung von Zeigern in Zahlen erinnern.  In miri bewirkt das Umsetzen eines Zeigers auf eine Zahl eigentlich nichts. Wir erhalten lediglich eine numerische Variable (d. H. Ihr <em>Typ</em> sagt, dass es sich um eine Zahl handelt), deren <em>Wert</em> ein Zeiger ist (d. H. Ein Paar aus Speicherbereich und Versatz).  Das Multiplizieren dieser Zahl mit 2 führt jedoch zu einem Fehler, da völlig unklar ist, was es bedeutet, "einen solchen abstrakten Zeiger mit 2 zu multiplizieren". </p><br><p>  Ich muss klarstellen: Dies ist <em>keine</em> gute Lösung, wenn es darum geht, die Semantik einer Sprache zu definieren.  Dies funktioniert jedoch gut für den Interpreter.  Dies ist der einfachste Ansatz, und wir haben ihn gewählt, weil nicht klar ist, wie dies anders gemacht werden kann (außer um solche Reduzierungen überhaupt nicht zu unterstützen - aber mit ihrer Unterstützung kann miri mehr Programme ausführen): In unserer abstrakten Maschine gibt es keinen einzigen "Adressraum". in dem sich alle zugewiesenen Speicherbereiche befinden würden und alle Zeiger auf bestimmte unterschiedliche Nummern abgebildet wurden.  Jeder Speicherbereich wird durch eine (versteckte) ID identifiziert.  Jetzt können wir beginnen, unserem Modell zusätzliche Daten hinzuzufügen, wie z. B. die Basisadresse für jeden Speicherbereich, und sie irgendwie verwenden, um die Nummer wieder auf den Zeiger zu bringen ... und an diesem Punkt wird der Prozess wirklich sehr kompliziert und auf jeden Fall eine Diskussion darüber Modelle sind nicht der Zweck, einen Beitrag zu schreiben.  Ziel ist es, die Notwendigkeit eines solchen Modells zu erörtern.  Wenn Sie interessiert sind, empfehle ich Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Dokument zu</a> lesen, in dem die obige Idee des Hinzufügens einer Basisadresse näher erläutert wird. </p><br><p>  Kurz gesagt, die Abgüsse von Zeigern und Zahlen zueinander sind verwirrend und angesichts der oben diskutierten Optimierungen formal schwer zu bestimmen.  Es besteht ein Konflikt zwischen dem für Optimierungen erforderlichen Ansatz auf hoher Ebene und dem Ansatz auf niedriger Ebene, der zur Beschreibung von Casting-Zeigern auf Zahlen erforderlich ist, und umgekehrt.  Zum größten Teil ignorieren wir dieses Problem in miri einfach und versuchen, wann immer möglich, mit dem einfachen Modell, mit dem wir arbeiten, so viel wie möglich zu tun.  Eine vollständige Definition von Sprachen wie C ++ oder Rust kann natürlich nicht so einfach sein, sondern sollte erklären, was wirklich passiert.  Soweit ich weiß, gibt es keine geeignete Lösung, aber die akademische Forschung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nähert sich der Wahrheit</a> . </p><br><p>  Deshalb sind Zeiger auch nicht einfach. </p><br><h1 id="ot-ukazateley-k-baytam">  Von Zeigern zu Bytes </h1><br><p>  Ich hoffe, ich habe ein überzeugendes Argument vorgebracht, dass Zahlen nicht der einzige Datentyp sind, der berücksichtigt werden muss, wenn wir Low-Level-Sprachen wie C ++ oder den (unsicheren) Teil von Rust formal beschreiben möchten.  Dies bedeutet jedoch, dass eine einfache Operation wie das Lesen eines Bytes aus dem Speicher nicht einfach u8 zurückgeben kann.  Stellen Sie sich vor, wir <a href="">implementieren memcpy,</a> indem wir jedes Byte der Quelle nacheinander in eine lokale Variable v lesen und diesen Wert dann am Zielspeicherort speichern.  Was aber, wenn dieses Byte Teil eines Zeigers ist?  Wenn der Zeiger ein Paar aus Speicherbereichs-ID und Offset ist, welches ist dann sein erstes Byte?  Wir müssen sagen, was der Wert von v ist, also müssen wir diese Frage irgendwie beantworten.  (Und dies ist ein völlig anderes Problem als das Problem mit der Multiplikation, das im vorherigen Abschnitt beschrieben wurde. Wir gehen nur davon aus, dass es einen abstrakten Typ von Ponter gibt.) </p><br><p>  Wir können das Byte des Zeigers nicht als Wert des Bereichs 0..256 darstellen (Hinweis: Im Folgenden wird 0 aktiviert, 256 nicht).  Wenn wir ein naives Speicherrepräsentationsmodell verwenden, geht im Allgemeinen der zusätzliche „versteckte“ Teil des Zeigers (der ihn zu mehr als nur einer Zahl macht) verloren, wenn der Zeiger in den Speicher geschrieben und daraus erneut gelesen wird.  Wir müssen dies beheben und dafür unser Konzept des „Bytes“ erweitern, um diesen zusätzlichen Zustand darzustellen.  Somit ist das Byte nun <em>entweder der</em> Wert des Bereichs 0..256 ("Rohbits") <em>oder</em> das n-te Byte eines abstrakten Zeigers.  Wenn wir unser Speichermodell in Rust implementieren müssten, könnte es so aussehen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  Beispielsweise repräsentiert PtrFragment (ptr, 0) das erste Byte des ptr-Zeigers.  Somit kann memcpy den Zeiger in separate Bytes "zerlegen", die diesen Zeiger im Speicher darstellen, und sie einzeln kopieren.  In einer 32-Bit-Architektur enthält die vollständige ptr-Darstellung 4 Byte: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  Diese Darstellung unterstützt alle Operationen zum Verschieben von Daten über Zeiger auf Byte-Ebene, was für die Speicherung völlig ausreicht.  Arithmetik- oder Bitoperationen werden nicht vollständig unterstützt.  Wie oben erwähnt, würde dies eine komplexere Darstellung von Zeigern erfordern. </p><br><h1 id="neinicializirovannaya-pamyat">  Nicht initialisierter Speicher </h1><br><p>  Wir haben jedoch unsere Definition von "Byte" noch nicht abgeschlossen.  Um das Verhalten des Programms vollständig zu beschreiben, müssen wir eine andere Option in Betracht ziehen: Ein Byte im Speicher kann nicht <em>initialisiert werden</em> .  Die Definition des letzten Bytes sieht folgendermaßen aus (nehmen wir an, wir haben einen Zeigertyp für Zeiger): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  Wir verwenden den Uninit-Wert für alle Bytes im zugewiesenen Speicher, in die wir noch keinen Wert geschrieben haben.  Es ist möglich, nicht initialisierten Speicher ohne Probleme zu lesen, aber alle anderen <em>Aktionen</em> mit diesen Bytes (z. B. numerische Arithmetik) führen zu UB. </p><br><p>  Dies ist den LLVM-Regeln in Bezug auf den speziellen Giftwert sehr ähnlich.  Beachten Sie, dass LLVM <em>auch</em> einen undef-Wert hat, der für nicht initialisierten Speicher verwendet wird und etwas anders funktioniert.  Das Kompilieren unserer Uninit zu undef ist jedoch korrekt (undef ist in gewisser Weise „schwächer“), und es gibt Vorschläge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, undef aus LLVM zu entfernen und stattdessen Gift zu verwenden</a> . </p><br><p>  Sie fragen sich vielleicht, warum wir überhaupt einen besonderen Uninit-Wert haben.  Warum nicht für jedes neue Byte ein beliebiges b: u8 auswählen und dann Bits (b) als Anfangswert verwenden?  Dies ist wirklich eine Option.  Zunächst kamen jedoch alle Compiler zu diesem Ansatz, indem sie einen speziellen Wert für nicht initialisierten Speicher verwendeten.  Wenn Sie diesen Ansatz nicht befolgen, werden nicht nur Kompilierungsprobleme durch LLVM verursacht, sondern auch alle Optimierungen überprüft und sichergestellt, dass sie mit diesem modifizierten Modell ordnungsgemäß funktionieren.  Der entscheidende Punkt hier: Sie können Uninit immer sicher durch einen anderen Wert ersetzen: Jede Operation, die diesen Wert empfängt, führt in jedem Fall zu UB. </p><br><p>  Zum Beispiel ist dieser C-Code mit Uninit einfacher zu optimieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  Mit Uninit können wir leicht sagen, dass x entweder einen Uninit-Wert oder einen Wert von 1 hat, und da das Ersetzen von Uninit durch 1 funktioniert, ist die Optimierung leicht zu erklären.  Ohne Uninit ist x entweder „eine Art beliebiges Bitmuster“ oder 1, und dieselbe Optimierung ist schwerer zu erklären. </p><br><p>  (Wir können argumentieren, dass wir Operationen austauschen können, wenn wir eine nicht deterministische Entscheidung treffen, aber dann müssen wir beweisen, dass der schwer zu analysierende Code in keiner Weise x verwendet. Uninit vermeidet dieses Problem mit unnötigen Beweisen.) </p><br><p>  Schließlich ist Uninit die beste Wahl für Dolmetscher wie miri.  Solche Interpreter haben Probleme mit Operationen wie „Wählen Sie einfach einen dieser Werte aus“ (dh nicht deterministische Operationen), da sie dazu neigen, alle möglichen Pfade der Programmausführung zu durchlaufen, was bedeutet, dass sie alle möglichen Werte ausprobieren müssen.  Die Verwendung von Uninit anstelle eines beliebigen Bitmusters bedeutet, dass miri Ihnen nach einem Programmlauf mitteilen kann, ob Ihr Programm nicht initialisierte Werte falsch verwendet. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Wir haben gesehen, dass in Sprachen wie C ++ und Rust (im Gegensatz zu echten Computern) Zeiger unterschiedlich sein können, selbst wenn sie auf dieselbe Adresse verweisen, und dass ein Byte mehr als nur eine Zahl im Bereich 0..256 ist.  Wenn die C-Sprache 1978 "portabler Assembler" sein könnte, ist dies jetzt eine unglaublich falsche Aussage. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460953/">https://habr.com/ru/post/de460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460943/index.html">So wählen Sie vielversprechende Schlüssel für SEO basierend auf Szenarioprognosen in Google Data Studio (+ Vorlage)</a></li>
<li><a href="../de460945/index.html">Erfahrung in der Verwendung eines Telegrammkanals zur Steigerung der Bekanntheit und des Umsatzwachstums eines Spielestudios</a></li>
<li><a href="../de460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../de460949/index.html">„Und das Unmögliche ist möglich“: Wir verwandeln eine Black Box mithilfe einer binären Analyse in Weiß</a></li>
<li><a href="../de460951/index.html">Erstellen Sie Android Live Wallpapers</a></li>
<li><a href="../de460955/index.html">Bildungsprogramm zur Übergabe von Parametern nach Wert an Konstruktoren und Setter (modernes C ++, Beispiele)</a></li>
<li><a href="../de460959/index.html">Mit der neuen Technologie von Microsoft können 3D-Kopien einer realen Person jede Sprache sprechen</a></li>
<li><a href="../de460961/index.html">Einrichten von Unit-Tests in gemischten Swift + Objective-C-Projekten</a></li>
<li><a href="../de460965/index.html">Split Controller ohne diese Ihre Storyboards</a></li>
<li><a href="../de460967/index.html">Troy Hunt: 10 persönliche Finanzstunden für IT-Profis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>