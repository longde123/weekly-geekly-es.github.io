<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¥ üóΩ üßùüèª Zeiger sind komplex oder was ist in einem Byte gespeichert? ‚ûï ü•® üñïüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Zeiger sind kompliziert oder: Was ist in einem Byte?" Urheberschaft von Ralf Jung. 


...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zeiger sind komplex oder was ist in einem Byte gespeichert?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460953/"><p>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Zeiger sind kompliziert oder: Was ist in einem Byte?"  Urheberschaft von Ralf Jung. </p><br><p>  Diesen Sommer arbeite ich wieder ganzt√§gig an Rust und werde (unter anderem) wieder an einem ‚ÄûSpeichermodell‚Äú f√ºr Rust / MIR arbeiten.  Bevor ich jedoch √ºber meine Ideen spreche, muss ich endlich den Mythos zerstreuen, dass "Zeiger einfach sind: Sie sind nur Zahlen".  Beide Teile dieser Aussage sind fehlerhaft, zumindest in Sprachen mit unsicheren Merkmalen wie Rust oder C: Zeiger k√∂nnen weder als Primzahlen noch als (gew√∂hnliche) Zahlen bezeichnet werden. </p><br><p>  Ich m√∂chte auch den Teil des Speichermodells diskutieren, der angesprochen werden muss, bevor wir √ºber die komplexeren Teile sprechen k√∂nnen: In <em>welcher Form werden die</em> Daten im Speicher gespeichert?  Ein Speicher besteht aus Bytes, minimal adressierbaren Einheiten und den kleinsten Elementen, auf die zugegriffen werden kann (zumindest auf den meisten Plattformen). Was sind jedoch die m√∂glichen Bytewerte?  Wieder stellt sich heraus, dass "es ist nur eine 8-Bit-Zahl" nicht als Antwort geeignet ist. <a name="habracut"></a></p><br><p>  Ich hoffe, dass Sie mir nach dem Lesen dieses Beitrags in Bezug auf beide Aussagen zustimmen. </p><br><h1 id="ukazateli-slozhny">  Zeiger sind kompliziert </h1><br><p>  Was ist das Problem mit "Zeiger sind regul√§re Zahlen"?  Schauen wir uns das folgende Beispiel an: (Ich verwende hier C ++, da das Schreiben von unsicherem Code in C ++ einfacher ist als das Schreiben in Rust, und unsicherer Code nur der Ort ist, an dem die Probleme auftreten. Unsicheres Rust und C haben dieselben Probleme wie das und C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Die Optimierung des letzten Lesevorgangs von y [0] mit einer R√ºckgabe von 42 ist immer sehr vorteilhaft.  Der Grund f√ºr diese Optimierung ist, dass das √Ñndern von x_ptr, das auf x zeigt, y nicht √§ndern kann. </p><br><p>  Wenn wir uns jedoch mit einfachen Sprachen wie C ++ befassen, k√∂nnen wir diese Annahme verletzen, indem wir i den Wert yx zuweisen.  Da &amp; x [i] dasselbe ist wie x + i, schreiben wir 23 in &amp; y [0]. </p><br><p>  Dies hindert C ++ - Compiler nat√ºrlich nicht daran, solche Optimierungen vorzunehmen.  Um dies zu beheben, sagt der Standard, dass unser Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UB hat</a> . </p><br><p>  Erstens ist es nicht zul√§ssig, arithmetische Operationen an Zeigern durchzuf√ºhren (wie im Fall von &amp; x [i]), wenn in diesem Fall der Zeiger <a href="">eine der Grenzen des Arrays √ºberschreitet</a> .  Unser Programm verst√∂√üt gegen diese Regel: x [i] geht √ºber x hinaus, es ist also UB.  Mit anderen Worten, selbst die <em>Berechnung</em> des x_ptr-Werts ist UB, sodass wir nicht einmal an die Stelle gelangen, an der wir diesen Zeiger verwenden m√∂chten. </p><br><p>  (Es stellt sich heraus, dass i = yx auch UB ist, da <a href="">nur Zeiger, die auf dieselbe Speicherzuordnung</a> zeigen <a href="">, subtrahiert</a> werden <a href="">d√ºrfen</a> . Wir k√∂nnten jedoch i = ((size_t) y - (size_t) x) / sizeof (int) schreiben, um zu umgehen Dies ist eine Einschr√§nkung.) </p><br><p>  Aber wir sind noch nicht fertig: Diese Regel hat die einzige Ausnahme, die wir zu unserem Vorteil nutzen k√∂nnen.  Wenn die arithmetische Operation den Wert des Zeigers auf die Adresse <em>genau nach dem</em> Ende des Arrays berechnet, ist alles in Ordnung.  (Diese Ausnahme wird ben√∂tigt, um vec.end () f√ºr die h√§ufigsten Schleifen in C ++ 98 zu berechnen.) </p><br><p>  Lassen Sie uns das Beispiel ein wenig √§ndern: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Stellen Sie sich nun vor, dass x und y <em>nacheinander</em> zugewiesen wurden, wobei y eine gr√∂√üere Adresse hat.  Dann zeigt x_ptr <em>auf den Anfang von</em> y!  Dann ist die Bedingung wahr und die Zuordnung erfolgt.  Gleichzeitig gibt es keine UB aufgrund des Austritts des Zeigers ins Ausland. </p><br><p>  Dies scheint keine Optimierung zu erm√∂glichen.  Der C ++ - Standard hat jedoch ein weiteres Ass im √Ñrmel, um Compiler-Erstellern zu helfen: Tats√§chlich erlaubt es uns nicht, x_ptr zu verwenden.  Gem√§√ü den Angaben des Standards zum <a href="">Hinzuf√ºgen von Zahlen zu Zeigern</a> zeigt x_ptr auf die Adresse nach dem letzten Element des Arrays.  Es <em>zeigt nicht</em> auf ein bestimmtes Element eines anderen Objekts, <em>selbst wenn diese dieselbe Adresse haben</em> .  (Zumindest ist dies eine g√§ngige Interpretation des Standards, auf dessen Grundlage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM diesen Code optimiert</a> .) </p><br><p>  Und obwohl x_ptr und &amp; y [0] auf dieselbe <em>Adresse zeigen</em> , werden sie dadurch nicht zum <em>selben Zeiger</em> , dh sie k√∂nnen nicht austauschbar verwendet werden: &amp; y [0] zeigt auf das erste Element von y;  x_ptr zeigt auf die Adresse nach x.  Wenn wir * x_ptr = 23 durch die Zeichenfolge * &amp; y [0] = 0 ersetzen, √§ndern wir den Wert des Programms, obwohl die beiden Zeiger auf Gleichheit √ºberpr√ºft wurden. </p><br><p>  Dies ist es wert, wiederholt zu werden: </p><br><blockquote>  Nur weil zwei Zeiger auf dieselbe Adresse zeigen, bedeutet dies nicht, dass sie gleich sind und austauschbar verwendet werden k√∂nnen. </blockquote><p>  Ja, dieser Unterschied ist schwer zu fassen.  Tats√§chlich f√ºhrt dies immer noch zu Unterschieden bei Programmen, die mit LLVM und GCC kompiliert wurden. </p><br><p>  Beachten Sie auch, dass diese One-After-Regel nicht der einzige Ort in C / C ++ ist, an dem wir einen solchen Effekt beobachten k√∂nnen.  Ein weiteres Beispiel ist das Schl√ºsselwort "Einschr√§nken" in C, mit dem ausgedr√ºckt werden kann, dass sich Zeiger nicht √ºberlappen (nicht gleich sind): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  Der Aufruf test () ruft UB auf, da zwei Speicherzugriffe in foo nicht an derselben Adresse erfolgen sollten.  Wenn Sie * y durch * x in foo ersetzen, √§ndern wir den Wert des Programms und es wird UB nicht mehr aufgerufen.  Noch einmal: Obwohl x und y dieselbe Adresse haben, k√∂nnen sie nicht austauschbar verwendet werden. </p><br><p>  Zeiger sind definitiv nicht nur Zahlen. </p><br><h1 id="prostaya-model-ukazateley">  Einfaches Zeigermodell </h1><br><p>  Was ist ein Zeiger?  Ich kenne die vollst√§ndige Antwort nicht.  In der Tat ist dies ein offener Bereich f√ºr die Forschung. </p><br><p>  Ein wichtiger Punkt: Hier betrachten wir ein <em>abstraktes</em> Zeigermodell.  Auf einem echten Computer sind Zeiger nat√ºrlich Zahlen.  Ein echter Computer f√ºhrt jedoch nicht die Optimierungen durch, die moderne C ++ - Compiler vornehmen.  Wenn wir die obigen Programme in Assembler schreiben w√ºrden, g√§be es keine UB, keine Optimierungen.  C ++ und Rust verfolgen einen "√ºbergeordneten" Ansatz f√ºr Speicher und Zeiger und beschr√§nken den Programmierer auf den Compiler.  Wenn Sie formal beschreiben m√ºssen, was ein Programmierer in diesen Sprachen tun kann und was nicht, ist das Modell der Zeiger als Zahlen zerbrochen, sodass wir etwas anderes finden m√ºssen.  Dies ist ein weiteres Beispiel f√ºr die Verwendung einer "virtuellen Maschine", die sich von einem realen Computer f√ºr Spezifikationszwecke unterscheidet - eine Idee, √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich zuvor geschrieben habe</a> . </p><br><p>  Hier ist ein einfacher Satz (tats√§chlich wird dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeigermodell</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CompCert</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meiner Arbeit von RustBelt verwendet</a> sowie die Art und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weise</a> , wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Miri-Interpreter</a> <a href="">Zeiger</a> implementiert): Ein Zeiger ist ein Paar einer ID, die einen Speicherbereich eindeutig identifiziert (Zuordnung), und der Versatz ist relativ zu dieser Bereich.  Wenn Sie dies in Rust schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  Die Operationen zum Hinzuf√ºgen (Subtrahieren) einer Zahl zu einem Zeiger (von einem Zeiger) wirken sich nur auf den Versatz aus, und daher kann der Zeiger den Speicherbereich niemals verlassen.  Das Subtrahieren von Zeigern ist nur m√∂glich, wenn sie zum selben Speicherbereich geh√∂ren (gem√§√ü <a href="">C ++</a> ). </p><br><p>  (Wie wir sehen k√∂nnen, wendet der C ++ - Standard diese Regeln auf Arrays an, nicht auf Speicherbereiche. LLVM wendet sie jedoch auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereichsebene an</a> .) </p><br><p>  Es stellt sich heraus (und Miri zeigt dasselbe), dass dieses Modell uns gute Dienste leisten kann.  Wir erinnern uns immer daran, zu welchem ‚Äã‚ÄãSpeicherbereich der Zeiger geh√∂rt, sodass wir den nachfolgenden Zeiger eines Speicherbereichs vom Zeiger auf den Anfang eines anderen Bereichs unterscheiden k√∂nnen.  So kann miri feststellen, dass unser zweites Beispiel (mit &amp; x [8]) UB hat. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Unser Modell f√§llt auseinander </h1><br><p>  In unserem Modell sind Zeiger, obwohl sie keine Zahlen sind, zumindest einfach.  Dieses Modell wird jedoch vor unseren Augen auseinanderfallen, sobald Sie sich an die Umwandlung von Zeigern in Zahlen erinnern.  In miri bewirkt das Umsetzen eines Zeigers auf eine Zahl eigentlich nichts. Wir erhalten lediglich eine numerische Variable (d. H. Ihr <em>Typ</em> sagt, dass es sich um eine Zahl handelt), deren <em>Wert</em> ein Zeiger ist (d. H. Ein Paar aus Speicherbereich und Versatz).  Das Multiplizieren dieser Zahl mit 2 f√ºhrt jedoch zu einem Fehler, da v√∂llig unklar ist, was es bedeutet, "einen solchen abstrakten Zeiger mit 2 zu multiplizieren". </p><br><p>  Ich muss klarstellen: Dies ist <em>keine</em> gute L√∂sung, wenn es darum geht, die Semantik einer Sprache zu definieren.  Dies funktioniert jedoch gut f√ºr den Interpreter.  Dies ist der einfachste Ansatz, und wir haben ihn gew√§hlt, weil nicht klar ist, wie dies anders gemacht werden kann (au√üer um solche Reduzierungen √ºberhaupt nicht zu unterst√ºtzen - aber mit ihrer Unterst√ºtzung kann miri mehr Programme ausf√ºhren): In unserer abstrakten Maschine gibt es keinen einzigen "Adressraum". in dem sich alle zugewiesenen Speicherbereiche befinden w√ºrden und alle Zeiger auf bestimmte unterschiedliche Nummern abgebildet wurden.  Jeder Speicherbereich wird durch eine (versteckte) ID identifiziert.  Jetzt k√∂nnen wir beginnen, unserem Modell zus√§tzliche Daten hinzuzuf√ºgen, wie z. B. die Basisadresse f√ºr jeden Speicherbereich, und sie irgendwie verwenden, um die Nummer wieder auf den Zeiger zu bringen ... und an diesem Punkt wird der Prozess wirklich sehr kompliziert und auf jeden Fall eine Diskussion dar√ºber Modelle sind nicht der Zweck, einen Beitrag zu schreiben.  Ziel ist es, die Notwendigkeit eines solchen Modells zu er√∂rtern.  Wenn Sie interessiert sind, empfehle ich Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Dokument zu</a> lesen, in dem die obige Idee des Hinzuf√ºgens einer Basisadresse n√§her erl√§utert wird. </p><br><p>  Kurz gesagt, die Abg√ºsse von Zeigern und Zahlen zueinander sind verwirrend und angesichts der oben diskutierten Optimierungen formal schwer zu bestimmen.  Es besteht ein Konflikt zwischen dem f√ºr Optimierungen erforderlichen Ansatz auf hoher Ebene und dem Ansatz auf niedriger Ebene, der zur Beschreibung von Casting-Zeigern auf Zahlen erforderlich ist, und umgekehrt.  Zum gr√∂√üten Teil ignorieren wir dieses Problem in miri einfach und versuchen, wann immer m√∂glich, mit dem einfachen Modell, mit dem wir arbeiten, so viel wie m√∂glich zu tun.  Eine vollst√§ndige Definition von Sprachen wie C ++ oder Rust kann nat√ºrlich nicht so einfach sein, sondern sollte erkl√§ren, was wirklich passiert.  Soweit ich wei√ü, gibt es keine geeignete L√∂sung, aber die akademische Forschung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">n√§hert sich der Wahrheit</a> . </p><br><p>  Deshalb sind Zeiger auch nicht einfach. </p><br><h1 id="ot-ukazateley-k-baytam">  Von Zeigern zu Bytes </h1><br><p>  Ich hoffe, ich habe ein √ºberzeugendes Argument vorgebracht, dass Zahlen nicht der einzige Datentyp sind, der ber√ºcksichtigt werden muss, wenn wir Low-Level-Sprachen wie C ++ oder den (unsicheren) Teil von Rust formal beschreiben m√∂chten.  Dies bedeutet jedoch, dass eine einfache Operation wie das Lesen eines Bytes aus dem Speicher nicht einfach u8 zur√ºckgeben kann.  Stellen Sie sich vor, wir <a href="">implementieren memcpy,</a> indem wir jedes Byte der Quelle nacheinander in eine lokale Variable v lesen und diesen Wert dann am Zielspeicherort speichern.  Was aber, wenn dieses Byte Teil eines Zeigers ist?  Wenn der Zeiger ein Paar aus Speicherbereichs-ID und Offset ist, welches ist dann sein erstes Byte?  Wir m√ºssen sagen, was der Wert von v ist, also m√ºssen wir diese Frage irgendwie beantworten.  (Und dies ist ein v√∂llig anderes Problem als das Problem mit der Multiplikation, das im vorherigen Abschnitt beschrieben wurde. Wir gehen nur davon aus, dass es einen abstrakten Typ von Ponter gibt.) </p><br><p>  Wir k√∂nnen das Byte des Zeigers nicht als Wert des Bereichs 0..256 darstellen (Hinweis: Im Folgenden wird 0 aktiviert, 256 nicht).  Wenn wir ein naives Speicherrepr√§sentationsmodell verwenden, geht im Allgemeinen der zus√§tzliche ‚Äûversteckte‚Äú Teil des Zeigers (der ihn zu mehr als nur einer Zahl macht) verloren, wenn der Zeiger in den Speicher geschrieben und daraus erneut gelesen wird.  Wir m√ºssen dies beheben und daf√ºr unser Konzept des ‚ÄûBytes‚Äú erweitern, um diesen zus√§tzlichen Zustand darzustellen.  Somit ist das Byte nun <em>entweder der</em> Wert des Bereichs 0..256 ("Rohbits") <em>oder</em> das n-te Byte eines abstrakten Zeigers.  Wenn wir unser Speichermodell in Rust implementieren m√ºssten, k√∂nnte es so aussehen: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  Beispielsweise repr√§sentiert PtrFragment (ptr, 0) das erste Byte des ptr-Zeigers.  Somit kann memcpy den Zeiger in separate Bytes "zerlegen", die diesen Zeiger im Speicher darstellen, und sie einzeln kopieren.  In einer 32-Bit-Architektur enth√§lt die vollst√§ndige ptr-Darstellung 4 Byte: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  Diese Darstellung unterst√ºtzt alle Operationen zum Verschieben von Daten √ºber Zeiger auf Byte-Ebene, was f√ºr die Speicherung v√∂llig ausreicht.  Arithmetik- oder Bitoperationen werden nicht vollst√§ndig unterst√ºtzt.  Wie oben erw√§hnt, w√ºrde dies eine komplexere Darstellung von Zeigern erfordern. </p><br><h1 id="neinicializirovannaya-pamyat">  Nicht initialisierter Speicher </h1><br><p>  Wir haben jedoch unsere Definition von "Byte" noch nicht abgeschlossen.  Um das Verhalten des Programms vollst√§ndig zu beschreiben, m√ºssen wir eine andere Option in Betracht ziehen: Ein Byte im Speicher kann nicht <em>initialisiert werden</em> .  Die Definition des letzten Bytes sieht folgenderma√üen aus (nehmen wir an, wir haben einen Zeigertyp f√ºr Zeiger): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  Wir verwenden den Uninit-Wert f√ºr alle Bytes im zugewiesenen Speicher, in die wir noch keinen Wert geschrieben haben.  Es ist m√∂glich, nicht initialisierten Speicher ohne Probleme zu lesen, aber alle anderen <em>Aktionen</em> mit diesen Bytes (z. B. numerische Arithmetik) f√ºhren zu UB. </p><br><p>  Dies ist den LLVM-Regeln in Bezug auf den speziellen Giftwert sehr √§hnlich.  Beachten Sie, dass LLVM <em>auch</em> einen undef-Wert hat, der f√ºr nicht initialisierten Speicher verwendet wird und etwas anders funktioniert.  Das Kompilieren unserer Uninit zu undef ist jedoch korrekt (undef ist in gewisser Weise ‚Äûschw√§cher‚Äú), und es gibt Vorschl√§ge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, undef aus LLVM zu entfernen und stattdessen Gift zu verwenden</a> . </p><br><p>  Sie fragen sich vielleicht, warum wir √ºberhaupt einen besonderen Uninit-Wert haben.  Warum nicht f√ºr jedes neue Byte ein beliebiges b: u8 ausw√§hlen und dann Bits (b) als Anfangswert verwenden?  Dies ist wirklich eine Option.  Zun√§chst kamen jedoch alle Compiler zu diesem Ansatz, indem sie einen speziellen Wert f√ºr nicht initialisierten Speicher verwendeten.  Wenn Sie diesen Ansatz nicht befolgen, werden nicht nur Kompilierungsprobleme durch LLVM verursacht, sondern auch alle Optimierungen √ºberpr√ºft und sichergestellt, dass sie mit diesem modifizierten Modell ordnungsgem√§√ü funktionieren.  Der entscheidende Punkt hier: Sie k√∂nnen Uninit immer sicher durch einen anderen Wert ersetzen: Jede Operation, die diesen Wert empf√§ngt, f√ºhrt in jedem Fall zu UB. </p><br><p>  Zum Beispiel ist dieser C-Code mit Uninit einfacher zu optimieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  Mit Uninit k√∂nnen wir leicht sagen, dass x entweder einen Uninit-Wert oder einen Wert von 1 hat, und da das Ersetzen von Uninit durch 1 funktioniert, ist die Optimierung leicht zu erkl√§ren.  Ohne Uninit ist x entweder ‚Äûeine Art beliebiges Bitmuster‚Äú oder 1, und dieselbe Optimierung ist schwerer zu erkl√§ren. </p><br><p>  (Wir k√∂nnen argumentieren, dass wir Operationen austauschen k√∂nnen, wenn wir eine nicht deterministische Entscheidung treffen, aber dann m√ºssen wir beweisen, dass der schwer zu analysierende Code in keiner Weise x verwendet. Uninit vermeidet dieses Problem mit unn√∂tigen Beweisen.) </p><br><p>  Schlie√ülich ist Uninit die beste Wahl f√ºr Dolmetscher wie miri.  Solche Interpreter haben Probleme mit Operationen wie ‚ÄûW√§hlen Sie einfach einen dieser Werte aus‚Äú (dh nicht deterministische Operationen), da sie dazu neigen, alle m√∂glichen Pfade der Programmausf√ºhrung zu durchlaufen, was bedeutet, dass sie alle m√∂glichen Werte ausprobieren m√ºssen.  Die Verwendung von Uninit anstelle eines beliebigen Bitmusters bedeutet, dass miri Ihnen nach einem Programmlauf mitteilen kann, ob Ihr Programm nicht initialisierte Werte falsch verwendet. </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  Wir haben gesehen, dass in Sprachen wie C ++ und Rust (im Gegensatz zu echten Computern) Zeiger unterschiedlich sein k√∂nnen, selbst wenn sie auf dieselbe Adresse verweisen, und dass ein Byte mehr als nur eine Zahl im Bereich 0..256 ist.  Wenn die C-Sprache 1978 "portabler Assembler" sein k√∂nnte, ist dies jetzt eine unglaublich falsche Aussage. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460953/">https://habr.com/ru/post/de460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460943/index.html">So w√§hlen Sie vielversprechende Schl√ºssel f√ºr SEO basierend auf Szenarioprognosen in Google Data Studio (+ Vorlage)</a></li>
<li><a href="../de460945/index.html">Erfahrung in der Verwendung eines Telegrammkanals zur Steigerung der Bekanntheit und des Umsatzwachstums eines Spielestudios</a></li>
<li><a href="../de460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../de460949/index.html">‚ÄûUnd das Unm√∂gliche ist m√∂glich‚Äú: Wir verwandeln eine Black Box mithilfe einer bin√§ren Analyse in Wei√ü</a></li>
<li><a href="../de460951/index.html">Erstellen Sie Android Live Wallpapers</a></li>
<li><a href="../de460955/index.html">Bildungsprogramm zur √úbergabe von Parametern nach Wert an Konstruktoren und Setter (modernes C ++, Beispiele)</a></li>
<li><a href="../de460959/index.html">Mit der neuen Technologie von Microsoft k√∂nnen 3D-Kopien einer realen Person jede Sprache sprechen</a></li>
<li><a href="../de460961/index.html">Einrichten von Unit-Tests in gemischten Swift + Objective-C-Projekten</a></li>
<li><a href="../de460965/index.html">Split Controller ohne diese Ihre Storyboards</a></li>
<li><a href="../de460967/index.html">Troy Hunt: 10 pers√∂nliche Finanzstunden f√ºr IT-Profis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>