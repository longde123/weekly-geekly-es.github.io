<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ¥Ô∏è ‚¨õÔ∏è üé© Ketika panggilan fungsi eksternal lebih cepat dari panggilan C asli üïπÔ∏è üë≤üèΩ ‚òùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ditambahkan oleh: diskusi yang baik tentang Berita Peretas 

 David Yu di GitHub telah mengembangkan tes kinerja yang menarik untuk panggilan fungsi m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketika panggilan fungsi eksternal lebih cepat dari panggilan C asli</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413181/"> <font color="gray"><i>Ditambahkan oleh: diskusi yang baik tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berita Peretas</a></i></font> <br><br>  David Yu di GitHub telah mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes kinerja yang menarik</a> untuk panggilan fungsi melalui berbagai antarmuka eksternal (Foreign Function Interfaces, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FFI</a> ). <br><br>  Dia menciptakan file objek bersama ( <code>.so</code> ) dengan satu fungsi C. sederhana. Kemudian dia menulis kode untuk berulang kali memanggil fungsi ini melalui masing-masing FFI dengan dimensi waktu. <br><br>  Untuk C "FFI," ia menggunakan tautan dinamis standar, bukan <code>dlopen()</code> .  Perbedaan ini sangat penting, karena sangat mempengaruhi hasil tes.  Anda bisa berdebat seberapa jujur ‚Äã‚Äãperbandingan ini dengan FFI yang sebenarnya, tetapi masih menarik untuk diukur. <br><br>  Hasil benchmark paling mengejutkan adalah bahwa FFI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LuaJIT</a> <b>secara signifikan lebih cepat daripada C.</b>  Ini sekitar 25% lebih cepat dari panggilan C asli untuk fungsi objek bersama.  Bagaimana bahasa scripting yang lemah dan dinamis dapat mengambil alih dalam benchmark C?  Apakah hasilnya akurat? <br><a name="habracut"></a><br>  Sebenarnya, ini cukup logis.  Tes berjalan di Linux, jadi penundaan berasal dari Tabel Tautan Prosedur (PLT).  Saya menyiapkan percobaan yang sangat sederhana untuk menunjukkan efek dalam C lama: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/skeeto/dynamic-function-benchmark</a> <br><br>  Berikut adalah hasil dari Intel i7-6700 (Skylake): <br><br> <code>plt: 1.759799 ns/call <br> ind: 1.257125 ns/call <br> jit: 1.008108 ns/call</code> <br> <br>  Ada tiga jenis panggilan fungsi: <br><br><ol><li>  Melalui PLT. </li><li>  Panggilan fungsi tidak langsung (via <code>dlsym(3)</code> ) </li><li>  Panggilan fungsi langsung (melalui fungsi yang dikompilasi JIT) </li></ol><br>  Seperti yang Anda lihat, yang terakhir adalah yang tercepat.  Biasanya tidak digunakan dalam program C, tetapi ini adalah pilihan alami di hadapan kompiler JIT, termasuk, tentu saja, LuaJIT. <br><br>  Dalam tolok ukur saya, fungsi <code>empty()</code> disebut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Kompilasi ke objek bersama: <br><br><pre> <code class="cpp hljs">$ cc -shared -fPIC -Os -o empty.so empty.c</code> </pre> <br>  Seperti dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perbandingan PRNG</a> sebelumnya, benchmark sebanyak mungkin memanggil fungsi ini sebelum alarm berbunyi. <br><br><h1>  Tabel Tata Letak Prosedur </h1><br>  Ketika suatu program atau pustaka memanggil suatu fungsi di objek lain yang dibagikan, kompiler tidak bisa tahu di mana fungsi ini akan berada dalam memori.  Informasi ditemukan hanya pada saat runtime ketika program dan dependensinya dimuat ke dalam memori.  Biasanya fungsi ini terletak di tempat acak, misalnya, sesuai dengan pengacakan ruang alamat (Address Space Layout Randomization, ASLR). <br><br>  Bagaimana mengatasi masalah seperti itu?  Nah, ada beberapa opsi. <br><br>  Salah satunya adalah menandai setiap panggilan dalam metadata biner.  Pembangun runtime dinamis kemudian <i>memasukkan</i> alamat yang benar pada setiap panggilan.  Mekanisme spesifik tergantung pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model kode</a> yang digunakan selama kompilasi. <br><br>  Kelemahan dari pendekatan ini adalah memperlambat loading, meningkatkan ukuran file biner dan mengurangi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertukaran halaman kode</a> antara proses yang berbeda.  Pengunduhan diperlambat karena semua rekan panggilan dinamis perlu ditambal dengan alamat yang benar sebelum memulai program.  Biner membengkak karena setiap entri membutuhkan tempat di tabel.  Dan kurangnya berbagi dikaitkan dengan perubahan halaman kode. <br><br>  Di sisi lain, overhead dari menjalankan fungsi dinamis dapat dihilangkan, yang memberikan kinerja seperti JIT, seperti yang ditunjukkan dalam benchmark. <br><br>  Opsi kedua adalah untuk merutekan semua panggilan dinamis melalui tabel.  Rekan panggil asli merujuk ke rintisan dalam tabel ini, dan dari sana ke fungsi dinamis yang sebenarnya.  Dengan pendekatan ini, kode tidak perlu ditambal, yang mengarah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertukaran sepele</a> antara proses.  Untuk setiap fungsi dinamis, Anda perlu menambal hanya satu catatan di tabel.  Selain itu, koreksi ini dapat dilakukan dengan <i>malas</i> , pada panggilan fungsi pertama, yang mempercepat pemuatan lebih. <br><br>  Pada sistem biner ELF, tabel ini disebut Tabel Tautan Prosedur (PLT).  PLT itu sendiri tidak benar-benar diperbaiki - ini ditampilkan sebagai hanya-baca untuk sisa kode.  Sebagai gantinya, Global Offset Table (GOT) diperbaiki.  Rintisan PLT mengambil alamat fungsi dinamis dari GOT dan <i>secara tidak langsung</i> melompat ke alamat itu.  Untuk malas memuat alamat fungsi, entri GOT ini diinisialisasi dengan alamat fungsi yang menemukan karakter target, memperbarui GOT dengan alamat itu, dan kemudian beralih ke fungsi.  Panggilan selanjutnya menggunakan alamat yang terdeteksi malas. <br><br><img src="https://habrastorage.org/webt/47/2r/yh/472ryhlyogynkwwrxyopa1rg7l0.png"><br><br>  Kerugian dari PLT adalah biaya tambahan tambahan untuk menjalankan fungsi dinamis, yang muncul dalam benchmark.  Karena tolok ukur <i>hanya</i> mengukur pemanggilan fungsi, perbedaannya tampak cukup signifikan, tetapi dalam praktiknya biasanya mendekati nol. <br><br>  Inilah patokannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Cleared by an alarm signal. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plt_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) empty(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  Karena <code>empty()</code> dalam objek bersama, panggilan melewati PLT. <br><br><h1>  Panggilan Dinamis Tidak Langsung </h1><br>  Cara lain untuk memanggil fungsi secara dinamis adalah dengan menelusuri PLT dan mendapatkan alamat fungsi target dalam program, misalnya, melalui <code>dlsym(3)</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *h = dlopen(<span class="hljs-string"><span class="hljs-string">"path/to/lib.so"</span></span>, RTLD_NOW); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*f)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = dlsym(<span class="hljs-string"><span class="hljs-string">"f"</span></span>); f();</code> </pre> <br>  Jika alamat fungsi diterima, maka biayanya kurang dari panggilan fungsi melalui PLT.  Tidak ada fungsi antara rintisan dan akses ke GOT.  (Perhatian: jika program memiliki catatan PLT untuk fungsi ini, maka <code>dlsym(3)</code> sebenarnya dapat mengembalikan alamat rintisan). <br><br>  Tetapi ini masih merupakan tantangan <i>tidak langsung</i> .  Pada arsitektur konvensional, panggilan fungsi <i>langsung</i> menerima alamat relatif langsungnya.  Maksudnya, tujuan dari panggilan itu adalah beberapa offset kode-keras dari titik panggilan.  CPU dapat mengetahui ke mana panggilan akan pergi jauh lebih awal. <br><br>  Panggilan tidak langsung memiliki lebih banyak overhead.  Pertama, alamat perlu disimpan di suatu tempat.  Bahkan jika itu hanya sebuah register, penggunaannya meningkatkan defisit register.  Kedua, panggilan tidak langsung memprovokasi prediktor cabang di CPU, memaksakan beban tambahan pada prosesor.  Dalam skenario terburuk, panggilan bahkan dapat menyebabkan pipa berhenti. <br><br>  Inilah patokannya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sig_atomic_t</span></span> running; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indirect_benchmark</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*f)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (count = <span class="hljs-number"><span class="hljs-number">0</span></span>; running; count++) f(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; }</code> </pre> <br>  Fungsi yang diteruskan ke tolok ukur ini diekstraksi menggunakan <code>dlsym(3)</code> , sehingga kompiler tidak dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melakukan sesuatu yang rumit</a> , seperti mengubah panggilan tidak langsung ini kembali ke langsung. <br><br>  Jika loop body cukup kompleks untuk menyebabkan defisit register dan dengan demikian memberikan alamat ke stack, maka tolok ukur ini juga tidak dapat secara jujur ‚Äã‚Äãdibandingkan dengan tolok ukur PLT. <br><br><h1>  Panggilan fungsi langsung </h1><br>  Dua jenis panggilan fungsi dinamis yang pertama adalah sederhana dan mudah digunakan.  Panggilan <i>langsung</i> untuk fungsi dinamis lebih sulit untuk diatur, karena mereka memerlukan perubahan kode selama eksekusi.  Dalam benchmark saya, saya mengumpulkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompiler JIT kecil</a> untuk menghasilkan panggilan langsung. <br><br>  Kuncinya adalah bahwa pada transisi eksplisit x86-64 terbatas pada kisaran 2 GB karena operan yang ditandatangani 32-bit (langsung ditandatangani).  Ini berarti bahwa kode JIT harus ditempatkan hampir di sebelah fungsi target, <code>empty()</code> .  Jika kode JIT harus memanggil dua fungsi dinamis yang berbeda, dibagi lebih dari 2 GB, maka tidak mungkin untuk membuat dua panggilan langsung. <br><br>  Untuk menyederhanakan situasi, tolok ukur saya tidak khawatir tentang pilihan yang tepat atau sangat hati-hati dari alamat kode JIT.  Setelah menerima alamat fungsi target, itu hanya mengurangi 4 MB, membulatkannya ke halaman terdekat, mengalokasikan sedikit memori dan menulis kode untuk itu.  Jika semuanya dilakukan sebagaimana mestinya, maka untuk menemukan tempat Anda perlu memeriksa representasi Anda sendiri dari program dalam memori, dan ini tidak dapat dilakukan dengan cara yang bersih dan portabel.  Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membutuhkan parsing file virtual di bawah / proc</a> . <br><br>  Ini adalah bagaimana alokasi memori JIT saya terlihat.  Ini mengasumsikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perilaku yang wajar untuk casting uintptr_t</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jit_compile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct jit_func *f, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*empty)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> addr = (<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)empty; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *desired = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)((addr - SAFETY_MARGIN) &amp; PAGEMASK); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = mmap(desired, len, prot, flags, fd, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Dua halaman menonjol di sini: satu untuk menulis, dan yang lainnya dengan kode yang tidak dapat ditulis.  Seperti di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk penutupan</a> , di sini halaman bawah dapat ditulisi dan berisi variabel yang <code>running</code> yang disetel ulang ke alarm.  Halaman ini harus di sebelah kode JIT untuk memberikan akses yang efektif mengenai RIP, sebagai fungsi dalam dua tolok ukur lainnya.  Halaman atas berisi kode rakitan ini: <br><br><pre> <code class="hljs vbscript">jit_benchmark: push rbx <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> ebx, ebx .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: mov eax, [rel running] test eax, eax je .done <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-literal"><span class="hljs-literal">empty</span></span> inc ebx jmp .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> .done: mov eax, ebx pop rbx ret</code> </pre> <br>  <code>call empty</code> adalah satu-satunya instruksi yang dihasilkan secara dinamis, perlu untuk mengisi alamat relatif dengan benar (minus 5 ditunjukkan relatif ke <i>akhir</i> instruksi): <br><br><pre> <code class="hljs lisp"> // call empty uintptr_t rel = (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)empty - (<span class="hljs-name"><span class="hljs-name">uintptr_t</span></span>)p - <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-comment"><span class="hljs-comment">; *p++ = 0xe8; *p++ = rel &gt;&gt; 0; *p++ = rel &gt;&gt; 8; *p++ = rel &gt;&gt; 16; *p++ = rel &gt;&gt; 24;</span></span></code> </pre> <br>  Jika fungsi <code>empty()</code> tidak dalam objek umum, tetapi dalam file biner yang sama, maka ini pada dasarnya adalah panggilan langsung yang akan dihasilkan oleh kompiler untuk <code>plt_benchmark()</code> , dengan asumsi bahwa karena alasan tertentu ia tidak dibangun di <code>empty()</code> . <br><br>  Ironisnya, memanggil kode yang dikompilasi JIT membutuhkan panggilan tidak langsung (misalnya, melalui pointer fungsi), dan tidak ada cara lain untuk mengatasi hal ini.  Apa yang bisa saya lakukan di sini, mengkompilasi JIT fungsi lain untuk panggilan langsung?  Untungnya, ini tidak masalah karena hanya panggilan langsung yang diukur dalam satu lingkaran. <br><br><h1>  Bukan rahasia </h1><br>  Mengingat hasil ini, menjadi jelas mengapa LuaJIT menghasilkan panggilan yang lebih efisien untuk fungsi dinamis daripada PLT, <i>bahkan jika mereka tetap panggilan tidak langsung</i> .  Dalam patokan saya, panggilan tidak langsung tanpa PLT 28% lebih cepat daripada dengan PLT, dan panggilan langsung tanpa PLT 43% lebih cepat daripada dengan PLT.  Keuntungan kecil dari program JIT ini dibandingkan dengan program asli lama yang sederhana dicapai karena penolakan mutlak pertukaran kode antara proses. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413181/">https://habr.com/ru/post/id413181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413169/index.html">Array dan Metode Objek yang Berguna dalam JavaScript</a></li>
<li><a href="../id413171/index.html">Tokamak JET Meluncurkan Kampanye Deuterium Tritium Baru</a></li>
<li><a href="../id413173/index.html">Memantau kesalahan JavaScript dengan window.onerror</a></li>
<li><a href="../id413175/index.html">Analisis statis di Go: bagaimana kita menghemat waktu saat memeriksa kode</a></li>
<li><a href="../id413177/index.html">Acara digital di Moskow dari 4 hingga 10 Juni</a></li>
<li><a href="../id413183/index.html">Optane DC Persistent Memory - Optane dalam format DIMM</a></li>
<li><a href="../id413185/index.html">Bermain curang, atau bagaimana penyelenggara undian menipu kita</a></li>
<li><a href="../id413189/index.html">Koleksi css eyeshadows Box-shadows.css</a></li>
<li><a href="../id413193/index.html">Pembelian besi melawan awan: cara menghitung</a></li>
<li><a href="../id413195/index.html">Pemikiran fungsional. Bagian 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>