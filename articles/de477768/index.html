<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🤝‍👨🏼 🎅 🍸 Die Geschichte von Vim und eine Anleitung zu seiner effektiven Verwendung 😓 🏥 🐏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anmerkung des Übersetzers: Dies ist der erste Teil des monumentalen (tatsächlich monumentalen) Artikels über Vim und seine Fähigkeiten, den der Entwic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die Geschichte von Vim und eine Anleitung zu seiner effektiven Verwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dcmiran/blog/477768/">  <i>Anmerkung des Übersetzers: Dies ist der erste Teil des monumentalen (tatsächlich monumentalen) Artikels über Vim und seine Fähigkeiten, den der Entwickler aus Minneapolis und der Autor des <a href="http://postgrest.org/en/v6.0/">PostgREST-</a> Projekts <a href="http://postgrest.org/en/v6.0/">,</a> Joe <a href="https://github.com/begriffs">begriffs</a> Nelson, verfasst haben.</i> <i><br><br></i>  <i>Der erste Teil des Artikels befasst sich mit der Geschichte von Vim als Herausgeber und der Autor spricht über eine Reihe interessanter Fakten über die Fähigkeiten von Vim.</i>  <i>Im zweiten Teil der Übersetzung konzentrieren sich alle Chips und Life-Hacks, die Joe mit dem Publikum teilen möchte, da die Erzählung als solche verblasst und nur noch eine Reihe von Handlungsrichtlinien vorhanden sind.</i>  <i>Da der Originaltext völlig inakzeptable Dimensionen aufweist, haben wir diese Geschichte in zwei ungefähr gleich große Artikel unterteilt.</i>  <i>Heute ist die erste von zwei Veröffentlichungen.</i>  <i>Viel Spaß beim Lesen.</i> <br><br><hr><br>  Dieser Artikel basiert auf der Erforschung der Geschichte von Vim und dem durchgängigen Lesen des Benutzerhandbuchs.  Ich hoffe, diese Notizen helfen Ihnen dabei, die grundlegenden Funktionen dieses Editors für sich selbst zu entdecken (oder wiederzuentdecken?) Und ermöglichen es Ihnen, die Verwendung von vimrc-Dateien mit Warnhinweisen aufzugeben und Plug-ins durchdachter zu verwenden. <br><br><img src="https://habrastorage.org/webt/hn/0g/5q/hn0g5qskcbqwtg_kauayaurqcak.png"><br><br><h3>  Referenzliste </h3><br>  Um über die üblichen Themen hinauszugehen, würde ich empfehlen, eine gedruckte Version dieses Handbuchs und eine umfangreiche Taschenreferenz mitzunehmen.  Ich konnte kein gedrucktes Exemplar des Benutzerhandbuchs für Vim finden. Am Ende habe ich nur die <a href="https://begriffs.com/pdf/vim-user-manual.pdf">PDF-Datei</a> gedruckt, die mit dem Editor über printme1.com geliefert wurde.  <code>$VIMRUNTIME/doc/usr_??</code> es mit Software in <code>$VIMRUNTIME/doc/usr_??</code>  .  Als bequeme Liste von Befehlen kann ich das Nachschlagewerk <a href="https://www.goodreads.com/book/show/9787030-vi-and-vim-editors-pocket-reference">"Vi and Vim Editors Pocket"</a> empfehlen. <br><br>  <b>Inhalt</b> <br><br><ul><li>  Die Geschichte </li><li>  Konfigurationshierarchie </li><li>  Plugins von Drittanbietern </li><li>  Backups und Kickbacks </li><li>  Include und Pfad </li><li>  Bearbeiten und Kompilieren einer Schleife </li><li>  Diffs und Patches </li><li>  Ein- / Ausgabepuffer </li><li>  Dateitypen </li><li>  Vergiss die Maus nicht </li><li>  Verschiedenes </li></ul><br><h2>  Die Geschichte </h2><br><h3>  Geburt vi </h3><br>  Vi-Befehle und -Funktionen gibt es seit mehr als fünfzig Jahren, angefangen mit dem QED-Editor.  Hier ist seine Timeline: <br><a name="habracut"></a><br><ul><li>  1966: QED (Quick Editor) am Berkeley Timesharing System </li><li>  Juli 1969: Mit seiner Hilfe landeten sie auf dem Mond (na ja, als Referenz) </li><li>  Aug 1969: QED → Hrsg. Bei AT &amp; T </li><li>  1976 Feb: ed → em („Herausgeber für Sterbliche“) am Queen Mary's College </li><li>  1976: em → ex ("EXtended") an der University of California, Berkeley </li><li>  1977 Okt: Ex empfängt visuellen Modus, Vi - Text - Terminal </li></ul><br>  Wenn Sie das <a href="https://begriffs.com/pdf/qed-editor.pdf">QED-</a> und das <a href="https://begriffs.com/pdf/ex-manual.pdf">Ex-</a> Handbuch lesen, werden Sie möglicherweise Ähnlichkeiten zwischen ihnen feststellen.  Beide Editoren verwenden eine ähnliche Grammatik, um Zeilenbereiche anzugeben und mit diesen zu arbeiten. <br><br>  Editoren wie QED ed und em wurden für Druckterminals entwickelt, bei denen es sich größtenteils um normale elektrische Schreibmaschinen handelte, an die ein Modem angeschlossen war.  Solche "Vollkopierer" -Terminals zeigten Befehle auf Papier an und offensichtlich war es nach der Eingabe unmöglich, irgendwelche Korrekturen vorzunehmen.  Daher bestand der Bearbeitungsprozess darin, Benutzerbefehle manuell auf Papier zu bearbeiten und sie dann erneut einzugeben. <br><br>  1976 erschienen Videoterminals, zum Beispiel ADM-3A.  Dem Ex-Editor wurde ein „Öffnungsmodus“ hinzugefügt, der das Bearbeiten über ein Videoterminal auf einer einzelnen Seite ermöglicht.  Ein visueller Modus wurde hinzugefügt, um sich mit dem Cursor an den Linien des Terminals zu orientieren.  Der visuelle Modus wurde mit dem Befehl „vi“ aktiviert und die auf dem Bildschirm angezeigte Datei ständig aktualisiert, wobei die Position der Befehlszeile am unteren Bildschirmrand beibehalten wurde.  Interessante Tatsache: Auf dem ADM-3A wurden Pfeile auf die Tasten h, j, k, l gesetzt, mit denen wir den Cursor auf vi bewegen konnten. <br><br>  In <a href="https://begriffs.com/pdf/unix-review-bill-joy.pdf">einem Interview mit Bill Joy</a> erfahren Sie mehr über diesen Übergang von ed zu ex / vi.  Darin spricht er darüber, wie er Ex / Vi geschaffen hat und über einige Dinge, die ihn letztendlich enttäuscht haben. <br><br>  Classic vi ist nur ein alter is ex.  Beide werden durch dieselbe Binärdatei dargestellt, die abhängig vom Namen der ausführbaren Datei sowohl im Ex-Modus als auch im Vi-Modus ausgeführt werden kann.  Das Erbe dieser ganzen Geschichte ist, dass ex / vi sich bei Verwendung „entfaltet“, fast keine Systemressourcen benötigt und unter Bedingungen mit begrenzter Bandbreite arbeiten kann.  Es ist auch auf den meisten vorhandenen Systemen verfügbar und wird in POSIX <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/vi.html">vollständig beschrieben</a> . <br><br><h3>  Vi zu vim </h3><br>  Der von ed abgeleitete Ex / Vi-Editor war geistiges Eigentum von AT &amp; T.  Um vi auf anderen Plattformen als Unix zu verwenden, mussten Benutzer Klone schreiben, die eine andere Quellcodebasis hatten. <br><br>  Hier sind einige von ihnen: <br><br><ul><li>  nvi - 1980 für 4BSD </li><li>  calvin - 1987 für DOS </li><li>  vile - 1990 für DOS </li><li>  Stevie - 1987 für Atari ST </li><li>  elvis - 1990 für Minix und 386BSD </li><li>  vim - 1991 für Amiga </li><li>  Viper - 1995 für Emacs </li><li>  elwin - 1995 für Windows </li><li>  lemmy - 2002 für Windows </li></ul><br>  Wir werden uns auf den Klon aus der Mitte der Liste konzentrieren - Vim.  Bram Mulenaar wollte vi auf Amiga verwenden und begann mit Atari zu portieren und den vi-Klon Stevie zu entwickeln.  Und er nannte seine Version des Hafens "Vi Imitation".  Wenn Sie diesen Prozess aus erster Hand kennenlernen möchten, sehen Sie sich sein Interview für das Free Software Magazine an. <br><br>  In Version 1.22 wurde Vim in "Vi IMproved" umbenannt, was auf die Überlegenheit der Kopie gegenüber dem Original hinweist.  Hier ist ein Diagramm der folgenden Hauptversionen mit Beschreibungen einiger Funktionen: <br><br><img src="https://habrastorage.org/webt/n-/gw/lu/n-gwlulgvi4i6rrmjqfzvmvpwbi.png"><br><br>  Für weitere Informationen zu jeder Version sollte die Hilfe verwendet werden, z. B. für vim8.  Um die geplanten Updates sowie eine Liste der bekannten Fehler anzuzeigen, sollten Sie sich an todo.txt wenden. <br><br>  Beispielsweise enthielt die achte Version eine gewisse Unterstützung für asynchrone Jobs, da das Projekt von NeoVim unter Druck gesetzt wurde.  Die Entwickler der letzteren <a href="https://groups.google.com/forum/">wollten</a> Debugging und REPL für Web-Skripte direkt im Editor ausführen. <br><br>  Generell ist Vim superportabel.  Dieser Editor passte die gesamte Geschichte seines Bestehens an die Arbeit auf völlig anderen Plattformen an und war gezwungen, im Rahmen der „einfachen“ Kultur des Codierens zu bleiben.  Vim läuft unter OS / 390, Amiga, BeOS und BeBox, Macintosh Classic, Atari MiNT, MS-DOS, OS / 2, QNX, RISC-OS, BSD, Linux, OS X, VMS und MS-Windows.  Sie können sich überall auf Vim verlassen und es ist Ihnen egal, welche Ausrüstung Sie verwenden. <br><br>  Am Ende des ursprünglichen vi-Pfades wurde der ex / vi-Quellcode im Jahr 2002 noch unter der BSD-Lizenz für freie Software veröffentlicht.  Zauberer sind unter <a href="http://ex-vi.sourceforge.net/">ex-vi.sourceforge.net</a> verfügbar. <br><br>  Aber lasst uns zur Sache kommen.  Bevor Sie mit der Analyse von Vim beginnen, sollten Sie wissen, wie die Konfigurationsdateien organisiert und gelesen werden. <br><br><h2>  Konfigurationshierarchie </h2><br>  Bisher habe ich fälschlicherweise geglaubt, dass Vim alle Einstellungen und Skripte nur aus der .vimrc-Datei bezieht.  Das Betrachten von Repositories mit zufälligen „Punktedateien“ kann diese Meinung nur stärken.  Sehr oft laden Leute monströse einzelne .vimrc-Dateien hoch, deren Aufgabe es ist, jeden Aspekt des Editors zu kontrollieren.  Diese riesigen Konfigurationen werden manchmal auch "vim distros" genannt. <br><br>  Tatsächlich hat Vim eine übersichtliche Struktur, in der .vimrc nur einer von vielen „Einstiegspunkten“ ist.  Tatsächlich können Sie Vim selbst fragen, welche Skripte geladen werden.  Bearbeiten Sie dazu einen Quellcode für ein zufälliges Projekt auf Ihrem Computer, laden Sie ihn herunter und führen Sie den Befehl aus <br><br><pre> <code class="xml hljs">:scriptnames</code> </pre> <br>  Diese Liste ist lesenswert.  Versuchen Sie zu erraten, was diese Skripte bewirken, und notieren Sie sich die Verzeichnisse, in denen sie sich befinden. <br><br>  Die Liste war länger als erwartet?  Wenn Sie viele Plugins installiert haben, hat der Editor viel zu tun.  Stellen Sie sicher, dass es beim Start langsamer wird, indem Sie den folgenden Befehl zum Erstellen von start.log ausführen: <br><br><pre> <code class="xml hljs">vim --startuptime start.log name-of-your-file</code> </pre> <br>  Vergleichen Sie einfach, wie schnell Vim von Anfang an startet: <br><br><pre> <code class="xml hljs">vim --clean --startuptime clean.log name-of-your-file</code> </pre> <br>  Um zu bestimmen, welche Skripte beim Start oder beim Laden des Puffers geladen werden sollen, müssen Sie den Vim-Laufzeitpfad überprüfen.  Dieser Pfad wird durch eine durch Kommas getrennte Liste von Verzeichnissen dargestellt, von denen jedes eine gemeinsame Struktur enthält.  Vim überprüft diese Strukturen in jedem Verzeichnis, um die Startskripte zu finden.  Verzeichnisse werden streng in der Reihenfolge verarbeitet, in der sie sich in der Liste befinden. <br><br>  Überprüfen Sie den Ausführungspfad auf Ihrem System mit folgendem Befehl: <br><br><pre> <code class="xml hljs">:set runtimepath</code> </pre> <br>  Mein System enthält die folgenden Verzeichnisse, die standardmäßig für die Laufzeitpfadüberprüfung angegeben sind.  Nicht alle existieren sogar, aber Vim wird immer noch versuchen, auf sie zuzugreifen und den Inhalt zu überprüfen, wenn sie noch vorhanden sind: <br><br> <code>~/.vim</code> <br>  Basisverzeichnis für erstellte Profile. <br><br> <code>/usr/local/share/vim/vimfiles</code> <br>  Systemweites Vim-Verzeichnis für Profile mit Systemadministratorrechten. <br><br> <code>/usr/local/share/vim/vim81</code> <br>  Aka $ VIMRUNTIME, für mit Vim verteilte Dateien. <br><br> <code>/usr/local/share/vim/vimfiles/after</code> <br>  Im systemweiten Vim-Verzeichnis befindet sich auch das After-Verzeichnis.  Es ist beabsichtigt, die persönlichen Einstellungen des "Standard" -Systemadministrators hinzuzufügen. <br><br> <code>~/.vim/after</code> <br>  Das After-Verzeichnis im Home-Verzeichnis.  Dies ist erforderlich, damit persönliche Konfigurationen nicht abgebrochen werden oder sich mit den systemweiten oder „Standard“ -Einstellungen überschneiden. <br><br>  Im Allgemeinen werden Verzeichnisse in derselben Reihenfolge verarbeitet, in der sie in start.log geschrieben sind. Eine Ausnahme gilt nur für "after".  Dieser steht immer am Ende der Liste und wird zuletzt abgearbeitet. <br><br>  Bei der Verarbeitung jedes Verzeichnisses sucht Vim in diesen nach Unterordnern mit bestimmten Namen.  Weitere Informationen hierzu finden Sie unter help runtimepath.  Hier ist eine kurze Beschreibung derer, die wir im Text weiter betrachten werden: <br><br> <code>plugin /</code> <br>  Hier liegen die Vim-Skriptdateien, die beim Bearbeiten eines beliebigen Dateityps automatisch geladen werden.  Sie werden auch "global" genannt. <br><br> <code>autoload /</code> <br>  (Nicht zu verwechseln mit "Plugin").  Diese Startskripte enthalten Funktionen, die nur auf Anforderung anderer Skripte eingeschränkt werden. <br><br> <code>ftdetect /</code> <br>  Skripte zur Bestimmung der Dateitypen.  Bei ihrer Arbeit verlassen sie sich auf die Erweiterung, den Speicherort oder den internen Inhalt der Datei. <br><br> <code>ftplugin /</code> <br>  Skripte, die beim Bearbeiten von Dateien eines bekannten Typs ausgeführt werden. <br><br> <code>compiler /</code> <br>  Legt fest, wie verschiedene Compiler oder Flusenprüfungen ausgeführt und deren Ausgabe analysiert werden.  Es kann auf mehrere ftplugins gleichzeitig aufgeteilt werden.  Der Compiler wird nicht automatisch ausgeführt und muss von einem Befehl aufgerufen werden. <br><br> <code>pack /</code> <br>  Ein Container für native Vim 8-Pakete, der Nachfolger der Paketverwaltung im Pathogen-Stil.  Es verfügt über ein eigenes Verpackungssystem und erfordert keinen Code von Drittanbietern. <br><br>  Und schließlich ist <code>~ / .vimrc</code> eine Falle für allgemeine <code>~ / .vimrc</code> .  Dient zum Konfigurieren der Standardeinstellungen, die einem bestimmten Dateityp zugewiesen werden können.  Um die gesamte Liste anzuzeigen, können Sie .vimrc auswählen und den Befehl options ausführen. <br><br><h2>  Plugins von Drittanbietern </h2><br>  Plugins sind nur Vim-Skripte, für die es ausreicht, sie an den richtigen Stellen im Laufzeitpfad zu platzieren.  Im Allgemeinen ist der Installationsprozess äußerst einfach: Laden Sie einfach die Datei (en) hoch.  Das Problem ist, dass einige Plugins sehr schwer zu aktualisieren oder zu entfernen sind, da sie in verschiedenen Unterverzeichnissen verstreut sind und die Ausführungspfade mit ihren Skripten verstopfen.  Das heißt, am Ende ist es schwierig zu bestimmen, welche Datei zu welchem ​​Plugin gehört. <br><br>  Um dieses Problem zu lösen, begannen sich Plugin-Manager zu entwickeln.  Auf vim.org gab es mindestens bis einschließlich 2003 eine Plugin-Registrierung (sofern das Archiv nicht lügt).  „Plug-in-Manager“ als Einheit sind jedoch erst 2008 in Mode gekommen. <br><br>  Diese Tools fügen spezielle Verzeichnisse für Plugins hinzu, um Ausführungspfade zu verfolgen und Tags anzuordnen, mit denen Plugins verfolgt werden können.  Die meisten Manager rufen auch Plug-in-Updates aus dem Netzwerk auf. <br><br>  Im Folgenden habe ich Plugin-Manager entsprechend der Chronologie ihres Auftretens erstellt.  Basierend auf den Bereichen der Veröffentlichungstermine der ersten und neuesten Versionen.  Wenn es keine offiziellen Veröffentlichungen gab, habe ich die frühesten Veröffentlichungstermine und das letzte Update zugrunde gelegt. <br><br><ul><li>  März 2006 - Juli 2014: Vimball </li><li>  Okt 2008 - Dez 2015: Krankheitserreger </li><li>  Aug 2009 - Dez 2009: Vimana </li><li>  Dez 2009 - Dez 2014: VAM </li><li>  Aug 2010 - Nov 2010: Ruck </li><li>  Okt 2010 - Nov 2012: tplugin </li><li>  Okt 2010 - Feb 2014: Vundle </li><li>  März 2012 - März 2018: Vim-Geschmack </li><li>  April 2012 - März 2016: NeoBundle </li><li>  Jan 2013 - Aug 2017: infizieren </li><li>  Februar 2013 - August 2016: Vimogen </li><li>  Okt 2013 - Jan 2015: Vim-Unbundle </li><li>  Dez 2013 - Jul 2015: Zauberei </li><li>  Februar 2014 - Oktober 2018: Vim-Plug </li><li>  Jan 2015 - Okt 2015: Enabler </li><li>  August 2015 - April 2016: Zauberei 2 </li><li>  Jan 2016 - Jun 2018: dein.vim </li><li>  Sep 2016 - Heute: native in Vim 8 </li><li>  Februar 2017 - September 2018: Minpac </li><li>  März 2018 - März 2018: autopac </li><li>  Februar 2017 - Juni 2018: Packung </li><li>  März 2017 - September 2017: vim-pck </li><li>  Sep 2017 - Sep 2017: vim8-pack </li><li>  September 2017 - Mai 2019: Volt </li><li>  Sep 2018 - Feb 2019: vim-packager </li><li>  Feb 2019 - Feb 2019: plugpac.vim </li></ul><br>  Das Erste, worauf Sie in der obigen Liste achten müssen, ist die große Vielfalt.  Das zweite - jedes der vorgestellten Werkzeuge „lebt“ seit ungefähr vier Jahren und ist dann höchstwahrscheinlich aus der Mode gekommen. <br><br>  Der Weg des geringsten Widerstands bei der Plug-in-Verwaltung besteht einfach in der Verwendung der integrierten Vim 8-Funktionalität, für die kein Code von Drittanbietern abgerufen werden muss.  Schauen wir uns an, wie es geht. <br><br>  Erstellen Sie zunächst zwei Verzeichnisse in Ihrem Laufzeitpfad: opt und start. <br><br><pre> <code class="xml hljs">mkdir -p ~/.vim/pack/foobar/{opt,start}</code> </pre> <br>  Achten Sie auf den Platzhalter "foobar" (der Name kann geändert werden).  Es klassifiziert alle Pakete, die ins Innere gelangen, vollständig.  Die meisten Benutzer speichern einfach alle Plugins in einer Kategorie, und dies ist im Allgemeinen normal.  Wählen Sie einen beliebigen Namen.  Ich werde weiterhin foobar verwenden.  Theoretisch können Sie auch mehrere Kategorien erstellen, z. B. <code>~/.vim/pack/navigation</code> und <code>~/.vim/pack/linting</code> .  Bitte beachten Sie, dass Vim keine Duplikate zwischen Kategorien erkennt und Duplikate, falls vorhanden, zweimal herunterlädt. <br><br>  Pakete in "start" werden automatisch geladen, während Pakete in "opt" erst von Vim geladen werden, wenn Sie den folgenden Befehl verwenden <code>:packadd</code> .  Diese Option eignet sich für selten verwendete Pakete und wird von Vim standardmäßig unterstützt, ohne dass Skripts ausgeführt werden müssen.  Beachten Sie, dass <code>:packadd</code> kein Gegenstück zum Entladen von Paketen hat. <br><br>  Um dieses Beispiel zu überprüfen, fügen wir das CTRLP-Plugin für die Fuzzy-Suche hinzu.  Laden Sie die neueste Version herunter und entpacken Sie sie unter: <br><br><pre> <code class="xml hljs">curl -L https://github.com/kien/ctrlp.vim/archive/1.79.tar.gz \ | tar zx -C ~/.vim/pack/foobar/opt</code> </pre> <br>  Dieser Befehl erstellt den <code>~ / .vim / pack / foobar / opt / ctrlp.vim-1.79</code> fertige Paket <code>~ / .vim / pack / foobar / opt / ctrlp.vim-1.79</code> .  Kehren Sie zu vim zurück und erstellen Sie die Hilfe-Tag-Zeiger (Helptags-Index) für das neue Paket: <br><br><pre> <code class="xml hljs">:helptags ~/.vim/pack/foobar/opt/ctrlp.vim-1.79/doc</code> </pre> <br>  Mit diesem Befehl wird eine Datei mit dem Namen "tags" im Ordner mit den Sorten des Pakets erstellt, die Themen zur Anzeige im internen System von Vim zur Verfügung stellt.  Alternative Methode: Führen Sie helptags ALL nach dem Herunterladen des Pakets aus, und der Befehl kümmert sich um alle Dateien und ihre Ausführungspfade. <br>  Wenn Sie ein Paket verwenden möchten, laden Sie es einfach herunter und denken Sie daran, dass in diesem Fall die Terminierung mithilfe von Registerkarten funktioniert, sodass Sie nicht den vollständigen Namen eingeben müssen: <br><br><pre> <code class="xml hljs">:packadd ctrlp.vim-1.79</code> </pre> <br>  Das Basisverzeichnis von Packadd befindet sich in runtimepath, wodurch Skripte aus seinem Plugin und ftdetect verwendet werden können.  Nach dem Laden von ctrlp können Sie den Befehl CTRL-P verwenden, um die Dateisuche nach teilweiser Übereinstimmung zu öffnen. <br><br>  Einige Leute verfolgen ihr ~ / .vim-Verzeichnis und verwenden git, um die Version jedes Pakets zu kontrollieren.  Ich für meinen Teil entpacke einfach Pakete aus Tar-Archiven und verfolge sie manuell durch das Repository.  Wenn Sie ausreichend ausgereifte Pakete verwenden, für die keine häufigen Aktualisierungen erforderlich sind, sowie Skripte, sind diese recht klein und verstopfen den Git-Verlauf nicht. <br><br><h2>  Backups und Rollbacks von Versionen </h2><br>  Abhängig von Ihren Benutzereinstellungen kann Vim Sie vor vier möglichen Ursachen für Datenverlust schützen: <br><br><ol><li>  Absturz während der Bearbeitung (zwischen den Speichervorgängen).  Vim kann sich dagegen schützen, indem Änderungen an der Auslagerungsdatei regelmäßig gespeichert werden. </li><li>  Schutz vor dem Bearbeiten derselben Datei mit zwei Vim-Instanzen und vor dem Überschreiben von Änderungen, die über eine oder mehrere Instanzen vorgenommen wurden.  Dies geschieht auch über die Auslagerungsdatei. </li><li>  Fehler während des Speichervorgangs selbst nach dem Ändern der endgültigen Datei, aber bis der neue Inhalt vollständig geschrieben ist.  Vim kann Sie mit der Writebackup-Funktion davor schützen.  Dazu erstellt er beim Speichern eine neue Datei, die anschließend das Original ersetzt, wenn alles reibungslos lief.  Die Ersetzungsmethode wird durch die Einstellung für die Sicherungskopie bestimmt. </li><li>  Speichern Sie den neuen Inhalt der Datei, sofern das Original wiederhergestellt ist.  Mit Vim können Sie eine Sicherungskopie einer Datei speichern, nachdem Sie Änderungen vorgenommen haben. </li></ol><br>  Aber bevor Sie anfangen, diese intelligenten Einstellungen zu erkunden, wie wäre es mit ein paar Witzen?  Hier sind einige Beispielkommentare von vimrc-Dateien auf GitHub: <br><br>  „Erstellen Sie keine Auslagerungsdatei.  Verwalten Sie alles über die Versionskontrolle. “ <br>  „Backups für Exilanten.  Verwenden Sie die Versionskontrolle. “ <br>  "Nur Versionskontrolle!"  Nur Hardcore! " <br>  "Wir leben in einer Welt der Versionskontrolle. Auslagerungen und Backups sind also im Papierkorb." <br>  "Warum brauchen Sie Sicherungsdateien, wenn die Versionskontrolle ausreicht?" <br>  "Ich habe noch nie Vim-Sicherungsdateien verwendet ... Versionskontrolle verwenden." <br>  "Die meisten Dinge können über die Versionskontrolle gefunden werden." <br>  Msgstr "Dateisicherungen deaktivieren, da Sie immer noch das Versionskontrollsystem verwenden;)". <br>  "Und die Versionskontrolle kam und Git hat uns gerettet." <br>  Deaktivieren Sie Swap-Dateien und Backup-System.  Verwenden Sie immer die Versionskontrolle!  IMMER! " <br>  "Ich benötige kein Backup, da ich mit der Versionskontrolle arbeite." <br><br>  Die Ironie ist, dass die obigen Kommentare nur ein Verständnis der vierten und teilweise dritten Art des Scheiterns widerspiegeln.  Wenn Sie die Auslagerungsdatei und die Sicherung ablehnen, verlieren Sie den Schutz in dem in den Absätzen 1 und 2 beschriebenen Fall. <br><br>  Hier ist eine Beispielkonfiguration, die ich für einen sicheren Betrieb empfehle: <br><br><pre> <code class="xml hljs">" Protect changes between writes. Default values of " updatecount (200 keystrokes) and updatetime " (4 seconds) are fine set swapfile set directory^=~/.vim/swap// " protect against crash-during-write set writebackup " but do not persist backup after successful write set nobackup " use rename-and-write-new method whenever safe set backupcopy=auto " patch required to honor double slash at end if has("patch-8.1.0251") " consolidate the writebackups -- not a big " deal either way, since they usually get deleted set backupdir^=~/.vim/backup// end " persist the undo tree for each file set undofile set undodir^=~/.vim/undo//</code> </pre> <br>  Diese Einstellungen umfassen Sicherungen für unvollständige Aufzeichnungen, speichern jedoch keine Dateien, nachdem der Vorgang erfolgreich abgeschlossen wurde, da wir die Versionskontrolle, die beste Versionskontrolle, bla bla bla usw. haben.  usw.  Bitte beachten Sie, dass Sie möglicherweise mkdir ~ / .vim / {swap, undodir, backup} benötigen, andernfalls greift Vim auf den nächsten lesbaren Ordner zu.  Sie müssen wahrscheinlich auch den Befehl chmod für die Zielordner ausführen, damit deren Inhalt privat ist, da die Auslagerungsdateien und der Sicherungsverlauf möglicherweise vertrauliche Informationen enthalten. <br><br>  Es ist erwähnenswert, dass das Merkmal unserer Konfigurationspfade ist, dass sie immer mit einem Schrägstrich schließen.  Diese Schreibweise ermöglicht es der Funktion, die mögliche Mehrdeutigkeit in den Pfaden der Auslagerungs- und Sicherungsdateien für Dateien mit demselben Namen, die sich in verschiedenen Verzeichnissen befinden, zu beseitigen.  Beispielsweise wird die Auslagerungsdatei für / foo / bar in ~ / .vim / swap /% foo% bar.swp gespeichert (ich habe Schrägstriche mit Prozentzeichen ausgeblendet).  In dem kürzlich veröffentlichten Vim-Patch gab es einen Fehler, der verhinderte, dass der Schrägstrich für backupdir berücksichtigt wurde. Der Schutz dagegen ist oben dargestellt. <br><br>  Unser Vim speichert auch den Rollback-Verlauf für jede Datei, sodass Sie auch nach dem Verlassen des Bearbeitungsmodus die richtige Version wiederherstellen können.  Obwohl eine solche Funktion vor dem Hintergrund der bereits vorhandenen Auslagerungsdatei redundant zu sein scheint, ist der Rollback-Verlauf eine zusätzliche Verteidigungslinie bei der Dateiaufzeichnung. <br><br>  Wenn wir über Rollbacks sprechen, ist zu beachten, dass Vim einen vollständigen Baum der Dateibearbeitungshistorie unterstützt.  Dies bedeutet, dass Sie eine Änderung vornehmen, einen Rollback durchführen und dieselben Änderungen dann erneut wiederholen können. Dies sind dann drei verschiedene Wiederherstellungspunkte.  Der Zeitpunkt und das Ausmaß der vorgenommenen Änderungen können mit dem Befehl undolist überprüft werden. Es ist jedoch problematisch, den Baum daraus zu entfernen.                 :     5 ,      .     ,        —  ,  undotree —  . <br><br>              .                .   :        .       ,    . <br><br>     :      ,      ,vim         .       nowritebackup,        ,      .     ,   Vim      ,     .    backupskip        . <br><br>  «patchmode» Vim      .      ,     . ,     tar-,        ,     git.  set patchmod = .orig   foo-      foo.orig. <br><br><h2> Include  path </h2><br>      (include)      . Vim     path, include, suffixesadd,  includeexpr.    (. help include-search) —       ctags   . <br><br>         .    ,       .           ,     <code>help include</code> . <br><br>    ,    <code>[i</code>  ,    ,    <code>[d</code>    .    <code>gf</code>    Vim     .       :find,      <code>**/*</code>         ,    .       , ..   ,       . <br><br>        ,      .     (      )         CTRL-D.    . <br><br><pre> <code class="xml hljs">" fuzzy-find lite nmap <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Leader</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">space</span></span></span><span class="hljs-tag">&gt;</span></span> :e ./**/</code> </pre> <br>   :  path     (headers) .     ,   : checkpath,  ,   .     C   checkpath.     ,     ,       .   ,  checkpath      ,   . <br><br>      <code>«., / Usr / include ,,»</code> .  ,     —  /usr/include,        .       ,     <code>:help file-searching</code> . <br><br>   ftplugin   (  )      ,    . : ./src/include  ./include. <br><br><pre> <code class="xml hljs">setlocal path=.,,*/include/**3,./*/include/**3 setlocal path+=/usr/include</code> </pre> <br>   <code>«**3»</code> —      .    ,    .  ,      . <br><br>     ,        ,  :checkpath ,      . , ,       . <br><br>   : <code>:he [, :he gf, :he :find</code> . <br><br><hr><br> <i>  .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477768/">https://habr.com/ru/post/de477768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477754/index.html">Vergleiche micro: bit mit Arduino. Und wie bekommst du micro: bit kostenlos, wenn du kein Englischschüler bist?</a></li>
<li><a href="../de477756/index.html">Wie wir zwei Banking-CRM-Systeme heirateten</a></li>
<li><a href="../de477758/index.html">"Doktor, entfernen Sie dies von der Rechnung": wie wir nach illegalen Diensten in VHI gesucht haben</a></li>
<li><a href="../de477760/index.html">SberX RamblerFront & Meet Up: wie es war</a></li>
<li><a href="../de477766/index.html">Anwendung des Verschlüsselungsmodus von SL3 MIfare-Karten am Beispiel eines Unternehmens</a></li>
<li><a href="../de477770/index.html">Mach das Licht durch die Kraft des Denkens an, na ja, fast</a></li>
<li><a href="../de477774/index.html">Designtreffen im St. Petersburger Büro von Wrike 5. Dezember</a></li>
<li><a href="../de477778/index.html">Geschichte des Videoprozessors, Teil 2: 3Dfx Voodoo</a></li>
<li><a href="../de477780/index.html">Schreiben Sie Ihre eigene CLI für React</a></li>
<li><a href="../de477782/index.html">DJI Mavic Mini und das Gesetz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>