<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👟 🕑 In einem bestimmten Königreich, nicht in einem "springenden" Zustand. Yandex-Bericht 🚹 👩🏾‍🍳 👩🏽‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spring ist ein leistungsfähiges Open Source Java Framework. Ich habe beschlossen, Ihnen zu erklären, für welche Aufgaben das Spring-Backend nützlich i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>In einem bestimmten Königreich, nicht in einem "springenden" Zustand. Yandex-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/478788/">  Spring ist ein leistungsfähiges Open Source Java Framework.  Ich habe beschlossen, Ihnen zu erklären, für welche Aufgaben das Spring-Backend nützlich ist und welche Vor- und Nachteile es im Vergleich zu anderen Bibliotheken hat: Guice und Dagger 2. Berücksichtigen Sie die Injektion von Abhängigkeiten und die Inversion von Steuerelementen - Sie lernen, wie Sie mit dem Studium dieser Prinzipien beginnen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RrmrfoWDu5M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Hallo, mein Name ist Cyril.  Heute werde ich über Abhängigkeitsinjektion sprechen. <br><a name="habracut"></a><br>  Wir werden mit dem beginnen, was mein Bericht heißt.  "In einem bestimmten Königreich, nicht in einem" springenden "Zustand."  Wir werden natürlich über den Frühling sprechen, aber ich möchte auch alles betrachten, was außer ihm ist.  Worüber werden wir konkret sprechen? <br><br><img src="https://habrastorage.org/webt/cq/li/gv/cqligvmc0hnuu56z8mgqjjnoebo.jpeg"><br><br>  Ich werde einen kleinen Exkurs machen - erzählen Sie, woran ich arbeite, was mein Projekt ist, warum wir Dependency Injection verwenden.  Dann erzähle ich Ihnen, worum es geht, vergleiche Inversion of Control und Dependency Injection und spreche über die Implementierung in den drei bekanntesten Bibliotheken. <br><br>  Ich arbeite im Yandex.Tracker-Team.  Wir machen ein Lebensmittelanalog von Jira oder Trello.  [...] Wir haben uns entschlossen, unser eigenes Produkt herzustellen, das zuerst intern war.  Jetzt verkaufen wir es aus.  Jeder von Ihnen kann mitmachen, seinen eigenen Tracker erstellen und Aufgaben erledigen - zum Beispiel im Bildungs- oder Geschäftsbereich. <br><br>  Schauen wir uns die Oberfläche an.  In den Beispielen werde ich einige Begriffe aus meiner Region verwenden.  Wir werden versuchen, ein Ticket zu erstellen und die Kommentare zu lesen, die andere Kollegen mir hinterlassen werden. <br><br>  Was ist Dependency Injection im Allgemeinen?  Dies ist ein Programmiermuster, das dem alten amerikanischen Sprichwort, dem Hollywood-Prinzip, entspricht: "Rufen Sie uns nicht an, wir rufen Sie selbst an."  Abhängigkeiten selbst kommen zu uns.  Dies ist in erster Linie ein Muster, keine Bibliothek.  Daher ist ein solches Muster im Prinzip fast überall verbreitet.  Man kann sogar sagen, dass alle Anwendungen Dependency Injection auf die eine oder andere Weise verwenden. <br><br><img src="https://habrastorage.org/webt/wz/cj/8h/wzcj8hmirm_url9gghidooms19y.jpeg"><br><br>  Lassen Sie uns sehen, wie Sie sich Dependency Injection selbst einfallen lassen können, wenn wir bei Null anfangen.  Angenommen, ich habe beschlossen, eine so kleine Klasse zu entwickeln, in der ich über unsere API ein Ticket erstellen werde.  Erstellen Sie beispielsweise eine Instanz der TrackerApi-Klasse.  Es hat eine createTicket-Methode, mit der wir meine E-Mail senden.  Wir erstellen unter meinem Konto ein Ticket mit dem Namen: "Bereiten Sie einen Bericht für Java Meetup vor". <br><br><img src="https://habrastorage.org/webt/sp/dn/md/spdnmdmw57qzfgfdfjtwqwijtiq.jpeg"><br><br>  Schauen wir uns die Implementierung von TrackerApi an.  Hier können wir zum Beispiel Folgendes tun: Eine httpClient-Instanz erstellen.  In einfachen Worten werden wir ein Objekt erstellen, über das wir zur API gelangen.  Über dieses Objekt rufen wir die Execute-Methode auf. <br><br><img src="https://habrastorage.org/webt/x4/2a/iy/x42aiy9l2baljluoanesiq04gay.jpeg"><br><br>  Zum Beispiel eine benutzerdefinierte.  Ich habe externen Code aus diesen Klassen geschrieben, und er wird so etwas verwenden.  Ich erstelle einen neuen TicketCreator und rufe die Methode createTicket auf. <br><br><img src="https://habrastorage.org/webt/g8/al/li/g8allib-7c35r0iulwej8fjgmzu.jpeg"><br><br>  Hier gibt es ein Problem: Jedes Mal, wenn wir ein Ticket erstellen, werden wir httpClient neu erstellen und neu erstellen, obwohl dies im Allgemeinen nicht erforderlich ist.  httpClients sind sehr ernst zu schaffen. <br><br><img src="https://habrastorage.org/webt/eh/pc/o3/ehpco32zfcarfgwgabxumx6deuo.jpeg"><br><br>  Versuchen wir es mal.  Hier sehen Sie das erste Beispiel für Dependency Injection in unserem Code.  Achten Sie darauf, was wir getan haben.  Wir haben unsere Variable im Feld herausgenommen und im Konstruktor eingetragen.  Die Tatsache, dass wir es im Konstruktor eintragen, bedeutet, dass Abhängigkeiten zu uns kommen.  Dies ist die erste Abhängigkeitsinjektion. <br><br><img src="https://habrastorage.org/webt/x0/qw/2r/x0qw2rjibtfionm8och8p4fgxsm.jpeg"><br><br>  Wir haben die Verantwortung auf die Benutzer des Codes verlagert, daher müssen wir jetzt einen httpClient erstellen und ihn beispielsweise an TicketCreator übergeben. <br><br><img src="https://habrastorage.org/webt/x0/qw/2r/x0qw2rjibtfionm8och8p4fgxsm.jpeg"><br><br>  Dies ist auch hier nicht sehr gut, da wir jetzt durch Aufrufen dieser Methode jedes Mal wieder httpClient erstellen. <br><br><img src="https://habrastorage.org/webt/tk/ib/zn/tkibznrpcl80hnoqg7qccgvl0em.jpeg"><br><br>  Deshalb bringen wir es wieder aufs Feld.  Und hier gibt es übrigens ein nicht offensichtliches Beispiel für die Abhängigkeitsinjektion.  Wir können sagen, dass wir Tickets immer unter mir (oder unter jemand anderem) erstellen.  Wir werden jedes einzelne TicketCreator-Objekt unter verschiedenen Benutzern erstellen. <br><br>  Zum Beispiel wird dieser unter mir erschaffen, wenn wir ihn erschaffen.  Und die Zeile, die wir an den Konstruktor übergeben, ist auch Abhängigkeitsinjektion. <br><br><img src="https://habrastorage.org/webt/jl/uq/nb/jluqnb4_2lburqy9jwo3u2hsrg8.jpeg"><br><br>  Wie machen wir es jetzt?  Erstellen Sie eine neue Instanz von TrackerTicketCreator und rufen Sie die Methode auf.  Jetzt können wir sogar eine benutzerdefinierte Methode erstellen, die ein Ticket mit benutzerdefiniertem Text für uns erstellt.  Erstellen Sie beispielsweise ein Ticket "Neuen Auszubildenden einstellen". <br><br><img src="https://habrastorage.org/webt/zr/un/hp/zrunhp6rgmmvg55w5djkz9z1clo.jpeg"><br><br>  Nun wollen wir versuchen zu sehen, wie unser Code aussehen würde, wenn wir Kommentare in diesem Ticket auf die gleiche Weise unter mir lesen wollten.  Dies ist ungefähr der gleiche Code.  Wir würden die getComments-Methode für dieses Ticket aufrufen. <br><br><img src="https://habrastorage.org/webt/qs/hs/ek/qshsek9l2xmb9xskiryj-m6rtzm.jpeg"><br><br>  Wie würde er aussehen?  Wenn wir diese Funktionalität in einem Kommentar-Reader verwenden und duplizieren, duplizieren wir die Erstellung von httpClient.  Das passt nicht zu uns.  Wir wollen es loswerden. <br><br><img src="https://habrastorage.org/webt/tb/cq/ot/tbcqotqdzrcfxgzfzsba-e9us54.jpeg"><br><br>  Gut  Lassen Sie uns nun alle diese Parameter als Abhängigkeitsinjektion und als Konstruktorparameter weiterleiten. <br><br><img src="https://habrastorage.org/webt/qu/po/9k/qupo9kqigu94hoyo5tpcssyoxzg.jpeg"><br><br>  Was ist das Problem hier?  Wir haben alles übersprungen, aber in den Benutzercode schreiben wir jetzt "Boilerplate".  Dies ist eine Art unnötiger Code, den ein Benutzer normalerweise schreiben muss, um eine relativ kleine logische Aktion auszuführen.  Hier müssen wir ständig httpClient, eine API dafür, erstellen und Benutzer-E-Mails auswählen.  Jeder TicketCreator-Benutzer muss dies selbst tun.  Das ist nicht in Ordnung.  Wir werden jetzt versuchen zu sehen, wie es in Bibliotheken aussehen wird, wenn wir versuchen, es zu vermeiden. <br><br>  Lassen Sie uns nun ein wenig abweichen und untersuchen, was Inversion of Control ist, da viele damit Abhängigkeitsinjektion assoziieren. <br><br><img src="https://habrastorage.org/webt/h9/kj/xc/h9kjxcwtgvzwilwyikkiydksznm.jpeg"><br><br>  Inversion of Control ist ein Programmierprinzip, bei dem die von uns verwendeten Objekte nicht von uns erstellt werden.  Wir haben keinerlei Einfluss auf ihren Lebenszyklus.  In der Regel wird die Entität, die diese Objekte erstellt, als IoC-Container bezeichnet.  Viele von Ihnen haben hier vom Frühling gehört.  Die Dokumentation von Spring besagt, dass IoCs auch als Abhängigkeitsinjektion bezeichnet werden.  Sie glauben, dass dies ein und dasselbe ist. <br><br><img src="https://habrastorage.org/webt/fb/ue/oi/fbueoiomwpuhzlrkq3j9acynvcy.jpeg"><br><br>  Was sind die Grundprinzipien?  Objekte werden nicht durch Anwendungscode erstellt, sondern durch einen IoC-Container.  Wir als Bibliotheksnutzer tun nichts, alles kommt für uns allein.  Natürlich ist IoC relativ.  Der IoC-Container selbst erstellt diese Objekte und dies gilt nicht mehr für ihn.  Sie könnten denken, dass IoC nicht nur DI-Bibliotheken implementiert.  Die bekannten Java-Bibliotheken Servlets und Akka Actors, die jetzt in Scala und in Java-Code verwendet werden. <br><br><img src="https://habrastorage.org/webt/mg/cj/qu/mgcjqu4qucgjz1w27guicfvgji8.jpeg"><br><br>  Reden wir über Bibliotheken.  Generell wurden bereits viele Bibliotheken für Java und Kotlin geschrieben.  Ich werde die wichtigsten auflisten: <br><br>  - Frühling, ein großartiger Rahmen.  Sein Hauptteil ist Dependency Injection oder, wie sie sagen, Inversion of Control. <br>  - Guice ist eine Bibliothek, die ungefähr zwischen dem zweiten und dritten Frühling geschrieben wurde, als Spring von XML zu Codebeschreibung wechselte.  Das heißt, als der Frühling noch nicht so schön war. <br>  - Dolch ist das, was Leute auf Android normalerweise benutzen. <br><br>  Versuchen wir, unser Beispiel für Spring umzuschreiben. <br><br><img src="https://habrastorage.org/webt/n-/tq/bl/n-tqblihbupgiumevmkyjad7wnc.jpeg"><br><br>  Wir hatten unseren TrackerApi.  Ich habe den Benutzer hier nicht kurz eingeschlossen.  Nehmen wir an, wir versuchen in Dependency Injection, dies für httpClient zu tun.  Dazu müssen wir es mit einer Anmerkung deklarieren.  <a href="https://habr.com/ru/users/component/" class="user_link">Die Komponente</a> , die gesamte Klasse und insbesondere der Konstruktor werden mit der <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired-</a> Annotation <a href="https://habr.com/ru/users/autowired/" class="user_link">deklariert</a> .  Was bedeutet das für den Frühling? <br><br><img src="https://habrastorage.org/webt/qj/ef/i8/qjefi88q9vtuab9n16-rchaphzw.jpeg"><br><br>  Wir haben eine solche Konfiguration im Code, die durch die Annotation <a href="https://habr.com/ru/users/component/" class="user_link">Component</a> Scan angezeigt wird.  Dies bedeutet, dass wir versuchen werden, den gesamten Baum unserer Klassen in dem Paket durchzugehen, in dem er enthalten ist.  Weiter landeinwärts werden wir versuchen, alle Klassen zu finden, die in der Annotation " <a href="https://habr.com/ru/users/component/" class="user_link">Component"</a> markiert sind. <br><br><img src="https://habrastorage.org/webt/n-/tq/bl/n-tqblihbupgiumevmkyjad7wnc.jpeg"><br><br>  Diese Komponenten fallen in den IoC-Container.  Es ist wichtig für uns, dass alles für uns fällt.  Wir markieren nur, was wir ankündigen möchten.  Damit etwas zu uns kommt, müssen wir es mit der <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired-</a> Annotation im Konstruktor deklarieren. <br><br><img src="https://habrastorage.org/webt/ym/hq/le/ymhqlevva5gqgnoieckrw6ymm2k.jpeg"><br><br>  TicketCreator markieren wir genauso. <br><br><img src="https://habrastorage.org/webt/xk/fa/i_/xkfai_wibiwgnp1lpuzfi9fhbcs.jpeg"><br><br>  Und CommentReader auch. <br><br><img src="https://habrastorage.org/webt/qj/ef/i8/qjefi88q9vtuab9n16-rchaphzw.jpeg"><br><br>  Nun schauen wir uns noch einmal die Konfiguration an.  Wie bereits erwähnt, speichert Component Scan alles in einem IoC-Container.  Aber es gibt einen Punkt, die sogenannte Fabrikmethode.  Wir haben die httpClient-Methode, die wir nicht als Klasse erstellen, da httpClient aus der Bibliothek zu uns kommt.  Er hat kein Verständnis dafür, was Frühling ist usw. Wir werden es direkt in der Konfiguration erstellen.  Dazu schreiben wir eine Methode, die sie normalerweise einmal erstellt, und markieren sie mit der Bean-Annotation. <br><br><img src="https://habrastorage.org/webt/br/ba/rf/brbarflmwiprwpmlknhdqpl5muc.jpeg"><br><br>  Was sind die Vor- und Nachteile?  Das Hauptplus - Frühling ist in der Welt sehr verbreitet.  Das nächste Plus und Minus ist das automatische Scannen.  Wir sollten nicht explizit angeben, dass wir der IoC einen Container hinzufügen möchten, außer Anmerkungen über die Klassen selbst.  Genug Anmerkungen.  Und das Minus ist genau das gleiche: Wenn wir im Gegenteil die Kontrolle darüber haben wollen, dann bietet uns Spring dies nicht an.  Es sei denn, wir können in unserem Team sagen: „Nein, das werden wir nicht tun.  Wir müssen irgendwo eindeutig etwas vorschreiben.  Nur in der Konfiguration, wie wir es mit den Bohnen gemacht haben. <br><br>  Auch aus diesem Grund tritt ein langsamer Start auf.  Wenn die Anwendung gestartet wird, muss Spring all diese Klassen durchgehen und herausfinden, was in den IoC-Container eingefügt werden soll.  Es verlangsamt ihn.  Der größte Nachteil des Frühlings scheint mir der Abhängigkeitsbaum zu sein.  Es wird bei der Kompilierung nicht geprüft.  Wenn der Frühling irgendwann beginnt, muss er verstehen, ob ich eine solche Abhängigkeit in mir habe.  Wenn sich später herausstellt, dass es sich nicht im Abhängigkeitsbaum befindet, erhalten Sie zur Laufzeit einen Fehler.  Und wir in Java wollen keinen Laufzeitfehler.  Wir möchten, dass der Code für uns kompiliert wird.  Das bedeutet, dass es funktioniert. <br><br><img src="https://habrastorage.org/webt/nk/2l/6x/nk2l6x7k1fc6-undofdq53ppj8i.jpeg"><br><br>  Werfen wir einen Blick auf Guice.  Dies ist eine Bibliothek, die, wie gesagt, zwischen dem zweiten und dritten Frühling entstanden ist.  Die Schönheit, die wir gesehen haben, war nicht.  Es gab XML.  Um dieses Problem zu beheben, und wurde von Guice geschrieben.  Und hier sehen Sie, dass wir im Gegensatz zur Konfiguration ein Modul schreiben.  Darin deklarieren wir explizit, welche Klassen in dieses Modul eingefügt werden sollen: TrackerAPI, TrackerTicketCreator und alle anderen Klassen.  Ein Analogon zur Bean-Annotation hier ist <a href="https://habr.com/ru/users/provides/" class="user_link">Provides</a> , das auf die gleiche Weise httpClient erstellt. <br><br><img src="https://habrastorage.org/webt/tf/wc/hn/tfwchnamip5ovyhno-7j_9twrae.jpeg"><br><br>  Wir müssen jede dieser Bohnen deklarieren.  Wir werden ein Beispiel für <a href="https://habr.com/ru/users/singleton/" class="user_link">Singleton nennen</a> .  <a href="https://habr.com/ru/users/singleton/" class="user_link">Singleton</a> wird jedoch genau sagen, dass eine solche Bean genau einmal erstellt wird.  Wir werden es nicht ständig neu erstellen.  Und <a href="https://habr.com/ru/users/inject/" class="user_link">Inject</a> ist jeweils ein Analogon von <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired</a> . <br><br><img src="https://habrastorage.org/webt/32/i9/-5/32i9-5iuc58qvzmpiahf_3odv6k.jpeg"><br><br>  Eine kleine Tablette mit dem, was dazu gehört. <br><br><img src="https://habrastorage.org/webt/ny/5o/i4/ny5oi43in62gaprwj4ym5tvuxh8.jpeg"><br><br>  Was sind die Vor- und Nachteile?  Vorteile: Es scheint mir einfacher und verständlicher zu sein als die XML-Version von Spring.  Schnellerer Start.  Und hier kommen die Nachteile: Es erfordert eine explizite Deklaration der verwendeten Bohnen.  Wir hätten Bean schreiben sollen.  Andererseits ist dies ein Plus, wie wir bereits gesagt haben.  Dies ist ein Spiegelbild dessen, was der Frühling hat.  Natürlich ist es weniger verbreitet als der Frühling.  Das ist sein natürliches Minus.  Und es gibt genau das gleiche Problem: Der Abhängigkeitsbaum wird in der Kompilierungsphase nicht überprüft. <br><br>  Als die Jungs anfingen, Guice für Android zu verwenden, stellten sie fest, dass es ihnen immer noch an Startgeschwindigkeit mangelte.  Aus diesem Grund haben sie beschlossen, ein einfacheres und primitiveres Abhängigkeitsinjektionsframework zu schreiben, mit dem sie die Anwendung schnell starten können, da dies für Android sehr wichtig ist. <br><br><img src="https://habrastorage.org/webt/5x/sp/l7/5xspl7f9z-2xoy22flag9sgrdzy.jpeg"><br><br>  Hier ist die Terminologie dieselbe.  Dolch hat genau die gleichen Module wie Guice.  Sie sind jedoch bereits mit Anmerkungen versehen, nicht wie bei der Vererbung durch die Klasse.  Daher wird das Prinzip beibehalten. <br><br>  Das einzige Minus ist, dass wir im Modul immer explizit angeben müssen, wie die Beans erstellt werden.  In Guice könnten wir die Kreation von Bohnen innerhalb der Bohne selbst geben.  Wir mussten nicht sagen, zu welchen Abhängigkeiten wir weiterleiten müssen.  Und hier müssen wir das explizit sagen. <br><br><img src="https://habrastorage.org/webt/tu/q7/f8/tuq7f8jjaj-ouvsw1faz8e_8wgm.jpeg"><br><br>  In Dagger gibt es das Konzept einer Komponente, da Sie nicht zu manuell eingeben möchten.  Eine Komponente bindet Module, wenn ein Bin von einem Modul deklariert werden soll, damit es in ein anderes Modul übernommen werden kann.  Dies ist ein anderes Konzept.  Eine Bean aus einem Modul kann mithilfe einer Komponente eine Bean aus einem anderen Modul „injizieren“. <br><br><img src="https://habrastorage.org/webt/16/sn/41/16sn412k1exgnqbuil1mogbtpom.jpeg"><br><br>  Hier ist ungefähr dieselbe Übersichtstafel - was sich im Fall von Inject oder Modulen geändert hat oder nicht. <br><br><img src="https://habrastorage.org/webt/pm/v1/ur/pmv1urcl1djm48azfby8ux6uqbs.jpeg"><br><br>  Was sind die vorteile  Es ist noch einfacher als Guice.  Der Start ist noch schneller als bei Guice.  Und es wird wahrscheinlich nicht mehr schneller, weil Dagger das Nachdenken völlig aufgegeben hat.  Dies ist genau der Teil der Bibliothek in Java, der dafür verantwortlich ist, den Zustand eines Objekts, seine Klasse und Methoden zu untersuchen.  Das heißt, Sie erhalten den Status zur Laufzeit.  Daher wird keine Reflexion verwendet.  Er geht nicht und scannt nicht, welche Abhängigkeiten jemand hat.  Aber deshalb fängt er sehr schnell an. <br><br>  Wie macht er das?  Codegenerierung verwenden. <br><br><img src="https://habrastorage.org/webt/tu/q7/f8/tuq7f8jjaj-ouvsw1faz8e_8wgm.jpeg"><br><br>  Wenn wir zurückblicken, werden wir die Interface-Komponente sehen.  Wir haben keine Implementierung dieser Schnittstelle implementiert, Dagger erledigt dies für uns.  Und es wird möglich sein, die Schnittstelle in der Anwendung weiter zu verwenden. <br><br><img src="https://habrastorage.org/webt/pm/v1/ur/pmv1urcl1djm48azfby8ux6uqbs.jpeg"><br><br>  Natürlich ist es in der Android-Welt aufgrund dieser Geschwindigkeit sehr verbreitet.  Der Abhängigkeitsbaum wird sofort beim Kompilieren überprüft, da es nichts gibt, was wir zur Laufzeit verzögert überprüfen werden. <br><br>  Was sind die Nachteile?  Er hat weniger Möglichkeiten.  Es ist ausführlicher als Guice und Spring. <br><br><img src="https://habrastorage.org/webt/cx/m8/ng/cxm8ngienchgjtm4yc1m7uo26bo.jpeg"><br><br>  Innerhalb dieser Bibliotheken entstand in Java eine Initiative - das sogenannte JSR-330.  JSR ist eine Anforderung, die Sprachspezifikation zu ändern oder um einige zusätzliche Bibliotheken zu ergänzen.  Ein solcher Standard wurde basierend auf Guice vorgeschlagen, und dieser Bibliothek wurden <a href="https://habr.com/ru/users/inject/" class="user_link">Inject-</a> Anmerkungen hinzugefügt.  Dementsprechend unterstützen es Spring und Guice. <br><br>  Welche Schlussfolgerungen können gezogen werden?  Java hat viele verschiedene Bibliotheken für DI.  Und Sie müssen verstehen, warum wir einen bestimmten von ihnen nehmen.  Wenn wir Android nehmen, dann gibt es schon keine Wahl, wir benutzen Dolch.  Wenn wir in die Backend-Welt gehen, schauen wir uns bereits an, was am besten zu uns passt.  Und für die erste Studie zu Dependency Injection scheint mir Guice besser zu sein als Spring.  Darin ist nichts überflüssig.  Sie können sehen, wie es funktioniert, fühlen. <br><br>  Für weitere Studien empfehle ich Ihnen, sich mit der Dokumentation all dieser Bibliotheken und der Zusammensetzung von JSR vertraut zu machen: <br>  - <a href="https://spring.io/">Frühling</a> <br>  - <a href="https://github.com/google/guice/">Guice</a> <br>  - <a href="https://github.com/google/dagger">Dolch 2</a> <br>  - <a href="https://github.com/javax-inject/javax-inject">JSR-330</a> <br><br>  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de478788/">https://habr.com/ru/post/de478788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de478764/index.html">JavaScript-Fehler: beheben, verarbeiten, reparieren</a></li>
<li><a href="../de478766/index.html">Passen Sie die Zuordnung von Spring MVC-Controllern an</a></li>
<li><a href="../de478772/index.html">Faltungsstruktur</a></li>
<li><a href="../de478774/index.html">Neujahrsstimmung von Arduino und Stöcken</a></li>
<li><a href="../de478782/index.html">Erlangung der Genehmigung zum Fliegen einer Drohne (BVS, UAV) in der Russischen Föderation</a></li>
<li><a href="../de478790/index.html">Julia und Verteilungssemantik</a></li>
<li><a href="../de478796/index.html">Undergraduate in den USA: Unkonventioneller Weg zu Top High Schools</a></li>
<li><a href="../de478798/index.html">Graphen, das immer noch nicht konnte</a></li>
<li><a href="../de478802/index.html">React-Admin und Django ruhen Framework</a></li>
<li><a href="../de478804/index.html">Altertümer: Je schlechter, desto besser oder besser Sound Blaster Pro 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>