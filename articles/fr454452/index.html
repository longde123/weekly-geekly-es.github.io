<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏼 👩🏻‍🏫 ▪️ Nous affichons le contenu sur l'image reconnue selon certaines règles 🎹 💅🏾 👨🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parfois, lorsque vous lisez une tâche technique et définissez des délais de mise en œuvre, sous-estimez le temps et les efforts consacrés à la résolut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous affichons le contenu sur l'image reconnue selon certaines règles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p>  Parfois, lorsque vous lisez une tâche technique et définissez des délais de mise en œuvre, sous-estimez le temps et les efforts consacrés à la résolution d'un problème particulier.  Il arrive qu'un point, qui est estimé par le temps par semaine, soit réalisé à une heure, et parfois vice versa.  Mais cet article ne traite pas de cela.  Il s'agit d'une démonstration de l'évolution d'une solution à un problème.  De sa création à sa mise en œuvre. </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br><h1 id="ispolzuemye-terminy">  Termes utilisés </h1><br><ul><li><p>  Marque ou marqueur - une image chargée dans le moteur AR, qui est reconnue par l'appareil photo de l'appareil (tablette ou smartphone) et qui peut être identifiée de manière unique </p><br></li><li><p>  Trouvé - état du marqueur lorsqu'il a été détecté dans le champ de vision de la caméra </p><br></li><li><p>  Lost - état du marqueur lorsqu'il a été perdu de la vue de la caméra </p><br></li><li><p>  Il peut être affiché - lorsque le marqueur est trouvé, nous affichons le contenu attaché au marqueur </p><br></li><li><p>  Ne peut pas être affiché - lorsque nous trouvons le marqueur, n'affichez pas le contenu - Contenu attaché au marqueur - tout objet (modèle 3D, sprite, système de particules, etc.) qui peut être attaché au marqueur et qui, en conséquence, sera affiché à l'écran si un marqueur est trouvé </p><br></li><li><p>  Marque, marqueur, trouvé, perdu - les états de base inhérents à tous les moteurs offrant une fonctionnalité de reconnaissance </p><br></li><li><p>  Il peut être affiché et ne peut pas être affiché - l'état utilisé pour résoudre ce problème </p><br><p>  <strong>Un exemple:</strong> </p><br><ul><li>  Téléchargez l'application =&gt; toutes les marques téléchargées sont reconnaissables </li><li>  Nous essayons de reconnaître =&gt; l'état du marqueur passe à "trouvé" </li><li>  Si le marqueur peut être affiché =&gt; indiquer que le marqueur est «trouvé» et nous affichons le modèle attaché au marqueur </li><li>  Si le marqueur ne peut pas être affiché =&gt; l'état du marqueur est «trouvé», mais le modèle attaché n'est pas affiché </li><li>  La marque a disparu du champ de vision de la caméra =&gt; on change l'état en "perdu" </li></ul><br></li></ul><br><h1 id="vvedenie">  Présentation </h1><br><p>  Il y a une grande carte postale de la taille d'une feuille A4.  Il est divisé en 4 parties égales (format d'une partie A5), sur chacune de ces parties il y a: </p><br><ul><li>  Une marque de coin complète (1) </li><li>  La moitié de la marque latérale inférieure (5) </li><li>  La moitié de la marque latérale supérieure (8) </li><li>  Quart de centre (9) </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="image"></p><br><p> Si vous avez travaillé avec des moteurs de reconnaissance, par exemple, Vuforia, vous savez probablement que la «qualité de reconnaissance» n'existe pas.  La marque est reconnue ou non reconnue.  Par conséquent, si le moteur «voit» la marque, il change l'état en <code>Find</code> et la méthode <code>OnSuccess()</code> est <code>OnSuccess()</code> , s'il la «perd», l'état change en <code>Lost</code> et la méthode <code>OnLost()</code> est <code>OnLost()</code> .  En conséquence, à partir des conditions existantes et des données saisies, une situation s'est produite lorsque la possession d'une partie de la carte (la moitié ou le quart) a permis de reconnaître la marque. </p><br><p>  Le fait est que selon la tâche technique, un déverrouillage progressif des personnages était prévu.  Dans cette situation, un déverrouillage progressif est possible, mais étant donné qu'il n'y a personne qui essaie de reconnaître un quart ou la moitié de la marque. </p><br><h1 id="formulirovka-zadachi">  Énoncé de tâche </h1><br><p>  Il est nécessaire de mettre en œuvre une logique sous forme de code de programme, ce qui assure le déverrouillage progressif du contenu attaché aux marqueurs.  De l'emplacement des éléments sur la carte, il est connu que les marqueurs 1, 2, 3, 4 sont disponibles pour l'affichage initial. </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="image"></p><br><p>  Si le contenu a été lu et affiché sur 2 marqueurs, par exemple 2 et 3, alors nous autorisons l'affichage du contenu sur le marqueur 6. Si le marqueur 1 n'a pas encore été lu, alors l'accès au marqueur 5 est fermé.  Plus loin par analogie.  Nous autorisons en quelque sorte l'affichage du contenu sur les marqueurs latéraux uniquement lorsque nous avons lu les marqueurs de coin adjacents. </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="image"></p><br><p>  Si des marqueurs de 1 à 8 sont disponibles et trouvés, ouvrez le contenu du marqueur 9 pour l'affichage. Chaque marqueur a 2 états - le contenu est disponible et non disponible pour l'affichage, dont le champ <code>public bool IsActive;</code> est responsable <code>public bool IsActive;</code> </p><br><p>  Il est immédiatement clair que cela devrait être soit une machine à états avec une transition entre les États, soit une mise en œuvre du modèle «État». </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Le résultat n'était pas un, pas un autre.  Je ne peux pas dire que c'est une béquille car la solution répondait pleinement aux exigences du début de l'article.  Mais vous pouvez discuter avec moi. </p></div></div><br><p>  Sur ce point, je vous donne l'opportunité de réfléchir un peu aux solutions et implémentations possibles de cette tâche.  Il m'a fallu environ 5 heures pour réaliser et fixer dans ma tête l'image de la décision. </p><br><p>  Pour plus de clarté, j'ai enregistré une vidéo sur laquelle le résultat final de l'algorithme (si vous pouvez l'appeler ainsi) est déjà capturé. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu">  Approches de solution </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1. Des marqueurs de coin au centre </h2><br><p>  La première chose qui m'est venue à l'esprit était de présenter les interactions entre les marqueurs du coin au centre.  Sous forme graphique, cela ressemble à ceci: </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="image"></p><br><p>  Les problèmes: </p><br><ol><li>  Comment déterminer quelle étiquette latérale changer d'état?  Celui de gauche ou de droite?  Nous forçons également chaque marqueur à «connaître» l'existence d'un marqueur central. </li><li>  Il est nécessaire d'ajouter des dépendances non évidentes de la catégorie: le marqueur latéral souscrit à l'événement de marqueur de coin IsChangedEventCallback (), des actions similaires doivent être effectuées pour le marqueur central. </li><li>  Si nous considérons chaque type de marqueur comme une entité, alors dans la hiérarchie de ces entités, nous transmettrons la commande de changement d'état de bas en haut.  Ce n'est pas très bon, car nous nous lions étroitement avec le nombre, dans ce cas, les marqueurs angulaires, perdant la capacité de mise à l'échelle. </li></ol><br><p>  Incapable de mettre la solution ci-dessus dans ma tête en raison des nombreux cas marginaux et de la complexité de la perception, j'ai changé l'approche pour choisir un marqueur sur lequel les dépendances commencent à se propager. </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2. Les latéraux connaissent le centre et l'angle </h2><br><p>  En réfléchissant à la solution du paragraphe 3 de l'approche précédente, l'idée est venue de changer le type de marqueur, à partir duquel les états des autres marqueurs commencent à changer.  Comme les principaux marqueurs latéraux ont été pris.  Dans ce scénario, les communications (dépendances) ressemblent à ceci: </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="image"></p><br><p>  De là, il devient immédiatement clair que les connexions du latéral au central sont superflues, car le marqueur latéral n'a besoin de rien savoir du marqueur central, donc cette approche a été immédiatement transformée en finale. </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3. Le central connaît tout le monde, les côtés connaissent le coin </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="image"></p><br><p>  La solution finale est lorsque le marqueur latéral connaît les coins, que les coins «vivent leur vie» et que le central connaît l'état de tous les marqueurs. </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="image"></p><br><p>  Travailler avec la vue de carte postale n'est pas très pratique.  Les relations entre les entités ne semblent pas assez claires pour les convertir facilement en code.  Une tentative d'interprétation sous la forme d'un arbre binaire peut introduire une certaine ambiguïté.  Mais ici, l'une des propriétés de l'arbre binaire est violée, donc l'ambiguïté disparaît immédiatement.  D'où nous pouvons conclure que cette représentation peut être interprétée sans ambiguïté et utilisée pour représenter graphiquement la solution du problème.  Sur la base de ces conclusions, nous utiliserons la notation graphique, à savoir: </p><br><ul><li>  Angle Marker - Angle Node (niveau 3) </li><li>  Marqueur latéral - Noeud latéral (niveau 2) </li><li>  Marqueur central - Noeud central (niveau 1) </li></ul><br><p>  Avantages: </p><br><ol><li>  Les dépendances entre les marqueurs sont évidentes et évidentes. </li><li>  Chacun des niveaux peut être représenté sous la forme de 3 entités, chacune composée de parties de base, mais avec leurs ajouts inhérents à chacun des niveaux </li><li>  Pour vous développer, vous n'aurez qu'à ajouter un nouveau type de nœud avec ses propres caractéristiques </li><li>  Cette solution est facile à imaginer dans un style OO (orienté objet) </li></ol><br><h1 id="realizaciya">  Implémentation </h1><br><h2 id="bazovye-suschnosti">  Entités de base </h2><br><p>  Créons une interface qui contient les éléments inhérents à chaque entité (nom, état): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Ensuite, nous décrivons l'essence de chaque nœud: </p><br><ul><li>  <strong>CornerNode</strong> - un nœud angulaire.  <code>INode</code> interface <code>INode</code> : </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Pourquoi <code>IsActive = true</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">La réponse</b> <div class="spoiler_text"><p>  D'après les conditions du problème, le contenu des marqueurs de coin est initialement disponible pour la reconnaissance. </p></div></div><br><ul><li>  <strong>SideNode</strong> - un nœud latéral.  Nous implémentons l'interface <code>INode</code> , mais ajoutons les <code>RightCornerNode</code> <code>LeftCornerNode</code> et <code>RightCornerNode</code> .  Ainsi, le nœud latéral conserve son état en lui-même et ne connaît que l'existence de nœuds latéraux. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong> est le nœud central.  Comme dans les précédents, nous implémentons <code>INode</code> .  Ajoutez un champ de type <code>List&lt;INode&gt;</code> . </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard">  Classe Opencard </h2><br><h3 id="privatnye-metody-i-polya">  Méthodes et champs privés </h3><br><p>  Maintenant que nous avons créé tous les éléments de la carte que nous avons créés (toutes sortes de marqueurs), nous pouvons commencer à décrire l'essence de la carte elle-même.  Je n'ai pas l'habitude de démarrer une classe avec un constructeur.  Je commence toujours par les méthodes de base inhérentes à une entité particulière.  Commençons par les champs privés et les méthodes privées. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p>  Avec les champs, tout est assez simple.  2 listes avec nœuds latéraux angulaires et un champ du nœud central. </p><br><p>  Ensuite, vous devez clarifier un peu.  Le fait est que le marqueur lui-même est de type <code>Trackable</code> et il n'a aucune idée (et ne devrait pas avoir) qu'il fait partie d'une autre logique là-bas.  Par conséquent, tout ce que nous pouvons utiliser pour contrôler l'affichage est son nom.  Par conséquent, si le marqueur lui-même ne stocke pas le type de nœud auquel il appartient, nous devons transférer cette responsabilité à notre classe <code>OpenCard</code> .  Sur cette base, nous décrivons d'abord 3 méthodes privées chargées de déterminer le type de nœud. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Mais ces méthodes n'ont pas de sens à utiliser directement.  Il n'est pas pratique d'utiliser des valeurs booléennes lorsque vous travaillez avec des objets d'un autre niveau d'abstraction.  Par conséquent, nous allons créer une <code>enum NodeType</code> simple <code>enum NodeType</code> et une méthode privée <code>GetNodeType()</code> , qui encapsule en elle-même toute la logique associée à la détermination du type de nœud. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody">  Méthodes publiques </h3><br><ul><li>  <code>IsExist</code> est une méthode qui renvoie une valeur booléenne indiquant si notre marque appartient à une carte postale.  Il s'agit d'une méthode auxiliaire, qui est effectuée de sorte que si le marqueur n'appartient à aucune carte, nous pouvons afficher le contenu dessus. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code> - une méthode (comme son nom l'indique) dans laquelle nous vérifions l'état actuel du nœud et changeons son état. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor">  Constructeur </h3><br><p>  Lorsque toutes les cartes sont sur la table, nous pouvons enfin aller chez le constructeur.  Il peut y avoir plusieurs approches à l'initialisation.  Mais j'ai décidé de débarrasser autant que possible la classe <code>OpenCard</code> des gestes inutiles.  Il devrait répondre avec nous si le contenu est disponible pour l'affichage ou non.  Par conséquent, nous demandons simplement des listes d'entrée de nœuds de 2 types et un nœud central. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p>  Notez que puisque le nœud central n'a besoin que de vérifier la condition que tous les autres nœuds <code>true</code> , il nous suffit de <code>INode</code> implicitement <code>INode</code> nœuds angulaires et centraux entrés dans le constructeur en type <code>INode</code> . </p><br><h3 id="inicializaciya">  Initialisation </h3><br><p>  Quelle est la façon la plus pratique de créer des objets qui n'ont pas besoin d'être attachés (comme les composants <code>MonoBehaviour</code> ) à un GameObject?  - D' <code>ScriptableObject</code> , <code>ScriptableObject</code> .  De plus, pour plus de commodité, ajoutez l'attribut <code>MenuItem</code> , qui simplifiera la création de nouvelles cartes. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p>  L'accord final dans notre composition sera un passage à travers le tableau des <code>ScriptableObject</code> ajoutés (le cas échéant) et la création de cartes postales à partir d'eux.  Après cela, il nous reste dans la méthode de <code>Update</code> à <code>Update</code> de vérifier simplement si nous pouvons afficher le contenu ou non. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody">  Conclusions </h1><br><p>  Pour moi personnellement, les conclusions étaient les suivantes: </p><br><ol><li>  Lorsque vous essayez de résoudre un problème, vous devez essayer de diviser ses éléments en parties atomiques.  En outre, compte tenu de toutes les options possibles pour l'interaction entre ces parties atomiques, vous devez commencer par l'objet, d'où proviendront potentiellement plus de connexions.  D'une autre manière, il peut être formulé comme suit: s'efforcer de commencer à résoudre des problèmes avec des éléments qui, potentiellement, seront moins fiables </li><li>  Si possible, vous devez essayer de présenter les données source sous une forme différente.  Dans mon cas, la représentation graphique m'a beaucoup aidé. </li><li>  Chaque entité est séparée de l'autre par le nombre de connexions qui pourraient en découler. </li><li>  De nombreuses tâches appliquées qui sont plus habituelles à résoudre en écrivant un algorithme peuvent être représentées dans le style OO </li><li>  Une solution qui a des dépendances en anneau est une mauvaise solution </li><li>  S'il est difficile de garder toutes les connexions entre les objets dans votre tête, c'est une mauvaise décision </li><li>  Si vous ne pouvez pas garder à l'esprit la logique de l'interaction des objets - c'est une mauvaise décision </li><li>  Vos béquilles ne sont pas toujours une mauvaise décision </li></ol><br><p>  Connaissez-vous une autre solution?  - Écrivez dans les commentaires. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454452/">https://habr.com/ru/post/fr454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454440/index.html">Petty Little Fun # 2: Starlette</a></li>
<li><a href="../fr454442/index.html">Comment choisir un réseau proxy pour votre entreprise: 3 conseils pratiques</a></li>
<li><a href="../fr454444/index.html">Nous profilons le chargement de Habr ou comment 189 requêtes sur la page rendent l'influence</a></li>
<li><a href="../fr454446/index.html">Quoi de neuf en C # 8?</a></li>
<li><a href="../fr454450/index.html">Comment Edison a inventé le sans fil et n'a rien compris</a></li>
<li><a href="../fr454456/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 7. FAQ</a></li>
<li><a href="../fr454458/index.html">Tests métamorphiques: pourquoi presque personne ne connaît cette technique prometteuse</a></li>
<li><a href="../fr454460/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 300 (27 mai - 2 juin)</a></li>
<li><a href="../fr454462/index.html">Photogramme sans papier photo</a></li>
<li><a href="../fr454464/index.html">Développement de tests visuels basés sur Gemini et Storybook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>