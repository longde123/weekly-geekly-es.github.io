<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèº üë©üèª‚Äçüè´ ‚ñ™Ô∏è Nous affichons le contenu sur l'image reconnue selon certaines r√®gles üéπ üíÖüèæ üë®üèª‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parfois, lorsque vous lisez une t√¢che technique et d√©finissez des d√©lais de mise en ≈ìuvre, sous-estimez le temps et les efforts consacr√©s √† la r√©solut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous affichons le contenu sur l'image reconnue selon certaines r√®gles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454452/"><p>  Parfois, lorsque vous lisez une t√¢che technique et d√©finissez des d√©lais de mise en ≈ìuvre, sous-estimez le temps et les efforts consacr√©s √† la r√©solution d'un probl√®me particulier.  Il arrive qu'un point, qui est estim√© par le temps par semaine, soit r√©alis√© √† une heure, et parfois vice versa.  Mais cet article ne traite pas de cela.  Il s'agit d'une d√©monstration de l'√©volution d'une solution √† un probl√®me.  De sa cr√©ation √† sa mise en ≈ìuvre. </p><br><p><img src="https://habrastorage.org/webt/qh/ns/i7/qhnsi7xrjjlbxp7ob1rqgsmpo9o.jpeg"></p><a name="habracut"></a><br><h1 id="ispolzuemye-terminy">  Termes utilis√©s </h1><br><ul><li><p>  Marque ou marqueur - une image charg√©e dans le moteur AR, qui est reconnue par l'appareil photo de l'appareil (tablette ou smartphone) et qui peut √™tre identifi√©e de mani√®re unique </p><br></li><li><p>  Trouv√© - √©tat du marqueur lorsqu'il a √©t√© d√©tect√© dans le champ de vision de la cam√©ra </p><br></li><li><p>  Lost - √©tat du marqueur lorsqu'il a √©t√© perdu de la vue de la cam√©ra </p><br></li><li><p>  Il peut √™tre affich√© - lorsque le marqueur est trouv√©, nous affichons le contenu attach√© au marqueur </p><br></li><li><p>  Ne peut pas √™tre affich√© - lorsque nous trouvons le marqueur, n'affichez pas le contenu - Contenu attach√© au marqueur - tout objet (mod√®le 3D, sprite, syst√®me de particules, etc.) qui peut √™tre attach√© au marqueur et qui, en cons√©quence, sera affich√© √† l'√©cran si un marqueur est trouv√© </p><br></li><li><p>  Marque, marqueur, trouv√©, perdu - les √©tats de base inh√©rents √† tous les moteurs offrant une fonctionnalit√© de reconnaissance </p><br></li><li><p>  Il peut √™tre affich√© et ne peut pas √™tre affich√© - l'√©tat utilis√© pour r√©soudre ce probl√®me </p><br><p>  <strong>Un exemple:</strong> </p><br><ul><li>  T√©l√©chargez l'application =&gt; toutes les marques t√©l√©charg√©es sont reconnaissables </li><li>  Nous essayons de reconna√Ætre =&gt; l'√©tat du marqueur passe √† "trouv√©" </li><li>  Si le marqueur peut √™tre affich√© =&gt; indiquer que le marqueur est ¬´trouv√©¬ª et nous affichons le mod√®le attach√© au marqueur </li><li>  Si le marqueur ne peut pas √™tre affich√© =&gt; l'√©tat du marqueur est ¬´trouv√©¬ª, mais le mod√®le attach√© n'est pas affich√© </li><li>  La marque a disparu du champ de vision de la cam√©ra =&gt; on change l'√©tat en "perdu" </li></ul><br></li></ul><br><h1 id="vvedenie">  Pr√©sentation </h1><br><p>  Il y a une grande carte postale de la taille d'une feuille A4.  Il est divis√© en 4 parties √©gales (format d'une partie A5), sur chacune de ces parties il y a: </p><br><ul><li>  Une marque de coin compl√®te (1) </li><li>  La moiti√© de la marque lat√©rale inf√©rieure (5) </li><li>  La moiti√© de la marque lat√©rale sup√©rieure (8) </li><li>  Quart de centre (9) </li></ul><br><p><img src="https://habrastorage.org/webt/_k/87/c4/_k87c4c_mahdxfrbsijiidjauro.jpeg" alt="image"></p><br><p> Si vous avez travaill√© avec des moteurs de reconnaissance, par exemple, Vuforia, vous savez probablement que la ¬´qualit√© de reconnaissance¬ª n'existe pas.  La marque est reconnue ou non reconnue.  Par cons√©quent, si le moteur ¬´voit¬ª la marque, il change l'√©tat en <code>Find</code> et la m√©thode <code>OnSuccess()</code> est <code>OnSuccess()</code> , s'il la ¬´perd¬ª, l'√©tat change en <code>Lost</code> et la m√©thode <code>OnLost()</code> est <code>OnLost()</code> .  En cons√©quence, √† partir des conditions existantes et des donn√©es saisies, une situation s'est produite lorsque la possession d'une partie de la carte (la moiti√© ou le quart) a permis de reconna√Ætre la marque. </p><br><p>  Le fait est que selon la t√¢che technique, un d√©verrouillage progressif des personnages √©tait pr√©vu.  Dans cette situation, un d√©verrouillage progressif est possible, mais √©tant donn√© qu'il n'y a personne qui essaie de reconna√Ætre un quart ou la moiti√© de la marque. </p><br><h1 id="formulirovka-zadachi">  √ânonc√© de t√¢che </h1><br><p>  Il est n√©cessaire de mettre en ≈ìuvre une logique sous forme de code de programme, ce qui assure le d√©verrouillage progressif du contenu attach√© aux marqueurs.  De l'emplacement des √©l√©ments sur la carte, il est connu que les marqueurs 1, 2, 3, 4 sont disponibles pour l'affichage initial. </p><br><p><img src="https://habrastorage.org/webt/r_/a4/1-/r_a41-b9ezh2oxrcejsffh-ifus.jpeg" alt="image"></p><br><p>  Si le contenu a √©t√© lu et affich√© sur 2 marqueurs, par exemple 2 et 3, alors nous autorisons l'affichage du contenu sur le marqueur 6. Si le marqueur 1 n'a pas encore √©t√© lu, alors l'acc√®s au marqueur 5 est ferm√©.  Plus loin par analogie.  Nous autorisons en quelque sorte l'affichage du contenu sur les marqueurs lat√©raux uniquement lorsque nous avons lu les marqueurs de coin adjacents. </p><br><p><img src="https://habrastorage.org/webt/ux/qs/xu/uxqsxuydrxzijfakmcumpguqkg8.jpeg" alt="image"></p><br><p>  Si des marqueurs de 1 √† 8 sont disponibles et trouv√©s, ouvrez le contenu du marqueur 9 pour l'affichage. Chaque marqueur a 2 √©tats - le contenu est disponible et non disponible pour l'affichage, dont le champ <code>public bool IsActive;</code> est responsable <code>public bool IsActive;</code> </p><br><p>  Il est imm√©diatement clair que cela devrait √™tre soit une machine √† √©tats avec une transition entre les √âtats, soit une mise en ≈ìuvre du mod√®le ¬´√âtat¬ª. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  Le r√©sultat n'√©tait pas un, pas un autre.  Je ne peux pas dire que c'est une b√©quille car la solution r√©pondait pleinement aux exigences du d√©but de l'article.  Mais vous pouvez discuter avec moi. </p></div></div><br><p>  Sur ce point, je vous donne l'opportunit√© de r√©fl√©chir un peu aux solutions et impl√©mentations possibles de cette t√¢che.  Il m'a fallu environ 5 heures pour r√©aliser et fixer dans ma t√™te l'image de la d√©cision. </p><br><p>  Pour plus de clart√©, j'ai enregistr√© une vid√©o sur laquelle le r√©sultat final de l'algorithme (si vous pouvez l'appeler ainsi) est d√©j√† captur√©. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZcXxVQG2Rgk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="podhody-k-resheniyu">  Approches de solution </h1><br><h2 id="1-ot-uglovyh-markerov-k-centralnomu">  1. Des marqueurs de coin au centre </h2><br><p>  La premi√®re chose qui m'est venue √† l'esprit √©tait de pr√©senter les interactions entre les marqueurs du coin au centre.  Sous forme graphique, cela ressemble √† ceci: </p><br><p><img src="https://habrastorage.org/webt/0u/0j/re/0u0jrellt_78kezlvsgr7poeex0.jpeg" alt="image"></p><br><p>  Les probl√®mes: </p><br><ol><li>  Comment d√©terminer quelle √©tiquette lat√©rale changer d'√©tat?  Celui de gauche ou de droite?  Nous for√ßons √©galement chaque marqueur √† ¬´conna√Ætre¬ª l'existence d'un marqueur central. </li><li>  Il est n√©cessaire d'ajouter des d√©pendances non √©videntes de la cat√©gorie: le marqueur lat√©ral souscrit √† l'√©v√©nement de marqueur de coin IsChangedEventCallback (), des actions similaires doivent √™tre effectu√©es pour le marqueur central. </li><li>  Si nous consid√©rons chaque type de marqueur comme une entit√©, alors dans la hi√©rarchie de ces entit√©s, nous transmettrons la commande de changement d'√©tat de bas en haut.  Ce n'est pas tr√®s bon, car nous nous lions √©troitement avec le nombre, dans ce cas, les marqueurs angulaires, perdant la capacit√© de mise √† l'√©chelle. </li></ol><br><p>  Incapable de mettre la solution ci-dessus dans ma t√™te en raison des nombreux cas marginaux et de la complexit√© de la perception, j'ai chang√© l'approche pour choisir un marqueur sur lequel les d√©pendances commencent √† se propager. </p><br><h2 id="2-bokovye-znayut-o-centralnom-i-uglovyh">  2. Les lat√©raux connaissent le centre et l'angle </h2><br><p>  En r√©fl√©chissant √† la solution du paragraphe 3 de l'approche pr√©c√©dente, l'id√©e est venue de changer le type de marqueur, √† partir duquel les √©tats des autres marqueurs commencent √† changer.  Comme les principaux marqueurs lat√©raux ont √©t√© pris.  Dans ce sc√©nario, les communications (d√©pendances) ressemblent √† ceci: </p><br><p><img src="https://habrastorage.org/webt/t3/vz/3q/t3vz3qmk-wnhvwdbpgcdgemuciu.jpeg" alt="image"></p><br><p>  De l√†, il devient imm√©diatement clair que les connexions du lat√©ral au central sont superflues, car le marqueur lat√©ral n'a besoin de rien savoir du marqueur central, donc cette approche a √©t√© imm√©diatement transform√©e en finale. </p><br><h2 id="3-centralnyy-znaet-o-vseh-bokovye-znayut-o-uglovyh">  3. Le central conna√Æt tout le monde, les c√¥t√©s connaissent le coin </h2><br><p><img src="https://habrastorage.org/webt/24/y_/hm/24y_hmm09x-karjrpyddxkh6gqy.jpeg" alt="image"></p><br><p>  La solution finale est lorsque le marqueur lat√©ral conna√Æt les coins, que les coins ¬´vivent leur vie¬ª et que le central conna√Æt l'√©tat de tous les marqueurs. </p><br><p><img src="https://habrastorage.org/webt/no/ls/fl/nolsflwoafqlnjbnanb9illn2wi.jpeg" alt="image"></p><br><p>  Travailler avec la vue de carte postale n'est pas tr√®s pratique.  Les relations entre les entit√©s ne semblent pas assez claires pour les convertir facilement en code.  Une tentative d'interpr√©tation sous la forme d'un arbre binaire peut introduire une certaine ambigu√Øt√©.  Mais ici, l'une des propri√©t√©s de l'arbre binaire est viol√©e, donc l'ambigu√Øt√© dispara√Æt imm√©diatement.  D'o√π nous pouvons conclure que cette repr√©sentation peut √™tre interpr√©t√©e sans ambigu√Øt√© et utilis√©e pour repr√©senter graphiquement la solution du probl√®me.  Sur la base de ces conclusions, nous utiliserons la notation graphique, √† savoir: </p><br><ul><li>  Angle Marker - Angle Node (niveau 3) </li><li>  Marqueur lat√©ral - Noeud lat√©ral (niveau 2) </li><li>  Marqueur central - Noeud central (niveau 1) </li></ul><br><p>  Avantages: </p><br><ol><li>  Les d√©pendances entre les marqueurs sont √©videntes et √©videntes. </li><li>  Chacun des niveaux peut √™tre repr√©sent√© sous la forme de 3 entit√©s, chacune compos√©e de parties de base, mais avec leurs ajouts inh√©rents √† chacun des niveaux </li><li>  Pour vous d√©velopper, vous n'aurez qu'√† ajouter un nouveau type de n≈ìud avec ses propres caract√©ristiques </li><li>  Cette solution est facile √† imaginer dans un style OO (orient√© objet) </li></ol><br><h1 id="realizaciya">  Impl√©mentation </h1><br><h2 id="bazovye-suschnosti">  Entit√©s de base </h2><br><p>  Cr√©ons une interface qui contient les √©l√©ments inh√©rents √† chaque entit√© (nom, √©tat): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br><p>  Ensuite, nous d√©crivons l'essence de chaque n≈ìud: </p><br><ul><li>  <strong>CornerNode</strong> - un n≈ìud angulaire.  <code>INode</code> interface <code>INode</code> : </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CornerNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Pourquoi <code>IsActive = true</code> ? </p><br><div class="spoiler">  <b class="spoiler_title">La r√©ponse</b> <div class="spoiler_text"><p>  D'apr√®s les conditions du probl√®me, le contenu des marqueurs de coin est initialement disponible pour la reconnaissance. </p></div></div><br><ul><li>  <strong>SideNode</strong> - un n≈ìud lat√©ral.  Nous impl√©mentons l'interface <code>INode</code> , mais ajoutons les <code>RightCornerNode</code> <code>LeftCornerNode</code> et <code>RightCornerNode</code> .  Ainsi, le n≈ìud lat√©ral conserve son √©tat en lui-m√™me et ne conna√Æt que l'existence de n≈ìuds lat√©raux. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SideNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode LeftCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CornerNode RightCornerNode { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, CornerNode leftNode, CornerNode rightNode</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; LeftCornerNode = leftNode; RightCornerNode = rightNode; } }</code> </pre> <br><ul><li>  <strong>CenterNode</strong> est le n≈ìud central.  Comme dans les pr√©c√©dents, nous impl√©mentons <code>INode</code> .  Ajoutez un champ de type <code>List&lt;INode&gt;</code> . </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CentralNode</span></span> : <span class="hljs-title"><span class="hljs-title">INode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;INode&gt; NodesOnCard; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsActive { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { Name = name; IsActive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h2 id="klass-opencard">  Classe Opencard </h2><br><h3 id="privatnye-metody-i-polya">  M√©thodes et champs priv√©s </h3><br><p>  Maintenant que nous avons cr√©√© tous les √©l√©ments de la carte que nous avons cr√©√©s (toutes sortes de marqueurs), nous pouvons commencer √† d√©crire l'essence de la carte elle-m√™me.  Je n'ai pas l'habitude de d√©marrer une classe avec un constructeur.  Je commence toujours par les m√©thodes de base inh√©rentes √† une entit√© particuli√®re.  Commen√ßons par les champs priv√©s et les m√©thodes priv√©es. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;CornerNode&gt; cornerNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;SideNode&gt; sideNodes; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CentralNode centralNode;</code> </pre> <br><p>  Avec les champs, tout est assez simple.  2 listes avec n≈ìuds lat√©raux angulaires et un champ du n≈ìud central. </p><br><p>  Ensuite, vous devez clarifier un peu.  Le fait est que le marqueur lui-m√™me est de type <code>Trackable</code> et il n'a aucune id√©e (et ne devrait pas avoir) qu'il fait partie d'une autre logique l√†-bas.  Par cons√©quent, tout ce que nous pouvons utiliser pour contr√¥ler l'affichage est son nom.  Par cons√©quent, si le marqueur lui-m√™me ne stocke pas le type de n≈ìud auquel il appartient, nous devons transf√©rer cette responsabilit√© √† notre classe <code>OpenCard</code> .  Sur cette base, nous d√©crivons d'abord 3 m√©thodes priv√©es charg√©es de d√©terminer le type de n≈ìud. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCentralNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name == centralNode.Name; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSideNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCornerNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNode <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sideNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Mais ces m√©thodes n'ont pas de sens √† utiliser directement.  Il n'est pas pratique d'utiliser des valeurs bool√©ennes lorsque vous travaillez avec des objets d'un autre niveau d'abstraction.  Par cons√©quent, nous allons cr√©er une <code>enum NodeType</code> simple <code>enum NodeType</code> et une m√©thode priv√©e <code>GetNodeType()</code> , qui encapsule en elle-m√™me toute la logique associ√©e √† la d√©termination du type de n≈ìud. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> NodeType { CornerNode, SideNode, CentralNode } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NodeType? GetNodeType(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCentralNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CentralNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsSideNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.SideNode; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsCornerNode(name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodeType.CornerNode; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><h3 id="publichnye-metody">  M√©thodes publiques </h3><br><ul><li>  <code>IsExist</code> est une m√©thode qui renvoie une valeur bool√©enne indiquant si notre marque appartient √† une carte postale.  Il s'agit d'une m√©thode auxiliaire, qui est effectu√©e de sorte que si le marqueur n'appartient √† aucune carte, nous pouvons afficher le contenu dessus. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExist</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (centralNode.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><ul><li>  <code>CheckOnActiveAndChangeStatus</code> - une m√©thode (comme son nom l'indique) dans laquelle nous v√©rifions l'√©tat actuel du n≈ìud et changeons son √©tat. </li></ul><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOnActiveAndChangeStatus</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (GetNodeType(name)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CornerNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cornerNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.Name == name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.SideNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sideNodes) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.LeftCornerNode.IsActive &amp;&amp; node.RightCornerNode.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> NodeType.CentralNode: <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> centralNode.NodesOnCard) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!node.IsActive) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> centralNode.IsActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3 id="konstruktor">  Constructeur </h3><br><p>  Lorsque toutes les cartes sont sur la table, nous pouvons enfin aller chez le constructeur.  Il peut y avoir plusieurs approches √† l'initialisation.  Mais j'ai d√©cid√© de d√©barrasser autant que possible la classe <code>OpenCard</code> des gestes inutiles.  Il devrait r√©pondre avec nous si le contenu est disponible pour l'affichage ou non.  Par cons√©quent, nous demandons simplement des listes d'entr√©e de n≈ìuds de 2 types et un n≈ìud central. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenCard</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;CornerNode&gt; listCornerNode, List&lt;SideNode&gt; listSideNode, CentralNode centralNode</span></span></span><span class="hljs-function">)</span></span> { CornerNodes = listCornerNode; SideNodes = listSideNode; CentralNodes = centralNode; CentralNodes.NodesOnCard = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;INode&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> CornerNodes) CentralNodes.NodesOnCard.Add(node); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> SideNodes) CentralNodes.NodesOnCard.Add(node); }</code> </pre> <br><p>  Notez que puisque le n≈ìud central n'a besoin que de v√©rifier la condition que tous les autres n≈ìuds <code>true</code> , il nous suffit de <code>INode</code> implicitement <code>INode</code> n≈ìuds angulaires et centraux entr√©s dans le constructeur en type <code>INode</code> . </p><br><h3 id="inicializaciya">  Initialisation </h3><br><p>  Quelle est la fa√ßon la plus pratique de cr√©er des objets qui n'ont pas besoin d'√™tre attach√©s (comme les composants <code>MonoBehaviour</code> ) √† un GameObject?  - D' <code>ScriptableObject</code> , <code>ScriptableObject</code> .  De plus, pour plus de commodit√©, ajoutez l'attribut <code>MenuItem</code> , qui simplifiera la cr√©ation de nouvelles cartes. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CreateAssetMenu(fileName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Open Card"</span></span></span><span class="hljs-meta">, menuName = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"New Open Card"</span></span></span><span class="hljs-meta">, order = 51)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OpenCardScriptableObject</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightDownName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftUpName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> leftSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rightSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> downSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> upSideName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> centralName; }</code> </pre> <br><p>  L'accord final dans notre composition sera un passage √† travers le tableau des <code>ScriptableObject</code> ajout√©s (le cas √©ch√©ant) et la cr√©ation de cartes postales √† partir d'eux.  Apr√®s cela, il nous reste dans la m√©thode de <code>Update</code> √† <code>Update</code> de v√©rifier simplement si nous pouvons afficher le contenu ou non. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OpenCardScriptableObject[] openCards; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;OpenCard&gt; _cardList; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openCards.Length != <span class="hljs-number"><span class="hljs-number">0</span></span>) { _cardList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OpenCard&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> openCards) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightDown = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightDownName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.rightUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftUp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CornerNode(card.leftUpName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> leftSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.leftSideName, leftUp, leftDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> downSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.downSideName, leftDown, rightDown); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rightSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.rightSideName, rightDown, rightUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> upSide = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SideNode(card.upSideName, rightUp, leftUp); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> central = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CentralNode(card.centralName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;CornerNode&gt;() {leftDown, rightDown, rightUp, leftUp}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sideNodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;SideNode&gt;() {leftSide, downSide, rightSide, upSide}; _cardList.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenCard(nodes, sideNodes, central)); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> card <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _cardList) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.IsExist(trackableName)) isNotPartCard = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.CheckOnActiveAndChangeStatus(trackableName)) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNotPartCard) imageTrackablesMap[trackableName].OnTrackSuccess(trackable); } }</code> </pre> <br><h1 id="vyvody">  Conclusions </h1><br><p>  Pour moi personnellement, les conclusions √©taient les suivantes: </p><br><ol><li>  Lorsque vous essayez de r√©soudre un probl√®me, vous devez essayer de diviser ses √©l√©ments en parties atomiques.  En outre, compte tenu de toutes les options possibles pour l'interaction entre ces parties atomiques, vous devez commencer par l'objet, d'o√π proviendront potentiellement plus de connexions.  D'une autre mani√®re, il peut √™tre formul√© comme suit: s'efforcer de commencer √† r√©soudre des probl√®mes avec des √©l√©ments qui, potentiellement, seront moins fiables </li><li>  Si possible, vous devez essayer de pr√©senter les donn√©es source sous une forme diff√©rente.  Dans mon cas, la repr√©sentation graphique m'a beaucoup aid√©. </li><li>  Chaque entit√© est s√©par√©e de l'autre par le nombre de connexions qui pourraient en d√©couler. </li><li>  De nombreuses t√¢ches appliqu√©es qui sont plus habituelles √† r√©soudre en √©crivant un algorithme peuvent √™tre repr√©sent√©es dans le style OO </li><li>  Une solution qui a des d√©pendances en anneau est une mauvaise solution </li><li>  S'il est difficile de garder toutes les connexions entre les objets dans votre t√™te, c'est une mauvaise d√©cision </li><li>  Si vous ne pouvez pas garder √† l'esprit la logique de l'interaction des objets - c'est une mauvaise d√©cision </li><li>  Vos b√©quilles ne sont pas toujours une mauvaise d√©cision </li></ol><br><p>  Connaissez-vous une autre solution?  - √âcrivez dans les commentaires. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454452/">https://habr.com/ru/post/fr454452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454440/index.html">Petty Little Fun # 2: Starlette</a></li>
<li><a href="../fr454442/index.html">Comment choisir un r√©seau proxy pour votre entreprise: 3 conseils pratiques</a></li>
<li><a href="../fr454444/index.html">Nous profilons le chargement de Habr ou comment 189 requ√™tes sur la page rendent l'influence</a></li>
<li><a href="../fr454446/index.html">Quoi de neuf en C # 8?</a></li>
<li><a href="../fr454450/index.html">Comment Edison a invent√© le sans fil et n'a rien compris</a></li>
<li><a href="../fr454456/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 7. FAQ</a></li>
<li><a href="../fr454458/index.html">Tests m√©tamorphiques: pourquoi presque personne ne conna√Æt cette technique prometteuse</a></li>
<li><a href="../fr454460/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 300 (27 mai - 2 juin)</a></li>
<li><a href="../fr454462/index.html">Photogramme sans papier photo</a></li>
<li><a href="../fr454464/index.html">D√©veloppement de tests visuels bas√©s sur Gemini et Storybook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>