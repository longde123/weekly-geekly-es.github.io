<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè° üë©üèø‚Äçü§ù‚Äçüë®üèΩ üöè noexcept-ctcheck ou quelques macros simples pour aider le compilateur √† √©crire du code noexcept üò§ üë®üèæ‚Äçü§ù‚Äçüë®üèΩ üßú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors du d√©veloppement en C ++, vous devez √©crire de temps en temps du code dans lequel aucune exception ne devrait se produire. Par exemple, lorsque n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>noexcept-ctcheck ou quelques macros simples pour aider le compilateur √† √©crire du code noexcept</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466849/"><p>  Lors du d√©veloppement en C ++, vous devez √©crire de temps en temps du code dans lequel aucune exception ne devrait se produire.  Par exemple, lorsque nous devons √©crire un √©change sans exception pour les types natifs ou d√©finir une instruction noexcept move pour notre classe, ou impl√©menter manuellement un destructeur non trivial. </p><br><p>  En C ++ 11, le modificateur noexcept a √©t√© ajout√© au langage, ce qui permet au d√©veloppeur de comprendre que les exceptions ne peuvent pas √™tre supprim√©es de la fonction marqu√©e par noexcept.  Par cons√©quent, les fonctions avec une telle marque peuvent √™tre utilis√©es en toute s√©curit√© dans des contextes o√π aucune exception ne devrait se produire. </p><br><p>  Par exemple, si j'ai ces types et fonctions: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_resource</span></span></span><span class="hljs-class"> {</span></span>...}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_resource &amp; r)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(second_resource &amp; r)</span></span></span></span>;</code> </pre> <br><p>  et il y a une certaine classe <code>resources_owner</code> qui poss√®de des objets comme <code>first_resource</code> et <code>second_resource</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resources_owner</span></span></span><span class="hljs-class"> {</span></span> first_resource first_resource_; second_resource second_resource_; ... };</code> </pre> <br><p>  alors je peux √©crire le destructeur <code>resources_owner</code> comme suit: </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release()   ,    . release(first_resource_); //    close()   ,  //   try-catch. try{ close(second_resource_); } catch(...) {} }</span></span></code> </pre> <br><p>  D'une certaine mani√®re, sauf en C ++ 11 a facilit√© la vie d'un d√©veloppeur C ++.  Mais l'impl√©mentation noexcept actuelle en C ++ moderne a un c√¥t√© d√©sagr√©able ... </p><br><h1 id="kompilyator-ne-pomogaet-kontrolirovat-soderzhimoe-noexcept-funkciy-i-metodov">  Le compilateur n'aide pas √† contr√¥ler le contenu des fonctions et m√©thodes noexcept </h1><a name="habracut"></a><br><p>  Supposons que dans l'exemple ci-dessus je me suis tromp√©: pour une raison quelconque, j'ai consid√©r√© que <code>release()</code> marqu√© comme noexcept, mais en r√©alit√© il ne l'est pas et peut lever des exceptions.  Cela signifie que lorsque j'√©cris un destructeur √† l'aide d'une telle <code>release()</code> lancement <code>release()</code> : </p><br><pre> <code class="cpp hljs">resources_owner::~resources_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { release(first_resource_); <span class="hljs-comment"><span class="hljs-comment">//  try-catch   ... }</span></span></code> </pre> <br><p>  alors je prie pour les ennuis.  T√¥t ou tard, cette <code>release()</code> l√®vera une exception et toute mon application se bloquera en raison du <code>std::terminate()</code> appel√© automatiquement.  Ce sera encore pire si mon application ne plante pas, mais celle de quelqu'un d'autre, dans laquelle ils ont utilis√© ma biblioth√®que avec un destructeur si probl√©matique pour <code>resources_owner</code> . </p><br><p>  Ou une autre variante du m√™me probl√®me.  Supposons que je ne me sois pas tromp√© que <code>release()</code> effet marqu√© comme noexcept.  √áa l'√©tait. </p><br><p>  Il a √©t√© balis√© dans la version 1.0 d'une biblioth√®que tierce √† partir de laquelle j'ai pris <code>first_resource</code> et <code>release()</code> .  Et puis, apr√®s plusieurs ann√©es, je suis pass√© √† la version 3.0 de cette biblioth√®que, mais dans la version 3.0, la <code>release()</code> n'a plus de modificateur noexcept. </p><br><p>  Eh bien quoi?  La nouvelle version majeure, ils pourraient facilement casser l'API. </p><br><p>  Seulement maintenant, tr√®s probablement, j'oublierai de corriger l'impl√©mentation du destructeur <code>resources_owner</code> .  Et si au lieu de moi, quelqu'un d'autre est engag√© dans le support de <code>resource_owner</code> , qui n'a jamais examin√© ce destructeur, alors les changements dans la signature <code>release()</code> passeront probablement inaper√ßus. </p><br><p>  Par cons√©quent, personnellement, je n'aime pas le fait que le compilateur ne pr√©vienne en aucune fa√ßon le programmeur que le programmeur √† l'int√©rieur de la m√©thode / fonction noexcept lance un appel de m√©thode / fonction de lev√©e d'exceptions. </p><br><p>  Il serait pr√©f√©rable que le compilateur √©mette de tels avertissements. </p><br><h1 id="spasenie-utopayuschih-delo-ruk-samih-utopayuschih">  Le sauvetage de la noyade est l'≈ìuvre des noy√©s eux-m√™mes </h1><br><p>  OK, le compilateur ne donne aucun avertissement.  Et rien ne peut √™tre fait √† propos de ce simple d√©veloppeur.  Ne traitez pas les modifications du compilateur C ++ pour vos propres besoins.  Surtout si vous devez utiliser non pas un seul compilateur, mais diff√©rentes versions de diff√©rents compilateurs C ++. </p><br><p>  Est-il possible d'obtenir de l'aide du compilateur sans entrer dans ses abats?  C'est-√†-dire  Est-il possible de faire une sorte d'outils pour contr√¥ler le contenu des m√©thodes / fonctions noexcept, m√™me si la m√©thode dendro-f√©cale? </p><br><p>  Tu peux.  Sloppy, mais possible. </p><br><h1 id="otkuda-nogi-rastut">  D'o√π poussent les jambes? </h1><br><p>  L'approche d√©crite dans cet article a √©t√© test√©e dans la pratique lors de la pr√©paration de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prochaine version de notre petit serveur HTTP int√©gr√© RESTinio</a> . </p><br><p>  Le fait est que RESTinio regorge de fonctionnalit√©s, nous avons perdu de vue les probl√®mes de s√©curit√© exceptionnels √† plusieurs endroits.  En particulier, au fil du temps, il est devenu clair que les exceptions peuvent parfois dispara√Ætre des rappels transf√©r√©s √† Asio (qui ne devraient pas l'√™tre), ainsi que les exceptions, en principe, peuvent dispara√Ætre lors du nettoyage des ressources. </p><br><p>  Heureusement, dans la pratique, ces probl√®mes ne se sont jamais manifest√©s, mais la dette technique s'est accumul√©e et il a fallu faire quelque chose.  Et vous deviez faire quelque chose avec le code qui √©tait d√©j√† √©crit.  C'est-√†-dire  le code non-noexcept de travail doit √™tre converti en code noexcept de travail. </p><br><p>  Cela a √©t√© fait √† l'aide de plusieurs macros, organis√©es par code aux bons endroits.  Par exemple, un cas trivial: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Message_Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trigger_error_and_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Message_Builder msg_builder )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// An exception from logger/msg_builder shouldn't prevent // a call to close(). restinio::utils::log_error_noexcept( m_logger, std::move(msg_builder) ); RESTINIO_ENSURE_NOEXCEPT_CALL( close() ); }</span></span></code> </pre> <br><p>  Et voici un fragment moins trivial: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.empty()); RESTINIO_STATIC_ASSERT_NOEXCEPT( m_context_table.pop_response_context_nonchecked()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front()); RESTINIO_STATIC_ASSERT_NOEXCEPT(m_context_table.front().dequeue_group()); RESTINIO_STATIC_ASSERT_NOEXCEPT(make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; !m_context_table.empty(); m_context_table.pop_response_context_nonchecked() ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ec = make_asio_compaible_error( <span class="hljs-keyword"><span class="hljs-keyword">asio_convertible_error_t</span></span>::write_was_not_executed ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; current_ctx = m_context_table.front(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !current_ctx.empty() ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> wg = current_ctx.dequeue_group(); restinio::utils::suppress_exceptions_quietly( [&amp;] { wg.invoke_after_write_notificator_if_exists( ec ); } ); } } }</code> </pre> <br><p>  L'utilisation de ces macros s'est serr√©e la main plusieurs fois, pointant vers des endroits que j'avais par inadvertance per√ßus comme non, mais qui ne l'√©taient pas. </p><br><p>  Donc, l'approche d√©crite ci-dessous, bien s√ªr, est un lisop fait maison avec des roues carr√©es, mais √ßa va ... Je veux dire que cela fonctionne. </p><br><p>  Plus loin dans l'article, nous discuterons de l'impl√©mentation qui a √©t√© isol√©e du code RESTinio dans un ensemble distinct de macros. </p><br><h1 id="sut-podhoda">  L'essence de l'approche </h1><br><p>  L'essence de l'approche est de passer l'instruction / op√©rateur (stmt), qui doit √™tre v√©rifi√© sans exception, dans une certaine macro.  Cette macro utilise <code>static_assert(noexcept(stmt), msg)</code> pour v√©rifier que stmt est vraiment noexcept, puis remplace stmt dans le code. </p><br><p>  Essentiellement, c'est: </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  sera remplac√© par quelque chose comme: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><h2 id="pochemu-byl-sdelan-vybor-v-polzu-makrosov">  Pourquoi le choix a-t-il √©t√© fait en faveur des macros? </h2><br><p>  En principe, on pourrait se passer de macros et on pourrait √©crire <code>static_assert(noexcept(...))</code> juste dans le code juste avant les actions v√©rifi√©es.  Mais les macros ont au moins quelques vertus qui font pencher la balance en faveur de l'utilisation sp√©cifique des macros. </p><br><p>  Tout d'abord, les macros r√©duisent la duplication de code.  Il y a une comparaison: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>(release(some_resource)), <span class="hljs-string"><span class="hljs-string">"release(some_resource) is expected to be noexcept"</span></span>); release(some_resource);</code> </pre> <br><p>  et </p><br><pre> <code class="cpp hljs">ENSURE_NOEXCEPT_STATEMENT(release(some_resource));</code> </pre> <br><p>  il est clair qu'avec les macros l'expression principale, c'est-√†-dire  <code>release(some_resource)</code> ne peut √™tre √©crit qu'une seule fois.  Cela r√©duit la probabilit√© que le code "rampe" au fil du temps, avec son accompagnement, lorsqu'une correction a √©t√© effectu√©e √† un endroit et oubli√©e au second. </p><br><p>  Deuxi√®mement, les macros et, par cons√©quent, les contr√¥les cach√©s derri√®re eux peuvent √™tre tr√®s facilement d√©sactiv√©s.  Disons, si l'abondance de static_assert-s a commenc√© √† affecter n√©gativement la vitesse de compilation (m√™me si je n'ai pas remarqu√© un tel effet).  Ou, plus important encore, lors de la mise √† jour d'une biblioth√®que tierce, les erreurs de compilation de static_assert cach√©es derri√®re des macros peuvent arroser directement avec la rivi√®re.  La d√©sactivation temporaire des macros peut permettre une mise √† jour fluide du code, y compris des macros de v√©rification s√©quentiellement d'abord dans un fichier, puis dans le second, puis dans le troisi√®me, etc. </p><br><p>  Ainsi, les macros, bien qu'elles soient obsol√®tes et tr√®s controvers√©es en C ++, dans ce cas particulier, la vie du d√©veloppeur est simplifi√©e. </p><br><h2 id="osnovnoy-makros-ensure_noexcept_statement">  Macro principale ENSURE_NOEXCEPT_STATEMENT </h2><br><p>  La macro principale ENSURE_NOEXCEPT_STATEMENT est impl√©ment√©e de mani√®re triviale: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_STATEMENT(stmt) \ do { \ static_assert(noexcept(stmt), </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"this statement is expected to be noexcept: "</span></span></span><span class="hljs-meta"> #stmt); \ stmt; \ } while(false)</span></span></code> </pre> <br><p>  Il est utilis√© pour v√©rifier que les m√©thodes / fonctions appel√©es sont bien noexcept et que leurs appels n'ont pas besoin d'√™tre encadr√©s par des blocs try-catch.  Par exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_complex_container</span></span></span><span class="hljs-class"> {</span></span> one_container first_data_part_; another_container second_data_part_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(some_complex_container &amp; a, some_complex_container &amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; <span class="hljs-comment"><span class="hljs-comment">//  swap  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(swap(a.first_data_part_, b.first_data_part_)); ENSURE_NOEXCEPT_STATEMENT(swap(a.second_data_part_, b.second_data_part_)); ... } ... void clean() noexcept { //  clean()  noexcept,    . ENSURE_NOEXCEPT_STATEMENT(first_data_part_.clean()); ENSURE_NOEXCEPT_STATEMENT(second_data_part_.clean()); ... } ... };</span></span></code> </pre> <br><p>  En outre, il existe √©galement la macro ENSURE_NOT_NOEXCEPT_STATEMENT.  Il est utilis√© pour garantir qu'un bloc try-catch suppl√©mentaire est requis autour de l'appel afin que les exceptions possibles ne surviennent pas: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_resource_owner</span></span></span><span class="hljs-class"> {</span></span> some_resource resource_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~some_resource_owner() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  release   noexcept,  try-catch     //      . ENSURE_NOT_NOEXCEPT_STATEMENT(release(resource_)); } catch(...) {} ... } ... };</span></span></code> </pre> <br><h2 id="vspomogatelnye-makrosy-static_assert_noexcept-i-static_assert_not_noexcept">  Macros d'assistance STATIC_ASSERT_NOEXCEPT et STATIC_ASSERT_NOT_NOEXCEPT </h2><br><p>  Malheureusement, les macros ENSURE_NOEXCEPT_STATEMENT et ENSURE_NOT_NOEXCEPT_STATEMENT ne peuvent √™tre utilis√©es que pour les instructions / instructions, mais pas pour les expressions qui renvoient une valeur.  C'est-√†-dire  vous ne pouvez pas √©crire avec ENSURE_NOEXCEPT_STATEMENT comme ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_STATEMENT(acquire_resource(params));</code> </pre> <br><p>  Par cons√©quent, ENSURE_NOEXCEPT_STATEMENT ne peut pas √™tre utilis√©, par exemple, dans des boucles o√π vous devez souvent √©crire quelque chose comme: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  et vous devez vous assurer que les appels <code>get_first()</code> , <code>get_next()</code> , ainsi que l'attribution de nouvelles valeurs pour i ne <code>get_next()</code> pas d'exception. </p><br><p>  Pour lutter contre de telles situations, les macros STATIC_ASSERT_NOEXCEPT et STATIC_ASSERT_NOT_NOEXCEPT ont √©t√© √©crites, derri√®re lesquelles seuls les static_assert sont cach√©s et rien de plus.  En utilisant ces macros, je peux obtenir le r√©sultat dont j'ai besoin d'une certaine mani√®re (la compilation de ce fragment particulier n'a pas √©t√© v√©rifi√©e): </p><br><pre> <code class="cpp hljs">STATIC_ASSERT_NOEXCEPT(something.get_first()); STATIC_ASSERT_NOEXCEPT(something.get_first().get_next()); STATIC_ASSERT_NOEXCEPT(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(something.get_first())&gt;() = something.get_first().get_next()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = something.get_first(); i != some_other_object; i = i.get_next()) {...}</code> </pre> <br><p>  De toute √©vidence, ce n'est pas la meilleure solution, car  cela conduit √† la duplication du code et augmente le risque de "fluage" avec une maintenance suppl√©mentaire.  Mais dans un premier temps, ces macros simples se sont av√©r√©es utiles. </p><br><h1 id="biblioteka-noexcept-ctcheck">  Biblioth√®que Noexcept-ctcheck </h1><br><p>  Lorsque j'ai partag√© cette exp√©rience sur mon blog et sur Facebook, j'ai re√ßu une proposition pour organiser les d√©veloppements ci-dessus dans une biblioth√®que s√©par√©e.  Ce qui a √©t√© fait: github a maintenant une petite biblioth√®que d'en-t√™te <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">noexcept-compile-time-check (ou noexcept-ctcheck, si vous √©conomisez sur les lettres)</a> .  Donc, tout ce qui pr√©c√®de, vous pouvez prendre et essayer.  Certes, les noms des macros sont un peu plus longs que ceux utilis√©s dans l'article.  C'est-√†-dire  NOEXCEPT_CTCHECK_ENSURE_NOEXCEPT_STATEMENT au lieu de ENSURE_NOEXCEPT_STATEMENT. </p><br><h2 id="chto-v-noexcept-ctcheck-ne-popalo-poka">  Qu'est-ce qui n'est pas entr√© dans noexcept-ctcheck (encore?) </h2><br><p>  Il y a un d√©sir de faire la macro ENSURE_NOEXCEPT_EXPRESSION, qui pourrait √™tre utilis√©e comme ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> resource = ENSURE_NOEXCEPT_EXPRESSION(acquire_resource(params));</code> </pre> <br><p>  En premi√®re approximation, il pourrait ressembler √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENSURE_NOEXCEPT_EXPRESSION(expr) \ ([&amp;]() noexcept -&gt; decltype(auto) { \ static_assert(noexcept(expr), #expr </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" is expected to be noexcept"</span></span></span><span class="hljs-meta">); \ return expr; \ }())</span></span></code> </pre> <br><p>  Mais il y a de vagues soup√ßons qu'il y a des pi√®ges auxquels je n'ai pas pens√©.  En g√©n√©ral, les mains n'ont pas encore atteint ENSURE_NOEXCEPT_EXPRESSION :( </p><br><h1 id="a-esli-pomechtat">  Et si vous r√™vez? </h1><br><p>  Mon vieux r√™ve est d'obtenir un bloc noexcept en C ++ dans lequel le compilateur lui-m√™me v√©rifie la lev√©e des exceptions et √©met des avertissements si des exceptions peuvent √™tre lev√©es.  Il me semble que cela faciliterait l'√©criture de code sans exception.  Et pas seulement dans les cas √©vidents mentionn√©s ci-dessus (swap, move-operators, destructors).  Par exemple, un bloc noexcept pourrait aider dans cette situation: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">modify_some_complex_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . one_container_.modify(); // ,   . ,      . //         try. noexcept { current_age_.increment(); } //    ,      . try { another_container_.modify(); ... } catch(...) { noexcept { //  ,     . current_age_.decrement(); one_container_.rollback_modifications(); } throw; } }</span></span></code> </pre> <br><p>  Ici, pour l'exactitude du code, il est tr√®s important que les actions effectu√©es √† l'int√©rieur des blocs noexcept ne l√®vent pas d'exceptions.  Et si le compilateur peut tracer cela, alors ce sera une aide s√©rieuse pour le d√©veloppeur. </p><br><p>  Mais peut-√™tre qu'un bloc noexcept n'est qu'un cas particulier d'un probl√®me plus g√©n√©ral.  A savoir: v√©rifier les attentes du programmeur qu'un certain bloc de code poss√®de certaines propri√©t√©s.  Que ce soit l'absence d'exceptions, l'absence d'effets secondaires, l'absence de r√©cursivit√©, les courses de donn√©es, etc. </p><br><p>  Il y a quelques ann√©es, des r√©flexions sur ce sujet ont conduit √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">id√©e d'attribuer et d'attendre des attributs</a> .  Cette id√©e n‚Äôest pas all√©e plus loin que le billet de blog, car  alors qu'elle se trouve loin de mes int√©r√™ts et opportunit√©s actuels.  Mais soudain, ce sera int√©ressant pour quelqu'un et quelqu'un va pousser pour cr√©er quelque chose de plus viable. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Dans cet article, j'ai essay√© de parler de mon exp√©rience dans la simplification de l'√©criture de code sans exception.  Bien s√ªr, l'utilisation de macros ne rend pas le code plus beau et plus compact.  Mais √ßa marche.  Et m√™me de telles macros primitives augmentent consid√©rablement le coefficient de mon sommeil r√©parateur.  Donc, si quelqu'un d'autre n'a pas r√©fl√©chi √† la fa√ßon de contr√¥ler le contenu de ses propres m√©thodes / fonctions noexcept, cet article vous inspirera peut-√™tre √† r√©fl√©chir √† ce sujet. </p><br><p>  Et si quelqu'un trouve un moyen de simplifier sa vie en √©crivant sans code, alors il serait int√©ressant de savoir ce qu'est cette m√©thode, dans laquelle elle aide et dans laquelle elle ne fonctionne pas.  Et dans quelle mesure √™tes-vous satisfait de ce que vous utilisez? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466849/">https://habr.com/ru/post/fr466849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466833/index.html">Choses importantes √† savoir sur Tensorflow 2.0</a></li>
<li><a href="../fr466837/index.html">Week-end √† v√©lo √©lectrique avec g√©n√©rateur de gaz</a></li>
<li><a href="../fr466839/index.html">L'histoire de la cr√©ation de Norton Commander. Partie 1/3</a></li>
<li><a href="../fr466841/index.html">Pourquoi un coussin chauffant, s'il y a un ordinateur portable: l'√©tude de la r√©sistance thermique au niveau atomique</a></li>
<li><a href="../fr466845/index.html">Interview invers√©e: quelles questions poser √† l'entreprise?</a></li>
<li><a href="../fr466851/index.html">Ligne Agilex - FPGA Intel 10 nm</a></li>
<li><a href="../fr466855/index.html">Cr√©ation de Tower Defense dans Unity: sc√©narios et vagues d'ennemis</a></li>
<li><a href="../fr466857/index.html">Ex√©cution d'application en arri√®re-plan dans iOS 13</a></li>
<li><a href="../fr466859/index.html">Utilisation du service AD ‚Äã‚ÄãFederation pour autoriser les utilisateurs AWS avec une distribution de droits</a></li>
<li><a href="../fr466861/index.html">Comment √©chapper √† la r√©alit√© en utilisant un hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>