<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüéì ü¶ë üñãÔ∏è Bericht vom Java Virtual Machine Language Summit 2019 üç≠ üòÄ üëºüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute endete der zw√∂lfte JVM LS Summit. Wie √ºblich war es ein Hardcore-Event mit technischen Pr√§sentationen zu virtuellen Maschinen und den darauf aus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bericht vom Java Virtual Machine Language Summit 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/462101/"><img src="https://habrastorage.org/webt/nh/xk/cf/nhxkcfgwiztaulvnbccwhxgcpwe.png" align="right" width="250"><br><p>  Heute endete der zw√∂lfte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JVM LS</a> Summit.  Wie √ºblich war es ein Hardcore-Event mit technischen Pr√§sentationen zu virtuellen Maschinen und den darauf ausgef√ºhrten Sprachen.  Wie √ºblich fand der Gipfel in Santa Clara auf dem Oracle-Campus statt.  Wie √ºblich gibt es viel mehr Leute, die hierher kommen m√∂chten als Orte: Die Teilnehmerzahl √ºberschreitet 120 nicht. Wie √ºblich gab es kein Marketing, nur Innereien. </p><br><p>  Dieser Gipfel ist bereits der dritte f√ºr mich und jedes Mal, wenn ich ihn besuche, trotz des schrecklichen Jetlag.  Hier k√∂nnen Sie nicht nur Berichte anh√∂ren, sondern auch bessere Menschen aus der Welt von JVM kennenlernen, an informellen Gespr√§chen teilnehmen, Fragen in Workshops stellen und sich im Allgemeinen an gro√üartigen Leistungen beteiligt f√ºhlen. </p><br><p>  Wenn Sie nicht am Gipfel teilgenommen haben, spielt es keine Rolle.  Die meisten Berichte werden fast unmittelbar nach dem Gipfel auf YouTube ver√∂ffentlicht.  Eigentlich sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie schon verf√ºgbar</a> .  Um die Navigation zu vereinfachen, werde ich hier kurz alle Berichte und Workshops beschreiben, an denen ich teilgenommen habe. </p><a name="habracut"></a><br><h1>  29. Juli </h1><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ghadi Shayban - Clojure-Futures</a> </h1><br><p> Hier geht es nicht um die Merkmale der zuk√ºnftigen Kompilierung in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clojure-</a> Sprache, wie viele dachten, sondern lediglich um die Entwicklung der Sprache, die Feinheiten der Codegenerierung und die Probleme, auf die sie sto√üen.  Beispielsweise stellte sich heraus, dass es in Clojure wichtig ist, lokale Variablen nach der letzten Verwendung zu annullieren, denn wenn der Kopf einer Liste, die tr√§ge in einer lokalen Variablen generiert wird, diese umgeht, werden bereits umgangene Knoten m√∂glicherweise nicht vom Garbage Collector erfasst, und das Programm kann mit OutOfMemory abst√ºrzen .  Im Allgemeinen gibt der C2-JIT-Compiler die Variablen selbst nach der letzten Verwendung frei, aber der Standard garantiert dies nicht und beispielsweise der HotSpot-Interpreter nicht. </p><br><p>  Interessant war auch die Implementierung des dynamischen Dispatchings von Funktionsaufrufen.  Ich habe auch erfahren, dass Clojure bis vor kurzem auf JVM 6 abzielte und erst k√ºrzlich auf JVM 8 umgestellt hat. Jetzt betrachten die Compilerautoren invokedynamic. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alan Bateman und Rickard B√§ckman - Project Loom Update</a> </h1><br><p>  Das Loom-Projekt ist eine leichte Faser f√ºr Java.  Vor einem Jahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sprachen</a> Alan und Ron bereits √ºber dieses Projekt, und dann schien es, dass alles sehr gut lief und bald fertig sein w√ºrde.  Dieses Projekt ist jedoch noch nicht offiziell in Java eingetragen und wird noch in einem separaten Zweig des Repositorys entwickelt.  Nat√ºrlich stellte sich heraus, dass es notwendig war, viele Details zu regeln. </p><br><p>  Viele Standard-APIs von ReentrantLock.lock bis Socket.accept sind bereits f√ºr Glasfasern angepasst: Wenn ein solcher Aufruf innerhalb einer Glasfaser erfolgt, wird der Ausf√ºhrungsstatus gespeichert, der Stapel wird abgewickelt und der Betriebssystem-Thread wird f√ºr andere Aufgaben freigegeben, bis ein Ereignis die Glasfaser weckt (z. B. ReentrantLock.unlock).  Zum Beispiel funktioniert der gute alte synchronisierte Block jedoch immer noch nicht und es scheint, dass auf eine ernsthafte Umgestaltung der gesamten Synchronisationsunterst√ºtzung in der JVM nicht verzichtet werden kann.  Ein weiteres Abwickeln des Stapels funktioniert nicht, wenn sich zwischen dem Start der Faser und dem Haltepunkt native Frames im Stapel befinden.  In beiden F√§llen explodiert nichts, aber die Faser gibt den Strom nicht frei. </p><br><p>  Es gibt viele Fragen zum Vergleich von Fibre mit der alten Klasse java.lang.Thread.  Vor einem Jahr gab es die Idee, Fibre zu einer Unterklasse von Thread zu machen.  Jetzt haben sie es abgelehnt und es zu einer unabh√§ngigen Einheit gemacht, weil das Emulieren des gesamten Verhaltens eines regul√§ren Streams in jeder Faser ziemlich teuer ist.  In diesem Fall gibt Thread.currentThread () in der Glasfaser die generierte Mischung zur√ºck und nicht den realen Thread, in dem alles ausgef√ºhrt wird.  Aber der Haken wird sich ziemlich gut verhalten (obwohl er den Job verlangsamen kann).  Die wichtige Idee ist, unter keinen Umst√§nden den tats√§chlichen Medienstrom auszugeben, auf dem die Faser innerhalb der Faser l√§uft.  Dies kann gef√§hrlich sein, da sich eine Faser leicht zu einem anderen Faden bewegen kann.  Die T√§uschung wird fortgesetzt. </p><br><p>  Es ist merkw√ºrdig, dass die Projektteilnehmer bereits einige vorbereitende √Ñnderungen in das Haupt-JDK-Repository verschoben haben, um ihnen das Leben zu erleichtern.  In Java 13 wurde beispielsweise die Methode doPrivileged vollst√§ndig aus nativem Code in Java neu geschrieben, wodurch die Leistung um das 50-fache gesteigert wurde.  Warum ist das ein Loom-Projekt?  Tatsache ist, dass diese spezielle Methode sehr oft in der Mitte des Stapels auftritt, und obwohl sie urspr√ºnglich war, h√∂rten die Fasern mit diesem Stapel nicht auf.  Auf die eine oder andere Weise profitiert das Projekt bereits. </p><br><p>  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Projektseite</a> k√∂nnen Sie die Dokumentation lesen und den Quellbaum herunterladen. Au√üerdem gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bin√§rassemblys</a> , die Sie heute spielen k√∂nnen.  Wir hoffen, dass in den kommenden Jahren alles integriert wird. </p><br><h1>  Brian Goetz - Workshop "Projekt Amber" </h1><br><p> Parallel dazu fand ein Workshop √ºber das Loom-Projekt statt, aber ich ging zu Amber.  Hier haben wir kurz die Ziele des Projekts und die wichtigsten JEPs besprochen, in denen gearbeitet wird - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pattern Matching</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Records</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sealed Types</a> .  Dann fiel die ganze Diskussion in die private Frage des Scoping.  Ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habe</a> letztes Jahr auf der Joker-Konferenz dar√ºber gesprochen, im Prinzip wurde nichts sehr Neues gesagt.  Ich habe versucht, eine Idee mit impliziten Vereinigungstypen wie <code>if(obj instanceof Integer x || obj instanceof Long x) use(x.longValue())</code> , aber ich habe keine Begeisterung gesehen. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jean Christophe Beyler, Arthur Eubanks und Man Cao - Thread Sanitizing f√ºr Java</a> </h1><br><p>  In jeder Hinsicht ein wunderbares Projekt von Google zur Suche nach Rennen, bei dem Daten in Form des Lesens und Schreibens desselben nichtfl√ºchtigen Felds oder Array-Elements aus verschiedenen Streams verwendet werden, ohne dass eine Beziehung zustande kommt, bevor dies geschieht.  Das Projekt wurde urspr√ºnglich als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVM-Modul</a> f√ºr nativen Code geschrieben und jetzt f√ºr HotSpot angepasst.  Dies ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offizielles</a> OpenJDK- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> mit seiner Mailingliste und seinem Repository. </p><br><p>  Laut den Autoren funktioniert das Ding jetzt ganz gut, man kann zusammenbauen und spielen.  Dar√ºber hinaus findet sie Rennen nicht nur im Java-Code, sondern auch im Code nativer Bibliotheken.  Rennen im Code der virtuellen Maschine selbst werden nicht durchsucht, da dort alle Synchronisationsprimitive auf ihre eigene Weise geschrieben sind und TSan sie nicht erkennen kann.  Laut den Autoren gibt TSan keine falsch positiven Ergebnisse. </p><br><p>  Das Hauptproblem ist die Leistung.  Jetzt ist nur der Interpreter f√ºr Java-Code instrumentiert, die JIT-Kompilierung ist vollst√§ndig deaktiviert und der bereits langsame Interpreter wird mehrmals langsamer.  Wenn Sie jedoch √ºber gen√ºgend Ressourcen verf√ºgen (Google verf√ºgt nat√ºrlich √ºber gen√ºgend Ressourcen), k√∂nnen Sie Ihre Testsuiten gelegentlich mit TSan fahren.  Es ist auch geplant, die JIT um Instrumente zu erweitern, dies ist jedoch eine viel ernstere Intervention in der JVM. </p><br><p>  Jemand fragte, ob das Deaktivieren der JIT-Kompilierung das Ergebnis nicht beeinflusst, da einige Rennen m√∂glicherweise nicht auf dem Interpreter angezeigt werden.  Der Redner schloss diese M√∂glichkeit nicht aus, sagte aber, dass sie bereits eine gro√üe Anzahl von Rennen gefunden h√§tten, deren Harken sehr lange dauern w√ºrde.  Seien Sie also vorsichtig, wenn Sie Ihr Projekt unter TSan ausf√ºhren: M√∂glicherweise finden Sie die unangenehme Wahrheit heraus. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brian Goetz - Valhalla Update</a> </h1><br><p>  Jeder wartet auf Werttypen in Java, aber niemand wei√ü, wann sie erscheinen werden.  Die Bewegungen werden jedoch immer ernster.  Es gibt bereits Test- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bin√§r-Assemblys</a> mit dem aktuellen L2-Meilenstein.  In den aktuellen Pl√§nen wird das gesamte Walhalla den Meilenstein L100 erreichen, aber die Autoren sind immer noch optimistisch und glauben, dass mehr als zwei Prozent erreicht wurden. </p><br><p>  Aus sprachlicher Sicht haben wir also Klassen mit dem Inline-Modifikator, die von der virtuellen Maschine auf besondere Weise verarbeitet werden.  Instanzen solcher Klassen k√∂nnen in andere Objekte eingebettet werden, und flache Arrays, die Instanzen von Inline-Klassen enthalten, sind ebenfalls m√∂glich.  Die Instanz hat keinen Header, was bedeutet, dass es keine Identit√§t gibt. Der Hash-Code wird durch Felder berechnet, <code>==</code> auch durch Felder. Ein Synchronisierungsversuch oder <code>Object.wait()</code> f√ºr eine solche Klasse l√∂st eine IllegalMonitorStateException aus.  Das Schreiben von <code>null</code> in eine Variable dieses Typs funktioniert nat√ºrlich nicht.  Die Autoren bieten jedoch eine Alternative: Wenn Sie einen Inline-Klassenpunkt deklariert haben, k√∂nnen Sie ein Feld oder eine Variable vom Typ (√úberraschung-√úberraschung!) <code>Point?</code> deklarieren <code>Point?</code>  und dann wird es ein vollwertiges Objekt auf dem Heap geben (wie Boxen) mit einem Header, einer Identit√§t und einer <code>null</code> hineinpassen. </p><br><p>  Ernsthafte offene Fragen bleiben die Spezialisierung von Generika und die Migration vorhandener Klassen (z. B. <code>Optional</code> ) zu einer Inline-Klasse, um den vorhandenen Code nicht zu besch√§digen (ja, in Variablen vom Typ <code>Optional</code> <code>null</code> ).  Trotzdem taucht das Bild auf und die L√ºcke ist sichtbar. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">David Wrighton und Neal Gafter - Werttypen in der CLR</a> </h1><br><p>  Es war eine √úberraschung f√ºr mich, dass derselbe Neil Gufter, Co-Autor der urspr√ºnglichen Java-Puzzler, jetzt bei Microsoft zur .Net-Laufzeit arbeitet.  Es war auch eine √úberraschung, einen Bericht √ºber die CLR (die sogenannte .Net-Laufzeit) auf der JVM-LS zu sehen.  Es ist jedoch immer n√ºtzlich, die Erfahrungen von Kollegen aus anderen Welten kennenzulernen.  Der Bericht spricht √ºber die verschiedenen Referenzen und Zeiger in der CLR, √ºber die Bytecode-Anweisungen, die f√ºr Werttypen verwendet werden, und dar√ºber, wie sch√∂n spezialisierte verallgemeinerte Funktionen wie Reduzieren sind.  Es war interessant zu erfahren, dass eines der Ziele von Werttypen in .Net eine Interaktion mit nativem Code ist.  Aus diesem Grund ist die Position von Feldern in Werttypen streng festgelegt und kann ohne Transformationen auf eine Struktur projiziert werden.  Die JVM hatte noch nie eine solche Aufgabe und was mit dem nativen Interop zu tun ist - siehe unten. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vladimir Ivanov und John Rose - Vektoren und die Numerik auf der JVM</a> </h1><br><p>  Aktualisieren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Bericht des letzten Jahres erneut</a> .  Wieder ist die Frage, warum sie noch nichts ver√∂ffentlicht haben, wenn vor einem Jahr alles ziemlich gut aussah. </p><br><p>  Ein Vektor ist eine Sammlung mehrerer Zahlen, die in der Hardware durch ein einzelnes Vektorregister wie zmm0 f√ºr AVX512 dargestellt werden k√∂nnen.  In Vektoren k√∂nnen Sie Daten aus Arrays laden, Operationen wie elementweise Multiplikation ausf√ºhren und sie zur√ºckwerfen.  Alle Operationen, f√ºr die Prozessoranweisungen vorhanden sind, werden vom JIT-Compiler in diese Anweisungen integriert.  Die Anzahl der Operationen ist einfach riesig.  Wenn etwas fehlt, wird eine alternative langsame Implementierung verwendet.  Vektorzwischenobjekte werden idealerweise nicht erstellt, die Escape-Analyse funktioniert.  Alle Standard-Rechenalgorithmen werden mit einem Knall vektorisiert, wobei die gesamte Leistung Ihres Prozessors genutzt wird. </p><br><p>  Leider f√§llt es den Autoren schwer, keine Valgalla zu haben: Die Fluchtanalyse ist fragil und funktioniert m√∂glicherweise nicht einfach.  Diese Vektoren m√ºssen einfach Inline-Klassen sein, dann verschwinden alle Probleme.  Es ist unklar, ob diese API √ºberhaupt vor der ersten Version von Valgalla ver√∂ffentlicht werden kann.  Es scheint viel mehr bereit.  Zu den Problemen z√§hlen Schwierigkeiten bei der Unterst√ºtzung des Codes.  Es gibt viele sich wiederholende Teile f√ºr unterschiedliche Registergr√∂√üen und unterschiedliche Datentypen, sodass der gr√∂√üte Teil des Codes aus Vorlagen generiert wird und es weh tut, ihn zu verwalten. </p><br><p>  Die Verwendung ist auch unvollkommen.  In Java gibt es keine Operator√ºberladung, daher sieht die Mathematik h√§sslich aus: Anstelle von <code>max(va-vb*42, 0)</code> Sie <code>va.lanewise(SUB, vb.lanewise(MUL, 42)).lanewise(MAX, 0)</code> .  Es w√§re sch√∂n, Zugang zu AST-Lambdas wie in C # zu haben.  Dann w√§re es m√∂glich, eine benutzerdefinierte Lambda-Operation wie <code>MYOP = binOp((va, vb) -&gt; max(va-vb*42, 0))</code> zu generieren und zu verwenden. </p><br><h1>  30. Juli </h1><br><p>  Der zweite Tag verging unter der Flagge der Zusammenstellung. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mark Stoodley - Von AOT zu JIT und dar√ºber hinaus!</a> </h1><br><p>  Ein IBM-Mitarbeiter, Mitglied des JVM OpenJ9-Projekts, berichtet √ºber seine Erfahrungen mit der JIT- und AOT-Kompilierung.  Es gibt immer Probleme: JIT ist ein langsamer Start, weil es sich erw√§rmt.  CPU-Kosten f√ºr die Kompilierung.  AOT - suboptimale Leistung aufgrund des Fehlens eines Profils (es ist m√∂glich, ein Profil zu erstellen, aber nicht trivial und nicht immer stimmt das Profil w√§hrend der Kompilierung mit dem Profil bei der Ausf√ºhrung √ºberein), es ist schwieriger zu verwenden, an die Zielplattform, das Betriebssystem und den Garbage Collector zu binden.  Einige der Probleme k√∂nnen durch Kombinieren von Ans√§tzen gel√∂st werden: Beginnen Sie mit AOT-kompiliertem Code und beenden Sie dann mit JIT.  Eine gute Alternative zu all dem ist das Zwischenspeichern von JIT.  Wenn Sie viele virtuelle Maschinen haben (Hallo, Microservices), wenden sich alle an einen separaten Dienst - den JIT-Compiler (ja, JITaaS), bei dem alles wie ein Erwachsener ist, Orchestrierung, Lastausgleich.  Dieser Service wird kompiliert.  Sehr oft kann er einer bestimmten Methode vorgefertigten Code geben, da diese Methode bereits auf einer anderen JVM kompiliert wurde.  Dies verbessert das Aufw√§rmen erheblich, entfernt den Ressourcenverbrauch aus Ihrem JVM-Dienst und reduziert im Allgemeinen den gesamten Ressourcenverbrauch. </p><br><p>  Im Allgemeinen k√∂nnte JITaaS das n√§chste Schlagwort in der JVM-Welt sein.  Leider habe ich nicht verstanden, ob dies gerade gespielt werden kann oder ob es sich noch um eine geschlossene Entwicklung handelt. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Christian Wimmer - Verbesserung des nativen GraalVM-Images</a> </h1><br><p>  GraalVM Native Image ist eine Java-Anwendung, die in nativen Code kompiliert wurde und ohne JVM ausgef√ºhrt wird (im Gegensatz zu Modulen, die mit einem AOT-Compiler wie jaotc kompiliert wurden).  Genauer gesagt ist dies keine Java-Anwendung.  Um richtig zu arbeiten, ben√∂tigt er eine geschlossene Welt, dh der gesamte Code sollte in der Kompilierungsphase sichtbar sein, keine Class.forName.  Sie k√∂nnen Reflektions- und Methodenhandles verwenden, aber beim Kompilieren m√ºssen Sie genau angeben, welche Klassen und Methoden durch Reflektion verwendet werden. </p><br><p>  Eine weitere lustige Sache ist die Klasseninitialisierung.  Viele Klassen werden w√§hrend der Kompilierung initialisiert.  Das hei√üt, Ihre statischen Felder werden vom Compiler standardm√§√üig berechnet und das Ergebnis wird in das zusammengestellte Image geschrieben. Wenn Sie die Anwendung starten, wird es einfach gelesen.  Dies ist erforderlich, um eine bessere Kompilierungsqualit√§t zu erzielen: Eine konstante Faltung kann durchgef√ºhrt werden, wenn die Werte der statischen Felder dem Compiler bekannt sind.  Mit JIT ist alles in Ordnung, der Interpreter f√ºhrt eine statische Initialisierung durch und dann k√∂nnen Sie die Konstanten kennen, die Sie kompilieren k√∂nnen.  Und wenn Sie eine native Anwendung erstellen, m√ºssen Sie einen Trick machen.  Dies f√ºhrt nat√ºrlich zu lustigen psychedelischen Effekten.  Daher werden Klassen normalerweise in der Reihenfolge initialisiert, in der auf sie zugegriffen wird. W√§hrend der Kompilierung ist diese Reihenfolge unbekannt und eine Initialisierung in einer anderen ist m√∂glich.  Wenn zwischen Klasseninitialisierern Zirkelverweise vorhanden sind, k√∂nnen Sie den Unterschied im Verhalten des JVM-Codes und im nativen Image erkennen. </p><br><h1>  Workshop Schatzl - Hotspot GC. </h1><br><p>  Sortierte alle Schmerzen aus, die mit den M√ºllsammlern verbunden sind.  Leider habe ich am meisten zugeh√∂rt.  Ich erinnere mich, dass der Speicherabruf des Betriebssystems diskutiert wurde, einschlie√ülich des ekelhaften Xmx f√ºr alle.  Es gibt gute Nachrichten: In Java 13 wurde eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neue Option</a> -XX hinzugef√ºgt: SoftMaxHeapSize.  Bisher wird es nur vom ZGC-Kollektor unterst√ºtzt, aber G1 kann auch aufholen.  Es legt eine Grenze f√ºr die Gr√∂√üe des Heaps fest, die nur in Notfallsituationen √ºberschritten werden sollte, wenn dies nicht anders funktioniert.  Auf diese Weise k√∂nnen Sie ein gro√ües Xmx (z. B. gleich der Gr√∂√üe des gesamten RAM) und eine angemessene SoftMaxHeapSize festlegen.  Dann beh√§lt sich die JVM die meiste Zeit selbst bei, aber bei Spitzenlast wird OutOfMemoryError immer noch nicht ausgel√∂st, sondern es wird mehr Speicher vom Betriebssystem ben√∂tigt.  Wenn die Last abf√§llt, kehrt der Speicher zur√ºck. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mei-Chin Tsai - JIT und AOT in der CLR</a> </h1><br><p>  Microsoft Mei-Chin Tsai sprach √ºber die Funktionen der JIT- und AOT-Kompilierung in der CLR.  Die AOT-Kompilierung wurde f√ºr sie schon lange entwickelt, aber urspr√ºnglich (ngen.exe) wurde sie auf der Zielplattform ausgef√ºhrt, √§hnlich wie beim ersten Start (wenn Sie Windows haben, suchen Sie im Windows-Ordner nach den Dateien * .ni.dll).  Dateien werden abh√§ngig von der Version des lokalen Windows und sogar von anderen DLL-ek abgerufen.  Wenn die Abh√§ngigkeit aktualisiert wird, m√ºssen dementsprechend alle nativen Module neu kompiliert werden.  In der zweiten Generation (crossgen) haben Autoren Anwendungen und Module relativ unabh√§ngig von Hardware- und Betriebssystemversionen und -abh√§ngigkeiten vorkompiliert.  Dies verlangsamte den Code, da Abh√§ngigkeitsaufrufe nun ehrlich virtuell erfolgen mussten.  Dieses Problem wurde gel√∂st, indem JIT angeschlossen und der Hotcode w√§hrend der Anwendung neu kompiliert wurde.  Dann sprachen wir √ºber mehrstufige (gestufte) Kompilierung (es scheint, dass diese in der CLR noch in den Kinderschuhen steckt, w√§hrend sie sich seit mindestens zehn Jahren in Java entwickelt) und √ºber zuk√ºnftige Pl√§ne, AOT wirklich plattform√ºbergreifend zu machen. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wei Kuai und Xiaoming Gu - Speed ‚Äã‚ÄãJVM Performance mit JWarmUp</a> </h1><br><p>  Alibaba-Kollegen stellten ihre Herangehensweise an das JVM-Aufw√§rmproblem vor.  Sie verwenden die JVM f√ºr viele Webdienste.  Im Prinzip ist ein sehr schneller Start nicht so wichtig, da der Balancer immer warten kann, bis der Computer hochf√§hrt, und erst dann Anforderungen an ihn sendet.  Das Problem ist jedoch, dass sich der Computer nicht ohne Anforderungen aufw√§rmt: Der Code, der die Logik zum Verarbeiten von Anforderungen beschreibt, wird nicht aufgerufen, was bedeutet, dass er nicht kompiliert wird.  Es wird kompiliert, wenn die ersten Anforderungen eintreffen, dh unabh√§ngig davon, wie lange der Balancer wartet, tritt bei den ersten Anforderungen ein Leistungsfehler auf.  Zuvor haben sie versucht, dieses Problem zu l√∂sen, indem sie gef√§lschte Anfragen an den bevorstehenden Dienst gesendet haben, bevor sie echte Anfragen an diesen gesendet haben.  Der Ansatz ist interessant, aber es ist ziemlich schwierig, einen solchen gef√§lschten Stream zu generieren, der die Kompilierung des gesamten erforderlichen Codes bewirken w√ºrde. </p><br><p>  Ein separates Problem ist die Deoptimierung.  In den ersten tausend Abfragen, von denen eine immer entlang des ersten Zweigs ging, warf der JIT-Compiler im Allgemeinen den zweiten und f√ºgte dort eine Deoptimierungsfalle ein, um die Codegr√∂√üe zu verringern.  Die 1001. Anfrage ging jedoch an den zweiten Zweig, die Deoptimierung funktionierte und die gesamte Methode ging an den Dolmetscher.  W√§hrend die Statistiken erneut kompiliert werden, w√§hrend die Methode vom C1-Compiler und dann vom C2-Compiler √ºber das vollst√§ndige Profil kompiliert wird, tritt eine Verlangsamung auf.  Und dann in der gleichen Methode eine andere, <code>if</code> deoptimiert werden kann, und alles wird auf eine neue gehen. </p><br><p>  JWarmUp l√∂st das Problem wie folgt.  W√§hrend der ersten Ausf√ºhrung des Dienstes wird einige Minuten lang ein Kompilierungsprotokoll geschrieben: Es zeichnet auf, welche Methoden kompiliert wurden, und die erforderlichen Profilinformationen nach Zweigen, Typen usw. Wenn dieser Dienst sofort nach dem Start neu gestartet wird, werden alle Klassen aus dem Protokoll initialisiert und die protokollierten Methoden kompiliert unter Ber√ºcksichtigung des vorherigen Profils.  Infolgedessen funktioniert der Compiler beim Start gut. Danach beginnt der Balancer, Anforderungen an diese JVM zu senden.  Zu diesem Zeitpunkt ist der gesamte hei√üe Code, den sie bereits kompiliert hat. </p><br><p>  Es ist erw√§hnenswert, dass das Schnellstartproblem hier nicht gel√∂st ist.  Ein Start kann sogar noch langsamer sein, da viele Methoden kompiliert werden, von denen einige m√∂glicherweise nur wenige Minuten nach dem Start erforderlich sind.  Das Protokoll stellt sich jedoch als wiederverwendbar heraus: Im Gegensatz zu AOT k√∂nnen Sie den Dienst auf einer anderen Architektur oder mit einem anderen Garbage Collector erh√∂hen und das vorherige Protokoll wiederverwenden. </p><br><p>  Autoren haben lange <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versucht</a> , JWarmUp in OpenJDK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu</a> pushen.  Bisher erfolglos, aber die Arbeit bewegt sich.  Die Hauptsache ist, dass Sie auf dem Code Review-Server auf einen vollwertigen Patch zugreifen k√∂nnen, sodass Sie ihn problemlos auf die HotSpot-Quellen anwenden und die JVM selbst mit JWarmUp erstellen k√∂nnen. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Juan Fumero - TornadoVM</a> </h1><br><p>  Dies ist ein Forschungsbericht aus Manchester, aber die Autoren behaupten, dass das Projekt an einigen Stellen bereits umgesetzt wurde.  Es ist auch ein Add-On f√ºr OpenJDK, mit dem sich bestimmte Java-Codes ganz einfach auf GPU, iGPU, FPGA √ºbertragen oder einfach auf die Kerne des Prozessors parallelisieren lassen.  Zum Kompilieren auf der GPU verwenden sie GraalVM, in dem sie ihr Backend - TornadoJIT - erstellt haben.  Eine korrekt geschriebene Java-Methode wird transparent an das entsprechende Ger√§t gesendet.  Die Kompilierung auf FPGA kann zwar mehrere Stunden dauern, aber wenn Ihre Aufgabe als Monat betrachtet wird, warum dann nicht?  Einige Benchmarks (zum Beispiel die diskrete Fourier-Transformation) sind mehr als hundertmal schneller als Java, was im Prinzip erwartet wird.  Das Projekt wird vollst√§ndig auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> hochgeladen, wo Sie auch wissenschaftliche Ver√∂ffentlichungen zu diesem Thema finden. </p><br><h1>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Maurizio Cimadomore - Panama dekonstruieren</a> </h1><br><p>  Alles das gleiche Lied - ein langj√§hriges Projekt, jede Gipfelpr√§sentation, vor einem Jahr sah alles ziemlich fertig aus, aber es gab noch keine Ver√∂ffentlichung.  Es stellte sich heraus, dass sich der Fokus seitdem verschoben hat. </p><br><p>  Die Idee des Projekts ist eine verbesserte Interaktion mit nativem Code.  Jeder wei√ü, wie schmerzhaft es ist, JNI zu verwenden.  Es tut sehr weh.  Das Panama-Projekt hebt diesen Schmerz auf: Mit Jextract werden Java-Klassen aus den * .h-Dateien der nativen Bibliothek generiert, die durch Aufrufen nativer Methoden sehr praktisch sind.  Auf der C / C ++ - Seite m√ºssen Sie √ºberhaupt keine einzige Zeile schreiben.  Au√üerdem wurde alles viel schneller: Der Overhead bei Aufrufen von Java-&gt; native und native-&gt; Java ging zeitweise zur√ºck.  Was willst du mehr? </p><br><p>  Es gibt ein Problem, das schon seit einiger Zeit besteht - das √úbertragen von Datenarrays auf nativen Code.  Bisher ist die empfohlene Methode DirectByteBuffer, bei der viele Probleme auftreten.  Eine der schwerwiegendsten ist die nicht verwaltete Lebensdauer (der Puffer verschwindet, wenn der Garbage Collector das entsprechende Java-Objekt aufnimmt).  Aufgrund dieses und anderer Probleme verwenden Benutzer Unsafe, die mit der gebotenen Sorgfalt problemlos die gesamte virtuelle Maschine ablegen k√∂nnen. </p><br><p>  Dies bedeutet, dass Sie einen neuen normalen Speicherzugriff au√üerhalb des Java-Heaps ben√∂tigen.  Zuordnung, strukturierte Accessoren, explizite Entfernung.  Strukturierte Accessoren - damit Sie die Offsets nicht selbst berechnen m√ºssen, wenn Sie beispielsweise <code>struct { byte x; int y; }[5]</code> <code>struct { byte x; int y; }[5]</code>  <code>struct { byte x; int y; }[5]</code> .  Stattdessen beschreiben Sie einmal das Layout dieser Struktur und f√ºhren dann beispielsweise <code>VarHandle</code> , das alle <code>x</code> lesen kann, indem Sie √ºber <code>y</code> springen.  In diesem Fall sollte es nat√ºrlich immer eine Grenzpr√ºfung geben, wie bei normalen Java-Arrays.  Dar√ºber hinaus sollte der Zugang zu einem bereits geschlossenen Bereich verboten werden.  Und dies stellt sich als nicht triviale Aufgabe heraus, wenn wir die Leistung auf der unsicheren Ebene halten und den Zugriff von mehreren Threads aus erm√∂glichen m√∂chten.  Kurz gesagt, schauen Sie sich das Video an, sehr interessant. </p><br><h1>  Workshop: Vladimir Kozlov - Metropolis-Projekt </h1><br><p>  Das Metropolis-Projekt kombiniert alle Versuche, Teile der JVM in Java neu zu schreiben.  Sein Hauptteil ist heute der Graal-Compiler.  In den letzten Jahren hat es sich sehr gut entwickelt und es ist bereits die Rede von einem vollst√§ndigen Ersatz f√ºr das alternde C2.  Fr√ºher gab es ein Bootstrap-Problem: Der Gral begann langsam, weil er selbst JIT-kompiliert oder interpretiert werden musste.  Dann erschien die AOT-Kompilierung (ja, das Hauptziel des AOT-Kompilierungsprojekts ist der Bootstrap des Grals selbst).  Aber mit AOT frisst der Gral einen anst√§ndigen Teil des Heaps einer Java-Anwendung auf, die ihren Heap m√∂glicherweise nicht wirklich teilen m√∂chte.  Jetzt haben wir gelernt, den Gral mithilfe von Graal Native Image in eine native Bibliothek umzuwandeln, wodurch wir den Compiler letztendlich vom allgemeinen Heap isolieren konnten.  Bei der Spitzenleistung des vom Grail kompilierten Codes treten bei einigen Benchmarks immer noch Probleme auf.  Zum Beispiel bleibt der Gral in Bezug auf Intrinsik und Vektorisierung hinter C2 zur√ºck.  Dank der sehr leistungsf√§higen Inlining- und Escape-Analyse wird C2 im Funktionscode, in dem viele unver√§nderliche Objekte und viele kleine Funktionen erstellt werden, einfach unterbrochen.  Wenn Sie auf den Felsen schreiben und den Gral immer noch nicht verwenden, f√ºhren Sie ihn aus.  Dar√ºber hinaus ist es in den neuesten Versionen von JDK ziemlich trivial, ein paar Schl√ºssel zu machen, alles ist bereits im Kit enthalten. </p><br><h1>  31. Juli </h1><br><h1>  Kevin Bourrillion - Nullness Annotations f√ºr Java </h1><br><p>  Kevin k√ºndigte ein neues Projekt an, bat jedoch darum, nicht √∂ffentlich zu sprechen und keine Aufzeichnung seiner Rede auf YouTube zu ver√∂ffentlichen.  Tut mir leid.  ,        . </p><br><h1> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitry Petrashko ‚Äî Gradual typing for Ruby at Scale with Sorbet</a> </h1><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sorbet</a>   (!) Ruby,       Ruby   .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stripe</a>         Ruby   , ,    .  ,     . </p><br><h1> Lightning Talks </h1><br><p> -     .   Remi Forax     ,       ,   .    ,      : </p><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1156627887165804544"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><p>      ,   -     ,   . </p><br><h1> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erik Meijer ‚Äî Differentiable Programming</a> </h1><br><p>             ML  AI      ,     .     ,    Facebook   ‚Äî        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">getafix</a> , --,       ,   .          . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,    .  ,    ,        . </p><br><p>    .   .    OpenJDK Committer Workshop. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462101/">https://habr.com/ru/post/de462101/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462083/index.html">Schnelle Datenstrukturen mit Beispielen. Teil eins: verkn√ºpfte Liste</a></li>
<li><a href="../de462087/index.html">Testen einer intelligenten Haush√§lterin (Wodka, Kefir, Fotos anderer Leute)</a></li>
<li><a href="../de462091/index.html">L√∂sung der Aufgabe mit pwnable.kr cmd1, cmd2, asm, blukat. Bypass-Filterung unter Linux. Shellcode mit pwntools schreiben</a></li>
<li><a href="../de462095/index.html">Arbeiten mit Licht und Optik: Wie man eine Karriere an der Universit√§t beginnt - die Erfahrung von Absolventen von vier spezialisierten Masterstudieng√§ngen</a></li>
<li><a href="../de462097/index.html">Hellgr√ºne Tour</a></li>
<li><a href="../de462107/index.html">Kostenloser Marathon ‚ÄûBig Data und Superhelden: Ihre erste Erfahrung in der Datenanalyse‚Äú</a></li>
<li><a href="../de462109/index.html">Fast unsichtbar sehen, auch in Farbe: Eine Technik zur Visualisierung von Objekten durch einen Diffusor</a></li>
<li><a href="../de462111/index.html">Wie wir mehrere Zeitreihendatenbanken getestet haben</a></li>
<li><a href="../de462113/index.html">Schuldlose Umgebung: Niemand sollte Qualit√§tscode schreiben</a></li>
<li><a href="../de462115/index.html">Passen Sie den Sternenhimmel in WebGL in 1009 Byte JavaScript an</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>