<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😈 🏳️ ❔ MapKit搜索：提示和技巧 ☝🏻 ☪️ 👩‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="MapKit是一个软件库，可让您在移动应用程序中使用地图数据和Yandex技术。 她的官方文档已经包含API方法的详细说明，因此今天我们将讨论其他内容。 


 在本文中，我将向Habr读者介绍MapKit中的搜索功能，并分享可能对您有用的建议和技巧。 


 TL; DR如果您不想阅读整篇文章，这...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MapKit搜索：提示和技巧</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428564/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/dq/_i/jl/dq_ijlbhgproad1ydyfpsill35e.png" width="480"></div><br><p>  MapKit是一个软件库，可让您在移动应用程序中使用地图数据和Yandex技术。 她的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a>已经包含API方法的详细说明，因此今天我们将讨论其他内容。 </p><br><p> 在本文中，我将向Habr读者介绍MapKit中的搜索功能，并分享可能对您有用的建议和技巧。 </p><br><p>  <strong>TL; DR</strong>如果您不想阅读整篇文章，这里有两个最有用的要点，可以作为阅读前言的补偿： </p><br><ul><li> 不要忘记保存会话，否则搜索将无法进行。 </li><li> 所有最有趣的信息都存储在对象的元数据中。 如果要查找完整的地址，营业时间或在特定咖啡馆中一杯卡布奇诺咖啡的价格，则需要元数据。 </li></ul><br><p> 文本中文档的链接适用于Android，适用于iOS的类和方法以相同的方式调用。 </p><a name="habracut"></a><br><h2 id="chto-umeet-poisk"> 什么可以搜寻 </h2><br><p> 首先，让我们谈谈MapKit中的搜索功能。 当您想在地图应用程序中查找内容时，搜索可以满足您的期望。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/1g/wv/m01gwvpktgpsipyacy4rj5pi3yw.jpeg" width="720"></div><br><p> 当您在搜索栏中输入“ cafe”，“ Lev Tolstoy street，16”或“ tram 3”时， <strong>文本搜索将</strong>起作用。 这是最复杂的搜索类型。 从某种意义上说，它支持最大的自定义参数集。 您可以立即尝试沿着您感兴趣的路线或街道进行搜索，明确所需的结果数量，设置用户的位置，等等。 如果在第一次搜索后您想要移动地图或将过滤器应用于请求（“有游泳池的药房”），则这些是<strong>重新请求</strong> 。 </p><br><p> 大多数用户对“这里是什么？”这个问题<strong>很</strong>熟悉。 它允许您单击地图以确定哪个街道或房屋在“光标之下”或哪个组织在该点附近。 当您要查找特定对象时，需要<strong>按URI搜索</strong> 。 例如，它可用于在应用程序中创建书签。 我们找到了我们最喜欢的咖啡店，并用星号标记-下次无论地图窗口位于何处，都可以通过URI准确找到该组织。 反向查询和URI查询都不支持重新请求，因为没有为它们指定的内容。 </p><br><p> 搜索中存在的另一种可能性是<strong>搜索提示</strong> ，它使您可以在键入查询时自动补充查询。 但是，我们将再次推迟有关它们的详细故事。 </p><br><h2 id="kak-ustroen-zapros"> 请求的安排方式 </h2><br><p>搜索与MapKit的许多部分一样，都是异步进行的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">搜索会话</a>是处理此异步问题的主要对象。 让我们看一个小例子。 </p><br><div class="spoiler">  <b class="spoiler_title">关于例子</b> <div class="spoiler_text"><p>本文中的示例将在Kotlin上进行，以使使用可选值和减少样板代码的工作变得更加容易。  MapKit有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示应用程序</a> 。 它可以用来测试示例，但是为此， <a href=""><code>SearchActivity</code></a>应该从Java转换为Kotlin。  <code>showMessage</code>有时会出现在代码中，它是您在屏幕或日志中显示一行文本的任何便捷方法。 </p></div></div><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// `searchManager`  `searchSession` –  .    //    ,     . searchManager = SearchFactory.getInstance().createSearchManager( SearchManagerType.ONLINE ) val point = Geometry.fromPoint(Point(59.95, 30.32)) searchSession = searchManager!!.submit("", point, SearchOptions(), object: Session.SearchListener { override fun onSearchError(p0: Error) { showMessage("Error") } override fun onSearchResponse(p0: Response) { showMessage("Success") } } )</span></span></code> </pre> <br><p> 调用Submit之后<code>submit</code>控件将立即返回您的代码，并且MapKit收到来自服务器的响应时，将调用SearchListener。 </p><br><p> 搜索会话使您可以： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">取消请求</a> 。 例如，如果用户关闭搜索屏幕。 </li><li> 出现错误时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重复请求</a> 。 例如，如果网络有任何问题。 </li><li> 收到响应后，继续与搜索进行交互。 通过会话进行<strong>重新请求</strong> 。 </li></ul><br><p> 取消会话将自动取消。 这意味着，如果未将其保存在客户端代码侧，则搜索将无法进行。 <br>  <strong>不要忘记保存会话，该会话是您的朋友！</strong> </p><br><h3 id="search-options"> 搜索选项 </h3><br><p> 配置搜索查询的一般方法是通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>SearchOptions</code></a>类，该类允许您修改查询参数。 </p><br><ul><li> 这些参数的主要是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>SearchType</code></a> 。 它允许您指定是否要在答案中查看地名，组织或运输（您很可能不需要其他类型）。 </li><li> 另一个重要的查询参数是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘要</a> 。 我们将在响应设备部分中更详细地讨论它们。 </li><li> 如果要获取地名的几何形状（例如，街道或区域），则需要通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>setGeometry(true)</code></a>对其进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>setGeometry(true)</code></a> 。 请记住，就传输数据而言，几何结构非常“繁重”。 </li><li> 默认情况下，搜索不会返回封闭的（临时或永久）组织，但是如果需要它们，则需要设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>setSearchClosed(true)</code></a> 。 </li></ul><br><p> 除了列出的参数外，还有更多可能对您有用的参数，可以在该类的文档中找到它们。 请注意，并非所有查询都支持所有参数组合。 每个<code>SearchManager</code>或<code>Session</code>方法的文档都指出它可以理解<code>SearchOptions</code>哪些参数。 </p><br><h2 id="kak-ustroen-otvet"> 答案如何安排 </h2><br><p> 从支持方面的问题来看，大多数用户对搜索响应的格式感到困惑。 如果您查看响应类，它看起来非常简单（至少，对我们来说有趣的部分）： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> SearchMetadata </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> GeoObjectCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCollection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p> 在这里， <code>getCollection()</code>返回响应中的对象，而<code>getMetadata()</code>是一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">附加数据</a> ，例如，包含有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">响应窗口</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">排名类型</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到的结果数的信息</a> 。 如果查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>GeoObjectCollection</code></a>内部<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>GeoObjectCollection</code></a>可以看到它包含一些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Item</code></a> ，这些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>Item</code></a>可以是其他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>GeoObjectCollection</code></a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>GeoObject</code></a> 。 </p><br><p> 搜索中的集合内部没有集合（至少现在还没有），因此让我们看一下<code>GeoObject</code> 。 在对象内部有一个名称（ <code>getName()</code> ），一个描述（ <code>getDescriptionText()</code> ），一个框架（ <code>getBoundingBox()</code> ），一组几何形状（ <code>getGeometry()</code> ）以及其他一些不太清晰的方法。 该组织的电话号码在哪里？ 如何理解地名指的是哪个城市？ </p><br><p> 通过对象的方法，这不是很清楚。 </p><br><h3 id="geoobject"> 地物 </h3><br><p> 现在该讨论有关<code>GeoObject</code>更多信息。 </p><br><p>  <code>GeoObject</code>是这样的基本“卡片”对象。 它的内部可能是道路事件，与搜索结果不同的对象，路线中的动作或地图（POI）上的对象，例如纪念碑或某些著名的组织。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_l/ut/15/_lut15ur4w70yz88v1127swd6wg.png"></div><br><p> 关于对象的所有最有趣的内容都存储在元数据中。 可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>getMetadataContainer()</code></a>方法访问它们。 此容器中的键是元数据类型。 如果您在文档中看到以<code>Metadata</code>一词结尾的内容，则很可能在这里。 在搜索不同的“元数据”片段15。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gd/we/00/gdwe00tnfbshuzugslvjssupja4.png"></div><br><p> 元数据可以分为几种类型。 第一种类型是元数据，它确定对象所属的类型：地名（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>ToponymObjectMetadata</code></a> ），组织（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>BusinessObjectMetadata</code></a> ）或传输（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>TransitObjectMetadata</code></a> ）。 在地名的元数据中，您可以找到结构化的地址和详细的几何图形。 组织的元数据是营业时间或公司所在地。 此元数据由请求中的搜索类型确定-如果仅搜索地名，则响应中的每个对象都应具有相应的元数据。 如果要查找地名或组织，则每个对象将至少具有两个“元数据”之一。 </p><br><p> 这是查找公司电话号码的方法： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> phones = response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(<span class="hljs-type"><span class="hljs-type">BusinessObjectMetadata</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">phones</span></span></span></span></code> </pre> <br><p> 以下是在结构化地址中查找城市的方法： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> city = response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(<span class="hljs-type"><span class="hljs-type">ToponymObjectMetadata</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">address</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">components</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">?</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">firstOrNull</span></span></span><span class="hljs-class"> </span></span>{ it.kinds.contains(<span class="hljs-type"><span class="hljs-type">Address</span></span>.<span class="hljs-type"><span class="hljs-type">Component</span></span>.<span class="hljs-type"><span class="hljs-type">Kind</span></span>.<span class="hljs-type"><span class="hljs-type">LOCALITY</span></span>) } ?.name</code> </pre> <br><p> 第二种类型是对象附带的元数据，尽管您没有询问它。 您需要了解的主要类型是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>URIObjectMetadata</code></a> 。 在<code>URIObjectMetadata</code>内部<code>URIObjectMetadata</code>存储了对象的唯一标识符，必须在<strong>URI</strong>中将其传递给<strong>搜索</strong> 。 </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//       «»,     //     val uri = response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(UriObjectMetadata::class.java) ?.uris ?.firstOrNull() ?.value</span></span></code> </pre> <br><p> 第三种是元数据，仅当您明确要求对其进行搜索时，它才会出现在答案中。 以另一种方式，此元数据称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">片段</a> 。 片段是一些小的附加数据，它们的变化比基本的“参考”数据更频繁，或者不是每个人都需要。 这可以是等级，与照片或全景照片的链接，汇率或加油站的燃料价格。 摘要列表必须使用搜索选项进行设置。 如果服务器有一个有序的代码段，那么它将把它添加到相应的对象中。 </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> point = <span class="hljs-type"><span class="hljs-type">Geometry</span></span>.fromPoint(<span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">59.95</span></span>, <span class="hljs-number"><span class="hljs-number">30.32</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> options = <span class="hljs-type"><span class="hljs-type">SearchOptions</span></span>() options.snippets = <span class="hljs-type"><span class="hljs-type">Snippet</span></span>.<span class="hljs-type"><span class="hljs-type">FUEL</span></span>.value searchSession = searchManager!!.submit(<span class="hljs-string"><span class="hljs-string">""</span></span>, point, options, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> fun onSearchResponse(response: <span class="hljs-type"><span class="hljs-type">Response</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         showMessage(response.collection.children.firstOrNull()?.obj ?.metadataContainer ?.getItem(FuelMetadata::class.java) ?.fuels ?.joinToString("\n") { "Fuel(name=${it.name}, price=${it.price?.text})" } ?: "No fuel" ) }</span></span></code> </pre> <br><p> 上面列出的所有元数据都会添加到响应中的各个对象中。 也有元数据添加到整个响应中。 但是它们是用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>SearchMetadata</code></a>方法带出来的，不需要从任何特殊集合中提取它们。 </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//            response.metadata.businessResultMetadata?.categories //     (  )     response.metadata.toponymResultMetadata?.responseInfo?.mode</span></span></code> </pre> <br><h2 id="primery-ispolzovaniya"> 使用范例 </h2><br><p> 现在，让我们浏览一下搜索类的主要方法，查看使用示例以及与之相关的一些非显而易见的地方。 </p><br><h3 id="poisk-po-tekstu"> 文字搜寻 </h3><br><p> 文本搜索（可能是整个搜索）的主要方法是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>submit</code></a> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Session </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String text, Geometry geometry, SearchOptions searchOptions, SearchListener searchListener )</span></span></span></span>;</code> </pre> <br><ul><li>  <code>text</code>参数应包含您要搜索的文本。 </li><li>  <code>geometry</code>参数有点棘手。 根据传输的几何类型，搜索的行为将有所不同： <br><ul><li> 如果您通过了一个点，则搜索将在该点旁边的一个小窗口中进行。 </li><li> 如果传递矩形窗口（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>BoundingBox</code></a> ）或四个点的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多边形</a> ，则它将用作搜索框。 这种窗口的一个简单示例是地图的可见区域。 </li><li> 最后，如果传递<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">折线</a> ，则描述该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">折线</a>的窗口将用作搜索窗口，并将考虑该折线进行排名。 </li></ul></li><li> 我们已经在上面谈到了<code>SearchOptions</code>和<code>SearchListener</code> 。 </li></ul><br><p> 服务器可能认为正确的答案不在执行初始搜索的窗口中（当搜索窗口位于莫斯科时，“符拉迪沃斯托克咖啡馆”）。 在这种情况下，您将需要进入响应窗口并将卡移动到那里，以便在屏幕上看到结果（重新请求不允许自己执行此操作，也不会要求移动卡）。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>submit</code></a>方法具有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>submit</code></a>双胞胎： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Session </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String text, Polyline polyline, Geometry geometry, SearchOptions searchOptions, SearchListener searchListener )</span></span></span></span>;</code> </pre> <br><p> 带有一个附加参数。 此参数可用于传输较大的折线（例如，到另一座城市的路线）和较小的搜索窗口。 然后，搜索本身将切出已转移折线的必要部分，并将其仅用于查询。 </p><br><h3 id="perezaprosy"> 重新要求 </h3><br><p> 与其他类型的请求不同，重新请求是在搜索会话的帮助下完成的，该搜索会话返回相同的<code>submit</code>及其孪生兄弟。 会话的部分方法简单明了： </p><br><ul><li> 您可以更改<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请求窗口</a> （例如，当用户移动卡时） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">搜索选项</a>可以更新（例如，更新用户的位置） </li><li> 您可以更改排名的类型-通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">距离</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">等级</a> 。 </li></ul><br><p> 要执行精确搜索，您需要使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>resubmit</code></a>方法。 它接受与常规搜索相同的<code>SearchListener</code> 。 在调用它之前，您可以更改几个会话参数。 例如，同时更改排名类型并应用过滤器。 </p><br><h4 id="filtry"> 筛选器 </h4><br><p> 由于我们在谈论过滤器。 筛选条件适用于Wi-Fi和意大利美食。 它们可能具有MapKit中所有搜索界面中最令人困惑的语法。 这是由于以下事实：使用相同的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据结构</a>从搜索响应中获取过滤器并在重新请求中指定过滤器。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7m/51/ky/7m51ky9gytyd1rlubljviboun5k.jpeg" width="360"></div><br><p> 过滤器有两种类型。 布尔过滤器仅假设两个互斥的值-是或否。 这可能是咖啡馆，加油站的洗手间或组织附近的停车场中存在Wi-Fi。 枚举过滤器假定可以一起请求许多值。 例如，这是咖啡馆的厨房类型或加油站的燃料类型。 </p><br><p> 首先，让我们看看如何使过滤器可用于当前重启： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> fun filters(response: <span class="hljs-type"><span class="hljs-type">Response</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span>? { fun enumValues(filter: <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>) = filter .values .enums ?.joinToString(prefix = <span class="hljs-string"><span class="hljs-string">" -&gt; "</span></span>) { e -&gt; e.value.id } ?: <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response .metadata .businessResultMetadata ?.businessFilters ?.joinToString(separator = <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) { f -&gt; <span class="hljs-string"><span class="hljs-string">"${f.id}${enumValues(f)}"</span></span> } }</code> </pre> <br><p> 在结果行中，对于布尔过滤器，将仅显示标识符，对于枚举过滤器，将显示过滤器本身的标识符和可用值的标识符。 现在，凭借对可用标识符的了解，我们将寻找带有Wi-Fi的义大利风味咖啡馆。 首先添加一个布尔过滤器： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boolFilter = <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* id= */</span></span> <span class="hljs-string"><span class="hljs-string">"wi_fi"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* name= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* disabled= */</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* values= */</span></span> <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">Values</span></span>.fromBooleans( listOf(<span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">BooleanValue</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) ) )</code> </pre> <br><p> 现在，枚举过滤器： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enumFilter = <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* id= */</span></span> <span class="hljs-string"><span class="hljs-string">"type_cuisine"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* name= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* disabled= */</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* values= */</span></span> <span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">Values</span></span>.fromEnums( listOf(<span class="hljs-type"><span class="hljs-type">BusinessFilter</span></span>.<span class="hljs-type"><span class="hljs-type">EnumValue</span></span>( <span class="hljs-type"><span class="hljs-type">Feature</span></span>.<span class="hljs-type"><span class="hljs-type">FeatureEnumValue</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* id= */</span></span> <span class="hljs-string"><span class="hljs-string">"italian_cuisine"</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* name= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* imageUrlTemplate= */</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> ), <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> )) ) )</code> </pre> <br><p> 最后，您可以向会话添加过滤器并调用<code>resubmit()</code> ： </p><br><pre> <code class="scala hljs">searchSession!!.setFilters(listOf(boolFilter, enumFilter)) searchSession!!.resubmit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><p> 请注意，您无法为第一个查询设置过滤器。 首先，您需要获取列出可用过滤器的搜索响应。 然后才重新启动。 </p><br><h5 id="dopolnitelnye-rezultaty"> 附加结果 </h5><br><p> 另一个会话使您可以检查是否有其他搜索结果可用于您的请求。 并且，如果是，请获取它们。 例如，当您在城市中寻找咖啡馆时，很可能所有咖啡馆都不适合搜索答案的一页。 要查看列表中的以下页面，需要几个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>hasNextPage</code></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>fetchNextPage</code></a> 。 在这里，您需要知道，首先，如果<code>hasNextPage</code>方法返回<code>false</code> ，则调用<code>fetchNextPage</code>将引发异常。 其次，使用这些方法意味着其余参数不会更改。 也就是说，该会话用于完善请求（ <code>resubmit()</code> ），或检索以下页面（ <code>fetchNextPage()</code> ）。 不需要组合这些模式。 </p><br><h4 id="obratnyy-poisk"> 反向搜寻 </h4><br><p> 为了方便而进行的反向搜索也称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>submit</code></a> ： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Session </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Point point, Integer zoom, SearchOptions searchOptions, SearchListener searchListener )</span></span></span></span></code> </pre> <br><p> 它与其他类型的查询的不同之处在于，只<em>需要</em>输入一种搜索即可。 您可以传递<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>GEO</code></a>类型并查找地名，或者传递<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>BIZ</code></a>类型并查找组织。 没有第三名。 </p><br><p> 使用<code>GEO</code>类型进行搜索时，有一些点需要澄清。 请注意，答案将在层次结构中包含多个对象（也就是说，答案将包括房屋，街道，城市等）。 在简单的情况下，您可以仅拍摄第一个对象。 在更复杂的数据库中，搜索所需的层次结构。 </p><br><p> 需要缩放级别才能产生足够的结果，具体取决于用户在地图上看到的内容。 假设有一个用户在全国范围内查看地图。 如果用户不小心进入了街道或房屋，那么他单击另一条街道或房屋将很奇怪。 足够多的城市。 这就是<code>zoom</code>参数的用途。 </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(<span class="hljs-number"><span class="hljs-number">55.734</span></span>, <span class="hljs-number"><span class="hljs-number">37.588</span></span>) <span class="hljs-comment"><span class="hljs-comment">//         «  , 16» searchSession = searchManager!!.submit(point, 16, SearchOptions(), this) //    –  " " searchSession = searchManager!!.submit(point, 14, SearchOptions(), this)</span></span></code> </pre> <br><h4 id="poisk-po-uri"> 依URI搜寻 </h4><br><p> 这里的一切都非常清楚-我们从<code>URIObjectMetadata</code>获取URI，并记住它，经过一段时间的搜索之后，通过此URI，我们可以准确地得到我们记住的对象。 </p><br><pre> <code class="scala hljs">searchSession = searchManager!!.resolveURI(uri, <span class="hljs-type"><span class="hljs-type">SearchOptions</span></span>(), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><p> 不知何故甚至无聊。 </p><br><h2 id="poiskovyy-sloy-i-svetloe-buduschee"> 搜索层与光明的未来 </h2><br><p> 在<code>SearchManager</code>旁边，还有一个叫做<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">搜索层</a>的东西。 设想该层将搜索与地图结合起来。 他本人知道如何向其中添加结果，移动地图，以便在用户移动地图时显示这些结果并进行重新查询。 在许多方面，它类似于<code>SearchManager</code>和<code>Session</code>的组合，但是内置的地图功能增加了新功能。 而谈论它们超出了本文的范围。 在发布MapKit 3.1时，我们已经在实际应用程序中的搜索层上运行了，因此您可以在家中尝试使用它。 也许它将使您的搜索工作更加轻松。 </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/tg/g4/cttgg4rh3iffabd5xfm8fc6s_ha.jpeg" width="480"></div><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 我希望阅读本文后，您将全面了解如何在MapKit中使用搜索。 当然，仍然存在一些微妙和不平凡的时刻（例如，我们几乎没有谈论提示和搜索层）。 可以在文档中找到某些内容，可以在GitHub上的项目中找到一些内容，或者寻求我们的支持。 </p><br><p> 尝试使用MapKit，使用其中的搜索功能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来</a>使用MapKit，使它们变得更好！ </p><br><p>  <strong>PS</strong> And还将在11月29日来访我们，以听取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">汽车路由后端的安排</a> 。 顺便说一下，它也可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MapKit中使用</a> ，但这是一个完全不同的故事。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428564/">https://habr.com/ru/post/zh-CN428564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428552/index.html">算法：如何查找下一个词典编排</a></li>
<li><a href="../zh-CN428556/index.html">“生产环境超出您的控制范围”：Rian Lewis测试区块链项目</a></li>
<li><a href="../zh-CN428558/index.html">我是如何从懒惰中为WordPress创建向导的</a></li>
<li><a href="../zh-CN428560/index.html">计划外的周五公告</a></li>
<li><a href="../zh-CN428562/index.html">Droidcon伦敦。 怎么样了</a></li>
<li><a href="../zh-CN428566/index.html">JavaScript箭头功能：为什么需要它们，如何处理它们，何时使用它们以及何时不使用它们</a></li>
<li><a href="../zh-CN428568/index.html">React Native Web应用程序开发指南</a></li>
<li><a href="../zh-CN428570/index.html">JavaScript中的高阶函数</a></li>
<li><a href="../zh-CN428572/index.html">React中的高阶组件</a></li>
<li><a href="../zh-CN428574/index.html">通过Zextras Chat将公司沟通提升到一个新的水平</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>