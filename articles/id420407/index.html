<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸ’» ğŸ¦ â†–ï¸ C bukan bahasa tingkat rendah ğŸ“œ ğŸ˜º ğŸ‘¨ğŸ¾â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Komputer Anda bukan versi cepat PDP-11 
 Halo, Habr! 

 Nama saya Anton Dovgal, saya adalah pengembang C (dan tidak hanya) di Badoo. 

 Saya menemukan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C bukan bahasa tingkat rendah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/420407/"><img src="https://habrastorage.org/webt/8n/tg/og/8ntgogmuur_qld0ho0701jc83du.jpeg"><br><br><h3>  <i>Komputer Anda bukan versi cepat PDP-11</i> </h3><br>  Halo, Habr! <br><br>  Nama saya Anton Dovgal, saya adalah pengembang C (dan tidak hanya) di Badoo. <br><br>  Saya menemukan sebuah artikel oleh David Chiznell, seorang peneliti di Universitas Cambridge, di mana ia membantah pendapat yang diterima secara umum bahwa C adalah bahasa tingkat rendah, dan argumennya sepertinya cukup menarik bagi saya. <br><br>  Mengingat kerentanan yang baru ditemukan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meltdown dan Specter</a> harus meluangkan waktu untuk mencari tahu alasan terjadinya mereka.  Kedua kerentanan ini mengeksploitasi eksekusi spekulatif instruksi oleh prosesor dan memungkinkan penyerang menerima hasil melalui saluran pihak ketiga.  Kerentanan dalam fitur prosesor, bersama dengan beberapa yang lain, ditambahkan sehingga programmer C terus percaya bahwa mereka memprogram dalam bahasa tingkat rendah, meskipun ini tidak terjadi selama beberapa dekade. <br><br>  Produsen prosesor tidak sendirian dalam hal ini.  Pengembang kompiler C / C ++ juga berkontribusi. <br><a name="habracut"></a><br><h2>  Apa itu bahasa tingkat rendah? </h2><br>  Ilmuwan komputer Amerika dan pemenang Hadiah Turing pertama Alan Perlis memberikan definisi berikut: <br><blockquote>  "Bahasa pemrograman tingkat rendah jika program yang ditulis di atasnya memerlukan perhatian terhadap yang tidak esensial." </blockquote><br>  Meskipun definisi ini mengacu pada C, itu tidak memberikan pemahaman tentang apa yang orang ingin lihat dalam bahasa tingkat rendah.  Berbagai properti membuat orang menganggap bahasanya rendah.  Bayangkan skala bahasa pemrograman dengan assembler di satu ujung dan antarmuka ke komputer Enterprise di ujung lainnya.  Bahasa tingkat rendah lebih dekat dengan besi, sedangkan bahasa tingkat lebih tinggi lebih dekat dengan cara orang berpikir. <br><br>  Agar â€œlebih dekat dengan perangkat kerasâ€, bahasa harus menyediakan abstraksi yang cocok dengan abstraksi platform target.  Mudah untuk membuktikan bahwa C adalah bahasa tingkat rendah dalam PDP-11.  Eksekusi berurutan dari program, ruang alamat datar, bahkan operator sebelum dan sesudah kenaikan, jatuh sempurna pada mode pengalamatan PDP-11. <br><br><h2>  Emulator PDP-11 cepat </h2><br>  Alasan utama untuk kerentanan Specter dan Meltdown adalah bahwa pembuat prosesor tidak hanya membuat prosesor cepat, mereka membuat prosesor cepat dengan antarmuka PDP-11.  Ini penting karena memungkinkan programmer C untuk terus percaya bahwa bahasa mereka dekat dengan perangkat keras. <br><br>  Kode C memberikan otomat abstrak berurutan sebagian besar (hingga C11, itu sepenuhnya berurutan, jika ekstensi non-standar dikecualikan).  Membuat utas baru adalah panggilan ke fungsi perpustakaan, operasi yang cukup mahal.  Oleh karena itu, prosesor, yang ingin terus mengeksekusi kode C, bergantung pada level-level parallelism (ILP).  Mereka menganalisis operasi tetangga dan melakukan operasi independen secara paralel.  Ini sangat menyulitkan prosesor dan mengarah pada peningkatan konsumsi daya, tetapi memungkinkan programmer untuk menulis sebagian besar kode berurutan.  Sebaliknya, prosesor grafis (GPU) mencapai kinerja tinggi dengan cara lain: mereka memerlukan penulisan program paralel. <br><br>  Konkurensi tinggi pada level perintah adalah penyebab langsung Specter dan Meltdown.  Prosesor Intel modern mengeksekusi hingga 180 instruksi secara bersamaan (tidak seperti mesin C berurutan abstrak, yang mengharapkan instruksi sebelumnya dijalankan sebelum yang berikutnya dimulai).  Heuristik khas kode C menunjukkan bahwa rata-rata ada satu cabang untuk setiap tujuh instruksi.  Jika Anda ingin agar pipa instruksi tetap lengkap, maka Anda perlu menebak 25 cabang berikutnya.  Ini, pada gilirannya, menambah kerumitan - prosesor pertama-tama menghitung cabang yang salah duga, dan kemudian melempar hasil perhitungan, yang secara negatif memengaruhi konsumsi energi.  Data yang dilemparkan ini memiliki hasil tidak langsung yang terlihat, yang digunakan dalam serangan Specter dan Meltdown. <br><br>  Mengganti nama register menghabiskan banyak energi dan area chip pada prosesor modern.  Itu tidak dapat dimatikan atau konsumsi energinya berkurang, yang membuatnya tidak nyaman di era <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">silikon yang gelap</a> , ketika transistor rendah, tetapi transistor yang terlibat adalah sumber daya yang berharga.  Perangkat ini tidak ada dalam GPU, di mana konkurensi dicapai dengan menggunakan utas alih-alih mencoba paralel mengeksekusi kode sekuensial awalnya.  Jika instruksi tidak memiliki dependensi yang perlu dibangun kembali, maka tidak perlu mengganti nama register juga. <br><br>  Pertimbangkan bagian fundamental lain dari desain C: memori datar.  Itu tidak ada selama beberapa dekade.  Prosesor modern sering memiliki tiga level caching antara register dan memori utama, sehingga mengurangi waktu yang diperlukan untuk mengakses yang terakhir. <br><br>  Cache disembunyikan dari pemrogram dan oleh karena itu tidak dapat diakses dari C. Penggunaan cache yang efektif adalah salah satu cara untuk mempercepat eksekusi kode pada prosesor modern, namun itu sepenuhnya tersembunyi dari mesin abstrak dan pemrogram dipaksa untuk mengandalkan pengetahuan tentang detail implementasi cache (misalnya, bahwa keduanya selaras 64-bit). nilai dapat muncul dalam satu baris cache) untuk menulis kode yang efisien. <br><br><h2>  Optimasi C </h2><br>  Salah satu karakteristik umum yang dikaitkan dengan bahasa tingkat rendah adalah kecepatan.  Secara khusus, mereka harus mudah diterjemahkan ke dalam kode cepat tanpa kompiler yang rumit.  Argumen bahwa kompiler yang cukup pintar dapat membuat bahasa cepat sering diabaikan oleh pendukung C ketika mereka berbicara tentang bahasa lain. <br><br>  Sayangnya, menggunakan terjemahan sederhana, Anda tidak bisa mendapatkan kode cepat dari C. <br>  Arsitek prosesor melakukan upaya heroik untuk membuat chip yang dapat mengeksekusi kode C dengan cepat.  Tetapi tingkat kinerja yang diharapkan oleh pemrogram dapat dicapai hanya dengan bantuan optimasi yang sangat rumit yang dilakukan oleh kompiler. <br>  Compiler Dentang (termasuk bagian yang sesuai dari LLVM) adalah sekitar 2 juta baris kode.  Untuk analisis dan transformasi kode, yang diperlukan untuk mempercepat C, diperlukan sekitar 200.000 baris kode (tidak termasuk komentar dan baris kosong). <br><br>  Misalnya, untuk memproses sejumlah besar data dalam C, Anda perlu menulis loop yang memproses setiap elemen secara berurutan.  Untuk pelaksanaan optimal siklus ini pada prosesor modern, kompiler harus menentukan bahwa iterasi siklus tidak saling tergantung.  Batasan kata kunci dapat membantu dalam kasus ini - ini memastikan bahwa menulis ke satu pointer tidak akan mengganggu pembacaan dari pointer lain.  Informasi dalam C ini jauh lebih terbatas daripada dalam bahasa seperti Fortran, yang merupakan alasan utama bahwa C tidak dapat mendorongnya keluar dari komputasi kinerja tinggi. <br><br>  Setelah kompiler menentukan bahwa iterasi tidak tergantung satu sama lain, langkah selanjutnya adalah upaya untuk mengubah hasilnya, karena throughput prosesor modern empat hingga delapan kali lebih tinggi untuk kode vektor daripada kode skalar.  Bahasa tingkat rendah untuk prosesor semacam itu akan memiliki jenis vektor sendiri dengan panjang sewenang-wenang.  Jenis tersebut hadir dalam representasi LLVM menengah, karena selalu lebih mudah untuk membagi operasi besar dengan vektor menjadi beberapa yang kecil daripada membangun operasi vektor yang lebih besar. <br><br>  Pada titik ini, pengoptimal harus bersaing dengan aturan memori C. C memastikan bahwa struktur dengan awalan yang sama dapat digunakan secara bergantian, dan menyediakan akses ke bidang bidang offset bidang struktur dalam bahasa.  Ini berarti bahwa kompiler tidak dapat mengubah urutan bidang dalam struktur atau menambahkan perataan untuk meningkatkan vektorisasi (misalnya, mengubah struktur dari array ke array struktur atau sebaliknya).  Ini biasanya bukan masalah dalam bahasa tingkat rendah, di mana dimungkinkan untuk mengontrol lokasi bidang dalam struktur, tetapi itu membuat tugas mempercepat C. lebih sulit. <br><br>  C juga membutuhkan perataan di akhir struktur, karena memastikan bahwa tidak ada perataan dalam array.  Alignment adalah bagian yang agak rumit dari spesifikasi C, yang berinteraksi buruk dengan bagian bahasa lainnya.  Misalnya, Anda harus dapat membandingkan dua struktur menggunakan metode perbandingan tanpa tipe (yaitu, fungsi memcmp ()), sehingga salinan struktur juga harus disejajarkan.  Dalam beberapa kasus, menyalin keberpihakan membutuhkan waktu yang cukup lama. <br><br>  Pertimbangkan dua optimasi dasar yang dihasilkan oleh kompiler C: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SROA</a> (penggantian skalar agregat, penggantian skalar agregat) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembukaan loop</a> . <br><br>  SROA sedang berusaha mengganti struktur dan array ukuran tetap dengan variabel terpisah.  Ini memungkinkan kompiler untuk memproses akses kepada mereka secara independen satu sama lain dan mengabaikan operasi, jika jelas bahwa hasilnya tidak digunakan.  Dalam beberapa kasus, efek tidak langsung dari pengoptimalan ini adalah untuk menghapus perataan. <br><br>  Optimasi kedua, membuka loop, mengubah loop dengan kondisi menjadi kondisi dengan loop berbeda di kedua cabang.  Ini mengubah urutan eksekusi yang bertentangan dengan pernyataan bahwa programmer tahu apa yang akan dieksekusi dalam bahasa tingkat rendah.  Dan ini juga menciptakan masalah serius dengan bagaimana C menangani variabel tidak terdefinisi dan perilaku tidak terdefinisi. <br><br>  Dalam C, variabel yang tidak diinisialisasi memiliki nilai yang tidak ditentukan, yang dapat berbeda dengan setiap panggilan.  Ini penting karena memungkinkan Anda menerapkan daur ulang halaman memori yang malas.  Misalnya, di FreeBSD, implementasi malloc () memberi tahu sistem bahwa halaman tidak lagi digunakan, dan sistem menggunakan entri pertama di halaman sebagai bukti bahwa ini bukan masalahnya.  Banding ke memori yang baru dialokasikan dapat memperoleh nilai lama, maka sistem operasi dapat menggunakan kembali halaman memori, dan kemudian menggantinya dengan halaman yang diisi dengan nol saat berikutnya Anda menulis ke tempat lain di halaman.  Panggilan kedua ke tempat yang sama pada halaman akan mendapatkan nilai nol. <br><br>  Jika kondisi menggunakan nilai yang tidak ditentukan, maka hasilnya juga tidak ditentukan - apa pun bisa terjadi.  Bayangkan loop terbuka optimasi di mana loop dijalankan nol kali.  Dalam aslinya, seluruh loop adalah kode mati.  Dalam versi terbuka sekarang ada kondisi dengan variabel yang mungkin tidak diinisialisasi. <br>  Akibatnya, kode mati dapat dikonversi menjadi perilaku yang tidak terdefinisi.  Ini hanyalah salah satu dari banyak optimasi yang, ketika lebih teliti mengeksplorasi semantik C, tidak dapat diandalkan. <br><br>  Pada akhirnya, Anda dapat membuat kode C berjalan cepat, tetapi hanya setelah menghabiskan ribuan tahun manusia membuat kompiler yang cukup pintar.  Tetapi ini hanya mungkin jika aturan bahasa tertentu dilanggar.  Pembuat kompiler memungkinkan pemrogram C untuk membayangkan bahwa mereka menulis kode yang "dekat dengan perangkat keras", tetapi mereka harus membuat kode mesin yang berperilaku berbeda sehingga pemrogram terus percaya bahwa mereka menulis dalam bahasa cepat. <br><br><h2>  Memahami C </h2><br>  Salah satu atribut dasar dari bahasa tingkat rendah adalah bahwa pemrogram dapat dengan mudah memahami bagaimana mesin bahasa abstrak ditransfer ke mesin fisik.  Ini jelas terjadi pada PDP-11, di mana ekspresi C diterjemahkan ke dalam satu atau dua instruksi.  Demikian pula, kompiler memasukkan variabel ke dalam slot tumpukan dan mengkonversi tipe sederhana menjadi dapat dimengerti untuk PDP-11. <br><br>  Sejak itu, implementasi C menjadi jauh lebih rumit - untuk mempertahankan ilusi bahwa C mudah dipindahkan ke platform perangkat keras dan berjalan cepat.  Pada 2015, survei antara programmer C, penulis kompiler, dan anggota komite standardisasi menunjukkan bahwa ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah dalam memahami C.</a>  Misalnya, bahasa ini memungkinkan implementasi untuk menambahkan perataan ke struktur (tetapi tidak ke array) untuk memastikan bahwa semua bidang disejajarkan dengan benar untuk platform target.  Jika Anda mengisi struktur ini dengan nol dan kemudian tentukan nilai untuk beberapa bidang, apakah akan ada nol dalam bit pelurusan?  Menurut survei, 36% yakin akan melakukannya, dan 29% tidak tahu jawabannya.  Bergantung pada kompiler dan tingkat optimasi, ini mungkin benar (atau tidak). <br><br>  Ini adalah contoh yang cukup sepele, tetapi banyak programmer baik memberikan jawaban yang salah atau tidak bisa menjawab sama sekali. <br><br>  Jika Anda menambahkan pointer, semantik C menjadi semakin membingungkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model BCPL</a> cukup sederhana: semua artinya adalah kata-kata.  Setiap kata adalah data atau alamat dalam memori.  Memori adalah susunan rata sel yang diindeks berdasarkan alamat. <br><br>  Model C memungkinkan implementasi untuk platform yang berbeda, termasuk arsitektur tersegmentasi, di mana pointer dapat terdiri dari ID segmen dan offset, serta mesin virtual dengan pengumpul sampah.  Spesifikasi C membatasi operasi penunjuk yang diizinkan untuk menghindari masalah dengan sistem tersebut.  Tanggapan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan Cacat 260</a> menyebutkan asal dari pointer: <br><blockquote>  â€œImplementasi dapat mengikuti asal set bit dan menangani yang mengandung nilai yang tidak terdefinisi berbeda dari yang mengandung bit tertentu.  "Mereka dapat menangani pointer berbeda tergantung pada asalnya, bahkan jika mereka sama dalam hal nilai bit mereka." </blockquote><br>  Sayangnya, kata "asal" tidak ada dalam spesifikasi C11, sehingga kompiler memutuskan sendiri apa artinya.  GCC dan Dentang, misalnya, berbeda dalam apakah penunjuk yang dikonversi ke integer dan kembali mempertahankan asalnya.  Compiler dapat memutuskan bahwa dua pointer ke hasil malloc () selalu memberikan hasil negatif ketika membandingkan, bahkan jika mereka menunjuk ke alamat yang sama. <br><br>  Kesalahpahaman ini tidak sepenuhnya bersifat akademis.  Misalnya, kerentanan telah diamati, yang merupakan hasil meluap dari integer yang ditandatangani (perilaku tidak terdefinisi dalam C) atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mendereferensi pointer sebelum mengeceknya untuk NULL</a> , meskipun faktanya kompilator diberitahu bahwa pointer tidak boleh NULL. <br><br>  Jika ada masalah seperti itu, sulit untuk mengharapkan seorang programmer untuk sepenuhnya memahami bagaimana program C diterjemahkan ke arsitektur yang sesuai. <br><br><h2>  Memperkenalkan prosesor bukan untuk C </h2><br>  Patch yang diusulkan untuk melindungi dari Specter dan Meltdown menyebabkan degradasi kinerja yang parah, membatalkan semua pencapaian arsitektur mikro selama dekade terakhir.  Mungkin sudah waktunya untuk berhenti berpikir tentang cara membuat kode C lebih cepat, dan alih-alih memikirkan model pemrograman baru pada prosesor yang dirancang untuk kecepatan. <br><br>  Ada banyak contoh arsitektur yang belum berfokus pada kode C tradisional dan dari mana untuk mendapatkan inspirasi.  Sebagai contoh, prosesor yang berorientasi multithreading seperti Sun / Oracle UltraSPARC Tx tidak memerlukan banyak cache untuk membuat aktuator mereka sibuk.  Prosesor penelitian telah memperluas konsep ini ke sejumlah besar rangkaian perangkat keras yang direncanakan.  Gagasan utamanya adalah bahwa, dengan utas yang cukup, prosesor dapat menjeda utas yang menunggu data dan mengisi aktuator dengan instruksi dari utas lainnya.  Masalahnya adalah bahwa program C biasanya memiliki sedikit utas. <br><br>  SVE ARM (Ekstensi Skalar Vektor, ekstensi skalar vektor) adalah karya serupa lainnya dari Berkeley, yang menawarkan tampilan pada antarmuka yang ditingkatkan antara program dan perangkat keras.  Blok vektorisasi reguler mengimplementasikan operasi dengan vektor dengan ukuran tetap dan mengharapkan kompiler untuk mengadaptasi algoritma ke ukuran yang ditentukan.  Sebaliknya, antarmuka SVE meminta programmer untuk secara independen menggambarkan tingkat paralelisme dan mengharapkan perangkat keras untuk menyesuaikannya dengan aktuator yang tersedia.  Menggunakan ini dalam C sulit karena vektorizer otomatis perlu menghitung paralelisme berdasarkan loop dalam kode. <br><br>  Tembolok itu besar, tetapi ini bukan satu-satunya alasan kompleksitasnya.  Protokol dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koherensi cache</a> adalah salah satu komponen paling kompleks dari prosesor modern.  Sebagian besar kesulitan berasal dari keharusan mempertahankan bahasa di mana data dapat dibagi dan diubah.  Sebagai contoh yang berlawanan, kita dapat menggunakan mesin abstrak bergaya Erlang, di mana setiap objek bersifat lokal atau tidak berubah.  Protokol koherensi cache untuk sistem seperti itu hanya akan memiliki dua kasus: data yang dapat diubah dan data bersama.  Cache aliran program yang ditransfer ke prosesor lain harus dinonaktifkan secara eksplisit, tetapi ini adalah operasi yang relatif jarang. <br><br>  Objek yang tidak dapat diubah dapat menyederhanakan cache lebih banyak lagi, dan juga membuat beberapa operasi lebih murah.  Dalam proyek Maxwell dari Sun Labs, tercatat bahwa objek dalam cache dan objek yang baru dibuat hampir selalu sama.  Jika benda mati sebelum dikeluarkan dari cache, maka Anda tidak dapat menulisnya ke memori utama dan dengan demikian menghemat konsumsi energi.  Proyek Maxwell mengusulkan pengumpul sampah yang bekerja di cache dan memungkinkan Anda mendaur ulang memori dengan cepat.  Dengan objek yang tidak dapat diubah pada tumpukan dan tumpukan yang dapat berubah, pengumpul sampah menjadi mesin keadaan yang sangat sederhana, yang mudah diimplementasikan dalam perangkat keras dan memungkinkan Anda untuk secara efisien menggunakan cache yang relatif kecil. <br><br>  Prosesor yang dirancang hanya untuk kecepatan, dan bukan untuk pertukaran antara kecepatan dan dukungan C, mungkin harus mendukung sejumlah besar thread, memiliki blok vektorisasi besar dan model memori yang lebih sederhana.  Akan sulit untuk mengeksekusi kode C pada prosesor seperti itu, oleh karena itu, mengingat volume kode C lama di dunia, tidak mungkin untuk sukses secara komersial. <br><br>  Di bidang pengembangan perangkat lunak, ada mitos bahwa pemrograman paralel itu sulit.  Alan Kay akan sangat terkejut mendengar ini: ia mengajar anak-anak untuk menggunakan model aktor, yang dengannya mereka menulis program di lebih dari 200 aliran.  Ini juga tidak diketahui oleh programmer Erlang, yang sering menulis program dengan ribuan komponen paralel.  Lebih tepat mengatakan bahwa pemrograman paralel sulit dalam bahasa dengan mesin abstrak seperti C. Dan jika Anda memperhatikan dominasi perangkat keras paralel (dari prosesor multi-core ke GPU multi-core), maka ini hanyalah cara lain untuk mengatakan bahwa C tidak cocok untuk perangkat keras modern. menyediakan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420407/">https://habr.com/ru/post/id420407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420391/index.html">Pertengahan 2018 gaji IT</a></li>
<li><a href="../id420393/index.html">PHP, YII2 dan pembentukan file excel besar</a></li>
<li><a href="../id420395/index.html">Tablet "gratis" untuk tahanan - sama sekali tidak gratis</a></li>
<li><a href="../id420397/index.html">Para ilmuwan telah menemukan cara untuk membalikkan proses penuaan sel</a></li>
<li><a href="../id420405/index.html">Meneliti Proses Penjualan TI</a></li>
<li><a href="../id420409/index.html">Pelajari OpenGL. Pelajaran 5.7 - HDR</a></li>
<li><a href="../id420413/index.html">SQLite dan NW.js - petunjuk langkah demi langkah untuk menciptakan persahabatan yang kuat</a></li>
<li><a href="../id420415/index.html">Segala sesuatu yang ingin Anda ketahui tentang pengujian adaptor Wi-Fi, tetapi takut untuk bertanya</a></li>
<li><a href="../id420419/index.html">Pelari untuk mereka yang suka penghinaan atau bagaimana kami mengubah dan memodifikasi PixJam</a></li>
<li><a href="../id420423/index.html">Masalah antarmuka crossing darat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>