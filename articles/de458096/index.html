<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏽 👨🏾‍🎓 🥡 Was ist der MERN-Stack und wie arbeitet man damit? 👶🏼 🏺 👨‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Es war einmal ein Pilotprojekt auf dem MEAN-Stack (Mongo, Express, Angular, Node), das uns im Allgemeinen nicht enttäuschte. Wir haben ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Was ist der MERN-Stack und wie arbeitet man damit?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458096/">  Hallo Habr! <br><br>  Es war einmal ein Pilotprojekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf dem MEAN-Stack</a> (Mongo, Express, Angular, Node), das uns im Allgemeinen nicht enttäuschte. Wir haben uns jedoch entschieden, zu diesem Zeitpunkt keine zusätzlichen Drucke und Aktualisierungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorzunehmen</a> - im Gegensatz zu Manning, das dieses Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktualisiert</a> hat .  Trotzdem suchen wir weiter in diese Richtung und möchten heute mit Ihnen über den zugehörigen MERN-Stack sprechen, in dem sich React auf dem Client befindet, nicht auf Angular.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wort wird Tim Smith gegeben</a> . <br><br><img src="https://habrastorage.org/webt/1d/hf/l7/1dhfl7yw9am620o13r-nz-i4il8.jpeg"><br><a name="habracut"></a><br>  Warnung: Der gesamte Code für diesen Artikel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  In diesem MERN-Stack-Handbuch schreiben wir ein einfaches Blog mit React.js, Node.js, Express.js und MongoDB, um unser Full-Stack-Arsenal zu erweitern. <br><br><h3>  Was ist ein Stapel? </h3><br>  Vielleicht ist das erste, was zu diskutieren ist, die Idee eines "Stapels" als solchen.  Es gibt viele verschiedene Stapel, und alle sind nur verschiedene Wege, um das gleiche Ziel zu erreichen.  Beim Erstellen einer Full-Stack-Anwendung stellen wir den Client-Teil bereit, mit dem der Benutzer interagieren wird, und derselbe Client-Teil vermittelt die Arbeit mit dem Server und der Datenbank, wodurch dieser gesamte Prozess so einfach und verwaltbar wie möglich wird. <br><br>  Wir können sagen, dass der Stapel eine bestimmte Reihe von Technologien ist, die zur Lösung dieses Problems verwendet werden. <br><br>  Obwohl es viele Stapel gibt, über die es sich zu sprechen lohnt, sind einige von ihnen heute beliebter als andere.  Einer dieser beliebten Stapel heißt MEAN und besteht aus: <br><br><ul><li>  <b>M</b> ongoDb </li><li>  <b>E</b> xpress.js </li><li>  <b>A</b> ngular.js </li><li>  <b>N</b> ode.js. </li></ul><br>  Heute werden wir über den MERN-Stack sprechen, der MEAN sehr ähnlich ist, außer dass Angular.js hier durch React.js ersetzt wird.  Daher können wir MongoDB als Datenbank verwenden, Node.js bzw. Express für den Server und das Routing sowie React.js, um den Client-Teil zu erstellen, mit dem der Benutzer interagieren wird. <br><br><h3>  Wie erfolgt die Entwicklung mit diesem Stack? </h3><br>  Bevor wir zu allen Feinheiten übergehen, werfen wir einen allgemeinen Blick darauf, wie all diese Elemente zusammenarbeiten.  Persönlich habe ich eine Weile gebraucht, um mich damit zu befassen, da mein Hintergrund mit PHP zusammenhängt, wo die Client- und Serverteile etwas durcheinander sind. <br><br>  <i>1. Der Serverteil (Node und Express.js) und der Clientteil (React.js)</i> <br><br>  Zunächst müssen Sie verstehen, dass der Serverteil und der Clientteil separate Entitäten sind.  Der Client-Teil befindet sich möglicherweise im selben Repository wie der Server oder in einem völlig anderen. <br><br>  <i>2. API-Terminals werden für die Kommunikation verwendet</i> <br><br>  Wenn Sie bereits darüber nachdenken, wie Sie Freunde aus den Client- und Serverteilen gewinnen können, werde ich antworten: Dies erfolgt über die API.  Auf dem Server wird eine API (Application Program Interface) erstellt, über die wir „Terminals“ erhalten, über die die im Client-Teil befindliche Anwendung mit dem Server interagieren kann. <br><br>  Lassen Sie uns an den Fingern erklären: Stellen Sie sich vor, Ihre linke Hand ist die Serverseite und Ihre rechte Hand ist die Clientseite. <br><br>  Falten Sie nun Ihre Hände und drehen Sie Ihre Finger zusammen, als ob Sie Ihre eigene Hand schütteln würden.  So funktionieren Vorlagensprachen.  Mit ihnen können Sie einfach ein Markup zusammen mit den mit den Servern gespeicherten Daten anzeigen - und in ihnen überlappen sich die Client- und Serverkomponenten weitgehend. <br><br>  Jetzt öffne deine Hände.  Spreizen Sie Ihre Finger so weit wie möglich und achten Sie darauf, dass sich Ihre linke und rechte Hand nur mit Ihren Fingerspitzen berühren.  So funktioniert der MERN-Stack.  Der Serverteil bietet Terminals (Fingerspitzen von der linken Hand) für den Zugriff auf den Server, an den der Client Anrufe sendet (über die Fingerspitzen der rechten Hand) und über diese Kontaktpunkte Informationen mit dem Server austauscht (linke Hand). <br><br>  Ich hoffe, es ist etwas klarer geworden, und wenn nicht, vergessen Sie all diese Metapher, als hätte ich sie nicht erwähnt. <br><br><h3>  Unsere Serverseite von Node.js und Express.js </h3><br>  Obwohl ich hier keine schrittweisen Anweisungen zum Erstellen dieses Stapels geben werde (dies ist ein Thema für einen separaten Artikel), möchte ich die verschiedenen Elemente des Stapels berücksichtigen, die normalerweise verwendet werden oder darin verwendet werden können.  Ich selbst habe mehrere Handbücher gelesen, in denen erklärt wurde, wie der Server konfiguriert wird, aber nicht erklärt, warum diese speziellen Bibliotheken dafür verwendet werden. <br><br>  Nachdem wir die Datei app.js erstellt haben, müssen Sie eine Reihe von Paketen installieren.  Das Folgende sind die häufigsten Pakete, die ich zuvor in meinen Projekten mit Express.js verwendet habe - vielleicht sind sie auch für Sie nützlich. <br><br><ul><li>  <b>Express.js</b> ist ein Framework zum Erstellen von Webanwendungen.  Es verfügt über eine integrierte Funktionalität, um viele Probleme zu lösen, insbesondere um das Routing einzurichten. </li><li>  <b>Mongoose</b> ist ein Objektdatenmanager (ODM), der Interoperabilität zwischen einer express.js-Anwendung und einer MongoDB-Datenbank bietet. </li><li>  <b>BodyParser</b> ist eine Bibliothek, mit der die Anwendung express.js den <b>Text</b> (d. H. Den Inhalt) eingehender Anforderungen lesen kann. </li><li>  <b>DotENV</b> - Ermöglicht die Verwendung von Dateien mit der Erweiterung .env, um mit vertraulichen Daten zu arbeiten. </li><li>  <b>Passport.js</b> - bietet Authentifizierung in unserer Anwendung und bietet verschiedene Authentifizierungsmethoden. </li><li>  <b>Validator</b> - einfache Validierung vieler Datentypen </li><li>  <b>bCrypt</b> - Verschlüsselung sensibler Daten wie Passwörter </li><li>  <b>Nodemon</b> - "Hot Reboot" für unseren Node-Server, falls sich die Situation ändert;  Dank Nodemon können Sie den Server nach Änderungen nicht stoppen oder neu starten. </li></ul><br>  Natürlich gibt es viele andere Pakete, aber meiner Erfahrung nach werden diese Bibliotheken am häufigsten verwendet. <br><br>  Nachdem wir einige der am häufigsten verwendeten Pakete aussortiert haben, schauen wir uns den Code an.  Um loszulegen - unser Server: <br><br><img src="https://habrastorage.org/webt/xk/g7/f_/xkg7f_3zeltvgqsj-knjstppros.png"><br><br>  Dies ist ein einfacher API-Server.  Wie Sie sehen können, ist es mit der grundlegenden CRUD-Funktionalität (Create-Read-Update-Delete) ausgestattet - nichts Übernatürliches.  Bei näherer Betrachtung wird <code>res.json()</code> dass <code>res.json()</code> hier verwendet wird, um Ausgabedaten für eine bestimmte URL bereitzustellen. Das heißt, HTML oder eine andere Vorlage wird nicht für die Ausgabe verwendet.  Auf diese Weise erstellen wir unsere APIs, indem wir den Datenzugriff auf React.js öffnen. <br><br>  Möglicherweise stellen Sie auch fest, dass ich Mungo gerade auf meinen eigenen Mongodb-Server gezeigt habe, der auf meinem Computer installiert ist.  Damit ein solcher Mechanismus ordnungsgemäß funktioniert, muss MongoDB auf Ihrem Computer installiert sein und funktionieren.  Wenn es nicht funktioniert, öffnen Sie einfach das Konsolenfenster und geben Sie den folgenden Befehl ein: <br><br><img src="https://habrastorage.org/webt/yz/fr/o2/yzfro2ns9az9yqno2kc522rdnfa.png"><br><br>  Der MongoDB-Server wird auf Ihrem lokalen Computer gestartet.  Da dies alles lokal erfolgt, können Sie meine Beiträge nicht sehen, wenn Sie den Code aus dem Repository ausführen.  Wir müssen selbst neue Inhalte schreiben.  Wenn Sie einen Content-Stub benötigen, empfehle ich den hervorragenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fillerama.io-</a> Generator, der Text aus einigen meiner Lieblingsfilme und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-fernsehshows schneidet</a> . <br><br>  Wenn Sie den Server selbst testen möchten, können Sie ihn mit dem folgenden Befehl starten: <br><br><img src="https://habrastorage.org/webt/83/fr/1z/83fr1z4cgcdnjrx9up44nk5enxe.png"><br><br>  Nachdem der Server gestartet wurde und uns mitgeteilt hat, dass er auf Port 3333 funktioniert und mit MongoDB verbunden ist, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postman</a> öffnen und dort unsere Routen testen.  Bei den GET-Optionen können Sie einfach die Route einfügen und auf "Senden" klicken.  Im Falle von POST müssen Sie "Body" auswählen und die Felder für die Kopfzeile und den Hauptinhalt ausfüllen. <br><br><h3>  Client-Randnotiz </h3><br>  Nachdem wir unseren Server konfiguriert und gestartet haben, können wir mit der Arbeit an dem Client beginnen, mit dem unsere Benutzer interagieren werden.  Der Client wird in React.js geschrieben, und dies kann auf verschiedene Arten erfolgen. <br><br>  Die erste besteht darin, einfach alle für die Clientseite erforderlichen Bibliotheken ( <code>package.json</code> -Dom, <code>package.json</code> -Router usw.) derselben Datei <code>package.json</code> , in der wir die <code>package.json</code> geschrieben haben.  In diesem Projekt habe ich genau das getan, aber ich muss sagen, dass ich diese Option nicht für optimal halte.  Ich denke, dass mit dem Wachstum unseres Projekts die Codebasis immer verwirrender wird. Wenn Sie nur diese Methode verwenden, wird die Arbeit damit in Zukunft komplizierter.  Ich habe diesen Pfad in der beschriebenen Anwendung genau deshalb bevorzugt, weil ich sicher weiß: Er wird nicht wachsen und sich überhaupt nicht ändern.  Diese Anwendung wurde ausschließlich zu Demonstrationszwecken geschrieben. <br><br>  Der zweite und (meiner Meinung nach) optimalere Ansatz besteht darin, ein separates Repository für die Serverseite und ein separates für den Client zu erstellen.  Wir können das Client-Teil-Repository weiterhin problemlos mit unserem Projekt in das Verzeichnis <code>.gitignore</code> . <code>.gitignore</code> einfach sicher, dass das Client-Teil in unserer <code>.gitignore</code> Datei aufgeführt ist.  In der Dateistruktur für diese Anwendung befindet sich beispielsweise ein <code>client</code> Verzeichnis, in dem sich der gesamte Client-Teilecode befindet.  Wir könnten es in ein völlig separates Repository bringen und dann einfach den folgenden Eintrag zur <code>.gitignore</code> Datei unseres Repositorys auf der Serverseite hinzufügen: <br><br><img src="https://habrastorage.org/webt/o8/sy/h4/o8syh4xj4rxbc5te5wwk_ax_7bc.png"><br><br>  Durch Hinzufügen des <code>client</code> Ordners zur <code>.gitignore</code> Datei stellen wir <code>.gitignore</code> , dass das System diesen Ordner nicht als zweites Repository im Projekt wahrnimmt.  Darüber hinaus erleichtert dieser Ansatz das Neugestalten oder Ersetzen des Client-Teils, da der Server-Teil überhaupt nicht betroffen ist. <br><br>  Wie genau Ihre Full-Stack-Anwendung entworfen wird, liegt ganz bei Ihnen.  Mir scheint nur, dass die Struktur der Anwendung etwas genauer ist, wenn Sie separate Repositorys für die Client- und Serverteile verwalten. <br><br><h3>  Wir erstellen einen Client-Teil auf React.js </h3><br>  Nachdem wir nun die Organisation des Projekts verstanden haben, sprechen wir über den Client-Code.  Unten ist meine <code>app.js</code> Datei für eine Anwendung auf React.js. Ich werde in diesem Beitrag nicht für jede Komponente Code einfügen. Ich lasse einfach einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zum Repository und erkläre, was jede der React-Komponenten tut. <br><br>  Und so sieht der Screenshot der Hauptseite unserer Anwendung aus: <br><br><img src="https://habrastorage.org/webt/rp/j-/yz/rpj-yzfnehkwotobufkxqxf3zzi.png"><br><br>  Wie Sie sehen können, ist <code>app.js</code> absolut nichts kompliziertes.  Es gibt einen &lt;Router&gt;, mit dem Sie in React.js Routen einrichten können, die verschiedene Komponenten basierend auf ihrer URL anzeigen.  Hier sind die anderen Komponenten, die in unserer React.js-Anwendung verwendet werden: <br><br><ul><li>  <b>Kopfzeile</b> - Die Navigationsleiste am oberen Bildschirmrand </li><li>  <b>Index</b> - Listet verfügbare Blogeinträge auf </li><li>  <b>Neu</b> - Das Formular, mit dem der Benutzer einen neuen Beitrag erstellen kann </li><li>  <b>Single</b> - Zeigt einen bestimmten Blogeintrag basierend auf seiner <code>id</code> </li><li>  <b>Bearbeiten</b> - Das Formular, über das der Benutzer den nach <code>id</code> gefundenen Blogeintrag aktualisieren kann </li></ul><br>  Wir verwenden Axios, um http-Aufrufe an die API-Terminals durchzuführen, und verwenden dann React.js, um die Daten nach Belieben anzuzeigen.  In diesem Beitrag werde ich Index.js Code geben, um klarer zu machen, wie alles zusammenarbeitet. <br><br><img src="https://habrastorage.org/webt/9j/dp/wo/9jdpwo-gh8ifomloyx0cibju1mi.png"><br><br>  Im obigen Code ist eine Klassenkomponente enthalten, mit der wir Status- und Lebenszyklusmethoden verwenden können.  Dies ist erforderlich, da Axios-Aufrufe in der Lebenszyklusmethode <code>componentDidMount()</code> werden müssen.  Es ist zu beachten, dass beim Versuch, meine lokale API aufzurufen, ein CORS-Fehler aufgetreten ist.  Um dieses Problem zu lösen, habe ich der Datei server.js auf meinem Express-Server mehrere Header hinzugefügt - und es hat funktioniert.  Dieser Code wird in den Kommentaren zur Datei server.js vermerkt. <br><br>  <i>Stellen wir sicher, dass Such-Bots unsere React.js-App normal lesen.</i> <br><br>  Abschließend möchte ich kurz auf das Rendern eingehen.  Wenn Sie unsere Website starten und direkt zu einem Blog-Beitrag gehen, kann es zu Problemen bei der Anzeige von Inhalten kommen.  In diesem Fall ist das Durchsuchen der Website nicht nur für Benutzer unpraktisch, sondern auch für die Suche nach Robotern, die Inhalte indizieren.  Um dieses Problem zu umgehen, empfehle ich die Verwendung von Tools wie Gatsby js oder Next js.  Diese beiden Lösungen unterscheiden sich voneinander, aber beide können nützlich sein, je nachdem, was genau Sie benötigen. <br><br>  Gatsby js ist ein statischer Site-Generator.  Sie können eine Site auf React.js schreiben, und dann wandelt Gatsby sie während des Builds in statische Dateien um, wodurch die Site superschnell wird.  Gatsby enthält viele nützliche Plugins, die das Tool nahezu universell machen.  Meine Seite wurde übrigens mit Gatsby.js erstellt!  Da statische Dateien während der Montage erstellt werden, muss die Site immer dann neu erstellt werden, wenn sich der ursprüngliche Inhalt ändert. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Next.js</a> ist wiederum eine Serverkomponente zum Anzeigen von React.js-Sites.  Darin sind viele nützliche Funktionen integriert, insbesondere Routing, Code-Aufteilung, entworfene Komponenten und vieles mehr.  Server-Rendering bedeutet, dass die Daten automatisch aktualisiert werden, wie dies auf dem Server erfolgt. Bevor sie jedoch im Browserfenster angezeigt werden, findet die Rendering-Phase statt.  Aus diesem Grund sollte es keine Probleme mit der Anzeige von Daten für den Benutzer geben, und auch Suchroboter erledigen ihre Arbeit ohne Probleme. <br><br>  Es gibt viele andere Lösungen dieser Art, aber ich habe am meisten über diese beiden gehört, und als ich an diesem Projekt arbeitete, habe ich sie verwendet.  Beide sind hervorragend dokumentiert, so dass es einfach ist, schnell mit beiden umzugehen und zur Sache zu kommen. <br><br><h3>  Letzte Gedanken zum MERN-Stack </h3><br>  Hoffentlich hat Ihnen dieser Artikel dabei geholfen, die Funktionsweise des MERN-Stacks etwas genauer zu bestimmen.  Darin nehmen wir einfach MongoDB, Express.js und Node.js und erstellen daraus einen Server, der bereits API-Terminals bereitstellt, über die unsere React.js-Anwendung auf Daten zugreifen kann.  Jetzt verstehst du viel, es ist Zeit, großartige Dinge zu tun! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458096/">https://habr.com/ru/post/de458096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458084/index.html">50 ausgewählte Materialien über das Einkommen von Musikern, Sound in Spielen und Filmen, ungewöhnliche Instrumente und das vergessene Alte</a></li>
<li><a href="../de458088/index.html">Beste Linux-Distributionen für ältere Computer</a></li>
<li><a href="../de458090/index.html">Was ist wirklich mit der verschwundenen malaysischen Boeing passiert (Teil 2/3)</a></li>
<li><a href="../de458092/index.html">Auf dem Weg zum Python-Kern</a></li>
<li><a href="../de458094/index.html">„Intelligente“ Videoüberwachung: Wie wird das Leben unter Kameras mit künstlicher Intelligenz aussehen?</a></li>
<li><a href="../de458098/index.html">Fallstricke der DSGVO</a></li>
<li><a href="../de458100/index.html">Python in Visual Studio Code - Veröffentlichung im Juni 2019</a></li>
<li><a href="../de458102/index.html">Effektiver Webentwicklungs-Workflow: Konfluenz, Airtable und mehr</a></li>
<li><a href="../de458104/index.html">RDMA im Rechenzentrum bei der Implementierung von Huawei</a></li>
<li><a href="../de458106/index.html">Tauchen Sie in Jetpack Compose</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>