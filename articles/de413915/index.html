<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèª ü§ú üçï Tower Defense zu einem Einheitsspiel machen - Teil 2 üë©üèΩ‚Äçüè≠ üñêÔ∏è üë®‚Äçüë©‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil des Tutorials ‚ÄûErstellen eines Tower Defense-Spiels in Unity‚Äú . Wir entwickeln in Unity ein Tower Defense-Genre-Spiel und am ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tower Defense zu einem Einheitsspiel machen - Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413915/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png" alt="Bild"></div><br>  Dies ist der zweite Teil des Tutorials <i>‚ÄûErstellen eines Tower Defense-Spiels in Unity‚Äú</i> .  Wir entwickeln in Unity ein Tower Defense-Genre-Spiel und am Ende des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teils</a> haben wir gelernt, wie man Monster platziert und verbessert.  Wir haben auch einen Feind, der Cookies angreift. <br><br>  Der Feind wei√ü jedoch noch nicht, wo er suchen soll!  Au√üerdem sieht ein Angriff allein seltsam aus.  In diesem Teil des Tutorials werden wir Wellen von Feinden und Armmonstern hinzuf√ºgen, damit diese einen wertvollen Keks verteidigen k√∂nnen. <br><a name="habracut"></a><br><h2>  An die Arbeit gehen </h2><br>  √ñffnen Sie das Projekt in Unity, das wir im letzten Teil gestoppt haben.  Wenn Sie gerade zu uns gekommen sind, laden Sie den <a href="">Projektentwurf</a> herunter und √∂ffnen Sie <em>TowerDefense-Part2-Starter</em> . <br><br>  √ñffne <em>GameScene</em> aus dem Ordner " <em>Szenen</em> ". <br><br><h2>  Wende Feinde ab </h2><br>  Am Ende des vorherigen Tutorials lernte der Feind, sich auf der Stra√üe zu bewegen, aber es scheint, dass er keine Ahnung hat, wo er suchen soll. <br><br>  √ñffnen Sie das Skript <em>MoveEnemy.cs</em> in der IDE und f√ºgen Sie die folgende Methode hinzu, um die Situation zu beheben. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateIntoMoveDirection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 Vector3 newStartPosition = waypoints [currentWaypoint].transform.position; Vector3 newEndPosition = waypoints [currentWaypoint + 1].transform.position; Vector3 newDirection = (newEndPosition - newStartPosition); //2 float x = newDirection.x; float y = newDirection.y; float rotationAngle = Mathf.Atan2 (y, x) * 180 / Mathf.PI; //3 GameObject sprite = gameObject.transform.Find("Sprite").gameObject; sprite.transform.rotation = Quaternion.AngleAxis(rotationAngle, Vector3.forward); }</span></span></code> </pre> <br>  <code>RotateIntoMoveDirection</code> dreht den Feind so, dass er immer <code>RotateIntoMoveDirection</code> vorne <code>RotateIntoMoveDirection</code> .  Er macht es wie folgt: <br><br><ol><li>  Berechnet die aktuelle Richtung des Fehlers, indem die Position des aktuellen Wegpunkts von der Position des n√§chsten Punkts abgezogen wird. </li><li>  Verwendet <code>Mathf.Atan2</code> , um den Winkel im Bogenma√ü zu bestimmen, in den <code>Mathf.Atan2</code> gerichtet ist (der Nullpunkt befindet sich rechts).  Multipliziert das Ergebnis mit <code>180 / Mathf.PI</code> und konvertiert den Winkel in Grad. </li><li>  Schlie√ülich erh√§lt es das <em>Sprite-</em> Kind und dreht die Achse um Winkelwinkel.  Beachten Sie, dass wir das <i>Kind</i> und nicht das Elternteil drehen, damit der Energiestreifen, den wir sp√§ter hinzuf√ºgen, horizontal bleibt. </li></ol><br>  Ersetzen Sie in <code>Update()</code> den Kommentar <code>// TODO:    </code> n√§chsten Aufruf von <code>RotateIntoMoveDirection</code> : <br><br><pre> <code class="cs hljs">RotateIntoMoveDirection();</code> </pre> <br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  F√ºhren Sie die Szene aus;  Jetzt wei√ü der Feind, wohin er sich bewegt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73d/7f4/9e5/73d7f49e5fec3785e2ac3376c3774f27.gif"></div><br>  Jetzt wei√ü der Fehler, wohin es geht. <br><br>  Der einzige Feind sieht nicht sehr beeindruckend aus.  Wir brauchen Horden!  Und wie in jedem Tower Defense-Spiel laufen Horden in Wellen! <br><br><h2>  Spieler informieren </h2><br>  Bevor wir anfangen, die Horden zu bewegen, m√ºssen wir den Spieler vor dem bevorstehenden Kampf warnen.  Au√üerdem lohnt es sich, die aktuelle Wellenzahl oben auf dem Bildschirm anzuzeigen. <br><br>  <em>Wave-</em> Informationen werden von mehreren GameObjects ben√∂tigt, daher werden sie der <em>GameManagerBehavior-</em> Komponente des <em>GameManager hinzugef√ºgt</em> . <br><br>  √ñffnen Sie die <em>GameManagerBehavior.cs</em> in der IDE und f√ºgen Sie die folgenden zwei Variablen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text waveLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] nextWaveLabels;</code> </pre> <br>  <code>waveLabel</code> speichert einen Link zum Wellenzahl-Ausgabeetikett in der oberen rechten Ecke des Bildschirms.  <code>nextWaveLabels</code> speichert zwei GameObjects, die eine Kombination von Animationen erstellen, die wir zu Beginn einer neuen Welle zeigen werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7c/650/8f0/e7c6508f018c4382e490a4f6bee31e1f.gif"></div><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  W√§hlen Sie <em>GameManager</em> in der <em>Hierarchie</em> .  Klicken Sie auf den Kreis rechts neben der <em>Wellenbeschriftung</em> und w√§hlen <em>Sie</em> im Dialogfeld <em>Text</em> ausw√§hlen <em>auf</em> der Registerkarte <em>Szene</em> die <em>Option Wellenbeschriftung</em> aus. <br><br>  Stellen Sie nun die <em>Gr√∂√üe</em> f√ºr die <em>Beschriftungen der n√§chsten Welle</em> auf <em>2 ein</em> .  Setzen Sie nun <em>Element 0</em> auf <em>NextWaveBottomLabel</em> , und f√ºr <em>Element 1 ist</em> <em>NextWaveTopLabel</em> dasselbe wie bei Wave Label. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/725/1f8/d197251f821c7262c638df487fb752cd.png"></div><br>  <i>So sollte das Verhalten von Game Managern jetzt aussehen</i> <br><br>  Wenn der Spieler verliert, sollte er keine Nachricht √ºber die n√§chste Welle sehen.  Um diese Situation zu bew√§ltigen, kehren Sie zu <em>GameManagerBehavior.cs zur√ºck</em> und f√ºgen Sie eine weitere Variable hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> gameOver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  In <code>gameOver</code> speichern wir den Wert, ob der Spieler verloren hat. <br><br>  Hier verwenden wir wieder die Eigenschaft, um die Elemente des Spiels mit der aktuellen Welle zu synchronisieren.  F√ºgen Sie <code>GameManagerBehavior</code> den folgenden Code <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> wave; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Wave { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wave; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { wave = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!gameOver) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nextWaveLabels.Length; i++) { nextWaveLabels[i].GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string"><span class="hljs-string">"nextWave"</span></span>); } } waveLabel.text = <span class="hljs-string"><span class="hljs-string">"WAVE: "</span></span> + (wave + <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br>  Das Erstellen einer privaten Variablen, einer Eigenschaft und eines Getters sollte Ihnen bereits vertraut sein.  Aber mit dem Setter ist wieder alles etwas interessanter. <br><br>  Wir weisen <code>wave</code> neuen <code>value</code> . <br><br>  Dann pr√ºfen wir, ob das Spiel beendet ist.  Wenn nicht, durchlaufen Sie alle <em>nextWaveLabels-</em> Labels - diese Labels haben eine <em>Animator-</em> Komponente.  Um die <em>Animator-</em> Animation zu aktivieren, <em>definieren</em> wir einen <em>nextWave-</em> Trigger. <br><br>  Schlie√ülich setzen wir den <code>text</code> von <code>waveLabel</code> auf <code>wave + 1</code> .  Warum <code>+1</code> ?  Normale Leute z√§hlen nicht von vorne (ja, das ist seltsam). <br><br>  In <code>Start()</code> den Wert dieser Eigenschaft: <br><br><pre> <code class="cs hljs">Wave = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Wir beginnen die Z√§hlung mit der Nummer <em>0</em> <code>Wave</code> . <br><br>  Speichern Sie die Datei und f√ºhren Sie die Szene in Unity aus.  Das Wave-Label zeigt 1 korrekt an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0d/edf/546/b0dedf546c1b6ad9b0d0b91c5021212d.png"></div><br>  <i>F√ºr einen Spieler beginnt alles mit Welle 1.</i> <br><br><h2>  Wellen: Erschaffe Haufen von Feinden </h2><br>  Es mag offensichtlich erscheinen, aber um mit einer Horde anzugreifen, m√ºssen mehr Feinde geschaffen werden - obwohl wir nicht wissen, wie das geht.  Au√üerdem sollten wir die n√§chste Welle erst erzeugen, wenn die aktuelle zerst√∂rt ist. <br><br>  Das hei√üt, das Spiel sollte in der Lage sein, die Anwesenheit von Feinden in der Szene zu erkennen, und <em>Tags</em> sind eine gute M√∂glichkeit, Spielobjekte hier zu identifizieren. <br><br><h3>  Feindliche Markierung </h3><br>  W√§hlen Sie im Projektbrowser das <em>Enemy-</em> Fertighaus aus.  Klicken Sie oben im <em>Inspektor</em> auf die Dropdown-Liste <em>Tag</em> und w√§hlen <em>Sie Tag hinzuf√ºgen</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be0/7ea/b29/be07eab29a25c69751add67ce4faa283.png"></div><br>  Erstellen Sie ein <em>Tag</em> namens <em>Enemy</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/c66/d02/df1c66d02e0c29a7a6ec0b615dbbd2fc.png"></div><br>  W√§hlen Sie den vorgefertigten <em>Feind</em> .  Legen Sie im <em>Inspektor</em> <em>das</em> <em>Enemy-</em> <em>Tag</em> daf√ºr fest. <br><br><h3>  Wellen von Feinden definieren </h3><br>  Jetzt m√ºssen wir die Welle der Feinde einstellen.  √ñffnen Sie <em>SpawnEnemy.cs</em> in der IDE und f√ºgen Sie vor <code>SpawnEnemy</code> die folgende Klassenimplementierung <code>SpawnEnemy</code> : <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">System.Serializable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wave</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject enemyPrefab; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnInterval = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxEnemies = <span class="hljs-number"><span class="hljs-number">20</span></span>; }</code> </pre> <br>  <em>Wave</em> enth√§lt <code>enemyPrefab</code> - die Basis zum Erstellen von Instanzen aller Feinde in dieser Welle, <code>spawnInterval</code> - Zeit zwischen Feinden in der Welle in Sekunden und <code>maxEnemies</code> - die Anzahl der in dieser Welle erstellten Feinde. <br><br>  Die Klasse ist <em>serialisierbar</em> , <em>dh</em> wir k√∂nnen ihre Werte im Inspektor √§ndern. <br><br>  F√ºgen Sie der <code>SpawnEnemy</code> Klasse die folgenden Variablen <code>SpawnEnemy</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Wave[] waves; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> timeBetweenWaves = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastSpawnTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemiesSpawned = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Hier legen wir die Variablen f√ºr das Laichen von Feinden fest, was sehr √§hnlich ist, wie wir Feinde zwischen Punkten auf der Route bewegt haben. <br><br>  Wir setzen die Wellen einzelner Feinde in <code>waves</code> und verfolgen die Anzahl der erstellten Feinde und die Zeit, zu der sie in den <code>enemiesSpawned</code> und <code>lastSpawnTime</code> . <br><br>  Nach all diesen Kills brauchen die Spieler Zeit zum Atmen, also setzen Sie <code>timeBetweenWaves</code> auf 5 Sekunden. <br><br>  Ersetzen Sie den Inhalt von <code>Start()</code> folgenden Code. <br><br><pre> <code class="cs hljs">lastSpawnTime = Time.time; gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br>  Hier weisen wir <code>lastSpawnTime</code> Wert der aktuellen Zeit zu, <code>lastSpawnTime</code> Zeit, zu der das Skript nach dem Laden der Szene gestartet wurde.  Dann bekommen wir das bereits bekannte <code>GameManagerBehavior</code> . <br><br>  F√ºgen Sie <code>Update()</code> den folgenden Code hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 int currentWave = gameManager.Wave; if (currentWave &lt; waves.Length) { // 2 float timeInterval = Time.time - lastSpawnTime; float spawnInterval = waves[currentWave].spawnInterval; if (((enemiesSpawned == 0 &amp;&amp; timeInterval &gt; timeBetweenWaves) || timeInterval &gt; spawnInterval) &amp;&amp; enemiesSpawned &lt; waves[currentWave].maxEnemies) { // 3 lastSpawnTime = Time.time; GameObject newEnemy = (GameObject) Instantiate(waves[currentWave].enemyPrefab); newEnemy.GetComponent&lt;MoveEnemy&gt;().waypoints = waypoints; enemiesSpawned++; } // 4 if (enemiesSpawned == waves[currentWave].maxEnemies &amp;&amp; GameObject.FindGameObjectWithTag("Enemy") == null) { gameManager.Wave++; gameManager.Gold = Mathf.RoundToInt(gameManager.Gold * 1.1f); enemiesSpawned = 0; lastSpawnTime = Time.time; } // 5 } else { gameManager.gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag ("GameWon"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); }</span></span></code> </pre> <br>  Lassen Sie es uns Schritt f√ºr Schritt analysieren: <br><br><ol><li>  Wir erhalten den Index der aktuellen Welle und pr√ºfen, ob es die letzte ist. </li><li>  Wenn ja, berechnen wir die Zeit, die nach dem vorherigen Spawn des Feindes vergangen ist, und pr√ºfen, ob es Zeit ist, einen Feind zu erschaffen.  Hier ber√ºcksichtigen wir zwei F√§lle.  Wenn dies der erste Feind in der Welle ist, pr√ºfen wir, ob <code>timeInterval</code> als <code>timeBetweenWaves</code> .  Andernfalls pr√ºfen wir, ob <code>timeInterval</code> als <code>spawnInterval</code> Wellen ist.  In jedem Fall √ºberpr√ºfen wir, ob wir nicht alle Feinde in dieser Welle erschaffen haben. </li><li>  Wenn n√∂tig, <code>enemyPrefab</code> den Feind und erstelle eine Instanz von <code>enemyPrefab</code> .  Erh√∂hen Sie auch den Wert von <code>enemiesSpawned</code> . </li><li>  √úberpr√ºfen Sie die Anzahl der Feinde auf dem Bildschirm.  Wenn sie nicht da sind und dies der letzte Feind in der Welle war, dann erschaffen wir die n√§chste Welle.  Ebenfalls am Ende der Welle geben wir dem Spieler 10 Prozent des gesamten verbleibenden Goldes. </li><li>  Nach dem Sieg √ºber die letzte Welle wird hier eine Animation des Sieges im Spiel abgespielt. </li></ol><br><h3>  Spawn-Intervalle einstellen </h3><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck.  W√§hlen Sie das Stra√üenobjekt in der <em>Hierarchie aus</em> .  Setzen Sie im <em>Inspektor</em> die <em>Gr√∂√üe</em> des <em>Waves-</em> Objekts auf <em>4</em> . <br><br>  W√§hlen Sie zun√§chst ein <em>Enemy-</em> Objekt f√ºr alle vier Elemente als <em>Enemy Prefab aus</em> .  Konfigurieren Sie die Felder <em>Spawn Interval</em> und <em>Max Enemies</em> wie folgt: <br><br><ul><li>  <em>Element 0</em> : Spawn-Intervall: <em>2,5</em> , Max. Gegner: <em>5</em> </li><li>  <em>Element 1</em> : Spawn-Intervall: <em>2</em> , Max. Gegner: <em>10</em> </li><li>  <em>Element 2</em> : Spawn-Intervall: <em>2</em> , Max. Gegner: <em>15</em> </li><li>  <em>Element 3</em> : Spawn-Intervall: <em>1</em> , Max. Gegner: <em>5</em> </li></ul><br>  Das fertige Schema sollte folgenderma√üen aussehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff7/0fa/954/ff70fa95476112b51dfb83505f9a785b.png"></div><br>  Nat√ºrlich k√∂nnen Sie mit diesen Werten experimentieren, um die Komplexit√§t zu erh√∂hen oder zu verringern. <br><br>  Starte das Spiel.  Ja!  K√§fer haben die Reise zu Ihrem Keks begonnen! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/097/4d3/a7f0974d36a188b5575a3e70a8488a4a.gif" alt="Fehler"></div><br><h3>  Zus√§tzliche Aufgabe: F√ºge verschiedene Arten von Feinden hinzu </h3><br>  Kein Turmverteidigungsspiel kann als vollst√§ndig mit nur einem Feindtyp betrachtet werden.  Gl√ºcklicherweise gibt es auch <em>Enemy2</em> im <em>Prefabs-</em> Ordner. <br><br>  <em>W√§hlen Sie</em> im <em>Inspektor</em> <em>Prefabs \ Enemy2 aus</em> und f√ºgen Sie das <em>MoveEnemy-</em> Skript hinzu.  Stellen Sie die <em>Geschwindigkeit</em> auf <em>3</em> und <em>das</em> <em>Enemy-</em> <em>Tag ein</em> .  Jetzt k√∂nnen Sie diesen schnellen Feind verwenden, damit sich der Spieler nicht entspannt! <br><br><h2>  Player Life Update </h2><br>  Obwohl Horden von Feinden den Cookie angreifen, erleidet der Spieler keinen Schaden.  Aber bald werden wir es beheben.  Der Spieler muss leiden, wenn er dem Feind erlaubt, sich anzuschleichen. <br><br>  √ñffnen Sie die <em>GameManagerBehavior.cs</em> in der IDE und f√ºgen Sie die folgenden zwei Variablen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text healthLabel; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject[] healthIndicator;</code> </pre> <br>  Wir verwenden <code>healthLabel</code> um auf den Lebenswert des Spielers zuzugreifen, und <code>healthIndicator</code> um auf die f√ºnf kleinen gr√ºnen Monster zuzugreifen, die Kekse kauen - sie symbolisieren einfach die Gesundheit des Spielers.  Es ist lustiger als ein Standard-Gesundheitsindikator. <br><br><h3>  Gesundheitsmanagement </h3><br>  <code>GameManagerBehavior</code> nun eine Eigenschaft hinzu, die die Gesundheit des Spielers in <code>GameManagerBehavior</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> health; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> health; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if (value &lt; health) { Camera.main.GetComponent&lt;CameraShake&gt;().Shake(); } // 2 health = value; healthLabel.text = "HEALTH: " + health; // 3 if (health &lt;= 0 &amp;&amp; !gameOver) { gameOver = true; GameObject gameOverText = GameObject.FindGameObjectWithTag("GameOver"); gameOverText.GetComponent&lt;Animator&gt;().SetBool("gameOver", true); } // 4 for (int i = 0; i &lt; healthIndicator.Length; i++) { if (i &lt; Health) { healthIndicator[i].SetActive(true); } else { healthIndicator[i].SetActive(false); } } } }</span></span></code> </pre> <br>  So verwalten wir die Gesundheit des Spielers.  Und wieder befindet sich der Hauptteil des Codes im Setter: <br><br><ol><li>  Wenn wir die Gesundheit des Spielers verringern, verwenden wir die <code>CameraShake</code> Komponente, um einen sch√∂nen Sch√ºtteleffekt zu erzielen.  Dieses Skript ist im herunterladbaren Projekt enthalten und wird hier nicht ber√ºcksichtigt. </li><li>  Wir aktualisieren die private Variable und das Health-Label in der oberen linken Ecke des Bildschirms. </li><li>  Wenn der Gesundheitszustand auf 0 gesunken ist und das Ende des Spiels noch nicht erreicht ist, <code>gameOver</code> auf <code>true</code> und starten Sie die <code>gameOver</code> Animation. </li><li>  Wir entfernen eines der Monster aus den Keksen.  Wenn wir sie nur ausschalten, kann dieser Teil einfacher geschrieben werden, aber hier unterst√ºtzen wir die Wiedereingliederung, falls die Gesundheit hinzugef√ºgt wird. </li></ol><br>  Wir initialisieren <code>Health</code> in <code>Start()</code> : <br><br><pre> <code class="cs hljs">Health = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br>  Wir setzen <code>Health</code> auf <code>5</code> wenn die Szene abgespielt wird. <br><br>  Nachdem wir dies alles getan haben, k√∂nnen wir jetzt den Zustand des Players aktualisieren, wenn der Fehler im Cookie auftritt.  Speichern Sie die Datei und <em>wechseln</em> Sie zur IDE zum Skript <em>MoveEnemy.cs</em> . <br><br><h3>  Gesundheitsver√§nderung </h3><br>  Um Ihre Gesundheit zu √§ndern, suchen Sie den Kommentar in <code>Update()</code> mit den Worten <code>// TODO:  </code> und durch diesen Code ersetzen: <br><br><pre> <code class="cs hljs">GameManagerBehavior gameManager = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>).GetComponent&lt;GameManagerBehavior&gt;(); gameManager.Health -= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Also bekommen wir das <code>GameManagerBehavior</code> und subtrahieren die Einheit von ihrer <code>Health</code> . <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck. <br><br>  W√§hlen Sie einen <em>GameManager</em> in der <em>Hierarchie aus</em> und w√§hlen Sie <em>HealthLabel</em> als <em>Health Label aus</em> . <br><br>  Erweitern Sie das <em>Cookie-</em> Objekt in der <em>Hierarchie</em> und ziehen Sie die f√ºnf <em>untergeordneten</em> <em>HealthIndicators</em> in das <em>Health Indicator-</em> Array des <em>GameManager. Die Health-Indikatoren</em> sind kleine gr√ºne Monster, die Cookies essen. <br><br>  F√ºhren Sie die Szene aus und warten Sie, bis die Fehler den Cookie erreichen.  Tu nichts, bis du verlierst. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d8/f4a/ea4/8d8f4aea4cec500c3894d233f402b7ba.gif" alt="Cookie Angriff"></div><br><h2>  Monster Rache </h2><br>  Monster an Ort und Stelle?  Ja  Angreifen Feinde?  Ja, und sie sehen bedrohlich aus!  Es ist Zeit, diese Tiere zu beantworten! <br><br>  Dazu ben√∂tigen wir Folgendes: <br><br><ul><li>  Spur der Gesundheit, damit der Spieler wei√ü, welche Feinde stark und welche schwach sind </li><li>  Feinde in Reichweite eines Monsters erkennen </li><li>  Eine Entscheidung treffen - auf welchen Feind geschossen werden soll </li><li>  Ein paar Muscheln </li></ul><br><h3>  Feindliche Gesundheitsleiste </h3><br>  Um das Gesundheitsband zu implementieren, verwenden wir zwei Bilder - eines f√ºr den dunklen Hintergrund und das zweite (der gr√ºne Balken ist etwas kleiner) skalieren wir entsprechend der Gesundheit des Feindes. <br><br>  Ziehen Sie vom <em>Projektbrowser</em> in die Szene <em>Prefabs \ Enemy</em> . <br><br>  Ziehen Sie dann in der <em>Hierarchie</em> <em>Images \ Objects \ HealthBarBackground</em> auf <em>Enemy</em> , um es als <em>untergeordnetes</em> <em>Element</em> hinzuzuf√ºgen. <br><br>  Setzen Sie im <em>Inspektor</em> die <em>Position des</em> <em>HealthBarBackground</em> auf <em>(0, 1, -4)</em> . <br><br>  W√§hlen Sie dann im <em>Projektbrowser</em> <em>Images \ Objects \ HealthBar aus</em> und stellen Sie sicher, dass der <em>Pivot</em> <em>links ist</em> .  <em>F√ºgen</em> Sie es dann als <em>untergeordnetes Element</em> des <em>Feindes</em> in die <em>Hierarchie ein</em> und setzen Sie seinen <em>Positionswert</em> <em>(-0,63, 1, -5)</em> .  Setzen Sie f√ºr <em>X</em> <em>Scale</em> den Wert auf <em>125</em> . <br><br>  F√ºgen Sie <em>dem HealthBar</em> -Spielobjekt ein neues <em>C #</em> <em>-Skript mit dem Namen HealthBar hinzu</em> .  Sp√§ter werden wir es so √§ndern, dass es die L√§nge des Gesundheitsbalkens √§ndert. <br><br>  Stellen Sie nach Auswahl eines <em>feindlichen</em> Objekts in der <em>Hierarchie</em> sicher, dass seine Position <em>(20, 0, 0) ist</em> . <br><br>  Klicken <em>Sie</em> oben im <em>Inspektor</em> auf √úbernehmen, um alle √Ñnderungen als Teil des Fertighauses zu speichern.  L√∂schen Sie abschlie√üend das <em>Enemy-</em> Objekt in der <em>Hierarchie</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e7/b84/7d2/9e7b847d22d2fda1e146dbf9149f912e.png"></div><br>  Wiederholen Sie nun alle diese Schritte, um eine <em>Integrit√§tsleiste</em> f√ºr <em>Prefabs \ Enemy2 hinzuzuf√ºgen</em> . <br><br><h3>  √Ñndern Sie die L√§nge der Gesundheitsleiste </h3><br>  √ñffnen Sie die IDE <em>HealthBar.cs</em> und f√ºgen Sie die folgenden Variablen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> currentHealth = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> originalScale;</code> </pre> <br>  In <code>maxHealth</code> die maximale Gesundheit des Feindes gespeichert und in <code>currentHealth</code> die verbleibende Gesundheit.  Schlie√ülich ist in <code>originalScale</code> die anf√§ngliche Gr√∂√üe der Integrit√§tsleiste. <br><br>  Speichern Sie das <code>originalScale</code> Objekt in <code>Start()</code> : <br><br><pre> <code class="cs hljs">originalScale = gameObject.transform.localScale.x;</code> </pre> <br>  Wir speichern den <code>x</code> Wert der <code>localScale</code> Eigenschaft. <br><br>  Legen Sie die Skalierung der Integrit√§tsleiste fest, indem Sie <code>Update()</code> den folgenden Code hinzuf√ºgen: <br><br><pre> <code class="cs hljs">Vector3 tmpScale = gameObject.transform.localScale; tmpScale.x = currentHealth / maxHealth * originalScale; gameObject.transform.localScale = tmpScale;</code> </pre> <br>  Wir k√∂nnen <code>localScale</code> in eine tempor√§re Variable kopieren, da wir ihren <i>x-</i> Wert nicht separat √§ndern k√∂nnen.  Dann berechnen wir die neue <i>x-</i> Skala basierend auf dem aktuellen <code>localScale</code> des K√§fers und weisen den Wert <code>localScale</code> erneut einer tempor√§ren Variablen zu. <br><br>  Speichern Sie die Datei und starten Sie das Spiel in Unity.  √úber Feinden sehen Sie Gesundheitsstreifen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd4/78a/29c/dd478a29c258b63dc809ca16de4ee16a.png"></div><br>  Erweitern Sie w√§hrend des Spiels eines der <em>Enemy (Clone)</em> -Objekte in der <em>Hierarchie</em> und w√§hlen Sie die <em>untergeordnete HealthBar aus</em> .  √Ñndern Sie den <em>aktuellen Gesundheitswert</em> und sehen Sie, wie sich der Gesundheitsbalken √§ndert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ee/af7/22c/5eeaf722c2e6a6ee1d2799380cdcfead.gif"></div><br><h3>  Erkennung von Feinden in Reichweite </h3><br>  Jetzt m√ºssen unsere Monster herausfinden, auf welche Feinde sie zielen sollen.  Aber bevor Sie diese Gelegenheit nutzen, m√ºssen Sie Monster und Feind vorbereiten. <br><br>  W√§hlen Sie Project Browser <em>Prefabs \ Monster</em> und f√ºgen Sie im <em>Inspector</em> die <em>Circle Collider 2D-</em> Komponente hinzu. <br><br>  Setze den <em>Radius-</em> Parameter des Colliders auf <em>2,5</em> - dies zeigt den Angriffsradius der Monster an. <br><br>  Aktivieren Sie das Kontrollk√§stchen <em>Ist Ausl√∂ser</em> , damit Objekte diesen Bereich passieren, anstatt mit ihm zu kollidieren. <br><br>  <em>Stellen Sie schlie√ülich</em> oben im <em>Inspektor</em> die <em>Ebene</em> des Monsters so ein, dass <em>Raycast ignoriert wird</em> .  Klicken Sie im Dialogfeld auf <em>Ja,</em> untergeordnete <em>Elemente √§ndern</em> .  Wenn Raycast ignorieren nicht ausgew√§hlt ist, reagiert der Collider auf Mausklickereignisse.  Dies wird ein Problem sein, da Monster Ereignisse blockieren, die f√ºr Openspot-Objekte unter ihnen bestimmt sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/302/cf2/e3e302cf21adee1433fe2183120c2ba1.png"></div><br>  Um sicherzustellen, dass der Feind im Triggerbereich erkannt wird, m√ºssen wir einen Collider und einen starren K√∂rper hinzuf√ºgen, da Unity nur dann Triggerereignisse sendet, wenn ein starrer K√∂rper an einem der Collider befestigt ist. <br><br>  <em>W√§hlen Sie</em> im <em>Projektbrowser</em> <em>Prefabs \ Enemy aus</em> .  F√ºgen Sie die <em>Rigidbody 2D-</em> Komponente hinzu und w√§hlen Sie <em>Kinematik</em> f√ºr <em>K√∂rpertyp</em> .  Dies bedeutet, dass der K√∂rper nicht von der Physik beeinflusst wird. <br><br>  F√ºgen Sie <em>Circle Collider 2D</em> mit einem <em>Radius</em> von <em>1 hinzu</em> .  Wiederholen Sie diese Schritte f√ºr <em>Prefabs \ Enemy 2</em> . <br><br>  Die Ausl√∂ser sind so konfiguriert, dass Monster verstehen, dass sich Feinde innerhalb ihres Aktionsradius befinden. <br><br>  Wir m√ºssen noch eines vorbereiten: ein Skript, das Monstern sagt, wenn der Feind zerst√∂rt wird, damit sie keine Ausnahme ausl√∂sen, w√§hrend sie weiter schie√üen. <br><br>  Erstellen Sie ein neues <em>C #</em> <em>-Skript</em> mit dem Namen <em>EnemyDestructionDelegate</em> und f√ºgen Sie es den <em>Prefabs</em> <em>Enemy</em> und <em>Enemy2 hinzu</em> . <br><br>  √ñffnen Sie <em>EnemyDestructionDelegate.cs</em> in der IDE und f√ºgen Sie die folgende Delegierungsdeklaration hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnemyDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject enemy</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyDelegate enemyDelegate;</code> </pre> <br>  Hier erstellen wir einen <code>delegate</code> , dh einen Container f√ºr eine Funktion, die als Variable √ºbergeben werden kann. <br><br><blockquote>  <em>Hinweis</em> : Delegaten werden verwendet, wenn ein Spielobjekt andere Spielobjekte aktiv √ºber √Ñnderungen informieren muss.  Weitere Informationen zu Delegierten finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="aus der Unity-Dokumentation">Unity-Dokumentation</a> . </blockquote><br>  F√ºgen Sie die folgende Methode hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDestroy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enemyDelegate != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { enemyDelegate(gameObject); } }</code> </pre> <br>  Wenn ein Spielobjekt zerst√∂rt wird, ruft Unity diese Methode automatisch auf und √ºberpr√ºft den Delegaten auf <code>null</code> .  In unserem Fall rufen wir es mit <code>gameObject</code> als Parameter auf.  Auf diese Weise k√∂nnen alle als Delegierte registrierten Befragten wissen, dass der Feind zerst√∂rt wurde. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck. <br><br><h3>  Wir geben Monstern eine Lizenz zum T√∂ten </h3><br>  Und jetzt k√∂nnen Monster Feinde im Radius ihrer Aktion erkennen.  F√ºgen Sie dem <em>Monster-</em> Fertighaus ein neues <em>C #</em> -Skript hinzu und nennen Sie es <em>ShootEnemies</em> . <br><br>  √ñffnen Sie <em>ShootEnemies.cs</em> in der IDE und f√ºgen Sie <code>using</code> Konstrukts Folgendes hinzu <code>using</code> um auf <code>Generics</code> zuzugreifen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;</code> </pre> <br>  F√ºgen Sie eine Variable hinzu, um alle Feinde in Reichweite zu verfolgen: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;GameObject&gt; enemiesInRange;</code> </pre> <br>  In <code>enemiesInRange</code> speichern wir alle Feinde in Reichweite. <br><br>  Initialisieren Sie das Feld in <code>Start()</code> . <br><br><pre> <code class="cs hljs">enemiesInRange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameObject&gt;();</code> </pre> <br>  Ganz am Anfang befinden sich keine Feinde im Aktionsradius, daher erstellen wir eine leere Liste. <br><br>  <code>enemiesInRange</code> die Liste der <code>enemiesInRange</code> !  F√ºgen Sie dem Skript den folgenden Code hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 void OnEnemyDestroy(GameObject enemy) { enemiesInRange.Remove (enemy); } void OnTriggerEnter2D (Collider2D other) { // 2 if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Add(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate += OnEnemyDestroy; } } // 3 void OnTriggerExit2D (Collider2D other) { if (other.gameObject.tag.Equals("Enemy")) { enemiesInRange.Remove(other.gameObject); EnemyDestructionDelegate del = other.gameObject.GetComponent&lt;EnemyDestructionDelegate&gt;(); del.enemyDelegate -= OnEnemyDestroy; } }</span></span></code> </pre> <br><ol><li>  In <code>OnEnemyDestroy</code> entfernen wir den Feind aus feindlicher <code>enemiesInRange</code> .  Wenn ein Feind auf einen Abzug um ein Monster tritt, wird <code>OnTriggerEnter2D</code> . </li><li>  Dann f√ºgen wir den Feind zur <code>enemiesInRange</code> Liste hinzu und f√ºgen das <code>EnemyDestructionDelegate</code> Ereignis <code>OnEnemyDestroy</code> .  Wir garantieren also, dass bei Zerst√∂rung des Feindes <code>OnEnemyDestroy</code> aufgerufen wird.  Wir wollen nicht, dass Monster Munition f√ºr tote Feinde ausgeben, oder? </li><li>  In <code>OnTriggerExit2D</code> entfernen wir den Feind von der Liste und <code>OnTriggerExit2D</code> die Registrierung des Delegaten auf.  Jetzt wissen wir, welche Feinde sich in Reichweite befinden. </li></ol><br>  Speichern Sie die Datei und starten Sie das Spiel in Unity.  Um sicherzustellen, dass alles funktioniert, positioniere das Monster, w√§hle es aus und folge den √Ñnderungen in der <code>enemiesInRange</code> Rangliste im <code>enemiesInRange</code> . <br><br><h3>  Zielauswahl </h3><br>  Monster wissen jetzt, welcher Feind sich in Reichweite befindet.  Aber was werden sie tun, wenn sich mehrere Feinde im Radius befinden? <br><br>  Nat√ºrlich werden sie denjenigen angreifen, der der Leber am n√§chsten liegt! <br><br>  √ñffne das IDE-Skript <em>MoveEnemy.cs</em> und f√ºge eine neue Methode hinzu, mit der dieses Monster berechnet wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceToGoal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; distance += Vector2.Distance( gameObject.transform.position, waypoints [currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = currentWaypoint + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; waypoints.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { Vector3 startPosition = waypoints [i].transform.position; Vector3 endPosition = waypoints [i + <span class="hljs-number"><span class="hljs-number">1</span></span>].transform.position; distance += Vector2.Distance(startPosition, endPosition); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance; }</code> </pre> <br>  Der Code berechnet die Wegl√§nge, die der Feind noch nicht zur√ºckgelegt hat.  Dazu wird <code>Distance</code> , die als Abstand zwischen zwei Instanzen von <code>Vector3</code> . <br><br>  Wir werden diese Methode sp√§ter verwenden, um herauszufinden, welches Ziel angegriffen werden soll.  Obwohl unsere Monster nicht bewaffnet und hilflos sind, werden wir es zuerst tun. <br><br>  Speichern Sie die Datei und kehren Sie zu Unity zur√ºck, um mit dem Einrichten Ihrer Shells zu beginnen. <br><br><h3>  Geben wir den Monstern Muscheln.  Viele Muscheln! </h3><br>  Ziehen Sie aus dem Projektbrowser in die <em>Szene Images / Objects / Bullet1</em> .  Setzen Sie die Position auf <em>z</em> auf <em>-2</em> - die Positionen auf x und y sind nicht wichtig, da wir sie jedes Mal setzen, wenn wir w√§hrend der Programmausf√ºhrung eine neue Instanz des Projektils erstellen. <br><br>  F√ºgen Sie ein neues <em>C #</em> <em>-Skript mit dem</em> Namen <em>BulletBehavior hinzu</em> und f√ºgen Sie dann in der IDE die folgenden Variablen hinzu: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> damage; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject target; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 startPosition; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 targetPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> startTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameManagerBehavior gameManager;</code> </pre> <br>  <code>speed</code> bestimmt die Geschwindigkeit der Projektile;  Die <code>damage</code> aus dem Namen. <br><br>  <code>target</code> , <code>startPosition</code> und <code>targetPosition</code> bestimmen die Richtung des Projektils. <br><br>  <code>distance</code> und <code>startTime</code> verfolgen die aktuelle Position des Projektils.  <code>gameManager</code> belohnt den Spieler, wenn er den Feind t√∂tet. <br><br>  Weisen Sie die Werte dieser Variablen in <code>Start()</code> : <br><br><pre> <code class="cs hljs">startTime = Time.time; distance = Vector2.Distance (startPosition, targetPosition); GameObject gm = GameObject.Find(<span class="hljs-string"><span class="hljs-string">"GameManager"</span></span>); gameManager = gm.GetComponent&lt;GameManagerBehavior&gt;();</code> </pre> <br> <code>startTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir stellen den Wert der aktuellen Zeit ein und berechnen den Abstand zwischen Start- und Zielposition. </font><font style="vertical-align: inherit;">Auch bekommen wir wie immer </font></font><code>GameManagerBehavior</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie den </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Code </font><font style="vertical-align: inherit;">hinzu, um die Bewegung des Projektils zu steuern </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 float timeInterval = Time.time - startTime; gameObject.transform.position = Vector3.Lerp(startPosition, targetPosition, timeInterval * speed / distance); // 2 if (gameObject.transform.position.Equals(targetPosition)) { if (target != null) { // 3 Transform healthBarTransform = target.transform.Find("HealthBar"); HealthBar healthBar = healthBarTransform.gameObject.GetComponent&lt;HealthBar&gt;(); healthBar.currentHealth -= Mathf.Max(damage, 0); // 4 if (healthBar.currentHealth &lt;= 0) { Destroy(target); AudioSource audioSource = target.GetComponent&lt;AudioSource&gt;(); AudioSource.PlayClipAtPoint(audioSource.clip, transform.position); gameManager.Gold += 50; } } Destroy(gameObject); }</span></span></code> </pre> <br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen die neue Position des Projektils unter Verwendung der </font></font><code>Vector3.Lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolation zwischen der Start- und Endposition.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Projektil erreicht </font></font><code>targetPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pr√ºfen wir, ob es noch vorhanden ist </font></font><code>target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten die Komponente des </font></font><code>HealthBar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ziels und reduzieren seine Gesundheit um die Gr√∂√üe des </font></font><code>damage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projektils.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn die Gesundheit des Feindes auf Null reduziert wird, zerst√∂ren wir sie, reproduzieren den Soundeffekt und belohnen den Spieler f√ºr seine Genauigkeit. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speichern Sie die Datei und kehren Sie zu Unity zur√ºck. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir machen gro√üe Muscheln </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§re es nicht gro√üartig, wenn das Monster mehr Granaten auf hohem Niveau abschie√üen w√ºrde? Gl√ºcklicherweise ist dies einfach zu implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ziehen Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Spielobjekt </font><font style="vertical-align: inherit;">aus der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hierarchie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf die Registerkarte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um ein Projektil-Fertighaus zu erstellen. Entfernen Sie das Originalobjekt aus der Szene - wir werden es nicht mehr ben√∂tigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duplizieren Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighaus </font><em><font style="vertical-align: inherit;">zweimal</font></em><font style="vertical-align: inherit;"> . </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nennen </font></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Kopien von </font><em><font style="vertical-align: inherit;">Bullet2</font></em><font style="vertical-align: inherit;"> und </font><em><font style="vertical-align: inherit;">Bullet3</font></em><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Setzen Sie </font><font style="vertical-align: inherit;">im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspektor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feld der </font><em><font style="vertical-align: inherit;">Sprite- </font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderer-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komponente </font><font style="vertical-align: inherit;">auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images / Objects / Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Also werden wir Bullet2 etwas mehr als Bullet1 machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie den Vorgang, um das Sprite des Bullet3- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertighauses</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Images / Objects / Bullet3 zu √§ndern</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiter im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet Behaviour werden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir die H√∂he des durch Granaten verursachten Schadens anpassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie das </font><font style="vertical-align: inherit;">vorgefertigte </font><em><font style="vertical-align: inherit;">Bullet1</font></em><font style="vertical-align: inherit;"> auf der Registerkarte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt aus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Der </font><em><font style="vertical-align: inherit;">Inspektor</font></em><font style="vertical-align: inherit;"> Sie sehen </font><em><font style="vertical-align: inherit;">Einschuss Verhalten (Script)</font></em><font style="vertical-align: inherit;"> , die zugeordnet werden </font><font style="vertical-align: inherit;">k√∂nnen </font><em><font style="vertical-align: inherit;">Damage</font></em><font style="vertical-align: inherit;"> Wert </font><em><font style="vertical-align: inherit;">10</font></em><font style="vertical-align: inherit;"> f√ºr </font><em><font style="vertical-align: inherit;">Bullet1</font></em><font style="vertical-align: inherit;"> , </font><em><font style="vertical-align: inherit;">15</font></em><font style="vertical-align: inherit;"> f√ºr </font><em><font style="vertical-align: inherit;">Bullet2</font></em><font style="vertical-align: inherit;"> und </font><em><font style="vertical-align: inherit;">20</font></em><font style="vertical-align: inherit;"> f√ºr </font><em><font style="vertical-align: inherit;">Bullet3</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - oder andere Werte, die Sie m√∂gen. </font></font><br><br><blockquote> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ich habe die Werte so ge√§ndert, dass bei h√∂heren Werten der Schadenspreis h√∂her wird. </font><font style="vertical-align: inherit;">Dies verhindert, dass der Spieler durch das Upgrade Monster an den besten Punkten aktualisieren kann.</font></font></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0a/e2d/da2/c0ae2dda288d44bc380864dd1e85f3b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fertige Muscheln - Gr√∂√üe nimmt mit dem Level zu</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñndern der Muschelstufe </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weisen Sie verschiedenen Monsterstufen unterschiedliche Granaten zu, damit st√§rkere Monster Feinde schneller zerst√∂ren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MonsterData.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der IDE </font><font style="vertical-align: inherit;">und f√ºgen Sie die </font></font><code>MonsterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Variablen hinzu:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject bullet; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fireRate;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir das Fertighaus des Projektils und die H√§ufigkeit des Feuers f√ºr jede Stufe von Monstern festgelegt. </font><font style="vertical-align: inherit;">Speichern Sie die Datei und kehren Sie zu Unity zur√ºck, um das Monster-Setup abzuschlie√üen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monster-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fertighaus im Projektbrowser aus </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspektor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erweitert </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der </font><font style="vertical-align: inherit;">Komponente </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monster Daten (Script)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Stellen Sie die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feuerrate</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Gegenstands auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 ein</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Setzen Sie dann den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parameter </font><font style="vertical-align: inherit;">von Element 0, 1 und 2 auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bullet3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monsterlevel sollten wie folgt eingestellt werden:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c0/7d0/fd9/8c07d0fd96492f9e0e6c6e1737791c11.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Granaten t√∂ten Feinde? </font></font> Ja!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lass uns das Feuer er√∂ffnen! </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Offenes Feuer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ñffnen Sie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShootEnemies.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der IDE </font><font style="vertical-align: inherit;">und f√ºgen Sie die folgenden Variablen hinzu:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lastShotTime; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MonsterData monsterData;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie der Name schon sagt, verfolgen diese Variablen die Zeit des letzten Monsterschusses sowie die Struktur </font></font><code>MonsterData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Informationen √ºber die Art der Monsterschalen, die H√§ufigkeit des Feuers usw. enth√§lt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legen Sie die Werte dieser Felder fest in </font></font><code>Start()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cs hljs">lastShotTime = Time.time; monsterData = gameObject.GetComponentInChildren&lt;MonsterData&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier weisen wir den </font></font><code>lastShotTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert der aktuellen Zeit zu und erhalten Zugriff auf die Komponente </font></font><code>MonsterData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Objekts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie die folgende Methode hinzu, um die Aufnahme zu implementieren:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider2D target</span></span></span><span class="hljs-function">)</span></span> { GameObject bulletPrefab = monsterData.CurrentLevel.bullet; <span class="hljs-comment"><span class="hljs-comment">// 1 Vector3 startPosition = gameObject.transform.position; Vector3 targetPosition = target.transform.position; startPosition.z = bulletPrefab.transform.position.z; targetPosition.z = bulletPrefab.transform.position.z; // 2 GameObject newBullet = (GameObject)Instantiate (bulletPrefab); newBullet.transform.position = startPosition; BulletBehavior bulletComp = newBullet.GetComponent&lt;BulletBehavior&gt;(); bulletComp.target = target.gameObject; bulletComp.startPosition = startPosition; bulletComp.targetPosition = targetPosition; // 3 Animator animator = monsterData.CurrentLevel.visualization.GetComponent&lt;Animator&gt;(); animator.SetTrigger("fireShot"); AudioSource audioSource = gameObject.GetComponent&lt;AudioSource&gt;(); audioSource.PlayOneShot(audioSource.clip); }</span></span></code> </pre> <br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten die Start- und Zielpositionen der Kugel. </font><font style="vertical-align: inherit;">Stellen Sie die Position z gleich z ein </font></font><code>bulletPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zuvor haben wir die Fertighausposition des Projektils in z so eingestellt, dass das Projektil unter dem schie√üenden Monster, aber √ºber den Feinden erscheint.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erstellen eine Instanz einer neuen Shell mit der </font></font><code>bulletPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entsprechenden </font></font><code>MonsterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Zuweisen </font></font><code>startPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>targetPosition</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projektil.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir machen das Spiel interessanter: Wenn das Monster schie√üt, starten Sie die Animation des Schie√üens und spielen Sie den Klang des Lasers. </font></font></li></ol><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alles zusammenf√ºgen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist Zeit, alles zusammenzusetzen. </font><font style="vertical-align: inherit;">Definiere das Ziel und lass das Monster es betrachten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c5/934/9a7/3c59349a719669c9508c38f155bf25dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Skript </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShootEnemies.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºgen Sie </font><font style="vertical-align: inherit;">den </font></font><code>Update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folgenden Code:</font></font><br><br><pre> <code class="cs hljs">GameObject target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 float minimalEnemyDistance = float.MaxValue; foreach (GameObject enemy in enemiesInRange) { float distanceToGoal = enemy.GetComponent&lt;MoveEnemy&gt;().DistanceToGoal(); if (distanceToGoal &lt; minimalEnemyDistance) { target = enemy; minimalEnemyDistance = distanceToGoal; } } // 2 if (target != null) { if (Time.time - lastShotTime &gt; monsterData.CurrentLevel.fireRate) { Shoot(target.GetComponent&lt;Collider2D&gt;()); lastShotTime = Time.time; } // 3 Vector3 direction = gameObject.transform.position - target.transform.position; gameObject.transform.rotation = Quaternion.AngleAxis( Mathf.Atan2 (direction.y, direction.x) * 180 / Mathf.PI, new Vector3 (0, 0, 1)); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrachten Sie diesen Code Schritt f√ºr Schritt. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bestimmen Sie den Zweck des Monsters. </font><font style="vertical-align: inherit;">Wir beginnen mit der maximal m√∂glichen Entfernung in </font></font><code>minimalEnemyDistance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir gehen in einem Zyklus aller Feinde in Reichweite umher und machen den Feind zu einem neuen Ziel, wenn seine Entfernung zum Cookie geringer ist als die derzeit kleinste.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir rufen an, </font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die verstrichene Zeit gr√∂√üer als die Schussfrequenz des Monsters ist, und stellen den </font></font><code>lastShotTime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert der aktuellen Zeit ein.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berechnen den Drehwinkel zwischen dem Monster und seinem Ziel. </font><font style="vertical-align: inherit;">Wir drehen das Monster in diesen Winkel. </font><font style="vertical-align: inherit;">Jetzt wird er immer auf das Ziel schauen.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie die Datei und starten Sie das Spiel in Unity. </font><font style="vertical-align: inherit;">Monster werden verzweifelt anfangen, Cookies zu sch√ºtzen. </font><font style="vertical-align: inherit;">Wir sind endlich fertig!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wohin als n√§chstes gehen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das fertige Projekt kann hier heruntergeladen </font></font><a href="" title="hier"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben in diesem Tutorial gro√üartige Arbeit geleistet und jetzt haben wir ein gro√üartiges Spiel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier einige Ideen f√ºr die Weiterentwicklung des Projekts:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Weitere Arten von Feinden und Monstern </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Wege der Feinde </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Spielstufen </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder dieser Aspekte erfordert nur minimale √Ñnderungen und kann das Spiel unterhaltsamer machen. </font><font style="vertical-align: inherit;">Wenn Sie ein neues Spiel basierend auf diesem Tutorial erstellen, werde ich es gerne spielen. Bitte teilen Sie einen Link dazu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interessante Gedanken zur Erstellung eines Tower Defense-Hit-Spiels finden Sie in diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" title="Ein Hit Tower Defense-Spiel machen: Ein Top-App-Entwickler-Interview"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interview</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413915/">https://habr.com/ru/post/de413915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413901/index.html">Steuerung des selbstausgleichenden EduMip-Roboters mit dem PS4 Dualshock 4 Joystick √ºber ROS</a></li>
<li><a href="../de413903/index.html">Wie Cambridge Analytica Klicks in Stimmen verwandelt</a></li>
<li><a href="../de413907/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 256 (4. Juni - 12. Juni)</a></li>
<li><a href="../de413909/index.html">Dort sind deine Kindheitserinnerungen geblieben</a></li>
<li><a href="../de413913/index.html">Bekanntschaft mit den Ausstellungen von Audio- und Videoger√§ten: kurz √ºber die gr√∂√üten Ereignisse - Teil eins</a></li>
<li><a href="../de413917/index.html">Inhaber von Urheberrechten glauben, dass Yandex zum Wachstum der Piraterie im Land beitr√§gt</a></li>
<li><a href="../de413921/index.html">So sparen Sie das Projekt vor zus√§tzlichen Pfunden</a></li>
<li><a href="../de413923/index.html">Vielleicht kann die Atmosph√§re noch von Kohlendioxid gereinigt werden</a></li>
<li><a href="../de413925/index.html">CVT f√ºr Moskvich</a></li>
<li><a href="../de413927/index.html">Digispark on Attiny85 - Verbindung unter Windows 10 herstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>