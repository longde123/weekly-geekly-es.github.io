<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèΩ ‚òÅÔ∏è üèß Programa√ß√£o din√¢mica ou dividir e conquistar üèõÔ∏è üëèüèº üëßüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo discute as semelhan√ßas e diferen√ßas entre as duas abordagens para resolver problemas algor√≠tmicos: programa√ß√£o din√¢mica (programa√ß√£o din√¢m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o din√¢mica ou dividir e conquistar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423939/"> Este artigo discute as semelhan√ßas e diferen√ßas entre as duas abordagens para resolver problemas algor√≠tmicos: <b>programa√ß√£o</b> din√¢mica (programa√ß√£o din√¢mica) e o princ√≠pio de <b>‚Äúdividir e conquistar‚Äù</b> (dividir e conquistar).  Vamos comparar usando dois algoritmos como exemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesquisa bin√°ria</a> (como encontrar rapidamente um n√∫mero em uma matriz classificada) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dist√¢ncia de Levenshtein</a> (como converter uma linha em outra com um n√∫mero m√≠nimo de opera√ß√µes). <br><br>  <i>Quero observar imediatamente que essa compara√ß√£o e explica√ß√£o n√£o afirmam ser extremamente corretas.</i>  <i>E talvez at√© alguns professores universit√°rios gostariam de me expulsar :) Este artigo √© apenas minha tentativa pessoal de resolver as coisas e entender o que √© programa√ß√£o din√¢mica e como o princ√≠pio de ‚Äúdividir e conquistar‚Äù est√° envolvido.</i> <br><br>  Ent√£o, vamos come√ßar ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/863/582/ca28635824478a8aa8e81bd43c78338e.png" alt="imagem"><br><a name="habracut"></a><br><h3>  O problema </h3><br>  Quando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comecei a estudar algoritmos,</a> era dif√≠cil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para</a> mim entender a id√©ia b√°sica da programa√ß√£o din√¢mica (doravante <b>DP</b> , da Programa√ß√£o Din√¢mica) e como ela difere da abordagem de ‚Äúdividir e conquistar‚Äù ( <b>DC</b> adicional, de dividir e conquistar).  Quando se trata de comparar esses dois paradigmas, geralmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">muitos usam com sucesso a fun√ß√£o Fibonacci</a> para ilustrar.  E esta √© uma √≥tima ilustra√ß√£o.  Mas parece-me que, quando usamos <b>a mesma</b> tarefa para ilustrar DP e DC, perdemos um detalhe importante que pode nos ajudar a perceber a diferen√ßa entre as duas abordagens mais rapidamente.  E esse detalhe √© que essas duas t√©cnicas se manifestam melhor na solu√ß√£o de <b>diferentes</b> tipos de problemas. <br><br>  Ainda estou aprendendo DP e DC e n√£o posso dizer que entendi completamente esses conceitos.  Mas ainda espero que este artigo lance mais luz e ajude a dar o pr√≥ximo passo no estudo de abordagens significativas, como programa√ß√£o din√¢mica e divis√£o e conquista. <br><br><h3>  Semelhan√ßas entre DP e DC </h3><br>  Da maneira como vejo esses dois conceitos agora, posso concluir que o <b>DP √© uma vers√£o estendida do DC</b> . <br><br>  Eu <b>n√£o os</b> consideraria algo completamente diferente.  Como esses dois conceitos <b>dividem recursivamente um problema em dois ou mais subproblemas do mesmo tipo</b> at√© que esses subproblemas sejam f√°ceis o suficiente para serem resolvidos diretamente.  Al√©m disso, todas as solu√ß√µes para o subproblema s√£o combinadas para, finalmente, dar uma resposta ao problema original. <br><br>  Ent√£o, por que ainda temos duas abordagens diferentes (DP e DC) e por que chamei a programa√ß√£o din√¢mica de extens√£o.  Isso ocorre porque a programa√ß√£o din√¢mica pode ser aplicada a tarefas que possuem certas <b>caracter√≠sticas e limita√ß√µes</b> .  E somente neste caso o DP expande a CD por meio de duas t√©cnicas: <b>memoriza√ß√£o</b> e <b>tabula√ß√£o</b> . <br><br>  Vamos nos aprofundar um pouco mais nos detalhes ... <br><br><h3>  Limita√ß√µes e caracter√≠sticas necess√°rias para programa√ß√£o din√¢mica </h3><br>  Como acabamos de descobrir, existem duas caracter√≠sticas principais que uma tarefa / problema deve ter para tentar resolv√™-lo usando a programa√ß√£o din√¢mica: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Subestrutura ideal</a> - deve ser poss√≠vel compor uma solu√ß√£o ideal para um problema, de uma solu√ß√£o ideal para suas subtarefas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intersec√ß√£o de subproblemas</a> - o problema deve ser dividido em subproblemas, que por sua vez s√£o reutilizados repetidamente.  Em outras palavras, uma abordagem recursiva para resolver o problema implicaria uma solu√ß√£o m√∫ltipla (e <b>n√£o</b> √∫nica) para o mesmo subproblema, em vez de produzir subproblemas novos e exclusivos em cada ciclo recursivo. </li></ol><br>  Assim que encontrarmos essas duas caracter√≠sticas no problema que estamos considerando, podemos dizer que ele pode ser resolvido usando programa√ß√£o din√¢mica. <br><br><h3>  Programa√ß√£o din√¢mica como uma extens√£o do princ√≠pio de "dividir e conquistar" </h3><br>  O DP estende o CD com a ajuda de duas t√©cnicas ( <b>memoriza√ß√£o</b> e <b>tabula√ß√£o</b> ), cujo objetivo √© salvar solu√ß√µes em subproblemas para sua reutiliza√ß√£o futura.  Assim, as solu√ß√µes s√£o armazenadas em cache por subproblemas, o que leva a uma melhoria significativa no desempenho do algoritmo.  Por exemplo, a complexidade de tempo de uma implementa√ß√£o recursiva "ing√™nua" da fun√ß√£o Fibonacci √© <code>O(2 <sup>n</sup> )</code> .  Ao mesmo tempo, uma solu√ß√£o baseada em programa√ß√£o din√¢mica √© executada em apenas <code>(n)</code> . <br><br>  <b>A memoriza√ß√£o (preenchendo o cache de cima para baixo)</b> √© uma t√©cnica de armazenamento em cache que utiliza solu√ß√µes rec√©m-computadas para subtarefas.  A fun√ß√£o Fibonacci usando a t√©cnica de memoriza√ß√£o ficaria assim: <br><br><pre> <code class="javascript hljs">memFib(n) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mem[n] is <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) result = n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = memFib(n<span class="hljs-number"><span class="hljs-number">-2</span></span>) + memFib(n<span class="hljs-number"><span class="hljs-number">-1</span></span>) mem[n] = result <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre> <br>  <b>A tabula√ß√£o (preenchendo o cache de baixo para cima)</b> √© uma t√©cnica semelhante, mas que se concentra principalmente no preenchimento do cache, e n√£o em encontrar uma solu√ß√£o para o subproblema.  O c√°lculo dos valores que precisam ser armazenados em cache √©, neste caso, mais f√°cil de ser executado iterativamente, em vez de recursivamente.  A fun√ß√£o Fibonacci usando a t√©cnica de tabula√ß√£o ficaria assim: <br><br><pre> <code class="javascript hljs">tabFib(n) { mem[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> mem[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2.</span></span>..n mem[i] = mem[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] + mem[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mem[n] }</code> </pre><br>  Voc√™ pode ler mais sobre a compara√ß√£o de memoriza√ß√£o e tabula√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A id√©ia principal que precisa ser capturada nesses exemplos √© que, como nossos problemas de CD t√™m subproblemas sobrepostos, podemos usar o cache de solu√ß√µes para subproblemas usando uma das duas t√©cnicas de armazenamento em cache: memoriza√ß√£o e tabula√ß√£o. <br><br><h3>  Ent√£o, qual √© a diferen√ßa entre DP e DC no final </h3><br>  Aprendemos sobre as limita√ß√µes e pr√©-requisitos para o uso de programa√ß√£o din√¢mica, bem como as t√©cnicas de armazenamento em cache usadas na abordagem de DP.  Vamos tentar resumir e descrever os pensamentos acima na ilustra√ß√£o a seguir: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f1/8e4/8a1/8f18e48a15bcdbe1e3541540c8a76274.png" alt="imagem"><br><br>  Vamos tentar resolver alguns problemas usando DP e DC para demonstrar essas duas abordagens em a√ß√£o. <br><br><h3>  Exemplo de divis√£o e conquista: Pesquisa bin√°ria </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O</a> algoritmo de pesquisa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bin√°ria</a> √© um algoritmo de pesquisa que localiza a posi√ß√£o do elemento solicitado em uma matriz classificada.  Na pesquisa bin√°ria, comparamos o valor da vari√°vel com o valor do elemento no meio da matriz.  Se eles n√£o forem iguais, ent√£o metade da matriz na qual o elemento desejado n√£o pode ser exclu√≠do de pesquisas adicionais.  A pesquisa continua nessa metade da matriz, na qual a vari√°vel desejada pode ser localizada at√© ser encontrada.  Se a pr√≥xima metade da matriz n√£o contiver elementos, a pesquisa ser√° considerada completa e conclu√≠mos que a matriz n√£o cont√©m o valor desejado. <br><br>  <b>Exemplo</b> <br><br>  A ilustra√ß√£o abaixo √© um exemplo de uma pesquisa bin√°ria para o n√∫mero 4 em uma matriz. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3f/845/628/a3f8456289058a7401640fdf368e7c44.png" alt="imagem"><br><br>  Vamos retratar a mesma l√≥gica de pesquisa, mas na forma de uma "√°rvore de decis√£o". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/79d/904/a9f79d904494ff947b2d730de4e9fbba.png" alt="imagem"><br><br>  Voc√™ pode ver neste diagrama um princ√≠pio claro de "dividir e conquistar", usado para resolver esse problema.  Iterativamente, dividimos nossa matriz original em sub-matrizes e tentamos encontrar o elemento que estamos procurando. <br><br>  Podemos resolver esse problema usando programa√ß√£o din√¢mica?  <b>N√£o.</b>  Pelo motivo que esta tarefa <b>n√£o cont√©m subproblemas que se cruzam</b> .  Cada vez que dividimos uma matriz em partes, ambas s√£o completamente independentes e n√£o se sobrep√µem.  E de acordo com as suposi√ß√µes e limita√ß√µes da programa√ß√£o din√¢mica que discutimos acima, os subproblemas devem se sobrepor de alguma forma, <b>devem ser repetitivos</b> . <br><br>  Geralmente, sempre que uma √°rvore de decis√£o se parece exatamente com uma <b>√°rvore</b> (e <b>n√£o como um gr√°fico</b> ), isso provavelmente significa que n√£o h√° subproblemas sobrepostos, <br><br>  <b>Implementa√ß√£o de algoritmo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> voc√™ pode encontrar o c√≥digo fonte completo do algoritmo de busca bin√°ria com testes e explica√ß√µes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binarySearch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sortedArray, seekElement</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> endIndex = sortedArray.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (startIndex &lt;= endIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleIndex = startIndex + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor((endIndex - startIndex) / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If we've found the element just return its position. if (sortedArray[middleIndex] === seekElement)) { return middleIndex; } // Decide which half to choose: left or right one. if (sortedArray[middleIndex] &lt; seekElement)) { // Go to the right half of the array. startIndex = middleIndex + 1; } else { // Go to the left half of the array. endIndex = middleIndex - 1; } } return -1; }</span></span></code> </pre><br><h3>  Exemplo de programa√ß√£o din√¢mica: dist√¢ncia de edi√ß√£o </h3><br>  Geralmente, quando se trata de explicar a programa√ß√£o din√¢mica, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a fun√ß√£o Fibonacci √©</a> usada como exemplo.  Mas, no nosso caso, vamos dar um exemplo um pouco mais complexo.  Quanto mais exemplos, mais f√°cil √© entender o conceito. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A dist√¢ncia de edi√ß√£o</a> (ou a dist√¢ncia de Levenshtein) entre duas linhas √© o n√∫mero m√≠nimo de opera√ß√µes para inserir um caractere, excluir um caractere e substituir um caractere por outro, necess√°rio para transformar uma linha em outra. <br><br>  <b>Exemplo</b> <br><br>  Por exemplo, a dist√¢ncia de edi√ß√£o entre as palavras "gatinho" e "sentado" √© 3, porque voc√™ precisa executar tr√™s opera√ß√µes de edi√ß√£o (duas substitui√ß√µes e uma inser√ß√£o) para converter uma linha em outra.  E √© imposs√≠vel encontrar uma op√ß√£o de convers√£o mais r√°pida com menos opera√ß√µes: <br><br><ol><li>  gatinho ‚Üí gatinho (substituindo "k" por "s") </li><li>  sitten ‚Üí sittin (substituindo "e" por "i") </li><li>  sentado ‚Üí sentado (insira ‚Äúg‚Äù completamente). </li></ol><br>  <b>Aplica√ß√£o de algoritmo</b> <br><br>  O algoritmo possui uma ampla gama de aplica√ß√µes, por exemplo, para verifica√ß√£o ortogr√°fica, sistemas de corre√ß√£o de reconhecimento √≥ptico, pesquisa imprecisa de cadeias, etc. <br><br>  <b>Defini√ß√£o matem√°tica de um problema</b> <br><br>  Matematicamente, a dist√¢ncia de Levenstein entre duas linhas <code>a, b</code> (com comprimentos | a | e <code>|b|</code> respectivamente) √© determinada pela <code>function lev(|a|, |b|)</code> , em que: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/242/84e/2f424284e297eab78f308d35eb27ed94.png" alt="imagem"><br><br>  Observe que a primeira linha na fun√ß√£o <code>min</code> corresponde √† opera√ß√£o de <b>exclus√£o</b> , a segunda linha corresponde √† opera√ß√£o de <b>inser√ß√£o</b> e a terceira linha corresponde √† opera√ß√£o de <b>substitui√ß√£o</b> (caso as letras n√£o sejam iguais). <br><br>  <b>Explica√ß√£o</b> <br><br>  Vamos tentar descobrir o que essa f√≥rmula nos diz.  Veja um exemplo simples de como encontrar a dist√¢ncia m√≠nima de edi√ß√£o entre as linhas <b>ME</b> e <b>MY</b> .  Intuitivamente, voc√™ j√° sabe que a dist√¢ncia m√≠nima de edi√ß√£o √© uma ( <b>1</b> ) opera√ß√£o de substitui√ß√£o (substitua "E" por "Y").  Mas vamos formalizar nossa solu√ß√£o e transform√°-la em uma forma algor√≠tmica, para poder resolver vers√µes mais complexas desse problema, como transformar a palavra <b>s√°bado</b> em <b>domingo</b> . <br><br>  Para aplicar a f√≥rmula √† transforma√ß√£o ME ‚Üí MY, primeiro devemos descobrir a dist√¢ncia m√≠nima de edi√ß√£o entre ME ‚Üí M, M ‚Üí MY e M ‚Üí M.  Em seguida, devemos escolher o m√≠nimo de tr√™s dist√¢ncias e adicionar uma opera√ß√£o (+1) da transforma√ß√£o E ‚Üí Y. <br><br>  Portanto, j√° podemos ver a natureza recursiva dessa solu√ß√£o: a dist√¢ncia m√≠nima de edi√ß√£o ME ‚Üí MY √© calculada com base nas tr√™s transforma√ß√µes poss√≠veis anteriores.  Assim, j√° podemos dizer que este √© um algoritmo de divis√£o e conquista. <br><br>  Para explicar melhor o algoritmo, vamos colocar nossas duas linhas em uma matriz: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3d/71e/646/b3d71e646f887852ecf0a579ff8c5957.png" alt="imagem"><br><br>  <b>A c√©lula (0,1)</b> cont√©m o n√∫mero vermelho 1. Isso significa que precisamos executar 1 opera√ß√£o para converter M em uma sequ√™ncia vazia - excluir M. Portanto, marcamos esse n√∫mero em vermelho. <br><br>  <b>A c√©lula (0,2)</b> cont√©m um n√∫mero vermelho 2. Isso significa que precisamos executar 2 opera√ß√µes para transformar a string ME em uma string vazia - exclua E, exclua M. <br><br>  <b>A c√©lula (1,0)</b> cont√©m um n√∫mero verde 1. Isso significa que precisamos de 1 opera√ß√£o para transformar uma string vazia em M - colar M. Marcamos a opera√ß√£o de inser√ß√£o em verde. <br><br>  <b>A c√©lula (2,0)</b> cont√©m um n√∫mero verde 2. Isso significa que precisamos executar 2 opera√ß√µes para converter uma string vazia em uma string MY - insira Y, insira M. <br><br>  <b>A c√©lula (1,1)</b> cont√©m o n√∫mero 0. Isso significa que n√£o precisamos executar nenhuma opera√ß√£o para converter a string M em M. <br><br>  <b>A c√©lula (1,2)</b> cont√©m o n√∫mero vermelho 1. Isso significa que precisamos executar 1 opera√ß√£o para transformar a sequ√™ncia ME em M - excluir E. <br><br>  E assim por diante ... <br><br>  N√£o parece dif√≠cil para matrizes pequenas, como a nossa (apenas 3x3).  Mas como podemos calcular os valores de todas as c√©lulas para matrizes grandes (por exemplo, para uma matriz 9x7 na transforma√ß√£o s√°bado ‚Üí domingo)? <br><br>  A boa not√≠cia √© que, de acordo com a f√≥rmula, tudo o que precisamos para calcular o valor de qualquer c√©lula com coordenadas <code>(i,j)</code> s√£o apenas os valores de 3 c√©lulas vizinhas <code>(i-1,j)</code> , <code>(i-1,j-1)</code> e <code>(i,j-1)</code> .  Tudo o que precisamos fazer √© encontrar o valor m√≠nimo de tr√™s c√©lulas vizinhas e adicionar uma (+1) a esse valor se tivermos letras diferentes na i-√©sima linha e j-√©sima coluna. <br><br>  Ent√£o, novamente, voc√™ pode ver claramente a natureza recursiva dessa tarefa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c96/541/c96/c96541c96d184b5f7dee8b1465e5963e.png" alt="imagem"><br><br>  Tamb√©m vimos que est√°vamos lidando com uma tarefa de dividir e conquistar.  Mas, podemos aplicar programa√ß√£o din√¢mica para resolver esse problema?  Essa tarefa satisfaz as condi√ß√µes de " <b>problemas de interse√ß√£o</b> " e " <b>subestruturas √≥timas</b> " mencionadas acima?  <b>Sim</b>  Vamos construir uma √°rvore de decis√£o. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/d3d/aac/cfad3daaccada3e2bbfb66c85f93a9ef.png" alt="imagem"><br><br>  Primeiro, voc√™ pode perceber que nossa √°rvore de decis√£o se parece mais com um <b>gr√°fico de decis√£o</b> do <b>que com</b> uma <b>√°rvore</b> .  Voc√™ tamb√©m pode observar <b>v√°rias subtarefas sobrepostas</b> .  Tamb√©m √© visto que √© imposs√≠vel reduzir o n√∫mero de opera√ß√µes e torn√°-lo menor que o n√∫mero de opera√ß√µes dessas tr√™s c√©lulas vizinhas (subproblemas). <br><br>  Voc√™ tamb√©m pode perceber que o valor em cada c√©lula √© calculado com base nos valores anteriores.  Portanto, neste caso, a t√©cnica de <b>tabula√ß√£o</b> √© usada (preenchendo o cache na dire√ß√£o de baixo para cima).  Voc√™ ver√° isso no exemplo de c√≥digo abaixo. <br><br>  Aplicando todos esses princ√≠pios, podemos resolver problemas mais complexos, por exemplo, a tarefa de transforma√ß√£o S√°bado ‚Üí Domingo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c60/843/ae9c6084303f344ab2d54fbeaeb7f9d3.png" alt="imagem"><br><br>  <b>Exemplo de c√≥digo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui</a> voc√™ encontra uma solu√ß√£o completa para encontrar a dist√¢ncia m√≠nima de edi√ß√£o com testes e explica√ß√µes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">levenshteinDistance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> distanceMatrix = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(b.length + <span class="hljs-number"><span class="hljs-number">1</span></span>) .fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) .map( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(a.length + <span class="hljs-number"><span class="hljs-number">1</span></span>).fill(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { distanceMatrix[j][<span class="hljs-number"><span class="hljs-number">0</span></span>] = j; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt;= b.length; j += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= a.length; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> indicator = a[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] === b[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; distanceMatrix[j][i] = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( distanceMatrix[j][i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// deletion distanceMatrix[j - 1][i] + 1, // insertion distanceMatrix[j - 1][i - 1] + indicator, // substitution ); } } return distanceMatrix[b.length][a.length]; }</span></span></code> </pre><br><h3>  Conclus√µes </h3><br>  Neste artigo, comparamos duas abordagens algor√≠tmicas (‚Äúprograma√ß√£o din√¢mica‚Äù e ‚Äúdividir e conquistar‚Äù) com a solu√ß√£o de problemas.  Descobrimos que a programa√ß√£o din√¢mica usa o princ√≠pio de "dividir e conquistar" e pode ser aplicada √† solu√ß√£o de problemas se o problema contiver subproblemas que se cruzam e a subestrutura ideal (como √© o caso da dist√¢ncia de Levenshtein).  A programa√ß√£o din√¢mica ainda usa t√©cnicas de memoriza√ß√£o e tabula√ß√£o para preservar as sub-resolu√ß√µes para reutiliza√ß√£o posterior. <br><br>  Espero que este artigo esclare√ßa e n√£o complique a situa√ß√£o para aqueles que tentaram lidar com conceitos importantes como programa√ß√£o din√¢mica e "dividir e conquistar" :) <br><br>  Voc√™ pode encontrar mais exemplos algor√≠tmicos usando programa√ß√£o din√¢mica, com testes e explica√ß√µes no reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JavaScript Algorithms and Data Structures</a> . <br><br>  Codifica√ß√£o bem sucedida! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423939/">https://habr.com/ru/post/pt423939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423927/index.html">10 motores de busca promissores para melhorar o SEO</a></li>
<li><a href="../pt423931/index.html">Como ignorar a autentica√ß√£o de SMS ao se conectar a redes Wi-Fi p√∫blicas?</a></li>
<li><a href="../pt423933/index.html">Microsoft Office Security: Objetos incorporados</a></li>
<li><a href="../pt423935/index.html">A Embox responde a perguntas populares do festival de TI TechTrain</a></li>
<li><a href="../pt423937/index.html">Escalonamento de privil√©gios do Windows</a></li>
<li><a href="../pt423941/index.html">Relat√≥rios do iOS mitap Redmadrobot</a></li>
<li><a href="../pt423943/index.html">Otimiza√ß√£o de pre√ßo de varejo offline</a></li>
<li><a href="../pt423945/index.html">A Suprema Corte especificou o procedimento para considerar casos com republica√ß√µes e curtidas</a></li>
<li><a href="../pt423947/index.html">Nossos dados pessoais n√£o custam nada</a></li>
<li><a href="../pt423949/index.html">Um universo consistente com nossas cren√ßas atuais pode n√£o ser poss√≠vel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>