<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗑️ 😙 ⬅️ Gros o 👇🏿 🚶🏽 📎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque Traduction abrégée, plutôt raconter avec vos propres mots. 
 UPD: comme indiqué dans les commentaires, les exemples ne sont pas parfaits. L'a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gros o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444594/">  <i><u>Remarque</u></i>  <i>Traduction abrégée, plutôt raconter avec vos propres mots.</i> <i><br></i>  <i>UPD: comme indiqué dans les commentaires, les exemples ne sont pas parfaits.</i>  <i>L'auteur ne cherche pas la meilleure solution au problème, son but est d'expliquer la complexité des algorithmes «sur les doigts».</i> <br><br>  La notation Big O est nécessaire pour décrire la complexité des algorithmes.  Pour cela, le concept de temps est utilisé.  Le sujet est effrayant pour beaucoup, les programmeurs évitant de parler du "temps de l'ordre N" est une chose courante. <br><br>  Si vous êtes en mesure d'évaluer le code en termes de Big O, vous êtes probablement considéré comme un «gars intelligent».  Et très probablement, vous passerez par votre prochaine entrevue.  Vous ne serez pas arrêté par la question de savoir s'il est possible de réduire la complexité d'un morceau de code à n log n contre n ^ 2. <br><br><h2>  Structures de données </h2><br>  Le choix de la structure des données dépend de la tâche spécifique: du type de données et de l'algorithme pour leur traitement.  Diverses structures de données (en .NET ou Java ou Elixir) ont été créées pour certains types d'algorithmes. <br><br>  Souvent, en choisissant l'une ou l'autre structure, nous copions simplement la solution généralement acceptée.  Dans la plupart des cas, cela suffit.  Mais en fait, sans comprendre la complexité des algorithmes, nous ne pouvons pas faire un choix éclairé.  Le sujet des structures de données ne peut être passé qu'après la complexité des algorithmes. <br><br>  Ici, nous n'utiliserons que des tableaux de nombres (comme dans une interview).  Exemples JavaScript. <br><a name="habracut"></a><br><h2>  Commençons par le plus simple: O (1) </h2><br>  Prenez un tableau de 5 nombres: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Supposons que vous ayez besoin d'obtenir le premier élément.  Pour cela, nous utilisons l'index: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstNumber = nums[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  À quel point cet algorithme est-il compliqué?  Nous pouvons dire: "pas du tout compliqué - prenez simplement le premier élément du tableau."  C'est vrai, mais il est plus correct de décrire la complexité à travers le nombre d'opérations effectuées pour atteindre le résultat, selon l'entrée ( <i>opérations d'</i> entrée). <br><br>  En d'autres termes: combien d'opérations augmenteront à mesure que le nombre de paramètres d'entrée augmentera. <br><br>  Dans notre exemple, il y a 5 paramètres d'entrée, car il y a 5 éléments dans le tableau.  Pour obtenir le résultat, vous devez effectuer une opération (prendre un élément par index).  Combien d'opérations seront nécessaires s'il y a 100 éléments dans le tableau?  Ou 1000?  Ou 100 000?  Néanmoins, une seule opération est nécessaire. <br><br>  C'est-à-dire: «une opération pour toutes les données d'entrée possibles» - O (1). <br><br>  O (1) peut être lu comme «complexité d'ordre 1» (ordre 1) ou «algorithme s'exécute en temps constant / constant» (temps constant). <br><br>  Vous avez déjà deviné que les algorithmes O (1) sont les plus efficaces. <br><br><h2>  Itérations et "heure de l'ordre n": O (n) </h2><br>  Maintenant, trouvons la somme des éléments du tableau: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nums){ sum += num; }</code> </pre> <br>  Encore une fois, nous nous demandons: de combien d'opérations d'entrée avons-nous besoin?  Ici, vous devez trier tous les éléments, c'est-à-dire  opération sur chaque élément.  Plus le tableau est grand, plus il y a d'opérations. <br><br>  Utilisation de la notation Big O: O (n), ou «complexité de l'ordre n (ordre n)».  De plus, ce type d'algorithme est appelé «linéaire» ou que l'algorithme est «mis à l'échelle linéairement». <br><br><h3>  Analyse </h3><br>  Pouvons-nous rendre la sommation plus efficace?  Généralement non.  Et si nous savons que le tableau est garanti pour commencer à 1, trié et qu'il n'y a pas d'espace?  Ensuite, nous pouvons appliquer la formule S = n (n + 1) / 2 (où n est le dernier élément du tableau): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumContiguousArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//get the last item const lastItem = ary[ary.length - 1]; //Gauss's trick return lastItem * (lastItem + 1) / 2; } const nums = [1,2,3,4,5]; const sumOfArray = sumContiguousArray(nums);</span></span></code> </pre> <br>  Un tel algorithme est beaucoup plus efficace que O (n), de plus, il est exécuté en «temps constant / constant», c'est-à-dire  c'est O (1). <br><br>  En fait, il y a plus d'une opération: vous devez obtenir la longueur du tableau, obtenir le dernier élément, effectuer la multiplication et la division.  N'est-ce pas O (3) ou quelque chose?  En notation Big O, le nombre réel d'étapes n'est pas important, il est important que l'algorithme s'exécute en temps constant. <br><br>  Les algorithmes à temps constant sont toujours O (1).  La même chose avec les algorithmes linéaires, en fait, les opérations peuvent être O (n + 5), dans Big O la notation est O (n). <br><br><h2>  Pas les meilleures solutions: O (n ^ 2) </h2><br>  Écrivons une fonction qui vérifie le tableau pour les doublons.  Solution de boucle imbriquée: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDuplicates = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//loop the list, our O(n) op for (let i = 0; i &lt; nums.length; i++) { const thisNum = nums[i]; //loop the list again, the O(n^2) op for (let j = 0; j &lt; nums.length; j++) { //make sure we're not checking same number if (j !== i) { const otherNum = nums[j]; //if there's an equal value, return if (otherNum === thisNum) return true; } } } //if we're here, no dups return false; } const nums = [1, 2, 3, 4, 5, 5]; hasDuplicates(nums);//true</span></span></code> </pre> <br>  Nous savons déjà que l'itération du tableau est O (n).  Nous avons une boucle imbriquée, pour chaque élément, nous réitérons - c'est-à-dire  O (n ^ 2) ou «complexité d'ordre n carré». <br><br>  Les algorithmes avec des boucles imbriquées sur la même collection sont toujours O (n ^ 2). <br><br><h2>  "La complexité de l'ordre du log n": O (log n) </h2><br>  Dans l'exemple ci-dessus, une boucle imbriquée, par elle-même (si vous ne prenez pas en compte qu'elle est imbriquée), a une complexité O (n), car  c'est l'énumération des éléments du tableau.  Ce cycle se termine dès que l'élément souhaité est trouvé, c'est-à-dire  en fait, tous les éléments ne seront pas énumérés.  Mais la notation Big O considère toujours le pire des cas - l'élément que vous recherchez peut être le dernier. <br><br>  Ici, une boucle imbriquée est utilisée pour rechercher un élément donné dans un tableau.  La recherche d'un élément dans un tableau, dans certaines conditions, peut être optimisée - mieux que O (n) linéaire. <br><br>  Laissez le tableau être trié.  Ensuite, nous pouvons utiliser l'algorithme de recherche binaire: diviser le tableau en deux moitiés, éliminer les inutiles, diviser à nouveau le reste en deux parties, et ainsi de suite jusqu'à ce que nous trouvions la valeur souhaitée.  Ce type d'algorithme est appelé diviser et conquérir Diviser et conquérir. <br><br><img src="https://habrastorage.org/webt/0p/b9/em/0pb9em6fqdkdj0dtknyxbt8kbvk.png" alt="recherche binaire"><br><br>  Cet algorithme est basé sur un logarithme. <br><br><h2>  Aperçu rapide des logarithmes </h2><br>  Prenons un exemple, à quoi x sera-t-il égal? <br><br>  x ^ 3 = 8 <br><br>  Nous devons prendre la racine cubique de 8 - ce sera 2. Maintenant, plus difficile <br><br>  2 ^ x = 512 <br><br>  En utilisant le logarithme, le problème peut être écrit comme <br><br>  log2 (512) = x <br><br>  "Le logarithme en base 2 de 512 est x."  Faites attention à la «base 2», c'est-à-dire  nous pensons par deux - combien de fois vous devez multiplier 2 pour obtenir 512. <br><br>  Dans l'algorithme de recherche binaire, à chaque étape, nous divisons le tableau en deux parties. <br><br>  <i><u>Mon ajout.</u></i>  <i>C'est-à-dire</i>  <i>dans le pire des cas, nous faisons autant d'opérations que nous pouvons diviser le tableau en deux parties.</i>  <i>Par exemple, combien de fois pouvons-nous diviser un tableau de 4 éléments en deux parties?</i>  <i>2 fois.</i>  <i>Et un tableau de 8 éléments?</i>  <i>3 fois.</i>  <i>C'est-à-dire</i>  <i>nombre de divisions / opérations = log2 (n) (où n est le nombre d'éléments dans le tableau).</i> <i><br><br></i>  <i>Il s'avère que la dépendance du nombre d'opérations sur le nombre d'éléments d'entrée est décrite comme log2 (n)</i> <i><br></i> <br><br>  Ainsi, en utilisant la notation Big O, l'algorithme de recherche binaire a la complexité O (log n). <br><br><h2>  Améliorez O (n ^ 2) en O (n log n) </h2><br>  Revenons à la tâche de vérification du tableau pour les doublons.  Nous avons itéré sur tous les éléments du tableau, et pour chaque élément, nous avons à nouveau itéré.  Ils ont fait O (n) à l'intérieur de O (n), c'est-à-dire  O (n * n) ou O (n ^ 2). <br><br>  Nous pouvons remplacer la boucle imbriquée par une recherche binaire *.  C'est-à-dire  il suffit de passer par tous les éléments de O (n), à l'intérieur on fait O (log n).  Il s'avère O (n * log n), ou O (n log n). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchFor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//use binary search! //if found, return the number. Otherwise... //return null. We'll do this in a later chapter. } const hasDuplicates = function (nums) { for (let num of nums) { //let's go through the list again and have a look //at all the other numbers so we can compare if (searchFor(nums, num)) { return true; } } //only arrive here if there are no dups return false; }</span></span></code> </pre> <br><br>  * ATTENTION, afin d'éviter l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impression</a> .  L'utilisation de la recherche binaire pour vérifier un tableau pour les doublons est une mauvaise solution.  Il montre uniquement comment, en termes Big O, évaluer la complexité de l'algorithme indiqué dans la liste de codes ci-dessus.  Un bon algorithme ou un mauvais n'est pas important pour cet article; la visibilité est importante. <br><br><h2>  Penser en termes de Big O </h2><br><ul><li>  L'obtention de l'élément de collection est O (1).  Que ce soit par index dans un tableau ou par clé dans un dictionnaire en notation Big O, ce sera O (1) </li><li>  Itérer sur une collection est O (n) </li><li>  Les boucles imbriquées sur la même collection sont O (n ^ 2) </li><li>  Diviser et conquérir toujours O (log n) </li><li>  Les itérations qui utilisent Divide and Conquer sont O (n log n) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444594/">https://habr.com/ru/post/fr444594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444582/index.html">Palo Alto Networks NGFW Optimiseur de politique de sécurité</a></li>
<li><a href="../fr444584/index.html">Android offrira aux utilisateurs européens un navigateur et un moteur de recherche de choix</a></li>
<li><a href="../fr444586/index.html">Architecture du segment Internet russe</a></li>
<li><a href="../fr444590/index.html">Fuite de données (qui aurait pu se produire mais ne s'est pas produite) de la société de télémédecine</a></li>
<li><a href="../fr444592/index.html">L'armée américaine prévoit d'utiliser un nouveau type d'exosquelette</a></li>
<li><a href="../fr444596/index.html">Iodide: Mozilla Interactive Science Editor</a></li>
<li><a href="../fr444598/index.html">Le CD a 40 ans et il est mort (n'est-ce pas?)</a></li>
<li><a href="../fr444600/index.html">Évaluation de 14 cm sans tête 2019</a></li>
<li><a href="../fr444602/index.html">Encapsulation en C ++ et C</a></li>
<li><a href="../fr444610/index.html">Statistiques et suivi des scripts PHP en temps réel. ClickHouse et Grafana vont aider Pinba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>