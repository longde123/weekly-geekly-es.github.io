<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—‘ï¸ ğŸ˜™ â¬…ï¸ Gros o ğŸ‘‡ğŸ¿ ğŸš¶ğŸ½ ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Remarque Traduction abrÃ©gÃ©e, plutÃ´t raconter avec vos propres mots. 
 UPD: comme indiquÃ© dans les commentaires, les exemples ne sont pas parfaits. L'a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gros o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444594/">  <i><u>Remarque</u></i>  <i>Traduction abrÃ©gÃ©e, plutÃ´t raconter avec vos propres mots.</i> <i><br></i>  <i>UPD: comme indiquÃ© dans les commentaires, les exemples ne sont pas parfaits.</i>  <i>L'auteur ne cherche pas la meilleure solution au problÃ¨me, son but est d'expliquer la complexitÃ© des algorithmes Â«sur les doigtsÂ».</i> <br><br>  La notation Big O est nÃ©cessaire pour dÃ©crire la complexitÃ© des algorithmes.  Pour cela, le concept de temps est utilisÃ©.  Le sujet est effrayant pour beaucoup, les programmeurs Ã©vitant de parler du "temps de l'ordre N" est une chose courante. <br><br>  Si vous Ãªtes en mesure d'Ã©valuer le code en termes de Big O, vous Ãªtes probablement considÃ©rÃ© comme un Â«gars intelligentÂ».  Et trÃ¨s probablement, vous passerez par votre prochaine entrevue.  Vous ne serez pas arrÃªtÃ© par la question de savoir s'il est possible de rÃ©duire la complexitÃ© d'un morceau de code Ã  n log n contre n ^ 2. <br><br><h2>  Structures de donnÃ©es </h2><br>  Le choix de la structure des donnÃ©es dÃ©pend de la tÃ¢che spÃ©cifique: du type de donnÃ©es et de l'algorithme pour leur traitement.  Diverses structures de donnÃ©es (en .NET ou Java ou Elixir) ont Ã©tÃ© crÃ©Ã©es pour certains types d'algorithmes. <br><br>  Souvent, en choisissant l'une ou l'autre structure, nous copions simplement la solution gÃ©nÃ©ralement acceptÃ©e.  Dans la plupart des cas, cela suffit.  Mais en fait, sans comprendre la complexitÃ© des algorithmes, nous ne pouvons pas faire un choix Ã©clairÃ©.  Le sujet des structures de donnÃ©es ne peut Ãªtre passÃ© qu'aprÃ¨s la complexitÃ© des algorithmes. <br><br>  Ici, nous n'utiliserons que des tableaux de nombres (comme dans une interview).  Exemples JavaScript. <br><a name="habracut"></a><br><h2>  CommenÃ§ons par le plus simple: O (1) </h2><br>  Prenez un tableau de 5 nombres: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Supposons que vous ayez besoin d'obtenir le premier Ã©lÃ©ment.  Pour cela, nous utilisons l'index: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstNumber = nums[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Ã€ quel point cet algorithme est-il compliquÃ©?  Nous pouvons dire: "pas du tout compliquÃ© - prenez simplement le premier Ã©lÃ©ment du tableau."  C'est vrai, mais il est plus correct de dÃ©crire la complexitÃ© Ã  travers le nombre d'opÃ©rations effectuÃ©es pour atteindre le rÃ©sultat, selon l'entrÃ©e ( <i>opÃ©rations d'</i> entrÃ©e). <br><br>  En d'autres termes: combien d'opÃ©rations augmenteront Ã  mesure que le nombre de paramÃ¨tres d'entrÃ©e augmentera. <br><br>  Dans notre exemple, il y a 5 paramÃ¨tres d'entrÃ©e, car il y a 5 Ã©lÃ©ments dans le tableau.  Pour obtenir le rÃ©sultat, vous devez effectuer une opÃ©ration (prendre un Ã©lÃ©ment par index).  Combien d'opÃ©rations seront nÃ©cessaires s'il y a 100 Ã©lÃ©ments dans le tableau?  Ou 1000?  Ou 100 000?  NÃ©anmoins, une seule opÃ©ration est nÃ©cessaire. <br><br>  C'est-Ã -dire: Â«une opÃ©ration pour toutes les donnÃ©es d'entrÃ©e possiblesÂ» - O (1). <br><br>  O (1) peut Ãªtre lu comme Â«complexitÃ© d'ordre 1Â» (ordre 1) ou Â«algorithme s'exÃ©cute en temps constant / constantÂ» (temps constant). <br><br>  Vous avez dÃ©jÃ  devinÃ© que les algorithmes O (1) sont les plus efficaces. <br><br><h2>  ItÃ©rations et "heure de l'ordre n": O (n) </h2><br>  Maintenant, trouvons la somme des Ã©lÃ©ments du tableau: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nums){ sum += num; }</code> </pre> <br>  Encore une fois, nous nous demandons: de combien d'opÃ©rations d'entrÃ©e avons-nous besoin?  Ici, vous devez trier tous les Ã©lÃ©ments, c'est-Ã -dire  opÃ©ration sur chaque Ã©lÃ©ment.  Plus le tableau est grand, plus il y a d'opÃ©rations. <br><br>  Utilisation de la notation Big O: O (n), ou Â«complexitÃ© de l'ordre n (ordre n)Â».  De plus, ce type d'algorithme est appelÃ© Â«linÃ©aireÂ» ou que l'algorithme est Â«mis Ã  l'Ã©chelle linÃ©airementÂ». <br><br><h3>  Analyse </h3><br>  Pouvons-nous rendre la sommation plus efficace?  GÃ©nÃ©ralement non.  Et si nous savons que le tableau est garanti pour commencer Ã  1, triÃ© et qu'il n'y a pas d'espace?  Ensuite, nous pouvons appliquer la formule S = n (n + 1) / 2 (oÃ¹ n est le dernier Ã©lÃ©ment du tableau): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumContiguousArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//get the last item const lastItem = ary[ary.length - 1]; //Gauss's trick return lastItem * (lastItem + 1) / 2; } const nums = [1,2,3,4,5]; const sumOfArray = sumContiguousArray(nums);</span></span></code> </pre> <br>  Un tel algorithme est beaucoup plus efficace que O (n), de plus, il est exÃ©cutÃ© en Â«temps constant / constantÂ», c'est-Ã -dire  c'est O (1). <br><br>  En fait, il y a plus d'une opÃ©ration: vous devez obtenir la longueur du tableau, obtenir le dernier Ã©lÃ©ment, effectuer la multiplication et la division.  N'est-ce pas O (3) ou quelque chose?  En notation Big O, le nombre rÃ©el d'Ã©tapes n'est pas important, il est important que l'algorithme s'exÃ©cute en temps constant. <br><br>  Les algorithmes Ã  temps constant sont toujours O (1).  La mÃªme chose avec les algorithmes linÃ©aires, en fait, les opÃ©rations peuvent Ãªtre O (n + 5), dans Big O la notation est O (n). <br><br><h2>  Pas les meilleures solutions: O (n ^ 2) </h2><br>  Ã‰crivons une fonction qui vÃ©rifie le tableau pour les doublons.  Solution de boucle imbriquÃ©e: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDuplicates = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//loop the list, our O(n) op for (let i = 0; i &lt; nums.length; i++) { const thisNum = nums[i]; //loop the list again, the O(n^2) op for (let j = 0; j &lt; nums.length; j++) { //make sure we're not checking same number if (j !== i) { const otherNum = nums[j]; //if there's an equal value, return if (otherNum === thisNum) return true; } } } //if we're here, no dups return false; } const nums = [1, 2, 3, 4, 5, 5]; hasDuplicates(nums);//true</span></span></code> </pre> <br>  Nous savons dÃ©jÃ  que l'itÃ©ration du tableau est O (n).  Nous avons une boucle imbriquÃ©e, pour chaque Ã©lÃ©ment, nous rÃ©itÃ©rons - c'est-Ã -dire  O (n ^ 2) ou Â«complexitÃ© d'ordre n carrÃ©Â». <br><br>  Les algorithmes avec des boucles imbriquÃ©es sur la mÃªme collection sont toujours O (n ^ 2). <br><br><h2>  "La complexitÃ© de l'ordre du log n": O (log n) </h2><br>  Dans l'exemple ci-dessus, une boucle imbriquÃ©e, par elle-mÃªme (si vous ne prenez pas en compte qu'elle est imbriquÃ©e), a une complexitÃ© O (n), car  c'est l'Ã©numÃ©ration des Ã©lÃ©ments du tableau.  Ce cycle se termine dÃ¨s que l'Ã©lÃ©ment souhaitÃ© est trouvÃ©, c'est-Ã -dire  en fait, tous les Ã©lÃ©ments ne seront pas Ã©numÃ©rÃ©s.  Mais la notation Big O considÃ¨re toujours le pire des cas - l'Ã©lÃ©ment que vous recherchez peut Ãªtre le dernier. <br><br>  Ici, une boucle imbriquÃ©e est utilisÃ©e pour rechercher un Ã©lÃ©ment donnÃ© dans un tableau.  La recherche d'un Ã©lÃ©ment dans un tableau, dans certaines conditions, peut Ãªtre optimisÃ©e - mieux que O (n) linÃ©aire. <br><br>  Laissez le tableau Ãªtre triÃ©.  Ensuite, nous pouvons utiliser l'algorithme de recherche binaire: diviser le tableau en deux moitiÃ©s, Ã©liminer les inutiles, diviser Ã  nouveau le reste en deux parties, et ainsi de suite jusqu'Ã  ce que nous trouvions la valeur souhaitÃ©e.  Ce type d'algorithme est appelÃ© diviser et conquÃ©rir Diviser et conquÃ©rir. <br><br><img src="https://habrastorage.org/webt/0p/b9/em/0pb9em6fqdkdj0dtknyxbt8kbvk.png" alt="recherche binaire"><br><br>  Cet algorithme est basÃ© sur un logarithme. <br><br><h2>  AperÃ§u rapide des logarithmes </h2><br>  Prenons un exemple, Ã  quoi x sera-t-il Ã©gal? <br><br>  x ^ 3 = 8 <br><br>  Nous devons prendre la racine cubique de 8 - ce sera 2. Maintenant, plus difficile <br><br>  2 ^ x = 512 <br><br>  En utilisant le logarithme, le problÃ¨me peut Ãªtre Ã©crit comme <br><br>  log2 (512) = x <br><br>  "Le logarithme en base 2 de 512 est x."  Faites attention Ã  la Â«base 2Â», c'est-Ã -dire  nous pensons par deux - combien de fois vous devez multiplier 2 pour obtenir 512. <br><br>  Dans l'algorithme de recherche binaire, Ã  chaque Ã©tape, nous divisons le tableau en deux parties. <br><br>  <i><u>Mon ajout.</u></i>  <i>C'est-Ã -dire</i>  <i>dans le pire des cas, nous faisons autant d'opÃ©rations que nous pouvons diviser le tableau en deux parties.</i>  <i>Par exemple, combien de fois pouvons-nous diviser un tableau de 4 Ã©lÃ©ments en deux parties?</i>  <i>2 fois.</i>  <i>Et un tableau de 8 Ã©lÃ©ments?</i>  <i>3 fois.</i>  <i>C'est-Ã -dire</i>  <i>nombre de divisions / opÃ©rations = log2 (n) (oÃ¹ n est le nombre d'Ã©lÃ©ments dans le tableau).</i> <i><br><br></i>  <i>Il s'avÃ¨re que la dÃ©pendance du nombre d'opÃ©rations sur le nombre d'Ã©lÃ©ments d'entrÃ©e est dÃ©crite comme log2 (n)</i> <i><br></i> <br><br>  Ainsi, en utilisant la notation Big O, l'algorithme de recherche binaire a la complexitÃ© O (log n). <br><br><h2>  AmÃ©liorez O (n ^ 2) en O (n log n) </h2><br>  Revenons Ã  la tÃ¢che de vÃ©rification du tableau pour les doublons.  Nous avons itÃ©rÃ© sur tous les Ã©lÃ©ments du tableau, et pour chaque Ã©lÃ©ment, nous avons Ã  nouveau itÃ©rÃ©.  Ils ont fait O (n) Ã  l'intÃ©rieur de O (n), c'est-Ã -dire  O (n * n) ou O (n ^ 2). <br><br>  Nous pouvons remplacer la boucle imbriquÃ©e par une recherche binaire *.  C'est-Ã -dire  il suffit de passer par tous les Ã©lÃ©ments de O (n), Ã  l'intÃ©rieur on fait O (log n).  Il s'avÃ¨re O (n * log n), ou O (n log n). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchFor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//use binary search! //if found, return the number. Otherwise... //return null. We'll do this in a later chapter. } const hasDuplicates = function (nums) { for (let num of nums) { //let's go through the list again and have a look //at all the other numbers so we can compare if (searchFor(nums, num)) { return true; } } //only arrive here if there are no dups return false; }</span></span></code> </pre> <br><br>  * ATTENTION, afin d'Ã©viter l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impression</a> .  L'utilisation de la recherche binaire pour vÃ©rifier un tableau pour les doublons est une mauvaise solution.  Il montre uniquement comment, en termes Big O, Ã©valuer la complexitÃ© de l'algorithme indiquÃ© dans la liste de codes ci-dessus.  Un bon algorithme ou un mauvais n'est pas important pour cet article; la visibilitÃ© est importante. <br><br><h2>  Penser en termes de Big O </h2><br><ul><li>  L'obtention de l'Ã©lÃ©ment de collection est O (1).  Que ce soit par index dans un tableau ou par clÃ© dans un dictionnaire en notation Big O, ce sera O (1) </li><li>  ItÃ©rer sur une collection est O (n) </li><li>  Les boucles imbriquÃ©es sur la mÃªme collection sont O (n ^ 2) </li><li>  Diviser et conquÃ©rir toujours O (log n) </li><li>  Les itÃ©rations qui utilisent Divide and Conquer sont O (n log n) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444594/">https://habr.com/ru/post/fr444594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444582/index.html">Palo Alto Networks NGFW Optimiseur de politique de sÃ©curitÃ©</a></li>
<li><a href="../fr444584/index.html">Android offrira aux utilisateurs europÃ©ens un navigateur et un moteur de recherche de choix</a></li>
<li><a href="../fr444586/index.html">Architecture du segment Internet russe</a></li>
<li><a href="../fr444590/index.html">Fuite de donnÃ©es (qui aurait pu se produire mais ne s'est pas produite) de la sociÃ©tÃ© de tÃ©lÃ©mÃ©decine</a></li>
<li><a href="../fr444592/index.html">L'armÃ©e amÃ©ricaine prÃ©voit d'utiliser un nouveau type d'exosquelette</a></li>
<li><a href="../fr444596/index.html">Iodide: Mozilla Interactive Science Editor</a></li>
<li><a href="../fr444598/index.html">Le CD a 40 ans et il est mort (n'est-ce pas?)</a></li>
<li><a href="../fr444600/index.html">Ã‰valuation de 14 cm sans tÃªte 2019</a></li>
<li><a href="../fr444602/index.html">Encapsulation en C ++ et C</a></li>
<li><a href="../fr444610/index.html">Statistiques et suivi des scripts PHP en temps rÃ©el. ClickHouse et Grafana vont aider Pinba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>