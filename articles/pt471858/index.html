<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêì ‚ùå üïì RabbitMQ vs. Kafka: Failover e alta disponibilidade em clusters ü§≤üèø ‚òùüèø üëâüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Toler√¢ncia a falhas e alta disponibilidade s√£o grandes t√≥picos; portanto, o RabbitMQ e o Kafka dedicar√£o artigos separados. Este artigo √© sobre o Rabb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: Failover e alta disponibilidade em clusters</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/471858/"><img src="https://habrastorage.org/webt/hr/j2/oy/hrj2oyxwqv8-wo-vpmagx_dwmia.jpeg"><br><br>  Toler√¢ncia a falhas e alta disponibilidade s√£o grandes t√≥picos; portanto, o RabbitMQ e o Kafka dedicar√£o artigos separados.  Este artigo √© sobre o RabbitMQ e o pr√≥ximo √© sobre o Kafka, comparado ao RabbitMQ.  O artigo √© longo, ent√£o fique √† vontade. <br><br>  Considere as estrat√©gias para toler√¢ncia a falhas, consist√™ncia e alta disponibilidade (HA), bem como as vantagens e desvantagens que cada estrat√©gia deve fazer.  O RabbitMQ pode ser executado em um cluster de n√≥s - e depois √© classificado como um sistema distribu√≠do.  Quando se trata de sistemas distribu√≠dos, geralmente falamos sobre consist√™ncia e acessibilidade. <br><br>  Esses conceitos descrevem como o sistema se comporta no caso de uma falha.  Falha na conex√£o de rede, falha no servidor, falha no disco r√≠gido, indisponibilidade tempor√°ria do servidor devido √† coleta de lixo, perda de pacotes ou lentid√£o na conex√£o de rede.  Tudo isso pode levar √† perda ou conflito de dados.  Acontece que √© quase imposs√≠vel criar um sistema que seja simultaneamente completamente consistente (sem perda de dados, sem discrep√¢ncias de dados) e acess√≠vel (ele aceitar√° opera√ß√µes de leitura e grava√ß√£o) para todos os tipos de falhas. <br><a name="habracut"></a><br>  Veremos que a consist√™ncia e a acessibilidade est√£o em diferentes extremos do espectro, e voc√™ precisa escolher qual caminho otimizar.  A boa not√≠cia √© que, com o RabbitMQ, essa escolha √© poss√≠vel.  Voc√™ tem uma esp√©cie de alavancagem "nerd" para mudar a balan√ßa em dire√ß√£o a maior coer√™ncia ou maior acessibilidade. <br><br>  Prestaremos aten√ß√£o especial a quais configura√ß√µes levam √† perda de dados devido a registros confirmados.  Existe uma cadeia de responsabilidade entre editores, corretores e consumidores.  Depois que a mensagem √© transmitida ao corretor, √© seu trabalho n√£o perd√™-la.  Quando o corretor confirma ao editor o recebimento da mensagem, n√£o esperamos que ela se perca.  Mas veremos que isso pode realmente acontecer, dependendo da configura√ß√£o do seu corretor e editor. <br><br><h1>  As primitivas de estabilidade de um n√≥ </h1><br><h3>  Filas / roteamento sustentados </h3><br>  Existem dois tipos de filas no RabbitMQ: dur√°vel / n√£o dur√°vel.  Todas as filas s√£o armazenadas no banco de dados Mnesia.  As filas persistentes s√£o declaradas novamente quando o n√≥ √© iniciado e, portanto, sobrevivem a uma reinicializa√ß√£o, falha no sistema ou no servidor (desde que os dados sejam salvos).  Isso significa que enquanto voc√™ declarar roteamento (troca) e a fila resiliente, a infraestrutura das filas / roteamento retornar√° online. <br><br>  Filas vol√°teis e roteamento s√£o exclu√≠das quando o host √© reiniciado. <br><br><h3>  Mensagens persistentes </h3><br>  S√≥ porque a fila √© longa, n√£o significa que todas as suas mensagens sobreviver√£o √† reinicializa√ß√£o do n√≥.  Somente as mensagens definidas pelo editor como persistentes ser√£o restauradas.  Mensagens persistentes criam uma carga adicional no broker, mas se a perda de mensagens for inaceit√°vel, n√£o haver√° outra maneira. <br><br><img src="https://habrastorage.org/webt/hl/nv/gv/hlnvgvt20t-fbikkajwnkirflyo.png"><br>  <i>Fig.</i>  <i>1. Matriz de estabilidade</i> <br><br><h1>  Cluster de espelhamento de fila </h1><br>  Para sobreviver √† perda de um corretor, precisamos de redund√¢ncia.  Podemos combinar v√°rios n√≥s RabbitMQ em um cluster e adicionar redund√¢ncia adicional replicando as filas entre v√°rios n√≥s.  Assim, se um n√≥ cair, n√£o perderemos dados e permaneceremos dispon√≠veis. <br><br>  Espelhamento de fila: <br><br><ul><li>  uma fila principal (principal), que recebe todos os comandos de grava√ß√£o e leitura <br></li><li>  um ou mais espelhos que recebem todas as mensagens e metadados da fila principal.  Esses espelhos n√£o existem para dimensionamento, mas apenas para redund√¢ncia. </li></ul><br><img src="https://habrastorage.org/webt/am/-b/ol/am-boljly334-fiqfajsoowe3iu.png"><br>  <i>Fig.</i>  <i>2. Espelhando a fila</i> <br><br>  O espelhamento √© definido pela pol√≠tica apropriada.  Nele, voc√™ pode escolher a taxa de replica√ß√£o e at√© os n√≥s nos quais a fila deve ser colocada.  Exemplos: <br><br><ul><li><code>ha-mode: all</code> <br> </li><li>  <code>ha-mode: exactly, ha-params: 2</code> (um mestre e um espelho) <br></li><li> <code>ha-mode: nodes, ha-params: rabbit@node1, rabbit@node2</code> </li> </ul><br><h1>  Confirma√ß√£o ao editor </h1><br>  Para obter uma grava√ß√£o sequencial, o Publisher Confirms deve ser confirmado.  Sem eles, h√° uma chance de perder mensagens.  Uma confirma√ß√£o √© enviada ao editor depois de gravar a mensagem no disco.  O RabbitMQ grava mensagens no disco n√£o ap√≥s o recebimento, mas periodicamente, na regi√£o de v√°rias centenas de milissegundos.  Quando a fila √© espelhada, a confirma√ß√£o √© enviada somente ap√≥s todos os espelhos tamb√©m terem gravado sua c√≥pia da mensagem no disco.  Isso significa que o uso de confirma√ß√µes aumenta o atraso, mas se a seguran√ßa dos dados √© importante, elas s√£o necess√°rias. <br><br><h1>  Fila de Failover </h1><br>  Quando o broker √© encerrado ou falha, todas as filas principais (mestres) nesse n√≥ caem com ele.  O cluster seleciona o espelho mais antigo de cada mestre e o promove como um novo mestre. <br><br><img src="https://habrastorage.org/webt/pq/v_/_a/pqv__ahffpye5i6h_2pdzozyrgi.png"><br>  <i>Fig.</i>  <i>3. V√°rias filas espelhadas e suas pol√≠ticas</i> <br><br>  Corretor 3 gotas.  Observe que o espelho da Fila C no Broker 2 √© atualizado para um mestre.  Observe tamb√©m que um novo espelho foi criado para a Fila C no Broker 1. O RabbitMQ sempre tenta manter a taxa de replica√ß√£o especificada em suas pol√≠ticas. <br><br><img src="https://habrastorage.org/webt/df/e7/la/dfe7laf8pyg0pobmrkgteky-wsw.png"><br>  <i>Fig.</i>  <i>4. O Broker 3 cai, causando falha na fila C</i> <br><br>  O pr√≥ximo Broker 1 est√° caindo!  Temos apenas um corretor restante.  O espelho da fila B sobe para o mestre. <br><br><img src="https://habrastorage.org/webt/b2/bd/qi/b2bdqi_lz21qoe8hcdmsjy8g5kc.png"><br>  <i>Fig.</i>  <i>5</i> <br><br>  Retornamos o Broker 1. N√£o importa com que √™xito os dados tenham sobrevivido √† perda e recupera√ß√£o do broker, todas as mensagens da fila espelhada s√£o descartadas na reinicializa√ß√£o.  √â importante notar, pois haver√° consequ√™ncias.  Em breve consideraremos essas consequ√™ncias.  Portanto, o Broker 1 agora √© novamente um membro do cluster e o cluster est√° tentando cumprir as pol√≠ticas e, portanto, cria espelhos no Broker 1. <br><br>  Nesse caso, a perda do Broker 1 foi conclu√≠da e os dados, portanto, a Fila D n√£o espelhada foi completamente perdida. <br><br><img src="https://habrastorage.org/webt/wi/ql/68/wiql68dzsoerzuibhspllun85ec.png"><br>  <i>Fig.</i>  <i>6. O Broker 1 est√° de volta ao servi√ßo</i> <br><br>  O Broker 3 est√° de volta √† linha, de modo que as linhas A e B recebem espelhos criados nele de acordo com suas pol√≠ticas de HA.  Mas agora todas as linhas principais est√£o em um n√≥!  Isso n√£o √© ideal; uma distribui√ß√£o uniforme entre os n√≥s √© melhor.  Infelizmente, n√£o h√° op√ß√µes especiais para reequilibrar os mestres.  Voltaremos a esse problema mais tarde, pois precisamos considerar a sincroniza√ß√£o da fila primeiro. <br><br><img src="https://habrastorage.org/webt/bg/hj/4n/bghj4n6pdd5ki4oideq7zbwmasi.png"><br>  <i>Fig.</i>  <i>7. O Broker 3 est√° de volta ao servi√ßo.</i>  <i>Todas as filas principais em um n√≥!</i> <br><br>  Portanto, agora voc√™ deve ter uma id√©ia de como os espelhos fornecem redund√¢ncia e toler√¢ncia a falhas.  Isso garante a disponibilidade no caso de falha de um √∫nico n√≥ e protege contra a perda de dados.  Mas ainda n√£o terminamos, porque na realidade tudo √© muito mais complicado. <br><br><h1>  Sincronizar </h1><br>  Ao criar um novo espelho, todas as novas mensagens sempre ser√£o replicadas para esse espelho e para quaisquer outras.  Quanto aos dados existentes na fila principal, podemos replic√°-los em um novo espelho, que se torna uma c√≥pia completa do mestre.  Tamb√©m n√£o podemos replicar mensagens existentes e permitir que a fila principal e o novo espelho converjam no tempo em que novas mensagens chegam ao final e as mensagens existentes saem da cabe√ßa da fila principal. <br><br>  Essa sincroniza√ß√£o √© realizada autom√°tica ou manualmente e √© controlada usando uma diretiva de fila.  Considere um exemplo. <br><br>  Temos duas linhas espelhadas.  A fila A √© sincronizada automaticamente e a fila B manualmente.  Ambas as linhas t√™m dez mensagens cada. <br><br><img src="https://habrastorage.org/webt/vz/zm/5x/vzzm5x_2w3tphqi09kn6h_9_e1c.png"><br>  <i>Fig.</i>  <i>8. Duas filas com diferentes modos de sincroniza√ß√£o</i> <br><br>  Agora estamos perdendo o Broker 3. <br><br><img src="https://habrastorage.org/webt/5x/wp/ki/5xwpki1aoj_-e1hdt0i-gswn-nu.png"><br>  <i>Fig.</i>  <i>9. O broker 3 caiu</i> <br><br>  O Broker 3 est√° de volta ao servi√ßo.  O cluster cria um espelho para cada fila no novo n√≥ e sincroniza automaticamente a nova Fila A com o mestre.  No entanto, o espelho da nova curva B permanece vazio.  Portanto, temos uma redund√¢ncia completa da Fila A e apenas um espelho para as mensagens existentes da Fila B. <br><br><img src="https://habrastorage.org/webt/zo/hb/ha/zohbhaicbgsjdynexgjhuh70ujg.png"><br>  <i>Fig.</i>  <i>10. O novo espelho da Fila A recebe todas as mensagens existentes, mas o novo espelho da Fila B n√£o</i> <br><br>  Ambas as linhas recebem mais dez mensagens.  Em seguida, o Broker 2 cai e a Fila A retorna ao espelho mais antigo, localizado no Broker 1. No caso de uma falha, n√£o h√° perda de dados.  Existem vinte mensagens na Fila B no assistente e apenas dez no espelho, pois essa fila nunca replicou as dez mensagens originais. <br><br><img src="https://habrastorage.org/webt/yy/hc/sz/yyhcszfowfi6eiidhubgqfy1zry.png"><br>  <i>Fig.</i>  <i>11. A linha A √© revertida para o Broker 1 sem perder mensagens</i> <br><br>  Ambas as linhas recebem mais dez mensagens.  O Broker 1. agora trava.A fila A muda para o espelho sem problemas sem perder mensagens.  No entanto, a fila B tem problemas.  Nesse ponto, podemos otimizar acessibilidade ou consist√™ncia. <br><br>  Se quisermos otimizar a acessibilidade, a pol√≠tica de <b><i>promover sob falha</i></b> deve ser definida como <b><i>sempre</i></b> .  Esse √© o valor padr√£o, portanto, voc√™ pode simplesmente omitir a pol√≠tica.  Nesse caso, de fato, permitimos falhas em espelhos n√£o sincronizados.  Isso resultar√° na perda de mensagens, mas a fila permanece leg√≠vel e grav√°vel. <br><br><img src="https://habrastorage.org/webt/4h/hv/_n/4hhv_n4seyvz33pq_sk3my2bnmk.png"><br>  <i>Fig.</i>  <i>12. A linha A √© revertida para o Broker 3 sem perder mensagens.</i>  <i>A linha B volta ao Broker 3 com a perda de dez mensagens</i> <br><br>  Tamb√©m podemos definir <code>ha-promote-on-failure</code> como <code>when-synced</code> .  Nesse caso, em vez de reverter para o espelho, a fila aguardar√° at√© que o Broker 1 com seus dados retorne ao modo online.  Ap√≥s seu retorno, a fila principal aparece novamente no Broker 1 sem perda de dados.  A acessibilidade √© sacrificada para seguran√ßa dos dados.  Mas esse √© um modo arriscado, que pode at√© levar a uma completa perda de dados, que consideraremos em um futuro pr√≥ximo. <br><br><img src="https://habrastorage.org/webt/fk/mx/gx/fkmxgxilgyi8bp_n_-osz6q8be0.png"><br>  <i>Fig.</i>  <i>13. A linha B permanece indispon√≠vel ap√≥s a perda do Broker 1</i> <br><br>  Voc√™ pode fazer uma pergunta: ‚ÄúTalvez seja melhor nunca usar a sincroniza√ß√£o autom√°tica?‚Äù.  A resposta √© que a sincroniza√ß√£o √© uma opera√ß√£o de bloqueio.  Durante a sincroniza√ß√£o, a fila principal n√£o pode executar nenhuma opera√ß√£o de leitura ou grava√ß√£o! <br><br>  Considere um exemplo.  Agora temos filas muito longas.  Como eles podem crescer para esse tamanho?  Por v√°rias raz√µes: <br><br><ul><li>  Filas n√£o s√£o usadas ativamente. <br></li><li>  S√£o linhas de alta velocidade e, no momento, os consumidores s√£o lentos <br></li><li>  S√£o filas de alta velocidade, ocorreu uma falha e os consumidores est√£o alcan√ßando </li></ul><br><img src="https://habrastorage.org/webt/es/6q/gy/es6qgy7p-1cu0avxb1xivijyjii.png"><br>  <i>Fig.</i>  <i>14. Duas filas grandes com diferentes modos de sincroniza√ß√£o</i> <br><br>  Agora o Broker 3 falha. <br><br><img src="https://habrastorage.org/webt/vg/ta/ue/vgtauedea7kaitatv7oshzottps.png"><br>  <i>Fig.</i>  <i>15. O corretor 3 cai, deixando um mestre e um espelho em cada fila</i> <br><br>  O Broker 3 retorna e novos espelhos s√£o criados.  A fila principal A come√ßa a replicar as mensagens existentes para um novo espelho e, durante esse per√≠odo, a fila A fica indispon√≠vel.  A replica√ß√£o de dados requer duas horas, resultando em duas horas de inatividade para esta fila! <br><br>  No entanto, a linha B permanece dispon√≠vel durante todo o per√≠odo.  Ela sacrificou alguma redund√¢ncia por uma quest√£o de acessibilidade. <br><br><img src="https://habrastorage.org/webt/qn/rd/ep/qnrdep5m7sszgxjesb_kfwuw-zw.png"><br>  <i>Fig.</i>  <i>16. A fila permanece indispon√≠vel durante a sincroniza√ß√£o</i> <br><br>  Ap√≥s duas horas, a Fila A tamb√©m fica dispon√≠vel e pode novamente come√ßar a aceitar opera√ß√µes de leitura e grava√ß√£o. <br><br><h3>  Atualiza√ß√µes </h3><br>  Esse comportamento de bloqueio durante a sincroniza√ß√£o dificulta a atualiza√ß√£o de clusters com filas muito grandes.  Em algum momento, o n√≥ com o assistente precisa ser reiniciado, o que significa alternar para o espelho ou desativar a fila durante a atualiza√ß√£o do servidor.  Se escolhermos uma transi√ß√£o, perderemos mensagens se os espelhos n√£o estiverem sincronizados.  Por padr√£o, quando um broker √© desativado, a transi√ß√£o para um espelho n√£o sincronizado n√£o √© executada.  Isso significa que, assim que o corretor retorna, n√£o perdemos nenhuma mensagem, o √∫nico dano foi apenas uma fila simples.  A desativa√ß√£o de intermedi√°rios √© regida pela pol√≠tica de <code>ha-promote-on-shutdown</code> .  Voc√™ pode definir um dos dois valores: <br><br><ul><li>  <code>always</code> = enabled alternando para espelhos n√£o sincronizados <br></li><li>  <code>when-synced</code> = alterna apenas para o espelho sincronizado; caso contr√°rio, a fila se torna inacess√≠vel para leitura e grava√ß√£o.  A fila retorna assim que o broker retorna </li></ul><br>  De uma forma ou de outra, com grandes filas, voc√™ deve escolher entre perda e inacessibilidade de dados. <br><br><h3>  Quando a disponibilidade melhora a seguran√ßa dos dados </h3><br>  Antes de tomar uma decis√£o, mais uma complica√ß√£o deve ser levada em considera√ß√£o.  Embora a sincroniza√ß√£o autom√°tica seja melhor para redund√¢ncia, como isso afeta a seguran√ßa dos dados?  Obviamente, gra√ßas √† melhor redund√¢ncia, o RabbitMQ tem menos chances de perder as mensagens existentes, mas e as novas mensagens dos editores? <br><br>  Aqui voc√™ precisa considerar o seguinte: <br><ul><li>  Um editor pode simplesmente retornar um erro e um servi√ßo ou usu√°rio superior tentar√° novamente mais tarde? <br></li><li>  Um editor pode salvar uma mensagem localmente ou em um banco de dados para tentar novamente mais tarde? </li></ul><br>  Se o publicador conseguir apenas soltar a mensagem, de fato, melhorar a acessibilidade tamb√©m aumentar√° a seguran√ßa dos dados. <br><br>  Portanto, voc√™ precisa procurar um equil√≠brio, e a decis√£o depende da situa√ß√£o espec√≠fica. <br><br><h1>  Problemas com ha-promover-em-falha = quando sincronizado </h1><br>  A id√©ia de <i><b>ha-promover-em-falha</b></i> = <i><b>quando sincronizado</b></i> √© que impedimos a mudan√ßa para um espelho n√£o sincronizado e, assim, evitamos a perda de dados.  A fila permanece inacess√≠vel para leitura ou grava√ß√£o.  Em vez disso, tentamos retornar um broker ca√≠do com dados n√£o danificados para que ele retome o trabalho como mestre sem perda de dados. <br><br>  Mas (e isso √© grande, mas) se o corretor perdeu seus dados, temos um grande problema: a fila est√° perdida!  Todos os dados se foram!  Mesmo se voc√™ tiver espelhos que alcan√ßam basicamente a fila principal, esses espelhos tamb√©m ser√£o descartados. <br><br>  Para incluir novamente um n√≥ com o mesmo nome, pedimos ao cluster para esquecer o n√≥ perdido (com o <i>comando rabbitmqctl forget_cluster_node</i> ) e inicie um novo broker com o mesmo nome de host.  Enquanto o cluster se lembrar do n√≥ perdido, ele se lembrar√° da fila antiga e dos espelhos n√£o sincronizados.  Quando um cluster √© solicitado a esquecer um n√≥ perdido, essa fila tamb√©m √© esquecida.  Agora voc√™ precisa declar√°-lo novamente.  Perdemos todos os dados, embora tiv√©ssemos espelhos com um conjunto de dados parciais.  Seria melhor mudar para um espelho n√£o sincronizado! <br><br>  Portanto, a sincroniza√ß√£o manual (e falha de sincroniza√ß√£o) em combina√ß√£o com <code>ha-promote-on-failure=when-synced</code> , na minha opini√£o, √© bastante arriscada.  Os documentos dizem que essa op√ß√£o existe para seguran√ßa de dados, mas √© uma faca de dois gumes. <br><br><h1>  Mestres de reequil√≠brio </h1><br>  Como prometido, voltamos ao problema da acumula√ß√£o de todos os mestres em um ou mais n√≥s.  Isso pode acontecer mesmo como resultado das atualiza√ß√µes cont√≠nuas do cluster sem interrup√ß√£o.  Em um cluster com tr√™s n√≥s, todas as filas principais ser√£o acumuladas em um ou dois n√≥s. <br><br>  O reequil√≠brio dos mestres pode ser problem√°tico por dois motivos: <br><br><ul><li>  N√£o h√° boas ferramentas de reequil√≠brio </li><li>  Sincroniza√ß√£o de Filas </li></ul><br>  Para o reequil√≠brio, h√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plug-in de</a> terceiros que n√£o √© oficialmente suportado.  Em rela√ß√£o aos plug-ins de terceiros, o manual do RabbitMQ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diz</a> : ‚ÄúO plug-in fornece algumas ferramentas adicionais de configura√ß√£o e relat√≥rios, mas n√£o √© suportado e n√£o √© testado pela equipe do RabbitMQ.  Use por sua conta e risco. <br><br>  H√° outro truque para mover a fila principal pelas pol√≠ticas de alta disponibilidade.  O manual menciona um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">script</a> para isso.  Funciona da seguinte maneira: <br><br><ul><li>  Exclui todos os espelhos usando uma pol√≠tica tempor√°ria com uma prioridade mais alta que a pol√≠tica de alta disponibilidade existente. <br></li><li>  Altera a pol√≠tica tempor√°ria de alta disponibilidade para usar o modo de n√≥s com o n√≥ para o qual a fila principal precisa ser movida. <br></li><li>  Sincroniza a fila para migra√ß√£o for√ßada. <br></li><li>  Ap√≥s a conclus√£o da migra√ß√£o, exclui a pol√≠tica tempor√°ria.  A pol√≠tica inicial de alta disponibilidade entra em vigor e o n√∫mero necess√°rio de espelhos √© criado. </li></ul><br>  A desvantagem √© que essa abordagem pode n√£o funcionar se voc√™ tiver filas grandes ou requisitos estritos de redund√¢ncia. <br><br>  Agora vamos ver como os clusters RabbitMQ funcionam com parti√ß√µes de rede. <br><br><h1>  Interrup√ß√£o da conectividade </h1><br>  Os n√≥s de um sistema distribu√≠do s√£o conectados por links de rede, e os links de rede podem e ser√£o desconectados.  A frequ√™ncia das interrup√ß√µes depende da infraestrutura local ou da confiabilidade da nuvem selecionada.  Em qualquer caso, os sistemas distribu√≠dos devem ser capazes de lidar com eles.  Novamente, temos uma escolha entre acessibilidade e consist√™ncia, e novamente a boa not√≠cia √© que o RabbitMQ fornece os dois (mas n√£o ao mesmo tempo). <br><br>  Com o RabbitMQ, temos duas op√ß√µes principais: <br><br><ul><li>  Permitir separa√ß√£o l√≥gica (c√©rebro dividido).  Isso fornece acessibilidade, mas pode causar perda de dados. <br></li><li>  N√£o permitir separa√ß√£o l√≥gica.  Pode resultar em uma perda de disponibilidade a curto prazo, dependendo de como os clientes se conectam ao cluster.  Tamb√©m pode levar √† inacessibilidade completa em um cluster de dois n√≥s. </li></ul><br>  Mas o que √© separa√ß√£o l√≥gica?  √â quando um cluster √© dividido em dois devido √† perda de conex√µes de rede.  De cada lado, os espelhos sobem para o mestre, portanto, no final, existem v√°rios mestres em cada turno. <br><br><img src="https://habrastorage.org/webt/mi/4f/bb/mi4fbbuk9maj487alkqsbbykkns.png"><br>  <i>Fig.</i>  <i>17. A linha principal e dois espelhos, cada um em um n√≥ separado.</i>  <i>Em seguida, ocorre uma falha na rede e um espelho se separa.</i>  <i>O n√≥ desanexado v√™ que os outros dois ca√≠ram e avan√ßa seus espelhos para o mestre.</i>  <i>Agora, temos duas linhas principais, e ambas permitem escrever e ler.</i> <br><br>  Se os editores enviarem dados para os dois mestres, obteremos duas c√≥pias divergentes da fila. <br><br>  Os v√°rios modos RabbitMQ fornecem acessibilidade ou consist√™ncia. <br><br><h3>  Modo Ignorar (padr√£o) </h3><br>  Este modo fornece acessibilidade.  Ap√≥s a perda da conectividade, ocorre uma separa√ß√£o l√≥gica.  Ap√≥s reconectar, o administrador deve decidir qual parti√ß√£o preferir.  O lado perdedor ser√° reiniciado e todos os dados acumulados desse lado ser√£o perdidos. <br><br><img src="https://habrastorage.org/webt/ih/rj/ow/ihrjow-ceolx0wy8y2o-cn2yiuk.png"><br>  <i>Fig.</i>  <i>18. Tr√™s publicadores est√£o associados a tr√™s corretores.</i>  <i>Internamente, o cluster encaminha todas as solicita√ß√µes para a fila principal no Broker 2.</i> <br><br>  Agora estamos perdendo o Corretor 3. Ele v√™ que outros corretores ca√≠ram e move o espelho para o mestre.  Esta √© a separa√ß√£o l√≥gica. <br><br><img src="https://habrastorage.org/webt/u_/l8/af/u_l8af-qqcyv4ldqdgwrn4t22ei.png"><br>  <i>Fig.</i>  <i>19. Separa√ß√£o l√≥gica (c√©rebro dividido).</i>  <i>Os registros s√£o divididos em duas linhas principais e duas c√≥pias divergem.</i> <br><br>  A conectividade √© restaurada, mas a separa√ß√£o l√≥gica permanece.  O administrador deve selecionar manualmente o lado perdedor.  No caso a seguir, o administrador reinicia o Broker 3. Todas as mensagens que ele n√£o conseguiu transmitir s√£o perdidas. <br><br><img src="https://habrastorage.org/webt/_o/a9/ft/_oa9ftbuvl6dwnewtgfkrhkyva4.png"><br>  <i>Fig.</i>  <i>20. O administrador desativa o Broker 3.</i> <br><br><img src="https://habrastorage.org/webt/ni/y_/xq/niy_xqsgzuvf5ktcta35z98zzxs.png"><br>  <i>Fig.</i>  <i>21. O administrador inicia o Broker 3 e ele ingressa no cluster, perdendo todas as mensagens que permaneceram l√°.</i> <br><br>  Durante a perda de conectividade e ap√≥s sua restaura√ß√£o, o cluster e essa fila estavam dispon√≠veis para leitura e grava√ß√£o. <br><br><h3>  Modo de recupera√ß√£o autom√°tica </h3><br>  Funciona de maneira semelhante ao modo Ignorar, exceto que o pr√≥prio cluster seleciona automaticamente o lado perdedor ap√≥s dividir e restaurar a conectividade.  O lado perdedor retorna ao cluster vazio e a fila perde todas as mensagens enviadas apenas para esse lado. <br><br><h3>  Pausar modo minorit√°rio </h3><br>  Se n√£o queremos permitir a separa√ß√£o l√≥gica, nossa √∫nica op√ß√£o √© recusar a leitura e grava√ß√£o no lado menor ap√≥s a parti√ß√£o do cluster.  Quando um corretor v√™ que ele est√° do lado menor, ele faz uma pausa, ou seja, fecha todas as conex√µes existentes e recusa quaisquer novas.  Uma vez por segundo, ele verifica a reconex√£o.  Depois de restaurada, a conectividade retoma o trabalho e ingressa no cluster. <br><br><img src="https://habrastorage.org/webt/xl/cc/af/xlccafaylyx2nrsz5scaafo1h6u.png"><br>  <i>Fig.</i>  <i>22. Tr√™s publicadores est√£o associados a tr√™s corretores.</i>  <i>Internamente, o cluster encaminha todas as solicita√ß√µes para a fila principal no Broker 2.</i> <br><br>  Em seguida, os Brokers 1 e 2 s√£o separados do Broker 3. Em vez de atualizar seu espelho para um mestre, o Broker 3 faz uma pausa e fica inacess√≠vel. <br><br><img src="https://habrastorage.org/webt/8h/0_/hc/8h0_hc8vj99u6zaht7cgymlckve.png"><br>  <i>Fig.</i>  <i>23. O Broker 3 faz uma pausa, desconecta todos os clientes e rejeita solicita√ß√µes de conex√£o.</i> <br><br>  Depois que a conectividade √© restaurada, ela retorna ao cluster. <br><br>  Vejamos outro exemplo, onde a linha principal est√° no Broker 3. <br><br><img src="https://habrastorage.org/webt/rs/0s/if/rs0siffyxwpdc8imasvfvkapykw.png"><br>  <i>Fig.</i>  <i>24. A linha principal no Broker 3.</i> <br><br>  Em seguida, ocorre a mesma perda de conectividade.  O Broker 3 faz uma pausa porque est√° no lado menor.  Por outro lado, os n√≥s veem que o Broker 3 caiu, de modo que o espelho mais antigo dos Brokers 1 e 2 sobe para o mestre. <br><br><img src="https://habrastorage.org/webt/ba/o3/gr/bao3gr7y31x5ljbbpkqkretaaty.png"><br>  <i>Fig.</i>  <i>25. Transi√ß√£o para o Broker 2 se o Broker 3 n√£o estiver dispon√≠vel.</i> <br><br>  Quando a conectividade √© restaurada, o Broker 3 ingressa no cluster. <br><br><img src="https://habrastorage.org/webt/3z/rp/3k/3zrp3knvfoew7m25bg6bg4dlhju.png"><br>  <i>Fig.</i>  <i>26. O cluster retornou √† opera√ß√£o normal.</i> <br><br>  √â importante entender que estamos obtendo consist√™ncia, mas tamb√©m podemos obter acessibilidade <i><b>se</b></i> transferirmos com √™xito os clientes para a maior parte da se√ß√£o.  Para a maioria das situa√ß√µes, eu pessoalmente escolheria o modo Pausar Minoria, mas isso realmente depende do caso espec√≠fico. <br><br>  Para garantir a disponibilidade, √© importante garantir que os clientes se conectem com √™xito ao site.  Considere nossas op√ß√µes. <br><br><h1>  Conectividade do Cliente </h1><br>  Temos v√°rias op√ß√µes de como, ap√≥s perder a conectividade, envia os clientes para a parte principal do cluster ou para os n√≥s em funcionamento (ap√≥s a falha de um n√≥).  Primeiro, lembremos que uma fila espec√≠fica est√° hospedada em um host espec√≠fico, mas o roteamento e as pol√≠ticas s√£o replicadas em todos os hosts.  Os clientes podem se conectar a qualquer n√≥, e o roteamento interno os direcionar√° quando necess√°rio.  Mas quando um n√≥ √© suspenso, ele rejeita a conex√£o, portanto, os clientes devem se conectar a outro n√≥.  Se um n√≥ cair, ele poder√° fazer pouco. <br><br>  Nossas op√ß√µes: <br><br><ul><li>  O cluster √© acessado usando um balanceador de carga, que simplesmente percorre os n√≥s e os clientes fazem repetidas tentativas de conex√£o at√© que sejam conclu√≠dos com √™xito.      ,        ,        (  ).         ,    . <br></li><li>         /   ,    .    ,        ,     . <br></li><li>      ,          .       ,       ,   . <br></li><li>    /    DNS.      TTL. </li></ul><br><h1>  Conclus√µes </h1><br>   RabbitMQ    .      , : <br><br><ul><li>        ; <br></li><li>      . </li></ul><br>         .   RabbitMQ      ,     .        ,     .         RabbitMQ        .      RabbitMQ     : <br><br><ul><li>  . <br></li><li>  . <br></li><li>   . </li></ul><br>      ,   : <br><br><ul><li> <code>ha-promote-on-failure=always</code> <br> </li><li> <code>ha-sync-mode=manual</code> <br> </li><li> <code>cluster_partition_handling=ignore</code> ( <code>autoheal</code> ) <br></li><li>   <br></li><li> ,      ,  -     </li></ul><br>   ( )   : <br><br><ul><li> Publisher Confirms  Manual Acknowledgements    <br></li><li> <code>ha-promote-on-failure=when-synced</code> ,              !   <code>=always</code> . <br></li><li> <code>ha-sync-mode=automatic</code> (        ;  , ,       ) <br></li><li>  Pause Minority <br></li><li>   </li></ul><br>          ; ,      (,   ).        Shovel. <br><br>    - , ,  . <br><br> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,       RabbitMQ   Docker  Blockade,      ,    . <br><br>   : <br> ‚Ññ1 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr.com/ru/company/itsumma/blog/416629</a> <br> ‚Ññ2 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr.com/ru/company/itsumma/blog/418389</a> <br> ‚Ññ3 ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr.com/ru/company/itsumma/blog/437446</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471858/">https://habr.com/ru/post/pt471858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471840/index.html">Por que ir a entrevistas</a></li>
<li><a href="../pt471844/index.html">5 raz√µes para visitar EPAM INSIDER no Cazaquist√£o</a></li>
<li><a href="../pt471852/index.html">Not√≠cias do mundo do OpenStreetMap n¬∫ 481 (01/10/2019 - 07/10/2019)</a></li>
<li><a href="../pt471854/index.html">Calor Morte 5G</a></li>
<li><a href="../pt471856/index.html">Resolvemos todas as 42 vers√µes do quebra-cabe√ßa de po√ß√µes de Harry Potter</a></li>
<li><a href="../pt471860/index.html">Analisadores de Peg</a></li>
<li><a href="../pt471862/index.html">Implementa√ß√£o do Analisador PEG</a></li>
<li><a href="../pt471864/index.html">Gera√ß√£o de analisador PEG</a></li>
<li><a href="../pt471870/index.html">Uso efetivo do libdispatch</a></li>
<li><a href="../pt471872/index.html">Interfaces no C # 8: suposi√ß√µes perigosas na implementa√ß√£o padr√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>