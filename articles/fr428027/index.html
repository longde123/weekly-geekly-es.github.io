<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏻 🏏 ✡️ Comment j'ai essayé de faire un analyseur statique GLSL (et ce qui n'a pas fonctionné) 💚 👩🏽‍🏭 👍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une fois, je me préparais pour Ludum Dare et j'ai fait un jeu simple où j'utilisais des pixel shaders (d'autres n'étaient pas intégrés au moteur Phase...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai essayé de faire un analyseur statique GLSL (et ce qui n'a pas fonctionné)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428027/"><p> Une fois, je me préparais pour Ludum Dare et j'ai fait un jeu simple où j'utilisais des pixel shaders (d'autres n'étaient pas intégrés au moteur Phaser). </p><br><div class="spoiler">  <b class="spoiler_title">Que sont les shaders?</b> <div class="spoiler_text"><p>  Les shaders sont des programmes de type C GLSL qui s'exécutent sur une carte graphique.  Il existe deux types de shaders, dans cet article nous parlons de pixel shaders (ils sont aussi des «fragment», fragment shaders), qui peuvent être très grossièrement représentés sous cette forme: </p><br><pre><code class="hljs lisp">color = pixelShader(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, ...other attributes)</code> </pre> <br><p>  C'est-à-dire  un shader est exécuté pour chaque pixel de l'image de sortie, déterminant ou affinant sa couleur. <br>  Vous pouvez lire l'article d'introduction sur un autre article sur le hub - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/post/333002/</a> </p></div></div><br><p>  Après les tests, j'ai jeté le lien à un ami et reçu de lui une telle capture d'écran avec la question "est-ce normal?" </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ys/ti/qp/ystiqpls-jpsxgixk9blbocn6u8.png"></div><br><p>  Non, ce n'était pas normal.  Après avoir examiné attentivement le code du shader, j'ai trouvé une erreur de calcul: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; M) { realColor = mix(color1,color2, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span> - t / R1, <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); }</code> </pre> <br><p>  Parce que  Puisque la constante R1 était inférieure à M, dans certains cas, le résultat dans le premier argument de pow était un nombre inférieur à zéro.  La racine carrée du nombre négatif est une chose mystérieuse, du moins pour la norme GLSL.  Ma carte vidéo n'était pas confuse, et elle est en quelque sorte sortie de cette position (il semble l'avoir retournée de la puissance 0), mais elle s'est avérée plus lisible pour un ami. </p><br><p>  Et puis j'ai pensé: puis-je éviter de tels problèmes à l'avenir?  Personne n'est à l'abri des erreurs, en particulier celles qui ne sont pas reproduites localement.  Vous ne pouvez pas écrire de tests unitaires pour GLSL.  En même temps, les transformations à l'intérieur du shader sont assez simples - multiplication, division, sinus, cosinus ... Est-il vraiment impossible de suivre les valeurs de chaque variable et de s'assurer qu'en aucun cas elle ne dépasse les limites de valeurs autorisées? </p><br><p>  J'ai donc décidé d'essayer de faire une analyse statique pour GLSL.  Ce qui en est ressorti - vous pouvez le lire sous la coupe. </p><br><p>  Je vous préviens tout de suite: je n'ai pu obtenir aucun produit fini, seulement un prototype pédagogique. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-analiz">  Analyse préliminaire </h2><br><p>  Après avoir étudié un peu des articles existants sur ce sujet (et découvert simultanément que le sujet s'appelle Value Range Analysis), j'étais heureux d'avoir GLSL, et pas une autre langue.  Jugez par vous-même: </p><br><ul><li>  pas de «dynamique» - références aux fonctions, interfaces, types déduits automatiquement, etc. </li><li>  pas de gestion directe de la mémoire </li><li>  pas de modules, liaison, liaison tardive - tout le code source du shader est disponible <br>  les plages sont généralement bien connues pour les valeurs d'entrée </li><li>  quelques types de données, et ceux-ci tournent autour d'un flotteur.  int / bool sont rarement utilisés, et ce n'est pas si important de les suivre </li><li>  les ifs et les boucles sont rarement utilisés (en raison de problèmes de performances).  les boucles, si elles sont utilisées, sont souvent de simples compteurs pour parcourir un tableau ou répéter un certain effet plusieurs fois.  Personne n'écrira une telle horreur en GLSL (j'espère). </li></ul><br><pre> <code class="python hljs">//   - https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/RangeAnalysis.pdf k = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> k &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>: i = <span class="hljs-number"><span class="hljs-number">0</span></span> j = k <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; j: i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> j = j – <span class="hljs-number"><span class="hljs-number">1</span></span> k = k + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  En général, étant donné les limites de GLSL, la tâche semble être résoluble.  L'algorithme principal est le suivant: </p><br><ol><li>  analyser le code du shader et créer une séquence de commandes qui modifient les valeurs des variables </li><li>  connaître les plages initiales des variables, parcourir la séquence, mettre à jour les plages lorsqu'elles changent </li><li>  si la plage viole des limites données (par exemple, un nombre négatif peut arriver, ou quelque chose de plus grand que 1 arrivera à la "couleur de sortie" gl_FragColor dans le composant rouge), vous devez afficher un avertissement </li></ol><br><h2 id="ispolzuemye-tehnologii">  Technologies utilisées </h2><br><p>  Ici, j'ai eu un choix long et douloureux.  D'une part, mon objectif principal est de vérifier les shaders WebGL, alors pourquoi ne pas javascript pour tout exécuter dans le navigateur pendant le développement.  D'un autre côté, j'ai prévu de quitter Phaser depuis longtemps et d'essayer un autre moteur comme Unity ou LibGDX.  Il y aura également des shaders, mais javascript aura disparu. </p><br><p>  Et d'autre part, la tâche a été faite principalement pour le divertissement.  Et le meilleur divertissement au monde est le zoo.  Par conséquent: </p><br><ol><li>  Analyse du code GLSL effectuée en javascript.  C'est juste que j'ai trouvé assez rapidement la bibliothèque pour analyser GLSL dans AST, et l'interface utilisateur de test semble être plus familière avec le Web.  AST se transforme en une séquence de commandes, qui est envoyée à ... </li><li>  ... la deuxième partie, qui est écrite en C ++ et compilée dans WebAssembly.  J'ai décidé de cette façon: si je veux soudainement fixer cet analyseur à un autre moteur, avec une bibliothèque C ++, cela devrait être fait le plus simplement. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Quelques mots sur la boîte à outils</b> <div class="spoiler_text"><ul><li>  J'ai pris Visual Studio Code comme IDE principal et j'en suis généralement satisfait.  J'ai besoin d'un peu de bonheur - l'essentiel est que Ctrl + Click devrait fonctionner et se compléter automatiquement lors de la frappe.  Les deux fonctions fonctionnent bien en C ++ et JS.  Eh bien, la possibilité de ne pas changer d'IDE entre eux est également excellente. </li><li>  pour compiler C ++, WebAssembly utilise l'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cheerp</a> (il est payant, mais gratuit pour les projets open-source).  Je n'ai rencontré aucun problème avec son utilisation, sauf qu'il a optimisé le code plutôt étrange, mais ici, je ne sais pas de qui il s'agit - le cheerp lui-même ou le compilateur clang utilisé par lui. </li><li>  pour les tests unitaires en C ++ a pris le bon vieux gtest </li><li>  pour construire js en bundle, il a fallu du micro-paquet.  Il a satisfait mes exigences "Je veux un paquet de 1 npm et quelques drapeaux de ligne de commande", mais en même temps pas sans problème, hélas.  Supposons que watch se bloque en cas d'erreur lors de l'analyse du javascript entrant avec le message <code>[Object object]</code> , ce qui n'aide pas beaucoup. </li></ul></div></div><br><p>  Tout, maintenant vous pouvez partir. </p><br><h2 id="korotko-o-modeli">  En bref sur le modèle </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/hf/8s/chhf8sgclvkleyx_kwasvr74hz8.png"></div><br><p>  L'analyseur conserve en mémoire une liste de variables qui se trouvent dans le shader, et pour chacune il stocke la plage de valeurs possible actuelle (comme <code>[0,1]</code> ou <code>[1,∞)</code> ). </p><br><p>  L'analyseur reçoit un flux de travail comme celui-ci: </p><br><pre> <code class="hljs matlab">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> opCode: <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span> arguments: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,-,-,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,-,-]</code> </pre> <br><p>  Ici, nous appelons la fonction sin, les variables avec id = 3 et 4 y sont introduites et le résultat est écrit dans les variables 1 et 2. Cet appel correspond à la GLSL-th: </p><br><pre> <code class="hljs lisp">vec2 a = sin(<span class="hljs-name"><span class="hljs-name">b</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Notez les arguments vides (marqués comme "-").  Dans GLSL, presque toutes les fonctions intégrées sont surchargées pour différents ensembles de types d'entrée, c'est-à-dire  il y a le <code>sin(float)</code> , le <code>sin(vec2)</code> , le <code>sin(vec3)</code> , le <code>sin(vec4)</code> .  Pour plus de commodité, <code>sin(vec4)</code> toutes les versions surchargées sous une seule forme - dans ce cas, <code>sin(vec4)</code> . </p><br><p>  L'analyseur génère une liste de modifications pour chaque variable, comme </p><br><pre> <code class="hljs vhdl">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> branchId: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>: [-<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Ce qui signifie que "la variable 2 de la ligne 10 de la branche 1 a une plage de -1 à 1 inclus" (nous parlerons de la branche un peu plus loin).  Maintenant, vous pouvez magnifiquement mettre en évidence des plages de valeurs dans le code source. </p><br><h2 id="horoshee-nachalo">  Bon début </h2><br><p>  Lorsque l'arborescence AST a déjà commencé à se transformer en une liste de commandes, il est temps d'implémenter des fonctions et des méthodes standard.  Il y en a beaucoup (et ils ont aussi un tas de surcharges, comme je l'ai écrit ci-dessus), mais en général, ils ont des transformations de plage prévisibles.  Disons que, pour un tel exemple, tout se passe assez clairement: </p><br><pre> <code class="hljs ruby">uniform float angle; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; (-∞,∞) /<span class="hljs-regexp"><span class="hljs-regexp">/... float y = sin(angle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [-1,1] float ynorm = 1 + y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [0,2] gl_FragColor.r = ynorm /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/aj/0f/vbaj0fdcx0nnk3lc2qti7egg7yq.png"></div><br><p>  Le canal rouge de la couleur de sortie est dans la plage acceptable, il n'y a pas d'erreur. </p><br><p>  Si vous couvrez plus de fonctions intégrées, alors pour la moitié des shaders, une telle analyse suffit.  Mais qu'en est-il de la seconde moitié - avec des conditions, des boucles et des fonctions? </p><br><h2 id="vetvleniya">  Succursales </h2><br><p>  Prenons par exemple un tel shader. </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uSampler; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec2 uv; <span class="hljs-comment"><span class="hljs-comment">// [0,1] void main() { float a = texture2D(uSampler, uv).a; // -&gt; [0,1] float k; // -&gt; ? if (a &lt; 0.5) { k = a * 2.; } else { k = 1. - a; } gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  La variable <code>a</code> est tirée de la texture, et donc la valeur de cette variable se situe de 0 à 1. Mais quelles valeurs peut <code>k</code> prendre? </p><br><p>  Vous pouvez suivre la voie simple et «unir les branches» - calculer la plage dans chacun des cas et donner le total.  Pour la branche if, nous obtenons <code>k = [0,2]</code> , et pour la branche else, <code>k = [0,1]</code> .  Si vous combinez, il s'avère <code>[0,2]</code> , et vous devez donner une erreur, car  les valeurs supérieures à 1 tombent dans la couleur de sortie de <code>gl_FragColor</code> . </p><br><p>  Cependant, il s'agit d'une fausse alarme claire, et pour un analyseur statique, il n'y a rien de pire que les fausses alarmes - si elles ne sont pas désactivées après le premier cri de "loup", puis après le dixième à coup sûr. </p><br><p>  Donc, nous devons traiter les deux branches séparément, et dans les deux branches, nous devons clarifier la plage de la variable <code>a</code> (bien qu'elle n'ait pas été officiellement modifiée).  Voici à quoi cela pourrait ressembler: </p><br><p>  Branche 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0, 0.5) k = a * 2.; //k = [0, 1) gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Branche 2: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0.5, 1] k = 1. - a; //k = [0, 0.5] gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Ainsi, lorsque l'analyseur rencontre une certaine condition qui se comporte différemment selon la plage, il crée des branches (brunchs) pour chacun des cas.  Dans chaque cas, il affine la plage de la variable source et descend plus bas dans la liste des commandes. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/fp/dy/n7fpdy2xtg92oy5f0qsl7p8thz4.png"></div><br><p>  Il convient de préciser que les branches dans ce cas ne sont pas liées à la construction if-else.  Les branches sont créées lorsqu'une plage d'une variable est divisée en sous-plages, et la cause peut être une instruction conditionnelle facultative.  Par exemple, la fonction step crée également des branches.  Le shader GLSL suivant fait la même chose que le précédent, mais n'utilise pas de branchement (qui, soit dit en passant, est meilleur en termes de performances). </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> k = mix(a * <span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>. - a, step(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, a)); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>.) * k;</code> </pre> <br><p>  La fonction step doit retourner 0 si a &lt;0,5 et 1 sinon.  Par conséquent, des branches seront également créées ici - comme dans l'exemple précédent. </p><br><h2 id="utochnenie-drugih-peremennyh">  Affinement d'autres variables </h2><br><p>  Prenons un exemple précédent légèrement modifié: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-comment"><span class="hljs-comment">// -&gt; [0,1] float b = a - 0.5; // -&gt; [-0.5, 0.5] if (b &lt; 0.) { k = a * 2.; // k,a -&gt; ? } else { k = 1. - a; }</span></span></code> </pre> <br><p>  Ici, la nuance est la suivante: la ramification se produit par rapport à la variable <code>b</code> et les calculs se produisent avec la variable <code>a</code> .  Autrement dit, à l'intérieur de chaque branche, il y aura une valeur correcte de la plage <code>b</code> , mais complètement inutile, et la valeur d'origine de la plage <code>a</code> , complètement incorrecte. </p><br><p>  Cependant, l'analyseur a vu que la plage <code>b</code> était obtenue en calculant à partir de <code>a</code> .  Si vous vous souvenez de ces informations, lors de la ramification, l'analyseur peut parcourir toutes les variables source et affiner leur plage en effectuant le calcul inverse. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pi/lb/sz/pilbszwvjnellonuoosc_oux7wq.png"></div><br><h2 id="funkcii-i-cikly">  Fonctions et boucles </h2><br><p>  GLSL n'a pas de méthodes virtuelles, de pointeurs de fonction ou même d'appels récursifs, donc chaque appel de fonction est unique.  Par conséquent, il est plus facile d'insérer le corps de la fonction à l'endroit de l'appel (en ligne, en d'autres termes).  Cela sera parfaitement cohérent avec la séquence de commandes. </p><br><p>  C'est plus compliqué avec les cycles, car  formellement, GLSL prend entièrement en charge la boucle for de type C.  Cependant, le plus souvent, les boucles sont utilisées sous la forme la plus simple, comme ceci: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) {}</code> </pre> <br><p>  De tels cycles sont faciles à «déployer», c'est-à-dire  insérer le corps de la boucle 12 fois l'un après l'autre.  En conséquence, après avoir réfléchi, j'ai décidé jusqu'à présent de ne soutenir qu'une telle option. </p><br><p>  L'avantage de cette approche est que des commandes peuvent être émises dans un flux vers l'analyseur sans qu'il soit nécessaire de mémoriser des fragments (tels que des corps de fonction ou des boucles) pour une réutilisation ultérieure. </p><br><h2 id="vsplyvshie-problemy">  Problèmes pop-up </h2><br><h3 id="problema-1-slozhnost-ili-nevozmozhnost-utochneniya">  Problème n ° 1: difficulté ou incapacité à clarifier </h3><br><p>  Ci-dessus, nous avons examiné des cas où, lors du raffinement des valeurs d'une variable, nous avons tiré des conclusions sur les valeurs d'une autre variable.  Et ce problème est résolu lorsque des opérations telles que l'addition / la soustraction sont impliquées.  Mais, disons, que faire de la trigonométrie?  Par exemple, une telle condition: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) &gt; <span class="hljs-number"><span class="hljs-number">0.</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    a? }</span></span></code> </pre> <br><p>  Comment calculer la portée d' <code>a</code> intérieur si?  Il s'avère qu'un ensemble infini de plages avec des étapes pi, qui sera alors très gênant pour travailler avec. </p><br><p>  Et il peut y avoir une telle situation: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-comment"><span class="hljs-comment">// [-10,10] float b = getAnotherValue(); //[-20, 30] float k = a + b; if (k &gt; 0) { //a? b? }</span></span></code> </pre> <br><p>  Clarifier les plages <code>a</code> et <code>b</code> dans le cas général sera irréaliste.  Et, par conséquent, les faux positifs sont possibles. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/z9/ea/7ez9eady082-nfgem7j0c65hslk.png"></div><br><h3 id="problema-2-zavisimye-diapazony">  Problème n ° 2: plages dépendantes </h3><br><p>  Considérez cet exemple: </p><br><pre> <code class="hljs pgsql">uniform <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> //-&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-type"><span class="hljs-type">float</span></span> val2 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1.</span></span>; gl_FragColor = vec4(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - val2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/0m/jo/gh0mjodwd1oqeoh32mcdkollcyg.png"></div><br><p>  Pour commencer, l'analyseur considère la plage de la variable <code>val2</code> - et elle devrait être <code>[0,1] - 1 == [-1, 0]</code> </p><br><p>  Cependant, compte tenu de la <code>value - val2</code> , l'analyseur ne tient pas compte du fait que <code>val2</code> été obtenu à partir de la <code>value</code> et fonctionne avec des plages comme si elles étaient indépendantes les unes des autres.  Obtient <code>[0,1] - [-1,0] = [0,2]</code> et signale une erreur.  Bien qu'en réalité, il aurait dû avoir un 1 constant. </p><br><p>  Solution possible: pour stocker pour chaque variable non seulement l'historique des plages, mais aussi l'ensemble de «l'arbre généalogique» - de quelles variables dépendaient, de quelles opérations, etc.  Une autre chose est que «déplier» ce pedigree ne sera pas facile. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/47/-_/qb/47-_qbz4nhcsbbfo_8wvtepll94.png"></div><br><h3 id="problema-3-diapazony-zavisimye-neyavno">  Problème n ° 3: plages implicitement dépendantes </h3><br><p>  Voici un exemple: </p><br><pre> <code class="hljs lisp">float k = sin(<span class="hljs-name"><span class="hljs-name">a</span></span>) + cos(<span class="hljs-name"><span class="hljs-name">a</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Ici, l'analyseur supposera que la plage <code>k = [-1,1] + [-1,1] = [-2,2]</code> .  Ce qui est faux, car  <code>sin(a) + cos(a)</code> pour tout <code>a</code> se situe dans la plage <code>[-√2, √2]</code> . </p><br><p>  Le résultat du calcul de <code>sin(a)</code> ne dépend pas formellement du résultat du calcul de <code>cos(a)</code> .  Cependant, ils dépendent de la même plage de <code>a</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pf/wz/ne/pfwznek8x2iguen0bhyx0thwjuq.png"></div><br><h2 id="itogi-i-vyvody">  Résumé et conclusions </h2><br><p>  Il s'est avéré que faire une analyse de la plage de valeurs même pour un langage aussi simple et hautement spécialisé que GLSL n'est pas une tâche facile.  La couverture des fonctionnalités du langage peut encore être renforcée: la prise en charge des tableaux, des matrices et de toutes les opérations intégrées est une tâche purement technique qui nécessite simplement beaucoup de temps.  Mais comment résoudre des situations avec des dépendances entre variables - la question n'est toujours pas claire pour moi.  Sans résoudre ces problèmes, les faux positifs sont inévitables, dont le bruit peut finalement l'emporter sur les avantages de l'analyse statique. </p><br><p>  Compte tenu de ce que j'ai rencontré, je ne suis pas particulièrement surpris de l'absence d'outils bien connus pour l'analyse de la plage de valeurs dans d'autres langues - il y a clairement plus de problèmes en eux que dans le GLSL relativement simple.  Dans le même temps, vous pouvez écrire au moins des tests unitaires dans d'autres langues, mais ici vous ne pouvez pas le faire. </p><br><p>  Une solution alternative pourrait être la compilation à partir d'autres langues dans GLSL - récemment, il y avait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article sur la compilation à partir de kotlin</a> .  Ensuite, vous pouvez écrire des tests unitaires pour le code source et couvrir toutes les conditions aux limites.  Ou créez un «analyseur dynamique» qui exécutera les mêmes données qui vont au shader via le code kotlin d'origine et avertira des problèmes possibles. </p><br><p>  Alors à ce stade, je me suis arrêté.  La bibliothèque, hélas, n'a pas fonctionné, mais peut-être que ce prototype est utile à quelqu'un. </p><br><p>  Dépôt sur github, pour examen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/AlexeyGrishin/glsl-value-range-analysis</a> </li></ul><br><p>  Pour essayer: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://alexeygrishin.github.io/glsl-value-range-analysis/html/</a> </li></ul><br><h2 id="bonus-osobennosti-sborki-webassembly-s-raznymi-flagami-kompilyatora">  Bonus: fonctionnalités d'assemblage Web avec différents drapeaux de compilation </h2><br><p>  Au départ, j'ai fait l'analyseur sans utiliser stdlib - à l'ancienne, avec des tableaux et des pointeurs.  A cette époque, j'étais très inquiet de la taille du fichier wasm de sortie, je voulais qu'il soit petit.  Mais à partir d'un moment donné, j'ai commencé à ressentir de l'inconfort et j'ai donc décidé de tout transférer vers stdlib - des pointeurs intelligents, des collections normales, c'est tout. </p><br><p>  En conséquence, j'ai eu l'occasion de comparer les résultats de l'assemblage de deux versions de la bibliothèque - avec et sans stdlib.  Eh bien, voyez également comment le bon / mauvais cheerp (et le bruit qu'il utilise) optimise le code. </p><br><p>  Par conséquent, j'ai compilé les deux versions avec différents ensembles d'indicateurs d'optimisation ( <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-O3</code> , <code>-Os</code> et <code>-Oz</code> ), et pour certaines de ces versions, j'ai mesuré la vitesse d'analyse de 3000 opérations avec 1000 branches.  Je suis d'accord, pas le plus grand exemple, mais à mon humble avis est suffisant pour une analyse comparative. </p><br><p>  Que s'est-il passé en fonction de la taille du fichier wasm: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qz/u9/sc/qzu9sc7tg2jdz7v5-zfbvceqkv8.png"></div><br><p>  Étonnamment, l'option de taille avec l'optimisation «zéro» est meilleure que presque toutes les autres.  Je suppose que dans <code>O3</code> y a une ligne agressive de tout dans le monde, ce qui gonfle le binaire.  La version attendue sans stdlib est plus compacte, mais pas tant que <del>  supporter une telle humiliation </del>  pour vous priver du plaisir de travailler avec des collections pratiques. </p><br><p>  Par vitesse d'exécution: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w_/dc/hs/w_dchsujm7zdc4rvzjsaiwpzeme.png"></div><br><p>  Maintenant, je peux voir que <code>-O3</code> ne mange pas en vain son pain, par rapport à <code>-O0</code> .  En même temps, la différence entre les versions avec et sans stdlib est pratiquement absente (j'ai fait 10 mesures, je pense qu'avec un plus grand nombre la différence disparaîtrait complètement). </p><br><p>  Il convient de noter 2 points: </p><br><ul><li>  Le graphique montre les valeurs moyennes de 10 exécutions consécutives de l'analyse, mais dans tous les tests, la toute première analyse a duré 2 fois plus longtemps que les autres (c'est-à-dire, 120 ms, et les suivantes étaient déjà autour de 60 ms).  Il y a probablement eu une initialisation de WebAssembly. </li><li>  Avec le drapeau <code>-O3</code> , j'ai attrapé des bugs terriblement étranges que je n'ai pas attrapés pour d'autres drapeaux.  Par exemple, les fonctions min et max ont soudainement commencé à fonctionner de la même manière - comme min. </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Merci à tous pour votre attention. <br>  Ne laissez jamais les valeurs de vos variables dépasser les limites. <br>  Et voilà. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428027/">https://habr.com/ru/post/fr428027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428011/index.html">Chansons de zombies spatiaux</a></li>
<li><a href="../fr428019/index.html">Jouez à Mortal Kombat avec TensorFlow.js</a></li>
<li><a href="../fr428021/index.html">Scelle contre le réseau neuronal. Ou sélectionnez et exécutez un réseau de neurones pour reconnaître les objets sur le Raspberry Zero</a></li>
<li><a href="../fr428023/index.html">Bases de la sécurité électrique dans la conception d'appareils électroniques</a></li>
<li><a href="../fr428025/index.html">Connexion d'un fichier d'échange (SWAP) sous MAC OS X lors de l'utilisation d'un SSD externe comme système</a></li>
<li><a href="../fr428029/index.html">Événements numériques à Moscou du 29 octobre au 4 novembre</a></li>
<li><a href="../fr428031/index.html">Intégration de 3CX avec 1C: Trade Management - une méthode de combinaison de configurations</a></li>
<li><a href="../fr428033/index.html">Aux États-Unis, le piratage légal des appareils intelligents et des ordinateurs de bord à des fins de réparation et de mise à niveau</a></li>
<li><a href="../fr428035/index.html">Red Hat sera absorbé par IBM</a></li>
<li><a href="../fr428039/index.html">Le gouvernement n'a pas l'intention de plaider pour la neutralité du réseau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>