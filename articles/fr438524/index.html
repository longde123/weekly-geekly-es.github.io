<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë®üèæ üë®üèº‚Äçüöí üó≥Ô∏è Architecture de l'application Flutter 101: Vanilla, Scoped Model, BLoC üë∂üèΩ üíº üïâÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(initialement publi√© sur Medium ) 


 Flutter fournit un cadre moderne de style r√©actif, une riche collection de widgets et des outils, mais il n'y a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architecture de l'application Flutter 101: Vanilla, Scoped Model, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438524/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (initialement publi√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> ) </p><br><p>  Flutter fournit un cadre moderne de style r√©actif, une riche collection de widgets et des outils, mais il n'y a rien de similaire au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide</a> Android de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture des applications</a> . </p><br><p>  En effet, il n'y a pas d'architecture ultime qui r√©pondrait √† toutes les exigences possibles, mais avouons-le, la plupart des applications mobiles sur lesquelles nous travaillons ont au moins certaines des fonctionnalit√©s suivantes: </p><br><ol><li>  Demander / t√©l√©charger des donn√©es depuis / vers le r√©seau. </li><li>  Cartographier, transformer, pr√©parer des donn√©es et les pr√©senter √† l'utilisateur. </li><li>  Mettez / obtenez des donn√©es vers / depuis la base de donn√©es. </li></ol><br><p>  En tenant compte de cela, j'ai cr√©√© un exemple d'application qui r√©sout exactement le m√™me probl√®me en utilisant trois approches diff√©rentes de l'architecture. <a name="habracut"></a></p><br><p>  L'utilisateur se voit pr√©senter un bouton ¬´Charger les donn√©es utilisateur¬ª au centre de l'√©cran.  Lorsque l'utilisateur clique sur le bouton, le chargement des donn√©es asynchrones est d√©clench√© et le bouton est remplac√© par un indicateur de chargement.  Une fois les donn√©es charg√©es, l'indicateur de chargement est remplac√© par les donn√©es. </p><br><p>  Commen√ßons. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="data">  Les donn√©es </h2><br><p> Pour des raisons de simplicit√©, j'ai cr√©√© une classe <code>Repository</code> qui contient la m√©thode <code>getUser()</code> qui √©mule un appel r√©seau asynchrone et renvoie un objet <code>Future&lt;User&gt;</code> avec des valeurs cod√©es en dur. </p><br><p>  Si vous n'√™tes pas familier avec Futures et la programmation asynchrone dans Dart, vous pouvez en apprendre plus √† ce sujet en suivant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce tutoriel</a> et en lisant un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">document</a> . </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vanille </h2><br><p>  Construisons l'application comme le feraient la plupart des d√©veloppeurs apr√®s avoir lu la documentation officielle de Flutter. </p><br><p>  Navigation vers l'√©cran <code>VanillaScreen</code> l'aide de <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Comme l'√©tat du widget peut changer plusieurs fois pendant la dur√©e de vie du widget, nous devons √©tendre <code>StatefulWidget</code> .  L'impl√©mentation d'un widget avec √©tat n√©cessite √©galement d'avoir une classe <code>State</code> .  Les champs <code>bool _isLoading</code> et <code>User _user</code> dans la classe <code>_VanillaScreenState</code> repr√©sentent l'√©tat du widget.  Les deux champs sont initialis√©s avant l' <code>build(BuildContext context)</code> m√©thode <code>build(BuildContext context)</code> . </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Lorsque l'objet d'√©tat du widget est cr√©√©, la m√©thode <code>build(BuildContext context)</code> est appel√©e pour construire l'interface utilisateur.  Toutes les d√©cisions concernant les widgets qui doivent √™tre cr√©√©s pour repr√©senter l'√©tat actuel sont prises dans le code de d√©claration de l'interface utilisateur. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Pour afficher l'indicateur de progression lorsque l'utilisateur clique sur le bouton ¬´Charger les d√©tails de l'utilisateur¬ª, nous proc√©dons ci-dessous. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><blockquote>  L'appel de setState () informe le framework que l'√©tat interne de cet objet a chang√© d'une mani√®re qui pourrait avoir un impact sur l'interface utilisateur dans cette sous-arborescence, ce qui oblige le framework √† planifier une g√©n√©ration pour cet objet State. </blockquote><p>  Cela signifie qu'apr√®s avoir appel√© la m√©thode <code>setState()</code> m√©thode <code>build(BuildContext context)</code> est √† nouveau appel√©e par le framework et <strong>l'arborescence enti√®re du widget est reconstruite</strong> .  Comme <code>_isLoading</code> est d√©sormais d√©fini sur <code>true</code> m√©thode <code>_buildLoading()</code> est appel√©e √† la place de <code>_buildBody()</code> et l'indicateur de chargement s'affiche √† l'√©cran.  Exactement la m√™me chose se produit lorsque nous g√©rons le rappel de <code>getUser()</code> et appelons <code>setState()</code> pour r√©affecter les champs <code>_isLoading</code> et <code>_user</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="pros">  Avantages </h3><br><ol><li>  Facile √† apprendre et √† comprendre. </li><li>  Aucune biblioth√®que tierce n'est requise. </li></ol><br><h3 id="cons">  Inconv√©nients </h3><br><ol><li>  L'arborescence enti√®re du widget est reconstruite √† chaque changement d'√©tat du widget. </li><li>  Cela brise le principe de la responsabilit√© unique.  Widget n'est pas seulement responsable de la construction de l'interface utilisateur, il est √©galement responsable du chargement des donn√©es, de la logique m√©tier et de la gestion des √©tats. </li><li>  Les d√©cisions sur la fa√ßon dont l'√©tat actuel doit √™tre repr√©sent√© sont prises dans le code de d√©claration de l'interface utilisateur.  Si nous avions un peu plus de lisibilit√© du code d'√©tat complexe, cela diminuerait. </li></ol><br><h2 id="scoped-model">  Mod√®le de port√©e </h2><br><p>  Scoped Model est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package tiers</a> qui n'est pas inclus dans le framework Flutter.  Voici comment les d√©veloppeurs de Scoped Model le d√©crivent: </p><br><blockquote>  Un ensemble d'utilitaires qui vous permettent de transmettre facilement un mod√®le de donn√©es d'un widget parent √† ses descendants.  En outre, il reconstruit √©galement tous les enfants qui utilisent le mod√®le lorsque le mod√®le est mis √† jour.  Cette biblioth√®que a √©t√© initialement extraite de la base de code Fuchsia. </blockquote><p>  Construisons le m√™me √©cran en utilisant le mod√®le Scoped.  Tout d'abord, nous devons installer le package Scoped Model en ajoutant la d√©pendance <code>pubspec.yaml</code> √† <code>pubspec.yaml</code> dans <code>dependencies</code> section des <code>dependencies</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Jetons un coup d'≈ìil au widget <code>UserModelScreen</code> et comparons-le avec l'exemple pr√©c√©dent qui a √©t√© construit sans utiliser le mod√®le Scoped.  Jetons un coup d'≈ìil au widget UserModelScreen et comparons-le avec l'exemple pr√©c√©dent qui a √©t√© construit sans utiliser le mod√®le Scoped.  Comme nous voulons rendre notre mod√®le disponible pour tous les descendants du widget, nous devons l'envelopper avec ScopedModel g√©n√©rique et fournir un widget et un mod√®le. </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Dans l'exemple pr√©c√©dent, l'ensemble de l'arborescence des widgets a √©t√© reconstruit lorsque l'√©tat du widget a chang√©.  Mais avons-nous r√©ellement besoin de reconstruire tout l'√©cran?  Par exemple, AppBar ne devrait pas changer du tout, il est donc inutile de le reconstruire.  Id√©alement, nous devrions reconstruire uniquement les widgets mis √† jour.  Le mod√®le de port√©e peut nous aider √† r√©soudre ce probl√®me. </p><br><p>  <code>ScopedModelDescendant&lt;UserModel&gt;</code> est utilis√© pour rechercher <code>UserModel</code> dans l'arborescence Widget.  Il sera automatiquement reconstruit chaque fois que le <code>UserModel</code> notifie que le changement a eu lieu. </p><br><p>  Une autre am√©lioration est que <code>UserModelScreen</code> n'est plus responsable de la gestion de l'√©tat et de la logique m√©tier. </p><br><p>  Jetons un coup d'≈ìil au code <code>UserModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  D√©sormais, <code>UserModel</code> d√©tient et g√®re l'√©tat.  Afin d'avertir les √©couteurs (et reconstruire les descendants) que la modification a eu lieu, la m√©thode <code>notifyListeners()</code> doit √™tre appel√©e. </p><br><h3 id="pros-1">  Avantages </h3><br><ol><li>  Logique d'entreprise, gestion des √©tats et s√©paration du code de l'interface utilisateur. </li><li>  Facile √† apprendre. <br><h3 id="cons">  Inconv√©nients </h3></li><li>  N√©cessite une biblioth√®que tierce. </li><li>  Comme le mod√®le devient de plus en plus complexe, il est difficile de savoir quand vous devez appeler <code>notifyListeners()</code> . </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC ( <strong>B</strong> usiness Logic <strong>C</strong> omponents) est un mod√®le recommand√© par les d√©veloppeurs de Google.  Il exploite la fonctionnalit√© des flux afin de g√©rer et de propager les changements d'√©tat. </p><br><p>  <strong>Pour les d√©veloppeurs Android:</strong> vous pouvez consid√©rer l'objet <code>Bloc</code> comme un <code>ViewModel</code> et <code>StreamController</code> comme un <code>LiveData</code> .  Cela rendra le code suivant tr√®s simple car vous √™tes d√©j√† familier avec les concepts. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  Aucun appel de m√©thode suppl√©mentaire n'est requis pour informer les abonn√©s lorsque l'√©tat change. </p><br><p>  J'ai cr√©√© 3 classes pour repr√©senter les √©tats possibles de l'√©cran: </p><br><p>  <code>UserInitState</code> pour l'√©tat, lorsque l'utilisateur ouvre un √©cran avec un bouton au centre. </p><br><p>  <code>UserLoadingState</code> pour l'√©tat, lorsque l'indicateur de chargement est affich√© pendant le chargement des donn√©es. </p><br><p>  <code>UserDataState</code> pour l'√©tat, lorsque les donn√©es sont charg√©es et affich√©es √† l'√©cran. </p><br><p>  La propagation des changements d'√©tat de cette mani√®re nous permet de nous d√©barrasser de toute la logique du code de d√©claration de l'interface utilisateur.  Dans l'exemple avec Scoped Model, nous v√©rifions toujours si <code>_isLoading</code> est <code>true</code> dans le code de d√©claration de l'interface utilisateur pour d√©cider quel widget nous devons rendre.  Dans le cas de BLoC, nous propagons l'√©tat de l'√©cran et la seule responsabilit√© du widget <code>UserBlocScreen</code> est de rendre l'interface utilisateur pour cet √©tat. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  <code>UserBlocScreen</code> code <code>UserBlocScreen</code> est devenu encore plus simple par rapport aux exemples pr√©c√©dents.  Pour √©couter les changements d'√©tat, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StreamBuilder</a> .  <code>StreamBuilder</code> est un <code>StatefulWidget</code> qui se construit sur la base du dernier instantan√© d'interaction avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stream</a> . </p><br><h3 id="pros-2">  Avantages </h3><br><p>  Aucune biblioth√®que tierce n'est requise. <br>  Logique d'entreprise, gestion des √©tats et s√©paration de la logique de l'interface utilisateur. <br>  C'est r√©actif.  Aucun appel suppl√©mentaire n'est n√©cessaire, comme dans le cas avec notifyListeners du mod√®le <code>notifyListeners()</code> . </p><br><h3 id="cons-1">  Inconv√©nients </h3><br><p>  Une exp√©rience de travail avec les flux ou rxdart est requise. </p><br><h2 id="links">  Les liens </h2><br><p>  Vous pouvez extraire le code source des exemples ci-dessus depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce d√©p√¥t github.</a> </p><br><p>  L'article est initialement publi√© sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438524/">https://habr.com/ru/post/fr438524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438512/index.html">Compression de donn√©es Huffman</a></li>
<li><a href="../fr438514/index.html">Comment je n'ai pas travaill√© depuis un an chez Sberbank</a></li>
<li><a href="../fr438516/index.html">Quand enregistrer la longueur d'un tableau dans une variable locale en C #</a></li>
<li><a href="../fr438518/index.html">Cr√©ation de votre jsfiddle, partie 2</a></li>
<li><a href="../fr438522/index.html">√âgaliseur strat√©gique</a></li>
<li><a href="../fr438526/index.html">Les r√©seaux de neurones artificiels font cro√Ætre les cellules de navigation comme dans le cerveau</a></li>
<li><a href="../fr438530/index.html">Podcasts hipster # 1</a></li>
<li><a href="../fr438534/index.html">Modbus sur le microcontr√¥leur russe K1986BE92QI</a></li>
<li><a href="../fr438536/index.html">Sous le capot du chatbot: ce que RocketBot peut et comment cela fonctionne</a></li>
<li><a href="../fr438538/index.html">Teamlead Conf 2019 Msk: √† propos d'un autre format de communication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>