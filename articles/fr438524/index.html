<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏾 👨🏼‍🚒 🗳️ Architecture de l'application Flutter 101: Vanilla, Scoped Model, BLoC 👶🏽 💼 🕉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(initialement publié sur Medium ) 


 Flutter fournit un cadre moderne de style réactif, une riche collection de widgets et des outils, mais il n'y a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architecture de l'application Flutter 101: Vanilla, Scoped Model, BLoC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438524/"><p><img src="https://habrastorage.org/webt/2j/2p/yu/2j2pyudr-kde4fqeczqoic_9lpq.png"></p><br><p>  (initialement publié sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> ) </p><br><p>  Flutter fournit un cadre moderne de style réactif, une riche collection de widgets et des outils, mais il n'y a rien de similaire au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">guide</a> Android de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture des applications</a> . </p><br><p>  En effet, il n'y a pas d'architecture ultime qui répondrait à toutes les exigences possibles, mais avouons-le, la plupart des applications mobiles sur lesquelles nous travaillons ont au moins certaines des fonctionnalités suivantes: </p><br><ol><li>  Demander / télécharger des données depuis / vers le réseau. </li><li>  Cartographier, transformer, préparer des données et les présenter à l'utilisateur. </li><li>  Mettez / obtenez des données vers / depuis la base de données. </li></ol><br><p>  En tenant compte de cela, j'ai créé un exemple d'application qui résout exactement le même problème en utilisant trois approches différentes de l'architecture. <a name="habracut"></a></p><br><p>  L'utilisateur se voit présenter un bouton «Charger les données utilisateur» au centre de l'écran.  Lorsque l'utilisateur clique sur le bouton, le chargement des données asynchrones est déclenché et le bouton est remplacé par un indicateur de chargement.  Une fois les données chargées, l'indicateur de chargement est remplacé par les données. </p><br><p>  Commençons. </p><br><p><img src="https://habrastorage.org/webt/c5/by/8g/c5by8gjmz_oov-ukuy4_dwo4njs.gif"></p><br><h2 id="data">  Les données </h2><br><p> Pour des raisons de simplicité, j'ai créé une classe <code>Repository</code> qui contient la méthode <code>getUser()</code> qui émule un appel réseau asynchrone et renvoie un objet <code>Future&lt;User&gt;</code> avec des valeurs codées en dur. </p><br><p>  Si vous n'êtes pas familier avec Futures et la programmation asynchrone dans Dart, vous pouvez en apprendre plus à ce sujet en suivant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce tutoriel</a> et en lisant un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">document</a> . </p><br><pre> <code class="plaintext hljs">class Repository { Future&lt;User&gt; getUser() async { await Future.delayed(Duration(seconds: 2)); return User(name: 'John', surname: 'Smith'); } }</code> </pre> <br><pre> <code class="plaintext hljs">class User { User({ @required this.name, @required this.surname, }); final String name; final String surname; }</code> </pre> <br><h2 id="vanilla">  Vanille </h2><br><p>  Construisons l'application comme le feraient la plupart des développeurs après avoir lu la documentation officielle de Flutter. </p><br><p>  Navigation vers l'écran <code>VanillaScreen</code> l'aide de <code>Navigator</code> </p><br><pre> <code class="plaintext hljs">Navigator.push( context, MaterialPageRoute( builder: (context) =&gt; VanillaScreen(_repository), ), );</code> </pre> <br><p>  Comme l'état du widget peut changer plusieurs fois pendant la durée de vie du widget, nous devons étendre <code>StatefulWidget</code> .  L'implémentation d'un widget avec état nécessite également d'avoir une classe <code>State</code> .  Les champs <code>bool _isLoading</code> et <code>User _user</code> dans la classe <code>_VanillaScreenState</code> représentent l'état du widget.  Les deux champs sont initialisés avant l' <code>build(BuildContext context)</code> méthode <code>build(BuildContext context)</code> . </p><br><pre> <code class="plaintext hljs">class VanillaScreen extends StatefulWidget { VanillaScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _VanillaScreenState(); } class _VanillaScreenState extends State&lt;VanillaScreen&gt; { bool _isLoading = false; User _user; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Vanilla'), ), body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), ), ); } Widget _buildBody() { if (_user != null) { return _buildContent(); } else { return _buildInit(); } } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { setState(() { _isLoading = true; }); widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); }); }, ), ); } Widget _buildContent() { return Center( child: Text('Hello ${_user.name} ${_user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Lorsque l'objet d'état du widget est créé, la méthode <code>build(BuildContext context)</code> est appelée pour construire l'interface utilisateur.  Toutes les décisions concernant les widgets qui doivent être créés pour représenter l'état actuel sont prises dans le code de déclaration de l'interface utilisateur. </p><br><pre> <code class="plaintext hljs">body: SafeArea( child: _isLoading ? _buildLoading() : _buildBody(), )</code> </pre> <br><p>  Pour afficher l'indicateur de progression lorsque l'utilisateur clique sur le bouton «Charger les détails de l'utilisateur», nous procédons ci-dessous. </p><br><pre> <code class="plaintext hljs">setState(() { _isLoading = true; });</code> </pre> <br><blockquote>  L'appel de setState () informe le framework que l'état interne de cet objet a changé d'une manière qui pourrait avoir un impact sur l'interface utilisateur dans cette sous-arborescence, ce qui oblige le framework à planifier une génération pour cet objet State. </blockquote><p>  Cela signifie qu'après avoir appelé la méthode <code>setState()</code> méthode <code>build(BuildContext context)</code> est à nouveau appelée par le framework et <strong>l'arborescence entière du widget est reconstruite</strong> .  Comme <code>_isLoading</code> est désormais défini sur <code>true</code> méthode <code>_buildLoading()</code> est appelée à la place de <code>_buildBody()</code> et l'indicateur de chargement s'affiche à l'écran.  Exactement la même chose se produit lorsque nous gérons le rappel de <code>getUser()</code> et appelons <code>setState()</code> pour réaffecter les champs <code>_isLoading</code> et <code>_user</code> . </p><br><pre> <code class="plaintext hljs">widget._repository.getUser().then((user) { setState(() { _user = user; _isLoading = false; }); });</code> </pre> <br><h3 id="pros">  Avantages </h3><br><ol><li>  Facile à apprendre et à comprendre. </li><li>  Aucune bibliothèque tierce n'est requise. </li></ol><br><h3 id="cons">  Inconvénients </h3><br><ol><li>  L'arborescence entière du widget est reconstruite à chaque changement d'état du widget. </li><li>  Cela brise le principe de la responsabilité unique.  Widget n'est pas seulement responsable de la construction de l'interface utilisateur, il est également responsable du chargement des données, de la logique métier et de la gestion des états. </li><li>  Les décisions sur la façon dont l'état actuel doit être représenté sont prises dans le code de déclaration de l'interface utilisateur.  Si nous avions un peu plus de lisibilité du code d'état complexe, cela diminuerait. </li></ol><br><h2 id="scoped-model">  Modèle de portée </h2><br><p>  Scoped Model est un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">package tiers</a> qui n'est pas inclus dans le framework Flutter.  Voici comment les développeurs de Scoped Model le décrivent: </p><br><blockquote>  Un ensemble d'utilitaires qui vous permettent de transmettre facilement un modèle de données d'un widget parent à ses descendants.  En outre, il reconstruit également tous les enfants qui utilisent le modèle lorsque le modèle est mis à jour.  Cette bibliothèque a été initialement extraite de la base de code Fuchsia. </blockquote><p>  Construisons le même écran en utilisant le modèle Scoped.  Tout d'abord, nous devons installer le package Scoped Model en ajoutant la dépendance <code>pubspec.yaml</code> à <code>pubspec.yaml</code> dans <code>dependencies</code> section des <code>dependencies</code> . </p><br><pre> <code class="plaintext hljs">scoped_model: ^1.0.1</code> </pre> <br><p>  Jetons un coup d'œil au widget <code>UserModelScreen</code> et comparons-le avec l'exemple précédent qui a été construit sans utiliser le modèle Scoped.  Jetons un coup d'œil au widget UserModelScreen et comparons-le avec l'exemple précédent qui a été construit sans utiliser le modèle Scoped.  Comme nous voulons rendre notre modèle disponible pour tous les descendants du widget, nous devons l'envelopper avec ScopedModel générique et fournir un widget et un modèle. </p><br><pre> <code class="plaintext hljs">class UserModelScreen extends StatefulWidget { UserModelScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserModelScreenState(); } class _UserModelScreenState extends State&lt;UserModelScreen&gt; { UserModel _userModel; @override void initState() { _userModel = UserModel(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return ScopedModel( model: _userModel, child: Scaffold( appBar: AppBar( title: const Text('Scoped model'), ), body: SafeArea( child: ScopedModelDescendant&lt;UserModel&gt;( builder: (context, child, model) { if (model.isLoading) { return _buildLoading(); } else { if (model.user != null) { return _buildContent(model); } else { return _buildInit(model); } } }, ), ), ), ); } Widget _buildInit(UserModel userModel) { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { userModel.loadUserData(); }, ), ); } Widget _buildContent(UserModel userModel) { return Center( child: Text('Hello ${userModel.user.name} ${userModel.user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } }</code> </pre> <br><p>  Dans l'exemple précédent, l'ensemble de l'arborescence des widgets a été reconstruit lorsque l'état du widget a changé.  Mais avons-nous réellement besoin de reconstruire tout l'écran?  Par exemple, AppBar ne devrait pas changer du tout, il est donc inutile de le reconstruire.  Idéalement, nous devrions reconstruire uniquement les widgets mis à jour.  Le modèle de portée peut nous aider à résoudre ce problème. </p><br><p>  <code>ScopedModelDescendant&lt;UserModel&gt;</code> est utilisé pour rechercher <code>UserModel</code> dans l'arborescence Widget.  Il sera automatiquement reconstruit chaque fois que le <code>UserModel</code> notifie que le changement a eu lieu. </p><br><p>  Une autre amélioration est que <code>UserModelScreen</code> n'est plus responsable de la gestion de l'état et de la logique métier. </p><br><p>  Jetons un coup d'œil au code <code>UserModel</code> . </p><br><pre> <code class="plaintext hljs">class UserModel extends Model { UserModel(this._repository); final Repository _repository; bool _isLoading = false; User _user; User get user =&gt; _user; bool get isLoading =&gt; _isLoading; void loadUserData() { _isLoading = true; notifyListeners(); _repository.getUser().then((user) { _user = user; _isLoading = false; notifyListeners(); }); } static UserModel of(BuildContext context) =&gt; ScopedModel.of&lt;UserModel&gt;(context); }</code> </pre> <br><p>  Désormais, <code>UserModel</code> détient et gère l'état.  Afin d'avertir les écouteurs (et reconstruire les descendants) que la modification a eu lieu, la méthode <code>notifyListeners()</code> doit être appelée. </p><br><h3 id="pros-1">  Avantages </h3><br><ol><li>  Logique d'entreprise, gestion des états et séparation du code de l'interface utilisateur. </li><li>  Facile à apprendre. <br><h3 id="cons">  Inconvénients </h3></li><li>  Nécessite une bibliothèque tierce. </li><li>  Comme le modèle devient de plus en plus complexe, il est difficile de savoir quand vous devez appeler <code>notifyListeners()</code> . </li></ol><br><h2 id="bloc">  BLoC </h2><br><p>  BLoC ( <strong>B</strong> usiness Logic <strong>C</strong> omponents) est un modèle recommandé par les développeurs de Google.  Il exploite la fonctionnalité des flux afin de gérer et de propager les changements d'état. </p><br><p>  <strong>Pour les développeurs Android:</strong> vous pouvez considérer l'objet <code>Bloc</code> comme un <code>ViewModel</code> et <code>StreamController</code> comme un <code>LiveData</code> .  Cela rendra le code suivant très simple car vous êtes déjà familier avec les concepts. </p><br><pre> <code class="plaintext hljs">class UserBloc { UserBloc(this._repository); final Repository _repository; final _userStreamController = StreamController&lt;UserState&gt;(); Stream&lt;UserState&gt; get user =&gt; _userStreamController.stream; void loadUserData() { _userStreamController.sink.add(UserState._userLoading()); _repository.getUser().then((user) { _userStreamController.sink.add(UserState._userData(user)); }); } void dispose() { _userStreamController.close(); } } class UserState { UserState(); factory UserState._userData(User user) = UserDataState; factory UserState._userLoading() = UserLoadingState; } class UserInitState extends UserState {} class UserLoadingState extends UserState {} class UserDataState extends UserState { UserDataState(this.user); final User user; }</code> </pre> <br><p>  Aucun appel de méthode supplémentaire n'est requis pour informer les abonnés lorsque l'état change. </p><br><p>  J'ai créé 3 classes pour représenter les états possibles de l'écran: </p><br><p>  <code>UserInitState</code> pour l'état, lorsque l'utilisateur ouvre un écran avec un bouton au centre. </p><br><p>  <code>UserLoadingState</code> pour l'état, lorsque l'indicateur de chargement est affiché pendant le chargement des données. </p><br><p>  <code>UserDataState</code> pour l'état, lorsque les données sont chargées et affichées à l'écran. </p><br><p>  La propagation des changements d'état de cette manière nous permet de nous débarrasser de toute la logique du code de déclaration de l'interface utilisateur.  Dans l'exemple avec Scoped Model, nous vérifions toujours si <code>_isLoading</code> est <code>true</code> dans le code de déclaration de l'interface utilisateur pour décider quel widget nous devons rendre.  Dans le cas de BLoC, nous propagons l'état de l'écran et la seule responsabilité du widget <code>UserBlocScreen</code> est de rendre l'interface utilisateur pour cet état. </p><br><pre> <code class="plaintext hljs">class UserBlocScreen extends StatefulWidget { UserBlocScreen(this._repository); final Repository _repository; @override State&lt;StatefulWidget&gt; createState() =&gt; _UserBlocScreenState(); } class _UserBlocScreenState extends State&lt;UserBlocScreen&gt; { UserBloc _userBloc; @override void initState() { _userBloc = UserBloc(widget._repository); super.initState(); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text('Bloc'), ), body: SafeArea( child: StreamBuilder&lt;UserState&gt;( stream: _userBloc.user, initialData: UserInitState(), builder: (context, snapshot) { if (snapshot.data is UserInitState) { return _buildInit(); } if (snapshot.data is UserDataState) { UserDataState state = snapshot.data; return _buildContent(state.user); } if (snapshot.data is UserLoadingState) { return _buildLoading(); } }, ), ), ); } Widget _buildInit() { return Center( child: RaisedButton( child: const Text('Load user data'), onPressed: () { _userBloc.loadUserData(); }, ), ); } Widget _buildContent(User user) { return Center( child: Text('Hello ${user.name} ${user.surname}'), ); } Widget _buildLoading() { return const Center( child: CircularProgressIndicator(), ); } @override void dispose() { _userBloc.dispose(); super.dispose(); } }</code> </pre> <br><p>  <code>UserBlocScreen</code> code <code>UserBlocScreen</code> est devenu encore plus simple par rapport aux exemples précédents.  Pour écouter les changements d'état, nous utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StreamBuilder</a> .  <code>StreamBuilder</code> est un <code>StatefulWidget</code> qui se construit sur la base du dernier instantané d'interaction avec un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stream</a> . </p><br><h3 id="pros-2">  Avantages </h3><br><p>  Aucune bibliothèque tierce n'est requise. <br>  Logique d'entreprise, gestion des états et séparation de la logique de l'interface utilisateur. <br>  C'est réactif.  Aucun appel supplémentaire n'est nécessaire, comme dans le cas avec notifyListeners du modèle <code>notifyListeners()</code> . </p><br><h3 id="cons-1">  Inconvénients </h3><br><p>  Une expérience de travail avec les flux ou rxdart est requise. </p><br><h2 id="links">  Les liens </h2><br><p>  Vous pouvez extraire le code source des exemples ci-dessus depuis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce dépôt github.</a> </p><br><p>  L'article est initialement publié sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Medium</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438524/">https://habr.com/ru/post/fr438524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438512/index.html">Compression de données Huffman</a></li>
<li><a href="../fr438514/index.html">Comment je n'ai pas travaillé depuis un an chez Sberbank</a></li>
<li><a href="../fr438516/index.html">Quand enregistrer la longueur d'un tableau dans une variable locale en C #</a></li>
<li><a href="../fr438518/index.html">Création de votre jsfiddle, partie 2</a></li>
<li><a href="../fr438522/index.html">Égaliseur stratégique</a></li>
<li><a href="../fr438526/index.html">Les réseaux de neurones artificiels font croître les cellules de navigation comme dans le cerveau</a></li>
<li><a href="../fr438530/index.html">Podcasts hipster # 1</a></li>
<li><a href="../fr438534/index.html">Modbus sur le microcontrôleur russe K1986BE92QI</a></li>
<li><a href="../fr438536/index.html">Sous le capot du chatbot: ce que RocketBot peut et comment cela fonctionne</a></li>
<li><a href="../fr438538/index.html">Teamlead Conf 2019 Msk: à propos d'un autre format de communication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>