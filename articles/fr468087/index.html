<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏻 🦕 🚂 Méthode de division bisectionnelle dans les tests 🌉 🌏 🌮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table des matières 


- Description de la méthode 
- Application par les testeurs Ligne de données Fichier 
- Ligne de données 
- Fichier 
- Applicati...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Méthode de division bisectionnelle dans les tests</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468087/"><h2>  Table des matières </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Description de la méthode</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application par les testeurs</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ligne de données</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fichier</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application par les développeurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résumé</a> </li></ul><br>  Parfois, les bugs eux-mêmes nous trouvent.  Nous avons donc poussé une grande rangée de données - et le système s'est bloqué.  Est-ce à cause du million de personnages qui sont tombés?  Ou n'en aimait-elle pas un en particulier? <br><br>  Ou le fichier a été téléchargé sur le système et il s'est écrasé.  Pourquoi?  En raison du nom, de l'extension, des données à l'intérieur ou des tailles?  Vous pouvez pousser la localisation sur le développeur, laissez-le penser ce qui est mauvais dans le fichier.  Mais souvent, vous pouvez trouver la raison vous-même, puis décrire plus précisément le problème. <br><br>  Si vous trouvez le minimum de données à jouer, alors: <br><br><ul><li>  Vous gagnerez du temps pour le développeur - il n'aura pas à se connecter au banc d'essai, à charger le fichier lui-même et à faire ses débuts </li><li>  Le gestionnaire pourra facilement évaluer la priorité de la tâche - est-il urgent de la corriger ou le bug peut-il attendre?  Alors que le nom "certains fichiers tombent, xs why" est difficile à faire ... </li><li>  Une description du bug de la compréhension de la cause de la chute sera également bénéfique. </li></ul><br>  Comment trouver le minimum de données pour jouer un bug?  S'il existe des indices dans les journaux, appliquez-les.  S'il n'y a aucun indice, alors la meilleure méthode est la méthode de division bisectionnelle (également connue sous le nom de méthode de «bissection» ou de «dichotomie»). <br><a name="desc"></a><br><h2>  Description de la méthode </h2><br>  La méthode est utilisée pour trouver l'endroit exact de la chute: <br><br><ol><li>  Prenez un paquet de données en baisse. </li><li>  Pause en deux. </li><li>  Vérifier la moitié 1 <br><br><ul><li>  S'il est tombé, alors le problème est là.  Nous travaillons plus loin avec elle. </li><li>  S'il ne tombe pas → vérifier la moitié 2. </li></ul></li><li>  Répétez les étapes 1 à 3 jusqu'à ce qu'il ne reste qu'une valeur en baisse. </li></ol><br><img src="https://habrastorage.org/webt/3p/9c/f-/3p9cf-cfekl63ojwbskywttrowu.png"><br><br>  La méthode vous permet de localiser rapidement le problème, surtout si cela se fait par programme.  Les développeurs intègrent ces mécanismes dans le traitement des données.  Et s'ils ne l'intègrent pas, alors ils souffrent eux-mêmes plus tard, lorsque le testeur vient vers eux et dit: "Cela tombe dans ce dossier, mais je n'ai pas pu trouver la raison exacte." <br><a name="habracut"></a><br><a name="test"></a><br><h2>  Application par les testeurs </h2><br><a name="string"></a><br><h3>  Ligne de données </h3><br>  A chargé une ligne de 1 million de données - le système se bloque. <br>  Nous essayons 500 mille (divisé en deux) - il se bloque toujours. <br>  Nous essayons 250 mille - ça ne pend pas, tout va bien. <br><br>  ↓ <br><br>  D'où la conclusion que le problème se situe entre 250 et 500 000. Encore une fois, nous appliquons la division bisectionnelle. <br><br>  Nous essayons 350 000 (en le divisant «par l'œil» - c'est tout à fait permis, vous n'avez pas à entrer des chiffres exacts lorsque vous jouez manuellement) - tout va bien <br>  Nous essayons 450 mille - c'est mauvais. <br>  Nous essayons 400 000 - c'est mauvais. <br><br>  ↓ <br><br>  En général, vous pouvez déjà obtenir un bug.  Il est très rarement demandé au testeur de signaler que la bordure ou le bug est clairement au numéro 286 586. Il suffit de le localiser environ - 290 000. <br><br>  C’est juste une chose de vérifier «10» et immédiatement «300 000», et c’est complètement différent de fournir des informations plus complètes: «jusqu’à 10 000 tout est OK, de 10 à 280 000 freins démarrent, ça tombe déjà à 290 000». <br><br>  Il est clair que lorsque la quantité est mesurée en milliers, il faudra trop de temps pour rechercher manuellement un visage spécifique.  Oui, le développeur n'en a pas besoin.  Eh bien, personne ne veut perdre son temps en vain. <br><br><img src="https://habrastorage.org/webt/el/eg/de/elegdeql-ebnkuuveicpqye9pqo.png"><br><br>  Bien sûr, si le problème d'origine était sur une ligne de 10 à 30 caractères, vous pouvez trouver la bordure exacte.  Tout est dans une relation raisonnable avec le temps - si vous utilisez la conjecture ou la division bissectionnelle, vous pouvez rapidement trouver la valeur exacte et elle est petite (jusqu'à 100 généralement) - nous recherchons à coup sûr.  Si les problèmes sont sur une grande ligne, plus de 1000 → recherchez environ. <br><a name="file"></a><br><h3>  Fichier </h3><br>  Téléchargement d'un fichier - plantage!  Comment, pourquoi?  Premièrement, nous essayons d'analyser par nous-mêmes ce qui pourrait affecter ce que notre test a testé?  Il s'agit de la puce de règle principale "d'abord positive, puis négative".  Si vous n'essayez pas de tout ranger dans un seul test à la fois: <br><br><ul><li>  Vérifié un petit fichier d'exemple </li><li>  Nous avons vérifié un énorme fichier de 2 Go, avec un tas de colonnes, un tas de colonnes, ainsi que différentes variations des données internes </li></ul><br>  Il sera difficile de localiser ici.  Et si vous séparez les chèques: <br><br><ul><li>  Beaucoup de lignes (mais les données sont positives et vérifiées plus tôt) </li><li>  Beaucoup de colonnes </li><li>  Poids lourd </li><li>  ... </li></ul><br>  C'est déjà à peu près compréhensible, quelle est la raison.  Par exemple, il tombe sur un grand nombre de lignes - à partir de 100 000.  Ok, nous recherchons une frontière plus précise en utilisant la division bisectionnelle: <br><br><ul><li>  Nous avons divisé le dossier en deux par 50 000, vérifié le premier. </li><li>  Si tu tombes, divise-le </li><li>  Et donc, jusqu'à ce que nous trouvions un endroit précis pour tomber </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s1/t_/xn/s1t_xngwtntmh0hhlvvkgwz6p9q.png"></div><br>  Si la baisse dépend du nombre de lignes, nous recherchons une bordure approximative: "Après 5000, elle tombe, il n'y en a pas 4000 mille."  La recherche d'un lieu spécifique (4589) n'est pas nécessaire.  Trop long et ne vaut pas le temps. <br><br><blockquote>  Ce bug a été découvert par des étudiants de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dadat</a> .  Des fichiers de données peuvent y être chargés, le système traitera et standardisera ces données: corriger les fautes de frappe, déterminer les informations manquantes dans les répertoires (code KLADR, FIAS, coordonnées géographiques, quartier de la ville, code postal ...). <br><br>  La fille a essayé de télécharger un gros fichier et a obtenu le résultat: le système affiche une barre de progression à 100% de charge et se bloque pendant plus de 30 minutes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-m/tb/78/-mtb78f5xzib4lpt-xiyf2yukha.jpeg"></div><br>  La localisation est allée plus loin - quand le gel commence-t-il?  Ceci est important car il affecte la priorité de la tâche.  Quelle est la taille de téléchargement typique?  À quelle fréquence les utilisateurs expédient-ils directement des LOTS? <br><br>  Peut-être que le système est conçu pour traiter des milliers de lignes, alors un tel bogue est entassé dans «Fix it un jour».  Ou des téléchargements typiques - 10 à 50 000 lignes qui fonctionnent normalement, eh bien, cela signifie que le bogue ne brûle pas, nous le corrigerons un peu plus tard. <br><br>  Localisation des tâches: <br><br><ul><li>  pour un fichier de 50 000 lignes, 15 secondes de blocage, </li><li>  pour un fichier de 100 000 lignes, 30 secondes de blocage, </li><li>  pour un fichier de 150 000 lignes, 1 minute se bloque, </li><li>  pour un fichier de 165 mille lignes bloque 4 minutes, </li><li>  pour un fichier 172 000 lignes avec une barre de progression complète à 100% se bloque pendant plus d'une demi-heure </li></ul><br>  C'est là que le travail du testeur est déjà effectué qualitativement.  Des informations complètes sont fournies sur le fonctionnement du système, sur la base desquelles le gestionnaire peut déjà conclure à l'urgence de corriger le bogue. <br><br>  La vérification ne prend pas non plus trop de temps.  Vous pouvez aller ou de la fin - ici, nous avons téléchargé 200 000 lignes, et quand le problème commence-t-il?  Nous utilisons la méthode de division bisectionnelle! <br><br>  Ou commencez par un nombre relativement petit - 50 000, augmentant progressivement (de moitié, la méthode de division bisectionnelle, juste le contraire).  Sachant que tout ira mal à 200 000, on comprend qu'il n'y aura pas beaucoup de tests.  Nous avons vérifié 50, 100, 150 - pour trois tests, nous avons trouvé une frontière approximative.  Et puis creuser n'est plus nécessaire. <br></blockquote><br>  Mais rappelez-vous que vous devez également tester votre théorie.  Est-il vrai que le problème réside dans le nombre de lignes et non dans les données du fichier?  La vérification est très simple - créez un fichier de 5 000 lignes avec une seule valeur «positive».  Cette valeur qui fonctionne exactement que vous avez déjà vérifiée plus tôt.  S'il n'y a pas de chute, le problème est impur =)) Il semble que la théorie du nombre de lignes était erronée et le problème se trouve dans les données elles-mêmes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vy/sb/de/vysbde5vdjztq6dnntm9os8xpoy.png"></div><br>  Bien que vous puissiez essayer 10 000 lignes avec exactement une valeur positive.  Il est possible que la chute se reproduise.  Seul votre fichier source était sur plusieurs colonnes.  Ou il y avait des caractères à l'intérieur qui prenaient plus d'octets qu'une valeur positive ... En général, ne rejetez pas immédiatement la théorie de la taille du fichier ou du nombre de lignes.  Essayez la division bisectionnelle au contraire - doublez le fichier. <br><br>  Mais dans tous les cas, rappelez-vous que plus il y a de contrôles en un, plus il est difficile de localiser le bogue.  Par conséquent, il est préférable de tester immédiatement le nombre de lignes ou de colonnes sur une seule valeur positive.  Pour être sûr que vous testez la quantité de données, pas les données elles-mêmes.  Analyse de test et tout ça =) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f1/qc/wr/f1qcwrou3aj-wein9ymrhkg6jiq.png"></div><br>  Mais que se passe-t-il si le problème n'est pas dans le nombre de lignes, mais dans les données elles-mêmes?  Et vous ne savez pas exactement où.  Peut-être avez-vous entassé des données de «Guerre et paix» dans un fichier de test, ou téléchargé une grande feuille de calcul quelque part sur Internet ... Ou l'utilisateur a trouvé un problème - il a téléchargé son fichier et tout est tombé.  Il est venu au support, le support est venu à vous: le fichier est sur vous, jouez-le. <br><br>  D'autres actions dépendent de la situation.  Si les délais de l'utilisateur sont en cours d'exécution ou que de l'argent lui est débité, puis que le traitement du fichier est tombé, il s'agit d'un bogue bloquant.  Et il n'y a pas de temps pour former un testeur de localisation.  Il est plus facile de donner le fichier exact au développeur, de le laisser libre et de trouver lui-même la raison. <br><br>  Mais si vous avez vous-même trouvé une erreur, c'est le temps de la creuser vous-même.  Encore une fois, sans oublier le bon sens, comme toujours avec la localisation.  Au début, nous avons essayé de tirer des conclusions nous-mêmes, puis nous sommes allés chercher de l'aide.  Pour tirer une conclusion vous-même, vous avez besoin de: <br><br><ul><li>  vérifiez les journaux, il peut y avoir la bonne réponse; </li><li>  voir le contenu du fichier: quelque chose peut attirer votre attention, c'est la première théorie; </li><li>  utiliser la méthode de division bisectionnelle. </li></ul><br>  Par conséquent, au lieu du bogue «Fichier Fall, xs pourquoi, voici un fichier joint de 2 Go», vous placez un bogue bien pensé et localisé: «Chute le fichier si la date est au format JJ / MM / AAAA».  Et puis vous n'avez pas besoin d'un fichier de 2 Go déjà, vous n'avez besoin que d'un fichier pour une ligne et une colonne! <br><br><img src="https://habrastorage.org/webt/dv/tj/5n/dvtj5nacjhowgbwxhdx74cd1ea8.png"><br><a name="prog"></a><br><h2>  Application par les développeurs </h2><br>  Sur une grande quantité de données, le testeur ne recherche pas de limite claire, car il est déraisonnable de le faire manuellement.  Mais les développeurs utilisent la méthode de division bisectionnelle dans le code et peuvent toujours trouver un endroit spécifique pour tomber.  Après tout, le système se divisera jusqu'à la victoire, et non une personne! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ab/1q/am/ab1qamsk9ygow7dvurjbygxbueu.png"></div><br>  Par exemple, nous avons un mécanisme pour charger les données dans le système.  Il peut charger jusqu'à 10 mille et un million.  Mais cela n'a pas d'importance, car le téléchargement se fait par lots de 200 entrées.  En cas de problème, le système procède lui-même à une division bisectionnelle.  Lui-même.  Jusqu'à ce qu'il trouve un endroit problématique.  Lisez ensuite dans les journaux: <br><br><blockquote><ul><li>  Vous avez 1000 entrées </li><li>  200 enregistrements traités </li><li>  400 enregistrements traités </li><li>  Oups, tombé sur un pack de 200 disques! </li><li>  J'essaie de traiter un pack de taille 100 </li><li>  J'essaye de traiter un pack de taille 50 </li><li>  J'essaie de traiter un pack de taille 25 </li></ul><br>  ... <br><ul><li>  Erreur sur ces identifiants: le champ Email requis n'est pas rempli </li><li>  600 enregistrements traités </li></ul><br>  ... </blockquote><br>  Ici, bien sûr, la logique dépend également du développeur.  Soit le traitement s'arrête après avoir rencontré une erreur, soit va plus loin.  Vous êtes tombé sur un pack de 200 entrées?  Nous sommes arrivés au point de trouver un goulot d'étranglement, avons marqué l'entrée comme erronée, avons traité les 199 restants et avons continué. <br><br>  Mais que se passe-t-il si le pack entier s'effondre?  Nous avons marqué le dossier comme étant erroné, mais les 199 autres ont également été incapables de traiter.  Pourquoi?  Nous appliquons la même méthode, à la recherche d'un nouveau problème.  L'astuce est que vous devez toujours pouvoir vous arrêter à l'heure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mu/1v/ir/mu1viryveqlw6vqmexnqjirg2ke.png"></div><br>  Si le nombre d'erreurs est supérieur à 10-50-100, il est préférable d'arrêter le téléchargement.  Il est possible qu'une erreur de téléchargement se soit produite dans le système d'origine et nous avons reçu un million de «courbes» de données.  Si le système divise chaque paquet de 200 enregistrements en deux, puis divise les 199 restants, et ainsi de suite, alors ce sera mauvais pour tout le monde: <br><br><ul><li>  Le journal passe de 15 mb à 3 gb et devient illisible; </li><li>  Le système peut planter en essayant de générer un message d'erreur final (j'ai parlé de cette situation dans la section <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BMW Mnemonics</a> ); </li><li>  Beaucoup de temps est consacré à la recherche de toutes les erreurs.  Oui, le système le fait plus rapidement qu'une personne, mais si vous divisez un million de packs de 200 enregistrements, cela prendra du temps. </li></ul><br>  Le cerveau doit donc être inclus partout - à la fois dans les tests manuels et lors de l'écriture du code du programme.  Vous devez toujours comprendre quand vous arrêter.  Ce n'est que dans le cas de tests manuels qu'il sera «sur le point de trouver la frontière», et dans le développement «s'arrêtera s'il y a beaucoup de chutes». <br><a name="itogo"></a><br><h3>  Résumé </h3><br>  La méthode de division bisectionnelle est utilisée pour rechercher l'emplacement exact de la chute et la localisation du bug. <br><br>  Recherchez le nombre et commencez à le diviser en deux: <br><br><ul><li>  longueur de ligne; </li><li>  taille du fichier </li><li>  poids du fichier; </li><li>  nombre de lignes / colonnes; </li><li>  quantité de mémoire libre dans un téléphone mobile; </li><li>  ... </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_d/6_/7v/_d6_7vxayb-tfjsku59wq1vfopq.png"></div><br>  Mais souvenez-vous - un jour, vous devez vous arrêter!  Pas besoin de s'arrêter et de chercher le nombre exact s'il nécessite des milliers de tests supplémentaires.  Mais 5 à 10 minutes peuvent être accordées à la localisation. <br><br>  <i>PS - recherchez des articles plus utiles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur mon blog par la balise "utile"</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468087/">https://habr.com/ru/post/fr468087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468077/index.html">Posit les tests de façon adulte. Analyse spectrale</a></li>
<li><a href="../fr468079/index.html">Dimensions personnalisées dans Google Analytics qui nous ont fait économiser plus d'une fois</a></li>
<li><a href="../fr468081/index.html">«Données anonymes» ou ce qui est prévu dans 152-FZ</a></li>
<li><a href="../fr468083/index.html">API Android Camera2 depuis la bouilloire</a></li>
<li><a href="../fr468085/index.html">Le livre "Safe DevOps. Fonctionnement efficace du système</a></li>
<li><a href="../fr468089/index.html">Redéfinition basée sur l'édition: est-il possible en production?</a></li>
<li><a href="../fr468091/index.html">Le projet de loi sur la création d'une base de données unique avec les données des citoyens adopté à la Douma d'Etat en première lecture</a></li>
<li><a href="../fr468093/index.html">Nitrates dans les produits: magasins suisses vs magasins russes vs chalet d'été</a></li>
<li><a href="../fr468097/index.html">Microsoft Edge - XSS générique</a></li>
<li><a href="../fr468099/index.html">C / C ++ de Python (CFFI, pybind11)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>