<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèæ üíµ üëáüèº M√°quinas autom√°ticas contra c√≥digo de espaguete üè® üìÑ ‚öíÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Eu amo westerns de espaguete, odeio c√≥digo de espaguete" 

 O "c√≥digo do espaguete" √© uma express√£o ideal para descrever software que √© um caos fumeg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√°quinas autom√°ticas contra c√≥digo de espaguete</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/15b/078/04915b0789f8de5be2bc6950b3265a8a.png"></div><br>  <i>"Eu amo westerns de espaguete, odeio c√≥digo de espaguete"</i> <br><br>  O "c√≥digo do espaguete" √© uma express√£o ideal para descrever software que √© um caos fumegante do ponto de vista cognitivo e est√©tico.  Neste artigo, falarei sobre um plano de tr√™s pontos para destruir um c√≥digo de espaguete: <br><br><ul><li>  Discutimos por que o c√≥digo do espaguete n√£o √© t√£o saboroso. </li><li>  Apresentando uma nova vis√£o do que o c√≥digo realmente faz. </li><li>  Estamos discutindo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">FMN (Frame Machine Notation)</a> , que ajuda os desenvolvedores a desvendar uma bola de cola. </li></ul><br>  Todos sabemos o qu√£o dif√≠cil √© ler o c√≥digo de outra pessoa.  Isso pode ser devido ao fato de que a tarefa em si √© dif√≠cil ou porque a estrutura do c√≥digo √© muito ... "criativa".  Muitas vezes, esses dois problemas andam de m√£os dadas. <br><br>  Desafios s√£o tarefas dif√≠ceis, e geralmente nada al√©m de uma descoberta revolucion√°ria pode simplific√°-los.  No entanto, acontece que a pr√≥pria estrutura de software adiciona complexidade desnecess√°ria, e <em>vale a pena</em> solucionar esse problema. <br><br>  A fei√∫ra do c√≥digo do espaguete est√° em sua l√≥gica condicional complexa.  E embora a vida possa ser dif√≠cil de imaginar sem as muitas constru√ß√µes complicadas de "se-ent√£o-outro", este artigo mostrar√° uma solu√ß√£o melhor. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/af0/c3c/6ccaf0c3c57a472e1eb5b80a238a86c5.png"></div><br>  Para ilustrar a situa√ß√£o com o c√≥digo espaguete, precisamos primeiro transformar isso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf9/eac/43c/cf9eac43c588d9fecbbfc9bf15753ee1.jpg"></div><br>  <i>Massa crocante</i> <br><br>  Neste: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7fc/683/f12/7fc683f12aa20bcf4abcf5a774c7a039.jpg"></div><br>  <i>Al dente!</i> <br><br>  Vamos come√ßar a cozinhar. <br><br><h3>  Estado impl√≠cito </h3><br>  Para fazer macarr√£o, definitivamente precisamos de √°gua para cozinhar.  No entanto, mesmo um elemento aparentemente simples envolvendo c√≥digo de espaguete pode ser muito confuso. <br><br>  Aqui est√° um exemplo simples: <br><br><pre><code class="cpp hljs">(temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>)</code> </pre> <br>  O que essa verifica√ß√£o realmente faz?  Obviamente, ele divide a linha num√©rica em duas partes, mas o <em>que</em> essas partes <em>significam</em> ?  Eu acho que voc√™ pode fazer uma suposi√ß√£o l√≥gica, mas o problema √© que o c√≥digo n√£o comunica isso <em>explicitamente</em> . <br><br>  Se eu realmente confirmar que ela verifica se a √°gua √© S√ìLIDA <i>[aprox.</i>  <i>pista: de acordo com a escala de Fahrenheit, a √°gua congela a +32 graus]</i> , o que logicamente significa o retorno falso? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) }</span></span></code> </pre> <br>  Embora o cheque tenha dividido os n√∫meros em dois grupos, na verdade existem tr√™s estados l√≥gicos - s√≥lido, l√≠quido e g√°s (S√ìLIDO, L√çQUIDO, G√ÅS)! <br><br>  Ou seja, esta linha num√©rica: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/b04/343/fadb04343c512bbf297dbf17a250d742.png"></div><br>  dividir por verifica√ß√£o de condi√ß√£o da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e83/2cc/56ae832ccebc547053d46dec39993ec3.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a55/dcf/20d/a55dcf20d2de1f679a233913c045546f.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Observe o que aconteceu porque √© muito importante para entender a natureza do c√≥digo do espaguete.  Uma verifica√ß√£o booleana dividiu o espa√ßo num√©rico em duas partes, mas N√ÉO categorizou o sistema como uma estrutura l√≥gica real de (SOLID, LIQUID, GAS).  Em vez disso, a verifica√ß√£o dividiu o espa√ßo em (SOLID, tudo o resto). <br><br>  Aqui est√° uma verifica√ß√£o semelhante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// GAS water } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  Visualmente, ficar√° assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt; <span class="hljs-number"><span class="hljs-number">212</span></span>) {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/127/810/51d127810231b42191868d0972e3865f.png"></div><br><pre> <code class="cpp hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42a/187/bd4/42a187bd4559e2dfa9e6acffcd24c8b2.png"></div><br><pre> <code class="cpp hljs">}</code> </pre> <br>  Note que: <br><br><ol><li>  o conjunto completo de estados poss√≠veis n√£o √© anunciado em nenhum lugar </li><li>  em nenhum lugar nas constru√ß√µes condicionais s√£o estados l√≥gicos verific√°veis ‚Äã‚Äãou grupos de estados declarados </li><li>  alguns estados s√£o indiretamente agrupados pela estrutura da l√≥gica condicional e ramifica√ß√£o </li></ol><br>  Esse c√≥digo √© fr√°gil, mas muito comum e n√£o √© t√£o grande que cause problemas com seu suporte.  Ent√£o, vamos piorar a situa√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/852/bd5/7a1/852bd57a151d005a34ddd883aea5d1ab.png"></div><br>  <i>Eu nunca gostei do seu c√≥digo de qualquer maneira</i> <br><br>  O c√≥digo mostrado acima implica a exist√™ncia de tr√™s estados da mat√©ria - S√ìLIDO, L√çQUIDO, G√ÅS.  No entanto, de acordo com dados cient√≠ficos, de fato, existem <strong><em>quatro</em></strong> estados observ√°veis ‚Äã‚Äãnos quais o plasma (PLASMA) est√° inclu√≠do (de fato, existem muitos outros, mas isso ser√° suficiente para n√≥s).  Embora ningu√©m esteja preparando uma pasta a partir do plasma, se esse c√≥digo for publicado no Github, e algum aluno de p√≥s-gradua√ß√£o em f√≠sica de alta energia for√ß√°-lo, teremos que manter esse estado tamb√©m. <br><br>  No entanto, quando o plasma √© adicionado, o c√≥digo mostrado acima far√° ingenuamente o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SOLID water } else { // not SOLID water. is (LIQUID | GAS) + (PLASMA?) // how did PLASMA get in here?? } if (temp &gt; 212) { // GAS water + (PLASMA) // again with the PLASMA!! } else { // not GAS water. is (SOLID | LIQUID) }</span></span></code> </pre> <br>  √â prov√°vel que o c√≥digo antigo, quando adicionado a muitos estados do plasma, seja interrompido nos outros ramos.  Infelizmente, nada na estrutura de c√≥digo ajuda a relatar a exist√™ncia de um novo estado ou a influenciar mudan√ßas.  Al√©m disso, √© prov√°vel que quaisquer erros sejam impercept√≠veis, ou seja, encontr√°-los ser√° o mais dif√≠cil.  Apenas diga n√£o aos insetos no espaguete. <br><br>  Em resumo, o problema √© este: as verifica√ß√µes booleanas s√£o usadas para determinar os estados <em>indiretamente</em> .  Os estados l√≥gicos geralmente n√£o s√£o declarados e n√£o s√£o vis√≠veis no c√≥digo.  Como vimos acima, quando o sistema adiciona novos estados l√≥gicos, o c√≥digo existente pode quebrar.  Para evitar isso, os <strong>desenvolvedores devem reexaminar cada verifica√ß√£o e ramifica√ß√£o condicional individual</strong> para garantir que os caminhos de c√≥digo ainda sejam v√°lidos para <em>todos os</em> seus estados l√≥gicos!  Esse √© o principal motivo da degrada√ß√£o de grandes fragmentos de c√≥digo √† medida que se tornam mais complexos. <br><br>  Embora n√£o haja maneiras de se livrar completamente das verifica√ß√µes de dados condicionais, qualquer t√©cnica que as minimize reduz a complexidade do c√≥digo. <br><br>  Vamos agora dar uma olhada em uma implementa√ß√£o t√≠pica orientada a objetos de uma classe que cria um modelo <em>muito</em> simples do volume de √°gua.  A turma gerenciar√° mudan√ßas no estado da subst√¢ncia da √°gua.  Depois de estudar os problemas da solu√ß√£o cl√°ssica para esse problema, discutimos uma nova nota√ß√£o chamada <strong>Frame</strong> e mostramos como ela pode lidar com as dificuldades que descobrimos. <br><br><h3>  Primeiro, deixe a √°gua ferver ... </h3><br>  A ci√™ncia deu nomes a todas as transi√ß√µes poss√≠veis que uma subst√¢ncia pode fazer quando a temperatura muda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/016/dc5/638016dc5b2a19ecd2b677cc40e2ee26.png"></div><br>  Nossa classe √© muito simples (e n√£o √© particularmente √∫til).  Ele responde aos desafios de realizar transi√ß√µes entre estados e altera a temperatura at√© que se torne adequado ao estado de destino desejado: <br><br>  (Nota: escrevi esse pseudoc√≥digo. Use-o no seu trabalho apenas por sua pr√≥pria conta e risco.) <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> temp:<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Water</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(temp:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.temp = temp } <span class="hljs-comment"><span class="hljs-comment">// gas -&gt; solid func depose() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do depose while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // gas -&gt; liquid func condense() { // If not in GAS state, throw an error if (temp &lt; WATER_GAS_TEMP) throw new IllegalStateError() // do condense while (temp &gt; WATER_GAS_TEMP) decreaseTemp(1) } // liquid -&gt; gas func vaporize() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do vaporize while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } // liquid -&gt; solid func freeze() { // If not in LIQUID state, throw an error if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError() // do freeze while (temp &gt; WATER_SOLID_TEMP) decreaseTemp(1) } // solid -&gt; liquid func melt() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do melt while (temp &lt; WATER_SOLID_TEMP) increaseTemp(1) } // solid -&gt; gas func sublimate() { // If not in SOLID state, throw an error if (temp &gt; WATER_SOLID_TEMP) throw new IllegalStateError() // do sublimate while (temp &lt; WATER_GAS_TEMP) increaseTemp(1) } func getState():string { if (temp &lt; WATER_SOLID_TEMP) return "SOLID" if (temp &gt; WATER_GAS_TEMP) return "GAS" return "LIQUID" } }</span></span></code> </pre> <br>  Comparado ao primeiro exemplo, esse c√≥digo possui certas melhorias.  Primeiro, os n√∫meros "m√°gicos" codificados (32, 212) s√£o substitu√≠dos pelas constantes dos limites de temperatura do estado (WATER_SOLID_TEMP, WATER_GAS_TEMP).  Essa mudan√ßa come√ßa a tornar os estados mais expl√≠citos, embora indiretamente. <br><br>  As verifica√ß√µes de ‚Äúprograma√ß√£o defensiva‚Äù tamb√©m aparecem neste c√≥digo, que restringem a chamada do m√©todo se estiver em um estado inadequado para a opera√ß√£o.  Por exemplo, a √°gua n√£o pode congelar se n√£o for um l√≠quido - isso viola a lei (da natureza).  Mas a adi√ß√£o de condi√ß√µes de vigil√¢ncia complica o entendimento do objetivo do c√≥digo.  Por exemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// liquid -&gt; solid if (!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP)) throw new IllegalStateError()</span></span></code> </pre> <br>  Essa verifica√ß√£o condicional faz o seguinte: <br><br><ol><li>  Verifica se a <code>temp</code> inferior √† temperatura limite do GAS </li><li>  Verifica se a <code>temp</code> excede a temperatura limite do SOLID </li><li>  Retorna um erro se uma dessas verifica√ß√µes n√£o for verdadeira </li></ol><br>  Essa l√≥gica √© confusa.  Em primeiro lugar, o estado l√≠quido √© determinado pelo que a subst√¢ncia <strong>n√£o</strong> √© - um s√≥lido ou g√°s. <br><br><pre> <code class="cpp hljs">(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// is liquid?</span></span></code> </pre> <br>  Em segundo lugar, o c√≥digo verifica se a √°gua √© l√≠quida para descobrir se √© necess√°rio retornar um erro. <br><br><pre> <code class="cpp hljs">!(temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-comment"><span class="hljs-comment">// Seriously?</span></span></code> </pre> <br>  A primeira vez que se entende essa dupla nega√ß√£o de estados n√£o √© f√°cil.  Aqui est√° uma simplifica√ß√£o que reduz um pouco a complexidade da express√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLiquidWater = (temp &lt; WATER_GAS_TEMP &amp;&amp; temp &gt; WATER_SOLID_TEMP) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isLiquidWater) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateError()</code> </pre> <br>  Esse c√≥digo √© mais f√°cil de entender porque o estado <strong>isLiquidWater</strong> √© <em>expl√≠cito</em> . <br><br>  Agora estamos explorando t√©cnicas que corrigem um <strong>estado expl√≠cito</strong> como a melhor maneira de resolver problemas.  Com essa abordagem, os estados l√≥gicos do sistema tornam-se a estrutura f√≠sica do software, o que melhora o c√≥digo e simplifica seu entendimento. <br><br><h3>  Nota√ß√£o de m√°quina de estrutura </h3><br>  <strong>A FMN (Frame Machine Notation)</strong> √© uma linguagem espec√≠fica de dom√≠nio (Domain Specific Language, DSL) que define uma abordagem categ√≥rica, metodol√≥gica e simples para definir e implementar v√°rios tipos de <em>m√°quinas</em> .  Por simplicidade, chamarei os aut√¥matos de quadros simplesmente de ‚Äúm√°quinas‚Äù, porque essa nota√ß√£o pode definir crit√©rios te√≥ricos para quaisquer tipos diferentes (m√°quinas de estado, aut√¥matos de loja e a evolu√ß√£o principal dos aut√¥matos - m√°quinas de Turing).  Para conhecer os diferentes tipos de m√°quinas e suas aplica√ß√µes, recomendo estudar a p√°gina na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow noopener">Wikipedia</a> . <br><br>  Embora a teoria dos aut√¥matos possa ser interessante (uma afirma√ß√£o MUITO duvidosa), neste artigo, focaremos na aplica√ß√£o pr√°tica desses poderosos conceitos para construir sistemas e escrever c√≥digo. <br><br>  Para resolver esse problema, o Frame apresenta uma nota√ß√£o padronizada que funciona em tr√™s n√≠veis integrados: <br><br><ol><li>  DSL de texto para definir controladores de quadro com sintaxe elegante e concisa </li><li>  Um conjunto de padr√µes de codifica√ß√£o de refer√™ncia para implementar classes orientadas a objetos na forma de m√°quinas que o Frame chama de "controladores" </li><li>  Nota√ß√£o visual em que o FMN √© usado para expressar opera√ß√µes complexas dif√≠ceis de representar graficamente - <strong>Nota√ß√£o Visual de Quadro (FVN)</strong> </li></ol><br>  Neste artigo, considerarei os dois primeiros pontos: FMN e padr√µes de refer√™ncia e deixarei a discuss√£o da FVN para artigos futuros. <br><br>  Frame √© uma nota√ß√£o que possui v√°rios aspectos importantes: <br><br><ol><li>  O FMN possui objetos de primeiro n√≠vel relacionados ao conceito de aut√¥matos, que n√£o est√£o dispon√≠veis em linguagens orientadas a objetos. </li><li>  A especifica√ß√£o FMN define padr√µes de implementa√ß√£o padr√£o em pseudo-c√≥digo que demonstram como a nota√ß√£o FMN pode ser implementada. </li><li>  Em breve, o FMN poder√° compilar (trabalho em andamento) em qualquer linguagem orientada a objetos </li></ol><br>  Nota: a implementa√ß√£o de refer√™ncia √© usada para demonstrar a equival√™ncia absoluta da nota√ß√£o FMN e uma maneira simples de implement√°-la em qualquer linguagem orientada a objetos.  Voc√™ pode escolher qualquer m√©todo. <br><br>  Agora, apresentarei os dois objetos de primeiro n√≠vel mais importantes em Frame - <strong>Frame Events</strong> e <strong>Frame Controllers</strong> . <br><br><h3>  Eventos de quadro </h3><br>  Os FrameEvents s√£o parte integrante da simplicidade da nota√ß√£o FMN.  Um FrameEvent √© implementado como uma estrutura ou classe que possui pelo menos as seguintes vari√°veis ‚Äã‚Äãde membro: <br><br><ul><li>  ID da mensagem </li><li>  dicion√°rio ou lista de par√¢metros </li><li>  retornar objeto </li></ul><br>  Aqui est√° o pseudoc√≥digo da classe FrameEvent: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-class"> {</span></span> var _msg:String var _params:Object var _return:<span class="hljs-function"><span class="hljs-function">Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FrameEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg:String, params:Object = null)</span></span></span><span class="hljs-function"> </span></span>{ _msg = msg _params = params } }</code> </pre> <br>  A nota√ß√£o de quadro usa o s√≠mbolo <strong>@</strong> , que identifica o objeto FrameEvent.  Cada um dos atributos FrameEvent necess√°rios possui um token especial para acess√°-lo: <br><br><pre> <code class="cpp hljs">@|message| :  -    _msg @[param1] :  []      @^ :              _return</code> </pre> <br>  Frequentemente, n√£o precisamos especificar com o que o FrameEvent funciona.  Como a maioria dos contextos trabalha com apenas um FrameEvent de cada vez, a nota√ß√£o pode definitivamente ser simplificada, de forma que use apenas seletores de atributos.  Portanto, podemos simplificar o acesso: <br><br><pre> <code class="cpp hljs">|buttonClick| <span class="hljs-comment"><span class="hljs-comment">// Select for a "buttonClick" event _msg [firstName] = "Mark" // Set firstName _params property to "Mark" ^ = "YES" // Set the _return object to "YES"</span></span></code> </pre> <br>  Essa nota√ß√£o pode parecer estranha a princ√≠pio, mas em breve veremos como uma sintaxe t√£o simples para eventos simplifica bastante o entendimento do c√≥digo FMN. <br><br><h3>  Controladores de quadro </h3><br>  Um Frame Controller √© uma classe orientada a objetos, ordenada de uma maneira bem definida para implementar uma m√°quina Frame.  Os tipos de controlador s√£o identificados pelo prefixo <strong>#</strong> : <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  isso √© equivalente ao seguinte pseudoc√≥digo orientado a objeto: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span>}</code> </pre> <br>  Obviamente, essa classe n√£o √© particularmente √∫til.  Para que ele possa fazer algo, o controlador precisa de pelo menos um estado para responder aos eventos. <br><br>  Os controladores s√£o estruturados de forma a conter blocos de v√°rios tipos, identificados por um tra√ßo ao redor do nome do tipo de bloco: <br><br><pre> <code class="cpp hljs">#MyController&lt;br&gt; -block <span class="hljs-number"><span class="hljs-number">1</span></span>- -block <span class="hljs-number"><span class="hljs-number">2</span></span>- -block <span class="hljs-number"><span class="hljs-number">3</span></span>-</code> </pre> <br>  Um controlador n√£o pode ter mais de uma inst√¢ncia de cada bloco e os tipos de bloco podem conter apenas certos tipos de subcomponentes.  Neste artigo, examinamos apenas o bloco <strong>-m√°quina-</strong> , que pode conter apenas estados.  Os estados s√£o identificados pelo token de prefixo <strong>$</strong> . <br><br>  Aqui vemos o FMN para um controlador contendo uma m√°quina com apenas um estado: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration</span></span></code> </pre> <br>  Aqui est√° a implementa√ß√£o do c√≥digo FMN acima: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = S1 // initialize state variable // to $S1 func S1(e:FrameEvent) { // state $S1 does nothing } }</span></span></code> </pre> <br>  A implementa√ß√£o do bloco da m√°quina consiste nos seguintes elementos: <br><br><ol><li>  vari√°vel <strong>_state</strong> , que se refere a uma fun√ß√£o do estado atual.  √â inicializado com a primeira fun√ß√£o de estado no controlador. </li><li>  um ou mais m√©todos de estado </li></ol><br>  O m√©todo Frame state √© definido como uma fun√ß√£o com a seguinte assinatura: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span></span>;</code> </pre> <br>  Depois de definir esses fundamentos da implementa√ß√£o do bloco da m√°quina, podemos ver como o objeto FrameEvent interage com a m√°quina. <br><br><h3>  Unidade de interface </h3><br>  A intera√ß√£o dos FrameEvents que controlam a opera√ß√£o da m√°quina √© a pr√≥pria ess√™ncia da simplicidade e poder da nota√ß√£o de quadros.  No entanto, ainda n√£o respondemos √† pergunta, de onde v√™m os FrameEvents - como eles entram no controlador para control√°-lo?  Uma op√ß√£o: os pr√≥prios clientes externos podem criar e inicializar FrameEvents e, em seguida, chamar diretamente o m√©todo apontado pela vari√°vel de membro _state: <br><br><pre> <code class="cpp hljs">myController._state(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  Uma alternativa muito melhor seria criar uma interface comum que envolva uma chamada direta para a vari√°vel de membro _state: <br><br><pre> <code class="cpp hljs">myController.sendEvent(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>))</code> </pre> <br>  No entanto, a maneira mais simples e sem complica√ß√µes, correspondente √† maneira usual de criar software orientado a objetos, √© criar m√©todos comuns que enviam um evento em nome do cliente para a m√°quina interna: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FrameEvent e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameEvent(<span class="hljs-string"><span class="hljs-string">"buttonClick"</span></span>) _state(e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e._return } }</code> </pre> <br>  O quadro define a sintaxe para <strong>um bloco de interface</strong> que cont√©m m√©todos que transformam chamadas em uma interface comum para FrameEvents. <br><br><pre> <code class="cpp hljs">#MyController -interface- buttonClick ...</code> </pre> <br>  O bloco de <code>interface</code> possui muitos outros recursos, mas este exemplo nos d√° uma id√©ia geral de como isso funciona.  Darei mais explica√ß√µes nos seguintes artigos da s√©rie. <br><br>  Agora vamos continuar estudando a opera√ß√£o do aut√¥mato Frame. <br><br><h3>  Manipuladores de eventos </h3><br>  Embora tenhamos mostrado como definir um carro, ainda n√£o temos uma nota√ß√£o com a qual <em>fazer</em> alguma coisa.  Para processar eventos, precisamos 1) poder selecionar o evento que precisa ser processado e 2) anex√°-lo ao comportamento que est√° sendo executado. <br><br>  Aqui est√° um controlador de quadro simples que fornece a infraestrutura para manipular eventos: <br><br><pre> <code class="cpp hljs">#MyController <span class="hljs-comment"><span class="hljs-comment">// controller declaration -machine- // machine block $S1 // state declaration |e1| ^ // e1 event handler and return</span></span></code> </pre> <br>  Como mencionado acima, para acessar o atributo <code>_msg</code> evento <code>_msg</code> , a nota√ß√£o FMN usa colchetes de linhas verticais: <br><br><pre> <code class="cpp hljs">|messageName|</code> </pre> <br>  O FMN tamb√©m usa um token de expoente que representa a instru√ß√£o de retorno.  O controlador mostrado acima ser√° implementado da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #MyController // -machine- var _state(e:FrameEvent) = S1 func S1(e:FrameEvent) { // $S1 if (e._msg == "e1") { // |e1| return // ^ } } }</span></span></code> </pre> <br>  Aqui, vemos com que clareza a nota√ß√£o FMN corresponde a um padr√£o de implementa√ß√£o f√°cil de entender e codificar. <br><br>  Depois de definir esses aspectos b√°sicos de eventos, controladores, m√°quinas, estados e manipuladores de eventos, podemos resolver problemas reais com a ajuda deles. <br><br><h3>  M√°quinas de foco √∫nico </h3><br>  Acima, vimos um controlador sem estado que era bastante in√∫til. <br><br><pre> <code class="cpp hljs">#MyController</code> </pre> <br>  Um passo mais alto na cadeia de utilidade alimentar √© uma classe com um √∫nico estado que, embora n√£o seja in√∫til, √© simplesmente chato.  Mas pelo menos ele est√° fazendo <em>alguma coisa</em> . <br><br>  Primeiro, vamos ver como uma classe com apenas um estado (impl√≠cito) ser√° implementada: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span> } }</code> </pre> <br>  Nenhum estado √© declarado ou mesmo impl√≠cito aqui, mas vamos assumir que, se o c√≥digo fizer alguma coisa, o sistema estar√° no estado "Trabalhando". <br><br>  Tamb√©m apresentaremos uma id√©ia importante: as chamadas de interface ser√£o consideradas semelhantes ao envio de um evento para um objeto.  Portanto, o c√≥digo acima pode ser considerado como um m√©todo de transmiss√£o do | status |  a classe Mono, sempre no estado $ Working. <br><br>  Essa situa√ß√£o pode ser visualizada usando a tabela de liga√ß√£o de eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/81e/7e0/e1b81e7e0916b8354c4092abcc79ab40.png"></div><br>  Agora vamos dar uma olhada no FMN, que demonstra a mesma funcionalidade e corresponde √† mesma tabela de liga√ß√£o: <br><br><pre> <code class="cpp hljs">#Mono -machine- $Working |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>)</code> </pre> <br>  Aqui est√° a apar√™ncia da implementa√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mono</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Mono // -machine- var _state(e:FrameEvent) = Working // initialize start state func Working(e:FrameEvent) { // $Working if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } }</span></span></code> </pre> <br>  Voc√™ pode perceber que tamb√©m introduzimos uma nova nota√ß√£o para a <strong>declara√ß√£o de retorno</strong> , o que significa avaliar a express√£o e retornar o resultado √† interface: <br><br><pre> <code class="cpp hljs">^(return_expr)</code> </pre> <br>  Este operador √© equivalente <br><br><pre> <code class="cpp hljs">@^ = return_expr</code> </pre> <br>  ou apenas <br><br><pre> <code class="cpp hljs">^ = return_expr</code> </pre> <br>  Todos esses operadores s√£o funcionalmente equivalentes e voc√™ pode us√°-los, mas <code>^(return_expr)</code> parece o mais expressivo. <br><br><h3>  Ligue o fog√£o </h3><br>  At√© agora, vimos um controlador com 0 estados e um controlador com 1 estado.  Eles ainda n√£o s√£o muito √∫teis, mas j√° estamos √† beira de algo interessante. <br><br>  Para cozinhar nossas massas, primeiro voc√™ precisa ligar o fog√£o.  A seguir, √© apresentada uma classe Switch simples com uma √∫nica vari√°vel booleana: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch</span></span></span><span class="hljs-class"> {</span></span> boolean _isOn; <span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isOn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ON"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OFF"</span></span>; } } }</code> </pre> <br>  Embora, √† primeira vista, isso n√£o seja √≥bvio, o c√≥digo mostrado acima implementa a seguinte tabela de liga√ß√µes de eventos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ef/5f8/ad7/2ef5f8ad7634c21066e847faf89c8228.png"></div><br>  Para compara√ß√£o, aqui est√° um FMN para o mesmo comportamento: <br><br><pre> <code class="cpp hljs">#Switch1 -machine- $Off |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Agora vemos como exatamente a nota√ß√£o Frame corresponde ao objetivo do nosso c√≥digo - anexar um evento (chamada de m√©todo) ao comportamento com base no estado em que o controlador est√° localizado.  Al√©m disso, a estrutura de implementa√ß√£o tamb√©m corresponde √† tabela de liga√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch1 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { // $Off if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { // $On if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  A tabela permite que voc√™ entenda rapidamente a finalidade do controlador em seus v√°rios estados.  A estrutura de nota√ß√£o de quadro e o padr√£o de implementa√ß√£o t√™m vantagens semelhantes. <br><br>  No entanto, nosso switch tem um problema funcional percept√≠vel.  √â inicializado no estado $ Off, mas n√£o pode alternar para o estado $ On!  Para fazer isso, precisamos inserir um operador de <strong>mudan√ßa de estado</strong> . <br><br><h3>  Alterar estado </h3><br>  <strong>A declara√ß√£o de mudan√ßa de estado √© a</strong> seguinte: <br><br><pre> <code class="cpp hljs">-&gt;&gt; $NewState</code> </pre> <br>  Agora podemos usar esse operador para alternar entre $ Off e $ On: <br><br><pre> <code class="cpp hljs">#Switch2 -machine- $Off |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  E aqui est√° a tabela de liga√ß√£o de evento correspondente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/08f/688/b0208f68897eb1412f386392e8779247.png"></div><br>  Novo evento | alternar |  agora desencadeia uma mudan√ßa que simplesmente percorre os dois estados.  Como uma opera√ß√£o de mudan√ßa de estado pode ser implementada? <br><br>  Nenhum lugar √© mais f√°cil.  Aqui est√° a implementa√ß√£o do Switch2: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch2 // -machine- var _state(e:FrameEvent) = Off func Off(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } func On(e:FrameEvent) { if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^("OFF") } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br>  Voc√™ tamb√©m pode fazer o √∫ltimo aprimoramento no Switch2, para que ele n√£o apenas permita alternar entre estados, mas tamb√©m defina explicitamente o estado: <br><br><pre> <code class="cpp hljs">#Switch3 -machine- $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"OFF"</span></span>) $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^(<span class="hljs-string"><span class="hljs-string">"ON"</span></span>)</code> </pre> <br>  Diferente do evento | toggle |, se | turnOn |  transmitida quando o Switch3 j√° est√° ligado ou | desligar | quando j√° est√° desligado, a mensagem √© ignorada e nada acontece.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Essa pequena melhoria oferece ao cliente a capacidade de indicar explicitamente o estado em que o comutador deve estar: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Switch3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Switch3 // -machine- var _state(e:FrameEvent) = Off /********************************** $Off |turnOn| -&gt;&gt; $On ^ |toggle| -&gt;&gt; $On ^ |status| ^("OFF") ***********************************/ func Off(e:FrameEvent) { if (e._msg == "turnOn") { // |turnOn| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "toggle") { // |toggle| _state = On // -&gt;&gt; $On return // ^ } if (e._msg == "status") { // |status| e._return = "OFF" return // ^("OFF") } } /********************************** $On |turnOff| -&gt;&gt; $Off ^ |toggle| -&gt;&gt; $Off ^ |status| ^("ON") ***********************************/ func On(e:FrameEvent) { if (e._msg == "turnOff") { // |turnOff| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "toggle") { // |toggle| _state = Off // -&gt;&gt; $Off return // ^ } if (e._msg == "status") { // |status| e._return = "ON" return // ^("ON") } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O passo final na evolu√ß√£o do nosso switch mostra como √© f√°cil entender o objetivo do controlador FMN. </font><font style="vertical-align: inherit;">O c√≥digo relevante demonstra como √© f√°cil implementar usando os mecanismos Frame. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de criar a m√°quina Switch, podemos acender o fogo e come√ßar a cozinhar!</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estado do som </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um aspecto chave, embora sutil, dos aut√¥matos √© que o estado atual da m√°quina √© o resultado de uma situa√ß√£o (por exemplo, ligar) ou de algum tipo de an√°lise de dados ou do ambiente. </font><font style="vertical-align: inherit;">Quando a m√°quina mudou para o estado desejado, ela est√° impl√≠cita. </font><font style="vertical-align: inherit;">que a situa√ß√£o n√£o vai mudar sem o conhecimento do carro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, essa suposi√ß√£o nem sempre √© verdadeira. </font><font style="vertical-align: inherit;">Em algumas situa√ß√µes, a verifica√ß√£o (ou "detec√ß√£o") dos dados √© necess√°ria para determinar o estado l√≥gico atual:</font></font><br><br><ol><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado restaurado inicial</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - quando a m√°quina √© restaurada de um estado constante</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado externo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - define a ‚Äúsitua√ß√£o real‚Äù existente no ambiente no momento da cria√ß√£o, restaura√ß√£o ou opera√ß√£o da m√°quina</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado interno vol√°til</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - quando parte dos dados internos gerenciados por uma m√°quina em execu√ß√£o pode mudar fora do controle da m√°quina</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em todos esses casos, dados, ambiente ou ambos devem ser "analisados" para determinar a situa√ß√£o e definir o estado da m√°quina de acordo. </font><font style="vertical-align: inherit;">Idealmente, essa l√≥gica booleana pode ser implementada em uma √∫nica fun√ß√£o que define o estado l√≥gico correto. </font><font style="vertical-align: inherit;">Para suportar esse padr√£o, a nota√ß√£o de quadro tem um tipo especial de fun√ß√£o que investiga o universo e determina a situa√ß√£o no momento atual. </font><font style="vertical-align: inherit;">Tais fun√ß√µes s√£o indicadas pelo prefixo </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> antes do nome do m√©todo que retorna um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link para o estado</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em nossa situa√ß√£o, esse m√©todo pode ser implementado da seguinte maneira: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probeForState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:FrameState </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Solid <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &lt; <span class="hljs-number"><span class="hljs-number">212</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Liquid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Gas }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como podemos ver, o m√©todo simplesmente retorna uma refer√™ncia √† fun√ß√£o state correspondente ao estado l√≥gico correto. </font><font style="vertical-align: inherit;">Essa fun√ß√£o de detec√ß√£o pode ser usada para entrar no estado correto:</font></font><br><br><pre> <code class="cpp hljs">-&gt;&gt; $probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O mecanismo de implementa√ß√£o fica assim: </font></font><br><br><pre> <code class="cpp hljs">_state = probeForState()</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo de detec√ß√£o de estado √© um exemplo de nota√ß√£o de quadro para gerenciar estado de uma determinada maneira. </font><font style="vertical-align: inherit;">Em seguida, tamb√©m aprenderemos a nota√ß√£o importante para gerenciar os FrameEvents.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Heran√ßa comportamental e despachante </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A heran√ßa comportamental e o dispatcher</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o um poderoso paradigma de programa√ß√£o e o √∫ltimo t√≥pico sobre a nota√ß√£o de quadros neste artigo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O uso de quadros usa heran√ßa de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comportamento</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , n√£o heran√ßa de dados ou outros atributos. </font><font style="vertical-align: inherit;">Para esse estado, os FrameEvents s√£o enviados para outros estados se o estado inicial n√£o manipular o evento (ou, como veremos nos pr√≥ximos artigos, apenas desejar transmiti-lo). </font><font style="vertical-align: inherit;">Essa cadeia de eventos pode atingir qualquer profundidade desejada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para isso, as m√°quinas podem ser implementadas usando uma t√©cnica chamada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encadeamento de m√©todos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">A nota√ß√£o FMN para enviar eventos de um estado para outro √© o </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expedidor </font></font></strong> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs">$S1 =&gt; $S2</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta declara√ß√£o FMN pode ser implementada da seguinte maneira: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">func </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e:FrameEvent)</span></span></span><span class="hljs-function"> </span></span>{ S2(e) <span class="hljs-comment"><span class="hljs-comment">// $S1 =&gt; $S2 }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vemos como √© f√°cil encadear m√©todos de estado. </font><font style="vertical-align: inherit;">Vamos aplicar esta t√©cnica a uma situa√ß√£o bastante dif√≠cil:</font></font><br><br><pre> <code class="cpp hljs">#Movement -machine- $Walking =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">3</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Running =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">6</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Crawling =&gt; $Moving |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">.5</span></span>) |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $AtAttention =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $LyingDown =&gt; $Motionless |isStanding| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) $Moving |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) $Motionless |getSpeed| ^(<span class="hljs-number"><span class="hljs-number">0</span></span>) |isMoving| ^(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No c√≥digo acima, vemos que existem dois estados b√°sicos - $ Moving e $ Motionless - e os outros cinco estados herdam uma funcionalidade importante deles. </font><font style="vertical-align: inherit;">A liga√ß√£o de evento mostra claramente como ser√£o as liga√ß√µes em geral:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/117/95d/97c/11795d97c6a96d32824dc9ac2ddf62dc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gra√ßas √†s t√©cnicas que aprendemos, a implementa√ß√£o ser√° muito simples: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Movement</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// #Movement // -machine- /********************************** $Walking =&gt; $Moving |getSpeed| ^(3) |isStanding| ^(true) ***********************************/ func Walking(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 3 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Walking =&gt; $Moving } /********************************** $Running =&gt; $Moving |getSpeed| ^(6) |isStanding| ^(true) ***********************************/ func Running(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 6 return } if (e._msg == "isStanding") { e._return = true return } Moving(e) // $Running =&gt; $Moving } /********************************** $Crawling =&gt; $Moving |getSpeed| ^(.5) |isStanding| ^(false) ***********************************/ func Crawling(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = .5 return } if (e._msg == "isStanding") { e._return = false return } Moving(e) // $Crawling =&gt; $Moving } /********************************** $AtAttention =&gt; $Motionless |isStanding| ^(true) ***********************************/ func AtAttention(e:FrameEvent) { if (e._msg == "isStanding") { e._return = true return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $LyingDown =&gt; $Motionless |isStanding| ^(false) ***********************************/ func LyingDown(e:FrameEvent) { if (e._msg == "isStanding") { e._return = false return } Motionless(e) // $AtAttention =&gt; $Motionless } /********************************** $Moving |isMoving| ^(true) ***********************************/ func Moving(e:FrameEvent) { if (e._msg == "isMoving") { e._return = true return } } /********************************** $Motionless |getSpeed| ^(0) |isMoving| ^(false) ***********************************/ func Motionless(e:FrameEvent) { if (e._msg == "getSpeed") { e._return = 0 return } if (e._msg == "isMoving") { e._return = false return } } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√°quina de √°gua </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, temos os conhecimentos b√°sicos sobre FMN, permitindo entender como reimplementar a classe WaterSample com estados e de uma maneira muito mais inteligente. </font><font style="vertical-align: inherit;">Tamb√©m o tornaremos √∫til para o f√≠sico de nossos alunos de p√≥s-gradua√ß√£o e adicionaremos um novo estado $ Plasma:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/d16/64d/afbd1664dacfde5e4857c45e35ee33ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Veja como √© a implementa√ß√£o completa da FMN: </font></font><br><br><pre> <code class="cpp hljs">#WaterSample -machine- $Begin |create| <span class="hljs-comment"><span class="hljs-comment">// set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |getState| ^("SOLID") $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, temos o estado inicial de $ Begin, que responde √† mensagem | create | e ret√©m valor </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A fun√ß√£o de detec√ß√£o verifica primeiro o valor inicial </font></font><code>temp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar o estado l√≥gico e, em seguida, executa a transi√ß√£o da m√°quina para esse estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todos os estados f√≠sicos ($ S√≥lido, $ L√≠quido, $ G√°s, $ Plasma) herdam o comportamento de prote√ß√£o do estado $ Padr√£o. Todos os eventos que n√£o s√£o v√°lidos para o estado atual s√£o passados ‚Äã‚Äãpara o estado $ Default, que gera um erro InvalidStateError. Isso mostra como a simples programa√ß√£o defensiva pode ser implementada usando a heran√ßa de comportamento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E agora a implementa√ß√£o:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaterSample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// -machine- var _state(e:FrameEvent) = Begin /********************************** $Begin |create| // set temp to the event param value setTemp(@[temp]) // probe for temp state and change to it -&gt;&gt; $probeForState() ^ ***********************************/ func Begin(e:FrameEvent) { if (e._msg == "create") { setTemp(e["temp"]) _state = probeForState() return } } /********************************** $Solid =&gt; $Default |melt| doMelt() -&gt;&gt; $Liquid ^ |sublimate| doSublimate() -&gt;&gt; $Gas ^ |sublimate| ^("SOLID") ***********************************/ func Solid(e:FrameEvent) { if (e._msg == "melt") { doMelt() _state = Liquid return } if (e._msg == "sublimate") { doSublimate() _state = Gas return } if (e._msg == "getState") { e._return = "SOLID" return } Default(e) } /********************************** $Liquid =&gt; $Default |freeze| doFreeze() -&gt;&gt; $Solid ^ |vaporize| doVaporize() -&gt;&gt; $Gas ^ |getState| ^("LIQUID") ***********************************/ func Liquid(e:FrameEvent) { if (e._msg == "freeze") { doFreeze() _state = Solid return } if (e._msg == "vaporize") { doVaporize() _state = Gas return } if (e._msg == "getState") { e._return = "LIQUID" return } Default(e) } /********************************** $Gas =&gt; $Default |condense| doCondense() -&gt;&gt; $Liquid ^ |depose| doDepose() -&gt;&gt; $Solid ^ |ionize| doIonize() -&gt;&gt; $Plasma ^ |getState| ^("GAS") ***********************************/ func Gas(e:FrameEvent) { if (e._msg == "condense") { doCondense() _state = Liquid return } if (e._msg == "depose") { doDepose() _state = Solid return } if (e._msg == "ionize") { doIonize() _state = Plasma return } if (e._msg == "getState") { e._return = "GAS" return } Default(e) } /********************************** $Plasma =&gt; $Default |recombine| doRecombine() -&gt;&gt; $Gas ^ |getState| ^("PLASMA") ***********************************/ func Plasma(e:FrameEvent) { if (e._msg == "recombine") { doRecombine() _state = Gas return } if (e._msg == "getState") { e._return = "PLASMA" return } Default(e) } /********************************** $Default |melt| throw new InvalidStateError() |sublimate| throw new InvalidStateError() |freeze| throw new InvalidStateError() |vaporize| throw new InvalidStateError() |condense| throw InvalidStateError() |depose| throw InvalidStateError() |ionize| throw InvalidStateError() |recombine| throw InvalidStateError() |getState| throw InvalidStateError() ***********************************/ func Default(e:FrameEvent) { if (e._msg == "melt") { throw new InvalidStateError() } if (e._msg == "sublimate") { throw new InvalidStateError() } if (e._msg == "freeze") { throw new InvalidStateError() } if (e._msg == "vaporize") { throw new InvalidStateError() } if (e._msg == "condense") { throw new InvalidStateError() } if (e._msg == "depose") { throw new InvalidStateError() } if (e._msg == "ionize") { throw new InvalidStateError() } if (e._msg == "recombine") { throw new InvalidStateError() } if (e._msg == "getState") { throw new InvalidStateError() } } }</span></span></code> </pre> <br><h3>  Conclus√£o </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aut√¥matos √© um conceito b√°sico de ci√™ncia da computa√ß√£o que tem sido usado por muito tempo apenas em √°reas especializadas de desenvolvimento de software e hardware. A principal tarefa do Frame √© criar uma nota√ß√£o para descrever aut√¥matos e definir padr√µes simples para escrever c√≥digo ou "mecanismos" para sua implementa√ß√£o. Espero que a nota√ß√£o de quadro mude a maneira como os programadores veem as m√°quinas, fornecendo uma maneira f√°cil de coloc√°-las em pr√°tica nas tarefas di√°rias de programa√ß√£o e, √© claro, salv√°-las de espaguete no c√≥digo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/041/f9d/411041f9dac0d4b6b9901a9528939495.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Terminator come macarr√£o (foto de Suzuki san)</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em artigos futuros, com base nos conceitos que aprendemos, criaremos ainda mais poder e expressividade da nota√ß√£o FMN. </font><font style="vertical-align: inherit;">Com o tempo, expandirei a discuss√£o para um estudo de modelagem visual, que inclui FMN e resolve os problemas de comportamento incerto nas abordagens modernas da modelagem de software.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446330/">https://habr.com/ru/post/pt446330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446320/index.html">Como o scanner 3D permitiu abandonar o conjunto de controle em escala real da ponte</a></li>
<li><a href="../pt446322/index.html">Criptografia em Java. Utilit√°rio Keytool</a></li>
<li><a href="../pt446324/index.html">Navega√ß√£o no DataGrip com Yandex.Navigator</a></li>
<li><a href="../pt446326/index.html">Resolvendo problemas de tr√°fego</a></li>
<li><a href="../pt446328/index.html">Por que precisamos de servi√ßos de recep√ß√£o de SMS e com o que eles comem</a></li>
<li><a href="../pt446332/index.html">IBM System i (aka AS / 400) - Como fizemos testes autom√°ticos de aplicativos em tela verde</a></li>
<li><a href="../pt446334/index.html">Reflex√µes sobre uma carreira em TI e dicas para iniciantes</a></li>
<li><a href="../pt446336/index.html">Como banir senhas padr√£o e fazer com que todos te odeiem</a></li>
<li><a href="../pt446338/index.html">SVG 3D: criar, girar e animar</a></li>
<li><a href="../pt446340/index.html">Sistemas operacionais: tr√™s pe√ßas f√°ceis. Parte 1: Introdu√ß√£o (tradu√ß√£o)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>