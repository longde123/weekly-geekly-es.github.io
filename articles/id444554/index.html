<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸš’ ğŸ½ï¸ ğŸ¦– API tenang JSON sederhana di Elixir ğŸ’‡ğŸ¼ ğŸ¥  ğŸ¤‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara mengimplementasikan JSON endpoint API di Elixir tanpa kerangka kerja? 


 Dari penerjemah: 
 Artikel ini memberikan contoh aplikasi web...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API tenang JSON sederhana di Elixir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444554/"><p>  <strong>Bagaimana cara mengimplementasikan JSON endpoint API di Elixir tanpa kerangka kerja?</strong> </p><br><p>  <em>Dari penerjemah:</em> <em><br></em>  <em>Artikel ini memberikan contoh aplikasi web yang sangat sederhana yang dapat dianggap sebagai Hello, World!</em>  <em>dalam membuat API paling sederhana di Elixir.</em> <em><br></em>  <em>Kode sampel sedikit dimodifikasi untuk mencocokkan versi perpustakaan saat ini.</em> <em><br></em>  <em>Kode sampel lengkap dengan perubahan dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/vheathen/elixir-">dilihat di GitHub</a> .</em> </p><br><p><img src="https://habrastorage.org/webt/4u/ez/x7/4uezx7-azvbu2fk6bbbkj1veqdw.jpeg"></p><br><h2 id="problemy-novogo-yazyka">  Tantangan Bahasa Baru </h2><br><p>  Banyak pengembang datang ke Elixir dari <strong>dunia Ruby.</strong>  <strong>Ini adalah lingkungan yang sangat matang</strong> dalam hal jumlah perpustakaan dan kerangka kerja yang tersedia.  Dan kedewasaan seperti itu terkadang tidak cukup bagi saya di Elixir.  Ketika saya membutuhkan layanan pihak ketiga, hasil pencarian yang sesuai mungkin sebagai berikut: </p><a name="habracut"></a><br><ul><li>  ada perpustakaan resmi yang didukung dengan baik (sangat jarang); </li><li>  ada perpustakaan yang resmi, tetapi sudah ketinggalan zaman atau bermasalah (kadang-kadang terjadi); </li><li>  Ada perpustakaan yang didukung dengan baik yang dikembangkan oleh seseorang dari komunitas (kadang-kadang dari waktu ke waktu); </li><li>  ada perpustakaan yang dikembangkan oleh seseorang dari komunitas, tetapi tidak lagi didukung (kasus yang sangat umum); </li><li>  ada beberapa perpustakaan, yang masing-masing ditulis oleh seseorang untuk kebutuhan mereka sendiri, dan tidak memiliki fitur yang diperlukan (opsi paling populer); </li><li>  ada perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya sendiri</a> , menggabungkan semua yang terbaik di atas ... (terlalu sering ditemukan). </li></ul><br><h2 id="prostoe-json-api-na-eliksire">  API JSON sederhana di Elixir </h2><br><p><img src="https://habrastorage.org/webt/3k/3b/7u/3k3b7ugydkdw_7bcsz_hk3-ytdq.jpeg"></p><br><p>  Anda mungkin terkejut, tetapi <strong>Ruby tidak selalu <em>di</em> rel</strong> ( <em>Ruby on Rails, ingat? - Catatan Penerjemah</em> ).  Komunikasi dengan web juga tidak selalu diperlukan untuk hadir.  Meskipun dalam kasus khusus ini, mari kita bicara tentang web. </p><br><p>  Ketika mengimplementasikan titik akhir RESTful tunggal, biasanya ada banyak pilihan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi rak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hanami</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinatra</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anggur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rails :: API</a> </li></ul><br><p>  Ini adalah contoh alat yang saya gunakan secara pribadi.  Rekan-rekan saya puas dengan pengguna Sinatra.  Mereka berhasil mencoba Hanami.  Saya dapat memilih opsi yang cocok untuk saya, bahkan tergantung pada suasana hati saya saat ini. </p><br><p>  Tetapi ketika saya beralih ke Elixir, ternyata pilihannya terbatas.  Meskipun ada beberapa "kerangka" alternatif (yang namanya karena alasan yang jelas tidak akan saya sebutkan di sini), hampir tidak mungkin untuk menggunakannya! </p><br><p>  Saya menghabiskan sepanjang hari memilah-milah setiap perpustakaan yang pernah disebutkan di Internet.  Bertindak sebagai bot Slack, saya mencoba <strong>menggunakan server HTTP2 sederhana untuk Heroku</strong> , tetapi menyerah pada akhir hari.  Secara harfiah, tidak ada opsi yang saya temukan dapat menerapkan persyaratan dasar. </p><br><h2 id="ne-vsegda-reshenie---phoenix">  Tidak selalu solusi - Phoenix </h2><br><p>  <strong>Phoenix adalah kerangka web favorit saya, hanya saja kadang-kadang berlebihan.</strong>  Saya tidak ingin menggunakannya, menarik seluruh kerangka kerja ke dalam proyek semata-mata demi satu titik akhir;  dan tidak masalah bahwa itu sangat sederhana. </p><br><p>  Saya juga tidak bisa menggunakan perpustakaan yang sudah jadi, karena, seperti yang sudah saya katakan, semua perpustakaan yang saya temukan tidak cocok untuk kebutuhan saya (diperlukan perutean dasar dan dukungan JSON), atau tidak cukup nyaman untuk penyebaran Heroku yang mudah dan cepat.  Ambil langkah mundur, pikirku. </p><br><p><img src="https://habrastorage.org/webt/jf/qg/yl/jfqgylkj7urywy09ic2tqtmlnic.jpeg"></p><br><p>  Tapi sebenarnya, Phoenix sendiri dibangun berdasarkan <em>sesuatu</em> , bukan? </p><br><h2 id="plug--cowboy-prihodyat-na-pomosch">  Pasang &amp; Koboi datang untuk menyelamatkan </h2><br><p> Jika Anda perlu membuat server yang benar-benar minimalis di Ruby, Anda cukup menggunakan <code>rack</code> - antarmuka modular untuk server web Ruby. </p><br><p>  Untungnya, sesuatu yang serupa tersedia di Elixir.  Dalam hal ini, kami akan menggunakan elemen-elemen berikut: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cowboy</a> adalah server HTTP kecil dan cepat untuk Erlang / OTP yang mengimplementasikan stack HTTP penuh dan routing, dioptimalkan untuk meminimalkan latensi dan penggunaan memori; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plug</a> - satu set adapter untuk berbagai server web yang berjalan di Erlang VM;  setiap adaptor menyediakan antarmuka langsung ke server web yang terletak di belakangnya; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">poison</a> adalah perpustakaan untuk memproses JSON di Elixir. </li></ul><br><h1 id="realizaciya">  Implementasi </h1><br><p>  Saya ingin mengimplementasikan komponen seperti Endpoint (endpoint), Router (router) dan JSON Parser (JSON handler).  Kemudian saya ingin menggunakan hasilnya pada Heroku dan dapat memproses permintaan yang masuk.  Mari kita lihat bagaimana ini bisa dicapai. </p><br><h2 id="prilozhenie">  Aplikasi </h2><br><p>  Pastikan proyek Elixir Anda berisi seorang supervisor.  Untuk melakukan ini, buat proyek seperti ini: </p><br><pre> <code class="plaintext hljs">mix new minimal_server --sup</code> </pre> <br><p>  Pastikan mix.exs mengandung: </p><br><pre> <code class="plaintext hljs">def application do [ extra_applications: [:logger], mod: {MinimalServer.Application, []} ] end</code> </pre> <br><p>  dan buat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">file</a> <code>lib/minimal_server/application.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do use Application def start(_type, _args), do: Supervisor.start_link(children(), opts()) defp children do [] end defp opts do [ strategy: :one_for_one, name: MinimalServer.Supervisor ] end end</code> </pre> <br><h2 id="biblioteki">  Perpustakaan </h2><br><p>  Pustaka berikut harus ditentukan dalam <code>mix.exs</code> : </p><br><pre> <code class="plaintext hljs">defp deps do [ {:poison, "~&gt; 4.0"}, {:plug, "~&gt; 1.7"}, {:cowboy, "~&gt; 2.5"}, {:plug_cowboy, "~&gt; 2.0"} ] end</code> </pre> <br><p>  Kemudian unduh dan kompilasi dependensi: </p><br><pre> <code class="plaintext hljs">mix do deps.get, deps.compile, compile</code> </pre> <br><h2 id="endpoint">  Titik akhir </h2><br><p>  Sekarang semuanya siap untuk membuat titik masuk ke server.  Mari kita membuat file <code>lib/minimal_server/endpoint.ex</code> dengan konten berikut: </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do use Plug.Router plug(:match) plug(Plug.Parsers, parsers: [:json], pass: ["application/json"], json_decoder: Poison ) plug(:dispatch) match _ do send_resp(conn, 404, "Requested page not found!") end end</code> </pre> <br><p>  Modul <code>Plug</code> berisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Plug.Router</code></a> untuk mengarahkan ulang permintaan yang masuk tergantung pada jalur yang digunakan dan metode HTTP.  Setelah menerima permintaan, router akan memanggil module <code>:match</code> , diwakili oleh fungsi <code>match/2</code> , yang bertanggung jawab untuk menemukan rute yang sesuai, dan kemudian mengarahkannya ke module <code>:dispatch</code> , yang akan menjalankan kode yang sesuai. </p><br><p>  Karena kami ingin API kami sesuai dengan JSON, kami perlu mengimplementasikan <code>Plug.Parsers</code> .  Karena memproses permintaan <code>application/json</code> dengan diberikan <code>:json_decoder</code> , kita akan menggunakannya untuk menganalisis tubuh permintaan. </p><br><p>  Akibatnya, kami membuat rute sementara "permintaan apa pun" yang cocok dengan semua permintaan dan merespons dengan kode HTTP not found (404). </p><br><h2 id="marshrutizator">  Router </h2><br><p>  Menerapkan router akan menjadi langkah terakhir dalam membuat aplikasi kita.  Ini adalah elemen terakhir dari keseluruhan pipa yang kami buat: dimulai dengan menerima permintaan dari browser web dan diakhiri dengan pembentukan respons. </p><br><p>  Router akan memproses permintaan yang masuk dari klien dan mengirimkan kembali beberapa pesan dalam format yang diinginkan ( <em>tambahkan kode di atas ke file <code>lib/minimal_server/router.ex</code> - catatan penerjemah</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Router do use Plug.Router plug(:match) plug(:dispatch) get "/" do conn |&gt; put_resp_content_type("application/json") |&gt; send_resp(200, Poison.encode!(message())) end defp message do %{ response_type: "in_channel", text: "Hello from BOT :)" } end end</code> </pre> <br><p>  Dalam modul <code>Router</code> atas, permintaan hanya akan diproses jika dikirim dengan metode <code>GET</code> dan dikirim di sepanjang rute <code>/</code> .  Modul Router akan merespons dengan header <code>Content-Type</code> berisi <code>application/json</code> dan tubuh: </p><br><pre> <code class="plaintext hljs">{ "response_type": "in_channel", "text": "Hello from BOT :)" }</code> </pre> <br><h2 id="soberyom-vsyo-vmeste">  Menyatukan semuanya </h2><br><p>  Sekarang adalah waktunya untuk mengubah modul <code>Endpoint</code> untuk meneruskan permintaan ke router dan memodifikasi <code>Application</code> untuk meluncurkan modul <code>Endpoint</code> itu sendiri. </p><br><p>  Yang pertama dapat dilakukan dengan menambahkan ke <code>MinimalServer.Endpoint</code> [ <em>sebelum <code>match _ do ... end</code> rule - approx.</em>  <em>translator</em> ] string </p><br><pre> <code class="plaintext hljs">forward("/bot", to: MinimalServer.Router)</code> </pre> <br><p>  Ini memastikan bahwa semua permintaan ke <code>/bot</code> akan dialihkan ke dan diproses oleh modul <code>Router</code> . </p><br><p>  Yang kedua dapat diimplementasikan dengan menambahkan fungsi <code>child_spec/1</code> dan <code>start_link/1</code> file <code>endpoint.ex</code> : </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... def child_spec(opts) do %{ id: __MODULE__, start: {__MODULE__, :start_link, [opts]} } end def start_link(_opts), do: Plug.Cowboy.http(__MODULE__, []) end</code> </pre> <br><p>  Sekarang Anda dapat memodifikasi <code>application.ex</code> dengan menambahkan <code>MinimalServer.Endpoint</code> ke daftar yang dikembalikan oleh fungsi <code>children/0</code> . </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Application do # ... defp children do [ MinimalServer.Endpoint ] end end</code> </pre> <br><p>  Untuk memulai server, lakukan saja: </p><br><pre> <code class="plaintext hljs">mix run --no-halt</code> </pre> <br><p>  Akhirnya Anda bisa mengunjungi alamat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http: // localhost: 4000 / bot</a> dan lihat pesan kami :) </p><br><h1 id="razvertyvanie">  Penempatan </h1><br><p><img src="https://habrastorage.org/webt/kf/8j/cb/kf8jcbh1srxmbcpbxl_9yhnkckg.jpeg"></p><br><h2 id="konfig">  Konfigurasi </h2><br><p>  Paling sering, di lingkungan lokal dan untuk operasi, server dikonfigurasi secara berbeda.  Karena itu, kita perlu memasukkan pengaturan terpisah untuk masing-masing mode ini.  Pertama-tama, <code>config.exs</code> kami dengan menambahkan: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: 4000</code> </pre> <br><p>  Dalam hal ini, ketika aplikasi mulai dalam mode <code>test</code> , <code>prod</code> dan <code>dev</code> , ia akan menerima port 4000 jika pengaturan ini tidak diubah. </p><br><div class="spoiler">  <b class="spoiler_title">Dari penerjemah</b> <div class="spoiler_text"><p>  Pada titik ini, penulis teks asli lupa menyebutkan cara memodifikasi config.exs sehingga Anda dapat menggunakan opsi yang berbeda untuk mode yang berbeda.  Untuk melakukan ini, tambahkan <code>import_config "#{Mix.env()}.exs"</code> ; di baris terakhir di <code>config/config.exs</code> ;  hasilnya adalah sesuatu seperti: </p><br><pre> <code class="plaintext hljs">use Mix.Config config :minimal_server, MinimalServer.Endpoint, port: 4000 import_config "#{Mix.env()}.exs"</code> </pre> <br><p>  Setelah itu, buat file <code>prod.exs</code> , <code>test.exs</code> , <code>dev.exs</code> di direktori <code>config</code> dengan menempatkannya di setiap baris: </p><br><pre> <code class="plaintext hljs">use Mix.Config</code> </pre> </div></div><br><p>  Dalam produksi, kami biasanya tidak ingin mengatur nomor port keras, tetapi bergantung pada beberapa variabel lingkungan sistem, misalnya: </p><br><pre> <code class="plaintext hljs">config :minimal_server, MinimalServer.Endpoint, port: "PORT" |&gt; System.get_env() |&gt; String.to_integer()</code> </pre> <br><p>  <em>Tambahkan teks di atas ke akhir <code>config/prod.exs</code> - kira-kira.</em>  <em>penerjemah</em> </p><br><p>  Setelah itu, nilai tetap akan digunakan secara lokal, dan dalam operasi operasional, konfigurasi variabel lingkungan. </p><br><p>  Mari kita implementasikan skema ini di <code>endpoint.ex</code> , ( <em>mengganti fungsi start_link / 1 - komentar penerjemah</em> ): </p><br><pre> <code class="plaintext hljs">defmodule MinimalServer.Endpoint do # ... require Logger def start_link(_opts) do with {:ok, [port: port] = config} &lt;- Application.fetch_env(:minimal_server, __MODULE__) do Logger.info("Starting server at http://localhost:#{port}/") Plug.Adapters.Cowboy2.http(__MODULE__, [], config) end end end</code> </pre> <br><h2 id="heroku">  Heroku </h2><br><p>  Heroku menawarkan penyebaran satu klik paling sederhana tanpa pengaturan rumit.  Untuk menggunakan proyek kami, <strong>Anda perlu menyiapkan beberapa file sederhana dan membuat aplikasi jarak jauh</strong> . </p><br><p><img src="https://habrastorage.org/webt/ro/x_/dh/rox_dhu_pwqqvdetmn-hwtjasb0.png"></p><br><p>  Setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginstal Heroku CLI,</a> Anda dapat membuat aplikasi baru sebagai berikut: </p><br><pre> <code class="plaintext hljs">$ heroku create minimal-server-habr Creating â¬¢ minimal-server-habr... done https://minimal-server-habr.herokuapp.com/ | https://git.heroku.com/minimal-server-habr.git</code> </pre> <br><p>  Sekarang tambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Elixir Build Kit</a> ke aplikasi Anda: </p><br><pre> <code class="plaintext hljs">heroku buildpacks:set \ https://github.com/HashNuke/heroku-buildpack-elixir.git</code> </pre> <br><p>  Pada saat terjemahan ini, versi Elixir dan Erlang saat ini adalah (plus atau minus): </p><br><pre> <code class="plaintext hljs">erlang_version=21.1 elixir_version=1.8.1</code> </pre> <br><p>  Untuk mengkonfigurasi kit bangun itu sendiri, tambahkan baris di atas ke file <code>elixir_buildpack.config</code> . </p><br><p>  Langkah terakhir adalah membuat Procfile, dan, sekali lagi, ini sangat sederhana: </p><br><pre> <code class="plaintext hljs">web: mix run --no-halt</code> </pre> <br><p>  <em>Catatan Penerjemah: untuk menghindari kesalahan selama pembuatan di Heroku, Anda harus menetapkan nilai variabel lingkungan yang digunakan dalam aplikasi:</em> </p><br><pre> <code class="plaintext hljs">$ heroku config:set PORT=4000 Setting PORT and restarting â¬¢ minimal-server-habr... done, v5 PORT: 4000</code> </pre> <br><p>  Segera setelah Anda mengkomit file baru [ <em>menggunakan git - kira - kira.</em>  <em>penerjemah</em> ], Anda dapat mengunggahnya ke Heroku: </p><br><pre> <code class="plaintext hljs">$ git push heroku master Initializing repository, done. updating 'refs/heads/master' ...</code> </pre> <br><p>  Dan itu saja!  Aplikasi ini tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://minimal-server-habr.herokuapp.com</a> . </p><br><h1 id="rezyume">  Ringkasan </h1><br><p>  Pada titik ini, Anda sudah mengerti bagaimana <strong>menerapkan API JSON RESTful dan server HTTP paling sederhana ke Elixir</strong> tanpa menggunakan kerangka kerja apa pun, hanya menggunakan 3 ( <em>sekitar 4 - Penerjemah</em> ) perpustakaan. </p><br><p>  Ketika Anda perlu memberikan akses ke titik akhir sederhana, Anda benar-benar tidak perlu menggunakan Phoenix setiap kali, tidak peduli seberapa keren itu, serta kerangka kerja lainnya. </p><br><p>  Penasaran mengapa tidak ada kerangka kerja yang andal, teruji dan didukung di suatu tempat antara <code>plug</code> + <code>cowboy</code> dan Phoenix?  Mungkin tidak ada kebutuhan nyata untuk mengimplementasikan hal-hal sederhana?  Mungkin masing-masing perusahaan menggunakan perpustakaannya sendiri?  Atau mungkin semua orang menggunakan Phoenix atau pendekatan yang disajikan? </p><br><p><img src="https://habrastorage.org/webt/lr/bb/w-/lrbbw-w-ulfd0eatm5yabyl-sma.jpeg"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://github.com/KamilLelonek/elixir-">Repositori</a> , seperti biasa, tersedia di GitHub saya. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444554/">https://habr.com/ru/post/id444554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444544/index.html">Sesuatu tentang pusat data terdistribusi untuk bisnis</a></li>
<li><a href="../id444546/index.html">Bagaimana dan mengapa bekerja lebih lambat? Metode Sergey Korolev</a></li>
<li><a href="../id444548/index.html">Pengalaman pribadi: bagaimana kami terlibat dalam promosi startup Hispanik di Amerika Latin</a></li>
<li><a href="../id444550/index.html">Untuk pertanyaan pembagian</a></li>
<li><a href="../id444552/index.html">TDMS Fairway. Bekerja dengan keahlian</a></li>
<li><a href="../id444556/index.html">Warna bulan dan matahari dari ruang angkasa di nilai RGB dan suhu warna</a></li>
<li><a href="../id444558/index.html">Apa yang baru di CUBA 7</a></li>
<li><a href="../id444560/index.html">Kami mengundang Anda ke konferensi "Awan. Tren Mode â€26 Maret 2019</a></li>
<li><a href="../id444562/index.html">Modernisasi GHIDRA. Loader untuk rum Sega Mega Drive</a></li>
<li><a href="../id444564/index.html">Pengembangan Produk Digital dengan Model Mental</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>