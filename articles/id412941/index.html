<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚮 👨‍👧‍👦 🚞 Konferensi Eropa Timur Jawa 2018: laporan dan kesan ✌🏿 🕒 ↪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diposting oleh Igor Masternaya, Pengembang Senior, Pemimpin Komunitas Java DataArt 

 Pada 18-19 Mei, JEEonf diadakan di Kiev, salah satu acara yang p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konferensi Eropa Timur Jawa 2018: laporan dan kesan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataart/blog/412941/"><img src="https://habrastorage.org/webt/yg/-q/5j/yg-q5j1vqjcwmaqigggiuqll1yk.jpeg"><br><br>  <i>Diposting oleh Igor Masternaya, Pengembang Senior, Pemimpin Komunitas Java DataArt</i> <br><br>  Pada 18-19 Mei, JEEonf diadakan di Kiev, salah satu acara yang paling dinanti untuk seluruh komunitas Jawa di Eropa Timur.  DataArt bermitra dengan konferensi.  Pembicara dari seluruh dunia berbicara pada empat tahap: Volker Simonis, Perwakilan SAP di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JCP</a> dan kontributor OpenJDK, Jürgen Höller, Kepala Insinyur Pivotal, bapak Kerangka Kerja Musim Semi tercinta, Klaus Ibsen, pencipta Apache Camel, dan Hugh McKee, penginjil di Lightbend. <br><br>  Jadwal sangat sibuk: dalam dua hari lebih dari 50 pertunjukan, masing-masing 45 menit.  Istirahat 10 menit - dan lari ke laporan baru.  Ini akan memakan waktu lama untuk menonton semua video ketika mereka muncul di jaringan.  Oleh karena itu, saya akan menjelaskan secara singkat laporan yang menurut saya paling menarik dan yang saya kunjungi secara pribadi. <a name="habracut"></a><br><br><h3>  15 tahun Musim Semi </h3><br>  Konferensi dibuka oleh Jürgen Höller.  Dia berbicara tentang 15 tahun (!) History of the Spring Framework, dari konfigurasi XML "favorit" di versi 0.9 hingga Spring WebFlux reaktif, yang muncul dari proyek penelitian yang dipengaruhi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reactive Manifesto</a> .  Jürgen berbicara tentang koeksistensi Spring MVC dan Spring WebFlux di Spring WEB, menjelaskan mengapa mereka memutuskan untuk tidak mengintegrasikannya.  Intinya adalah bahwa abstraksi utama Spring MVC adalah Servlet API 3.0 dan memblokir IO, sementara Spring WebFlux menggunakan abstraksi Reactive Streams dan non-blocking IO.  Anda dapat menjalankan layanan Anda di SpringWebFlux di server mana pun yang mendukung IO non-blocking: Netty, versi baru Tomcat (&gt; 8.5), Jetty.  Membuat pengontrol WebFlux reaktif tidak jauh berbeda dengan membuatnya menggunakan Spring MVC, tetapi masih ada perbedaan.  Memproses permintaan pengguna, pengontrol reaktif tidak memprosesnya dalam pengertian biasa, tetapi membuat saluran pipa untuk memproses permintaan tersebut.  Dispatcher memanggil metode pengontrol, yang membuat pipa dan segera memberikannya sebagai aliran penerbit.  Aliran penerbit di Reactive Spring disajikan sebagai dua abstraksi: Fluks / Mono.  Flux mengembalikan aliran objek, sementara Mono selalu mengembalikan satu objek. <br><br>  Jürgen juga menyebutkan kemudahan menggunakan Java 8-style ketika bekerja dengan Spring 5.0 dan menjanjikan kandidat rilis Spring 5.1 pada Juli 2018 dan rilis pada bulan September, yang akan mendukung Java 11 dan bekerja pada fine tuning fitur Spring 5.0 yang baru. <br><br><h3>  Integrasi python / Java </h3><br>  Ada banyak laporan, dan memilih yang paling menarik di slot berikutnya itu sulit.  Deskripsinya sama-sama menarik, jadi saya memercayai naluri saya dan memutuskan untuk mendengarkan Tamas Rozman, wakil presiden BlackRock dari Hongaria.  Tetapi akan lebih baik jika saya mendengarkan lagi tentang Acara Sourcing dan CQRS.  Dilihat oleh deskripsi, perusahaan bergerak dalam Ilmu Data untuk dana investasi besar.  Tujuan dari laporan ini adalah untuk menunjukkan bagaimana mereka menciptakan sistem yang stabil dan dapat diskalakan, yang sama nyamannya bagi analis data dengan Python mereka, dan untuk pengembang Java dari sistem utama.  Namun, bagi saya agak ragu bahwa sistem yang dibangun benar-benar nyaman.  Untuk berteman dengan Python dan Java, para insinyur di BlackRock datang dengan ide memulai interpreter Python sebagai proses dari aplikasi Java.  Mereka datang ke sini karena beberapa alasan: <br><ul><li>  Jython (Python pada JVM) tidak cocok karena basis kode yang ketinggalan zaman 2.7 vs CPython 3.6. </li><li>  Mereka menganggap opsi untuk menulis ulang logika Ilmu Data di Jawa sebagai proses yang terlalu lama. </li><li>  Apache Spark memutuskan untuk tidak mengambilnya, karena, seperti yang dijelaskan oleh pembicara, Anda tidak dapat mencampur beban kerja yang ditulis dalam Java dan Python.  Meskipun tidak jelas mengapa UDF dan UDFA tidak cocok [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> ].  Juga, Spark tidak cocok, karena mereka sudah memiliki semacam kerangka kerja, dan mereka tidak benar-benar ingin memperkenalkan yang baru.  Dan, ternyata, mereka juga tidak memiliki Big Data, dan semua pemrosesan tergantung pada statistik pada file 100 MB yang menyedihkan. </li></ul><br><br>  Komunikasi dari Jawa dengan proses Python diatur menggunakan file yang dipetakan memori (satu file digunakan sebagai file data input) dan perintah (file kedua adalah output dari proses Python).  Jadi, komunikasi adalah sesuatu dalam bentuk: <br><br><pre>  Java: calcExr |  1 + javaFunc (sqrt (36))
 Python: 1 + javaFunct | 6
 Java: 1 + sukses | 64
 Python: sukses |  65 </pre><br><br>  Masalah utama dari integrasi tersebut, Tamas disebut overhead selama serialisasi dan deserialisasi parameter input / output. <br><br><img src="https://habrastorage.org/webt/zz/l9/vt/zzl9vtuqxaff5kn7rvdqtpgsbey.jpeg"><br><br><h3>  Java 10 App CDS </h3><br>  Setelah presentasi tentang seluk-beluk menjalankan Python, saya benar-benar ingin mendengarkan sesuatu yang sangat teknis dari dunia Java.  Jadi saya pergi ke laporan oleh Volker Simonis, di mana dia berbicara tentang fitur berbagi data kelas Aplikasi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java 10+</a> .  Di dunia modern yang dibangun di atas layanan microser di Docker, kemampuan untuk berbagi Java Codecache dan Metaspace mempercepat peluncuran aplikasi dan menghemat memori.  Gambar tersebut menunjukkan hasil peluncuran tomat dengan dok yang dibagikan / dibagikan bersama kelas Tomcat.  Seperti yang Anda lihat, untuk proses kedua, beberapa halaman dalam memori sudah ditandai sebagai shared_clean - yang berarti bahwa saat ini dan setidaknya satu proses (tomcat berjalan kedua) merujuk kepada mereka. <br><br><img src="https://habrastorage.org/webt/4b/wf/hc/4bwfhctgsicnp_ulp-r0fo08opm.png"><br><br>  Detail tentang cara bermain dengan CDS di OpenJDK 10 dapat ditemukan di: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">App CDS</a> .  Selain membagi kelas aplikasi antara proses, di masa depan direncanakan untuk berbagi string diinternir di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JEP-250</a> . <br>  Keterbatasan utama AppCDS: <br><br>  Tidak bekerja dengan kelas hingga 1,5. <br><ul><li>  Anda tidak dapat menggunakan kelas yang diambil dari file (hanya arsip .jar). </li><li>  Kelas yang dimodifikasi oleh classloader tidak dapat digunakan. </li><li>  Kelas yang dimuat oleh banyak kelas dapat digunakan kembali hanya sekali. </li><li>  Penulisan ulang kode byte tidak berfungsi, yang dapat menyebabkan penurunan kinerja hingga 2%.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JDK-8074345</a> </li></ul><br><br><img src="https://habrastorage.org/webt/ql/id/ll/qlidll3gw8_b91uclq8onav6s3g.jpeg"><br><br><h3>  Pipa pemrosesan bahasa alami dengan Apache Spark </h3><br>  Laporan tentang NLP dan Apache Spark disampaikan oleh Vitaliy Kotlyarenko - insinyur dari Grammarly.  Vitaliy menunjukkan bagaimana Grammarly prototipe NLP-Jobs di Apache Zeppelin.  Contohnya adalah pembangunan pipa sederhana untuk pemodelan tematis berdasarkan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LDA</a> dari arsip Internet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crawl umum</a> .  Hasil pemodelan topik digunakan untuk memfilter situs dengan konten yang tidak pantas sebagai contoh fungsi kontrol orang tua.  Untuk membuat pipa, kami menggunakan skrip Terraform dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS EMR</a> Spark, yang memungkinkan Anda untuk menggunakan Spark Cluster dengan BENANG di Amazon.  Secara skematis, pipa terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/p6/m7/wp/p6m7wpmj43z9dyesvyjfptjf3z4.png"><br><br>  Tujuan dari laporan ini adalah untuk menunjukkan bahwa menggunakan kerangka kerja modern untuk membuat prototipe untuk tugas-ML cukup sederhana, namun, menggunakan perpustakaan standar, Anda masih mengalami kesulitan.  Sebagai contoh: <br><ul><li>  Pada langkah pertama membaca file WARC menggunakan pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HadoopInputFormat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IllegalStateExceptions</a> kadang-kadang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">macet</a> karena header file yang salah, perpustakaan harus ditulis ulang dan file yang salah dilewati. </li><li>  Ketergantungan pada jambu biji - perpustakaan definisi bahasa - berbenturan dengan dependensi yang diseret oleh Spark.  Java 8 membantu, dengan bantuan yang memungkinkan untuk membuang ketergantungan pada jambu biji di perpustakaan yang digunakan. </li></ul><br><br>  Selama demo, kami memantau pelaksanaan pekerjaan menggunakan Spark standar UI dan subsistem pemantauan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ganglia</a> , yang secara otomatis tersedia ketika digunakan untuk AWS EMR.  Penulis fokus pada peta panas Server Load Distribution, yang menunjukkan distribusi beban antara node dalam cluster, dan memberikan saran umum tentang mengoptimalkan pekerjaan Spark Job: meningkatkan jumlah partisi, mengoptimalkan serialisasi data, menganalisis log GC.  Anda dapat membaca lebih lanjut tentang cara mengoptimalkan Spark Jobs di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  File sumber untuk demo dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> penulis laporan. <br><br><h3>  Graal, Truffle, SubstrateVM, dan fasilitas lainnya: apa saja itu dan mengapa Anda membutuhkannya </h3><br>  Yang paling dinantikan saya adalah laporan oleh Oleg Chirukhin dari JUG.ru.  Dia memberi tahu cara mengoptimalkan kode jadi menggunakan Grail.  Apa itu Cawan?  Grail adalah merek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oracle Labs</a> , yang menggabungkan kompiler JIT (just-in-time), kerangka kerja untuk menulis bahasa DSL - Truffle - dan JVM ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SubstrateVM</a> ) khusus - mesin virtual <a href="">dunia-tertutup</a> universal yang dapat Anda tulis dalam JavaScript, Ruby, Python, Java, Scala.  Laporan ini berfokus pada kompiler JIT dan pengujiannya dalam produksi. <br><br>  Pertama, ingat proses mengeksekusi kode oleh mesin Java dan perhatikan bahwa Java sudah memiliki dua kompiler: C1 (Client compiler) dan C2 (Server Compiler).  Grail dapat digunakan sebagai kompiler C2. <br><br><img src="https://habrastorage.org/webt/3k/qk/lt/3kqklt1q02gtnej89a0wa2ttou0.png"><br><br>  Ketika ditanya mengapa kami membutuhkan kompiler lain, salah satu karyawan Oracle Labs, Dr. Chris Seaton, menjawab dengan sangat baik dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Cara Kerja Graal</a> .  Singkatnya, ide asli proyek Graal, serta proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metropolis</a> , adalah untuk menulis ulang bagian dari kode JVM yang ditulis dalam C ++ di Jawa.  Ini akan memungkinkan di masa depan untuk melengkapi kode dengan mudah.  Sebagai contoh, salah satu optimasi - P <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artial Escape Analysis</a> - sudah ada di Grail, tetapi tidak di Hotspot - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">karena memperluas kode Grail jauh lebih mudah daripada kode C2</a> . <br><br>  Kedengarannya hebat, tetapi bagaimana ini akan bekerja dalam proyek saya, Anda bertanya?  Grail cocok untuk proyek: <br><br><ul><li>  Yang banyak mengotori, menciptakan banyak benda kecil. </li><li>  Ditulis dengan gaya Jawa 8, dengan banyak aliran dan lambda. </li><li>  Menggunakan berbagai bahasa: Ruby, Java, R. </li></ul><br><br>  Salah satu yang pertama dalam produksi, Grail mulai digunakan di Twitter.  Anda dapat membaca lebih lanjut tentang ini dalam sebuah wawancara dengan Christian Talinger, yang diterbitkan di Habré ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interview_1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interview_2</a> ).  Di sana, ia menjelaskan bahwa dengan mengganti C2 dengan Graal, Twitter mulai menghemat sekitar 8% dari utilisasi CPU, yang cukup baik mengingat ukuran organisasi. <br><br>  Pada konferensi tersebut, kami juga dapat memverifikasi kecepatan Graal dengan meluncurkan salah satu tolok ukur Scala di bawahnya - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scala DaCapo</a> .  Sebagai hasilnya, pada Graal, benchmark dilewatkan dalam ~ 7000 ms, dan pada JVM reguler dalam ~ 14000 ms!  Mengapa ini terjadi, Anda bisa melihat dengan melihat tes gclog.  Jumlah kegagalan Alokasi saat menggunakan Graal secara signifikan kurang dari Hotspot.  Namun, Anda masih tidak dapat mengatakan bahwa Grail akan menjadi solusi untuk masalah kinerja aplikasi Java Anda.  Oleg juga menunjukkan kisah kegagalan dalam laporannya, membandingkan karya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache Ignite di</a> bawah Grail dan tanpa itu - tidak ada perubahan kinerja yang nyata. <br><br><img src="https://habrastorage.org/webt/wg/a9/9i/wga99iykqcg8ubellwz6_upyy9o.jpeg"><br><br><h3>  Merancang Layanan Kesalahan Toleransi </h3><br>  Laporan lain tentang arsitektur microservice gagal-aman dibaca oleh Orkhan Gasimov dari AppsFlyer.  Dia memperkenalkan pola desain populer untuk membangun aplikasi terdistribusi.  Kita mungkin mengenal banyak dari mereka, tetapi berjalan-jalan dan mengingat mereka masing-masing tidak akan menyakitkan sama sekali. <br><br>  Masalah utama toleransi kesalahan layanan dengan mana pola yang dijelaskan dalam laporan dipanggil untuk melawan adalah: jaringan, beban puncak, mekanisme komunikasi antar layanan RPC. <br>  Untuk memecahkan masalah dengan jaringan, ketika salah satu layanan tidak lagi tersedia, kita perlu kemampuan untuk segera menggantinya dengan yang lain yang sama.  Dalam praktiknya, ini dapat dicapai dengan beberapa instance dari layanan yang sama dan deskripsi jalur alternatif untuk instance ini, yang merupakan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penemuan Layanan</a> .  Terlibat dalam layanan <b>detak jantung</b> dan mendaftarkan layanan baru akan menjadi contoh yang terpisah - Service Registry.  Merupakan kebiasaan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zookeeper</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsul yang terkenal</a> sebagai Registry Layanan.  Yang, pada gilirannya, juga memiliki sifat terdistribusi dan dukungan untuk toleransi kesalahan. <br><br>  Setelah menyelesaikan masalah dengan jaringan, kami beralih ke masalah beban puncak ketika beberapa layanan berada di bawah beban dan memproses permintaan jauh lebih lambat daripada mode biasa.  Untuk mengatasinya, Anda dapat menggunakan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penskalaan otomatis</a> .  Dia tidak hanya akan mengambil tugas untuk secara otomatis mengubah skala layanan yang sangat banyak, tetapi juga menghentikan mesin virtual setelah periode beban puncak. <br><br>  Bab terakhir dari laporan penulis adalah deskripsi tentang kemungkinan masalah komunikasi antarperusahaan RPC internal.  Urahan memberikan perhatian khusus pada tesis "Pengguna tidak harus menunggu pesan kesalahan untuk waktu yang lama."  Situasi seperti itu dapat muncul jika permintaannya diproses oleh rantai layanan dan masalahnya ada di akhir rantai: oleh karena itu, pengguna dapat menunggu permintaan diproses oleh masing-masing layanan dalam rantai dan hanya pada tahap terakhir yang menerima kesalahan.  Yang terburuk, jika layanan akhir kelebihan beban, dan setelah menunggu lama, klien akan menerima HTTP-ERROR yang tidak berarti: 500. <br><br>  Untuk mengatasi situasi seperti itu, Anda dapat menggunakan <b>Timeout</b> , namun, permintaan yang masih dapat diproses dengan benar dapat masuk ke dalam timeout.  Untuk melakukan ini, logika batas waktu bisa rumit dan nilai ambang batas khusus untuk jumlah kesalahan layanan per interval waktu dapat ditambahkan.  Ketika jumlah kesalahan melebihi nilai ambang batas, kami memahami bahwa layanan ini sedang dimuat dan menganggapnya tidak tersedia, memberikannya waktu yang diperlukan untuk mengatasi tugas saat ini.  Pendekatan ini menggambarkan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Circuit Breaker</a> .  Anda juga dapat menggunakan CircuitBreaker.html "&gt; Circuit Beaker sebagai metrik tambahan untuk pemantauan, yang memungkinkan Anda untuk dengan cepat merespons kemungkinan masalah dan dengan jelas mengidentifikasi rantai layanan yang mengalaminya. Untuk melakukan ini, setiap panggilan layanan harus dibungkus dengan Circuit Breaker. <br><br>  Juga dalam laporan tersebut, penulis mengingat pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">redundansi N-Modular</a> , yang dirancang untuk "memproses permintaan lebih cepat jika mungkin," dan memberikan contoh yang indah tentang penggunaannya untuk memvalidasi alamat klien.  Permintaan dalam sistem mereka melalui cache alamat segera dikirim ke beberapa penyedia Geo Map, yang karenanya respons tercepat dimenangkan. <br><br>  Selain pola yang dijelaskan, berikut ini disebutkan: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pola <b>Jalur Cepat</b></a> , yang dapat diterapkan, misalnya, saat caching hasil kueri.  Maka akses cache adalah jalur cepat. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pola <b>Kernel Kesalahan</b></a> - pola dari dunia Akka yang melibatkan pembagian tugas menjadi sub-tugas dan mendelegasikan sub-tugas ke aktor hilir.  Dengan cara ini, fleksibilitas pemrosesan kesalahan eksekusi sub-tugas tercapai. </li><li>  <b>Penyembuh Instance</b> , yang mengasumsikan keberadaan layanan khusus - pengawas yang mengelola layanan lain dan menanggapi perubahan di negara mereka.  Misalnya, jika terjadi kesalahan dalam layanan, pengawas dapat memulai kembali layanan masalah. </li></ul><br><br><img src="https://habrastorage.org/webt/am/ik/kr/amikkrgoxhuaajndqk1zgfhv12u.jpeg"><br><br><h3>  Clustered Event Sourcing dan CQRS dengan Akka dan Java </h3><br>  Laporan terakhir yang ingin saya tarik perhatian Anda dibacakan oleh salah satu penginjil dan arsitek Lightbend Hugh McKee.  Lightbend (sebelumnya Typesafe) adalah sesuatu seperti Oracle, tetapi untuk bahasa Scala.  Perusahaan juga aktif mengembangkan kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akka.io.</a>  Dalam sebuah laporan, Hugh berbicara tentang implementasi pendekatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CQRS</a> (Command Query Responsibility Commands / SEGREGATION) yang populer pada kerangka Akka.  Secara skematis, arsitektur sistem CQRS terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/n-/jy/in/n-jyin0xfhmrsqxlixxwh478ot0.png"><br><br>  Hugh mengambil prototipe bank sebagai contoh sistem kerja.  Klien dalam arsitektur CQRS melakukan dua operasi: permintaan, perintah.  Setiap tim (misalnya, transaksi bank yang mentransfer uang dari satu akun ke akun lain) menghasilkan acara (faitertai) yang akan dicatat di EventStore (misalnya: Cassandra).  Agregasi rantai (menyetor uang ke dalam akun, transfer dari akun ke akun, menarik di ATM) dari peristiwa membentuk keadaan klien saat ini, saldo uangnya di akun.  Permintaan untuk keadaan saat ini pergi ke repositori yang terpisah, snapshot dari repositori acara, karena tidak masuk akal untuk menyimpan riwayat lengkap rekening bank.  Cukup untuk memperbarui status yang dilemparkan secara berkala untuk setiap pengguna. <br><br>  Pendekatan ini memungkinkan untuk pulih secara otomatis ketika kesalahan terjadi: untuk ini kita perlu mendapatkan peran terakhir dari status pengguna dan menerapkan semua peristiwa yang terjadi sebelum kesalahan terjadi.  Karena adanya dua penyimpanan, arsitektur CQRS mentoleransi beban puncak yang muncul (paku) dengan baik.  Sejumlah besar acara akan memuat Toko Acara, tetapi tidak akan memengaruhi Read Store, dan pengguna masih dapat memenuhi kueri ke database. <br><br>  Mari kita kembali ke prototipe sistem perbankan pada Akka dan CQRS.  Setiap klien bank / akun / tim yang memungkinkan dalam sistem akan diwakili oleh satu (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aktor</a> .  Sebuah bank besar dapat mendukung ratusan ribu akun, dan ini tidak akan menjadi masalah bagi Akka.  Kerangka out-of-the-box mendukung pengelompokan dan dapat dijalankan pada ratusan JVM.  Jika salah satu mesin di cluster gagal, Akka menyediakan mekanisme khusus yang secara otomatis menanggapi situasi seperti itu: dalam kasus kami, aktor klien dapat diciptakan kembali pada mesin yang tersedia di cluster, dan statusnya akan dibaca kembali dari repositori. <br><br>  Utas terpisah tidak dibuat untuk aktor - ini memungkinkan untuk mendukung puluhan ribu aktor dalam JVM tunggal.  Pada saat yang sama, aktor menjamin bahwa setiap permintaan akan diproses secara terpisah (!) Dalam urutan penerimaan permintaan.  Jaminan ini secara otomatis menghilangkan kemungkinan kondisi balapan saat memproses permintaan.  Anda dapat memahami prototipe sistem secara lebih rinci dengan membuka kodenya menggunakan tautan di GitHub.  Setiap sub proyek menunjukkan implementasi tahap paling kompleks dalam membangun prototipe: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aktor clustering terdistribusi</a> adalah contoh sederhana membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cluster Akka '</a> a. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akka cluster singleton</a> menunjukkan bagaimana menerapkan pola singleton dalam lingkungan Akka terdistribusi. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Entitas terdistribusi sharding akka cluster sharding</a> adalah contoh pengelolaan distribusi entitas dalam sebuah cluster dan perutean permintaan klien. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CQRS - Ketekunan menulis sisi akka</a> - merekam peristiwa dalam repositori. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CQRS - Baca permintaan persistensi akka sisi</a> - memproses permintaan klien </li></ul>  tawon. <br><br>  Catatan semua laporan akan muncul online dalam beberapa minggu.  Saya harap artikel ini akan membantu Anda menentukan urutan tontonan, terutama karena saya pikir layak menonton pertunjukan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412941/">https://habr.com/ru/post/id412941/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412927/index.html">Yang seru untuk dilihat di akhir pekan: 5 film tentang peretas</a></li>
<li><a href="../id412929/index.html">Intisari Fintech: Diterbitkan undang-undang cryptocurrency yang tidak konsisten dengan para ahli, solusi fintech menjadi lebih populer</a></li>
<li><a href="../id412933/index.html">Tesla membuka sebagian kode sumber untuk Model S / X 2018.12</a></li>
<li><a href="../id412937/index.html">Demo hack: PenTest Show akan menunjukkan betapa mudahnya meretas jaringan kantor dan sistem keamanan untuk mencuri apa pun</a></li>
<li><a href="../id412939/index.html">Penguji Melawan Pengujian</a></li>
<li><a href="../id412945/index.html">Manajer ketergantungan</a></li>
<li><a href="../id412947/index.html">Muat pengujian di cloud Azure. Bagaimana cara menguji toko online besar dalam kondisi mendekati nyata?</a></li>
<li><a href="../id412949/index.html">Ahli astrologi mengumumkan minggu pengembangan iOS di Avito</a></li>
<li><a href="../id412951/index.html">DotVVM - Komunikasi antara klien dan server</a></li>
<li><a href="../id412953/index.html">Kalibrasi Kamera Intel RealSense d435 Menggunakan OpenCV2 dan ROS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>