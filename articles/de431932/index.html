<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèª ‚ùÑÔ∏è üë©üèª‚Äçü§ù‚Äçüë®üèø Fort Byte Car (und mehr) Indianer üêì üë®üèæ‚Äçüéì üõ°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ja, ja, es ist das "Byte" und es ist in indisch (nicht indisch). Ich werde in der richtigen Reihenfolge beginnen. K√ºrzlich erschienen hier auf Habr√© A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fort Byte Car (und mehr) Indianer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431932/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Bild"><br><br>  Ja, ja, es ist das "Byte" und es ist in indisch (nicht indisch).  Ich werde in der richtigen Reihenfolge beginnen.  K√ºrzlich erschienen hier auf Habr√© Artikel √ºber Bytecode.  Und es war einmal ein Spa√ü, Fort-Systeme zu schreiben.  Nat√ºrlich im Assembler.  Sie waren 16-Bit.  Ich habe nie auf x86-64 programmiert.  Auch mit 32 konnte nicht gespielt werden.  Also kam der Gedanke - warum nicht?  Warum nicht das 64-Bit-Fort und sogar den Bytecode aufr√ºhren?  Ja, und unter Linux, wo ich auch nichts System geschrieben habe. <br><br>  Ich habe einen Heimserver mit Linux.  Im Allgemeinen habe ich ein bisschen gegoogelt und herausgefunden, dass der Assembler unter Linux GAS und der Befehl as hei√üt.  Ich verbinde mich √ºber SSH mit dem Server und tippe als - ja!  Ich habe es bereits installiert.  Ben√∂tigen Sie noch einen Linker, geben Sie ld ein - ja!  Also, und versuchen Sie, etwas Interessantes in Assembler zu schreiben.  Ohne Zivilisation nur ein Wald, wie echte Indianer :) Ohne Entwicklungsumgebung nur eine Kommandozeile und Midnight Commander.  Der Editor wird Nano sein, der an meinem F4 in mc h√§ngt.  Wie singt die Gruppe ‚ÄûZero‚Äú?  Ein wahrer Inder braucht nur eines ... Was braucht ein echter Inder noch?  Nat√ºrlich ein Debugger.  Wir tippen gdb - is!  Dr√ºcken Sie Umschalt + F4 und los geht's! <br><a name="habracut"></a><br><h2>  Architektur </h2><br>  Entscheiden wir uns zun√§chst f√ºr die Architektur.  Bei bereits ermittelten Bittiefen 64 Bit.  In klassischen Fort-Implementierungen sind Daten und Codesegment identisch.  Aber wir werden versuchen, es richtig zu machen.  Wir haben nur den Code im Codesegment, die Daten im Datensegment.  Als Ergebnis erhalten wir einen Kernel f√ºr die Plattform und einen vollst√§ndig plattformunabh√§ngigen Bytecode. <br><br>  Versuchen wir, die schnellste gestapelte Byte-Maschine zu erstellen (jedoch ohne JIT).  Wir werden also eine Tabelle mit 256 Adressen haben - eine f√ºr jeden Bytebefehl.  Weniger als alles andere - eine zus√§tzliche √úberpr√ºfung, dies sind 1-2 Prozessoranweisungen.  Und wir brauchen schnell und ohne Kompromisse. <br><br><h4>  Stapel </h4><br>  Normalerweise wird in Fort-Implementierungen der Prozessor-R√ºckgabestapel (* SP) als Datenstapel verwendet, und der Fort-System-R√ºckgabestapel wird auf andere Weise implementiert.  In der Tat wird unsere Maschine gestapelt, und die Hauptarbeit liegt auf dem Datenstapel.  Machen wir also dasselbe - RSP wird ein Datenstapel sein.  Nun, der R√ºckgabestapel sei RBP, was standardm√§√üig auch mit dem Stapelsegment funktioniert.  Wir werden also drei Speichersegmente haben: ein Codesegment, ein Datensegment und ein Stapelsegment (es wird sowohl einen Datenstapel als auch einen R√ºckgabestapel haben). <br><br><h4>  Register </h4><br>  Ich gehe in die Beschreibung der Register x86-64 und hoppla!  Es gibt bis zu 8 zus√§tzliche Allzweckregister (R8 - R16) im Vergleich zu 32- oder 16-Bit-Modi. Nicht schlecht ... <br><br>  Bereits entschieden, dass sie RSP und RBP ben√∂tigen.  Ben√∂tigen noch einen Zeiger (Z√§hler) der Bytecode-Befehle.  Von Operationen in diesem Register wird nur das Lesen des Speichers ben√∂tigt.  Die Hauptregister (RAX, RBX, RCX, RDX, RSI, RDI) sind flexibler, universeller, mit ihnen gibt es viele spezielle Befehle.  Sie werden uns f√ºr verschiedene Aufgaben n√ºtzlich sein, und f√ºr den Bytecode-Anweisungsz√§hler nehmen wir eines der neuen Register f√ºr mich, sei es R8. <br><br><h2>  Fangen wir an </h2><br>  Ich habe keine Erfahrung in der Programmierung unter Linux in Assemblersprache.  Daher finden wir zun√§chst die fertige "Hallo Welt", um zu verstehen, wie das Programm startet und den Text anzeigt.  Unerwartet f√ºr mich fand ich Optionen mit einer seltsamen Syntax, bei denen sogar die Quelle und der Empf√§nger neu angeordnet wurden.  Wie sich herausstellte, ist dies die AT &amp; T-Syntax, die haupts√§chlich unter GAS darauf geschrieben ist.  Es wird jedoch eine andere Syntaxoption unterst√ºtzt, die als Intel-Syntax bezeichnet wird.  Ich dachte nach und beschloss, es trotzdem zu benutzen.  Schreiben Sie am Anfang von .intel_syntax noprefix. <br><br>  Kompilieren Sie "Hallo Welt" und f√ºhren Sie es aus, um sicherzustellen, dass alles funktioniert.  Durch das Lesen der Hilfe und der Experimente begann ich, den folgenden Befehl zum Kompilieren zu verwenden: <br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt</code> <br>  Hier gibt der Schalter -o die Ergebnisdatei an, der Schalter -g weist an, Debugging-Informationen zu generieren, und der Schalter -ahlsm legt das Listenformat fest.  Und ich behalte die Ausgabe in der Liste, darin k√∂nnen Sie viele n√ºtzliche Dinge sehen.  Ich gebe zu, zu Beginn der Arbeit habe ich die Auflistung nicht durchgef√ºhrt und nicht einmal den Schalter -g angegeben.  Ich begann den Schalter -g nach der ersten Verwendung des Debuggers zu verwenden und begann mit der Auflistung, nachdem die Makros im Code erschienen waren :) <br><br>  Danach verwenden wir den Linker, aber hier ist nirgendwo einfacher: <br><br> <code>$ ld forth.o -o forth</code> <br>  Nun, lauf! <br> <code>$ ./forth <br> Hello, world!</code> <br>  Es funktioniert. <br><br><div class="spoiler">  <b class="spoiler_title">Dies war der erste vierte (tats√§chlich ist es 'Hellow, Welt!', Nat√ºrlich)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix .section .data msg: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> len = . - msg #  len    .section .text .global _start #     _start: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, OFFSET FLAT:msg #     mov edx, len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit xor ebx, ebx #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> <br>  √úbrigens habe ich sp√§ter herausgefunden, dass es in x86-64 korrekter ist, syscall f√ºr einen Systemaufruf zu verwenden, als int 0x80.  Der 0x80-Aufruf wird f√ºr diese Architektur als veraltet angesehen, obwohl er unterst√ºtzt wird. <br></div></div><br>  Ein Anfang wurde gemacht, und jetzt ... <br><br><h2>  Lass uns gehen! </h2><br>  Da√ü es zumindest einige Besonderheiten geben w√ºrde, werden wir den Code eines Byte-Befehls schreiben.  Sei es das Fort-Wort "0", das 0 auf den Stapel legt: <br><br><pre> <code class="cpp hljs">bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br>  Zum Zeitpunkt der Ausf√ºhrung dieses Befehls zeigt R8 bereits auf den n√§chsten Bytebefehl.  Es ist notwendig, es zu lesen, R8 zu erh√∂hen, die ausf√ºhrbare Adresse durch den Code des Bytebefehls zu bestimmen und die Steuerung darauf zu √ºbertragen. <br><br>  Aber ... welche Bittiefe wird die Bytebefehls-Adresstabelle haben?  Dann musste ich mich f√ºr mich in das neue x86-64-Befehlssystem einarbeiten.  Leider habe ich keine Befehle gefunden, mit denen Sie zum Offset im Speicher wechseln k√∂nnen.  Berechnen Sie also entweder die Adresse, oder die Adresse ist bereit - 64 Bit.  Wir haben keine Zeit zum Berechnen, was bedeutet - 64 Bit.  In diesem Fall betr√§gt die Tabellengr√∂√üe 256 * 8 = 4096 Byte.  Nun, schlie√ülich codieren Sie den _next-Aufruf: <br><br><pre> <code class="cpp hljs">_next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-meta"><span class="hljs-meta"># bcmd -   -</span></span></code> </pre><br>  Nicht schlecht, scheint mir ... Es gibt nur drei Prozessoranweisungen, wenn von einem Bytebefehl zu einem anderen gewechselt wird. <br><br>  Tats√§chlich waren diese Befehle f√ºr mich nicht so einfach.  Ich musste mich erneut mit dem Befehlssystem 0x86-64 befassen und einen neuen MOVZX-Befehl f√ºr mich finden.  Tats√§chlich konvertiert dieser Befehl einen Wert von 8, 16 oder 32 Bit in ein 64-Bit-Register.  Es gibt zwei Varianten dieses Befehls: vorzeichenlos, wobei die h√∂heren Ziffern mit Nullen aufgef√ºllt werden und die vorzeichenbehaftete Ziffer MOVSX ist.  In der vorzeichenbehafteten Version wird das Vorzeichen erweitert, dh bei positiven Zahlen werden Nullen auf die h√∂heren Ziffern und bei negativen auf Einsen gesetzt.  Diese Option ist auch f√ºr den Befehl lit byte n√ºtzlich. <br><br>  Ist diese Option √ºbrigens die schnellste?  Vielleicht schl√§gt jemand noch schneller vor? <br><br>  Nun haben wir eine Byte-Maschine, die eine Folge von Byte-Befehlen durchlaufen und ausf√ºhren kann.  Es ist notwendig, es in der Praxis zu testen, um zu zwingen, mindestens ein Team auszuf√ºhren.  Aber welches?  Null auf dem Stapel?  Aber hier kennen Sie nicht einmal das Ergebnis, wenn Sie sich den Stapel unter dem Debugger nicht ansehen ... Aber wenn das Programm gestartet wurde, kann es abgeschlossen werden :) <br><br>  Wir schreiben einen Tsch√ºss-Befehl, der das Programm vervollst√§ndigt und dar√ºber schreibt, zumal wir "Hellow, Welt!" Haben. <br><br><pre> <code class="cpp hljs">bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre><br>  Sie m√ºssen nur noch eine Adresstabelle f√ºr Bytebefehle erstellen, die Register initialisieren und die Byte-Maschine starten.  Also ... es gibt 256 Werte in der Tabelle und es gibt zwei Befehle.  Was ist in den anderen Zellen? <br>  Der Rest hat einen ung√ºltigen Operationscode.  Sie k√∂nnen dies jedoch nicht √ºberpr√ºfen. Dies sind zus√§tzliche Teams. Wir haben jetzt drei und mit dem Scheck sind es f√ºnf.  Also werden wir so einen Stub-Befehl machen - ein schlechtes Team.  Zuerst f√ºllen wir die gesamte Tabelle daf√ºr aus und beginnen dann, die Zellen mit n√ºtzlichen Befehlen zu belegen.  Lassen Sie das schlechte Team den Code 0x00, das Team bye - 0x01 und die '0' den Code 0x02 haben, sobald er bereits geschrieben ist.  Das schlechte Team wird vorerst dasselbe tun wie auf Wiedersehen, nur mit einem anderen Abschlusscode und Text (ich werde es in den Spoiler legen, fast genauso wie auf Wiedersehen): <br><br><div class="spoiler">  <b class="spoiler_title">bcmd_bad</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> </div></div>  Zeichnen Sie nun eine Adresstabelle.  Der Einfachheit halber platzieren wir acht in jeder Zeile, es gibt 16 Zeilen. Die Tabelle ist ziemlich gro√ü: <br><br><div class="spoiler">  <b class="spoiler_title">Byte-Befehlsadressentabelle</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad</code> </pre> </div></div>  Wir schreiben den Hauptteil des Byte-Programms.  Weisen Sie dazu Assembler-Variablen Befehlscodes zu.  Wir werden folgende Vereinbarungen treffen: <br><br><ul><li>  Adressen zum Ausf√ºhren von Bytebefehlen beginnen mit bcmd_ </li><li>  Die Befehlscodes selbst werden in Variablen gespeichert, die mit b_ beginnen </li></ul><br>  Der Hauptteil des Byte-Programms sieht also folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">start: .byte b_bye</code> </pre><br>  Deklarieren Sie die Gr√∂√üe des Datenstapels als stack_size.  Lassen Sie es so weit sein 1024. Bei der Initialisierung werden wir RBP = RSP - stack_size ausf√ºhren. <br><br><div class="spoiler">  <b class="spoiler_title">Eigentlich bekommen wir einen solchen Programmcode (viertens)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br></div></div><br>  Kompilieren, ausf√ºhren: <br><br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt <br> $ ld forth.o -o forth <br> $ ./forth <br> bye! <br></code> <br>  Es funktioniert!  Unser erstes Bytecode-Programm von einem Byte wurde gestartet :) <br>  Dies wird nat√ºrlich so sein, wenn alles richtig gemacht wird.  Und wenn nicht, ist das Ergebnis wahrscheinlich folgendes: <br><br> <code>$ ./forth <br>   <br></code> <br>  Nat√ºrlich sind auch andere Optionen m√∂glich, aber ich bin am h√§ufigsten darauf gesto√üen.  Und wir brauchen einen Debugger. <br><br><div class="spoiler">  <b class="spoiler_title">Debugger Lyrics</b> <div class="spoiler_text">  Wie bereits erw√§hnt, habe ich GDB verwendet.  Dies ist ein ziemlich leistungsf√§higer Debugger, aber mit einer Befehlszeilenschnittstelle.  Das Ausf√ºhren ist sehr einfach: <br><br><pre> <code class="plaintext hljs">$ gdb ./forth GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word"... Reading symbols from ./forth...done. (gdb)</code> </pre> <br>  Als n√§chstes debuggen wir durch Eingabe von Befehlen.  Ich hatte genug Stunden, um einige notwendige Befehle zu finden und zu lernen, wie man sie zum Debuggen verwendet.  Hier sind sie: <br>  b &lt;Label&gt; - Setzen Sie einen Haltepunkt <br>  l &lt;label&gt; - Quellcode anzeigen <br>  r - Programm starten oder neu starten <br>  Der Prozessor registriert den Status <br>  s - Schritt <br><br>  Denken Sie √ºbrigens daran, dass Sie das Programm mit dem Schalter -g kompilieren m√ºssen?  Andernfalls sind Tags und Quellcode nicht verf√ºgbar.  In diesem Fall ist es m√∂glich, nur durch disassemblierten Code zu debuggen und die Adressen im Speicher zu verwenden.  Wir sind nat√ºrlich Inder, aber nicht in gleichem Ma√üe ... </div></div><br>  Aber irgendwie macht das Programm sehr wenig.  Wir sagen nur "Hallo" zu ihr und sie sagt sofort "Tsch√ºss!".  Machen wir die echte "Hallo Welt!"  auf Bytecode.  Legen Sie dazu die Adresse und die Zeichenfolgenl√§nge auf den Stapel, f√ºhren Sie den Befehl aus, der die Zeichenfolge anzeigt, und anschlie√üend den Befehl bye.  Dazu sind neue Befehle erforderlich: Geben Sie ein, um die Zeichenfolge auszugeben, und leuchten Sie, um die Adresse und L√§nge der Zeichenfolge anzugeben.  Zuerst schreiben wir Typ, lassen Sie seinen Code 0x80 sein.  Wir brauchen wieder diesen Code mit dem Aufruf sys_write: <br><br><pre> <code class="cpp hljs">b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br>  Hier nehmen wir die Adresse und die Stringl√§nge mit POP-Befehlen aus dem Datenstapel.  Das Aufrufen von int 0x80 kann das Register von R8 √§ndern, daher speichern wir es.  Wir haben dies vorher nicht getan, weil das Programm beendet wurde.  Der Inhalt dieser Register war egal.  Dies ist nun ein regul√§rer Bytebefehl, nach dem der Bytecode weiterhin ausgef√ºhrt wird und Sie sich verhalten m√ºssen. <br><br>  Jetzt schreiben wir das Licht.  Dies wird unser erstes Team mit Parametern sein.  Nach dem Byte mit dem Code f√ºr diesen Befehl befinden sich Bytes mit der Nummer, die auf den Stapel gelegt wird.  Es stellt sich sofort die Frage, welche Bittiefe hier ben√∂tigt wird.  Um eine beliebige Zahl einzugeben, ben√∂tigen Sie 64 Bit.  Aber jedes Mal, wenn der Befehl 9 Bytes belegt, was w√ºrde eine Zahl setzen?  Wir verlieren also die Kompaktheit, eine der Haupteigenschaften des Bytecodes, und auch den Fort-Code ... <br><br>  Die L√∂sung ist einfach: Wir werden mehrere Befehle f√ºr unterschiedliche Bittiefen ausf√ºhren.  Dies sind lit8, lit16, lit32 und lit64.  F√ºr kleine Zahlen verwenden wir lit8 und lit16, f√ºr gr√∂√üere Zahlen lit32 und lit64.  Am h√§ufigsten werden kleine Zahlen verwendet, und f√ºr sie gibt es den k√ºrzesten Befehl, der zwei Bytes ben√∂tigt.  Nicht schlecht! .. Wir werden die Codes dieser Befehle 0x08 - 0x0B machen. <br><br><pre> <code class="cpp hljs">b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next</code> </pre> <br>  Hier verwenden wir den MOVSX-Befehl - dies ist eine ikonische Version des uns bereits bekannten MOVZX-Befehls.  R8 haben wir einen Bytebefehlsz√§hler.  Wir laden den Wert der gew√ºnschten Gr√∂√üe darauf, verschieben ihn zum n√§chsten Befehl und setzen den in 64 Bit konvertierten Wert auf den Stapel. <br><br>  <b>Vergessen Sie nicht, die Adressen neuer Teams in der Tabelle zu den gew√ºnschten Positionen hinzuzuf√ºgen.</b> <br><br>  Das ist alles bereit, um dein erstes Programm "Hallo Welt!" Zu schreiben.  auf unserem Bytecode.  Lass uns mit dem Compiler arbeiten!  :) :) <br><br><pre> <code class="cpp hljs">start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye</code> </pre> <br>  Wir verwenden zwei verschiedene lit-Befehle: lit64, mit dem die Adresse der Zeichenfolge auf den Stapel gelegt wird, und lit8, mit dem die L√§nge auf den Stapel gelegt wird.  Als n√§chstes f√ºhren wir zwei weitere Bytebefehle aus: type und bye. <br>  Kompilieren, ausf√ºhren: <br><br><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! bye!</code> </pre><br>  Wir haben unseren Bytecode verdient!  Dies ist das Ergebnis, das sein sollte, wenn alles in Ordnung ist. <br><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Quelle</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre> <br></div></div><br>  Aber die M√∂glichkeiten sind immer noch sehr primitiv, man kann keine Bedingung, keinen Zyklus machen. <br><br>  Wie ist es unm√∂glich?  Sie k√∂nnen, alles ist in unseren H√§nden!  Lassen Sie uns diese Zeile 10 Mal in der Schleife machen.  Dies erfordert einen bedingten Verzweigungsbefehl sowie ein wenig Stapelarithmetik: einen Befehl, der den Wert auf dem Stapel um 1 verringert (bei Fort ‚Äû1-‚Äú), und einen Vertex-Duplizierungsbefehl (‚Äûdup‚Äú). <br><br>  Mit Arithmetik ist alles einfach, ich werde nicht einmal kommentieren: <br><br><pre> <code class="cpp hljs">b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next</code> </pre> <br>  Nun ein bedingter Sprung.  Lassen Sie uns zun√§chst die Aufgabe vereinfachen - einen bedingungslosen √úbergang.  Es ist klar, dass Sie nur den Wert des Registers R8 √§ndern m√ºssen.  Das erste, was mir in den Sinn kommt, ist ein Bytebefehl, gefolgt von einem Parameter - die √úbergangsadresse ist 64 Bit.  Wieder neun Bytes.  Ben√∂tigen wir diese neun Bytes?  √úberg√§nge treten normalerweise √ºber kurze Entfernungen auf, oft innerhalb weniger hundert Bytes.  Wir werden also nicht die Adresse verwenden, sondern den Offset! <br><br>  Bittiefe?  In vielen F√§llen reichen 8 Bits (127 vorw√§rts / r√ºckw√§rts) aus, aber manchmal reicht dies nicht aus.  Daher machen wir dasselbe wie mit dem beleuchteten Befehl, wir machen zwei Optionen - 8 und 16 Ziffern, die Befehlscodes sind 0x10 und 0x11: <br><br><pre> <code class="cpp hljs">b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre>  Jetzt ist der bedingte √úbergang einfach zu implementieren.  Wenn der Stapel 0 ist, gehen Sie zu _next und wenn nicht, gehen Sie zum Verzweigungsbefehl! <br><pre> <code class="cpp hljs">b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir alles, um eine Schleife zu machen: </font></font><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ersten beiden Befehle - wir legen den Schleifenz√§hler auf den Stapel. </font><font style="vertical-align: inherit;">Drucken Sie als N√§chstes die Zeichenfolge Hallo. </font><font style="vertical-align: inherit;">Dann subtrahieren wir 1 vom Z√§hler, duplizieren ihn und f√ºhren den √úbergang durch (oder f√ºhren ihn nicht aus). </font><font style="vertical-align: inherit;">Der Duplizierungsbefehl wird ben√∂tigt, da der bedingte Verzweigungsbefehl den Wert vom oberen Rand des Stapels √ºbernimmt. </font><font style="vertical-align: inherit;">Der √úbergang ist hier acht Bit, da der Abstand nur wenige Bytes betr√§gt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir f√ºgen die Adressen neuer Befehle in eine Tabelle ein, kompilieren und f√ºhren sie aus.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde es in einen Spoiler stecken, sonst ist unser Programm ausf√ºhrlich geworden.)</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nun, wir k√∂nnen schon Bedingungen und Zyklen machen! </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndige Quelle</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber bis der fertigen Byte-Maschine fehlt eine weitere sehr wichtige Funktion. </font><font style="vertical-align: inherit;">Wir k√∂nnen keinen anderen aus dem Bytecode aufrufen. </font><font style="vertical-align: inherit;">Wir haben keine sogenannten Routinen, Prozeduren usw. </font><font style="vertical-align: inherit;">Und in der Festung k√∂nnen wir ohne dies keine anderen W√∂rter als Kernelw√∂rter in einigen W√∂rtern verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bringen die Arbeit zum Ende. </font><font style="vertical-align: inherit;">Hier brauchen wir zum ersten Mal einen Stapel Retouren. </font><font style="vertical-align: inherit;">Es werden zwei Befehle ben√∂tigt - der Aufrufbefehl und der R√ºckgabebefehl (Aufruf und Beenden).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufbefehl macht im Prinzip dasselbe wie die Verzweigung - √ºbertr√§gt die Steuerung auf einen anderen Bytecode. </font><font style="vertical-align: inherit;">Im Gegensatz zur Verzweigung m√ºssen Sie die R√ºcksprungadresse jedoch im R√ºckgabestapel speichern, damit Sie zur√ºckkehren und die Ausf√ºhrung fortsetzen k√∂nnen. </font><font style="vertical-align: inherit;">Es gibt noch einen weiteren Unterschied: Solche Anrufe k√∂nnen in viel gr√∂√üeren Entfernungen erfolgen. </font><font style="vertical-align: inherit;">Daher f√ºhren wir den Aufrufbefehl in der Art einer Verzweigung aus, jedoch in drei Versionen - 8, 16 und 32 Bit.</font></font><br><br><pre> <code class="cpp hljs">b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen k√∂nnen, werden hier im Gegensatz zu √úberg√§ngen 3 Teams hinzugef√ºgt. Einer von ihnen ordnet R8 zum n√§chsten Bytebefehl um, und die verbleibenden zwei speichern den empfangenen Wert im R√ºckgabestapel. √úbrigens habe ich hier versucht, die Prozessoranweisungen nicht nebeneinander zu setzen, damit der Prozessorf√∂rderer die Befehle parallel ausf√ºhren kann. Aber ich wei√ü nicht, wie sehr sich dies auswirkt. Falls gew√ºnscht, k√∂nnen Sie die Tests √ºberpr√ºfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass die Bildung eines Arguments f√ºr den Aufrufbefehl etwas anders ist als f√ºr die Verzweigung. F√ºr die Verzweigung wird der Versatz als Differenz zwischen der Verzweigungsadresse und der Adresse des Bytes nach dem Bytebefehl berechnet. Und f√ºr den Aufrufbefehl ist dies der Unterschied zwischen der Sprungadresse und der Adresse des n√§chsten Befehls.</font></font> Warum wird das ben√∂tigt?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies f√ºhrt zu weniger Prozessoranweisungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun der R√ºckgabebefehl. </font><font style="vertical-align: inherit;">Tats√§chlich besteht ihre Aufgabe nur darin, R8 vom R√ºckgabestapel wiederherzustellen und die Steuerung weiter auf die Byte-Maschine zu √ºbertragen:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Befehle werden sehr oft verwendet und m√ºssen maximal optimiert werden. </font><font style="vertical-align: inherit;">Der Befehl zum Beenden des Bytes belegt drei Maschinenbefehle. </font><font style="vertical-align: inherit;">Kann man hier etwas reduzieren? </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass Sie k√∂nnen! </font><font style="vertical-align: inherit;">Sie k√∂nnen den √úbergangsbefehl einfach entfernen :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platzieren Sie ihn dazu √ºber dem Einstiegspunkt der _next-Byte-Maschine:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbrigens m√ºssen die wichtigsten und am h√§ufigsten verwendeten Befehle (z. B. Aufruf) n√§her an der Byte-Maschine platziert werden, damit der Compiler einen Kurzsprungbefehl bilden kann. </font><font style="vertical-align: inherit;">Dies ist in der Auflistung deutlich sichtbar. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">262</span></span> <span class="hljs-number"><span class="hljs-number">0084</span></span> <span class="hljs-number"><span class="hljs-number">490F</span></span>BE00 bcmd_lit8: movsx rax, byte ptr [r8] <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">0088</span></span> <span class="hljs-number"><span class="hljs-number">49F</span></span>FC0 inc r8 <span class="hljs-number"><span class="hljs-number">264</span></span> <span class="hljs-number"><span class="hljs-number">008b</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">265</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>c EB90 jmp _next <span class="hljs-number"><span class="hljs-number">266</span></span> <span class="hljs-number"><span class="hljs-number">267</span></span> b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>e <span class="hljs-number"><span class="hljs-number">490F</span></span>BF00 bcmd_lit16: movsx rax, word ptr [r8] <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">0092</span></span> <span class="hljs-number"><span class="hljs-number">4983</span></span>C002 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> <span class="hljs-number"><span class="hljs-number">0096</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">0097</span></span> EB85 jmp _next <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-number"><span class="hljs-number">0099</span></span> <span class="hljs-number"><span class="hljs-number">496300</span></span> bcmd_lit32: movsx rax, dword ptr [r8] <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-number"><span class="hljs-number">009</span></span>c <span class="hljs-number"><span class="hljs-number">4983</span></span>C004 add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a0 <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a1 E978FFFF jmp _next <span class="hljs-number"><span class="hljs-number">277</span></span> FF <span class="hljs-number"><span class="hljs-number">278</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Zeile 265 und 271 ben√∂tigt der Befehl jmp jeweils 2 Byte, und in Zeile 277 ist derselbe Befehl bereits zu 5 Byte kompiliert, da die Sprungdistanz die L√§nge des Kurzbefehls √ºberschreitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher werden Bytebefehle wie bad, bye, type weiter neu angeordnet, und wie call, branch, lit sind n√§her. Leider kann nicht viel in einen 127-Byte-√úbergang passen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir f√ºgen der Tabelle der Befehlsadressen neue Befehle entsprechend ihren Codes hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben jetzt eine Herausforderung und eine R√ºckkehr, wir werden sie testen! W√§hlen Sie dazu den Zeilendruck in einem separaten Verfahren aus, und wir rufen ihn zweimal in einer Schleife auf. Und die Anzahl der Wiederholungen des Zyklus wird auf drei reduziert.</font></font><br><br><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call8 k√∂nnte hier verwendet werden, aber ich habe mich entschieden, call16 als wahrscheinlichste zu verwenden. </font><font style="vertical-align: inherit;">Der Wert 2 wird aufgrund der Besonderheiten der Berechnung der Adresse f√ºr den Aufrufbytebefehl, √ºber den ich geschrieben habe, abgezogen. </font><font style="vertical-align: inherit;">F√ºr call8 wird hier 1 abgezogen, f√ºr call32 jeweils 4. Wir </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompilieren und rufen auf:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Bad byte code!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ups ... wie sie sagen, etwas ist schief gelaufen :) Nun, wir starten GDB und sehen, was dort passiert. </font><font style="vertical-align: inherit;">Ich habe sofort einen Haltepunkt auf bcmd_exit gesetzt, da klar ist, dass der Aufruf von sub_hello √ºbergeben wird und der Hauptteil der Prozedur ausgef√ºhrt wird ... gestartet ... und das Programm den Haltepunkt nicht erreicht hat. </font><font style="vertical-align: inherit;">Sofort bestand der Verdacht auf einen Byte-Befehlscode. </font><font style="vertical-align: inherit;">Und tats√§chlich lag der Grund in ihm. </font><font style="vertical-align: inherit;">b_exit Ich habe den Wert 0x1f zugewiesen und die Adresse selbst wurde in die Tabellenzellennummer 0x17 eingef√ºgt. </font><font style="vertical-align: inherit;">Nun, dann werde ich den Wert von b_exit auf 0x17 korrigieren und es erneut versuchen:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genau sechsmal Begr√º√üung und einmal auf Wiedersehen. </font><font style="vertical-align: inherit;">Wie es sein sollte :)</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndige Quelle</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">4</span></span> ‚Äî sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist das Ergebnis? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine vollst√§ndige und ziemlich schnelle 64-Bit-Stack-Byte-Maschine getestet. In Bezug auf die Geschwindigkeit ist diese Byte-Maschine m√∂glicherweise eine der schnellsten ihrer Klasse (eine Stack-Byte-Maschine ohne JIT). Sie wei√ü, wie man Befehle nacheinander ausf√ºhrt, bedingte und bedingungslose Spr√ºnge ausf√ºhrt, Prozeduren aufruft und von ihnen zur√ºckkehrt. Gleichzeitig ist der verwendete Bytecode relativ kompakt. Grunds√§tzlich belegen Bytebefehle 1-3 Bytes, mehr ist sehr selten (nur gro√üe Zahlen und sehr weit entfernte Prozeduraufrufe). Es wird auch ein kleiner Satz von Bytebefehlen skizziert, der leicht zu erweitern ist. Angenommen, alle grundlegenden Befehle f√ºr die Arbeit mit dem Stapel (Drop, Swap, Over, Root usw. k√∂nnen in 20 Minuten geschrieben werden, der gleiche Betrag wird f√ºr arithmetische Ganzzahlbefehle verwendet).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer wichtiger Punkt. Der Bytecode enth√§lt im Gegensatz zum klassischen direkt gen√§hten Fort-Code keine Maschinenanweisungen, sodass er ohne Neukompilierung auf eine andere Plattform √ºbertragen werden kann. Es reicht aus, den Kernel einmal in das Befehlssystem des neuen Prozessors umzuschreiben, und dies kann sehr schnell erfolgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die aktuelle Version des Byte-Computers ist nicht spezifisch f√ºr eine bestimmte Sprache. Aber ich m√∂chte die Fort-Sprache darauf implementieren, weil ich Erfahrung damit habe und der Compiler daf√ºr sehr schnell fertig sein kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dies auf der Grundlage dieser Maschine Interesse besteht, werde ich im n√§chsten Artikel Zeichenfolgen und Zahlen, ein Fort-W√∂rterbuch und einen Interpreter eingeben und ausgeben. Sie k√∂nnen das Team mit Ihren H√§nden "ber√ºhren". Nun, im dritten Artikel werden wir einen Compiler erstellen und ein fast vollst√§ndiges Fort-System erhalten. Dann ist es m√∂glich, einige Standardalgorithmen zu schreiben und zu kompilieren und die Leistung mit anderen Sprachen und Systemen zu vergleichen. Sie k√∂nnen zum Beispiel das Sieb von Eratosthenes und dergleichen verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist interessant, mit Optionen zu experimentieren. </font><font style="vertical-align: inherit;">Erstellen Sie beispielsweise die Befehlstabelle 16-Bit, und sehen Sie, wie sich dies auf die Leistung auswirkt. </font><font style="vertical-align: inherit;">Sie k√∂nnen den Einstiegspunkt _next auch in ein Makro verwandeln. In diesem Fall vergr√∂√üert sich der Maschinencode jedes Bytebefehls um zwei Befehle (abz√ºglich des √úbergangs und plus drei Befehle von _next). </font><font style="vertical-align: inherit;">Das hei√üt, am Ende gibt es keinen √úbergang zu _next, sondern den Inhalt des _next-Punkts selbst (dies sind 14 Bytes). </font><font style="vertical-align: inherit;">Es ist interessant zu wissen, wie sich dies auf die Leistung auswirkt. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch versuchen, die Optimierung mithilfe von Registern durchzuf√ºhren. </font><font style="vertical-align: inherit;">Beispielsweise speichert eine Standardschleife mit einem Z√§hler in der Festung den Z√§hler auf dem R√ºckgabestapel. </font><font style="vertical-align: inherit;">Sie k√∂nnen eine Registerversion erstellen und auch testen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen auch einen Compiler aus Ausdr√ºcken erstellen, die in der klassischen Form geschrieben sind (z. B. A = 5 + (B + C * 4)).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generell gibt es Raum zum Experimentieren! </font></font> :) :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-Maschine f√ºr das Fort (und nicht nur) in Native American (Teil 2)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431932/">https://habr.com/ru/post/de431932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431920/index.html">Frontend Mix - Berichte √ºber Node.js, Skalierbarkeit und natives Web</a></li>
<li><a href="../de431922/index.html">Was sind Methodenhandles in Java?</a></li>
<li><a href="../de431924/index.html">Lagerverwaltungssystem mit CQRS und Event Sourcing. Entwicklungsprozess</a></li>
<li><a href="../de431928/index.html">Erm√ºdung durch Einwegartikel. Oder Ode A.S. Makarenko</a></li>
<li><a href="../de431930/index.html">DevOps-Treffen in St. Petersburg</a></li>
<li><a href="../de431934/index.html">Wie hilft k√ºnstliche Intelligenz bei der Arbeit mit juristischen Dokumenten? Vortrag von Egor Budnikov von ABBYY</a></li>
<li><a href="../de431936/index.html">Ergebnisse des TechnoText-Wettbewerbs</a></li>
<li><a href="../de431938/index.html">Ganzzahlige Kubikwurzel in Verilog</a></li>
<li><a href="../de431940/index.html">Menschen brennen aus, wenn sie sich nicht wert f√ºhlen. Was tun?</a></li>
<li><a href="../de431942/index.html">Hierarchische Abh√§ngigkeitsinjektion in React und MobX State Tree als Dom√§nenmodell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>