<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏻 ❄️ 👩🏻‍🤝‍👨🏿 Fort Byte Car (und mehr) Indianer 🐓 👨🏾‍🎓 🛡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ja, ja, es ist das "Byte" und es ist in indisch (nicht indisch). Ich werde in der richtigen Reihenfolge beginnen. Kürzlich erschienen hier auf Habré A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fort Byte Car (und mehr) Indianer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431932/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Bild"><br><br>  Ja, ja, es ist das "Byte" und es ist in indisch (nicht indisch).  Ich werde in der richtigen Reihenfolge beginnen.  Kürzlich erschienen hier auf Habré Artikel über Bytecode.  Und es war einmal ein Spaß, Fort-Systeme zu schreiben.  Natürlich im Assembler.  Sie waren 16-Bit.  Ich habe nie auf x86-64 programmiert.  Auch mit 32 konnte nicht gespielt werden.  Also kam der Gedanke - warum nicht?  Warum nicht das 64-Bit-Fort und sogar den Bytecode aufrühren?  Ja, und unter Linux, wo ich auch nichts System geschrieben habe. <br><br>  Ich habe einen Heimserver mit Linux.  Im Allgemeinen habe ich ein bisschen gegoogelt und herausgefunden, dass der Assembler unter Linux GAS und der Befehl as heißt.  Ich verbinde mich über SSH mit dem Server und tippe als - ja!  Ich habe es bereits installiert.  Benötigen Sie noch einen Linker, geben Sie ld ein - ja!  Also, und versuchen Sie, etwas Interessantes in Assembler zu schreiben.  Ohne Zivilisation nur ein Wald, wie echte Indianer :) Ohne Entwicklungsumgebung nur eine Kommandozeile und Midnight Commander.  Der Editor wird Nano sein, der an meinem F4 in mc hängt.  Wie singt die Gruppe „Zero“?  Ein wahrer Inder braucht nur eines ... Was braucht ein echter Inder noch?  Natürlich ein Debugger.  Wir tippen gdb - is!  Drücken Sie Umschalt + F4 und los geht's! <br><a name="habracut"></a><br><h2>  Architektur </h2><br>  Entscheiden wir uns zunächst für die Architektur.  Bei bereits ermittelten Bittiefen 64 Bit.  In klassischen Fort-Implementierungen sind Daten und Codesegment identisch.  Aber wir werden versuchen, es richtig zu machen.  Wir haben nur den Code im Codesegment, die Daten im Datensegment.  Als Ergebnis erhalten wir einen Kernel für die Plattform und einen vollständig plattformunabhängigen Bytecode. <br><br>  Versuchen wir, die schnellste gestapelte Byte-Maschine zu erstellen (jedoch ohne JIT).  Wir werden also eine Tabelle mit 256 Adressen haben - eine für jeden Bytebefehl.  Weniger als alles andere - eine zusätzliche Überprüfung, dies sind 1-2 Prozessoranweisungen.  Und wir brauchen schnell und ohne Kompromisse. <br><br><h4>  Stapel </h4><br>  Normalerweise wird in Fort-Implementierungen der Prozessor-Rückgabestapel (* SP) als Datenstapel verwendet, und der Fort-System-Rückgabestapel wird auf andere Weise implementiert.  In der Tat wird unsere Maschine gestapelt, und die Hauptarbeit liegt auf dem Datenstapel.  Machen wir also dasselbe - RSP wird ein Datenstapel sein.  Nun, der Rückgabestapel sei RBP, was standardmäßig auch mit dem Stapelsegment funktioniert.  Wir werden also drei Speichersegmente haben: ein Codesegment, ein Datensegment und ein Stapelsegment (es wird sowohl einen Datenstapel als auch einen Rückgabestapel haben). <br><br><h4>  Register </h4><br>  Ich gehe in die Beschreibung der Register x86-64 und hoppla!  Es gibt bis zu 8 zusätzliche Allzweckregister (R8 - R16) im Vergleich zu 32- oder 16-Bit-Modi. Nicht schlecht ... <br><br>  Bereits entschieden, dass sie RSP und RBP benötigen.  Benötigen noch einen Zeiger (Zähler) der Bytecode-Befehle.  Von Operationen in diesem Register wird nur das Lesen des Speichers benötigt.  Die Hauptregister (RAX, RBX, RCX, RDX, RSI, RDI) sind flexibler, universeller, mit ihnen gibt es viele spezielle Befehle.  Sie werden uns für verschiedene Aufgaben nützlich sein, und für den Bytecode-Anweisungszähler nehmen wir eines der neuen Register für mich, sei es R8. <br><br><h2>  Fangen wir an </h2><br>  Ich habe keine Erfahrung in der Programmierung unter Linux in Assemblersprache.  Daher finden wir zunächst die fertige "Hallo Welt", um zu verstehen, wie das Programm startet und den Text anzeigt.  Unerwartet für mich fand ich Optionen mit einer seltsamen Syntax, bei denen sogar die Quelle und der Empfänger neu angeordnet wurden.  Wie sich herausstellte, ist dies die AT &amp; T-Syntax, die hauptsächlich unter GAS darauf geschrieben ist.  Es wird jedoch eine andere Syntaxoption unterstützt, die als Intel-Syntax bezeichnet wird.  Ich dachte nach und beschloss, es trotzdem zu benutzen.  Schreiben Sie am Anfang von .intel_syntax noprefix. <br><br>  Kompilieren Sie "Hallo Welt" und führen Sie es aus, um sicherzustellen, dass alles funktioniert.  Durch das Lesen der Hilfe und der Experimente begann ich, den folgenden Befehl zum Kompilieren zu verwenden: <br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt</code> <br>  Hier gibt der Schalter -o die Ergebnisdatei an, der Schalter -g weist an, Debugging-Informationen zu generieren, und der Schalter -ahlsm legt das Listenformat fest.  Und ich behalte die Ausgabe in der Liste, darin können Sie viele nützliche Dinge sehen.  Ich gebe zu, zu Beginn der Arbeit habe ich die Auflistung nicht durchgeführt und nicht einmal den Schalter -g angegeben.  Ich begann den Schalter -g nach der ersten Verwendung des Debuggers zu verwenden und begann mit der Auflistung, nachdem die Makros im Code erschienen waren :) <br><br>  Danach verwenden wir den Linker, aber hier ist nirgendwo einfacher: <br><br> <code>$ ld forth.o -o forth</code> <br>  Nun, lauf! <br> <code>$ ./forth <br> Hello, world!</code> <br>  Es funktioniert. <br><br><div class="spoiler">  <b class="spoiler_title">Dies war der erste vierte (tatsächlich ist es 'Hellow, Welt!', Natürlich)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix .section .data msg: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> len = . - msg #  len    .section .text .global _start #     _start: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, OFFSET FLAT:msg #     mov edx, len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit xor ebx, ebx #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> <br>  Übrigens habe ich später herausgefunden, dass es in x86-64 korrekter ist, syscall für einen Systemaufruf zu verwenden, als int 0x80.  Der 0x80-Aufruf wird für diese Architektur als veraltet angesehen, obwohl er unterstützt wird. <br></div></div><br>  Ein Anfang wurde gemacht, und jetzt ... <br><br><h2>  Lass uns gehen! </h2><br>  Daß es zumindest einige Besonderheiten geben würde, werden wir den Code eines Byte-Befehls schreiben.  Sei es das Fort-Wort "0", das 0 auf den Stapel legt: <br><br><pre> <code class="cpp hljs">bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br>  Zum Zeitpunkt der Ausführung dieses Befehls zeigt R8 bereits auf den nächsten Bytebefehl.  Es ist notwendig, es zu lesen, R8 zu erhöhen, die ausführbare Adresse durch den Code des Bytebefehls zu bestimmen und die Steuerung darauf zu übertragen. <br><br>  Aber ... welche Bittiefe wird die Bytebefehls-Adresstabelle haben?  Dann musste ich mich für mich in das neue x86-64-Befehlssystem einarbeiten.  Leider habe ich keine Befehle gefunden, mit denen Sie zum Offset im Speicher wechseln können.  Berechnen Sie also entweder die Adresse, oder die Adresse ist bereit - 64 Bit.  Wir haben keine Zeit zum Berechnen, was bedeutet - 64 Bit.  In diesem Fall beträgt die Tabellengröße 256 * 8 = 4096 Byte.  Nun, schließlich codieren Sie den _next-Aufruf: <br><br><pre> <code class="cpp hljs">_next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-meta"><span class="hljs-meta"># bcmd -   -</span></span></code> </pre><br>  Nicht schlecht, scheint mir ... Es gibt nur drei Prozessoranweisungen, wenn von einem Bytebefehl zu einem anderen gewechselt wird. <br><br>  Tatsächlich waren diese Befehle für mich nicht so einfach.  Ich musste mich erneut mit dem Befehlssystem 0x86-64 befassen und einen neuen MOVZX-Befehl für mich finden.  Tatsächlich konvertiert dieser Befehl einen Wert von 8, 16 oder 32 Bit in ein 64-Bit-Register.  Es gibt zwei Varianten dieses Befehls: vorzeichenlos, wobei die höheren Ziffern mit Nullen aufgefüllt werden und die vorzeichenbehaftete Ziffer MOVSX ist.  In der vorzeichenbehafteten Version wird das Vorzeichen erweitert, dh bei positiven Zahlen werden Nullen auf die höheren Ziffern und bei negativen auf Einsen gesetzt.  Diese Option ist auch für den Befehl lit byte nützlich. <br><br>  Ist diese Option übrigens die schnellste?  Vielleicht schlägt jemand noch schneller vor? <br><br>  Nun haben wir eine Byte-Maschine, die eine Folge von Byte-Befehlen durchlaufen und ausführen kann.  Es ist notwendig, es in der Praxis zu testen, um zu zwingen, mindestens ein Team auszuführen.  Aber welches?  Null auf dem Stapel?  Aber hier kennen Sie nicht einmal das Ergebnis, wenn Sie sich den Stapel unter dem Debugger nicht ansehen ... Aber wenn das Programm gestartet wurde, kann es abgeschlossen werden :) <br><br>  Wir schreiben einen Tschüss-Befehl, der das Programm vervollständigt und darüber schreibt, zumal wir "Hellow, Welt!" Haben. <br><br><pre> <code class="cpp hljs">bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre><br>  Sie müssen nur noch eine Adresstabelle für Bytebefehle erstellen, die Register initialisieren und die Byte-Maschine starten.  Also ... es gibt 256 Werte in der Tabelle und es gibt zwei Befehle.  Was ist in den anderen Zellen? <br>  Der Rest hat einen ungültigen Operationscode.  Sie können dies jedoch nicht überprüfen. Dies sind zusätzliche Teams. Wir haben jetzt drei und mit dem Scheck sind es fünf.  Also werden wir so einen Stub-Befehl machen - ein schlechtes Team.  Zuerst füllen wir die gesamte Tabelle dafür aus und beginnen dann, die Zellen mit nützlichen Befehlen zu belegen.  Lassen Sie das schlechte Team den Code 0x00, das Team bye - 0x01 und die '0' den Code 0x02 haben, sobald er bereits geschrieben ist.  Das schlechte Team wird vorerst dasselbe tun wie auf Wiedersehen, nur mit einem anderen Abschlusscode und Text (ich werde es in den Spoiler legen, fast genauso wie auf Wiedersehen): <br><br><div class="spoiler">  <b class="spoiler_title">bcmd_bad</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> </div></div>  Zeichnen Sie nun eine Adresstabelle.  Der Einfachheit halber platzieren wir acht in jeder Zeile, es gibt 16 Zeilen. Die Tabelle ist ziemlich groß: <br><br><div class="spoiler">  <b class="spoiler_title">Byte-Befehlsadressentabelle</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad</code> </pre> </div></div>  Wir schreiben den Hauptteil des Byte-Programms.  Weisen Sie dazu Assembler-Variablen Befehlscodes zu.  Wir werden folgende Vereinbarungen treffen: <br><br><ul><li>  Adressen zum Ausführen von Bytebefehlen beginnen mit bcmd_ </li><li>  Die Befehlscodes selbst werden in Variablen gespeichert, die mit b_ beginnen </li></ul><br>  Der Hauptteil des Byte-Programms sieht also folgendermaßen aus: <br><br><pre> <code class="cpp hljs">start: .byte b_bye</code> </pre><br>  Deklarieren Sie die Größe des Datenstapels als stack_size.  Lassen Sie es so weit sein 1024. Bei der Initialisierung werden wir RBP = RSP - stack_size ausführen. <br><br><div class="spoiler">  <b class="spoiler_title">Eigentlich bekommen wir einen solchen Programmcode (viertens)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br></div></div><br>  Kompilieren, ausführen: <br><br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt <br> $ ld forth.o -o forth <br> $ ./forth <br> bye! <br></code> <br>  Es funktioniert!  Unser erstes Bytecode-Programm von einem Byte wurde gestartet :) <br>  Dies wird natürlich so sein, wenn alles richtig gemacht wird.  Und wenn nicht, ist das Ergebnis wahrscheinlich folgendes: <br><br> <code>$ ./forth <br>   <br></code> <br>  Natürlich sind auch andere Optionen möglich, aber ich bin am häufigsten darauf gestoßen.  Und wir brauchen einen Debugger. <br><br><div class="spoiler">  <b class="spoiler_title">Debugger Lyrics</b> <div class="spoiler_text">  Wie bereits erwähnt, habe ich GDB verwendet.  Dies ist ein ziemlich leistungsfähiger Debugger, aber mit einer Befehlszeilenschnittstelle.  Das Ausführen ist sehr einfach: <br><br><pre> <code class="plaintext hljs">$ gdb ./forth GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word"... Reading symbols from ./forth...done. (gdb)</code> </pre> <br>  Als nächstes debuggen wir durch Eingabe von Befehlen.  Ich hatte genug Stunden, um einige notwendige Befehle zu finden und zu lernen, wie man sie zum Debuggen verwendet.  Hier sind sie: <br>  b &lt;Label&gt; - Setzen Sie einen Haltepunkt <br>  l &lt;label&gt; - Quellcode anzeigen <br>  r - Programm starten oder neu starten <br>  Der Prozessor registriert den Status <br>  s - Schritt <br><br>  Denken Sie übrigens daran, dass Sie das Programm mit dem Schalter -g kompilieren müssen?  Andernfalls sind Tags und Quellcode nicht verfügbar.  In diesem Fall ist es möglich, nur durch disassemblierten Code zu debuggen und die Adressen im Speicher zu verwenden.  Wir sind natürlich Inder, aber nicht in gleichem Maße ... </div></div><br>  Aber irgendwie macht das Programm sehr wenig.  Wir sagen nur "Hallo" zu ihr und sie sagt sofort "Tschüss!".  Machen wir die echte "Hallo Welt!"  auf Bytecode.  Legen Sie dazu die Adresse und die Zeichenfolgenlänge auf den Stapel, führen Sie den Befehl aus, der die Zeichenfolge anzeigt, und anschließend den Befehl bye.  Dazu sind neue Befehle erforderlich: Geben Sie ein, um die Zeichenfolge auszugeben, und leuchten Sie, um die Adresse und Länge der Zeichenfolge anzugeben.  Zuerst schreiben wir Typ, lassen Sie seinen Code 0x80 sein.  Wir brauchen wieder diesen Code mit dem Aufruf sys_write: <br><br><pre> <code class="cpp hljs">b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br>  Hier nehmen wir die Adresse und die Stringlänge mit POP-Befehlen aus dem Datenstapel.  Das Aufrufen von int 0x80 kann das Register von R8 ändern, daher speichern wir es.  Wir haben dies vorher nicht getan, weil das Programm beendet wurde.  Der Inhalt dieser Register war egal.  Dies ist nun ein regulärer Bytebefehl, nach dem der Bytecode weiterhin ausgeführt wird und Sie sich verhalten müssen. <br><br>  Jetzt schreiben wir das Licht.  Dies wird unser erstes Team mit Parametern sein.  Nach dem Byte mit dem Code für diesen Befehl befinden sich Bytes mit der Nummer, die auf den Stapel gelegt wird.  Es stellt sich sofort die Frage, welche Bittiefe hier benötigt wird.  Um eine beliebige Zahl einzugeben, benötigen Sie 64 Bit.  Aber jedes Mal, wenn der Befehl 9 Bytes belegt, was würde eine Zahl setzen?  Wir verlieren also die Kompaktheit, eine der Haupteigenschaften des Bytecodes, und auch den Fort-Code ... <br><br>  Die Lösung ist einfach: Wir werden mehrere Befehle für unterschiedliche Bittiefen ausführen.  Dies sind lit8, lit16, lit32 und lit64.  Für kleine Zahlen verwenden wir lit8 und lit16, für größere Zahlen lit32 und lit64.  Am häufigsten werden kleine Zahlen verwendet, und für sie gibt es den kürzesten Befehl, der zwei Bytes benötigt.  Nicht schlecht! .. Wir werden die Codes dieser Befehle 0x08 - 0x0B machen. <br><br><pre> <code class="cpp hljs">b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next</code> </pre> <br>  Hier verwenden wir den MOVSX-Befehl - dies ist eine ikonische Version des uns bereits bekannten MOVZX-Befehls.  R8 haben wir einen Bytebefehlszähler.  Wir laden den Wert der gewünschten Größe darauf, verschieben ihn zum nächsten Befehl und setzen den in 64 Bit konvertierten Wert auf den Stapel. <br><br>  <b>Vergessen Sie nicht, die Adressen neuer Teams in der Tabelle zu den gewünschten Positionen hinzuzufügen.</b> <br><br>  Das ist alles bereit, um dein erstes Programm "Hallo Welt!" Zu schreiben.  auf unserem Bytecode.  Lass uns mit dem Compiler arbeiten!  :) :) <br><br><pre> <code class="cpp hljs">start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye</code> </pre> <br>  Wir verwenden zwei verschiedene lit-Befehle: lit64, mit dem die Adresse der Zeichenfolge auf den Stapel gelegt wird, und lit8, mit dem die Länge auf den Stapel gelegt wird.  Als nächstes führen wir zwei weitere Bytebefehle aus: type und bye. <br>  Kompilieren, ausführen: <br><br><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! bye!</code> </pre><br>  Wir haben unseren Bytecode verdient!  Dies ist das Ergebnis, das sein sollte, wenn alles in Ordnung ist. <br><br><div class="spoiler">  <b class="spoiler_title">Vollständige Quelle</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre> <br></div></div><br>  Aber die Möglichkeiten sind immer noch sehr primitiv, man kann keine Bedingung, keinen Zyklus machen. <br><br>  Wie ist es unmöglich?  Sie können, alles ist in unseren Händen!  Lassen Sie uns diese Zeile 10 Mal in der Schleife machen.  Dies erfordert einen bedingten Verzweigungsbefehl sowie ein wenig Stapelarithmetik: einen Befehl, der den Wert auf dem Stapel um 1 verringert (bei Fort „1-“), und einen Vertex-Duplizierungsbefehl („dup“). <br><br>  Mit Arithmetik ist alles einfach, ich werde nicht einmal kommentieren: <br><br><pre> <code class="cpp hljs">b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next</code> </pre> <br>  Nun ein bedingter Sprung.  Lassen Sie uns zunächst die Aufgabe vereinfachen - einen bedingungslosen Übergang.  Es ist klar, dass Sie nur den Wert des Registers R8 ändern müssen.  Das erste, was mir in den Sinn kommt, ist ein Bytebefehl, gefolgt von einem Parameter - die Übergangsadresse ist 64 Bit.  Wieder neun Bytes.  Benötigen wir diese neun Bytes?  Übergänge treten normalerweise über kurze Entfernungen auf, oft innerhalb weniger hundert Bytes.  Wir werden also nicht die Adresse verwenden, sondern den Offset! <br><br>  Bittiefe?  In vielen Fällen reichen 8 Bits (127 vorwärts / rückwärts) aus, aber manchmal reicht dies nicht aus.  Daher machen wir dasselbe wie mit dem beleuchteten Befehl, wir machen zwei Optionen - 8 und 16 Ziffern, die Befehlscodes sind 0x10 und 0x11: <br><br><pre> <code class="cpp hljs">b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre>  Jetzt ist der bedingte Übergang einfach zu implementieren.  Wenn der Stapel 0 ist, gehen Sie zu _next und wenn nicht, gehen Sie zum Verzweigungsbefehl! <br><pre> <code class="cpp hljs">b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt haben wir alles, um eine Schleife zu machen: </font></font><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ersten beiden Befehle - wir legen den Schleifenzähler auf den Stapel. </font><font style="vertical-align: inherit;">Drucken Sie als Nächstes die Zeichenfolge Hallo. </font><font style="vertical-align: inherit;">Dann subtrahieren wir 1 vom Zähler, duplizieren ihn und führen den Übergang durch (oder führen ihn nicht aus). </font><font style="vertical-align: inherit;">Der Duplizierungsbefehl wird benötigt, da der bedingte Verzweigungsbefehl den Wert vom oberen Rand des Stapels übernimmt. </font><font style="vertical-align: inherit;">Der Übergang ist hier acht Bit, da der Abstand nur wenige Bytes beträgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir fügen die Adressen neuer Befehle in eine Tabelle ein, kompilieren und führen sie aus.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich werde es in einen Spoiler stecken, sonst ist unser Programm ausführlich geworden.)</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nun, wir können schon Bedingungen und Zyklen machen! </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Quelle</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber bis der fertigen Byte-Maschine fehlt eine weitere sehr wichtige Funktion. </font><font style="vertical-align: inherit;">Wir können keinen anderen aus dem Bytecode aufrufen. </font><font style="vertical-align: inherit;">Wir haben keine sogenannten Routinen, Prozeduren usw. </font><font style="vertical-align: inherit;">Und in der Festung können wir ohne dies keine anderen Wörter als Kernelwörter in einigen Wörtern verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir bringen die Arbeit zum Ende. </font><font style="vertical-align: inherit;">Hier brauchen wir zum ersten Mal einen Stapel Retouren. </font><font style="vertical-align: inherit;">Es werden zwei Befehle benötigt - der Aufrufbefehl und der Rückgabebefehl (Aufruf und Beenden).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufbefehl macht im Prinzip dasselbe wie die Verzweigung - überträgt die Steuerung auf einen anderen Bytecode. </font><font style="vertical-align: inherit;">Im Gegensatz zur Verzweigung müssen Sie die Rücksprungadresse jedoch im Rückgabestapel speichern, damit Sie zurückkehren und die Ausführung fortsetzen können. </font><font style="vertical-align: inherit;">Es gibt noch einen weiteren Unterschied: Solche Anrufe können in viel größeren Entfernungen erfolgen. </font><font style="vertical-align: inherit;">Daher führen wir den Aufrufbefehl in der Art einer Verzweigung aus, jedoch in drei Versionen - 8, 16 und 32 Bit.</font></font><br><br><pre> <code class="cpp hljs">b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen können, werden hier im Gegensatz zu Übergängen 3 Teams hinzugefügt. Einer von ihnen ordnet R8 zum nächsten Bytebefehl um, und die verbleibenden zwei speichern den empfangenen Wert im Rückgabestapel. Übrigens habe ich hier versucht, die Prozessoranweisungen nicht nebeneinander zu setzen, damit der Prozessorförderer die Befehle parallel ausführen kann. Aber ich weiß nicht, wie sehr sich dies auswirkt. Falls gewünscht, können Sie die Tests überprüfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass die Bildung eines Arguments für den Aufrufbefehl etwas anders ist als für die Verzweigung. Für die Verzweigung wird der Versatz als Differenz zwischen der Verzweigungsadresse und der Adresse des Bytes nach dem Bytebefehl berechnet. Und für den Aufrufbefehl ist dies der Unterschied zwischen der Sprungadresse und der Adresse des nächsten Befehls.</font></font> Warum wird das benötigt?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies führt zu weniger Prozessoranweisungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun der Rückgabebefehl. </font><font style="vertical-align: inherit;">Tatsächlich besteht ihre Aufgabe nur darin, R8 vom Rückgabestapel wiederherzustellen und die Steuerung weiter auf die Byte-Maschine zu übertragen:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Befehle werden sehr oft verwendet und müssen maximal optimiert werden. </font><font style="vertical-align: inherit;">Der Befehl zum Beenden des Bytes belegt drei Maschinenbefehle. </font><font style="vertical-align: inherit;">Kann man hier etwas reduzieren? </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass Sie können! </font><font style="vertical-align: inherit;">Sie können den Übergangsbefehl einfach entfernen :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Platzieren Sie ihn dazu über dem Einstiegspunkt der _next-Byte-Maschine:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übrigens müssen die wichtigsten und am häufigsten verwendeten Befehle (z. B. Aufruf) näher an der Byte-Maschine platziert werden, damit der Compiler einen Kurzsprungbefehl bilden kann. </font><font style="vertical-align: inherit;">Dies ist in der Auflistung deutlich sichtbar. </font><font style="vertical-align: inherit;">Hier ist ein Beispiel.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">262</span></span> <span class="hljs-number"><span class="hljs-number">0084</span></span> <span class="hljs-number"><span class="hljs-number">490F</span></span>BE00 bcmd_lit8: movsx rax, byte ptr [r8] <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">0088</span></span> <span class="hljs-number"><span class="hljs-number">49F</span></span>FC0 inc r8 <span class="hljs-number"><span class="hljs-number">264</span></span> <span class="hljs-number"><span class="hljs-number">008b</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">265</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>c EB90 jmp _next <span class="hljs-number"><span class="hljs-number">266</span></span> <span class="hljs-number"><span class="hljs-number">267</span></span> b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>e <span class="hljs-number"><span class="hljs-number">490F</span></span>BF00 bcmd_lit16: movsx rax, word ptr [r8] <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">0092</span></span> <span class="hljs-number"><span class="hljs-number">4983</span></span>C002 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> <span class="hljs-number"><span class="hljs-number">0096</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">0097</span></span> EB85 jmp _next <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-number"><span class="hljs-number">0099</span></span> <span class="hljs-number"><span class="hljs-number">496300</span></span> bcmd_lit32: movsx rax, dword ptr [r8] <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-number"><span class="hljs-number">009</span></span>c <span class="hljs-number"><span class="hljs-number">4983</span></span>C004 add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a0 <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a1 E978FFFF jmp _next <span class="hljs-number"><span class="hljs-number">277</span></span> FF <span class="hljs-number"><span class="hljs-number">278</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Zeile 265 und 271 benötigt der Befehl jmp jeweils 2 Byte, und in Zeile 277 ist derselbe Befehl bereits zu 5 Byte kompiliert, da die Sprungdistanz die Länge des Kurzbefehls überschreitet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher werden Bytebefehle wie bad, bye, type weiter neu angeordnet, und wie call, branch, lit sind näher. Leider kann nicht viel in einen 127-Byte-Übergang passen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir fügen der Tabelle der Befehlsadressen neue Befehle entsprechend ihren Codes hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben jetzt eine Herausforderung und eine Rückkehr, wir werden sie testen! Wählen Sie dazu den Zeilendruck in einem separaten Verfahren aus, und wir rufen ihn zweimal in einer Schleife auf. Und die Anzahl der Wiederholungen des Zyklus wird auf drei reduziert.</font></font><br><br><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call8 könnte hier verwendet werden, aber ich habe mich entschieden, call16 als wahrscheinlichste zu verwenden. </font><font style="vertical-align: inherit;">Der Wert 2 wird aufgrund der Besonderheiten der Berechnung der Adresse für den Aufrufbytebefehl, über den ich geschrieben habe, abgezogen. </font><font style="vertical-align: inherit;">Für call8 wird hier 1 abgezogen, für call32 jeweils 4. Wir </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompilieren und rufen auf:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Bad byte code!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ups ... wie sie sagen, etwas ist schief gelaufen :) Nun, wir starten GDB und sehen, was dort passiert. </font><font style="vertical-align: inherit;">Ich habe sofort einen Haltepunkt auf bcmd_exit gesetzt, da klar ist, dass der Aufruf von sub_hello übergeben wird und der Hauptteil der Prozedur ausgeführt wird ... gestartet ... und das Programm den Haltepunkt nicht erreicht hat. </font><font style="vertical-align: inherit;">Sofort bestand der Verdacht auf einen Byte-Befehlscode. </font><font style="vertical-align: inherit;">Und tatsächlich lag der Grund in ihm. </font><font style="vertical-align: inherit;">b_exit Ich habe den Wert 0x1f zugewiesen und die Adresse selbst wurde in die Tabellenzellennummer 0x17 eingefügt. </font><font style="vertical-align: inherit;">Nun, dann werde ich den Wert von b_exit auf 0x17 korrigieren und es erneut versuchen:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genau sechsmal Begrüßung und einmal auf Wiedersehen. </font><font style="vertical-align: inherit;">Wie es sein sollte :)</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständige Quelle</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Was ist das Ergebnis? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine vollständige und ziemlich schnelle 64-Bit-Stack-Byte-Maschine getestet. In Bezug auf die Geschwindigkeit ist diese Byte-Maschine möglicherweise eine der schnellsten ihrer Klasse (eine Stack-Byte-Maschine ohne JIT). Sie weiß, wie man Befehle nacheinander ausführt, bedingte und bedingungslose Sprünge ausführt, Prozeduren aufruft und von ihnen zurückkehrt. Gleichzeitig ist der verwendete Bytecode relativ kompakt. Grundsätzlich belegen Bytebefehle 1-3 Bytes, mehr ist sehr selten (nur große Zahlen und sehr weit entfernte Prozeduraufrufe). Es wird auch ein kleiner Satz von Bytebefehlen skizziert, der leicht zu erweitern ist. Angenommen, alle grundlegenden Befehle für die Arbeit mit dem Stapel (Drop, Swap, Over, Root usw. können in 20 Minuten geschrieben werden, der gleiche Betrag wird für arithmetische Ganzzahlbefehle verwendet).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer wichtiger Punkt. Der Bytecode enthält im Gegensatz zum klassischen direkt genähten Fort-Code keine Maschinenanweisungen, sodass er ohne Neukompilierung auf eine andere Plattform übertragen werden kann. Es reicht aus, den Kernel einmal in das Befehlssystem des neuen Prozessors umzuschreiben, und dies kann sehr schnell erfolgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die aktuelle Version des Byte-Computers ist nicht spezifisch für eine bestimmte Sprache. Aber ich möchte die Fort-Sprache darauf implementieren, weil ich Erfahrung damit habe und der Compiler dafür sehr schnell fertig sein kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn dies auf der Grundlage dieser Maschine Interesse besteht, werde ich im nächsten Artikel Zeichenfolgen und Zahlen, ein Fort-Wörterbuch und einen Interpreter eingeben und ausgeben. Sie können das Team mit Ihren Händen "berühren". Nun, im dritten Artikel werden wir einen Compiler erstellen und ein fast vollständiges Fort-System erhalten. Dann ist es möglich, einige Standardalgorithmen zu schreiben und zu kompilieren und die Leistung mit anderen Sprachen und Systemen zu vergleichen. Sie können zum Beispiel das Sieb von Eratosthenes und dergleichen verwenden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist interessant, mit Optionen zu experimentieren. </font><font style="vertical-align: inherit;">Erstellen Sie beispielsweise die Befehlstabelle 16-Bit, und sehen Sie, wie sich dies auf die Leistung auswirkt. </font><font style="vertical-align: inherit;">Sie können den Einstiegspunkt _next auch in ein Makro verwandeln. In diesem Fall vergrößert sich der Maschinencode jedes Bytebefehls um zwei Befehle (abzüglich des Übergangs und plus drei Befehle von _next). </font><font style="vertical-align: inherit;">Das heißt, am Ende gibt es keinen Übergang zu _next, sondern den Inhalt des _next-Punkts selbst (dies sind 14 Bytes). </font><font style="vertical-align: inherit;">Es ist interessant zu wissen, wie sich dies auf die Leistung auswirkt. </font><font style="vertical-align: inherit;">Sie können auch versuchen, die Optimierung mithilfe von Registern durchzuführen. </font><font style="vertical-align: inherit;">Beispielsweise speichert eine Standardschleife mit einem Zähler in der Festung den Zähler auf dem Rückgabestapel. </font><font style="vertical-align: inherit;">Sie können eine Registerversion erstellen und auch testen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können auch einen Compiler aus Ausdrücken erstellen, die in der klassischen Form geschrieben sind (z. B. A = 5 + (B + C * 4)).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generell gibt es Raum zum Experimentieren! </font></font> :) :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-Maschine für das Fort (und nicht nur) in Native American (Teil 2)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431932/">https://habr.com/ru/post/de431932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431920/index.html">Frontend Mix - Berichte über Node.js, Skalierbarkeit und natives Web</a></li>
<li><a href="../de431922/index.html">Was sind Methodenhandles in Java?</a></li>
<li><a href="../de431924/index.html">Lagerverwaltungssystem mit CQRS und Event Sourcing. Entwicklungsprozess</a></li>
<li><a href="../de431928/index.html">Ermüdung durch Einwegartikel. Oder Ode A.S. Makarenko</a></li>
<li><a href="../de431930/index.html">DevOps-Treffen in St. Petersburg</a></li>
<li><a href="../de431934/index.html">Wie hilft künstliche Intelligenz bei der Arbeit mit juristischen Dokumenten? Vortrag von Egor Budnikov von ABBYY</a></li>
<li><a href="../de431936/index.html">Ergebnisse des TechnoText-Wettbewerbs</a></li>
<li><a href="../de431938/index.html">Ganzzahlige Kubikwurzel in Verilog</a></li>
<li><a href="../de431940/index.html">Menschen brennen aus, wenn sie sich nicht wert fühlen. Was tun?</a></li>
<li><a href="../de431942/index.html">Hierarchische Abhängigkeitsinjektion in React und MobX State Tree als Domänenmodell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>