<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔹 🌍 🐑 在Java中使用var类型的26条建议 📥 👯 ▪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="使用JEP 286：Local-Variable Type Inference 将Java局部变量类型推断（LVTI）或简称var类型（ var标识符不是关键字，而是保留的类型名称）添加到Java 10中。 作为100％的编译器函数，它不会影响字节码，运行时或性能。 基本上，编译器检查赋值运算符的右...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Java中使用var类型的26条建议</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438206/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/mq/zq/0cmqzquxmzrie0s3ryftj5dqvga.png"></div><br><p> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JEP 286：Local-Variable Type Inference</a> <strong>将Java局部变量类型推断（LVTI）</strong>或简称<strong>var</strong>类型（ <strong>var</strong>标识符不是关键字，而是保留的类型名称）添加到Java 10中。 作为100％的编译器函数，它不会影响字节码，运行时或性能。 基本上，编译器检查赋值运算符的右侧，并基于该赋值运算符确定变量的特定类型，然后将其替换为<strong>var</strong> 。 </p><br><p>此外，它对于减少样板代码的冗长性很有用，并且还可以加快编程过程本身。 例如，写<strong><code>var evenAndOdd =...</code></strong>而不是<strong><code>Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd =...</code></strong>非常方便<strong><code>var evenAndOdd =...</code></strong> </p><br><p>  <strong>var</strong>的出现并不意味着在任何地方使用它总是总是方便的，有时使用标准工具会更实用。 </p><br><p> 在本文中，我们将研究26种情况，并举例说明何时可以使用<strong>var</strong> ，以及何时不值得使用<strong>var</strong> 。 </p><a name="habracut"></a><br><h2 id="punkt-1-staraytes-davat-osmyslennye-imena-lokalnym-peremennym"> 要点1：尝试给局部变量起有意义的名字 </h2><br><p> 通常，我们专注于为类的字段提供正确的名称，但是我们对局部变量的名称没有给予同样的关注。 当我们的方法实现完美，包含很少的代码并具有良好的名称时，那么我们常常不注意局部变量，甚至完全不使用它们的名称。 </p><br><p> 当我们使用<strong>var</strong>而不是编写显式类型时，编译器会自动检测到它们并替换<strong>var</strong> 。 但是，另一方面，由于使用<strong>var</strong>会使代码的可读性和理解复杂化，因此人们阅读和理解代码变得更加困难。 在大多数情况下，这是因为我们倾向于将变量的类型视为主要信息，而将其名称视为次要信息。 虽然应该恰恰相反。 </p><br><h3 id="primer-1"> 范例1： </h3><br><p> 许多人可能会同意，在下面的示例中，局部变量的名称太短了： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// HAVING public boolean callDocumentationTask() { DocumentationTool dtl = ToolProvider.getSystemDocumentationTool(); DocumentationTask dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p> 当使用短名称以及<strong>var时</strong> ，代码变得更加不清楚： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public boolean callDocumentationTask() { var dtl = ToolProvider.getSystemDocumentationTool(); var dtt = dtl.getTask(...); return dtt.call(); }</span></span></code> </pre> <br><p> 首选选项： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public boolean callDocumentationTask() { var documentationTool = ToolProvider.getSystemDocumentationTool(); var documentationTask = documentationTool.getTask(...); return documentationTask.call(); }</span></span></code> </pre> <br><h3 id="primer-2"> 范例2： </h3><br><p> 避免这样命名变量： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public List&lt;Product&gt; fetchProducts(long userId) { var u = userRepository.findById(userId); var p = u.getCart(); return p; }</span></span></code> </pre> <br><p> 使用更有意义的名称： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public List&lt;Product&gt; fetchProducts(long userId) { var user = userRepository.findById(userId); var productList = user.getCart(); return productList; }</span></span></code> </pre> <br><h3 id="primer-3"> 范例3： </h3><br><p> 为了给局部变量赋予更易理解的名称，请不要极端： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteArrayOutputStream = new ByteArrayOutputStream();</span></span></code> </pre> <br><p> 相反，您可以使用更简短但也不难理解的选项： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var outputStream = new ByteArrayOutputStream(); // or var outputStreamOfFoo = new ByteArrayOutputStream();</span></span></code> </pre> <br><p> 您是否知道Java有一个内部类，名为： <br>  <strong>InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonWindowNotFocusedState</strong> </p><br><p> 好吧，用这种类型的变量命名可能很麻烦:) </p><br><h2 id="punkt-2-ispolzuyte-literaly-chtoby-pomoch-var-tochno-opredelit-tip-primitiva-int-long-float-double"> 第2点：使用文字帮助var查明基本类型（int，long，float，double） </h2><br><p> 在原始类型不使用文字的情况下，我们可能会发现预期类型和隐含类型可能会有所不同。 这是由<strong>var</strong>变量使用的隐式类型转换引起的。 </p><br><p> 例如，以下两个代码片段的行为符合预期。 在这里，我们显式声明<strong>boolean</strong>和<strong>char</strong>类型： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type boolean char a = 'a'; // this is of type char</span></span></code> </pre> <br><p> 现在我们使用<strong>var</strong> ，而不是显式声明类型： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is inferred as boolean var a = 'a'; // this is inferred as char</span></span></code> </pre> <br><p> 到目前为止一切顺利。 现在对<strong>int</strong> ， <strong>long</strong> ， <strong>float</strong>和<strong>double</strong>类型执行相同的操作： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> intNumber = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">// this is of type int long longNumber = 20; // this is of type long float floatNumber = 20; // this is of type float, 20.0 double doubleNumber = 20; // this is of type double, 20.0</span></span></code> </pre> <br><p> 尽管上面的代码段简单明了，但现在让我们使用<strong>var</strong>而不是显式指定类型。 </p><br><p> 避免： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var intNumber = 20; // this is inferred as int var longNumber = 20; // this is inferred as int var floatNumber = 20; // this is inferred as int var doubleNumber = 20; // this is inferred as int</span></span></code> </pre> <br><p> 所有四个变量都将作为<strong>int</strong>输出。 要解决此问题，我们需要使用Java文字： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var intNumber = 20; // this is inferred as int var longNumber = 20L; // this is inferred as long var floatNumber = 20F; // this is inferred as float, 20.0 var doubleNumber = 20D; // this is inferred as double, 20.0</span></span></code> </pre> <br><p> 但是，如果我们声明一个十进制数会怎样？ </p><br><p> 如果希望获得<strong>float</strong>类型的变量，请避免这种情况： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID, IF THIS IS A FLOAT var floatNumber = 20.5; // this is inferred as double</span></span></code> </pre> <br><p> 为避免意外，请使用适当的文字： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER, IF THIS IS A FLOAT var floatNumber = 20.5F; // this is inferred as float</span></span></code> </pre> <br><h2 id="punkt-3-v-nekotoryh-sluchayah-var-i-neyavnye-privedeniya-tipov-mogut-uprostit-podderzhku-koda"> 要点3：在某些情况下，var和隐式类型转换可以简化代码支持 </h2><br><p> 例如，假设我们的代码在两个方法之间。 一种方法是获取具有不同产品的购物车，然后计算出最佳价格。 为此，他比较了市场上的各种价格，并以<strong>浮点</strong>型的形式返回了总价格。 另一种方法只是从卡中扣除此价格。 </p><br><p> 首先，让我们看一下计算最佳价格的方法： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> price = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; }</code> </pre> <br><p> 其次，让我们看一下适用于地图的方法： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 现在，我们将代码作为客户端放在这两个外部服务方法之间。 我们的用户可以选择要购买的商品，然后我们为他们计算最优惠的价格，然后从卡中注销资金： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public void purchaseCart(long customerId) { ... float price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><p> 一段时间后，拥有API的公司决定放弃价格的材料表示形式，转而使用小数点（现在使用<strong>float</strong> ， <strong>int</strong>代替）。 因此，他们修改了API代码，如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeBestPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] items)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> realprice = ...; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> price = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) realprice; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> price; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">debitCard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> amount, ...)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p> 事实是我们的代码使用<strong>float</strong>变量的显式声明作为价格。 以当前形式，我们将在编译时收到错误。 但是，如果我们预见到了这种情况，并使用<strong>var</strong>而不是<strong>float</strong> ，那么由于隐式类型转换，我们的代码将继续正常工作： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public void purchaseCart(long customerId) { ... var price = computeBestPrice(...); debitCard(price, ...); }</span></span></code> </pre> <br><h2 id="punkt-4-kogda-literaly-ne-yavlyayutsya-podhodyaschim-resheniem-to-ispolzuyte-yavnoe-privedenie-tipov-ili-otkazhites-ot-var"> 要点4：如果文字不是合适的解决方案，请使用显式强制转换或放弃var </h2><br><p>  Java中的某些原始类型没有特殊的文字，例如<strong>字节</strong>和<strong>短</strong>类型。 在这种情况下，使用显式类型指定，我们可以毫无问题地创建变量。 </p><br><p> 使用它代替<strong>var</strong> ： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS INSTEAD OF USING VAR byte byteNumber = 45; // this is of type byte short shortNumber = 4533; // this is of type short</span></span></code> </pre> <br><p> 但是，为什么在这种情况下优先使用显式类型表示法而不是仅使用<strong>var</strong> ？ 好吧，让我们使用<strong>var</strong>编写这段代码。 请注意，在两种情况下，编译器都会假定您需要<strong>int</strong>类型的变量。 </p><br><p> 避免此错误： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var byteNumber = 45; // this is inferred as int var shortNumber = 4533; // this is inferred as int</span></span></code> </pre> <br><p> 这里没有任何文字可以帮助我们，因此我们被迫使用显式的向下类型转换。 就我个人而言，我会避免这种情况，因为我在这里看不到任何优势。 </p><br><p> 仅当您确实要使用<strong>var</strong>时才使用此条目： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER THIS ONLY IF YOU WANT TO USE VAR var byteNumber = (byte) 45; // this is inferred as byte var shortNumber = (short) 4533; // this is inferred as short</span></span></code> </pre> <br><h2 id="punkt-5-izbegayte-ispolzovaniya-var-esli-nazvaniya-peremennyh-ne-soderzhat-dostatochnoy-informacii-o-tipe-dlya-ponimaniya-koda"> 要点5：如果变量名称包含的类型信息不足以理解代码，请避免使用var </h2><br><p> 使用<strong>var</strong>的好处是编写更简洁的代码。 例如，在使用构造函数的情况下，我们可以避免重复类名的需要，从而消除了代码冗余。 </p><br><p> 避免以下情况： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID MemoryCacheImageInputStream inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p> 改用： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var inputStream = new MemoryCacheImageInputStream(...);</span></span></code> </pre> <br><p> 对于下面的构造， <strong>var</strong>也是简化代码而不丢失信息的好方法。 </p><br><p> 避免： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fm = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p> 使用以下代码： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var compiler = ToolProvider.getSystemJavaCompiler(); var fileManager = compiler.getStandardFileManager(...);</span></span></code> </pre> <br><p> 那么，为什么在给出的示例中我们更愿意使用<strong>var</strong> ？ 因为所有必需的信息都包含在变量的名称中。 但是，如果<strong>var</strong>与变量名结合使用会降低代码的清晰度，则最好拒绝使用它。 </p><br><p> 避免： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID public File fetchCartContent() { return new File(...); } // As a human, is hard to infer the "cart" type without // inspecting the fetchCartContent() method var cart = fetchCartContent();</span></span></code> </pre> <br><p> 用途： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public File fetchCartContent() { return new File(...); } File cart = fetchCartContent();</span></span></code> </pre> <br><p> 例如，考虑使用<strong><code>java.nio.channels.Selector</code></strong>类。 此类具有静态的<strong><code>open()</code></strong>方法，该方法返回一个新的Selector并将其打开。 但是在这里您可以轻松地认为<strong><code>Selector.open()</code></strong>方法可以返回<strong>布尔</strong>类型，这取决于打开现有选择器的成功程度，甚至可以返回<strong>void</strong> 。 在此处使用<strong>var</strong>会导致信息丢失和代码混乱。 </p><br><h2 id="punkt-6-tip-var-garantiruet-bezopasnost-vo-vremya-kompilyacii"> 要点6：var类型保证了编译时的安全性 </h2><br><p> 这意味着我们无法编译试图执行不正确分配的应用程序。 例如，下面的代码无法编译： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var items = 10; items = "10 items"; // incompatible types: String cannot be converted to int</span></span></code> </pre> <br><p> 但是这个编译： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-number"><span class="hljs-number">10</span></span>; items = <span class="hljs-number"><span class="hljs-number">20</span></span>;</code> </pre> <br><p> 并且此代码成功编译： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = <span class="hljs-string"><span class="hljs-string">"10"</span></span>; items = <span class="hljs-string"><span class="hljs-string">"10 items"</span></span>;</code> </pre> <br><p> 一旦编译器定义了<strong>var</strong>变量的值，就不能分配除此类型以外的任何内容。 </p><br><h2 id="punkt-7-var-ne-mozhet-ispolzovatsya-dlya-sozdaniya-ekzemplyara-konkretnogo-tipa-i-naznacheniya-ego-peremennoy-tipa-interfeysa"> 要点7：var不能用于实例化特定类型并将其分配给接口类型变量 </h2><br><p> 在Java中，我们使用“使用接口编程”方法。 例如，我们创建ArrayList类的实例，并将其与抽象（接口）相关联： </p><br><pre> <code class="java hljs">List&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p> 而且我们避免将对象绑定到相同类型的变量： </p><br><pre> <code class="java hljs">ArrayList&lt;String&gt; products = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br><p> 这是最常见且最理想的做法，因为我们可以轻松地用任何其他方式替换接口实现。 为此，只需要声明一个接口类型变量。 </p><br><p> 我们将无法使用var变量来遵循这个概念，因为 始终为他们显示特定类型。 例如，在下面的代码片段中，编译器会将变量的类型确定为<strong><code>ArrayList&lt;String&gt;</code></strong> ： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;String&gt;(); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p> 有几种防御参数可以解释此行为： </p><br><ul><li><p>  <strong>var</strong>用于局部变量，在大多数情况下，使用接口编程要比使用值或字段返回的方法参数少 </p><br></li><li><p> 局部变量的范围应该很小，因此解决由于切换到另一个实现而引起的问题应该不会很困难 </p><br></li><li><p>  <strong>var</strong>将右侧的代码视为用于确定实际类型的初始化程序。 如果在某个时候更改了初始化程序，则定义的类型也可能更改，从而导致依赖此变量的代码出现问题。 </p><br></li></ul><br><h2 id="punkt-8-veroyatnost-vyvoda-neozhidaemogo-tipa"> 要点8：意外类型的推断的可能性 </h2><br><p> 在没有信息来标识类型的情况下将var与<strong>菱形运算符</strong> （&lt;&gt;）结合使用可能会导致意外结果。 </p><br><p> 在Java 7之前，显式类型推断用于集合： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicitly specifying generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;String&gt;();</span></span></code> </pre> <br><p> 从Java 7开始，引入了<strong>diamond运算符</strong> 。 在这种情况下，编译器将独立派生必要的类型： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferring generic class's instantiation parameter type List&lt;String&gt; products = new ArrayList&lt;&gt;();</span></span></code> </pre> <br><p> 下面的代码将输出什么类型？ </p><br><p> 您应该避免这样的构造： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID var productList = new ArrayList&lt;&gt;(); // is inferred as ArrayList&lt;Object&gt;</span></span></code> </pre> <br><p> 该类型将定义为<strong><code>ArrayList&lt;Object&gt;</code></strong> 。 这是因为未提供正确确定类型所需的信息。 这导致将选择最接近的类型，这可以与正在发生的情况相兼容。 在这种情况下， <strong><code>Object</code></strong> 。 </p><br><p> 因此，只有在我们提供确定所需类型的必要信息时，才能使用<strong>var</strong> 。 可以直接指定类型，也可以将其作为参数传递。 </p><br><p> 直接指定类型： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var productList = new ArrayList&lt;String&gt;(); // inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><p> 传递所需类型的参数： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;String&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(productStack); <span class="hljs-comment"><span class="hljs-comment">// inferred as ArrayList&lt;String&gt;</span></span></code> </pre> <br><pre> <code class="java hljs">Product p1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); Product p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listOfProduct = List.of(p1, p2); <span class="hljs-comment"><span class="hljs-comment">// inferred as List&lt;Product&gt; // DON'T DO THIS var listofProduct = List.of(); // inferred as List&lt;Object&gt; listofProduct.add(p1); listofProduct.add(p2);</span></span></code> </pre> <br><h2 id="punkt-9-prisvoenie-massiva-k-var-peremennoy-ne-trebuet-skobok--"> 第9项：将数组分配给var变量不需要方括号[] </h2><br><p> 我们都知道如何在Java中声明数组： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// or, less preferred int numbers[] = new int[5];</span></span></code> </pre> <br><p> 使用数组时如何使用<strong>var</strong> ？ 在这种情况下，无需在左侧使用括号。 </p><br><p> 避免以下情况（甚至无法编译）： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var[] numbers = new int[5]; // or var numbers[] = new int[5];</span></span></code> </pre> <br><p> 用途： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var numbers = new int[5]; // inferred as array of int numbers[0] = 2; // work numbers[0] = 2.2; // doesn't work numbers[0] = "2"; // doesn't work</span></span></code> </pre> <br><p> 下面使用<strong>var</strong>的代码也无法编译。 这是因为编译器无法从右侧确定类型： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type work as expected int[] numbers = {1, 2, 3}; // IT DOESN'T COMPILE var numbers = {1, 2, 3}; var numbers[] = {1, 2, 3}; var[] numbers = {1, 2, 3};</span></span></code> </pre> <br><h2 id="punkt-10-var-nelzya-ispolzovat-pri-obyavlenii-neskolkih-peremennyh-v-odnoy-stroke"> 项目10：在同一行上声明多个变量时，不能使用var </h2><br><p> 如果您想一次声明一种类型的变量，那么您需要知道<strong>var</strong>不适合于此。 以下代码无法编译： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: 'var' is not allowed in a compound declaration var hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p> 改用： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String hello = "hello", bye = "bye", welcome = "welcome";</span></span></code> </pre> <br><p> 还是： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER var hello = "hello"; var bye = "bye"; var welcome = "welcome";</span></span></code> </pre> <br><h2 id="punkt-11-lokalnye-peremennye-dolzhny-stremitsya-k-minimizacii-svoey-oblasti-vidimosti-tip-var-usilivaet-eto-utverzhdenie"> 要点11：局部变量应努力使其范围最小。  var类型加强了该语句。 </h2><br><p> 对于局部变量，请保留较小的范围-我确定您在<strong>var</strong>之前听过此声明。 </p><br><p> 可读性和快速修复错误是支持此方法的理由。 例如，让我们如下定义一个堆栈： </p><br><p> 避免这种情况： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // George, Tyllen, Martin, Kelly stack.forEach(...); ...</span></span></code> </pre> <br><p> 请注意，我们正在调用<strong><code>forEach()</code></strong>方法，该方法继承自<strong><code>java.util.Vector</code></strong> 。 此方法将像其他任何向量一样遍历堆栈，这就是我们需要的。 但是现在我们决定使用<strong><code>ArrayDeque</code></strong>而不是<strong><code>Stack</code></strong> 。 当我们这样做时， <strong><code>forEach()</code></strong>方法将从ArrayDeque接收实现，该实现将作为标准堆栈（LIFO）遍历堆栈 </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID ... var stack = new ArrayDeque&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // 50 lines of code that doesn't use stack // Kelly, Martin, Tyllen, George stack.forEach(...); ...</span></span></code> </pre> <br><p> 这不是我们想要的。 在这里很难跟踪错误，因为包含<strong><code>forEach()</code></strong>部分的代码并不位于进行更改的代码旁边。 为了提高查找和修复错误的速度，最好使用<strong><code>stack</code></strong>变量编写代码，并尽可能靠近此变量的声明。 </p><br><p> 最佳做法如下： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER ... var stack = new Stack&lt;String&gt;(); stack.push("George"); stack.push("Tyllen"); stack.push("Martin"); stack.push("Kelly"); ... // George, Tyllen, Martin, Kelly stack.forEach(...); ... // 50 lines of code that doesn't use stack</span></span></code> </pre> <br><p> 现在，当开发人员从<strong><code>Stack</code></strong>切换到<strong><code>ArrayQueue</code></strong> ，他将能够迅速注意到错误并进行修复。 </p><br><h2 id="punkt-12-tip-var-uproschaet-ispolzovanie-razlichnyh-tipov-v-ternarnyh-operatorah"> 第12条：var类型简化了三元运算符中各种类型的使用 </h2><br><p> 我们可以在三元运算符的右侧使用不同类型的操作数。 </p><br><p> 当明确指定类型时，以下代码不会编译： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE List code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // or Set code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10);</span></span></code> </pre> <br><p> 不过，我们可以这样做： </p><br><pre> <code class="java hljs">Collection code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); Object code = containsDuplicates ? List.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) : Set.of(<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p> 以下代码也无法编译： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE int code = intOrString ? 12112 : "12112"; String code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p> 但是您可以使用更多常规类型： </p><br><pre> <code class="java hljs">Serializable code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>; Object code = intOrString ? <span class="hljs-number"><span class="hljs-number">12112</span></span> : <span class="hljs-string"><span class="hljs-string">"12112"</span></span>;</code> </pre> <br><p> 在所有这些情况下，最好使用<strong>var</strong> ： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // inferred as Collection&lt;Integer&gt; var code = containsDuplicates ? List.of(12, 1, 12) : Set.of(12, 1, 10); // inferred as Serializable var code = intOrString ? 12112 : "12112";</span></span></code> </pre> <br><p> 从这些示例中不能得出<strong>var</strong>类型在运行时定义对象类型的结论。 事实并非如此！ </p><br><p> 而且，当然， <strong>var</strong>类型将与两个操作数的相同类型一起正常工作： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inferred as float var code = oneOrTwoDigits ? 1211.2f : 1211.25f;</span></span></code> </pre> <br><h2 id="punkt-13-tip-var-mozhet-byt-ispolzovan-vnutri-ciklov"> 要点13：var类型可以在循环内使用 </h2><br><p> 我们可以轻松地将<strong>for</strong>循环中类型的显式声明替换<strong>为</strong> <strong>var</strong>类型。 </p><br><p> 将显式<strong>int</strong>类型更改为<strong>var</strong> ： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type for (int i = 0; i &lt; 5; i++) { ... } // using var for (var i = 0; i &lt; 5; i++) { // i is inferred of type int ... }</span></span></code> </pre> <br><p> 将<strong><code>Order</code></strong>的显式类型更改为<strong>var</strong> ： </p><br><pre> <code class="java hljs">List&lt;Order&gt; orderList = ...; <span class="hljs-comment"><span class="hljs-comment">// explicit type for (Order order : orderList) { ... } // using var for (var order : orderList) { // order type is inferred as Order ... }</span></span></code> </pre> <br><h2 id="punkt-14-var-otlichno-rabotaet-s-potokami-stream-v-java-8"> 要点14：var在Java 8中可以很好地处理流 </h2><br><p> 将Java 10中的var与Java 8中出现的流一起使用非常简单。 </p><br><p> 您可以简单地用<strong>var</strong>替换<strong>Stream</strong>类型的显式声明： </p><br><h3 id="primer-1-1"> 范例1： </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 4, 5); numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println); // using var var numbers = Stream.of(1, 2, 3, 4, 5); // inferred as Stream&lt;Integer&gt; numbers.filter(t -&gt; t % 2 == 0).forEach(System.out::println);</span></span></code> </pre> <br><h3 id="primer-2-1"> 范例2： </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit types Stream&lt;String&gt; paths = Files.lines(Path.of("...")); List&lt;File&gt; files = paths.map(p -&gt; new File(p)).collect(toList()); // using var var paths = Files.lines(Path.of("...")); // inferred as Stream&lt;String&gt; var files = paths.map(p -&gt; new File(p)).collect(toList()); // inferred as List&lt;File&gt;</span></span></code> </pre><br><h2 id="punkt-15-var-mozhno-ispolzovat-pri-obyavlenii-lokalnyh-peremennyh-prednaznachennyh-dlya-razbieniya-bolshih-cepochek-vyrazheniy-na-chasti"> 第15条：在声明旨在将大型表达式链分解成多个部分的局部变量时，可以使用var </h2><br><p> 带有大量嵌套的表达式看起来令人印象深刻，通常看起来像是某种智能且重要的代码段。 在需要提高代码可读性的情况下，建议使用局部变量将大表达式分解。 但是有时候写很多局部变量似乎是一项非常累人的工作，我想避免。 </p><br><p> 一个大型表达式的示例： </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// AVOID int result = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)) .values() .stream() .max(Comparator.comparing(List::size)) .orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p> 最好将代码分解为各个组成部分： </p><br><pre> <code class="java hljs">List&lt;Integer&gt; intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER Map&lt;Boolean, List&lt;Integer&gt;&gt; evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); Optional&lt;List&lt;Integer&gt;&gt; evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); int sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><p> 该代码的第二个版本看起来更易读，更简单，但是第一个版本也有权使用。 对我们来说，适应如此大的表达式并偏向于局部变量更喜欢我们。 但是，使用<strong>var</strong>类型可以通过减少声明局部变量的工作量来帮助破坏大型结构： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intList = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// PREFER var evenAndOdd = intList.stream() .collect(Collectors.partitioningBy(i -&gt; i % 2 == 0)); var evenOrOdd = evenAndOdd.values() .stream() .max(Comparator.comparing(List::size)); var sumEvenOrOdd = evenOrOdd.orElse(Collections.emptyList()) .stream() .mapToInt(Integer::intValue) .sum();</span></span></code> </pre> <br><h2 id="punkt-16-var-ne-mozhet-byt-ispolzovan-kak-tip-vozvraschaemogo-znacheniya-ili-kak-tip-argumenta-metoda"> 第16条：var不能用作返回类型或方法参数类型 </h2><br><p> 下面显示的两个代码段将无法编译。 </p><br><p> 使用<strong>var</strong>作为返回类型： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public var countItems(Order order, long timestamp) { ... }</span></span></code> </pre> <br><p> 使用<strong>var</strong>作为方法参数的类型： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public int countItems(var order, var timestamp) { ... }</span></span></code> </pre> <br><h2 id="punkt-17-lokalnye-peremennye-tipa-var-mogut-byt-peredany-kak-parametry-metoda-ili-mogut-prinimat-vozvraschaemoe-metodom-znachenie"> 第17条：var类型的局部变量可以作为方法的参数传递，也可以采用方法返回的值 </h2><br><p> 以下代码片段将编译并正常运行： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Order order, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timestamp)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// an Order instance var timestamp = ...; // a long representing a timestamp var itemsNr = countItems(order, timestamp); // inferred as int type ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;A, B&gt; <span class="hljs-function"><span class="hljs-function">B </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A container, B tocontain)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = ...; <span class="hljs-comment"><span class="hljs-comment">// Order instance var product = ...; // Product instance var resultProduct = contains(order, product); // inferred as Product type</span></span></code> </pre> <br><h2 id="punkt-18-peremennye-var-mogut-byt-ispolzovany-s-anonimnymi-klassami">  18:  var       </h2><br><p>    : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; Product product = ...; // a Product instance int weight = weighter.getWeight(product);</span></span></code> </pre> <br><p>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var weighter = new Weighter() { @Override public int getWeight(Product product) { ... } }; var product = ...; // a Product instance var weight = weighter.getWeight(product);</span></span></code> </pre> <br><h2 id="punkt-19-peremennye-tipa-var-mogut-ispolzovatsya-v-kachestve-effectively-final-peremennyh">  19:   var     effectively final  </h2><br><p> , : </p><br><blockquote> <em>…   Java SE 8,           ,   final  effectively final.   ,        ,  effectively final</em> . </blockquote><p>  ,   <strong>var</strong>   effectively final.      . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// AVOID int ratio = 5; // this is effectively final Weighter weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Weighter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Product product)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// PREFER var ratio = 5; // this is effectively final var weighter = new Weighter() { @Override public int getWeight(Product product) { return ratio * ...; } }; ratio = 3; // this reassignment will cause error</span></span></code> </pre> <br><h2 id="punkt-20-var-peremennye-mogut-byt-final-peremennymi">  20: var-   final- </h2><br><p>   <strong>var</strong>     ( ,     effectively final).     ,  <strong>final</strong> . </p><br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// AVOID // IT DOESN'T COMPILE public void discount(int price) { final int limit = 2000; final int discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><p> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER // IT DOESN'T COMPILE public void discount(int price) { final var limit = 2000; final var discount = 5; if (price &gt; limit) { discount++; // this reassignment will cause error, which is ok } }</span></span></code> </pre> <br><h2 id="punkt-21-lyambda-vyrazheniyam-i-ssylkam-na-metody-nuzhny-yavnye-tipy">  21:          </h2><br><p>  <strong>var</strong>   ,     .          ,   <strong>var</strong> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // lambda expression needs an explicit target-type var f = x -&gt; x + 1; // method reference needs an explicit target-type var exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Supplier&lt;IllegalArgumentException&gt; exception = IllegalArgumentException::new;</span></span></code> </pre> <br><p>   Java 11   <strong>var</strong> -    .      Java 11: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java 11 (var x, var y) -&gt; x + y // or (@Nonnull var x, @Nonnull var y) -&gt; x + y</span></span></code> </pre> <br><h2 id="punkt-22-inicializirovat-var-nullem-zaprescheno">  22:  var null'  </h2><br><p>   <strong>var</strong> -  . </p><br><p>     (  <strong>null</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message = null; // result in an error of type: variable initializer is 'null'</span></span></code> </pre> <br><p>      ( ): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE var message; // result in: cannot use 'var' on variable without initializer ... message = "hello";</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER String message = null; // or String message; ... message = "hello";</span></span></code> </pre> <br><h2 id="punkt-23-tip-var-nelzya-ispolzovat-v-polyah-klassa">  23:  var      </h2><br><p>    <strong>var</strong>   ,      . </p><br><p>      : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE public class Product { private var price; // error: 'var' is not allowed here private var name; // error: 'var' is not allowed here ... }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER public class Product { private int price; private String name; ... }</span></span></code> </pre> <br><h2 id="punkt-24-var-nelzya-ispolzovat-v-bloke-catch">  24: var     catch </h2><br><p>   ,    try-with-resources </p><br><h3 id="blok-catch">  catch </h3><br><p>    ,    ,   . </p><br><p>     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE try { TimeUnit.NANOSECONDS.sleep(5000); } catch (var ex) { ... }</span></span></code> </pre> <br><p>        : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// PREFER try { TimeUnit.NANOSECONDS.sleep(5000); } catch (InterruptedException ex) { ... }</span></span></code> </pre> <br><h3 id="try-with-resources"> Try-with-resources </h3><br><p> , <strong>var</strong>     <strong>try-with-resources</strong> . </p><br><p> ,  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type try (PrintWriter writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><p>     <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var try (var writer = new PrintWriter(new File("welcome.txt"))) { writer.println("Welcome message"); }</span></span></code> </pre> <br><h2 id="punkt-25-tip-var-mozhno-ispolzovat-s-dzhenerikami">  25:  var     </h2><br><p> ,     : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ T temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>   ,  <strong>var</strong>    ,       <strong>T</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = t; ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; }</code> </pre> <br><p>     ,      <strong>var</strong> : </p><br><pre> <code class="java hljs">codepublic &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;T&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)); numbers.add((T) Double.valueOf(<span class="hljs-number"><span class="hljs-number">3.9</span></span>)); numbers.add(t); numbers.add(<span class="hljs-string"><span class="hljs-string">"5"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><p>     <strong>List&lt;T&gt;</strong>  <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends Number&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;T&gt;(); <span class="hljs-comment"><span class="hljs-comment">// DON'T DO THIS, DON'T FORGET THE, T var numbers = new ArrayList&lt;&gt;(); numbers.add((T) Integer.valueOf(3)); numbers.add((T) Double.valueOf(3.9)); numbers.add(t); numbers.add("5"); // error: incompatible types: String cannot be converted to T ... }</span></span></code> </pre> <br><h2 id="punkt-26-budte-vnimatelny-s-tipom-var-pri-ispolzovanii-wildcards--kovariantov-i-kontrvariantov">  26:     var   Wildcards (?),    </h2><br><h3 id="ispolzovanie--wildcards"> ? Wildcards </h3><br><p>    <strong>var</strong>  : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;?&gt; clazz = Integer.class; // use var var clazz = Integer.class;</span></span></code> </pre> <br><p>    <strong>Foo&lt;?&gt;</strong>  <strong>var</strong>  ,      ,    <strong>var</strong>    . </p><br><p>     ,   , , ,    .       ,     <strong>ArrayList</strong>  ,     <strong>Collection&lt;?&gt;</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Collection&lt;?&gt; stuff = new ArrayList&lt;&gt;(); stuff.add("hello"); // compile time error stuff.add("world"); // compile time error // use var, this will remove the error, but I don't think that this is // what you had in mind when you wrote the above code var stuff = new ArrayList&lt;&gt;(); strings.add("hello"); // no error strings.add("world"); // no error</span></span></code> </pre> <br><h3 id="ispolzovanie-kovariantov-foo--extends-t-i-kontrvariantov-foo--super-t">   (Foo &lt;? extends T&gt;)   (Foo &lt;? super T&gt;) </h3><br><p>  ,    : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// explicit type Class&lt;? extends Number&gt; intNumber = Integer.class; Class&lt;? super FilterReader&gt; fileReader = Reader.class;</span></span></code> </pre> <br><p>            ,    ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// IT DOESN'T COMPILE // error: Class&lt;Reader&gt; cannot be converted to Class&lt;? extends Number&gt; Class&lt;? extends Number&gt; intNumber = Reader.class; // error: Class&lt;Integer&gt; cannot be converted to Class&lt;? super FilterReader&gt; Class&lt;? super FilterReader&gt; fileReader = Integer.class;</span></span></code> </pre> <br><p>    <strong>var</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// using var var intNumber = Integer.class; var fileReader = Reader.class;</span></span></code> </pre> <br><p>       ,     .        –     : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// this will compile just fine var intNumber = Reader.class; var fileReader = Integer.class;</span></span></code> </pre> <br><h2 id="zaklyuchenie"> 结论 </h2><br><p>       « <strong>var</strong> »,    Java 10.    ,           .   ,      <strong>var</strong>    ,     . </p><br><p>  <strong>var</strong>      Java! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438206/">https://habr.com/ru/post/zh-CN438206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438192/index.html">戴尔Inspiron 14（5482）：经济高效的2合1升级选项</a></li>
<li><a href="../zh-CN438196/index.html">如果项目是“剧院”，请使用演员...</a></li>
<li><a href="../zh-CN438198/index.html">让我们深入历史：直升机的腿在哪里生长</a></li>
<li><a href="../zh-CN438202/index.html">JavaScript：公共和私有类字段</a></li>
<li><a href="../zh-CN438204/index.html">Swift编译器设备。 第一部分</a></li>
<li><a href="../zh-CN438210/index.html">泉城文明，2/5</a></li>
<li><a href="../zh-CN438212/index.html">概念验证：如何验证ML实现值得我们关注</a></li>
<li><a href="../zh-CN438214/index.html">美国科技初创公司将在2019年面临新的政府管制</a></li>
<li><a href="../zh-CN438218/index.html">OpenSceneGraph：事件处理</a></li>
<li><a href="../zh-CN438224/index.html">政府宿舍。 飞行员</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>