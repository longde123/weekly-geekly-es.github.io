<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💻 🧕🏻 💀 Controlamos o gerador ou a luta contra o ADC no STM32F030 👸🏾 👩🏿 🧔🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="De alguma forma, historicamente, não funcionou para mim com a família STM32F030, há cerca de 5 anos, tentei trabalhar com eles e, por um longo tempo, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Controlamos o gerador ou a luta contra o ADC no STM32F030</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448202/"> De alguma forma, historicamente, não funcionou para mim com a família STM32F030, há cerca de 5 anos, tentei trabalhar com eles e, por um longo tempo, fiquei surpreso com o trabalho desajeitado da maioria dos periféricos e depois os consertei.  E no outro dia, eu ainda tinha que voltar a esta série, era necessário medir por dinheiro mínimo a tensão constante em uma bateria de chumbo (ou montagem de até 4 peças em série) de 8 a 60V com uma precisão não pior que ± 0,1V com baixa frequência de polling. <br><br>  A solução do problema "frontal" tornou possível medir com precisão a tensão apenas quando o valor da entrada ADC é superior a 1,5 ... 1,6V, ou seja, apenas na segunda metade da faixa, o que significava 30 ... 60V para mim, em vez dos 8 necessários. .60V.  O principal problema estava na faixa de 0 ... 1,6V, parecia que meu divisor de tensão estava "flutuando" ou a tensão de referência para o ADC (V <sub>ref</sub> ) era extremamente instável. <br><br>  Era necessário resolver rapidamente o problema, embora não da maneira mais elegante, mas pelo menos sem muletas óbvias.  Para fazer isso, primeiro foi necessário estudar o problema e entender de onde as “pernas crescem” e depois eliminar esse problema.  Se não der certo, pelo menos contorne-o para obter um dispositivo funcionando e enviá-lo ao cliente. <br><br><img src="https://habrastorage.org/webt/4u/fa/6z/4ufa6zj7pfysphxs0dye2xapd5a.jpeg"><br><a name="habracut"></a><br><h2>  Essência da tarefa </h2><br>  Em geral, eu venho tentando não resolver esse problema por um longo tempo, mas um parente se voltou para mim e, em período parcial, uma boa pessoa que também trabalha em tópicos próximos a mim - ele coleciona pequenos SES em algum lugar da região de Moscou.  Eu não queria recusar, e mesmo naquele momento essa tarefa me pareceu “algumas horas de ferro + algumas horas de código”.  O projeto no Altium Designer realmente me levou algumas horas, mas a luta contra o ADC foi iniciada a noite toda, então decidi compartilhar informações para que outros não perdessem tempo. <br><br>  <u>O dispositivo em si é extremamente simples, o algoritmo é o seguinte:</u> <br><br><ul><li>  meça a voltagem na montagem de 1 a 4 baterias de chumbo conectadas em série; </li><li>  se a tensão for menor que o "limiar inferior", feche o relé e ligue o gerador, que carrega nossas baterias; </li><li>  se a tensão subir acima do "limiar mais baixo + histerese", ou seja, as baterias estiverem carregadas até o limiar definido, desligue o gerador; </li><li>  se a tensão estiver acima do "limite superior", proibimos a ativação do gerador por precaução. </li></ul><br>  Isso é tudo!  Exemplo: existe uma bateria de 12V e o inversor é alimentado por ela.  Se a tensão cair abaixo do "limiar inferior", o padrão é 10,2V e ligue o gerador.  Se a voltagem da bateria aumentar para "limiar mais baixo + histerese", desligue-a.  Por padrão, a histerese é configurada para 2V e é necessária para que o gerador a gasolina não seja cortado assim que carregar ligeiramente a bateria para 10,3V.  De constante ligar / desligar, o gerador simplesmente morre.  Bem, por precaução, proteção: se a tensão da bateria estiver acima de 14,4V, não ligue o gerador exatamente. <br><br>  O algoritmo é simples e claro, além disso, foi necessário fazer um pequeno menu para que três variáveis ​​pudessem ser alteradas: “limiar inferior”, “histerese”, “limiar superior”.  Nada complicado, mas o diabo está nos detalhes. <br><br>  Inicialmente, a empresa em que o parente trabalha usava um dispositivo chinês com funcionalidade semelhante.  Das desvantagens menores - era impossível alterar a histerese, pois a energia precisava de uma fonte adicional de 5V e uma medição de apenas 30V, ou seja, para 1 ou 2 baterias.  Dos <b>grandes</b> desvantagens - o dispositivo chinês às vezes congela e reinicia no momento do início do gerador de gasolina que ele controlava.  O último "recurso" acabou de se tornar o motivo da tentativa de abandonar a decisão chinesa. <br><br>  Eles queriam eliminar todas essas desvantagens de mim e que o preço do dispositivo era igual ao dos chineses, ou seja, US $ 10.  A "ninharia diabólica" nesse caso foi que eles queriam comprar um dispositivo acabado de mim por US $ 10 em lotes de apenas 20 a 30 peças, embora fosse estável e com frequência suficiente.  Ou seja, eu tive que tornar o dispositivo muito melhor e muito mais barato que os chineses em uma pequena série, também preciso ganhar dinheiro no futuro.  Sim, eu também fui engraçado nos primeiros 10 minutos, mas quando percebi essa situação, eu já disse "SIM", ou seja, não havia terra além do Volga para mim ... <br><br><h2>  Resolução de problemas de ferro </h2><br>  Como escrevi acima, o principal problema é a operação instável do dispositivo durante a partida do gerador.  Como resultado, um dispositivo chinês com aliexpress foi comprado para testes e pesquisas.  O principal motivo da “demolição da cabeça” acabou não sendo o gerador, mas o relé :)) No momento de alternar a fonte de alimentação, um pulso com uma amplitude de cerca de 25V passava pelo barramento de 3,3V, o que sugeria ... O mesmo foi para os circuitos de sinal.  No circuito chinês, para combater esse problema, estavam os diodos LL4148, que bloqueavam o caminho da interferência.  Isso acabou sendo suficiente para o dispositivo funcionar normalmente em cima da mesa, mas não em um monte de interferências externas adicionais, como um gerador e outros equipamentos.  Para me livrar permanentemente do descrito acima, decidi usar o <b>isolamento galvânico</b> através de um monte de "optocoupler + dc / dc", que eliminava completamente o contato elétrico e o caminho da interferência entre a bobina do relé de controle e o restante do circuito. <br><br><img src="https://habrastorage.org/webt/l0/4r/cr/l04rcre8uydqsnfhozzzaejo0mq.png"><br><br>  Uma alternativa a essa solução foi o uso de diodos de TVS de proteção em conjunto com uma bobina de modo comum, bem como a complicação do filtro de energia.  Mas por que uma fazenda tão coletiva?  Colocar dc / dc é mais fácil, mas na prática ficou ainda mais barato - o módulo chinês Mornsun B0505S-1WR2 me custou US $ 0,4 com o custo de uma bobina de modo comum por um pequeno lote de cerca de US $ 0,32. <br><br>  Como resultado, após tal decisão e teste de protótipo, o dispositivo começou a funcionar como uma espingarda de assalto Kalashnikov e os problemas com a reinicialização desapareceram.  Em geral, estou um pouco surpreso que o relé + um pouco o gerador ainda tenha sido forçado a reiniciar o stm-ku, os desenvolvedores chineses, em princípio, fizeram tudo bem: 10 kOhm + 0,1 uF para redefinir, bloqueando capacitores de energia, contas de ferrite, tudo estava, mas acabou sendo o mesmo de qualquer maneira não é suficiente. <br><br>  O segundo menos dos "chineses" era a necessidade de energia adicional, aparentemente economizada em dc / dc.  Resolvi o problema na testa - peguei energia do sinal de entrada, diretamente de um conector.  Para fazer isso, basta colocar dc / dc, que digerirá pelo menos 4 * 14,4V, ou seja, 57,6V.  Minha escolha caiu no LMR16010PDDAR.  Em primeiro lugar, este é o Texas e é isso.  Em segundo lugar, os camaradas asiáticos sugeriram que eu carregasse esse chip por um preço muito baixo. <br><br>  O parágrafo anterior decidiu de maneira abrangente o terceiro menos - a capacidade de conectar até 4 baterias em série.  DC / DC digere facilmente 60V, começa a tentar queimar apenas em 72 ... 73V, então o máximo de 57,6V definitivamente não é assustador para ele.  O divisor de tensão em geral não se importa com o valor da entrada, então tudo foi decidido com o mínimo esforço. <br><br>  Você pode ver como tudo isso é implementado no diagrama aqui - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PDF</a> .  O esquema é grande o suficiente, então eu não o preenchi com uma imagem.  A propósito, em pdf, você também pode ver as dimensões com uma placa de circuito impresso, mas não há nada sobrenatural. <br><br>  Como resultado, os componentes para 10 dispositivos foram encomendados para o primeiro lote de teste e, após a montagem, ficou assim: <br><br><img src="https://habrastorage.org/webt/0e/ve/st/0evestpmuht21eg31ku7odxxdtk.jpeg"><br><br>  Não foi sem incidentes - quando criei o componente para o módulo dc / dc, misturei as pernas 1 e 2 em alguns lugares, tive que fazer uma pequena fazenda.  Embora eu tenha feito isso com mais cuidado nas placas subseqüentes para que ninguém percebesse, a placa da foto permaneceu comigo como uma ferramenta de depuração, apenas para o caso de aprimoramentos de software, se o cliente descobrisse algo durante o teste. <br><br><h2>  Combate à precisão da ADC </h2><br>  Agora vamos para a parte principal do artigo.  Como escrevi no início do artigo, o F030 ADC acabou sendo impreciso, ou seja, até uma tensão de 30 ... 32V na entrada do dispositivo, as leituras flutuaram com um desvio de até 15 ... 20% e o erro desapareceu gradualmente.  Uma coisa me agradou - à primeira vista, os desvios tinham alguma regularidade, o que significa que este não é um erro aleatório e você pode acompanhá-lo e tentar corrigi-lo. <br><br>  Vamos dar um pouco mais de detalhes sobre o erro ... Após a conversão, o ADC envia os dados brutos para o registro <i>DR</i> , que contém um valor de 0 a 4095 (2 <sup>12</sup> ).  Para converter esse valor em voltagem, você precisa multiplicá-lo pela etapa de quantização.  No meu caso, a tensão no pino do VDDA, da qual o ADC recebe o suporte, foi de 3,3072V e, consequentemente, o passo é de 3,3072V / 4096 = 0,000807V, arredondado para 0,0008.  Para obter a tensão na entrada do dispositivo, a tensão obtida precisa ser multiplicada pelo coeficiente do divisor de tensão; no meu caso, o resistor no braço é de 100 kOhm, e no braço de 4,7 kOhm, o que fornece o divisor 22,2765.  Com base nisso, a tensão na entrada do dispositivo, ou seja, a tensão da bateria, é encontrada usando a fórmula: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> voltageReference = <span class="hljs-number"><span class="hljs-number">0.0008</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> voltageDivider = <span class="hljs-number"><span class="hljs-number">22.2765</span></span>; adcVoltageResult = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)adcData * voltageReference * voltageDivider;</code> </pre> <br>  Acontece que, depois de ler os dados <i>ADC1-&gt; DR</i> , eles são convertidos no tipo <i>float</i> e simplesmente multiplicados pelos coeficientes, que são constantes, e obtemos o resultado nos volts habituais.  Na prática, verificou-se que tudo está muito ruim com precisão. <br><br>  Lembrando-me da navalha de Hanlon, comecei a procurar o lugar onde havia cometido um erro.  Primeiro, verifiquei a tensão na perna do VDDA, pensei que de alguma forma flutua e depende da tensão de entrada, por exemplo, o LDO está com defeito.  Armado com um multímetro de mesa, ele monitorou a tensão no VDDA e alterou a tensão de entrada de 8 para 60V, enquanto a tensão na perna do VDDA permaneceu inoperante em 3,3072V, apenas os 2 sinais seguintes flutuaram, o que é muito bom para um medidor linear de 10 centavos. <br><br>  O próximo local para erro em potencial foi o divisor de tensão.  Embora me parecesse estranho que os resistores de Bourns estejam flutuando ± 0,1%, de modo que os dados apresentem um erro de até 20% e esse erro não seja linear.  Conduzi o mesmo experimento: medi a tensão após o divisor com um multímetro e alterei a tensão de entrada em etapas de 0,5V e, como resultado, o coeficiente do divisor também foi firmemente fixado em 22,2768. <br><br>  Nesse momento, começou a se tornar interessante.  Havia apenas um componente que eu duvidava - o amplificador operacional LMV611MFX.  Este amplificador operacional está incluído como um seguidor de tensão.  A tensão ANTES e DEPOIS era a mesma até 4 casas decimais.  Estranho ... Pela folha de dados não é ruim e é a mesma TI, duvidei, mas decidi verificar, porque  é esse opamp nunca usado.  Só para garantir, o meu favorito e testado em vários projetos OPA320, que tenho nas bobinas, foram soldados em seu lugar e ele mostrou o mesmo resultado. <br><br>  O último componente permaneceu - MK, ou seja, o seu ADC.  Ao longo dos anos usando o STM, estou acostumado a confiar nos produtos deles, especialmente porque eu só pego os originais, então pensei na MK por último.  A primeira coisa que pensei foi que esqueci de calibrar ou fiz errado.  Úteis no manual de referência, eles exigiram não apenas reduzir o ADC escrevendo zero no bit <i>ADEN</i> , mas também definir 1 para <i>ADDIS</i> e 0 para <i>DMAEN</i> .  Os últimos 2 passos não foram seguidos, geralmente eu diminuo o ADC e tudo funciona bem, como resultado, corrigi um pedaço de código com calibração: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* disable ADC */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ADC1-&gt;CR &amp; ADC_CR_ADEN) { ADC1-&gt;CR |= ADC_CR_ADDIS; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ADC1-&gt;CR &amp; ADC_CR_ADEN) {} } <span class="hljs-comment"><span class="hljs-comment">/* calibrate ADC */</span></span> ADC1-&gt;CR |= ADC_CR_ADCAL; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ADC1-&gt;CR &amp; ADC_CR_ADCAL) {} <span class="hljs-comment"><span class="hljs-comment">/* reset configuration */</span></span> ADC1-&gt;CFGR2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* enable device */</span></span> ADC1-&gt;CR = ADC_CR_ADEN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!(ADC1-&gt;ISR &amp; ADC_ISR_ADRDY));</code> </pre><br>  Infelizmente, não ajudou e decidiu realizar o experimento a seguir ... Eu já verifiquei os coeficientes e eles estão 100% corretos, então aplicarei a tensão da fonte de alimentação do laboratório na entrada, altere-a e exibirei os resultados brutos da medição ADC em um indicador de sete segmentos e compararei com o que deve estar lá com o que você realmente mediu.  Como resultado, recebi os seguintes resultados: <br><br><img src="https://habrastorage.org/webt/ib/it/nr/ibitnrlbtgj1s7n1dafdlqv5wwc.png"><br><br>  Como você pode ver, o gráfico teórico possui excelente linearidade, porque  não está ligado ao ferro.  O gráfico baseado em dados reais também é quase linear com desvios mínimos.  De fato, o gráfico com dados reais pode ser combinado com o gráfico teórico por transferência paralela para uma determinada constante.  Falando na linguagem da eletrônica, <b>o ADC tem um deslocamento!</b> <br><br>  De acordo com os dados em que os gráficos foram construídos, descobri que o ADC tem um deslocamento em diferentes pontos de 71 a 73 etapas.  Esse era o problema, mas pensei em “não linearidade” porque o deslocamento de 71 passos em 10V é de cerca de 14% e em 30V já é de 4%.  Ou seja, se você construir um gráfico de desvios em%, a dependência terá uma forma exponencial, mas esse gráfico não é interessante. <br><br>  Decidiu-se que, para esclarecer os resultados, tente introduzir outra variável na fórmula, que alterará meus valores e terá a seguinte forma: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offsetVoltage = <span class="hljs-number"><span class="hljs-number">72</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> voltageReference = <span class="hljs-number"><span class="hljs-number">0.0008</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> voltageDivider = <span class="hljs-number"><span class="hljs-number">22.2765</span></span>; adcVoltageResult = ((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(adcData+offsetVoltage))*voltageReference*voltageDivider;</code> </pre><br>  Após essas simples manipulações, meu dispositivo começou a medir com precisão a tensão e os dados pararam de flutuar.  Até aquele momento, <i>ficava</i> em <i>72 * 0,0008V * 22,2768 = 1,28V</i> , o que é muito crítico no caso de controle de uma bateria.  A bateria de chumbo certamente não explode como o íon de lítio, mas ainda bate rapidamente, especialmente se for descarregada constantemente, não para 10,2V, mas para 8,92V. <br><br>  Aqui está uma história tão pequena sobre um pequeno pedaço de ferro.  Espero que alguém ache este material útil ou pelo menos interessante de ler.  Tenha cuidado com todos esses ADCs e outras coisas desagradáveis ​​:)) <br><br>  <b>UPD</b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">olartamonov</a> pede zelosamente para não enganar as pessoas e usar o código de calibração do manual de referência - fez a alteração com prazer.  Infelizmente, no meu caso, isso não mudou a situação e a mudança não foi a lugar nenhum.  Provavelmente o problema está no próprio chip.  <s>conforme orientação do Departamento de Estado jogou produtos falsificados</s> <br><br><h2>  Concorrência </h2><br>  Está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ocorrendo</a> uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">competição entre projetos técnicos entre os</a> camaradas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PCBway</a> , qualquer um pode participar.  As regras são simples.  Placas de circuito impresso para o seu projeto serão gratuitas.  E o mais importante, prêmios!  Estes são alguns documentos em verde com senhores americanos em seu paypal + moeda virtual para os quais você pode solicitar placas de circuito impresso + honra e respeito + a oportunidade de obter uma oferta de emprego em algum lugar fora da CEI :)) Eu recomendo especialmente que os alunos participem, o nível técnico não é muito alto lá , embora, a partir da experiência de concursos anteriores, haja projetos muito fortes, portanto, uma caixa de bricolage “forte” possa facilmente chegar aos vencedores! <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sp/jl/pd/spjlpdnbj4-ymwvgchsdtzzmlk4.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448202/">https://habr.com/ru/post/pt448202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448190/index.html">Editor de lógica visual para Unity3d. Parte 1</a></li>
<li><a href="../pt448192/index.html">Por que precisamos na produção de AR e VR</a></li>
<li><a href="../pt448194/index.html">Experiência de candidato no recrutamento de desenvolvedores de software. Parte 2</a></li>
<li><a href="../pt448196/index.html">O futuro (ou presente secreto) dos motores a plasma ou como atingir 27 giros máximos na atmosfera</a></li>
<li><a href="../pt448198/index.html">Transferência segura de dados entre dois aplicativos</a></li>
<li><a href="../pt448204/index.html">Ilhas Boêmias</a></li>
<li><a href="../pt448206/index.html">Desenvolvimento modular ou caminho até lá, não de volta</a></li>
<li><a href="../pt448208/index.html">20, 100, 3, 19 - InoThings em números</a></li>
<li><a href="../pt448210/index.html">Canhão para satélites, um blaster e uma nave solar: projetos curiosos e paradoxais</a></li>
<li><a href="../pt448212/index.html">Protocolo chinês AIBUS e reator químico de laboratório</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>