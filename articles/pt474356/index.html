<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏼 👼🏼 👨🏾‍✈️ ThingJS v1.0-alpha 📥 👩‍👩‍👦 🔊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos últimos dois anos, desenvolvi minha própria plataforma IoT e hoje estou pronto para mostrar sua versão alfa. 


 Juntamente com um parceiro, criam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ThingJS v1.0-alpha</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474356/"><p><img src="https://habrastorage.org/webt/hd/vu/kq/hdvukqu1cfju8ygby3otuzmptmu.png"></p><br><p> Nos últimos dois anos, desenvolvi minha própria plataforma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IoT</a> e hoje estou pronto para mostrar sua versão alfa. </p><br><p>  Juntamente com um parceiro, criamos e suportamos dispositivos de IoT.  Desmontamos mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de um ancinho</a> no processo dessa atividade.  O ThingJS nasceu não tanto do desejo como da necessidade de facilitar a vida para nós, mas ao mesmo tempo, espero, para você. </p><br><p>  O artigo será interessante para as pessoas que estão próximas ao tópico da IoT e que já fizeram algo nesta área.  Um ponto importante será que a plataforma deve interessar (de repente) desenvolvedores de JavaScript, como  esse idioma é escolhido como base da plataforma.  Obviamente, os desenvolvedores de C / C ++ também terão algo para ler. </p><br><p>  Primeiro, falarei sobre os principais problemas que encontramos ao desenvolver dispositivos de IoT, depois descreverei como a plataforma lida com eles e, no final, a coisa mais chata: o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vídeo</a> , a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte técnica</a> e você pode tocar tudo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ao vivo</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Sumário</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Problemas de IoT</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Problema com mão curta</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O problema da torre de Babel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Problema da Síndrome de Estocolmo</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Soluções para problemas</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comunidade, Vício, Moda, Juventude.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais promessas e abstrações.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dispositivos IoT virtuais</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Informações técnicas</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrutura de Aplicação ThingJS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pilha de tecnologia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recursos do ambiente de desenvolvimento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dispositivos suportados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comparação com concorrentes</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Início rápido</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eu só tenho que assistir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eu quero tentar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blink app</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Montagem da fonte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Composição da Aplicação</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manifest.json</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloco de componentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloco de scripts</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O bloco "requer"</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blink.js</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Blink.vue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">scripts / blink.js</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementação de interface</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ambiente de desenvolvimento</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de aplicações</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desenvolvimento de Firmware</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que vem a seguir?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Referências</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Perguntas frequentes</a> </li></ul></div></div><br><h1 id="problemy-iot--anchorproblemsanchor">  Problemas de IoT: <a name="problems"></a></h1><br><h2 id="--problema-korotkih-ruk-anchorshort-handsanchor">  - O problema das armas curtas <a name="short-hands"></a></h2><br><p>  A IoT é baseada em um ecossistema.  O desenvolvimento de seu conceito e arquitetura técnica é realmente muito trabalhoso.  Além disso, você ainda precisa desenvolver um monte de firmware para dispositivos heterogêneos.  Inventar e implementar o transporte para a troca de dados entre dispositivos em vários princípios físicos e lógicos.  Expanda os recursos da nuvem.  Elabore interfaces de usuário.  Etc.  etc. </p><br><p>  Mesmo que um especialista individual tenha as habilidades necessárias para fazer isso, ele simplesmente não tem tempo (mãos) suficiente para implementar essa idéia.  Enquanto ele vai cortar, ela se tornará obsoleta. </p><br><h2 id="--problema-vavilonskoy-bashni-anchortoweranchor">  - O problema da torre de Babel <a name="tower"></a></h2><br><p>  O desenvolvimento de um ecossistema de IoT completo exige uma pilha tecnológica muito ampla.  Ser uma pilha cheia na IoT é simples ... difícil.  Precisa de experiência em todos os lugares.  Nem todos podem se orgulhar de uma ampla gama de conhecimentos e até experiência.  E aqui a questão não está nas habilidades mentais.  Esta é uma conclusão óbvia do problema da mão curta. </p><br><p>  Criar um ecossistema verdadeiramente rico requer o trabalho de muitos especialistas bastante restritos, mas com profundo conhecimento em seu campo.  Esses especialistas falam idiomas diferentes, usam padrões diferentes e geralmente entendem termos elementares de maneiras diferentes.  E, como a IoT é baseada em dispositivos com recursos limitados, as comunicações efetivas são críticas para a realização do que se pretende. </p><br><h2 id="--problema-stokgolmskogo-sindroma-anchorsindromanchor">  - O problema da síndrome de Estocolmo <a name="sindrom"></a></h2><br><p>  Hoje existem fornecedores que desenvolvem seus ecossistemas.  São Google, Microsoft, Yandex, Megafone, MTS, etc.  Alguns deles permitem que você integre suas próprias coisas nos ecossistemas deles nos termos deles.  Isso abrange amplamente os problemas descritos acima.  Mas cria um novo - vício.  E os fornecedores gostam de alterar as condições de integração.  E mais ainda, não há questão de auto-realização neste paradigma. </p><br><h1 id="resheniya-problem-anchorsolutionsanchor">  Soluções para problemas: <a name="solutions"></a></h1><br><h2 id="--soobschestvo-zavisimosti-modno-molodezhno-anchorcommunityanchor">  - Comunidade, vício, moda, juventude <a name="community"></a></h2><br><p>  Os problemas descritos acima, de fato, bloqueiam o acesso ao desenvolvimento da IoT para indivíduos.  O desenvolvimento da plataforma foi lançado com a conscientização desses problemas.  A fundação foi lançada para o desenvolvimento da plataforma através da comunidade. </p><br><p>  Para implementar essa idéia, a plataforma, é claro, vem com uma base de código aberta e também possui um paradigma de dependência em todas as camadas. </p><br><p>  Se você não sabe o que são vícios, é hora de conhecê-los.  Mas se você tentar explicar de maneira muito simples, o módulo que você está desenvolvendo pode depender de outro que seu amigo escreve.  E você acessará seu módulo através de uma interface predefinida. </p><br><p>  Assim, ao mesmo tempo, de forma independente, muitas pessoas podem desenvolver seus próprios componentes de plataforma e reutilizar os existentes, desenvolvidos por alguém.  Isso resolve fundamentalmente o problema das mãos curtas. </p><br><p><img src="https://habrastorage.org/webt/zt/xk/ok/ztxkokx7yqcgzwymgrq3o-ueah4.png"></p><br><p>  Além disso, o problema da "Torre de Babel" está sendo resolvido.  As dependências são criadas para que os vários níveis da plataforma, desenvolvidos em diferentes idiomas, tenham um mecanismo predeterminado para criar dependências entre si. </p><br><p>  Por exemplo, um desenvolvedor C pode tirar proveito de um componente front-end pronto, fornecendo a interface necessária.  Ou, pelo contrário, o desenvolvedor front-end pode usar um componente pronto escrito em C. Isso é  todos farão o que ele conhece melhor. </p><br><h2 id="--bolshe-obeschaniy-i-abstrakciy-anchorpromisesanchor">  - Mais promessas e abstrações <a name="promises"></a></h2><br><p>  O protocolo de comunicação entre dispositivos é indefinido.  Em vez disso, há uma abstração - um barramento de dados.  O dispositivo pode enviar um evento para o ônibus ou ouvi-lo.  Não está claro quem escreve no ônibus e quem recebe antecipadamente.  E quando também.  A troca e entrega de dados assíncronas não são garantidas.  Em geral - inferno.  Sem pânico.  Tão concebido. </p><br><p>  O fato é que o ecossistema é um grupo de dispositivos separados e auto-suficientes.  A qualquer momento, alguns dispositivos podem não estar disponíveis.  Por várias razões.  Parar a atividade de outros dispositivos se uma peça não estiver disponível não é o melhor cenário.  É necessário legalizar aquilo que não pode ser evitado. </p><br><p>  A plataforma implementa o paradigma de promessas para fornecer eventos.  O primeiro dispositivo concorda com a promessa do segundo de fornecer informações.  Mas não há garantias.  O assinante deve decidir o que fazer em caso de fornecimento prematuro de dados para ele. </p><br><p>  O problema da comunicação síncrona é resolvido através da transmissão de eventos através do barramento com links para canais síncronos.  O protocolo de canal síncrono é determinado pelo próprio tipo de evento.  Por exemplo, você pode enviar um evento com o tipo "do-render-video-stream" e como enviar câmeras IP WEB como carga útil.  Assim, o destinatário saberá que você precisa reproduzir o fluxo de vídeo a partir do endereço especificado. </p><br><p><img src="https://habrastorage.org/webt/3s/th/vn/3sthvnlojthoq_gh9uqirnbqedg.png"></p><br><p>  Mas como o ônibus funciona fisicamente?  A implementação do ônibus fica com a comunidade.  O pneu se expande com o transporte que seu projeto exige.  Por exemplo, um evento é recebido por http e retransmitido por UART.  Para todos os elementos do ecossistema, exteriormente nada mudará. </p><br><h1 id="--virtualnye-iot-ustroystva-anchorvirtualanchor">  - dispositivos IoT virtuais <a name="virtual"></a></h1><br><p>  Para o ThingJS, algo não é apenas físico, mas também um aplicativo especial - virtual.  Além disso, uma coisa física pode conter várias coisas virtuais (aplicativos) que usam os recursos de uma coisa física. </p><br><p>  Essa abordagem permite que você unifique a interação entre o back-end condicional (controlador / servidor / nuvem, etc.) e o front-end (navegador, aplicativo etc.), bem como b2b e até f2f.  Construa uma matriz, não uma hierarquia de interações. </p><br><p><img src="https://habrastorage.org/webt/-l/vg/bd/-lvgbdkme-d81bzhaqpqjwhcnly.png"></p><br><p>  Um exemplo simples seria uma câmera WEB, que por si só tem uma coisa virtual - uma interface de usuário.  Quando o usuário acessa o endereço <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://192.168.4.1</a> , a página WEB é aberta, onde a coisa virtual começa a "viver".  A câmera (coisa física) e a página (coisa virtual) tornam-se automaticamente um ecossistema em que um barramento de dados unificado está disponível.  Por meio dele, a coisa virtual se comunica com o físico.  Nesse caso: a coisa física informa à virtual através do barramento o endereço do fluxo de vídeo, seu estado, etc., e a virtual mostra ao usuário o vídeo e dá os comandos necessários à coisa física. </p><br><p>  A continuação lógica é a capacidade de hospedar coisas virtuais nas nuvens e incluí-las em um ecossistema comum.  E isso, por sua vez, permite criar dispositivos virtuais com enormes recursos que resolvem problemas, por exemplo, disponíveis para IA. </p><br><p>  Você mesmo pode criar esses dispositivos ou usar os já criados.  A síndrome de Estocolmo é derrotada.  Você mesmo determina do que seu projeto depende e como o desenvolverá. </p><br><h1 id="tehnicheskaya-informaciya-anchortech-infoanchor">  Informações técnicas <a name="tech-info"></a></h1><br><h2 id="struktura-prilozheniya-thingjs-anchorapp-structanchor">  Estrutura de Aplicação ThingJS <a name="app-struct"></a></h2><br><p><img src="https://habrastorage.org/webt/sz/-w/ul/sz-wuldlbfp7z2kcc1vgrqov_ta.png"></p><br><h2 id="stek-tehnologiy-anchortech-stackanchor">  Pilha de tecnologia <a name="tech-stack"></a></h2><br><p>  A plataforma de hardware selecionada é o controlador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ESP32</a> .  A plataforma foi projetada como independente de hardware.  Infelizmente, não houve tempo para particionar em outros dispositivos. </p><br><p>  Para o desenvolvimento do firmware, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">são utilizadas as ferramentas</a> recomendadas da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Espressif</a> .  O firmware é desenvolvido em C. O coletor cmake.  O projeto utiliza o conceito de componente, também promovido pela Espressif. </p><br><p>  Além do esp-idf, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mongoose WEB Server é usado</a> , assim como um interpretador JavaScript modificado do Mongoose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mJS</a> . </p><br><p>  Para o desenvolvimento de aplicativos, o JavaScript é usado com a estrutura do VUE 2. Crie aplicativos usando o webpack.  O gerenciador de pacotes é npm.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CLI do VUE foi</a> usada como base para o ambiente de desenvolvimento. </p><br><p>  A fim de padronizar a visualização de aplicativos e facilitar as dores da criatividade da interface do usuário, o pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vuetifyjs</a> está incluído na plataforma. </p><br><h2 id="vozmozhnosti-sredy-razrabotki-anchordev-skilsanchor">  Recursos do ambiente de desenvolvimento <a name="dev-skils"></a></h2><br><p>  Para desenvolvedores de JavaScript (coisas virtuais): </p><br><ul><li>  IDE recomendado - WEBStorm; </li><li>  Todos os lucros que o VUE CLI e o IDE oferecem; </li><li>  Depuração intra-sistema de aplicativos (depurador mJS no controlador); </li><li>  O MJS implementa o comando debugger, que permite chamar o depurador em um local arbitrário; </li><li>  Upload quente de arquivos atualizados para o controlador durante o desenvolvimento (os desenvolvedores JavaScript já não podem viver sem esse recurso); </li><li>  O desenvolvimento do tempo de execução é emparelhado com um controlador real.  Você programa e, ali mesmo, vê o resultado no hardware; </li><li>  ESLint configurado para entender os objetos da plataforma. </li></ul><br><p>  Para desenvolvedores C (coisas físicas): </p><br><ul><li>  IDE recomendado - CLion; </li><li>  Todos os lucros esp-idf e IDE; </li><li>  A plataforma é dividida em componentes como parte do conceito esp-idf; </li><li>  Fácil integração com a plataforma de componentes nativos. </li></ul><br><h2 id="podderzhivaemye-ustroystva-anchorhw-supportedanchor">  Dispositivos suportados <a name="hw-supported"></a></h2><br><p>  No momento, apenas o ESP32 é suportado.  O chip é popular devido à sua disponibilidade com características técnicas surpreendentes.  Com base nisso, muitos dispositivos IoT prontos foram criados que podem ser usados ​​no ThingJS. </p><br><h2 id="sravnenie-s-konkurentami-anchorvs-otheranchor">  Comparação com concorrentes <a name="vs-other"></a></h2><br><p>  Sugiro não correr tão longe.  Não me atrevo a chamar concorrentes de plataformas comerciais.  E o código aberto aparece e desaparece sem deixar vestígios visíveis.  Portanto, não fiz uma comparação.  No entanto, se alguém quiser, estou pronto para postar o resultado de seu trabalho aqui. </p><br><h1 id="bystryy-start-anchorget-startedanchor">  Início rápido <a name="get-started"></a></h1><br><h2 id="mne-tolko-posmotret-anchorvideoanchor">  Eu só tenho que assistir <a name="video"></a></h2><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dhPIAL2N0MQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="hochu-poprobovat-anchortouch-itanchor">  Eu quero tentar <a name="touch-it"></a></h2><br><p>  Para experimentar a plataforma em hardware real, você precisará de qualquer dispositivo baseado no ESP32 com flash de 4mb e capacidade de flash via USB.  Mas a placa principal ESP32 v2 é mais adequada. </p><br><p><img src="https://habrastorage.org/webt/ik/qw/jy/ikqwjyhkejf5t5kwdmbn20lq1ko.png"></p><br><p>  Você pode comprar essas coisas sem problemas no Aliexpress ou no Ebay.  Além disso, existem até escritórios de representação na Rússia.  Eu pessoalmente compro em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">São Petersburgo</a> . </p><br><p>  Para testar a operação do aplicativo de teste “Blink”, você precisa conectar um LED.  Algumas versões das placas têm um LED pré-instalado conectado ao GPIO2.  Se você tem uma placa assim, não pode fazer nada.  O piscar deve funcionar sem movimentos desnecessários.  Se você tiver apenas um diodo (fonte de alimentação), precisará conectar o diodo indicador sozinho.  Isso não é nada complicado. </p><br><p>  Você precisará de qualquer LED indicador e resistência de 1 a 5K. </p><br><p><img src="https://habrastorage.org/webt/ey/vg/e7/eyvge7dfugct2jtk2u2rq8wkpqs.png"></p><br><p>  A única coisa que resta é implantar o pacote do usuário no dispositivo.  Você pode pegar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  As instruções de implantação estão localizadas lá. </p><br><h2 id="blink-prilozhenie-anchorblinkanchor">  Blink app <a name="blink"></a></h2><br><h3 id="sborka-iz-ishodnikov-anchorblink-bouldanchor">  Montagem da fonte <a name="blink-bould"></a></h3><br><p>  O Blink é um ecossistema simples que consiste em um dispositivo virtual que implementa a interface do usuário e um físico.  Um dispositivo virtual inicia a partir de um dispositivo físico ao acessá-lo através de um navegador. </p><br><p>  O script é simples.  Ao instalar o aplicativo em um dispositivo físico, o LED (anteriormente conectado a ele) começa a piscar na frequência de 1 Hz.  O usuário pode ativar ou desativar o diodo piscante na interface.  Você pode assistir ao vídeo na seção "Só posso assistir". </p><br><p>  As fontes estão no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório</a> src / applications / blink.  Para coletar o piscar de olhos e brincar com ele, você só precisa deste repositório.  Verifique se você já possui git, npm e nodejs instalados. </p><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install npm run build</code> </pre> <br><p>  Se tudo correu bem, você terá algo como o seguinte: </p><br><p><img src="https://habrastorage.org/webt/7b/a-/n8/7ba-n8_6y8hng41irp6jttozxks.png"></p><br><p>  Parabéns!  Você criou seu primeiro aplicativo ThingJS.  Você pode encontrá-lo na pasta dist / apps / blink e tentar instalá-lo imediatamente no dispositivo, guiado pelo vídeo na seção <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Só posso assistir"</a> . </p><br><h3 id="sostav-prilozheniya-anchorblink-containsanchor">  Composição da Aplicação <a name="blink-contains"></a></h3><br><div class="scrollable-table"><table><tbody><tr><th>  Ficheiro </th><th>  Descrição do produto </th></tr><tr><td>  scripts / blink.js </td><td>  O script que está instalado no controlador </td></tr><tr><td>  blink.js </td><td>  Ponto de montagem do componente do aplicativo </td></tr><tr><td>  Blink.vue </td><td>  Componente VUE que implementa a interface do usuário </td></tr><tr><td>  favicon.svg </td><td>  Ícone do aplicativo </td></tr><tr><td>  langs.js </td><td>  Pacote de idiomas do aplicativo </td></tr><tr><td>  manifest.json </td><td>  Manifesto de aplicativo </td></tr></tbody></table></div><br><p>  Você pode se familiarizar com todos os detalhes do aplicativo.  Vou me concentrar em vários arquivos. </p><br><h3 id="manifestjson-anchorblink-manifestanchor">  manifest.json <a name="blink-manifest"></a></h3><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span> : <span class="hljs-string"><span class="hljs-string">"rpiontik"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subversion"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"patch"</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blink Example"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"components"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: {...}, <span class="hljs-attr"><span class="hljs-attr">"requires"</span></span> : {...} }</code> </pre> <br><p>  Como o nome do arquivo indica, este é o manifesto do aplicativo.  Possui metadados gerais sobre os quais é fácil adivinhar.  Além deles, existem três blocos importantes.  Vamos olhar para eles de perto: </p><br><h4 id="blok-components-anchorblink-manifest-componentsanchor">  Bloco de componentes <a name="blink-manifest-components"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"components"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink-app"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"intent_filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"action"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.action.MAIN"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"category"</span></span>: <span class="hljs-string"><span class="hljs-string">"thingjs.intent.category.LAUNCH"</span></span> } ] } }</code> </pre> <br><p>  O bloco descreve toda a base de componentes do aplicativo.  O campo "origem" aponta para o ponto de montagem do componente (consulte blink.js) e é o ponto de entrada do assembly para o webpack ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entrada</a> ).  Assim, cada componente será emitido em um pacote separado.  Este pacote será <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregado</a> conforme necessário ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">carregamento lento</a> ). </p><br><p>  Uma estrutura importante é <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intent_filter</a> .  Se você programar para Android, encontrará algo familiar para você.  E não cometa um erro.  O sistema gera eventos de interface e serviço aos quais o componente assina.  Se ocorrer um evento que atenda às condições de filtragem, o componente será carregado e o controle será transferido para o ponto de montagem. </p><br><p>  Nesse caso, o componente "blink-app" é inscrito no evento de inicialização do componente de interface principal do aplicativo.  Quando o iniciador inicia o aplicativo, este componente será introduzido. </p><br><p>  Se você modificar o manifesto alterando a linha </p><br><p> <code>thingjs.intent.category.LAUNCH &gt;&gt; thingjs.intent.category.PREFERENCE</code> </p> <br><p>  , depois da montagem e instalação, verifica-se que o aplicativo parou de abrir na área de trabalho.  Mas um novo "bloco" apareceu na seção "Configurações".  Ao mesmo tempo, nada mudou funcionalmente. </p><br><p>  Assim, indicamos ao iniciador que esse componente é um elemento de interface para personalizar nosso aplicativo.  E esse componente começou a aparecer nas configurações. </p><br><h4 id="blok-scripts-anchorblink-manifest-scriptsanchor">  Bloco de scripts <a name="blink-manifest-scripts"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"entry"</span></span>: <span class="hljs-string"><span class="hljs-string">"blink"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"subscriptions"</span></span> : [<span class="hljs-string"><span class="hljs-string">"$-script-restart"</span></span>, <span class="hljs-string"><span class="hljs-string">"blink"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"modules"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"hot_reload"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"scripts/blink.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"optimize"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } }</code> </pre> <br><p>  Esse bloco é semelhante em função ao bloco "components", mas descreve a base de componentes do aplicativo no lado do controlador. </p><br><p>  Indica claramente o ponto de entrada.  No campo "entrada".  Separadamente, prestarei atenção que, ao instalar o aplicativo, o script não inicia imediatamente.  É iniciado apenas quando ocorre um dos eventos nos quais o script está registrado. </p><br><p>  O campo "assinaturas" é responsável por assinaturas.  Agora indica dois eventos: </p><br><ul><li>  <strong>$ -script-restart</strong> - ocorre quando o sistema é iniciado ou reiniciado; </li><li>  <strong>blink</strong> é um evento personalizado relevante para o ecossistema do blink. </li></ul><br><p>  No bloco "modules", segue uma descrição da composição dos scripts.  Vou observar dois campos: </p><br><ul><li>  <strong>hot_reload</strong> - se esse campo estiver definido como true, quando um arquivo for alterado no modo de desenvolvimento, ele será automaticamente baixado no controlador (hot reload); </li><li>  <strong>otimizar</strong> - se verdadeiro, ao criar o projeto, o script será otimizado e agregado. </li></ul><br><h4 id="blok-requires-anchorblink-manifest-requiresanchor">  O bloco "requer" <a name="blink-manifest-requires"></a></h4><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"requires"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"interfaces"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"blink"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"en"</span></span> : <span class="hljs-string"><span class="hljs-string">"LED indicator"</span></span> } } } }</code> </pre> <br><p>  Você provavelmente já percebeu que, ao instalar o aplicativo, precisa selecionar o pino no qual o LED piscará.  No entanto, por padrão, ele já está selecionado como GPIO2.  Este bloco é responsável por essas configurações. </p><br><p>  Neste bloco, as dependências são indicadas.  Nesse caso, para que o aplicativo funcione, ele precisa fornecer uma interface com o tipo "bit_port".  Essa interface é um requisito obrigatório (obrigatório = verdadeiro) e, por padrão, GPIO2 é especificado (padrão = 2).  Ele será projetado no script com o nome "piscar". </p><br><p>  Ao instalar o aplicativo, o perfil do equipamento no qual os scripts serão implantados é levado em consideração.  Esse perfil lista as interfaces disponíveis e os recursos de hardware disponíveis para eles (em particular, pinos e suas combinações).  Verifica a compatibilidade de requisitos e equipamentos.  Se o equipamento puder atender aos requisitos do aplicativo, será mostrado ao usuário um esquema de alocação de recursos, onde os recursos primários são alocados automaticamente, levando em consideração as recomendações do manifesto.  I.e.  desse mesmo campo "padrão". </p><br><p>  Assim, vários aplicativos podem ser instalados em um dispositivo, que podem compartilhar recursos de hardware entre si. </p><br><h3 id="blinkjs-anchorblink-blink-jsanchor">  blink.js <a name="blink-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Blink.vue'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Langs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./langs'</span></span>; $includeLang(Langs); $exportComponent(<span class="hljs-string"><span class="hljs-string">'blink-app'</span></span>, App);</code> </pre> <br><p>  O arquivo é o ponto de montagem do componente anunciado no manifesto (consulte manifest.js / components). Ele grava o VUE do componente 'blink-app' por meio do método de abstração $ exportComponent e também registra o pacote de idiomas. </p><br><p>  Você pode perguntar - por que essas dificuldades?  Por que não registrar imediatamente o componente VUE especificado na fonte?  O fato é que o manifesto descreve componentes públicos.  Esses componentes podem ser solicitados por aplicativos de terceiros (dependências de tempo de execução).  O ponto de montagem, por sua vez, pode registrar componentes relacionados (para uso interno), bem como serviços.  Ou seja, prepare o ambiente do componente. </p><br><h3 id="blinkvue-anchorblink-blink-vueanchor">  Blink.vue <a name="blink-blink-vue"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Blink'</span></span>, <span class="hljs-attr"><span class="hljs-attr">watch</span></span>: { blink_state (state) { <span class="hljs-comment"><span class="hljs-comment">// Send event to script this.$bus.$emit($consts.EVENTS.UBUS_MESSAGE, 'blink', state); } }, data () { return { blink_state: true }; } };</span></span></code> </pre> <br><p>  O código fala por si.  Quando a propriedade “blink_state” é alterada, uma mensagem é enviada ao barramento ($ bus) com o valor atual.  Isso é tudo o que você precisa fazer para que o script no lado do controlador receba o comando desejado. </p><br><h3 id="scriptsblinkjs-anchorblink-script-blink-jsanchor">  scripts / blink.js <a name="blink-script-blink-js"></a></h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> active = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Set port direction $res.blink.direction($res.blink.DIR_MODE_DEF_OUTPUT); // Run background process setInterval(function () { if (active) { // $res - is container with required resources $res.blink.set(state); // Do invert state = !state; } }, 1000); // Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  Em geral, o código é muito semelhante ao uso clássico de um timer em JavaScript.  Exceto que não está neste dialeto do JavaScript.  É implementado na plataforma.  Conheça este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mJS</a> .  Você pode aprender mais sobre isso na página oficial do projeto. </p><br><p>  Para as necessidades da plataforma, o dialeto é finalizado.  Os temporizadores foram introduzidos, assim como um comando útil como "depurador".  Bem, o próprio depurador.  Mais sobre isso separadamente na seção <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Ambiente de desenvolvimento"</a> . </p><br><p>  Preste atenção aos objetos globais da plataforma.  Eles são nomeados com o caractere "$". </p><br><ul><li>  <strong>$ res</strong> - contém recursos alocados ao script; </li><li>  <strong>$ bus</strong> - interface de <strong>barramento</strong> . </li></ul><br><p>  Porque  o aplicativo solicitou uma interface com o tipo “bit_port” (consulte profile.json / require) e o nome “blink”, foi atribuído a ele como $ res.blink.  A interface implementa apenas três funções: </p><br><ul><li>  <strong>set (value)</strong> - define o nível GPIO </li><li>  <strong>get ()</strong> - obtém o nível atual do GPIO </li><li>  <strong>direction (value)</strong> - define o modo GPIO </li></ul><br><p>  Para a função de direção, as constantes disponíveis são descritas na mesma interface $ res.blink.: DIR_MODE_DISABLE;  DIR_MODE_DEF_INPUT;  DIR_MODE_DEF_OUTPUT;  DIR_MODE_INPUT_OUTPUT_OD;  DIR_MODE_INPUT_OUTPUT. </p><br><p>  A inscrição em eventos de barramento é feita através do método $ bus.on.  Nesse caso, todos os eventos nos quais o script está inscrito chegarão ao manipulador.  O manipulador aceita três parâmetros: </p><br><ul><li>  <strong>evento</strong> - identificador de <strong>evento</strong> .  Nesse caso, apenas dois são possíveis: "$ -script-restart" e "piscar".  Dos quais apenas um é processado - pisque.  É necessário assinar o segundo para que o script seja iniciado imediatamente na inicialização do sistema. </li><li>  <strong>conteúdo</strong> - os dados podem vir com o evento.  Seu tamanho é limitado a 126 bytes, levando em consideração o tamanho do identificador de evento. </li><li>  <strong>data</strong> - dados transmitidos ao se inscrever no evento como um segundo parâmetro.  E neste caso, eles são nulos. </li></ul><br><p>  As interfaces são extensíveis.  Abaixo, você encontrará uma descrição de como criar sua própria interface. </p><br><h2 id="realizaciya-interfeysa-anchorintefacesanchor">  Implementação de interface <a name="intefaces"></a></h2><br><p>  O ThingJS permite expandir os recursos de hardware e serviço disponíveis por meio de interfaces especiais.  Você pode criar independentemente uma interface que implementará qualquer complexidade, precisão, carga, etc.  funcional. </p><br><p>  Por exemplo, você pode implementar uma interface de integração com seu serviço de nuvem.  Ou um processo assíncrono em segundo plano com o qual o script poderá trocar mensagens.  Bem, ou implemente o suporte de exibição.  Será igualmente fácil de fazer e usar.  Você e os outros.  Verdade, para isso você precisa conhecer C. </p><br><p>  Considere a implementação da interface bit_port, usada no exemplo Blink.  Para iniciar, você precisa implantar o projeto de liberação alfa do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelo ThingJS</a> .  A documentação de implantação está no próprio projeto. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-template</code> </pre> <br><p>  O projeto inclui componentes: </p><br><ul><li>  <strong>ThingJS-boards</strong> - contém configurações de dispositivos.  Até agora, apenas o ESP32_CORE_BOARD V2 e compatível; </li><li>  <strong>ThingJS-extern</strong> - bibliotecas de projetos de terceiros que o ThingJS usa; </li><li>  <strong>ThingJS-core</strong> - núcleo da plataforma; </li><li>  <strong>ThingJS-front</strong> - ambiente de desenvolvimento de aplicativos; </li><li>  <strong>ThingJS-stdi</strong> - interfaces padrão. </li></ul><br><p>  Estamos interessados ​​no projeto ThingJS-stdi.  Sua estrutura é a seguinte: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Ficheiro </th><th>  Descrição do produto </th></tr><tr><td>  implementação / tgsi_bit_port.c </td><td>  Implementação da interface Bit_port </td></tr><tr><td>  implementação / tgsi_bit_port.h </td><td>  Arquivo de cabeçalho da interface Bit_pro </td></tr><tr><td>  CMakeLists.txt </td><td>  script de construção do cmake </td></tr><tr><td>  README.md </td><td></td></tr><tr><td>  sdti_utils.h </td><td>  Ajudantes </td></tr><tr><td>  thingjs_stdi.c </td><td>  Ponto de montagem da interface </td></tr><tr><td>  thingjs_stdi.h </td><td>  Arquivo de cabeçalho do ponto de montagem </td></tr></tbody></table></div><br><p>  De fato, estamos interessados ​​apenas em um arquivo - deployment / tgsi_bit_port.c.  Ele contém tudo o que requer uma explicação separada. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thingjsBitPortRegister</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thingjs_bit_port_cases[] = DEF_CASES( DEF_CASE(GPIO0), DEF_CASE(GPIO2), DEF_CASE(GPIO3), DEF_CASE(GPIO4), DEF_CASE(GPIO5), DEF_CASE(GPIO12), DEF_CASE(GPIO13), DEF_CASE(GPIO14), DEF_CASE(GPIO15), DEF_CASE(GPIO16), DEF_CASE(GPIO17), DEF_CASE(GPIO18), DEF_CASE(GPIO19), DEF_CASE(GPIO21), DEF_CASE(GPIO22), DEF_CASE(GPIO23), DEF_CASE(GPIO25), DEF_CASE(GPIO26), DEF_CASE(GPIO27), DEF_CASE(GPIO32), DEF_CASE(GPIO33) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">st_thingjs_interface_manifest</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> = {</span></span> .type = <span class="hljs-string"><span class="hljs-string">"bit_port"</span></span>, .constructor = thingjsBitPortConstructor, .cases = thingjs_bit_port_cases }; thingjsRegisterInterface(&amp;interface); }</code> </pre> <br><p>  A função thingjsBitPortRegister registra um componente no núcleo do ThingJS.  Para fazer isso, ele chama a função thingjsRegisterInterface, para a qual passa uma estrutura com uma descrição da interface. </p><br><ul><li>  <strong>tipo</strong> - identificador de interface.  É ele quem é especificado como o tipo no arquivo manifest.json do aplicativo; </li><li>  <strong>constructor</strong> - link para o construtor de interface.  A função é chamada toda vez que você precisa criar uma nova instância da interface; </li><li>  <strong>cases</strong> é uma matriz que descreve possíveis recursos de hardware que a interface pode usar para seu trabalho.  Nesse caso, esses são GPIOs únicos.  Mas suas combinações ou dependências podem ser descritas separadamente. </li></ul><br><p>  O construtor de interface monta a interface na máquina mJS. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mjs_val_t</span></span> thingjsBitPortConstructor(struct mjs *mjs, cJSON *params) { <span class="hljs-comment"><span class="hljs-comment">//Validate preset params //The params must have pin number if (!cJSON_IsNumber(params)) return MJS_UNDEFINED; //Get pin number gpio_num_t gpio = params-&gt;valueint; //Create mjs object mjs_val_t interface = mjs_mk_object(mjs); /* Configure the IOMUX register for pad BLINK_GPIO (some pads are muxed to GPIO on reset already, but some default to other functions and need to be switched to GPIO. Consult the Technical Reference for a list of pads and their default functions.) */ gpio_pad_select_gpio(gpio); //Add protected property to interface mjs_set(mjs, interface, "gpio", ~0, mjs_mk_number(mjs, gpio)); //Set protected flag mjs_set_protected(mjs, interface, "gpio", ~0, true); //Bind functions mjs_set(mjs, interface, "set", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortSet)); mjs_set(mjs, interface, "get", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortGet)); mjs_set(mjs, interface, "direction", ~0, mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) thingjsBitPortDirection)); //Consts mjs_set(mjs, interface, "DIR_MODE_DISABLE", ~0, mjs_mk_number(mjs, GPIO_MODE_DISABLE)); mjs_set(mjs, interface, "DIR_MODE_DEF_INPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_INPUT)); mjs_set(mjs, interface, "DIR_MODE_DEF_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_DEF_OUTPUT)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT_OD", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT_OD)); mjs_set(mjs, interface, "DIR_MODE_INPUT_OUTPUT", ~0, mjs_mk_number(mjs, GPIO_MODE_INPUT_OUTPUT)); //Return mJS interface object return interface; }</span></span></code> </pre> <br><p>  Como os parâmetros são passados: </p><br><ul><li>  <strong>mjs</strong> - contexto de execução global; </li><li>  <strong>params</strong> - parâmetros de inicialização da interface.  Nesse caso, este é o número GPIO. </li></ul><br><p>  Um objeto "interface" mJS é criado, onde os métodos e propriedades da interface são montados: </p><br><ul><li>  <strong>gpio</strong> - propriedade somente leitura na qual o número de GPIO usado é armazenado; </li><li>  <strong>set</strong> - método para definir o nível do sinal; </li><li>  <strong>get</strong> - um método para obter o nível atual do sinal; </li><li>  <strong>direção</strong> - definindo o modo GPIO; </li></ul><br><p>  Além disso, são montadas constantes com as quais os scripts podem operar (DIR_MODE_DISABLE, DIR_MODE_DEF_INPUT, etc.). </p><br><p>  Depois de criar a interface, ela é montada sob um identificador específico (no exemplo Blink, é "blink") no objeto global $ res.  Um exemplo de uso pode ser encontrado na seção Blink ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">scripts / blink.js</a> ). </p><br><p>  Você pode formatar interfaces em componentes ou pacotes separados.  Isso permitirá que você monte o firmware como lego. </p><br><h1 id="sreda-razrabotki-anchordevanchor">  Ambiente de desenvolvimento <a name="dev"></a></h1><br><h2 id="razrabotka-prilozheniy-anchordev-appanchor">  Desenvolvimento de aplicações <a name="dev-app"></a></h2><br><p>  O ambiente de desenvolvimento de aplicativos é baseado na CLI VUE, que foi refinada para atender às necessidades da plataforma ThingJS.  Este é um garfo duro, incl.  vale a pena aguardar novos recursos do VUE CLI, se facilitarem bastante a vida. </p><br><p>  Para implantar o ambiente, é necessário clonar o projeto de liberação alfa do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ThingJS-front</a> .  Verifique se você já possui git, npm e nodejs instalados. </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> --branch alpha https://github.com/rpiontik/ThingJS-front <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ThingJS-front npm install</code> </pre> <br><p>  Ao desenvolver, recomendo usar o IDE WEBStorm. </p><br><p>  A composição e a estrutura do projeto são herdadas do VUE CLI.  Vou refletir diferenças significativas: </p><br><ol><li>  Scripts de construção reformulados na pasta de construção. </li><li>  Uma variável de ambiente “HW_DEVICE_URL” foi adicionada à configuração do ambiente dev (config / dev.env.js).  É necessário especificar um link para o dispositivo físico com o qual você trabalhará. </li><li>  A pasta do sistema src / applications apareceu.  Ele contém aplicativos que serão criados automaticamente.  Em particular, ele contém dois aplicativos: ante (iniciador) e pisca (aplicativo). </li><li>  Tudo acima da pasta src / applications é considerado módulos e recursos da plataforma.  Obviamente, você pode fazer alterações neles, mas nesse caso, eles aparecerão no controlador somente depois de piscá-lo.  T.ch.  A menos que você defina metas para si mesmo, é melhor não tocá-las. </li></ol><br><p>  Para teste, você pode iniciar imediatamente o servidor dev.  Embora você não possa desenvolver completamente sem o hardware físico, isso não interfere no desenvolvimento da interface.  E assim, o servidor dev inicia: </p><br><pre> <code class="bash hljs">npm run dev</code> </pre> <br><p>  O resultado deve ser algo como isto: </p><br><p><img src="https://habrastorage.org/webt/c2/ku/if/c2kuifxxfz1ppogv-_50rp7wtuo.png"></p><br><p>  Ao abrir o navegador e digitar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://0.0.0.0:8080</a> na barra de endereços, você verá a plataforma no modo de desenvolvimento: </p><br><p><img src="https://habrastorage.org/webt/no/cv/ax/nocvaxx5-kdjtvy0x7i5_jfvcbg.png"></p><br><p>  O processo de desenvolvimento de interface em si não é muito diferente do desenvolvimento front-end clássico no VUE.  Exceto que existem objetos de plataforma global dos quais você precisa estar ciente: </p><br><ul><li>  <strong>$ const</strong> - contém constantes da plataforma, bem como pacotes de idiomas; </li><li>  <strong>$ bus</strong> - barramento de dados; </li><li>  <strong>$ store</strong> - armazenamento global (VUEX). <br>  A partir dos exemplos, você pode entender como usá-los. </li></ul><br><p>  O multilinguismo é implementado da maneira mais simples - através do filtro "lang".  Especifique uma constante de idioma, que será interpretada em texto, dependendo do idioma da interface. </p><br><pre> <code class="xml hljs">v-bind:label="'BLINK_SATE' | lang"</code> </pre> <br><p>  Para avaliar completamente os recursos do ambiente de desenvolvimento, você precisará de um controlador preparado (costurado).  Você pode montar o firmware a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">partir do projeto</a> ou usar o firmware e o utilitário prontos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Depois de piscar o controlador e conectar-se à rede, você precisa garantir que o controlador esteja acessível via IP do seu computador.  Para fazer isso, digite <a href="">http: // [IP do</a> controlador] no navegador.  A interface WEB deve abrir. </p><br><p>  Agora você precisa especificar o endereço do controlador no arquivo config / dev.env.js </p><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> merge = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack-merge'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prodEnv = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./prod.env'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = merge(prodEnv, { <span class="hljs-attr"><span class="hljs-attr">NODE_ENV</span></span>: <span class="hljs-string"><span class="hljs-string">'"development"'</span></span>, <span class="hljs-attr"><span class="hljs-attr">HW_DEVICE_URL</span></span>: <span class="hljs-string"><span class="hljs-string">'"http://[IP ]"'</span></span> <span class="hljs-comment"><span class="hljs-comment">//HW_DEVICE_URL: '"http://192.168.8.105"', //HW_DEVICE_URL: '"http://192.168.4.1"', })</span></span></code> </pre> <br><p>  Se o servidor de desenvolvimento foi iniciado, pare-o e reinicie-o.  No futuro, depois de alterar os arquivos de construção, a configuração e o manifesto do aplicativo, sempre reinicie o servidor dev. </p><br><p>  Embora ao trabalhar em um ambiente de desenvolvimento, todos os aplicativos que estão na pasta src / application como instalados sejam exibidos, apenas aqueles realmente instalados no controlador funcionarão totalmente.  Este não é um recurso, mas um erro alfa.  No futuro, a sincronização do hardware e do ambiente de desenvolvimento ocorrerá automaticamente.  Mas, por enquanto, você precisa instalar manualmente o aplicativo no controlador para que o ambiente o conecte e sincronize com o que está em desenvolvimento. </p><br><p>  Montamos o aplicativo no modo prod: </p><br><pre> <code class="bash hljs">npm run prod</code> </pre> <br><p>  Instale os aplicativos coletados diretamente no controlador.  <u><strong>Não através do servidor de desenvolvimento</strong></u> . </p><br><p>  Agora você pode iniciar o desenvolvimento.  Quaisquer alterações feitas nos arquivos começarão automaticamente a reconstruir os aplicativos e a imagem na tela será alterada (recarga a quente).  A mesma regra se aplica aos scripts do controlador.  Por exemplo, você pode adicionar o comando debugger ao script do aplicativo piscar e ver o resultado. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Event listener // $bus - system bus interface $bus.on(function (event, content, data) { if (event === 'blink') { debugger; active = !!JSON.parse(content); } }, null);</span></span></code> </pre> <br><p>  Agora, quando o estado da caixa de seleção do aplicativo Blink mudar, o ambiente de desenvolvimento emitirá a seguinte mensagem: </p><br><p><img src="https://habrastorage.org/webt/bj/lw/qg/bjlwqgwrzgutdhi0vr2oed_cuee.png"></p><br><p>  Clicar no link "Iniciar depurador" o levará ao depurador.  A linha na qual a parada ocorreu é exibida. </p><br><p><img src="https://habrastorage.org/webt/m7/8u/3e/m78u3etl9hleirs072xjgpye_rw.png"></p><br><p>  O processo de depuração em si não é muito diferente de outros depuradores. </p><br><p><img src="https://habrastorage.org/webt/0m/i_/nt/0mi_nt0gx_-e-7nnvrrtdhxb9kg.png"></p><br><p>  O depurador é dividido em quatro seções.  No próprio código central.  Aplicativos instalados à esquerda no controlador.  Sua estrutura e composição.  Certo, inspetor.  O log é exibido abaixo.  No canto inferior esquerdo está o status atual da comunicação com o controlador. </p><br><p>  O ambiente de depuração está em processo de desenvolvimento intensivo.  Existem muitas outras ferramentas de monitoramento e depuração a serem construídas.  Peço desculpas antecipadamente por possíveis erros. </p><br><h2 id="razrabotka-proshivki-anchordev-firmwareanchor">  Desenvolvimento de Firmware <a name="dev-firmware"></a></h2><br><p>  O desenvolvimento do firmware é baseado no conceito proposto pela Espressif.  Não consigo superar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação nativa a</a> esse respeito. </p><br><p>  Um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório foi</a> preparado para um início rápido.  Ele contém informações de implantação.  Para um exemplo de uso, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Implementando uma interface"</a> . </p><br><p>  A montagem é muito simples e, literalmente, em 1-2 horas, você já estará montando o firmware sem problemas. </p><br><h1 id="chto-dalshe-anchorwhat-afteranchor">  O que vem a seguir? <a name="what-after"></a></h1><br><p>  Além disso, se a plataforma é de interesse da comunidade, está planejada: </p><br><ul><li>  Desenvolvimento de um ambiente de depuração; </li><li>  Padronização de nomeação de interfaces, eventos, componentes; </li><li>  Documentação detalhada na plataforma; </li><li>  Hospedagem em nuvem para coisas virtuais; </li><li>  Repositórios de tempo de execução </li><li>  Particionando em vários dispositivos acabados. </li></ul><br><p>  Além disso, estou procurando pessoas que gostariam de desenvolver a plataforma comigo.  Já é muito grande em escopo e ambição.  Eu assumo a cooperação igual, cujo objetivo será desenvolver a plataforma para um OpenSource de pleno direito. </p><br><p>        pull-     . </p><br><h1 id="ssylki-anchorrefsanchor">  Referências <a name="refs"></a></h1><br><p>   ThingJS: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Site</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> </li></ul><br><p>   ThingJS: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> </li></ul><br><p>  : </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ESP32</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esp-idf</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mongoose WEB Server</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mJS</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vue 2</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vuetifyjs</a> </li></ul><br><h1 id="faq-anchorfaqanchor"> FAQ <a name="faq"></a></h1><br><p>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474356/">https://habr.com/ru/post/pt474356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474342/index.html">Acelerando cenas em um vídeo usando uma exibição de tabela</a></li>
<li><a href="../pt474344/index.html">Internet das coisas na indústria: como funcionam as plantas inteligentes?</a></li>
<li><a href="../pt474346/index.html">Desenvolvimento do Docker no Windows Subsystem for Linux (WSL)</a></li>
<li><a href="../pt474352/index.html">Destruição de inimigos por um salto, como em "Mario" Unity 2D</a></li>
<li><a href="../pt474354/index.html">Casa inteligente em contêineres (ioBroker + Zigbee no Docker)</a></li>
<li><a href="../pt474358/index.html">Durma o suficiente no fim de semana: como o ruído branco ajuda os adultos a relaxar e monitora a qualidade do sono das crianças</a></li>
<li><a href="../pt474360/index.html">Melhore seu CSS com esses 5 princípios.</a></li>
<li><a href="../pt474364/index.html">Desenvolvimento de eletrônicos. Uma revisão subjetiva dos sensores integrados mais úteis</a></li>
<li><a href="../pt474366/index.html">Eventos digitais em Moscou, de 4 a 10 de novembro</a></li>
<li><a href="../pt474368/index.html">Sinopse sobre Machine Learning. Teoria da probabilidade. Fórmula de Bayes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>