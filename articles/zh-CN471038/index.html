<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐙 👨‍👩‍👦 📥 Linux描述符文件和示例 🐛 🧓🏿 ⌨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一次，在一次采访中，他们问我如果发现由于磁盘空间不足而无法使用的服务该怎么办？ 

 当然，我回答说，我将看到这个地方被占用了，如果可能的话，我会清理这个地方。 
 然后，面试官问，该部分是否没有可用空间，但是您也看不到占据整个位置的文件？ 

 为此，我说过，您始终可以例如使用lsof命令查看打开...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux描述符文件和示例</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471038/">一次，在一次采访中，他们问我如果发现由于磁盘空间不足而无法使用的服务该怎么办？ <br><br> 当然，我回答说，我将看到这个地方被占用了，如果可能的话，我会清理这个地方。 <br> 然后，面试官问，该部分是否没有可用空间，但是您也看不到占据整个位置的文件？ <br><br> 为此，我说过，您始终可以例如使用lsof命令查看打开的文件描述符，并了解哪个应用程序占用了所有可用空间，然后可以根据情况进行操作，具体取决于是否需要数据。 <br><br> 面试官最后一句话打断了我，并补充了我的问题：“假设我们不需要数据，它只是调试日志，但是应用程序无法运行，因为它无法记录调试信息？”？ <br><br> 我回答说：“好的，我们可以在应用程序的配置中关闭调试并重新启动它。” <br> 采访者反对：“不，我们无法重新启动应用程序，重要数据仍存储在我们的内存中，并且重要的客户端已连接到服务本身，因此我们不能强行重新连接”。 <br><br> 我说：“好吧，如果我们无法重新启动应用程序并且数据对我们来说并不重要，那么即使我们在文件系统上的ls命令中看不到它，也可以通过文件描述符简单地清除此打开的文件。” <br><br> 面试官很高兴，但我不满意。 <br><br> 然后我想，为什么测试我的知识的人不更深入？ 但是，如果数据仍然很重要怎么办？ 如果我们无法重新启动该过程，并且与此过程同时在没有可用空间的部分中将其写入文件系统，该怎么办？ 如果我们不仅不能丢失已经记录的数据，而且还可以丢失此过程写入或尝试记录的数据怎么办？ <br><a name="habracut"></a><br><h3> 图兹克 </h3><br> 在我职业生涯的开始，我试图创建一个小型应用程序，在其中必须存储有关用户的信息。 然后我想，如何将用户映射到他的数据。 例如，我有Ivan Ivanov Ivanich，他有一些数据，但是如何与他们交朋友呢？ 我可以直接指出，名为“ Tuzik”的狗就属于这个伊凡。 但是，如果他更改了自己的名字而代替了伊凡，例如奥利亚，该怎么办？ 事实证明，我们的Olya Ivanovna Ivanova将不再养狗，而我们的Tuzik仍属于不存在的Ivan。 该数据库得到一个数据库的帮助，该数据库为每个用户提供了一个唯一的标识符（ID），而我的Tuzik附加到该ID，实际上，这只是一个序数。 因此，tuzik的所有者的ID为2，并且在某个时间点Ivan处于该ID下，然后Olya成为相同的ID。 人畜问题已得到切实解决。 <br><br><h3> 文件描述符 </h3><br> 文件和使用此文件的程序的问题与我们的狗和人的问题大致相同。 假设我打开了一个名为ivan.txt的文件，并开始在其中写入单词tuzik，但是设法仅将第一个字母“ t”写入该文件，并且该文件被某人重命名，例如olya.txt。 但是文件保持不变，我仍然想在其中写入我的Ace。 每次使用任何编程语言通过开放系统调用打开文件时，我都会获得一个指向文件的唯一ID，该ID是文件描述符。 不管该文件的下一步操作是什么，他们都可以删除它，重命名它，更改所有者或删除读写权限，但我仍然可以访问它，因为在打开文件时我有权阅读和/或编写它，并且我设法开始与他合作，这意味着我必须继续这样做。 <br><br> 在Linux上，将为每个正在运行的应用程序（进程）3描述符文件打开libc库，编号为0,1,2。 您可以在链接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">man stdio</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">man stdout上</a>找到更多信息。 <br><br><ul><li> 文件描述符0称为STDIN，并且与从应用程序输入的数据相关联 </li><li> 文件描述符1称为STDOUT，由应用程序用于输出数据，例如打印命令 </li><li> 文件描述符2称为STDERR，应用程序使用它来输出错误报告数据。 </li></ul><br> 如果在程序中打开文件进行读取或写入，则很可能会获得第一个免费ID，该ID为3。 <br><br> 如果知道描述符文件的PID，则可以从任何进程查看描述符文件的列表。 <br><br> 例如，使用bash打开一个控制台，然后查看我们进程的PID <br><br><pre><code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 15771</code> </pre> <br> 在第二个控制台中，运行 <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br> 您可以放心地忽略本文框架中的文件描述符编号255；它是由bash本身（而不是由链接库）根据需要打开的。 <br><br> 现在，所有3个描述符文件都与伪终端设备<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">/ dev / pts</a>关联，但是我们仍然可以操纵它们，例如，在第二个控制台中运行 <br><br><pre> <code class="bash hljs">[user@localhost ]$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"hello world"</span></span> &gt; /proc/15771/fd/0</code> </pre><br> 在第一个控制台中，我们将看到 <br><br><pre> <code class="bash hljs">[user@localhost ]$ hello world</code> </pre><br><h3> 重定向和管道 </h3><br> 您可以在任何进程中轻松覆盖这3个描述符文件，包括在bash中，例如，通过连接两个进程的管道，请参见 <br><br><pre> <code class="bash hljs">[user@localhost ]$ cat /dev/zero | sleep 10000</code> </pre><br> 您可以使用<i>strace -f</i>自己运行此命令，并查看内部发生的情况，但我将简要介绍一下。 <br><br> 我们带有PID 15771的父进程bash解析我们的命令，并确切地了解我们要运行多少个命令，在我们的例子中，有两个命令：cat和sleep。  Bash知道他需要创建两个子进程，并将它们与一个管道结合在一起。 总共bash需要2个子进程和1个管道。 <br><br> 在创建子进程之前，bash启动<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">管道</a>系统调用并接收临时管道缓冲区的新文件描述符，但是该缓冲区尚未绑定我们的两个子进程。 <br><br> 对于父进程，看起来管道已经存在，并且还没有子进程： <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21</code> </pre><br> 然后，使用系统调用， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">clone</a> bash创建两个子进程，我们的三个进程如下所示： <br><br><pre> <code class="bash hljs">PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 15771 bash lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9004 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21 PID <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> 9005 bash lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 3 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 4 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 255 -&gt; /dev/pts/21</code> </pre><br> 不要忘记克隆会与所有文件描述符一起克隆该进程，因此它们在父进程和子进程中将是相同的。 具有PID 15771的父进程的任务是监视子进程，因此它仅等待子进程的响应。 <br><br> 因此，他不需要管道，并且用数字3和4关闭文件描述符。 <br><br> 在具有PID 9004的第一个bash子进程中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dup2</a>系统调用将我们的STDOUT文件描述符编号1更改为指向管道的文件描述符，在本例中为3。因此，具有PID 9004的第一个子进程将写入STDOUT的所有内容将自动落入管道缓冲区。 <br><br> 在使用PID 9005的第二个子进程中，bash使用dup2更改了描述符STDIN的编号为0，现在，我们使用PID 9005的第二bash读取的所有内容将从管道中读取。 <br><br> 此后，数字3和4的描述符也将在子进程中关闭，因为不再使用它们。 <br><br> 我故意忽略文件描述符255，它使用bash满足内部需要，并且也会在子进程中关闭。 <br><br> 此外，在具有PID 9004的第一个子进程中，bash使用系统调用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">exec</a>启动在命令行上指定的可执行文件，在本例中为/ usr / bin / cat。 <br><br> 在PID 9005的第二个子进程中，bash启动我们指定的第二个可执行文件，在本例中为/ usr / bin / sleep。 <br><br> 如果在打开调用期间未使用O_CLOEXEC标志打开文件描述符，则exec系统调用不会关闭文件描述符。 在我们的情况下，运行可执行文件后，将保存所有当前文件描述符。 <br><br> 检入控制台： <br><br><pre> <code class="bash hljs">[user@localhost ]$ pgrep -P 15771 9004 9005 [user@localhost ]$ ls -lah /proc/15771/fd/ total 0 dr-x------ 2 user user 0 Oct 7 15:42 . dr-xr-xr-x 9 user user 0 Oct 7 15:42 .. lrwx------ 1 user user 64 Oct 7 15:42 0 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 2 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:42 255 -&gt; /dev/pts/21 [user@localhost ]$ ls -lah /proc/9004/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lrwx------ 1 user user 64 Oct 7 15:57 0 -&gt; /dev/pts/21 l-wx------ 1 user user 64 Oct 7 15:57 1 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 lr-x------ 1 user user 64 Oct 7 15:57 3 -&gt; /dev/zero [user@localhost ]$ ls -lah /proc/9005/fd total 0 dr-x------ 2 user user 0 Oct 7 15:57 . dr-xr-xr-x 9 user user 0 Oct 7 15:57 .. lr-x------ 1 user user 64 Oct 7 15:57 0 -&gt; pipe:[253543032] lrwx------ 1 user user 64 Oct 7 15:57 1 -&gt; /dev/pts/21 lrwx------ 1 user user 64 Oct 7 15:57 2 -&gt; /dev/pts/21 [user@localhost ]$ ps -up 9004 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9004 0.0 0.0 107972 620 pts/21 S+ 15:57 0:00 cat /dev/zero [user@localhost ]$ ps -up 9005 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND user 9005 0.0 0.0 107952 360 pts/21 S+ 15:57 0:00 sleep 10000</code> </pre><br> 如您所见，我们的管道的唯一编号在两个过程中都相同。 因此，我们在一个父级的两个不同进程之间建立了联系。 <br><br> 对于那些不熟悉bash使用的系统调用的人，我强烈建议您通过strace运行命令并查看内部发生了什么，例如： <br><br><pre> <code class="bash hljs">strace -s 1024 -f bash -c <span class="hljs-string"><span class="hljs-string">"ls | grep hello"</span></span></code> </pre><br> 让我们回到磁盘空间不足并尝试在不重新启动进程的情况下保存数据的问题。 让我们编写一个小程序，该程序每秒将大约1兆字节写入磁盘。 此外，如果由于某种原因我们无法将数据写入磁盘，我们将简单地将其忽略，然后尝试在一秒钟后再次写入数据。 在我使用Python的示例中，您可以使用任何其他编程语言。 <br><br><pre> <code class="python hljs">[user@localhost ]$ cat openforwrite.py <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time mystr=<span class="hljs-string"><span class="hljs-string">"a"</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>+<span class="hljs-string"><span class="hljs-string">"\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f.write(str(datetime.datetime.now())) f.write(mystr) f.flush() time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br> 运行程序并查看文件描述符 <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py &amp; [1] 3762 [user@localhost ]$ ps axuf | grep [o]penforwrite user 3762 0.0 0.0 128600 5744 pts/22 S+ 16:28 0:00 | \_ python openforwrite.py [user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt</code> </pre><br> 如您所见，我们有3个标准文件描述符和另一个打开的文件描述符。 检查文件大小： <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 user user 117M Oct 7 16:30 123.txt</code> </pre><br> 正在写入数据，请尝试更改文件权限： <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo chown root: 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 168M Oct 7 16:31 123.txt [user@localhost ]$ ls -lah 123.txt -rw-rw-r-- 1 root root 172M Oct 7 16:31 123.txt</code> </pre><br> 尽管我们的用户无权写入文件，但我们仍看到数据仍在写入中。 让我们尝试将其删除： <br><br><pre> <code class="bash hljs">[user@localhost ]$ sudo rm 123.txt [user@localhost ]$ ls 123.txt ls: cannot access 123.txt: No such file or directory</code> </pre><br> 数据写在哪里？ 而且它们是全部写的吗？ 我们检查： <br><br><pre> <code class="bash hljs">[user@localhost ]$ ls -la /proc/3762/fd total 0 dr-x------ 2 user user 0 Oct 7 16:29 . dr-xr-xr-x 9 user user 0 Oct 7 16:29 .. lrwx------ 1 user user 64 Oct 7 16:29 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 7 16:29 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 7 16:29 3 -&gt; /home/user/123.txt (deleted)</code> </pre><br> 是的，我们的描述符文件仍然存在，我们可以像使用旧文件一样使用此描述符文件，我们可以读取，清理和复制它。 <br><br> 我们看一下文件大小： <br><br><pre> <code class="bash hljs">[user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 19923457 2621522 /home/user/123.txt</code> </pre><br> 文件大小19923457。尝试清除文件： <br><br><pre> <code class="bash hljs">[user@localhost ]$ truncate -s 0 /proc/31083/fd/3 [user@localhost ]$ lsof | grep 123.txt python 31083 user 3w REG 8,5 136318390 2621522 /home/user/123.txt</code> </pre><br> 如您所见，文件大小仅在增加，而我们的trankate无效。 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开放</a>系统调用，请参考文档。 如果在打开文件时使用O_APPEND标志，则每次操作系统检查文件大小并将数据写入文件的最后时，它都会自动执行此操作。 这允许多个线程或进程写入同一文件。 但是在我们的代码中，我们不使用此标志。 仅在打开文件进行其他记录时，我们才能在lsof中看到不同的文件大小，这意味着，而不是在我们的代码中 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br> 我们必须把 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br> 用“ w”标志检查 <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3</code> </pre><br> 并带有“ a”标志 <br><br><pre> <code class="bash hljs">[user@localhost ]$ strace -e trace=open python openforwrite.py 2&gt;&amp;1| grep 123.txt open(<span class="hljs-string"><span class="hljs-string">"123.txt"</span></span>, O_WRONLY|O_CREAT|O_APPEND, 0666) = 3</code> </pre><br><h3> 对已经运行的进程进行编程 </h3><br> 在创建和测试程序时，程序员经常在应用程序中使用调试器（例如GDB）或各种级别的日志记录。  Linux提供了实际编写和更改已经运行的程序的功能，例如，更改变量的值，设置断点等。 <br><br> 返回到磁盘空间不足以写入文件的原始问题，我们将尝试模拟该问题。 <br><br> 为分区创建一个文件，该文件将作为单独的磁盘装入： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=/dev/zero of=~/tempfile_for_article.dd bs=1M count=10 10+0 records <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 10+0 records out 10485760 bytes (10 MB) copied, 0.00525929 s, 2.0 GB/s [user@localhost ~]$</code> </pre><br> 创建一个文件系统： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfs.ext4 ~/tempfile_for_article.dd mke2fs 1.42.9 (28-Dec-2013) /home/user/tempfile_for_article.dd is not a block special device. Proceed anyway? (y,n) y ... Writing superblocks and filesystem accounting information: <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> [user@localhost ~]$</code> </pre><br> 挂载文件系统： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mount ~/tempfile_for_article.dd /mnt/ [sudo] password <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> user: [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 172K 7.9M 3% /mnt</code> </pre><br> 与我们的所有者创建目录： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ sudo mkdir /mnt/logs [user@localhost ~]$ sudo chown user: /mnt/logs</code> </pre><br> 我们打开文件以仅在程序中写入： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/123.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f:</code> </pre><br> 我们启动 <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py</code> </pre><br> 等待几秒钟 <br><br><pre> <code class="bash hljs">[user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br> 因此，我们得到了本文开头所述的问题。 可用空间为0，已占用100％。 <br><br> 我们记住，根据任务的条件，我们正在尝试记录非常重要的数据，这些数据不会丢失。 同时，我们需要在不重新启动过程的情况下修复服务。 <br><br> 假设我们仍然有磁盘空间，但是在另一个分区中，例如/ home。 <br><br> 让我们尝试“即时编程”我们的代码。 <br><br> 我们看一下进程的PID，它占用了所有磁盘空间： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]penfor user 10078 27.2 0.0 128600 5744 pts/22 R+ 11:06 0:02 | \_ python openforwrite.py</code> </pre><br> 我们通过gdb连接到进程 <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 10078 ... (gdb)</code> </pre><br> 我们看一下打开的文件描述符： <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt</code> </pre><br> 我们查看编号3的文件描述符信息，这对我们很感兴趣 <br><br><pre> <code class="bash hljs">(gdb) shell cat /proc/10078/fdinfo/3 pos: 8189952 flags: 0100001 mnt_id: 482</code> </pre><br> 记住Python做什么样的系统调用（请参见上文，我们在其中运行strace并找到了open调用），处理代码以打开文件，我们以自己的名义执行相同的操作，但是我们需要O_WRONLY | O_CREAT | O_TRUNC位用数值代替。 为此，请<a href="">在此处</a>打开内核源代码，例如，查看哪些标志负责什么。 <br><br>  ＃定义O_WRONLY 00000001 <br>  ＃定义O_CREAT 00000100 <br>  ＃定义O_TRUNC 00001000 <br><br> 我们将所有值合为一，得到00001101 <br><br> 从gdb运行我们的电话 <br><br><pre> <code class="bash hljs">(gdb) call open(<span class="hljs-string"><span class="hljs-string">"/home/user/123.txt"</span></span>, 00001101,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4</code> </pre><br> 因此，我们得到了一个编号为4的新描述符文件，另一部分为一个新的打开文件，请检查： <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br> 我们记得管道示例-bash如何更改文件描述符，并且已经学习了dup2系统调用。 <br><br> 我们尝试将一个文件描述符替换为另一个文件描述符 <br><br><pre> <code class="bash hljs">(gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3</code> </pre><br> 我们检查： <br><br><pre> <code class="bash hljs">(gdb) shell ls -lah /proc/10078/fd/ total 0 dr-x------ 2 user user 0 Oct 8 11:06 . dr-xr-xr-x 9 user user 0 Oct 8 11:06 .. lrwx------ 1 user user 64 Oct 8 11:09 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:09 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:06 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:09 3 -&gt; /home/user/123.txt l-wx------ 1 user user 64 Oct 8 11:15 4 -&gt; /home/user/123.txt</code> </pre><br> 我们关闭文件描述符4，因为我们不需要它： <br><br><pre> <code class="bash hljs">(gdb) call close (4) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 0</code> </pre><br> 并退出gdb <br><br><pre> <code class="bash hljs">(gdb) quit A debugging session is active. Inferior 1 [process 10078] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 10078</code> </pre><br> 检查新文件： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 5.1M Oct 8 11:18 /home/user/123.txt [user@localhost ~]$ ls -lah /home/user/123.txt -rw-rw-r-- 1 user user 7.1M Oct 8 11:18 /home/user/123.txt</code> </pre><br> 如您所见，数据已写入一个新文件，请检查旧文件： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/123.txt -rw-rw-r-- 1 user user 7.9M Oct 8 11:08 /mnt/logs/123.txt</code> </pre><br> 数据不会丢失，应用程序将运行，日志将被写入新位置。 <br><br><h3> 让我们把任务复杂一点 </h3><br> 想象一下数据对我们很重要，但是任何部分都没有磁盘空间，因此我们无法连接磁盘。 <br><br> 我们可以做的是将数据重定向到某个地方，例如到管道，然后来自管道的数据又通过某些程序（例如netcat）重定向到网络。 <br> 我们可以使用mkfifo命令创建一个命名管道。 即使文件系统上没有可用空间，它也会在文件系统上创建一个伪文件。 <br><br> 我们重新启动应用程序，并检查： <br><br><pre> <code class="bash hljs">[user@localhost ]$ python openforwrite.py [user@localhost ~]$ ps axuf | grep [o]pen user 5946 72.9 0.0 128600 5744 pts/22 R+ 11:27 0:20 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt [user@localhost ~]$ df -h | grep mnt /dev/loop0 8.7M 8.0M 0 100% /mnt</code> </pre><br> 没有磁盘空间，但是我们在此处成功创建了一个命名管道： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ mkfifo /mnt/logs/megapipe [user@localhost ~]$ ls -lah /mnt/logs/megapipe prw-rw-r-- 1 user user 0 Oct 8 11:28 /mnt/logs/megapipe</code> </pre><br> 现在，我们需要以某种方式将进入该管道的所有数据通过网络包装到另一台服务器，为此，所有相同的netcat都会这样做。 <br><br> 在remote-server.example.com服务器上，运行 <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc -l 7777 &gt; 123.txt</code> </pre><br> 在我们的问题服务器上，在单独的终端上运行 <br><br><pre> <code class="bash hljs">[user@localhost ~]$ nc remote-server.example.com 7777 &lt; /mnt/logs/megapipe</code> </pre><br> 现在，进入管道的所有数据将自动转到netcat中的stdin，它将通过端口7777发送到网络。 <br><br> 我们要做的就是开始将数据写入此命名管道。 <br><br> 我们已经有一个正在运行的应用程序： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ps axuf | grep [o]pen user 5946 99.8 0.0 128600 5744 pts/22 R+ 11:27 169:27 | \_ python openforwrite.py [user@localhost ~]$ ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt</code> </pre><br> 在所有标志中，我们只需要O_WRONLY，因为该文件已经存在并且我们不需要清除它 <br><br><pre> <code class="bash hljs">[user@localhost ~]$ gdb -p 5946 ... (gdb) call open(<span class="hljs-string"><span class="hljs-string">"/mnt/logs/megapipe"</span></span>, 00000001,0666) <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = 4 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/123.txt l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call dup2(4,3) <span class="hljs-variable"><span class="hljs-variable">$2</span></span> = 3 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe l-wx------ 1 user user 64 Oct 8 14:20 4 -&gt; /mnt/logs/megapipe (gdb) call close(4) <span class="hljs-variable"><span class="hljs-variable">$3</span></span> = 0 (gdb) shell ls -lah /proc/5946/fd total 0 dr-x------ 2 user user 0 Oct 8 11:27 . dr-xr-xr-x 9 user user 0 Oct 8 11:27 .. lrwx------ 1 user user 64 Oct 8 11:28 0 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:28 1 -&gt; /dev/pts/22 lrwx------ 1 user user 64 Oct 8 11:27 2 -&gt; /dev/pts/22 l-wx------ 1 user user 64 Oct 8 11:28 3 -&gt; /mnt/logs/megapipe (gdb) quit A debugging session is active. Inferior 1 [process 5946] will be detached. Quit anyway? (y or n) y Detaching from program: /usr/bin/python2.7, process 5946</code> </pre><br> 检查远程服务器remote-server.example.com <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah 123.txt -rw-rw-r-- 1 user user 38M Oct 8 14:21 123.txt</code> </pre><br> 数据走了，我们检查问题服务器 <br><br><pre> <code class="bash hljs">[user@localhost ~]$ ls -lah /mnt/logs/ total 7.9M drwxr-xr-x 2 user user 1.0K Oct 8 11:28 . drwxr-xr-x 4 root root 1.0K Oct 8 10:55 .. -rw-rw-r-- 1 user user 7.9M Oct 8 14:17 123.txt prw-rw-r-- 1 user user 0 Oct 8 14:22 megapipe</code> </pre><br> 数据已保存，问题已解决。 <br><br> 我借此机会向Degiro的同事们表达我的问候。 <br> 收听Radio T播客。 <br><br> 对所有人都好。 <br><br> 作为一项家庭作业，我建议考虑一下如果运行以下命令，cat and sleep进程的文件描述符中将包含什么内容： <br><br><pre> <code class="bash hljs">[user@localhost ~]$ cat /dev/zero 2&gt;/dev/null| sleep 10000</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN471038/">https://habr.com/ru/post/zh-CN471038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN471026/index.html">打字稿 力量永不</a></li>
<li><a href="../zh-CN471028/index.html">ROS卡车手推车。 第6部分。带轮编码器的里程表，房间图，激光雷达</a></li>
<li><a href="../zh-CN471032/index.html">隐形照片</a></li>
<li><a href="../zh-CN471034/index.html">Pornhub Web开发人员访谈</a></li>
<li><a href="../zh-CN471036/index.html">生活和学习。 第5部分。自我教育：齐心协力</a></li>
<li><a href="../zh-CN471040/index.html">[书签] React手册的PDF和ePUB版本</a></li>
<li><a href="../zh-CN471042/index.html">使用pwnable.kr 25解决问题-OTP Linux文件大小限制</a></li>
<li><a href="../zh-CN471044/index.html">Sass MediaScreen-定义CSS设备</a></li>
<li><a href="../zh-CN471046/index.html">时尚的阿瓦隆</a></li>
<li><a href="../zh-CN471048/index.html">React + Mobx：有什么意义？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>