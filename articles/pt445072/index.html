<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 🖕 🧔🏿 Telegraff: DSL Kotlin para telegrama 👨‍⚕️ 🈷️ 🤘🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No Habré, milhares de artigos sobre como fazer um bot do Telegram para diferentes linguagens e plataformas de programação. O tópico está longe de ser ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Telegraff: DSL Kotlin para telegrama</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445072/"><p><img src="https://habrastorage.org/webt/3v/da/0z/3vda0ztz83mtq8efycve_gfyrqa.png" alt="Logomarca"></p><br><p>  No Habré, milhares de artigos sobre como fazer um bot do Telegram para diferentes linguagens e plataformas de programação.  O tópico está longe de ser novo. </p><br><p>  Mas o Telegraff é a melhor estrutura para implementar os bots do Telegram, e vou provar isso por baixo. </p><a name="habracut"></a><br><h2 id="preambula">  Preâmbulo </h2><br><p>  Em 2015, o rublo russo estava com febre.  Economizei dólares e verifiquei a taxa literalmente a cada cinco minutos para vender a moeda na taxa que eu precisava.  A febre se arrastou, eu me cansei e escrevi para o bot do Telegram ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@TinkoffRatesBot</a> ), que o notifica se a taxa de câmbio atingir o valor limite (esperado). <br>  Fiquei muito emocionado com esta tarefa.  Botha escreveu muito rapidamente, mas ele não recebeu satisfação. </p><br><p> A integração com o Telegram não é e não houve problemas.  Esse problema foi resolvido em algumas horas.  E até me surpreendo que existam bibliotecas inteiras em Java (subjetivamente, com código nojento em qualidade) para integração com os Telegrams, que ganharam mais de mil estrelas no Github. </p><br><p>  O principal desafio para mim foi o sistema de script: o usuário chama um comando, por exemplo, "/ taxi", o bot faz uma série de perguntas, cada resposta é validada e pode afetar a ordem das perguntas subsequentes, a "forma" usual é formada, dada ao método de processamento final para a formação resposta. <br>  Eu fiz isso, mas a estrutura das classes, os níveis de abstração, era tudo tão heterogêneo que era amargo de se olhar.  Fiquei atormentado com a pergunta: como isso pode ser sucinta e organicamente transferido para um modelo orientado a objetos? </p><br><p>  Eu queria ter algo simples, conveniente e mais importante - para poder descrever o script inteiro em um arquivo isolado, para não precisar visualizar metade do projeto para entender a cadeia de interação do usuário. </p><br><p>  Para não dizer que o problema foi muito agudo, porque a tarefa já foi resolvida.  Em vez disso, às vezes eu pensava nele.  O pensamento era Groovy DSL, mas quando Kotlin chegou, a escolha se tornou óbvia.  Então Telegraff apareceu. </p><br><p>  Sim, claro, não havia competição que a Telegraff vencesse.  E a alegação de que Telegraff é o melhor não deve ser tomada literalmente.  Mas o Telegraff é uma abordagem nova e única para esse desafio.  É fácil ser o melhor, sendo o único. </p><br><h2 id="kak-etim-polzovatsya">  Como usá-lo? </h2><br><h3 id="zavisimosti">  Dependências </h3><br><p>  A primeira etapa é especificar um repositório adicional para dependências.  Talvez em algum momento eu publiquei o Telegraff no Maven Central ou no JCenter, mas por enquanto. </p><br><div class="spoiler">  <b class="spoiler_title">Gradle</b> <div class="spoiler_text"><pre><code class="kotlin hljs">repositories { maven { url <span class="hljs-string"><span class="hljs-string">"https://dl.bintray.com/ruslanys/maven"</span></span> } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Maven</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">snapshots</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">enabled</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">enabled</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">snapshots</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span>bintray-ruslanys-maven<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>bintray<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span>https://dl.bintray.com/ruslanys/maven<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Continua sendo o caso dos pequenos.  Para usar o Telegraff, é necessário especificar apenas uma dependência do iniciador de inicialização por mola: </p><br><div class="spoiler">  <b class="spoiler_title">Gradle</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">compile("me.ruslanys.telegraff:telegraff-starter:1.0.0")</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Maven</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>me.ruslanys.telegraff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>telegraff-starter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>1.0.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><h3 id="konfiguraciya">  Configuração </h3><br><p>  A configuração do projeto é simples e pode ser limitada aos dois ou três primeiros parâmetros: </p><br><div class="spoiler">  <b class="spoiler_title">application.properties</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">telegram.access-key=123 # ① telegram.mode=webhook # ② telegram.webhook-base-url=https://ruslanys.me # ③ telegram.webhook-endpoint-url=/telegram # ④ telegram.handlers-path=handlers # ⑤ telegram.unresolved-filter.enabled=false # ⑥</code> </pre> </div></div><br><ol><li>  Sua chave para a API do Telegram. </li><li>  O modo de receber mensagens (atualizações) do Telegram.  Pode ser polling ou webhook. </li><li>  Se o método para receber atualizações for indicado por "webhook", você deverá especificar o caminho para o seu aplicativo. </li><li>  Se desejar, você pode especificar seu próprio caminho para o terminal.  Se esse parâmetro não for redefinido, será gerado um caminho com o seguinte formulário: <code>/telegram/${UUID}</code> .  Antes de iniciar o aplicativo, o endereço especificado é definido como o endereço do gancho da web.  No final do trabalho, o endereço do gancho da Web é substituído para poder mudar para a pesquisa na próxima vez em que for iniciado. </li><li>  Se desejar, você pode alterar a pasta na qual os scripts dos manipuladores serão localizados.  Por padrão, esta é a pasta de <code>handlers</code> . </li><li>  <code>UnresolvedFilter</code> está incluído na "entrega" e está ativado por padrão.  Caso nenhum manipulador tenha sido encontrado na mensagem do usuário, o <code>UnresolvedFilter</code> responde com algo como "Desculpe, eu não entendo você :(". </li></ol><br><p>  É hora de escrever scripts! </p><br><h3 id="obrabotchiki">  Manipuladores </h3><br><p>  Manipuladores (scripts) são uma parte essencial do Telegraff.  É aqui que a cadeia de interação do usuário é definida.  A linha inferior é que cada comando, como “/ start”, “/ taxi”, “/ help”, é um script / script / manipulador / manipulador separado. </p><br><p>  Um script pode conter um conjunto de etapas (perguntas) pelas quais um usuário precisa executar para executar um comando.  Em outras palavras, o usuário deve preencher o formulário.  E como o messenger é da interface, você precisa conversar e perguntar ao usuário. </p><br><p>  Preciso explicar que as respostas do usuário precisam ser validadas?  A primeira coisa que o usuário fará é que ele responda de maneira diferente do que você espera. </p><br><p>  Bem, no final, o script pode ramificar, ou seja,  Cada resposta a uma pergunta pode afetar a ordem das seguintes. </p><br><p>  Por exemplo! </p><br><p>  Para iniciar, coloque o arquivo com a extensão <code>.kts</code> na pasta com <code>handlers</code> recursos: <code>src/main/resources/handlers/ExampleHandler.kts</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Cenário de chamada de táxi</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentMethod</span></span></span><span class="hljs-class"> </span></span>{ CARD, CASH } handler(<span class="hljs-string"><span class="hljs-string">"/taxi"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ① step&lt;String&gt;("locationFrom") { // ② question { // ③ MarkdownMessage(" ?") } } step&lt;String&gt;("locationTo") { question { MarkdownMessage(" ?") } } step&lt;PaymentMethod&gt;("paymentMethod") { question { state -&gt; MarkdownMessage("   ?", "", "") // ④ } validation { // ⑤ when (it.toLowerCase()) { "" -&gt; PaymentMethod.CARD "" -&gt; PaymentMethod.CASH else -&gt; throw ValidationException(",    ") // ⑥ } } next { state -&gt; null // ⑦ } } process { state, answers -&gt; // ⑧ val from = answers["locationFrom"] as String val to = answers["locationTo"] as String val paymentMethod = answers["paymentMethod"] as PaymentMethod // ⑨ // Business logic MarkdownMessage("""     #${state.chat.id}.   $from  $to.  $paymentMethod. """.trimIndent()) // ⑩ } }</span></span></code> </pre> </div></div><br><p>  As chaves das estepes não foram deliberadamente tomadas em constantes.  Na produção, é claro, é melhor evitar isso. </p><br><p>  Vamos descobrir isso: </p><br><ol><li>  Declaramos o script.  É necessário pelo menos um nome de equipe.  Nesse caso, existem duas equipes: "/ taxi", "taxi".  Se a mensagem do usuário começar com essas palavras, o manipulador correspondente será chamado. </li><li>  Nós determinamos as etapas (perguntas).  Um nome de etapa exclusivo é necessário porque  posteriormente, a resposta do usuário pode ser acessada com precisão por essa chave ("locationFrom"). </li><li>  Cada etapa contém três seções, a primeira das quais é a própria pergunta.  A questão é uma seção obrigatória que deve estar presente em todas as etapas.  Não há sentido em uma etapa sem uma pergunta. </li><li>  Você pode preencher a pergunta como desejar.  Nesse caso, o usuário será solicitado, através do teclado, a selecionar uma das opções: "Cartão" ou "Dinheiro".  Como resultado da chamada desse bloco, deve haver um objeto do tipo <code>TelegramSendRequest</code> .  Desculpe, não consegui encontrar nada melhor que o sufixo <code>SendRequest</code> , que descreve a estrutura como uma solicitação de saída no Telegram. <br><img src="https://habrastorage.org/webt/zc/fg/u0/zcfgu08yo--cn3bhnrnhawcfad0.png" alt="Estrutura de classe"></li><li>  A segunda seção da etapa mais importante é verificar a resposta do usuário.  O tipo de cada etapa é parametrizado (genérico) e, portanto, o bloco de validação deve retornar exatamente o tipo pelo qual sua etapa é parametrizada. </li><li>  Se a resposta do usuário for insatisfatória, você poderá lançar uma <code>ValidationException</code> com texto esclarecedor, mas com o mesmo teclado, se indicado na pergunta. </li><li>  A seção da etapa final é um bloco que indica a próxima etapa.  Por padrão, as etapas serão executadas na ordem de sua declaração, de cima para baixo.  Mas esse processo pode ser influenciado substituindo o bloco correspondente.  A chave da próxima etapa ( <code>String</code> ) ou “null” pode ser retornada como resultado da execução deste bloco, indicando que não há mais etapas e é hora de prosseguir com a execução do comando. </li><li>  Quando uma solicitação do usuário é gerada, seu processamento é necessário.  Os argumentos no lambda são State (isso é algo como uma sessão) e respostas do usuário. </li><li>  Observe que a resposta com falha não é mais a sequência de respostas do usuário, mas um objeto já processado do tipo desejado. </li><li>  A resposta ao comando pode ser qualquer uma, semelhante ao parágrafo 4. Se a resposta ao comando não for necessária, você poderá retornar "nulo". </li></ol><br><p>  Um manipulador pode não ter etapas.  Nesse caso, você só precisa determinar o comportamento do manipulador para chamar o comando. </p><br><div class="spoiler">  <b class="spoiler_title">Script de boas-vindas</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">handler(<span class="hljs-string"><span class="hljs-string">"/start"</span></span>) { process { _, _ -&gt; MarkdownMessage(<span class="hljs-string"><span class="hljs-string">"!"</span></span>) } }</code> </pre> </div></div><br><h3 id="probuem">  Experimente </h3><br><p>  Para tentar, bifurque o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">repositório</a> , clone-o na máquina local e vá para a pasta <code>telegraff-sample</code> .  Configure, inicie, toque! </p><br><p>  Em geral, <code>telegraff-sample</code> é um projeto deliberadamente independente, que não está relacionado ao pai e tem seu próprio Gradle Wrapper.  Você pode deixar apenas esta pasta.  Este é um tipo de arquétipo. </p><br><h2 id="kak-eto-ustroeno">  Como isso funciona? </h2><br><h3 id="telegram">  Telegram </h3><br><p>  A integração com o Telegram é muito simples e implementada no <a href=""><code>TelegramApi</code></a> . </p><br><p>  Cada método foi deliberadamente implementado individualmente devido a várias circunstâncias: a partir do uso do RestTemplate da Spring (e testes para ele), até a especificidade da API do Telegram. </p><br><p>  Como você pode ver na configuração, existem dois tipos de clientes dessa API no Telegraff: <a href="">PollingClient</a> , <a href="">WebhookClient</a> .  Dependendo da configuração, uma posição específica será declarada. </p><br><p>  E embora os métodos para receber atualizações (novas mensagens) sejam diferentes do Telegram, a essência permanece inalterada e resume-se a uma coisa: publicar um evento ( <a href=""><code>TelegramUpdateEvent</code></a> ) sobre novas mensagens no <code>EventPublisher</code> da Spring (padrão "Observer").  Se desejar, você pode implementar seu próprio ouvinte assinando esse tipo de evento.  Uma camada lógica, como me parece, de abstração, porque absolutamente não importa como a mensagem foi recebida. </p><br><h3 id="filtry">  Filtros </h3><br><p>  Assim que uma nova mensagem for recebida, é necessário processá-la e responder ao usuário.  Para fazer isso, a mensagem precisa passar pela cadeia de filtros. </p><br><p>  Isso é semelhante aos filtros Java EE familiares aos programadores Java.  A única diferença é que os chamados Manipuladores (se traçarmos um paralelo com o Java EE, estes são Servlets) não são independentes dos filtros, mas fazem parte deles. </p><br><p><img src="https://habrastorage.org/webt/uo/ok/y8/uooky82zpiurpncn-szq4bdejni.png" alt="Cadeia de filtro"></p><br><p>  Portanto, os filtros são otimizados e podem deixar as mensagens irem mais longe na cadeia, talvez não. </p><br><p>  <code>LoggingFilter</code> é obviamente o filtro de prioridade mais alta (primeiro) que será chamado como parte do processamento de uma nova mensagem.  Registra as informações em uma mensagem recebida e as envia mais adiante na cadeia.  Eu propositadamente adicionei o <code>LoggingFilter</code> como exemplo.  De fato, pode não fazer sentido, porque  As mensagens recebidas são registradas no nível do cliente. </p><br><p>  O próximo filtro é <code>CancelFilter</code> .  Funciona essencialmente em conjunto com o <code>HandlersFilter</code> e é um complemento para ele.  Sua tarefa é simples: se o usuário deseja abandonar o script atual, ele pode escrever "/ cancel" ou "cancel" e seu Status (sessão) deve ser limpo.  Ele pode iniciar qualquer novo cenário sem concluir o anterior.  Por esse motivo, o <code>CancelFilter</code> " <code>CancelFilter</code> " mais alto (prioritário). </p><br><p>  <code>HandlersFilter</code> é o principal filtro no processo atual.  É esse filtro que armazena o estado dos bate-papos do usuário, encontra e chama o manipulador (script) desejado, aplica blocos de validação, determina a ordem das etapas e responde ao usuário. </p><br><p>  Se o <code>HandlersFilter</code> não encontrou nenhum manipulador adequado para a mensagem do usuário, na sessão ou no conteúdo, a mensagem é enviada mais adiante na cadeia.  O filtro extremo é <code>UnresolvedFilter</code> .  Este é um filtro que sabe que é o último, portanto, sua funcionalidade é simples: se eles chegaram até mim, como responder a uma mensagem não está claro, direi que não entendi nada.  Parece-me que é melhor receber pelo menos algumas mensagens do bot se não souber responder, do que não receber nada. </p><br><p>  Para adicionar seu filtro, você precisa declarar um Bean da classe <code>TelegramFilter</code> e especificar a anotação <code>@TelegramFilterOrder(ORDER_NUMBER)</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Exemplo de filtro</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@TelegramFilterOrder(Integer.MIN_VALUE)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggingFilter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TelegramFilter { override fun handleMessage</span></span></span></span>(message: TelegramMessage, chain: TelegramFilterChain) { log.info(<span class="hljs-string"><span class="hljs-string">"New message from #{}: {}"</span></span>, message.chat.id, message.text) chain.doFilter(message) } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> log = LoggerFactory.getLogger(LoggingFilter::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> </div></div><br><p>  É assim que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@TinkoffRatesBot</a> implementa uma “calculadora”.  Sem chamar nenhum script e comando, você pode enviar um número, por exemplo, "1000" ou até uma expressão inteira, por exemplo, "4500 * 3 - 12000".  O bot calculará o resultado da expressão, aplicará as taxas de câmbio atuais ao resultado e exibirá informações sobre ele.  De fato, o resultado de tais ações é a execução do <code>CalculationFilter</code> , que está na cadeia abaixo do <code>HandlersFilter</code> , mas acima do <code>UnresolvedFilter</code> . </p><br><h3 id="obrabotchiki-1">  Manipuladores </h3><br><p>  O sistema de script Telegraff (manipuladores) é construído no DSL do Kotlin.  Em resumo, trata-se de lambdas e construtores. </p><br><p>  Não vejo o objetivo de visualizar separadamente o DSL Kotlin, porque  essa é uma conversa completamente diferente.  Há uma excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> do JetBrains e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relatório</a> abrangente do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">i_osipov</a> . </p><br><h3 id="nyuansy">  Nuances </h3><br><p>  Esta seção é dedicada aos recursos atuais.  Todos eles, na minha opinião, não são críticos, alguns podem ser corrigidos, outros não.  Mas você precisa saber sobre esses aspectos. </p><br><p>  Se você deseja participar ou conhece como corrigir um ou outro ponto desta seção, ficarei muito agradecido. </p><br><h4 id="telegram-1">  Telegram </h4><br><p>  A camada de integração com o Telegram provavelmente não está totalmente descrita.  Apenas os métodos que eu precisava foram implementados.  Se houver algo que lhe falte pessoalmente, corrija o <a href=""><code>TelegramApi</code></a> e envie o PR! </p><br><p>  Uma das partes importantes no momento é a falta de suporte ao teclado embutido (é quando o teclado está diretamente abaixo da mensagem na faixa de opções).  A tarefa é agravada pelo fato de que os teclados em linha precisam ser corretamente "inseridos" na estrutura existente, para que ela permaneça simples, conveniente e isolada.  Já existe uma boa idéia para implementar essa funcionalidade, mas ainda não foi implementada e testada de nenhuma forma. </p><br><h4 id="fat-jar">  Frasco de gordura </h4><br><p>  Infelizmente, algumas bibliotecas, como <code>JRuby</code> e provavelmente o <code>Kotlin Embedded Compiler</code> (necessário para compilar scripts), podem ter problemas como parte do <code>Fat JAR</code> .  <code>Fat JAR</code> é quando seu código e todas as suas dependências são compactados em um arquivo ( <code>*.jar</code> ). </p><br><p>  Para resolver esse problema, você pode descompactar dependências em tempo de execução.  Ou seja, quando o aplicativo é iniciado, a dependência JAR do pacote principal é implementada em algum lugar do disco e o caminho de classe é indicado antes dele.  Isso é muito fácil de fazer através <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da configuração</a> <code>bootJar</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Configuração de plugins</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">bootJar { requiresUnpack "**/**kotlin**.jar" requiresUnpack "**/**telegraff**.jar" }</code> </pre> </div></div><br><p>  No entanto, para se referir dos manipuladores (scripts) aos seus beans (serviços, por exemplo), eles também devem ser descompactados.  O que, em princípio, elimina os benefícios dessa abordagem. </p><br><p>  A meu ver, o uso do plugin do <code>application</code> Gradle continua sendo o método mais confiável, simples e conveniente.  Além disso, se você estiver continhando seu aplicativo, não há diferença no resultado. </p><br><p>  Sobre tudo isso, escrevi com alguns detalhes <a href="">aqui</a> . </p><br><h4 id="poryadok-inicializacii">  Ordem de inicialização </h4><br><p>  Aqui eu gostaria de observar duas circunstâncias. </p><br><p>  Primeiro, se você observar o cenário de chamada de táxi, poderá ver que a classe <code>enum</code> está definida acima da chamada para o <code>handler(...)</code> .  Essa necessidade é imposta pelo fato de que, de fato, <code>handler</code> é uma chamada de função.  Uma chamada de função, cujo resultado deve ser alguma estrutura, que o Telegraff usará mais tarde.  Se, de acordo com o resultado da execução do seu script, a fábrica não puder trazer o resultado para o tipo desejado, ocorrerá um erro no estágio de inicialização. </p><br><p>  Em segundo lugar, é necessário lembrar que seus scripts podem ser inicializados antes de todo o aplicativo e beans.  Se, por exemplo, colocarmos um link para o contexto em uma variável estática e tentarmos obter algum serviço na primeira linha do arquivo de script, pode acontecer que o contexto não o tenha, porque  ainda não foi inicializado.  Para evitar esses problemas, use <a href="">este</a> método Telegraff.  Ele garante que o contexto seja inicializado e que todos os beans necessários estejam disponíveis.  Um exemplo pode ser visto <a href="">aqui</a> . </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Eu queria tentar - garfo, <br>  Eu queria corrigi-lo - enviar PR, <br>  Queria agradecer - coloque um asterisco no Github, curta o post e conte para seus amigos! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Repositório do projeto</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445072/">https://habr.com/ru/post/pt445072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445060/index.html">Organizando pesquisas de dados usando os repositórios de dados-chave do Spring Data</a></li>
<li><a href="../pt445062/index.html">Formato de apresentação moderno?</a></li>
<li><a href="../pt445064/index.html">A batalha pela neutralidade da rede - uma chance de voltar</a></li>
<li><a href="../pt445066/index.html">Como escrevo notas de matemática no LaTeX no Vim</a></li>
<li><a href="../pt445070/index.html">O resumo de materiais interessantes para o desenvolvedor móvel # 291 (18 a 24 de março)</a></li>
<li><a href="../pt445074/index.html">Programando o LibreOffice Base. Parte 1</a></li>
<li><a href="../pt445076/index.html">Gigante de TI introduziu firewall definido por serviço</a></li>
<li><a href="../pt445078/index.html">A física quântica provavelmente protegerá as redes elétricas dos EUA contra hackers</a></li>
<li><a href="../pt445080/index.html">Na Rússia, criará uma "ferrovia digital"</a></li>
<li><a href="../pt445082/index.html">No mês passado, chamamos Zuckerberg de boob; corrigido: de fato, ele e seu Facebook são uma vergonha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>