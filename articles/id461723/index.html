<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈵 🥉 🎿 Memahami paket Konteks di Golang 🤒 💲 🤳🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Paket konteks di Go berguna untuk interaksi dengan API dan proses yang lambat, terutama dalam sistem tingkat produksi yang menangani permintaan web. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami paket Konteks di Golang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nixys/blog/461723/"><p><img src="https://habrastorage.org/getpro/habr/post_images/2f4/49e/54b/2f449e54b5540578a8ead5599e9e7f0e.jpg" alt="gambar"></p><br><p>  Paket konteks di Go berguna untuk interaksi dengan API dan proses yang lambat, terutama dalam sistem tingkat produksi yang menangani permintaan web.  Dengan bantuannya, goroutine dapat diberi tahu tentang perlunya menyelesaikan pekerjaan mereka. </p><br><p>  Di bawah ini adalah panduan kecil untuk membantu Anda menggunakan paket ini dalam proyek Anda, serta beberapa praktik terbaik dan perangkap. </p><br><p>  <em>(Catatan: Konteksnya digunakan dalam banyak paket, misalnya, dalam bekerja dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Docker</a> ).</em> </p><a name="habracut"></a><br><h2 id="pered-tem-kak-nachat">  Sebelum Anda mulai </h2><br><p>  Untuk menggunakan konteks, Anda harus memahami apa itu goroutine dan saluran.  Saya akan mencoba mempertimbangkannya secara singkat.  Jika Anda sudah terbiasa dengan mereka, langsung ke bagian Konteks. </p><br><h3 id="gorutina">  Gorutin </h3><br><p>  Dokumentasi resmi mengatakan bahwa "Gorutin adalah aliran eksekusi yang ringan."  Goroutin lebih ringan dari utas, jadi mengelolanya relatif kurang intensif sumber daya. </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Pasir</a> </p><br><pre><code class="plaintext hljs">package main import "fmt" // ,   Hello func printHello() { fmt.Println("Hello from printHello") } func main() { //   //       go func(){fmt.Println("Hello inline")}() //     go printHello() fmt.Println("Hello from main") }</code> </pre> <br><p>  Jika Anda menjalankan program ini, Anda akan melihat bahwa hanya <code>Hello from main</code> dicetak.  Sebenarnya, kedua goroutine mulai, tetapi <code>main</code> selesai lebih awal.  Jadi, Goroutine perlu cara untuk memberi tahu <code>main</code> tentang akhir eksekusi mereka, dan agar dia menunggu ini.  Di sini saluran datang untuk membantu kami. </p><br><h3 id="kanaly-channels">  Saluran </h3><br><p>  Saluran adalah cara komunikasi antara goroutine.  Mereka digunakan ketika Anda ingin mentransfer hasil, kesalahan atau informasi lain dari satu goroutine ke yang lain.  Saluran adalah tipe yang berbeda, misalnya, saluran tipe <code>int</code> menerima bilangan bulat, dan saluran tipe <code>error</code> menerima kesalahan, dll. </p><br><p>  Katakanlah kita memiliki saluran <code>ch</code> tipe <code>int</code> .  Jika Anda ingin mengirim sesuatu ke saluran, sintaksinya adalah <code>ch &lt;- 1</code> .  Anda bisa mendapatkan sesuatu dari saluran seperti ini: <code>var := &lt;- ch</code> , i.e.  ambil nilainya dari saluran dan simpan dalam variabel <code>var</code> . </p><br><p>  Kode berikut menggambarkan cara menggunakan saluran untuk mengkonfirmasi bahwa goroutine telah menyelesaikan pekerjaan mereka dan mengembalikan nilainya ke <code>main</code> . </p><br><p>  <em>Catatan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup menunggu</a> juga dapat digunakan untuk sinkronisasi, tetapi dalam artikel ini saya memilih saluran untuk contoh kode, karena kita akan menggunakannya nanti di bagian konteks.</em> </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Pasir</a> </p><br><pre> <code class="plaintext hljs">package main import "fmt" //       int   func printHello(ch chan int) { fmt.Println("Hello from printHello") //     ch &lt;- 2 } func main() { //  .       make //       : // ch := make(chan int, 2),       . ch := make(chan int) //  .  ,    . //       go func(){ fmt.Println("Hello inline") //     ch &lt;- 1 }() //     go printHello(ch) fmt.Println("Hello from main") //      //     ,    i := &lt;- ch fmt.Println("Received ",i) //      //    ,      &lt;- ch }</code> </pre> <br><h2 id="kontekst-context">  Konteks </h2><br><p>  Paket konteks di mana saja memungkinkan Anda untuk meneruskan data ke program Anda dalam semacam "konteks".  Konteksnya, seperti batas waktu, tenggat waktu atau saluran, memberi sinyal penutupan dan panggilan kembali. </p><br><p>  Misalnya, jika Anda membuat permintaan web atau menjalankan perintah sistem, sebaiknya gunakan batas waktu untuk sistem tingkat produksi.  Karena jika API yang Anda akses lambat, Anda tidak mungkin ingin mengakumulasi permintaan di sistem Anda, karena hal ini dapat menyebabkan peningkatan beban dan penurunan kinerja saat memproses permintaan Anda sendiri.  Hasilnya adalah efek kaskade. </p><br><p>  Dan di sini konteks batas waktu atau batas waktu mungkin tepat. </p><br><h3 id="sozdanie-konteksta">  Pembuatan konteks </h3><br><p>  Paket konteks memungkinkan Anda untuk membuat dan mewarisi konteks dengan cara berikut: </p><br><p>  <strong>context.Background () ctx Konteks</strong> </p><br><p>  Fungsi ini mengembalikan konteks kosong.  Ini harus digunakan hanya pada level tinggi (di utama atau di handler permintaan level tertinggi).  Ini dapat digunakan untuk mendapatkan konteks lain, yang akan kita bahas nanti. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.Background()</code> </pre> <br><p>  <em>Catatan</em>  <em>trans .: Ada ketidakakuratan dalam artikel asli, contoh yang benar dalam menggunakan <code>context.Background</code> akan menjadi sebagai berikut:</em> </p><br><pre> <code class="plaintext hljs">ctx := context.Background()</code> </pre> <br><p>  <strong>context.TODO () Konteks ctx</strong> </p><br><p>  Fungsi ini juga menciptakan konteks kosong.  Dan itu juga harus digunakan hanya pada level tinggi, baik ketika Anda tidak yakin konteks mana yang digunakan, atau jika fungsi belum menerima konteks yang diinginkan.  Ini berarti bahwa Anda (atau seseorang yang mendukung kode) berencana untuk menambahkan konteks ke fungsi nanti. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.TODO()</code> </pre> <br><p>  <em>Catatan</em>  <em>trans .: Ada ketidakakuratan dalam artikel asli, contoh yang benar untuk menggunakan <code>context.TODO</code> akan menjadi sebagai berikut:</em> </p><br><pre> <code class="plaintext hljs">ctx := context.TODO()</code> </pre> <br><p>  Menariknya, lihat <a href="">kodenya</a> , sama sekali sama dengan latar belakang.  Satu-satunya perbedaan adalah bahwa dalam kasus ini, Anda dapat menggunakan alat analisis statis untuk memeriksa validitas transfer konteks, yang merupakan detail penting, karena alat ini membantu mengidentifikasi potensi kesalahan pada tahap awal dan dapat dimasukkan dalam pipa CI / CD. </p><br><p>  <a href="">Dari sini</a> : </p><br><pre> <code class="plaintext hljs">var ( background = new(emptyCtx) todo = new(emptyCtx) )</code> </pre> <br><p>  <strong>context.Dengan Nilai (Konteks induk, kunci, antarmuka val {}) (Konteks CTX, batalkan CancelFunc)</strong> </p><br><p>  <em>Catatan</em>  <em>Lane: Ada ketidakakuratan dalam artikel asli, tanda tangan yang benar untuk <code>context.WithValue</code> akan sebagai berikut:</em> </p><br><pre> <code class="plaintext hljs">context.WithValue(parent Context, key, val interface{}) Context</code> </pre> <br><p>  Fungsi ini mengambil konteks dan mengembalikan konteks yang berasal darinya di mana nilai <code>val</code> dikaitkan dengan <code>key</code> dan melewati seluruh pohon konteks.  Yaitu, segera setelah Anda membuat konteks <code>WithValue</code> , setiap konteks turunan akan menerima nilai ini. </p><br><p>  Tidak disarankan untuk melewatkan parameter kritis menggunakan nilai konteks, sebagai gantinya, fungsi harus mengambilnya secara eksplisit dalam tanda tangan. </p><br><pre> <code class="plaintext hljs">ctx := context.WithValue(context.Background(), key, "test")</code> </pre> <br><p>  <strong>context.DenganCancel (Konteks induk) (Konteks CTX, batalkan CancelFunc)</strong> </p><br><p>  Menjadi sedikit lebih menarik di sini.  Fungsi ini menciptakan konteks baru dari orang tua yang diteruskan ke sana.  Orang tua dapat menjadi konteks latar belakang atau konteks yang diteruskan sebagai argumen ke fungsi. </p><br><p>  Konteks yang diturunkan dan fungsi undo dikembalikan.  Hanya fungsi yang membuatnya harus memanggil fungsi untuk membatalkan konteks.  Anda dapat meneruskan fungsi undo ke fungsi lain jika diinginkan, tetapi ini sangat tidak disarankan.  Biasanya keputusan ini dibuat dari kesalahpahaman tentang pembatalan konteks.  Karena itu, konteks yang dihasilkan dari orangtua ini dapat memengaruhi program, yang akan mengarah pada hasil yang tidak terduga.  Singkatnya, lebih baik untuk TIDAK PERNAH melewati fungsi batal. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <em>Catatan</em>  <em>Lane: Dalam artikel aslinya, penulis, kelihatannya, keliru untuk <code>context.WithCancel</code> memberi contoh dengan <code>context.WithDeadline</code> .</em>  <em>Contoh yang benar untuk <code>context.WithCancel</code></em> </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithCancel(context.Background())</code> </pre> <br><p>  <strong>context.DenganDeadline (Konteks induk, d waktu. Waktu) (Konteks ctx, batalkan CancelFunc)</strong> </p><br><p>  Fungsi ini mengembalikan konteks turunan dari induknya, yang dibatalkan setelah batas waktu atau panggilan ke fungsi batal.  Misalnya, Anda dapat membuat konteks yang secara otomatis dibatalkan pada waktu tertentu dan meneruskannya ke fungsi anak.  Ketika konteks ini dibatalkan setelah batas waktu, semua fungsi yang memiliki konteks ini harus diberitahukan melalui pemberitahuan. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <strong>context.Dengan Timeime (Konteks induk, batas waktu time. Durasi) (Konteks CTX, batalkan CancelFunc)</strong> </p><br><p>  Fungsi ini mirip dengan konteks.  Perbedaannya adalah bahwa lamanya waktu digunakan sebagai input.  Fungsi ini mengembalikan konteks turunan yang dibatalkan ketika fungsi batal dipanggil atau setelah beberapa saat. </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second))</code> </pre> <br><p>  <em>Catatan</em>  <em>Per.: Dalam artikel asli, penulis, tampaknya, keliru untuk <code>context.WithTimeout</code> memberi contoh dengan <code>context.WithDeadline</code> .</em>  <em>Contoh yang benar untuk <code>context.WithTimeout</code> adalah:</em> </p><br><pre> <code class="plaintext hljs">ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second)</code> </pre> <br><h3 id="priyom-i-ispolzovanie-kontekstov-v-vashih-funkciyah">  Penerimaan dan penggunaan konteks dalam fungsi Anda </h3><br><p>  Sekarang kita tahu cara membuat konteks (Latar Belakang dan TODO) dan cara membuat konteks (WithValue, WithCancel, Tenggat Waktu, dan Batas Waktu), mari kita bahas cara menggunakannya. </p><br><p>  Dalam contoh berikut, Anda dapat melihat bahwa fungsi yang mengambil konteks meluncurkan goroutine dan mengharapkannya untuk mengembalikan atau membatalkan konteks.  Pernyataan pilih membantu kita menentukan apa yang terjadi terlebih dahulu dan menghentikan fungsi. </p><br><p>  Setelah menutup saluran Selesai <code>&lt;-ctx.Done()</code> , case <code>case &lt;-ctx.Done():</code> dipilih.  Segera setelah ini terjadi, fungsi harus mengganggu pekerjaan dan bersiap untuk kembali.  Ini berarti Anda harus menutup koneksi terbuka, membebaskan sumber daya, dan kembali dari fungsi.  Ada saat-saat ketika pelepasan sumber daya dapat menunda pengembalian, misalnya, pembersihan terhenti.  Anda harus mengingat hal ini. </p><br><p>  Contoh yang mengikuti bagian ini adalah program yang sudah jadi yang menggambarkan fungsi timeout dan undo. </p><br><pre> <code class="plaintext hljs">// ,  -      // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } }</code> </pre> <br><h3 id="primer">  Contoh </h3><br><p>  Seperti yang kita lihat, menggunakan konteks Anda dapat bekerja dengan tenggat waktu, batas waktu, dan juga memanggil fungsi batal, dengan demikian memperjelas semua fungsi menggunakan konteks turunan yang Anda perlukan untuk menyelesaikan pekerjaan Anda dan menjalankan pengembalian.  Pertimbangkan sebuah contoh: </p><br><p>  fungsi <code>main</code> : </p><br><ul><li>  Membuat konteks fungsi batal </li><li>  Memanggil fungsi batal setelah batas waktu sewenang-wenang </li></ul><br><p>  Fungsi <code>doWorkContext</code> : </p><br><ul><li>  Menciptakan konteks turunan dengan batas waktu </li><li>  Konteks ini dibatalkan ketika fungsi utama memanggil cancelFunction, batas waktu habis, atau doWorkContext memanggil cancelFunction. </li><li>  Menjalankan goroutine untuk melakukan beberapa tugas lambat, melewati konteks yang dihasilkan </li><li>  Menunggu goroutine selesai atau konteksnya dibatalkan dari main, mana yang lebih dulu </li></ul><br><p>  Fungsi <code>sleepRandomContext</code> : </p><br><ul><li>  Meluncurkan goroutine untuk melakukan beberapa tugas lambat </li><li>  Menunggu goroutine selesai, atau </li><li>  Menunggu konteksnya dibatalkan oleh fungsi utama, batas waktu, atau panggil Fungsi batal sendiri </li></ul><br><p>  Fungsi <code>sleepRandom</code> : </p><br><ul><li>  Tertidur secara acak </li></ul><br><p>  Contoh ini menggunakan mode tidur untuk mensimulasikan waktu pemrosesan acak, tetapi dalam kenyataannya, Anda dapat menggunakan saluran untuk memberi sinyal fungsi ini tentang dimulainya pembersihan dan menunggu konfirmasi dari saluran bahwa pembersihan selesai. </p><br><p>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sandbox</a> (Sepertinya waktu acak yang saya gunakan di sandbox praktis tidak berubah. Coba ini di komputer lokal Anda untuk melihat keacakan)</em> </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </p><br><pre> <code class="plaintext hljs">package main import ( "context" "fmt" "math/rand" "Time" ) //   func sleepRandom(fromFunction string, ch chan int) { //    defer func() { fmt.Println(fromFunction, "sleepRandom complete") }() //    //   , // «»      seed := time.Now().UnixNano() r := rand.New(rand.NewSource(seed)) randomNumber := r.Intn(100) sleeptime := randomNumber + 100 fmt.Println(fromFunction, "Starting sleep for", sleeptime, "ms") time.Sleep(time.Duration(sleeptime) * time.Millisecond) fmt.Println(fromFunction, "Waking up, slept for ", sleeptime, "ms") //   ,     if ch != nil { ch &lt;- sleeptime } } // ,       // ,   -    func sleepRandomContext(ctx context.Context, ch chan bool) { //  (. .:  )    //     // ,    defer func() { fmt.Println("sleepRandomContext complete") ch &lt;- true }() //   sleeptimeChan := make(chan int) //       //     go sleepRandom("sleepRandomContext", sleeptimeChan) //  select        select { case &lt;-ctx.Done(): //   ,    //  ,    doWorkContext  // doWorkContext  main  cancelFunction //  ,     -   //    ,    ( ) //    -  , //    ,   //         fmt.Println("sleepRandomContext: Time to return") case sleeptime := &lt;-sleeptimeChan: //   ,       fmt.Println("Slept for ", sleeptime, "ms") } } //  ,         //       //   ,      main func doWorkContext(ctx context.Context) { //          - //  150  //  ,   ,   150  ctxWithTimeout, cancelFunction := context.WithTimeout(ctx, time.Duration(150)*time.Millisecond) //         defer func() { fmt.Println("doWorkContext complete") cancelFunction() }() //       //         , //      ,    ch := make(chan bool) go sleepRandomContext(ctxWithTimeout, ch) //  select      select { case &lt;-ctx.Done(): //   ,           //     ,   main   cancelFunction fmt.Println("doWorkContext: Time to return") case &lt;-ch: //   ,       fmt.Println("sleepRandomContext returned") } } func main() { //   background ctx := context.Background() //     ctxWithCancel, cancelFunction := context.WithCancel(ctx) //      //        defer func() { fmt.Println("Main Defer: canceling context") cancelFunction() }() //     - //   ,        go func() { sleepRandom("Main", nil) cancelFunction() fmt.Println("Main Sleep complete. canceling context") }() //   doWorkContext(ctxWithCancel) }</code> </pre> <br><h3 id="podvodnye-kamni">  Perangkap </h3><br><p>  Jika fungsi menggunakan konteks, pastikan pemberitahuan pembatalan ditangani dengan benar.  Misalnya, <code>exec.CommandContext</code> itu tidak menutup saluran baca sampai perintah menyelesaikan semua garpu yang dibuat oleh proses ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> ), yaitu bahwa membatalkan konteks tidak segera kembali dari fungsi jika Anda menunggu dengan cmd.Wait (), sampai semua percabangan dari perintah eksternal menyelesaikan pemrosesan. </p><br><p>  Jika Anda menggunakan batas waktu atau tenggat waktu dengan runtime maksimum, itu mungkin tidak berfungsi seperti yang diharapkan.  Dalam kasus seperti itu, lebih baik menerapkan timeout menggunakan <code>time.After</code> . </p><br><h3 id="luchshie-praktiki">  Praktik terbaik </h3><br><ol><li>  konteks. Latar belakang hanya boleh digunakan pada level tertinggi, sebagai akar dari semua konteks turunan. </li><li>  context.TODO harus digunakan ketika Anda tidak yakin apa yang harus digunakan, atau jika fungsi saat ini akan menggunakan konteks di masa depan. </li><li>  Pembatalan konteks disarankan, tetapi fungsi-fungsi ini mungkin membutuhkan waktu untuk dihapus dan keluar. </li><li>  context.Value harus digunakan sesedikit mungkin, dan tidak boleh digunakan untuk melewati parameter opsional.  Ini membuat API tidak dapat dipahami dan dapat menyebabkan kesalahan.  Nilai-nilai seperti itu harus dilewatkan sebagai argumen. </li><li>  Jangan menyimpan konteks dalam struktur, sampaikan secara eksplisit dalam fungsi, lebih baik sebagai argumen pertama. </li><li>  Jangan pernah melewatkan konteks nol sebagai argumen.  Jika ragu, gunakan TODO. </li><li>  Struktur <code>Context</code> tidak memiliki metode pembatalan, karena hanya fungsi yang memunculkan konteks yang harus membatalkannya. </li></ol><br><h3 id="ot-perevodchika">  Dari penerjemah </h3><br><p>  Di perusahaan kami, kami secara aktif menggunakan paket Konteks ketika mengembangkan aplikasi server untuk penggunaan internal.  Tetapi aplikasi seperti itu untuk fungsi normal, selain Konteks, memerlukan elemen tambahan, seperti: </p><br><ul><li>  Penebangan </li><li>  Pemrosesan sinyal untuk penghentian aplikasi, pemuatan ulang, dan pencatatan log </li><li>  Bekerja dengan file pid </li><li>  Bekerja dengan file konfigurasi </li><li>  Dan lainnya </li></ul><br><p>  Oleh karena itu, pada titik tertentu, kami memutuskan untuk merangkum semua pengalaman kami dan membuat paket tambahan yang sangat menyederhanakan aplikasi penulisan (terutama aplikasi yang memiliki API).  Kami telah memposting perkembangan kami di domain publik dan siapa pun dapat menggunakannya.  Berikut ini adalah beberapa tautan ke paket yang berguna untuk memecahkan masalah seperti itu: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nxs-go-appctx</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nxs-go-conf</a> </li></ul><br><p>  Baca juga artikel lain di blog kami: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tiga trik sederhana untuk mengurangi gambar buruh pelabuhan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cadangan stateful di Kubernetes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mencadangkan sejumlah besar proyek web heterogen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bot Telegram untuk Redmine.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara menyederhanakan hidup untuk diri sendiri dan orang</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461723/">https://habr.com/ru/post/id461723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461713/index.html">4 cara untuk menghemat cadangan cloud</a></li>
<li><a href="../id461715/index.html">Ketakutan dan Kebencian sebagai Techdir</a></li>
<li><a href="../id461717/index.html">Cara memadatkan hingga 90% penyimpanan cadangan dalam penyimpanan objek</a></li>
<li><a href="../id461719/index.html">Solusi open source untuk melaporkan otomatisasi</a></li>
<li><a href="../id461721/index.html">Metode Analisis Cluster Baru</a></li>
<li><a href="../id461725/index.html">DataGrip 2019.2: Manajemen koneksi, pencarian data, pemfilteran dalam navigasi</a></li>
<li><a href="../id461727/index.html">Solusi Cisco Small Business: Jaringan Yang Baik Tidak Perlu Mahal</a></li>
<li><a href="../id461729/index.html">Menggunakan jailbreaking untuk mengekstrak data: risiko dan konsekuensi</a></li>
<li><a href="../id461731/index.html">DPKI: Mengatasi Kerugian PKI Terpusat oleh Cara Blockchain</a></li>
<li><a href="../id461733/index.html">Belajar Bahasa Inggris: 9 idiom gaya Amerika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>