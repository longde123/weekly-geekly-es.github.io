<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔼 🎁 🔢 Wie Server miteinander verhandeln: Raft Distributed Consensus-Algorithmus 📗 💸 🏤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Cluster Hunderte und manchmal Tausende von Maschinen erreichen, stellt sich die Frage nach der Konsistenz der Serverzustände relativ zueinander. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Server miteinander verhandeln: Raft Distributed Consensus-Algorithmus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/469999/">  Wenn Cluster Hunderte und manchmal Tausende von Maschinen erreichen, stellt sich die Frage nach der Konsistenz der Serverzustände relativ zueinander.  Der Raft Distributed Consensus-Algorithmus bietet die strengste Konsistenzgarantie.  In diesem Artikel werden wir Raft aus der Sicht eines Ingenieurs betrachten und versuchen, die Fragen „Wie?“ Zu beantworten.  und "warum?"  es funktioniert. <br><br><img src="https://habrastorage.org/webt/e7/yf/fs/e7yffsk5gyqcjqxclgt9oqvnyrs.png"><br><br><a name="habracut"></a><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikelautor</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitry Pavlushin</a> (Entwickler Dodo Pizza Engineering). </blockquote><br>  Raft ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein verteilter Konsensalgorithmus</a> , der benötigt wird, damit mehrere Teilnehmer gemeinsam entscheiden können, ob und was passiert ist oder nicht. <br><br>  Die vom Raft-Cluster bereitgestellten Daten sind ein Protokoll, das aus Datensätzen besteht.  Wenn ein Benutzer die in einem Cluster gespeicherten Daten ändern möchte, versucht er, dem Protokoll mit dem folgenden Befehl einen neuen Datensatz hinzuzufügen: <br><br><img src="https://habrastorage.org/webt/vo/wu/sl/vowusleov4a4bpnob0koux_7vns.png"><br>  Diese Befehle werden von verteilten Zustandsautomaten ausgeführt.  Der Einfachheit und Klarheit halber gehen wir im Rahmen dieses Artikels davon aus, dass diese Datensätze einfach an einen Kunden weitergegeben werden, der basierend auf den aufgetretenen Ereignissen den aktuellen Status des Systems wiederherstellt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(siehe Ereignisbeschaffung)</a> . <br><br>  Um einen Konsens in Raft zu gewährleisten, wird zunächst ein Leiter ausgewählt, der für die Verwaltung des verteilten Protokolls verantwortlich ist.  Der Leiter akzeptiert Anforderungen von Clients und repliziert sie auf andere Server im Cluster.  Wenn der Anführer ausfällt, wird ein neuer Anführer im Cluster ausgewählt.  Dies ist, wenn für eine Weile in drei Sätzen.  Details folgen. <br><br><h2>  Grundbegriffe </h2><br><ol><li> <b>Serverstatus</b>  Im Raft-Cluster befindet sich jeder Server zu einem bestimmten Zeitpunkt in einem von drei Zuständen: <br><ul><li>  Leader (Leader) - verarbeitet alle Client-Anfragen, ist die Quelle der Wahrheit aller Daten im Protokoll und unterstützt das Follower-Protokoll. </li><li>  Follower (Follower) ist ein passiver Server, der nur neue Protokolleinträge des Leiters „abhört“ und alle eingehenden Anforderungen von Clients an den Leiter umleitet.  Tatsächlich handelt es sich um eine Hot-Standby-Nachbildung des Anführers. </li><li>  Kandidat (Kandidat) ist ein spezieller Status des Servers, der nur während der Auswahl eines neuen Leiters möglich ist. </li></ul><br>  Während des normalen Betriebs in einem Cluster ist nur ein Server der Anführer, der Rest sind seine Anhänger. <br><br><div class="spoiler">  <b class="spoiler_title">Über Asynchronismus</b> <div class="spoiler_text">  Es ist erwähnenswert, dass die Bedingung ein relatives Konzept ist.  Aufgrund der Tatsache, dass die Server asynchron kommunizieren, können verschiedene Server die Übergänge anderer Server zu unterschiedlichen Zeiten von einem Status in einen anderen beobachten. <br></div></div></li><li>  <b>Das Floß unterteilt die Zeit in Segmente beliebiger Länge, die als Fristen bezeichnet werden</b> .  Jeder Begriff hat eine monoton ansteigende Anzahl.  Die Amtszeit beginnt mit der Wahl eines Leiters, wenn ein oder mehrere Server Kandidaten werden.  Wenn der Kandidat die Mehrheit der Stimmen erhält, wird er bis zum Ende dieses Zeitraums führend.  Wenn die Stimmen geteilt sind und keiner der Kandidaten die Mehrheit der Stimmen erhalten kann, wird eine Zeitüberschreitung ausgelöst und dieser Zeitraum endet.  Danach beginnt eine neue Amtszeit mit neuen Kandidaten und Wahlen.  Diese Situation wird als getrennte Abstimmung bezeichnet.  Ein Beispiel wird durch den dritten Begriff in der folgenden Abbildung veranschaulicht: <br><br><img src="https://habrastorage.org/webt/uw/uj/cr/uwujcro7y3jflbpmc1y2iek_wlg.png"><br>  Die Termnummer dient als logischer Zeitstempel im Raft-Cluster.  Es hilft Servern zu bestimmen, welche Informationen momentan relevanter sind. <br><br><div class="spoiler">  <b class="spoiler_title">Regeln und Bedingungen für die Serverinteraktion</b> <div class="spoiler_text"><ul><li>  Jeder Server verfolgt die Nummer seiner aktuellen Laufzeit. </li><li>  Der Server enthält seine Ablaufnummer in jeder gesendeten Nachricht. </li><li>  Wenn der Server eine Nachricht mit einer geringeren Laufzeitnummer als seiner eigenen empfängt, ignoriert er diese Nachricht. </li><li>  Wenn der Server eine Nachricht mit einer längeren Frist als seiner eigenen empfängt, aktualisiert er seine Frist so, dass sie mit der empfangenen übereinstimmt. </li><li>  Wenn ein Kandidat oder Leiter eine Nachricht mit einer längeren Frist als seiner eigenen erhält, versteht er, dass andere Server bereits eine neue Frist eingeleitet haben und seine Frist nicht mehr relevant ist.  Daher wechselt es zusätzlich zur Aktualisierung seiner Nummer vom aktuellen Status in den Status "Follower". </li></ul></div></div><br></li><li>  <b>Serverkommunikation.</b>  Die Server in Raft interagieren, indem sie Anforderungen und Antworten austauschen.  Der grundlegende Algorithmus verwendet nur zwei Arten von Aufrufen: <br><br><ul><li>  <b>RequestVote wird</b> von Kandidaten während der Wahlen verwendet.  Die Anfrage enthält die Termnummer des Kandidaten und Metadaten zum Protokoll des Kandidaten, die nachstehend ausführlicher erläutert werden.  Die Antwort enthält die Deadline-Nummer des antwortenden Servers und den Wert "true", wenn der Server für den Kandidaten stimmt.  False, wenn der Server gegen den Kandidaten stimmt. </li><li>  <b>AppendEntries wird</b> vom Leader für die Protokollreplikation sowie für den Heartbeat-Mechanismus verwendet.  Die Anforderung enthält die Termnummer des Leiters, eine Sammlung von Einträgen, die dem Protokoll hinzugefügt werden müssen (oder eine leere Sammlung im Falle eines Herzschlags), einige Metadaten zum Protokoll des Leiters, die im Folgenden ebenfalls ausführlicher erläutert werden.  Die Antwort enthält die Nummer des Follower-Terms und den Wert "true", wenn der Follower erfolgreich Einträge zu seinem Protokoll hinzugefügt hat.  "False", wenn das Hinzufügen von Protokolleinträgen fehlgeschlagen ist. </li></ul></li></ol><br><h2>  Arbeitsalgorithmus </h2><br><h4>  1. Wählen Sie einen Führer </h4><br>  Um festzustellen, wann es Zeit ist, eine Neuwahl zu beginnen, setzt Raft auf Herzschlag.  Der Follower bleibt der Follower, bis er Nachrichten vom aktuellen Anführer oder Kandidaten erhält.  Der Leader sendet regelmäßig Heartbeat an alle anderen Server. <br><br>  Wenn der Follower einige Zeit keine Nachrichten erhält, geht er ganz natürlich davon aus, dass der Anführer tot ist, was bedeutet, dass es Zeit ist, die Initiative in seine Hände zu nehmen.  Zu diesem Zeitpunkt leitet der frühere Anhänger die Wahl ein. <br><br>  Um die Wahl einzuleiten, erhöht der Follower seine Laufzeitnummer, wechselt in den Status "Kandidat", stimmt für sich selbst und sendet dann die Anforderung "RequestVote" an alle anderen Server.  Danach wartet der Kandidat auf eines von drei Ereignissen: <br><br><ol><li>  <b>Der Kandidat erhält die Mehrheit der Stimmen (einschließlich seiner eigenen) und gewinnt die Wahl.</b>  Jeder Server stimmt nur einmal in jeder Amtszeit ab, damit der erste Kandidat erreicht wird (mit einigen Ausnahmen, die unten erläutert werden). Daher kann nur ein Kandidat die Mehrheit der Stimmen in einer bestimmten Amtszeit erhalten.  Der Gewinner-Server wird zum Leader, sendet Heartbeat und bedient Client-Anforderungen an den Cluster. </li><li>  <b>Der Kandidat erhält eine Nachricht vom aktuellen Leiter der aktuellen Amtszeit oder von einem Server mit einer älteren Amtszeit</b> .  In diesem Fall versteht der Kandidat, dass die Wahlen, an denen er teilnimmt, nicht mehr relevant sind.  Er hat keine andere Wahl, als einen neuen Führer / eine neue Amtszeit zu erkennen und in einen Zustand des Nachfolgers zu gelangen. </li><li>  <b>Ein Kandidat erhält für eine bestimmte Zeit keine Mehrheit der Stimmen.</b>  Dies kann passieren, wenn mehrere Anhänger Kandidaten werden und die Stimmen unter ihnen aufgeteilt werden, so dass nicht einer die Mehrheit erhält.  In diesem Fall endet die Amtszeit ohne Führer, und der Kandidat beginnt sofort mit Neuwahlen für die nächste Amtszeit. </li></ol><br><h4>  2. Wir replizieren Protokolle </h4><br>  Wenn ein Leiter ausgewählt wird, ist er für die Verwaltung des verteilten Protokolls verantwortlich.  Der Leiter akzeptiert Anfragen von Kunden, die einige Teams enthalten.  Der Anführer fügt in sein Protokoll einen neuen Datensatz ein, der den Befehl enthält, und sendet dann "AppendEntries" an alle Follower, um den Datensatz mit dem neuen Datensatz zu replizieren. <br><br>  Wenn der Datensatz auf den meisten Servern erfolgreich repliziert wurde, betrachtet der Leiter den Datensatz als geschlossen und antwortet dem Client.  Der Anführer verfolgt, welcher Datensatz der letzte ist.  Es sendet die Nummer dieses Datensatzes an AppendEntries (einschließlich Heartbeat), damit Follower den Datensatz für sich selbst festschreiben können. <br><br>  Falls der Anführer einige Follower nicht erreichen kann, wird er die AppendEntries bis ins Unendliche zurückverfolgen.  Das folgende Bild zeigt, wie die Protokolle im Raft-Cluster organisiert sind: <br><br><img src="https://habrastorage.org/webt/s3/2l/-z/s32l-zuwjn3u0eoz83j8pysn_uc.png"><br><br>  Jedes Feld ist ein Eintrag im Protokoll.  Jeder Datensatz speichert einen Befehl, z. B. x ← 3 weist der Taste x den Wert 3 zu.  Der Datensatz speichert auch die Nummer des Begriffs, in dem er generiert wurde.  Auf dem Bild wird dies durch eine Zahl am oberen Rand des Quadrats angezeigt.  Die Farbanzeige der Quadrate bedeutet auch die Termnummer.  Jeder Datensatz hat eine Seriennummer (Protokollindex). <br><br><h4>  3. Wir garantieren die Zuverlässigkeit des Algorithmus </h4><br>  Bisher ist nach unseren Untersuchungen nicht klar, wie Raft zumindest einige Garantien geben kann.  Der Algorithmus bietet jedoch eine Reihe von Eigenschaften, die zusammen die Zuverlässigkeit seiner Ausführung gewährleisten: <br><br><ul><li>  <b>Wahlsicherheit</b> : Innerhalb einer Amtszeit kann nicht mehr als ein Führer ausgewählt werden.  Diese Eigenschaft ergibt sich aus der Tatsache, dass jeder Server innerhalb jeder Amtszeit nur einmal abstimmt und für die Bildung eines Leiters eine Mehrheit der Stimmen erforderlich ist </li><li>  <b>Nur Anführer anhängen</b> : Der Anführer überschreibt oder löscht niemals, verschiebt keine Einträge in seinem Protokoll, fügt nur neue Einträge hinzu.  Diese Eigenschaft folgt direkt aus der Beschreibung des Algorithmus. Die einzige Operation, die ein Leiter mit seinem Protokoll ausführen kann, besteht darin, am Ende Einträge hinzuzufügen.  Und alle. </li><li>  <b>Protokollabgleich:</b> Wenn die Protokolle von zwei Servern einen Eintrag mit demselben Index und derselben Ablaufnummer enthalten, sind beide Protokolle bis einschließlich dieses Datensatzes identisch. <br><br><div class="spoiler">  <b class="spoiler_title">Beweis mit mathematischer Induktion und Bildern</b> <div class="spoiler_text">  Die mathematische Induktion ist ein Beweis dafür, wann der erste Schritt darin besteht, eine Aussage für einen einfachen Fall zu beweisen.  Im zweiten Schritt akzeptieren wir die Aussage wahr für einen Fall X. Auf dieser Grundlage versuchen wir, die Aussage für einen benachbarten Fall X + 1 zu beweisen.  Zusammen helfen diese beiden Schritte, die Aussage für alle Fälle zu beweisen. <br><br>  In unserer Situation sind leere Protokolle ein einfacher Fall.  Es gibt keine Aufzeichnungen, daher gibt es nichts, was die Eigenschaft verletzen könnte. <br><br>  Nehmen wir nun an, dass die Protokolle einige Einträge enthalten, die unserer Eigenschaft entsprechen.  Raft verfügt über einen Mechanismus, der verhindert, dass die Eigenschaft beschädigt wird, wenn sich ein Protokoll ändert.  Dieser Mechanismus wird als <b>Konsistenzprüfung bezeichnet</b> .  Schauen wir uns die Beispiele sofort an. <br><br>  <b>Gutes Beispiel</b> .  Es gibt zum Beispiel einen Führer der 4. Amtszeit, es gibt einen Anhänger.  Beide haben übereinstimmende Protokolle aus drei Einträgen. <br><br><img src="https://habrastorage.org/webt/ob/kl/qj/obklqjfsspdfwyxwmpodpyvc-ia.png"><br><br>  Eine Anfrage des Kunden kommt an den Leiter, er fügt seinem Protokoll einen Eintrag hinzu. <br><br><img src="https://habrastorage.org/webt/e9/d0/_x/e9d0_xsxyddboyfr9yjjdfake8m.png"><br><br>  Der Anführer sendet AppendEntries an den Follower.  Zusätzlich zu dem am häufigsten hinzugefügten Datensatz gibt der Leiter in der Anforderung an, dass der Datensatz bei Index 4 hinzugefügt werden muss, und bei Index 3 davor muss ein Datensatz aus Term 2 vorhanden sein. <br><br><img src="https://habrastorage.org/webt/eo/7l/x0/eo7lx0m8xul1tmtzqfkk4cgjdic.png"><br><br>  Der Protokolleintrag bei Index 3 im Follower-Protokoll stimmt mit dem in der Anforderung angegebenen überein, sodass der Follower den Eintrag zu seinem Protokoll hinzufügt und dem Leiter mit Erfolg antwortet.  Das Ende. <br><br><img src="https://habrastorage.org/webt/ef/e8/kg/efe8kg2uspvnflbnx6mnkx5-1ko.png"><br><br>  <b>Auch ein gutes Beispiel, aber mit einem tragischen Anfang.</b>  Jetzt unterscheidet sich das Protokoll des Followers vom Protokoll des aktuellen Anführers. <br><br><img src="https://habrastorage.org/webt/t8/5d/ae/t85daek6x0n9spztxu-jeu5qee8.png"><br><br>  Wenn der Leiter eine Anforderung zum Hinzufügen eines Eintrags zum Protokoll erhält, sendet er dieselben AppendEntries wie im vorherigen Beispiel. <br><br><img src="https://habrastorage.org/webt/ka/q5/gw/kaq5gw5c0ezpdflgrdinqmpbmmk.png"><br><br>  Diesmal schlägt der Follower jedoch fehl, da der Follower nicht mit dem vorherigen Datensatz übereinstimmt. <br><br><img src="https://habrastorage.org/webt/41/wk/zf/41wkzfixq1dr2x8artbwph2s3jw.png"><br><br>  Was macht der Anführer in diesem Fall?  Der Anführer rollt einfach ein wenig zurück und versucht, dem Follower den Datensatz zuzuführen, den er selbst für Index 3 hält. Er nimmt auch den vorherigen Datensatz in die Anfrage auf. <br><br><img src="https://habrastorage.org/webt/y_/gw/br/y_gwbrjzohvl83zh-e2hploan5m.png"><br><br>  Jetzt antwortet der Follower mit Erfolg und überschreibt die Einträge in seinem Protokoll ab Index 3. <br><br><img src="https://habrastorage.org/webt/8l/oa/wp/8loawpe9iqskomaw0p7zbwek9f8.png"><br><br>  Das Protokoll des Followers kann nach Belieben vom Protokoll des Anführers abweichen.  Es sind möglicherweise nicht genügend Einträge enthalten, möglicherweise sind zusätzliche Einträge enthalten.  In jedem Fall stellt die Konsistenzprüfung sicher, dass die Protokolle der Follower früher oder später mit dem Protokoll des Anführers übereinstimmen. <br></div></div><br></li><li>  <b>Vollständigkeit des Leiters</b> : Wenn der Protokolleintrag zu einem bestimmten Zeitpunkt festgeschrieben wird, enthalten die Protokolle der Leiter aller nachfolgenden Perioden diesen Datensatz.  Diese Eigenschaft bietet uns Haltbarkeitsgarantien. <br><br><div class="spoiler">  <b class="spoiler_title">Beweis und Bilder</b> <div class="spoiler_text">  Stellen Sie sich folgende Situation vor: Drei Server in einem Cluster.  Server S1 ist der Anführer der aktuellen ersten Amtszeit.  Alle Server haben drei Protokolleinträge. <br><br><img src="https://habrastorage.org/webt/g6/c9/zb/g6c9zbx5fsewp_4nn0komxcnikm.png"><br><br>  Leader S1 empfängt eine Anfrage vom Client, fügt seinem Protokoll einen neuen Datensatz hinzu und sendet AppendEntries an andere S2- und S3-Server. <br><br><img src="https://habrastorage.org/webt/rz/ki/gf/rzkigfvgmygzxg4qbwy9tfgf914.png"><br><br>  Die Aufzeichnung erreicht erfolgreich S2, aber das Netzwerk zwischen S1 und S3 blinkt und die Anforderung geht verloren.  Da S1 weiß, dass der Datensatz auf zwei der drei Server vorhanden ist, kann es feststellen, dass der Datensatz festgeschrieben ist, und erfolgreich auf den Client reagieren. <br><br>  S1 wird auch erneut versuchen, einen Eintrag zu S3 hinzuzufügen, bis dies erfolgreich ist.  Aber was passiert, wenn S1 ausfällt und herunterfährt?  Was passiert außerdem, wenn S3 als erster das Warten satt hat und ein Kandidat wird?  S2 wird dafür stimmen, S3 wird der Anführer der zweiten Amtszeit und bei der nächsten Aufforderung, einen Datensatz hinzuzufügen, wird S3 unseren aufgezeichneten Datensatz überschreiben? <br><br><img src="https://habrastorage.org/webt/_g/ij/l3/_gijl3pklfn6g5xme0ta7-svaus.png"><br><br>  Tatsächlich kann diese Situation im Raft-Cluster nicht auftreten.  Der Haken dabei ist, dass S2 nicht für S3 stimmen würde.  Warum?  Weil das S3-Serverprotokoll zum Zeitpunkt der Abstimmung weniger relevant ist als das S2-Serverprotokoll.  Dieser Mechanismus wird als <b>Wahlbeschränkung bezeichnet.</b> Der Server wählt nur dann für einen anderen Server, wenn das Protokoll des Kandidaten nicht weniger relevant ist als das Protokoll des Wählers. <br><br>  Raft vergleicht die Relevanz von Protokollen auf zwei Arten: <br><br><ul><li>  Nummer des letzten Aufnahmedatums </li><li>  Protokolllänge </li></ul><br>  Die Kandidaten nehmen diese beiden Parameter in die RequestVote-Anfrage auf, damit die Follower die Relevanz ihres Protokolls mit dem Protokoll des Kandidaten vergleichen können. <br><br>  "Am wichtigsten" ist das Protokoll, in dem der letzte Datensatz älter ist. <br><br><img src="https://habrastorage.org/webt/7o/2a/-v/7o2a-vpncoa6z4qwmn-xdgckh1m.png"><br><br>  Wenn die Nummern des Begriffs der letzten Einträge übereinstimmen, ist das Hauptprotokoll das längere Protokoll. <br><br><img src="https://habrastorage.org/webt/qf/kx/nk/qfkxnk-qv4py6t6lvw3i8wuphu4.png"><br><br>  Wenn beide übereinstimmen, sind die Protokolle gleichermaßen relevant und, wie aus der vorherigen Eigenschaft hervorgeht, absolut identisch. <br><br><img src="https://habrastorage.org/webt/hp/ej/x8/hpejx8hkcwkm-fjs7qs98gzn8pc.png"><br><br>  Es stellt sich heraus, dass das Serverprotokoll, in dem sich ein gesicherter Datensatz befindet, immer relevanter ist als das Protokoll, in dem es nicht vorhanden ist.  Und ein Server mit einem gesicherten Datensatz stimmt nicht für einen Server, der diesen nicht hat.  Und da auf den meisten Servern ein Datensatz aufgezeichnet ist, kann ein Kandidat ohne diesen Datensatz nicht die Mehrheit der Stimmen erhalten und führend werden, um diesen Datensatz von anderen Servern zu entfernen. <br></div></div><br></li><li>  <b>Sicherheit</b> von Zustandsautomaten: Diese Eigenschaft wird im Original in Bezug auf verteilte Zustandsautomaten beschrieben. In unserem Artikel kann diese Eigenschaft wie folgt beschrieben werden: Wenn ein Server einen Datensatz mit einem bestimmten Index festschreibt, schreibt kein anderer Server einen anderen Datensatz für diesen Index fest. <br><br>  Diese Eigenschaft folgt aus der Vergangenheit.  Wenn der Follower einen Datensatz bei Index N festlegt, ist sein Protokoll identisch mit dem Protokoll des Anführers bis einschließlich N.  Die Leader-Vollständigkeitseigenschaft garantiert, dass alle nachfolgenden Leader auch diesen gesicherten Datensatz bei Index N enthalten. Dies bedeutet, dass Follower, die in nachfolgenden Perioden einen Datensatz bei Index N festschreiben, denselben Wert festschreiben. <br></li></ul><br><h2>  Links zu Materialien für weitere Studien </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Floß-Konsens-Algorithmus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auf der Suche nach einem verständlichen Konsensalgorithmus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konsens: Brücke zwischen Theorie und Praxis</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schrödinger Katze ohne Box: das Problem des Konsenses in verteilten Systemen</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469999/">https://habr.com/ru/post/de469999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469985/index.html">Beschleunigen eines Programms für einen synthetisierten Redd-Prozessor ohne Optimierung: Ersetzen einer Uhr</a></li>
<li><a href="../de469987/index.html">Top 20 Marktentwicklungsunternehmen aus aller Welt</a></li>
<li><a href="../de469991/index.html">Wir bearbeiten Bestellungen aus dem Online-Shop mit RabbitMQ und TypeScript</a></li>
<li><a href="../de469995/index.html">Python SAX-Parser gegen Python DOM-Parser. Parsim FIAS-Häuser</a></li>
<li><a href="../de469997/index.html">Welche Schlagzeilen am ehesten Aufmerksamkeit erregen oder HabraHabr-Analyse</a></li>
<li><a href="../de470003/index.html">F # 1: Hallo Welt</a></li>
<li><a href="../de470005/index.html">Fernsteuerung des Computers über einen Browser</a></li>
<li><a href="../de470009/index.html">Sortieren Sie Fotos nach Daten aus EXIF ​​+ PHP</a></li>
<li><a href="../de470011/index.html">Interaktives Labor für Thermodynamik als effektives Mittel für das Simulationstraining</a></li>
<li><a href="../de470013/index.html">Wie ein russischer Milliardär, der nach Außerirdischen sucht, hilft, eines der größten Geheimnisse des Universums aufzudecken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>