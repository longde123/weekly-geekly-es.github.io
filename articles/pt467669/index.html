<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèø üßí üëã Assista-me na √≠ntegra: tire o m√°ximo proveito do v√≠deo ao vivo em plataformas m√≥veis üññüèø üë©‚Äç‚öïÔ∏è üìè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A maneira mais f√°cil de reproduzir v√≠deo em um dispositivo m√≥vel √© abrir o link com um player existente no sistema, mas isso nem sempre √© eficaz. 

 V...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Assista-me na √≠ntegra: tire o m√°ximo proveito do v√≠deo ao vivo em plataformas m√≥veis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/467669/"><img src="https://habrastorage.org/webt/3z/wx/89/3zwx89x0wbx0euzwj3a_f8vttwo.jpeg"><br><br>  A maneira mais f√°cil de reproduzir v√≠deo em um dispositivo m√≥vel √© abrir o link com um player existente no sistema, mas isso nem sempre √© eficaz. <br><br>  Voc√™ pode usar o ExoPlayer e otimiz√°-lo, ou pode at√© escrever seu pr√≥prio player de v√≠deo usando apenas codecs e soquetes.  O artigo falar√° sobre o trabalho de streaming e reprodu√ß√£o de v√≠deo e como reduzir o atraso no in√≠cio do v√≠deo, reduzir o tempo de resposta entre a serpentina e o espectador e otimizar o consumo de energia e a carga de ferro. <br><br>  Analisaremos isso usando aplicativos espec√≠ficos como exemplo: cliente m√≥vel Odnoklassniki (onde os v√≠deos s√£o reproduzidos) e OK Live (onde as transmiss√µes s√£o transmitidas do telefone para 1080p).  N√£o haver√° masterclasses sobre como reproduzir um v√≠deo por refer√™ncia, com exemplos de c√≥digo.  A hist√≥ria se concentrar√° na apar√™ncia do v√≠deo por dentro e em como, conhecendo a arquitetura geral dos players de v√≠deo e do streaming de v√≠deo, voc√™ pode entender qualquer sistema e torn√°-lo melhor. <br><br>  O material √© baseado na transcri√ß√£o do relat√≥rio de <b>Alexander Tobol</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@alatobol</a></b> ) e <b>Ivan Grigoriev</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@ivan_a</a></b> ) da confer√™ncia <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mobius</a></b> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/e1JYFRwHzkQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><h2>  Entrada </h2><br>  Para come√ßar - alguns n√∫meros sobre o v√≠deo em Odnoklassniki. <br><br>  O pico m√©dio do tr√°fego di√°rio de VOD (v√≠deo sob demanda) √© de mais de um ter√ßo e meio por segundo e para transmiss√µes ao vivo - mais de tr√™s terabits por segundo. <br><br>  Agora, em OK, existem mais de 870 milh√µes de visualiza√ß√µes de v√≠deo por dia, mais da metade das quais s√£o de dispositivos m√≥veis. <br><br><img src="https://habrastorage.org/webt/xt/nl/ij/xtnlijaizuntzzpkihtkpi-juws.jpeg"><br><br>  Se voc√™ observar o hist√≥rico do streaming, um v√≠deo para celular apareceu no YouTube em 2007.  Entramos nesse trem mais tarde, mas em 2014-2015 j√° t√≠nhamos reprodu√ß√£o de v√≠deo em 4K em dispositivos m√≥veis e, nos √∫ltimos anos, desenvolvemos ativamente nossos players.  Sobre isso e a conversa continuar√°. <br><br>  A segunda tend√™ncia que surgiu com o Periscope em 2015 foi a transmiss√£o por telefone.  Lan√ßamos nosso aplicativo OK Live, que permite transmitir at√© v√≠deo Full HD em redes m√≥veis.  Na segunda metade do material, tamb√©m falaremos sobre streaming. <br><br>  N√£o vamos nos concentrar na API para trabalhar com v√≠deo, mas agora mergulhe profundamente e tente descobrir o que est√° acontecendo l√° dentro. <br><br><img src="https://habrastorage.org/webt/4d/ne/-v/4dne-vlspxhbv3rm3wxixirrc8o.jpeg"><br><br>  Quando voc√™ grava um v√≠deo em uma c√¢mera, ele chega ao codec, de l√° para o soquete e depois para o servidor (independentemente de ser VOD ou Live).  E ent√£o o servidor na ordem inversa o distribui para o p√∫blico. <br><br>  Vamos come√ßar com o KPI player.  O que queremos dele? <br><br><ul><li>  Primeiro quadro r√°pido.  Os usu√°rios n√£o querem esperar o in√≠cio da reprodu√ß√£o. </li><li>  Falta de buffer.  Ningu√©m gosta de correr para um torso. </li><li>  Alta qualidade.  Quando ainda n√£o havia quase nenhum conte√∫do em 4K, j√° fizemos o suporte ao 4K "para o crescimento": se voc√™ adiar o player e descobrir o desempenho, o 1080p ser√° reproduzido perfeitamente, mesmo em dispositivos fracos. </li><li>  Requisitos de UX.  Precisamos que o v√≠deo seja reproduzido na fita durante a rolagem e, para a fita, precisamos buscar previamente o v√≠deo. </li></ul><br><br>  Existem muitos problemas dessa maneira.  O fluxo de v√≠deo em 4K √© grande e trabalhamos em dispositivos m√≥veis onde h√° problemas com a rede, h√° v√°rios recursos de formatos de v√≠deo e cont√™ineres em diferentes dispositivos, e os pr√≥prios dispositivos tamb√©m podem se tornar um problema. <br><br>  Onde voc√™ acha que o v√≠deo come√ßa mais r√°pido, no iOS ou Android? <br><br>  De fato, qualquer resposta est√° correta: depende do que, onde e como jogar.  Se tomarmos uma regi√£o da R√∫ssia com uma rede n√£o t√£o boa, veremos que o AVPlayer come√ßa em cerca de 800 milissegundos.  Mas com a mesma rede, o ExoPlayer no Android, reproduzindo um formato diferente, o iniciar√° em 660 ms.  E se voc√™ criar seu player no iOS, ele poder√° ser executado ainda mais r√°pido. <br><br><img src="https://habrastorage.org/webt/eb/jl/ao/ebjlao75uhegqjpd6mn-nfjuakk.jpeg"><br><br>  H√° uma nuance em que medimos a m√©dia dos usu√°rios e a pot√™ncia m√©dia dos dispositivos iOS √© maior que no Android. <br><br>  A primeira parte do material ser√° te√≥rica: aprenderemos o que √© o v√≠deo e como √© a arquitetura de qualquer player ao vivo.  E na segunda parte, vamos comparar os jogadores e falar sobre quando escrever o seu. <br><br><h2>  Parte um </h2><br><h3>  O que √© v√≠deo </h3><br>  Vamos come√ßar com o mais b√°sico.  O v√≠deo tem 60 ou 24 fotos por segundo. <br><br>  Obviamente, armazenar isso com um conjunto completo de fotos √© bastante caro.  Portanto, eles s√£o armazenados desta maneira: alguns quadros s√£o chamados de quadros de refer√™ncia (quadros I), enquanto outros (quadros B e quadros P) s√£o chamados de "diffs".  Na verdade, voc√™ tem um arquivo jpg e um conjunto espec√≠fico de altera√ß√µes. <br><br><img src="https://habrastorage.org/webt/lf/rk/nt/lfrknthpx0phqp5u7psr0if5j78.jpeg"><br><br>  Existe tamb√©m o conceito de GOP (grupo de imagens) - este √© um conjunto independente de quadros, que come√ßa com um quadro de refer√™ncia e continua com um conjunto de diferen√ßas.  Pode ser reproduzido independentemente, desembalado e assim por diante.  Ao mesmo tempo, se voc√™ perdeu um opornik no grupo, os quadros restantes n√£o s√£o mais relevantes. <br><br>  Existem muitos algoritmos de codifica√ß√£o, matrizes de transforma√ß√£o, pesquisa de movimento e similares - √© nisso que os codecs diferem. <br><br><h3>  Desempenho do codec </h3><br><br><img src="https://habrastorage.org/webt/q7/mj/ts/q7mjtslvjdqlperjccv0etipmgk.jpeg"><br><br>  O H.264 cl√°ssico √© conhecido desde 2003 e se desenvolveu bem.  Tomaremos sua efic√°cia como base.  Ele trabalha e toca em todos os lugares.  Possui suporte de hardware para CPU / GPU (ambos no iOS, no Android).  Isso significa que existe algum tipo de coprocessador especial que pode codific√°-lo ou conjuntos de instru√ß√µes internos que permitem fazer isso rapidamente.  Em m√©dia, o suporte de hardware oferece desempenho at√© 10 vezes mais r√°pido e economiza a bateria. <br><br>  Em 2010, o VP8 do Google apareceu.  N√£o difere em efici√™ncia do H.264.  Bem, na verdade a efic√°cia do codec √© uma coisa muito controversa.  Na testa, √© medida como a propor√ß√£o do v√≠deo original para o compactado, mas √© claro que existem diferentes artefatos de v√≠deo.  Portanto, fornecemos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> para compara√ß√µes detalhadas de codecs da Universidade Estadual de Moscou.  Mas aqui nos restringimos ao fato de que o VP8 est√° focado em uma organiza√ß√£o de software, voc√™ pode arrast√°-lo para qualquer lugar e geralmente √© usado como um substituto se n√£o houver suporte H.264 nativo. <br><br>  Em 2013, uma nova gera√ß√£o de codecs apareceu - H.265 (HEVC) e VP9.  O codec H.265 aumenta em 50% a efici√™ncia, mas no v√≠deo do Android eles n√£o podem ser codificados, o decodificador apareceu apenas no Android 5.0 ou superior.  Mas no iOS h√° suporte. <br><br>  Existe uma alternativa ao H.265 - VP9.  Mesmo assim, mas com suporte do Google.  Bem, V9 √© o YouTube e H.265 √© Netflix.  Portanto, cada um tem suas pr√≥prias peculiaridades: um n√£o funcionar√° no iOS, o outro ter√° problemas no Android.  No final, muitos permanecem no H.264. <br><br>  No futuro, prometemos o codec AV1, ele j√° possui uma implementa√ß√£o de software e sua efici√™ncia √© 35% maior que a dos codecs de 2013.  Agora dispon√≠vel no Chrome e Firefox, e em 2020 o Google promete suporte de hardware - acho que, provavelmente, todos iremos mudar para ele. <br><br>  Finalmente, eles anunciaram recentemente o codec H.266 / JVEC, dizendo que tudo ser√° melhor e mais r√°pido. <br><br>  O padr√£o principal: quanto maior a efici√™ncia do codec, mais recursos de computa√ß√£o s√£o necess√°rios para os dispositivos. <br><br>  Em geral, por padr√£o, todos usam o H.264 e, em dispositivos espec√≠ficos, pode ser complicado. <br><br><h3>  Qualidade, resolu√ß√£o e taxa de bits </h3><br>  Em 2019, voc√™ n√£o surpreender√° ningu√©m com qualidade adaptativa: os usu√°rios enviam ou transmitem v√≠deos em uma qualidade e cortamos uma linha de diferentes qualidades e enviamos as mais adequadas aos dispositivos. <br><br>  Nesse caso, √© necess√°rio que a resolu√ß√£o do v√≠deo se correlacione com a taxa de bits.  Se a resolu√ß√£o for dobrada, a taxa de bits tamb√©m dever√° dobrar: <br><br><img src="https://habrastorage.org/webt/vg/f0/y_/vgf0y_ve9h6r_0r-bvioww1qivw.jpeg"><br><br>  Obviamente, se voc√™ compactar uma resolu√ß√£o grande com uma taxa de bits baixa ou vice-versa, haver√° artefatos ou grava√ß√£o in√∫til da taxa de bits. <br><br>  Como a taxa de bits do v√≠deo codificado se compara √† quantidade original de informa√ß√µes?  Em uma tela 4K, podemos reproduzir quase 6 Gb / s de informa√ß√£o (se voc√™ contar todos os pixels e sua frequ√™ncia em 60 quadros por segundo), enquanto a taxa de bits do codec pode ser de 50 Mb / s.  Ou seja, o codec comprime o v√≠deo at√© 100 vezes. <br><br><h3>  Tecnologia de entrega </h3><br>  Voc√™ tem √°udio e v√≠deo compactados com alguns codecs.  Se voc√™ o mantiver em casa, poder√° adicionar todo o √°udio e v√≠deo adicionando um pequeno √≠ndice que indica a partir de que segundo o √°udio e o v√≠deo s√£o iniciados.  Mas o v√≠deo n√£o pode ser entregue ao telefone e, para transmitir on-line para o espectador, existem duas classes principais de protocolos: streaming e segmento. <br><br><img src="https://habrastorage.org/webt/yd/mn/bp/ydmnbpqbfq8p19nbq2wmdx4ktzi.jpeg"><br><br>  O protocolo de streaming implica que voc√™ tem algum tipo de estado no servidor, o cliente tamb√©m e envia dados.  O servidor pode ajustar, por exemplo, a qualidade.  Muitas vezes, essa √© uma conex√£o UDP. <br><br>  Tais protocolos s√£o altamente complexos para o servidor e dif√≠ceis de entregar.  Para tradu√ß√µes muito carregadas, usamos protocolos segmentados que funcionam sobre HTTP, podem ser armazenados em cache pelo nginx e CDN e s√£o muito mais f√°ceis de distribuir.  E o servidor n√£o √© respons√°vel por nada e, nesse caso, sem estado. <br><br>  Como √© a entrega por segmento: cortamos o v√≠deo existente em segmentos, acompanhamos-os com um cabe√ßalho para √°udio e v√≠deo, MPEG-TS e MP4 como exemplo de transporte.  No telefone, fornecemos um manifesto com informa√ß√µes sobre onde e qual a qualidade do segmento, e esse manifesto pode ser atualizado periodicamente. <br><br>  Historicamente, a Apple entrega atrav√©s do HLS e o Android atrav√©s do DASH.  Vamos ver como eles diferem. <br><br>  Vamos come√ßar com o HLS mais antigo, que possui um manifesto que descreve todas as qualidades dispon√≠veis - baixa, m√©dia, alta e assim por diante.  Existem taxas de bits dessas qualidades para que o jogador possa escolher imediatamente a correta.  Ele escolhe a qualidade e obt√©m um manifesto aninhado com uma lista de links para segmentos.  A dura√ß√£o desses segmentos tamb√©m √© indicada. <br><br><img src="https://habrastorage.org/webt/v5/xw/1r/v5xw1rnetgtu4wzdg7zmxsy2dqa.jpeg"><br><br>  H√° uma caracter√≠stica interessante aqui: para come√ßar a reproduzir o primeiro quadro, voc√™ ter√° que fazer duas viagens adicionais de ida e volta.  A primeira solicita√ß√£o, voc√™ obt√©m o manifesto principal, o segundo aninhado, e s√≥ ent√£o acessa os dados, o que n√£o √© muito bom. <br><br><img src="https://habrastorage.org/webt/hy/2u/af/hy2uafqbmeujkyq9ishlykfqppc.jpeg"><br><br>  A segunda dificuldade: o HLS foi projetado para funcionar na Internet via HTTP, mas o MPEG-2 Transport Stream herdado foi escolhido como um cont√™iner para dados de v√≠deo, desenvolvido para finalidades completamente diferentes: transmitir um sinal de um sat√©lite em canais ruidosos.  Como resultado, obtemos cabe√ßalhos adicionais, que no caso do HLS s√£o completamente in√∫teis e apenas acrescentam sobrecarga. <br><br><img src="https://habrastorage.org/webt/tm/ks/hs/tmkshszo_5atstyrbip1r64qs84.jpeg"><br><br>  Adicione sobrecarga de rede e a complexidade da an√°lise: se voc√™ tentar reproduzir 4K no DASH e HLS no Chrome, sentir√° a diferen√ßa quando o computador "decolar" com pacotes HLS. <br><br>  A Apple est√° tentando resolver isso.  Em 2016, eles anunciaram a possibilidade de usar o MPEG-4 fragmentado, havia algum suporte para o DASH no HLS, mas o RTT extra e seus recursos n√£o desapareceram. <br><br><img src="https://habrastorage.org/webt/xa/zy/ai/xazyaila94udoix88ia0vvea0yq.jpeg"><br><br>  O DASH parece um pouco mais simples: voc√™ tem um manifesto com todas as qualidades internas e cada qualidade √© um conjunto de segmentos.  Voc√™ pode reproduzir um segmento para reproduzir em uma qualidade e entender que a velocidade aumentou, do pr√≥ximo segmento para o outro.  Todos os segmentos sempre come√ßam com quadros de refer√™ncia, permitindo a troca. <br><br>  Aqui est√° um pequeno prato sobre o que escolher: <br><br><img src="https://habrastorage.org/webt/mq/n1/pk/mqn1pkjswjel-yxavreufexrrjm.jpeg"><br><br>  No HLS, os codecs de v√≠deo historicamente suportados s√£o apenas H.264; no MPEG-DASH voc√™ pode empurrar qualquer um.  O principal problema do HLS √© uma viagem de ida e volta extra no in√≠cio, que funciona bem no iOS e no Android com 4.0.  E o DASH √© suportado principalmente pelo Google (Chrome e Android) e n√£o pode ser reproduzido no iOS. <br><br><h3>  Arquitetura do jogador </h3><br>  Classificamos o v√≠deo mais ou menos, agora vamos ver como √© qualquer player. <br><br><img src="https://habrastorage.org/webt/li/uj/ra/liujrart9xshdsg8d1ffcgztm6g.jpeg"><br><br>  Vamos come√ßar com a parte da rede: ao iniciar um v√≠deo, o player segue o manifesto, de alguma forma seleciona a qualidade, depois segue o segmento, baixa-o, depois decodifica os quadros, entende que h√° quadros suficientes no buffer para reprodu√ß√£o e inicia a reprodu√ß√£o. <br><br>  A arquitetura geral do jogador: <br><br><img src="https://habrastorage.org/webt/-z/n2/1q/-zn21q-9ufwdrtdwgongpnk9bcg.jpeg"><br><br>  H√° uma parte da rede, um soquete, de onde v√™m os dados. <br><br>  Depois disso - um desmultiplexador ou algum tipo de coisa que obt√©m fluxos de √°udio e v√≠deo de um transporte (HLS / DASH).  Ela os envia para os codecs apropriados. <br><br>  Os codecs decodificam v√≠deo e √°udio e, em seguida, o mais interessante acontece: eles precisam ser sincronizados para que seu v√≠deo e √°udio sejam reproduzidos simultaneamente.  Existem v√°rios mecanismos baseados em timestamps para isso. <br><br>  Ent√£o voc√™ precisa renderiz√°-lo em algum lugar - em Textura, Superf√≠cie, GL ou Metal, em qualquer lugar. <br><br>  E na entrada existe um controle de carga, que carrega os dados e controla o buffer. <br><br>  Como √© o controle de carga em todos os players?  H√° uma quantidade de dados que precisa ser baixada.  O jogador espera at√© que seja baixado, come√ßa a tocar e fazemos o download.  Temos o limite m√°ximo de buffer, ao atingir o qual o download √© interrompido.  Depois disso, durante a reprodu√ß√£o, a quantidade de dados no buffer cai - e h√° uma borda m√≠nima na qual ele come√ßa a carregar.  Ent√£o, tudo isso tamb√©m vive: <br><br><img src="https://habrastorage.org/webt/4z/qj/rr/4zqjrrvsfqngzhxe9dx6h_kncfw.jpeg"><br><br>  Como √© o segmento do loop principal?  Os jogadores est√£o familiarizados com o conceito de "tick thread", parece estar aqui.  H√° uma parte respons√°vel pela rede que empilha tudo em um buffer.  Existe um extrator que descompacta e envia para os codecs, onde seu buffer intermedi√°rio e depois processa.  E voc√™ tem uma marca que muda e controla, lida com a sincroniza√ß√£o. <br><br><img src="https://habrastorage.org/webt/1e/1f/g6/1e1fg6x4ncbeslmzch3timofmfs.jpeg"><br><br>  L√° fora, voc√™ tem um aplicativo que envia alguns comandos atrav√©s de uma fila de mensagens e recebe algumas informa√ß√µes atrav√©s dos ouvintes.  E, √†s vezes, a press√£o de retorno pode aparecer, o que reduz a qualidade - por exemplo, em uma situa√ß√£o em que seu buffer se esgota ou a renderiza√ß√£o n√£o consegue lidar (por exemplo, soltar quadros aparecem). <br><br><h3>  Estimador </h3><br>  Ao se adaptar, o reprodutor conta com 2 par√¢metros principais: velocidade da rede e buffer de dados. <br><br>  Como fica: primeiro, uma certa qualidade √© reproduzida, por exemplo, 720p.  Voc√™ tem um buffer crescente, armazenando em cache cada vez mais.  Ent√£o a velocidade aumenta, voc√™ entende que pode baixar ainda mais, o buffer aumenta.  E neste momento voc√™ entende que est√° pisando em alguns limites do buffer m√≠nimo quando pode experimentar a seguinte qualidade. <br><br><img src="https://habrastorage.org/webt/ef/ti/ch/eftichq4decehj34b_ekowarlmi.jpeg"><br><br>  √â claro que voc√™ precisa tentar com cuidado: tamb√©m existe um estimador que diz se voc√™ pode obter essa qualidade em termos de velocidade da rede.  Se voc√™ se encaixa nessa avalia√ß√£o e o estoque de buffer permite, ent√£o voc√™ muda, por exemplo, para 1080p e continua a jogar. <br><br><h3>  Prote√ß√£o contra sobre press√£o </h3><br>  Com a gente, ela apareceu ao longo do tempo atrav√©s de tentativa e erro.  A necessidade disso surge quando voc√™ sobrecarrega levemente seu equipamento. <br><br>  H√° uma situa√ß√£o em que a rede fica entorpecida durante a reprodu√ß√£o ou os recursos acabam no back-end.  Quando o reprodutor retoma a reprodu√ß√£o, ele come√ßa a recuperar o atraso. <br><br>  Um grande conjunto de segmentos se acumulou no manifesto do player nesse momento, ele os baixa rapidamente de uma s√≥ vez e temos um "golpe de tr√¢nsito".  A situa√ß√£o pode ser agravada se ocorrer um tempo limite nos clientes e o player come√ßar a consultar novamente os dados.  Portanto, √© imperativo fornecer contrapress√£o no sistema. <br><br>  A primeira maneira simples que, √© claro, usamos √© o acelerador no servidor.  Ele entende que o tr√°fego acaba, reduz a qualidade e desacelera deliberadamente os clientes, para n√£o ser atingido. <br><br><img src="https://habrastorage.org/webt/bn/ed/nz/bnednzqso81wrz0doypdlaa2phq.jpeg"><br><br>  Mas isso n√£o afeta muito bem os estimadores.  Eles podem gerar as mesmas "reviravoltas".  Portanto, se poss√≠vel, apoie a remo√ß√£o da qualidade do manifesto.  Para fazer isso, voc√™ deve atualizar periodicamente o manifesto ou, se houver um canal de feedback, dar o comando para remover a qualidade e o player mudar√° automaticamente para outro, mais baixo. <br><br><h3>  Jogadores </h3><br>  No iOS, existe apenas o AVPlayer nativo, mas no Android h√° uma op√ß√£o.  Existe um MediaPlayer nativo, mas existe um ExoPlayer de c√≥digo aberto baseado em Java que os aplicativos "trazem com eles".  Quais s√£o os seus pr√≥s e contras? <br><br>  Compare todos os tr√™s: <br><br><img src="https://habrastorage.org/webt/tf/cr/lg/tfcrlg3alc4srbn9r3plynsxqna.jpeg"><br><br>  No caso de streaming adapt√°vel, o ExoPlayer reproduz o DASH / HLS e possui muitos m√≥dulos expans√≠veis para outros protocolos, enquanto o AVPlayer est√° piorando. <br><br>  O suporte para vers√µes do sistema operacional, em princ√≠pio, atende a todos os lugares. <br><br>  A pr√©-busca ocorre quando voc√™ sabe que ap√≥s o final de um v√≠deo deseja reproduzir o seguinte na fita e pr√©-carreg√°-lo. <br><br>  H√° um problema com corre√ß√µes de bugs de jogadores nativos.  No caso do ExoPlayer, basta transform√°-lo em uma nova vers√£o do seu aplicativo, mas no AVPlayer nativo e no MediaPlayer o bug ser√° corrigido apenas na pr√≥xima vers√£o do sistema operacional.  Nos deparamos com isso dolorosamente: no iOS 8.01, nosso v√≠deo come√ßou a ser ruim, no iOS 8.02 o portal inteiro parou de funcionar, no 8.03 tudo funcionou novamente.  E nada dependia de n√≥s, neste caso, apenas nos sentamos e esperamos a Apple lan√ßar a pr√≥xima vers√£o. <br><br>  A equipe do ExoPlayer fala sobre a inefici√™ncia do consumo de energia no caso do √°udio.  Existem recomenda√ß√µes gerais do Google: para reproduzir √°udio, use o MediaPlayer, para todo o resto do Exo. <br><br>  Entendido, usaremos o ExoPLayer com DASH para v√≠deo no Android e o AVPlayer com HLS no iOS. <br><br><h3>  Primeiro quadro r√°pido </h3><br>  Novamente, lembre-se do tempo at√© o primeiro quadro.  Como fica no iOS HLS: primeiro RTT atr√°s do manifesto, depois outro RTT atr√°s do manifesto aninhado, s√≥ ent√£o - obtendo o segmento e reproduzindo.  No Android, um RTT √© menor, ele come√ßa um pouco melhor. <br><br><img src="https://habrastorage.org/webt/gu/b7/hx/gub7hxr1ex5bhq6vanms80ht7x0.jpeg"><br><br><h3>  Tamanho do buffer </h3><br>  Agora vamos lidar com os buffers.  Temos uma quantidade m√≠nima de dados que precisam ser baixados antes de come√ßarmos a jogar.  No AVPlayer, esse valor √© configurado usando o AVPlayerItem preferidoForwardBufferDuration. <br><br><img src="https://habrastorage.org/webt/lm/cs/mg/lmcsmgwqpuukx1lsowi_xuneiba.jpeg"><br><br>  No Android, o ExoPlayer possui muito mais mecanismos de configura√ß√£o.  Existe o mesmo buffer m√≠nimo necess√°rio para iniciar.  Mas h√° tamb√©m uma configura√ß√£o separada para rejeitar (se sua rede cair, os dados do buffer acabar√£o e, em seguida, retornar√£o): <br><br><img src="https://habrastorage.org/webt/bs/wn/gj/bswngj3l6icqyk3detrxe82ve2s.jpeg"><br><br>  Qual √© o lucro?  Se voc√™ tem uma boa rede, inicia e luta rapidamente por um primeiro quadro r√°pido; pela primeira vez, pode tentar arriscar.  Mas se a rede interromper durante a reprodu√ß√£o, √© √≥bvio que voc√™ precisar√° solicitar mais buffer para reproduzir durante a rejei√ß√£o, para que n√£o haja problemas repetidos. <br><br><h3>  Qualidade original </h3><br><br><img src="https://habrastorage.org/webt/ec/1r/ns/ec1rnsjfbh1yk0cxiusj5x06w7g.jpeg"><br><br>  O HLS no iOS tem um problema interessante: ele sempre come√ßa a ser reproduzido a partir da primeira qualidade no manifesto m3u8.  O que voc√™ devolver a ele come√ßar√°.  E s√≥ ent√£o ele medir√° a velocidade do download e come√ßar√° a tocar com qualidade normal.  √â claro que isso n√£o deve ser permitido. <br><br>  Otimiza√ß√£o l√≥gica - re-classifique a qualidade.  No servidor (adicionando um par√¢metro adicional √† qualidade preferencial, ele classifica novamente o manifesto) ou no cliente (crie um proxy que fa√ßa isso por voc√™). <br><br>  E no Android, h√° um par√¢metro DefaultBandwidthMeter para isso.  Ele fornece um valor que considera a largura de banda padr√£o da sua banda. <br><br><img src="https://habrastorage.org/webt/vs/b3/m8/vsb3m8lvbwp3kwuc2mi9btg3im4.jpeg"><br><br>  Como funciona: h√° uma enorme tabela de constantes no c√≥digo, e os par√¢metros s√£o simples - o pa√≠s (regi√£o) e o tipo de conex√£o (wi-fi, 2G, 3G, 4G).  Quais s√£o os significados?  Por exemplo, se voc√™ possui Wi-Fi e est√° localizado nos EUA, sua largura de banda inicial √© de 5,6 Mbps.  E se 3G √© de 700 kbps. <br><br>  Pode-se ver que, de acordo com as estimativas do Google, o 4G na R√∫ssia √© 2-3 vezes mais r√°pido que nos Estados Unidos. <br><br>  ,   ‚Äî  ,       . ,    ,      ,     ,  . <br><br>      ,      ,    ,      ,    . ,        ( Android   ). <br><br><h3>    </h3><br>         (seek),       ,   . , ,       ,    . <br><br><img src="https://habrastorage.org/webt/ay/be/50/aybe50r6ymkweqtj9wygtuhdxga.jpeg"><br><br>   ,     ,  -     .   iOS,    ,       ,        ,    (  ,     ,   ). <br><br>  ExoPlayer   2.7.0   ,    ,    ¬´  ¬ª.                .  ,    . <br><br><img src="https://habrastorage.org/webt/3j/3a/i_/3j3ai__smnqi_oytag8ny1rico0.jpeg"><br><br>       (     ,        ),     - ,     Android  prepare(mediaSource),   seekTo().   ,   ,     ,   .     ‚Äî     : <br><br><img src="https://habrastorage.org/webt/pe/oy/d_/peoyd_g_aartazc_lofykbivmn0.jpeg"><br><br> ,     (  ,  ),    .     ( 100 ),            ,     . <br><br><img src="https://habrastorage.org/webt/0l/uh/7s/0luh7sbufo5x4qmxbscuzvd-xwk.jpeg"><br><br><h3>  </h3><br>  iOS   ,    Android    legacy-. <br>    TextureView.   ,     ,    ,   ,   UI.    ‚Äî      . <br><br>  SurfaceView.    ,       .     Android-        . YouTube       ,    . <br><br>    GLSurfaceView ‚Äî     .     ,         . <br><br><img src="https://habrastorage.org/webt/yx/tw/wg/yxtwwgajtkdlsclcsyadebja9cg.jpeg"><br><br>   :  ,     ExoPlayer,       23%.  ¬´¬ª   10%.        4% .     4% ‚Äî  ,   . <br><br><h3> :   Android </h3><br><ul><li>  MediaPlayer  ,     ExoPlayer </li><li>  start, seek, swap </li><li>   ,    </li><li>   view   </li></ul><br><h3> :   iOS </h3><br>  iOS  : <br><br><ul><li>     RTT  HLS  AVPlayer </li><li>   </li><li>     AVPlayer#pause </li><li>  ‚Äî  ,     iOS </li></ul><br><br>       DASH-,    ¬´  live-¬ª.  : <br><br><ul><li> cURL  GCDAsyncSocket </li><li> AVAssetReader,     </li><li> CADisplayLink </li><li> AVSampleBufferDisplayLayer </li></ul><br><br>  ,     .       28%, ¬´¬ª   6%.   ,     HLS  DASH       100 /,     6%. <br><br>    iOS  : <br><br><ul><li>  start  seek </li><li>  HLS over Fragmented mp4 </li><li>   DASH- </li></ul><br><br> ,        . <br><br><h3>    : </h3><br>    ,   ,    . <br><br><ul><li>     (  mp4) </li><li>    (ExoPlayer, AVPlayer) </li><li>    firstFrame, seek, emptyBuffer </li><li>       </li><li>    (      ) </li><li>    - ,  .     4,    :  performance,  ,  . </li></ul><br><br>   ‚Äî  . <br><br><h2>  :     </h2><br>  ,        ? <br><br><img src="https://habrastorage.org/webt/ji/0p/pk/ji0ppk9wacev99cddvsw0alqjj0.jpeg"><br><br>  API      .  API         iOS  Android,    ‚Äî    ,  . <br><br> :   - wrapper    ,    POSIX-,    ,        . <br><br> <b>     ?</b> <br><br><ul><li>   </li><li>    </li><li>     </li><li>  In√≠cio r√°pido </li></ul><br><br> <b>    ?</b> <br><br><ul><li>  bandwidth </li><li>  </li><li>     </li><li>   (N x RTT,       RTT) </li></ul><br><br><h3>     </h3><br><br><img src="https://habrastorage.org/webt/-b/ae/va/-baevaqjpxvp9nnr2ecdrjmgqr4.jpeg"><br><br>   ‚Äî   .     ,       ,    . <br><br>       :        ,      ,      .       ‚Äî  low latency. <br><br> ,     ‚Äî    .           . <br><br>   ‚Äî    4K. ,          ,        .      ,     30  ,           .     ,    . <br><br><h3>  </h3><br>   , , ,     .         (       100 ). <br><br> -    ,  ,         . <br><br>       .       100      ,  . ,        300 kbps  FullHD-  480p,     FullHD   .     ,  :  ,       ,   overhead-.      . <br><br>      : <br><br><img src="https://habrastorage.org/webt/kk/xs/xu/kkxsxux2cegqqdg5w9cuny-wzps.jpeg"><br><br>     ,      ,   .     ,     -     ,       ,   . <br><br>       MediaCodec  VideoToolbox (   ).      Server Transcoder. <br><br>   ‚Äî   ,       . <br><br><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando come√ßamos a nos aprofundar no streaming, encontramos um certo n√∫mero de compromissos. </font><font style="vertical-align: inherit;">Em particular, h√° um tri√¢ngulo nos cantos em que confiabilidade √© confiabilidade (sem quedas), rendimento √© largura de banda (quanto usamos a rede) e baixa lat√™ncia √© baixa lat√™ncia (obtemos baixa lat√™ncia). </font></font><br><br><img src="https://habrastorage.org/webt/zz/pc/xm/zzpcxmj1krgbg9qpfgxbb2q32wi.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se come√ßarmos a otimizar um desses par√¢metros, o resto inevitavelmente falhar√°. </font><font style="vertical-align: inherit;">N√£o podemos conseguir tudo de uma vez, temos que sacrificar alguma coisa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Protocolos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os protocolos que veremos hoje: RTMP e WebRTC s√£o protocolos padr√£o, OKMP √© o nosso protocolo personalizado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vale ressaltar que o RTMP √© executado sobre o TCP e os outros dois no UDP.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RTMP </font></font></h3><br>  O que ele d√°?  De certa forma, esse √© um padr√£o suportado por todos os servi√ßos - YouTube, Twitch, Flash, OK.  Eles o usam para que os usu√°rios possam fazer upload de transmiss√µes ao vivo.  Se voc√™ deseja transmitir uma transmiss√£o ao vivo para algum servi√ßo de terceiros, provavelmente precisar√° trabalhar com o RTMP. <br><br>  O atraso m√≠nimo que conseguimos obter de uma unidade de fita para um reprodutor √© de 300 ms, mas est√° em uma rede ideal quando o tempo est√° bom.  Quando temos uma rede real, o atraso geralmente aumenta para 2 a 3 segundos e, se tudo estiver ruim com a rede, pode aumentar para dezenas de segundos. <br><br>  O RTMP oferece suporte √† altera√ß√£o da resolu√ß√£o e da taxa de bits em tempo real (os outros protocolos mencionados s√£o os mesmos, mas h√° informa√ß√µes err√¥neas sobre o RTMP de que n√£o h√° altera√ß√µes em andamento). <br><br>  Das desvantagens: constru√≠das no TCP (explicaremos mais tarde por que isso √© ruim), o atraso n√£o √© controlado. <br><br>  Se voc√™ observar o tri√¢ngulo, o RTMP n√£o poder√° fornecer baixa lat√™ncia.  Pode ser obtido, mas n√£o garantido. <br><br>  Al√©m disso, o RTMP √© uma porcaria: n√£o suporta novos codecs, j√° que a Adobe n√£o faz isso, e a documenta√ß√£o √© bastante antiga e torta. <br><br><img src="https://habrastorage.org/webt/e_/p6/sm/e_p6sm4qifhwi6ftl0hgl-aiodk.jpeg"><br><br>  Por que o TCP n√£o √© adequado para transmiss√µes ao vivo?  O TCP oferece uma garantia de entrega: os dados que voc√™ coloca no soquete ser√£o entregues exatamente na ordem e na forma em que voc√™ os coloca l√°.  Nada ser√° descartado ou reorganizado.  O TCP far√° isso ou morrer√°.  Mas isso significa que uma garantia de atraso √© exclu√≠da - ele n√£o poder√° descartar dados antigos, que talvez j√° n√£o precisem ser enviados.  O buffer, os pedidos em atraso e assim por diante come√ßam a crescer. <br><br><img src="https://habrastorage.org/webt/nt/vw/tb/ntvwtb4fybykxeul4gf9cmhlnva.jpeg"><br><br>  Como ilustra√ß√£o, o problema de bloqueio do chefe de linha.  √â encontrado n√£o apenas no streaming, mas tamb√©m em muitos outros casos. <br><br>  O que √© isso  Temos um buffer receptor inicialmente vazio.  Estamos recebendo dados de algum lugar: muitos dados e muitos pacotes IP.  Recebemos o primeiro pacote IP e, no receptor, usando o m√©todo recv (), podemos subtrair esse pacote, obter dados, perder, renderizar.  Mas, de repente, o segundo pacote foi perdido.  O que acontece depois? <br><br>  Para recuperar um pacote IP perdido, o TCP deve retransmitir.  Para que isso aconte√ßa, voc√™ precisa gastar RTT, enquanto a retransmiss√£o tamb√©m pode ser perdida, e n√≥s iremos em ciclos.  Se houver muitos pacotes, isso definitivamente acontecer√°. <br><br>  Depois disso, existem muitos dados que n√£o podemos ler, porque estamos aguardando o segundo pacote.  Embora ele tenha mostrado um quadro de transmiss√£o que aconteceu cinco minutos atr√°s e n√£o √© mais necess√°rio. <br><br>  Para entender outro problema, vejamos a adapta√ß√£o do RTMP.  Fazemos a adapta√ß√£o no lado do remetente.  Se a rede n√£o puder empilhar dados na velocidade com que s√£o inseridos no soquete, o buffer √© preenchido e o soquete diz EWOULDBLOCK ou √© bloqueado se o bloqueio for usado neste momento. <br><br><img src="https://habrastorage.org/webt/oy/6z/uy/oy6zuyjliks8epvjx4g83uq5d_m.jpeg"><br><br>  Somente neste momento entendemos que temos problemas e precisamos reduzir a qualidade. <br><br>  Digamos que temos uma rede com uma velocidade espec√≠fica de 4 Mbps.  Escolhemos um tamanho de soquete de 250 KB (correspondente a 0,5 segundos em nossa velocidade).  De repente, a rede falhou 10 vezes - esta √© uma situa√ß√£o normal.  Temos 400 kbps.  O buffer encheu-se rapidamente em meio segundo, e somente nesse momento entendemos que precisamos desligar. <br><br><img src="https://habrastorage.org/webt/te/7l/0p/te7l0pkef3gz8ntjm7gq27yvxnm.jpeg"><br><br>  Mas agora o problema √© que temos um buffer de 250 KB que ser√° transmitido por 5 segundos.  J√° estamos completamente atrasados: precisamos empurrar os dados antigos primeiro, e somente ent√£o os novos e adaptados ser√£o atualizados em tempo real. <br><br>  O que fazer  Aqui o nosso "tri√¢ngulo de compromissos" √© apenas relevante. <br><br><img src="https://habrastorage.org/webt/s2/0k/fa/s20kfaykbgel7si5vtpcjiwla1w.jpeg"><br><br><ul><li>  Podemos reduzir o buffer do remetente, colocar em vez de 0,5 s - 0,1 s.  Mas estamos perdendo largura de banda, pois frequentemente entramos em p√¢nico e diminu√≠mos.  Al√©m disso, o TCP funciona de tal maneira que, se voc√™ colocar um buffer de remetente menor que o RTT, n√£o poder√° usar toda a largura de banda do canal, diminuir√° v√°rias vezes. </li><li>  N√≥s podemos aumentar o buffer do receptor.  Com um buffer grande, os dados chegam, podemos atenuar algumas irregularidades no buffer.  Mas, √© claro, estamos perdendo baixa lat√™ncia, pois montamos imediatamente um buffer de 5 segundos. </li><li>  Podemos eliminar agressivamente dados antigos.  No TCP, a √∫nica op√ß√£o para isso √© interromper a conex√£o e recri√°-la.  Perdemos a confiabilidade, porque neste momento o jogador n√£o tem nada para mostrar. </li></ul><br><br><h3>  WebRTC </h3><br>  Esta √© uma biblioteca C ++ que j√° leva em conta a experi√™ncia e √© executada sobre o UDP.  Constr√≥i em iOS, Android, √© incorporado em navegadores, suporta HTML5.  Como est√° preso para chamadas P2P, o atraso √© de 0,1 a 1 segundo. <br><br><img src="https://habrastorage.org/webt/gu/jv/co/gujvcogf5z-3szbr4b3fqxcs38m.jpeg"><br><br>  Dos pontos negativos: esta √© uma biblioteca monol√≠tica com uma abund√¢ncia de legados que n√£o podem ser removidos.  Al√©m disso, devido ao seu foco nas chamadas P2P, ele prioriza a baixa lat√™ncia.  Parece que quer√≠amos isso, mas, por causa disso, ela sacrifica outros par√¢metros.  E n√£o h√° configura√ß√µes para alterar prioridades. <br><br>  Tamb√©m deve-se ter em mente que a biblioteca √© orientada ao cliente para uma conversa entre dois clientes sem um servidor.  Voc√™ precisa procurar um servidor de terceiros ou escrever o seu. <br><br>  O que escolher - RTMP ou WebRTC?  Implementamos os dois protocolos e os testamos em diferentes cen√°rios.  No gr√°fico, o WebRTC tem um atraso baixo, mas um rendimento baixo, enquanto o RTMP tem o oposto.  E entre eles h√° um buraco. <br><br>  E quer√≠amos criar um protocolo que cubra completamente esse buraco e possa funcionar tanto no WebRTC quanto no modo RTMP.  Eles criaram e deram o nome de OKMP. <br><br><img src="https://habrastorage.org/webt/xq/8y/p1/xq8yp1lyi_jxdqc8h-tyzw0grgi.jpeg"><br><h3>  Okmp </h3><br>  Este √© um protocolo flex√≠vel para UDP. <br><br>  Suporta multiplexa√ß√£o.  O que isso significa: existem v√°rios canais dentro da sess√£o (no caso do OK Live - o gerente, √°udio e v√≠deo).  Dentro de cada canal, os dados s√£o garantidos para serem entregues em uma determinada ordem (mas eles n√£o s√£o garantidos para serem entregues), e a ordem entre os canais n√£o √© garantida, pois n√£o √© importante. <br><br>  O que isso d√°?  Primeiro, nos deu a oportunidade de priorizar os canais.  Podemos dizer que o canal de controle tem alta prioridade, o som √© m√©dio e o v√≠deo √© baixo.  √â mais f√°cil disfar√ßar a instabilidade de v√≠deo e a exibi√ß√£o irregular de v√≠deo, e o usu√°rio tem menos problemas com problemas de v√≠deo do que com a desagrad√°vel interrup√ß√£o do √°udio. <br><br><img src="https://habrastorage.org/webt/vd/nq/pp/vdnqppsvt33b7j82m2hxdgnf1ag.jpeg"><br><br>  Al√©m disso, nosso protocolo possui uma garantia de entrega opcional.  Podemos dizer que em um determinado canal trabalhamos no modo TCP, com entrega garantida, e no restante permitimos algumas quedas. <br><br>  Gra√ßas a isso, uma garantia de atraso pode ser feita: n√£o h√° garantia de atraso no canal TCP, mas nos outros onde as gotas s√£o permitidas, √© definido um limite, ap√≥s o qual os dados come√ßam a cair e paramos de fornecer dados antigos. <br><br>  Por exemplo, para √°udio, isso √© 1 segundo e, para v√≠deo, 0,5 segundos.  Por que o limite √© diferente?  Esse √© outro mecanismo de prioriza√ß√£o.  Como √© mais importante para n√≥s que o √°udio seja suave, come√ßamos a soltar o v√≠deo antes de tudo. <br><br>  Nosso protocolo √© configurado com flexibilidade: n√£o existe um modo de opera√ß√£o √∫nico, alteramos as configura√ß√µes rapidamente para alternar para o modo desejado sem efeitos vis√≠veis para o usu√°rio.  Porque  Por exemplo, para as mesmas videochamadas: se uma videochamada iniciar em um fluxo, transferimos-a silenciosamente para o modo de baixa lat√™ncia.  E, em seguida, volte ao modo de taxa de transfer√™ncia para obter a m√°xima qualidade. <br>  Dificuldades de implementa√ß√£o <br><br><img src="https://habrastorage.org/webt/zv/jl/wk/zvjlwkvrqjhldwib10ocewpc7iu.jpeg"><br><br>  Obviamente, se voc√™ decidir escrever seu protocolo no UDP, encontrar√° alguns problemas.  Usando o TCP, obtemos mecanismos que teremos que escrever no UDP: <br><br><ul><li>  Embalagem / despacketizing.  Voc√™ precisa cortar os dados em pacotes de aproximadamente 1,5 KB de tamanho para que eles se encaixem na rede MTU. </li><li>  Reordena√ß√£o.  Voc√™ envia pacotes em um pedido e eles s√£o reorganizados no caminho e v√™m em outro.  Para superar isso, voc√™ precisa definir a sequ√™ncia com o n√∫mero da embalagem e reorganiz√°-las no receptor. </li><li>  Perdas.  Claro, h√° perdas.  Quando ocorre uma perda, o destinat√°rio deve informar ao remetente separadamente que "eu recebi esses pacotes, mas n√£o os recebi" e o remetente deve retransmitir os pacotes ausentes.  Ou largue-os. </li><li>  Controle de fluxo  Se o Receptor n√£o receber dados, n√£o acompanhar a velocidade com que o empurramos, os dados podem come√ßar a se perder, devemos processar essa situa√ß√£o.  No caso do TCP, o soquete de envio ser√° bloqueado e, no caso do UDP, n√£o ser√° bloqueado, voc√™ deve entender que o receptor n√£o est√° recebendo dados e reduzir a quantidade de dados enviados. </li><li>  Controle de congestionamento.  Uma coisa semelhante, somente nesse caso a rede morreu.  Se enviarmos pacotes para a rede falecida, destruiremos n√£o apenas nossa conex√£o, mas tamb√©m as vizinhas. </li><li>  Criptografia  Precisa cuidar da criptografia </li><li>  ... e muito mais </li></ul><br><br><h3>  OKMP vs RTMP </h3><br>  O que obtivemos quando come√ßamos a usar o OKMP em vez do RTMP? <br><br><ul><li>  O aumento m√©dio na taxa de bits do OKLive √© de 30%. </li><li>  Tremula√ß√£o (medida da chegada desigual de pacotes) - 0% (em m√©dia, o mesmo). </li><li>  √Åudio de jitter - -25% </li><li>  V√≠deo de instabilidade - 40% </li></ul><br><br>  Mudan√ßas em √°udio e v√≠deo - demonstra√ß√£o de prioridades em nosso protocolo.  O √°udio d√° uma prioridade mais alta e come√ßou a ficar mais suave devido ao v√≠deo. <br><br><h3>  Como escolher um protocolo para streaming </h3><br><br><img src="https://habrastorage.org/webt/_l/g3/vs/_lg3vsf20spfixqon5z0m4fwa0w.jpeg"><br><br>  Se voc√™ precisar de baixa lat√™ncia - WebRTC. <br><br>  Se voc√™ quiser trabalhar com servi√ßos externos, publicar v√≠deos em servi√ßos de terceiros, precisar√° usar o RTMP. <br><br>  Se voc√™ deseja um protocolo personalizado para seus scripts - implemente o seu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467669/">https://habr.com/ru/post/pt467669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467659/index.html">Acelere significativamente a execu√ß√£o de tarefas pelo exemplo de configura√ß√£o adicional da mem√≥ria HyperX FURY DDR4 atualizada</a></li>
<li><a href="../pt467661/index.html">Dos√≠metro para Seryozha. Parte I. Polimaster - Ca√ßadores de Nucl√≠deos</a></li>
<li><a href="../pt467663/index.html">Suporte para instru√ß√µes espec√≠ficas de hardware no .NET Core (agora n√£o apenas no SIMD)</a></li>
<li><a href="../pt467665/index.html">Carrinho de caminh√£o ROS. Parte 5. Trabalhando em rviz e gazebo: xacro, novos sensores</a></li>
<li><a href="../pt467667/index.html">Planejamento de projeto da organiza√ß√£o (parte 4)</a></li>
<li><a href="../pt467671/index.html">Computador retro NLX</a></li>
<li><a href="../pt467673/index.html">Recursos de Go incorporados</a></li>
<li><a href="../pt467675/index.html">Modelando o estado do aplicativo usando objetos Store no SwiftUI</a></li>
<li><a href="../pt467677/index.html">Testes ou tipos</a></li>
<li><a href="../pt467679/index.html">PyCrunch - Execu√ß√£o de teste inteligente e cobertura de c√≥digo visual no IDE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>