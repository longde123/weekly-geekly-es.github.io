<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🔬 🚴🏿 🤸🏻 Linux Kernel 5.0 - menulis Perangkat Blok Sederhana di bawah blk-mq 🚴🏿 👨🏻‍🎤 🚡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kabar Baik, Semuanya! 

 Kernel Linux 5.0 sudah ada di sini dan muncul dalam distribusi eksperimental seperti Arch, openSUSE Tumbleweed, Fedora. 



 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux Kernel 5.0 - menulis Perangkat Blok Sederhana di bawah blk-mq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/446148/">  Kabar Baik, Semuanya! <br><br>  Kernel Linux 5.0 sudah ada di sini dan muncul dalam distribusi eksperimental seperti Arch, openSUSE Tumbleweed, Fedora. <br><br><img src="https://habrastorage.org/webt/me/zn/aq/meznaq4kak63su90hds63zvj1tq.png"><br><br>  Dan jika Anda melihat distribusi RC dari Ubuntu Disko Dingo dan Red Hat 8, maka menjadi jelas: segera kernel 5.0 juga akan ditransfer dari desktop fan ke server yang serius. <br>  Seseorang akan berkata - jadi apa.  Rilis berikutnya, tidak ada yang istimewa.  Jadi, Linus Torvalds sendiri berkata: <blockquote>  Saya ingin menunjukkan (lagi) bahwa kita tidak melakukan rilis berbasis fitur, dan bahwa "5.0" tidak berarti apa-apa lebih dari itu angka 4.x mulai menjadi cukup besar sehingga saya kehabisan jari dan jari kaki. <br><br>  ( <i>Sekali lagi saya ulangi - rilis kami tidak terikat dengan fitur tertentu, sehingga jumlah versi baru 5.0 hanya berarti bahwa untuk penomoran versi 4.x saya sudah tidak punya cukup jari tangan dan kaki</i> ) <br></blockquote><br>  Namun, modul untuk floppy disk (siapa yang tidak tahu - ini adalah disk seukuran baju saku dada, dengan kapasitas 1,44 MB) - dikoreksi ... <br>  Dan inilah alasannya: <br><a name="habracut"></a><br>  Ini semua tentang multi-queue block layer (blk-mq).  Ada banyak artikel pengantar tentang dia di Internet, jadi mari kita langsung ke intinya.  Transisi ke blk-mq dimulai sejak lama dan perlahan-lahan bergerak maju.  Scsi multi-antrian (parameter kernel scsi_mod.use_blk_mq) muncul, penjadwal baru mq-tenggat waktu, bfq, dan seterusnya muncul ... <br><br><pre><code class="dos hljs">[root@fedora-<span class="hljs-number"><span class="hljs-number">29</span></span> sblkdev]# cat /sys/block/sda/queue/scheduler [mq-deadline] none</code> </pre> <br>  Ngomong-ngomong, apa milikmu? <br><br>  Jumlah pengandar perangkat blok yang bekerja dengan cara lama berkurang.  Dan pada 5.0, fungsi blk_init_queue () dihapus sebagai tidak perlu.  Dan sekarang kode lama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lwn.net/Articles/58720</a> dari tahun 2003 tidak hanya tidak akan berhasil, tetapi juga kehilangan relevansi.  Selain itu, distribusi baru, yang sedang dipersiapkan untuk rilis tahun ini, menggunakan lapisan blok multi-antrian dalam konfigurasi default.  Sebagai contoh, pada Manjaro ke-18, kernel, meskipun versi 4.19, secara default blk-mq. <br><br>  Oleh karena itu, kita dapat mengasumsikan bahwa transisi ke blk-mq di kernel 5.0 telah selesai.  Dan bagi saya ini adalah peristiwa penting yang akan membutuhkan penulisan ulang kode dan pengujian tambahan.  Yang dengan sendirinya menjanjikan munculnya bug besar dan kecil, serta beberapa server macet (Kita harus, Fedya, aku harus! (C)). <br><br>  By the way, jika seseorang berpikir bahwa untuk rhel8 titik kritis ini tidak datang, karena kernel "flash" oleh versi 4.18 di sana, maka Anda salah.  Dalam RC baru di rhel8, produk baru dari 5.0 sudah dimigrasikan, dan fungsi blk_init_queue () juga terpotong (mungkin ketika menyeret check-in lain dari github.com/torvalds/linux ke sumbernya). <br>  Secara umum, versi "beku" dari kernel untuk distributor Linux seperti SUSE dan Red Hat telah lama menjadi konsep pemasaran.  Sistem melaporkan bahwa versi tersebut, misalnya, adalah 4.4, dan sebenarnya fungsionalitasnya berasal dari vanilla 4.8 baru.  Pada saat yang sama, sebuah prasasti memamerkan di situs web resmi seperti: "Dalam distribusi baru, kami telah menyimpan kernel 4.4 yang stabil untuk Anda." <br><br>  Tapi kami terganggu ... <br><br>  Jadi disini.  Kami membutuhkan driver perangkat blok sederhana baru untuk membuatnya lebih jelas bagaimana ini bekerja. <br>  Jadi, sumbernya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/CodeImp/sblkdev</a> .  Saya mengusulkan untuk berdiskusi, membuat permintaan tarik, memulai masalah - saya akan memperbaikinya.  QA belum diuji. <br><br>  Nanti dalam artikel saya akan mencoba menjelaskan apa sebabnya.  Karena itu, ada banyak kode. <br>  Saya langsung minta maaf karena gaya pengkodean kernel Linux tidak sepenuhnya dihormati, dan ya - saya tidak suka goto. <br><br>  Jadi, mari kita mulai dari titik masuk. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; _sblkdev_major = register_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to get major number\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } ret = sblkdev_add_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) unregister_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sblkdev_remove_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) unregister_blkdev(_sblkdev_major, _sblkdev_name); } module_init(sblkdev_init); module_exit(sblkdev_exit);</code> </pre><br>  Jelas, ketika modul dimuat, fungsi sblkdev_init () diluncurkan, ketika sblkdev_exit () diturunkan. <br>  Fungsi register_blkdev () mendaftarkan perangkat blok.  Ia dialokasikan sejumlah besar.  unregister_blkdev () - membebaskan nomor ini. <br><br>  Struktur kunci dari modul kami adalah sblkdev_device_t. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The internal representation of our device typedef struct sblkdev_device_s { sector_t capacity; // Device size in bytes u8* data; // The data aray. u8 - 8 bytes atomic_t open_counter; // How many openers struct blk_mq_tag_set tag_set; struct request_queue *queue; // For mutual exclusion struct gendisk *disk; // The gendisk structure } sblkdev_device_t;</span></span></code> </pre><br>  Ini berisi semua informasi tentang perangkat yang diperlukan untuk modul kernel, khususnya: kapasitas perangkat blok, data itu sendiri (ini sederhana), petunjuk ke disk dan antrian. <br><br>  Semua inisialisasi perangkat blok dilakukan dalam fungsi sblkdev_add_device (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_add_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to allocate %ld bytes\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } _sblkdev_device = dev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ ret = sblkdev_allocate_buffer(dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//simply variant with helper function blk_mq_init_sq_queue. It`s available from kernel 4.20 (vanilla). {//configure tag_set struct request_queue *queue; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.driver_data = dev; queue = blk_mq_init_sq_queue(&amp;dev-&gt;tag_set, &amp;_mq_ops, 128, BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: unable to allocate and initialize tag set\n"); break; } dev-&gt;queue = queue; } #else // more flexible variant {//configure tag_set dev-&gt;tag_set.ops = &amp;_mq_ops; dev-&gt;tag_set.nr_hw_queues = 1; dev-&gt;tag_set.queue_depth = 128; dev-&gt;tag_set.numa_node = NUMA_NO_NODE; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE; dev-&gt;tag_set.driver_data = dev; ret = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set); if (ret) { printk(KERN_WARNING "sblkdev: unable to allocate tag set\n"); break; } } {//configure queue struct request_queue *queue = blk_mq_init_queue(&amp;dev-&gt;tag_set); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: Failed to allocate queue\n"); break; } dev-&gt;queue = queue; } #endif dev-&gt;queue-&gt;queuedata = dev; {// configure disk struct gendisk *disk = alloc_disk(1); //only one partition if (disk == NULL) { printk(KERN_WARNING "sblkdev: Failed to allocate disk\n"); ret = -ENOMEM; break; } disk-&gt;flags |= GENHD_FL_NO_PART_SCAN; //only one partition //disk-&gt;flags |= GENHD_FL_EXT_DEVT; disk-&gt;flags |= GENHD_FL_REMOVABLE; disk-&gt;major = _sblkdev_major; disk-&gt;first_minor = 0; disk-&gt;fops = &amp;_fops; disk-&gt;private_data = dev; disk-&gt;queue = dev-&gt;queue; sprintf(disk-&gt;disk_name, "sblkdev%d", 0); set_capacity(disk, dev-&gt;capacity); dev-&gt;disk = disk; add_disk(disk); } printk(KERN_WARNING "sblkdev: simple block device was created\n"); }while(false); if (ret){ sblkdev_remove_device(); printk(KERN_WARNING "sblkdev: Failed add block device\n"); } return ret; }</span></span></span></span></code> </pre><br>  Kami mengalokasikan memori untuk struktur, mengalokasikan buffer untuk menyimpan data.  Tidak ada yang istimewa di sini. <br>  Selanjutnya, kami menginisialisasi antrian pemrosesan permintaan dengan salah satu fungsi blk_mq_init_sq_queue (), atau dua sekaligus: blk_mq_alloc_tag_set () + blk_mq_init_queue (). <br><br>  Ngomong-ngomong, jika Anda melihat sumber dari fungsi blk_mq_init_sq_queue (), Anda akan melihat bahwa ini hanyalah pembungkus di atas fungsi blk_mq_alloc_tag_set () dan blk_mq_init_queue (), yang muncul di kernel 4.20.  Selain itu, ia menyembunyikan banyak parameter antrian, tetapi terlihat lebih sederhana.  Anda harus memilih opsi mana yang lebih baik, tetapi saya lebih suka yang lebih eksplisit. <br><br>  Kunci dalam kode ini adalah variabel global _mq_ops. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_ops</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mq_ops</span></span></span><span class="hljs-class"> = {</span></span> .queue_rq = queue_rq, };</code> </pre><br>  Di sinilah fungsi yang menyediakan pemrosesan permintaan berada, tetapi lebih banyak tentangnya nanti.  Hal utama adalah bahwa kami telah menetapkan titik masuk ke penangan permintaan. <br><br>  Sekarang kita telah membuat antrian, kita dapat membuat instance dari disk. <br><br>  Tidak ada perubahan besar.  Disk dialokasikan, parameter ditetapkan, dan disk ditambahkan ke sistem.  Saya ingin menjelaskan tentang parameter disk-&gt; flags.  Ini memungkinkan Anda untuk memberi tahu sistem bahwa disk dapat dilepas, atau, misalnya, bahwa itu tidak mengandung partisi dan Anda tidak perlu mencarinya di sana. <br><br>  Ada struktur _fops untuk manajemen disk. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block_device_operations</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .open = _open, .release = _release, .ioctl = _ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = _compat_ioctl, #endif };</code> </pre><br>  Poin entri _open dan _release bagi kami untuk modul perangkat blok sederhana belum terlalu menarik.  Selain penghitung kenaikan dan penurunan atom, tidak ada apa pun di sana.  Saya juga meninggalkan compat_ioctl tanpa implementasi, karena versi sistem dengan kernel 64-bit dan lingkungan ruang pengguna 32-bit sepertinya tidak menjanjikan bagi saya. <br><br>  Tetapi _ioctl memungkinkan Anda memproses permintaan sistem untuk drive ini.  Ketika disk muncul, sistem mencoba untuk mempelajari lebih lanjut tentang itu.  Anda dapat menjawab beberapa pertanyaan sesuai keinginan Anda (misalnya, berpura-pura menjadi CD baru), tetapi aturan umumnya adalah ini: jika Anda tidak ingin menjawab pertanyaan yang tidak menarik bagi Anda, cukup kembalikan kode kesalahan -ENOTTY.  Omong-omong, jika perlu, di sini Anda dapat menambahkan penangan permintaan Anda tentang drive khusus ini. <br><br>  Jadi, kami menambahkan perangkat - kami harus mengurus pelepasan sumber daya.  Karat tidak di <s>sini</s> untukmu. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_remove_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = _sblkdev_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) del_gendisk(dev-&gt;disk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { blk_cleanup_queue(dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;tag_set.tags) blk_mq_free_tag_set(&amp;dev-&gt;tag_set); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) { put_disk(dev-&gt;disk); dev-&gt;disk = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } sblkdev_free_buffer(dev); kfree(dev); _sblkdev_device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: simple block device was removed\n"</span></span>); } }</code> </pre><br>  Pada prinsipnya, semuanya jelas: kami menghapus objek disk dari sistem dan membebaskan antrian, setelah itu kami juga membebaskan buffer kami (area data). <br><br>  Dan sekarang yang paling penting adalah pemrosesan query dalam fungsi queue_rq (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> blk_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_rq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct blk_mq_hw_ctx *hctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct blk_mq_queue_data* bd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">blk_status_t</span></span> status = BLK_STS_OK; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bd</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> blk_mq_start_request(rq); <span class="hljs-comment"><span class="hljs-comment">//we cannot use any locks that make the thread sleep { unsigned int nr_bytes = 0; if (do_simple_request(rq, &amp;nr_bytes) != SUCCESS) status = BLK_STS_IOERR; printk(KERN_WARNING "sblkdev: request process %d bytes\n", nr_bytes); #if 0 //simply and can be called from proprietary module blk_mq_end_request(rq, status); #else //can set real processed bytes count if (blk_update_request(rq, status, nr_bytes)) //GPL-only symbol BUG(); __blk_mq_end_request(rq, status); #endif } return BLK_STS_OK;//always return ok }</span></span></code> </pre><br>  Pertama, pertimbangkan parameternya.  Yang pertama adalah struct blk_mq_hw_ctx * hctx - keadaan antrian perangkat keras.  Dalam kasus kami, kami melakukannya tanpa antrian perangkat keras, jadi tidak digunakan. <br><br>  Parameter kedua adalah const struct blk_mq_queue_data * bd - parameter dengan struktur yang sangat ringkas, yang saya tidak takut untuk memberikan perhatian Anda secara keseluruhan: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_queue_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> last; };</code> </pre><br>  Ternyata pada dasarnya ini semua permintaan yang sama yang datang kepada kita dari waktu yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">elixir.bootlin.com</a> kronik tidak lagi ingat.  Jadi kami menerima permintaan dan mulai memprosesnya, yang kami beri tahu kernel dengan menelepon blk_mq_start_request ().  Setelah menyelesaikan pemrosesan permintaan, kami akan menginformasikan kernel tentang hal ini dengan memanggil fungsi blk_mq_end_request (). <br><br>  Berikut ini catatan kecil: fungsi blk_mq_end_request () pada dasarnya adalah pembungkus panggilan ke blk_update_request () + __blk_mq_end_request ().  Saat menggunakan fungsi blk_mq_end_request (), Anda tidak bisa menentukan berapa banyak byte yang sebenarnya diproses.  Percaya bahwa semuanya sudah diproses. <br><br>  Opsi alternatif memiliki fitur lain: fungsi blk_update_request diekspor hanya untuk modul khusus GPL.  Yaitu, jika Anda ingin membuat modul kernel berpemilik (biarkan PM menyelamatkan Anda dari jalur sulit ini), Anda tidak dapat menggunakan blk_update_request ().  Jadi pilihan ada di tangan Anda. <br><br>  Secara langsung menggeser byte dari permintaan ke buffer dan sebaliknya saya memasukkan fungsi do_simple_request (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_simple_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct request *rq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *nr_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bio_vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bvec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span> *dev = rq-&gt;q-&gt;queuedata; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> dev_size = (<span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span>)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT); printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: request start from sector %ld \n"</span></span>, blk_rq_pos(rq)); rq_for_each_segment(bvec, rq, iter) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_len = bvec.bv_len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pos + b_len) &gt; dev_size) b_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(dev_size - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rq_data_dir(rq))<span class="hljs-comment"><span class="hljs-comment">//WRITE memcpy(dev-&gt;data + pos, b_buf, b_len); else//READ memcpy(b_buf, dev-&gt;data + pos, b_len); pos += b_len; *nr_bytes += b_len; } return ret; }</span></span></code> </pre><br>  Tidak ada yang baru: rq_for_each_segment iterates atas semua bio, dan mereka semua memiliki struktur bio_vec, memungkinkan kita untuk sampai ke halaman dengan data permintaan. <br><br>  Apa kesan Anda?  Segalanya tampak sederhana?  Pemrosesan permintaan secara umum hanya menyalin data antara halaman permintaan dan buffer internal.  Cukup layak untuk driver perangkat blok sederhana, bukan? <br><br>  Tapi ada masalah: <b>Ini bukan untuk penggunaan nyata!</b> <br><br>  Inti dari masalah adalah bahwa fungsi pemrosesan permintaan queue_rq () dipanggil dalam loop yang memproses permintaan dari daftar.  Saya tidak tahu kunci mana untuk daftar ini yang digunakan di sana, Putar atau RCU (Saya tidak ingin berbohong - siapa tahu, perbaiki saya), tetapi ketika Anda mencoba menggunakan, misalnya, mutex dalam fungsi pemrosesan permintaan, kernel debugging bersumpah dan memperingatkan: tertidur ini tidak mungkin.  Artinya, menggunakan alat sinkronisasi konvensional atau memori bersebelahan virtual - yang dialokasikan menggunakan vmalloc dan dapat jatuh ke swap dengan semua yang disiratkannya - tidak mungkin, karena proses tidak dapat masuk ke keadaan siaga. <br><br>  Oleh karena itu, baik Spin atau RCU mengunci dan buffer dalam bentuk array halaman, atau daftar, atau pohon, seperti yang diterapkan di .. \ linux \ drivers \ block \ brd.c, atau menunda pemrosesan di utas lain, seperti yang diterapkan dalam .. \ linux \ drivers \ block \ loop.c. <br><br>  Saya pikir tidak perlu menjelaskan cara merakit modul, cara memuatnya ke dalam sistem dan cara membongkar.  Tidak ada produk baru di bagian depan ini, dan terima kasih untuk itu :) Jadi jika seseorang ingin mencobanya, saya pasti akan mengetahuinya.  <b>Jangan langsung melakukannya di laptop favorit Anda!</b>  Naikkan virtualochka atau setidaknya buat cadangan di atas bola. <br><br>  Omong-omong, Veeam Backup untuk Linux 3.0.1.1046 sudah tersedia.  Hanya saja, jangan mencoba menjalankan VAL 3.0.1.1046 pada kernel 5.0 atau yang lebih baru.  veeamsnap tidak akan berkumpul.  Dan beberapa inovasi multi-antrian masih dalam tahap pengujian. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446148/">https://habr.com/ru/post/id446148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446134/index.html">Ketergantungan Injeksi dalam Flutter</a></li>
<li><a href="../id446136/index.html">Mesin 3D Marmer Saya Dicetak</a></li>
<li><a href="../id446138/index.html">Betapa mudahnya mengatur startup Anda secara legal dalam bentuk kemitraan sederhana</a></li>
<li><a href="../id446142/index.html">Flat Earth: Eksperimen dan Bukti</a></li>
<li><a href="../id446144/index.html">Intisari materi menarik untuk pengembang seluler # 292 (25 Maret - 31 Maret)</a></li>
<li><a href="../id446150/index.html">Pembelajaran mesin tanpa Python, Anaconda dan reptil lainnya</a></li>
<li><a href="../id446152/index.html">Commando VM - Kali Linux Alternatif untuk Windows</a></li>
<li><a href="../id446162/index.html">Bagaimana menjadi "junior yang cerdas." Pengalaman pribadi</a></li>
<li><a href="../id446166/index.html">Codec ASN1 sprintf sederhana</a></li>
<li><a href="../id446172/index.html">Batasi Pesan API VK - apa yang harus dilakukan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>