<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧 👦 ✍🏾 Apa yang perlu Anda ketahui sebelum mengembangkan backtester untuk strategi perdagangan: masalah khas, jenis sistem dan parameternya 🙋🏾 🤟🏽 💡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Para editor portal QuantStart menulis materi tentang apa yang harus Anda ketahui ketika Anda mulai mengembangkan sistem Anda sendiri untuk menguji str...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang perlu Anda ketahui sebelum mengembangkan backtester untuk strategi perdagangan: masalah khas, jenis sistem dan parameternya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iticapital/blog/414273/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/yo/ur/rc/yourrczo-apctuvumq-jbnt3k-4.png"></a> <br><br>  Para editor portal QuantStart menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">materi</a> tentang apa yang harus Anda ketahui ketika Anda mulai mengembangkan sistem Anda sendiri untuk menguji strategi perdagangan.  Kami membahas beberapa masalah yang diangkat dalam artikel sebelumnya di blog, jadi kali ini kami menyiapkan pencabutan ulang yang disesuaikan dari tesis tentang masalah apa yang dihadapi pengembang, apa perbedaan antara backtests dari berbagai jenis, dan apa pro dan kontra mereka. <a name="habracut"></a><br><br><h2>  Apa itu Backtester? </h2><br>  Backtest adalah penerapan aturan strategi perdagangan untuk sekumpulan data historis tentang harga instrumen keuangan.  Inti dari pendekatan ini adalah bahwa jika kita mengembangkan mekanisme untuk menentukan saat memasuki dan keluar dari suatu posisi (beli / jual), misalnya, saham dari portofolio tertentu, dan menerapkan aturan yang dihasilkan pada data historis, ini akan memberikan gambaran tentang produktivitas strategi perdagangan “di masa lalu ". <br><br>  Seseorang pernah berkata bahwa "semua model salah, tetapi ada yang berguna."  Ungkapan ini bagus untuk pengujian ulang.  Sistem untuk pengujian historis dari strategi keuangan membantu menentukan apakah layak menerapkan seperangkat aturan yang ada pada perdagangan nyata.  Jika kita tahu bagaimana sebuah strategi dapat berperilaku di masa lalu, itu akan membantu menyaring strategi yang buruk tanpa perlu kerugian finansial yang nyata. <br><br>  Masalahnya adalah bahwa hasil backtesting tidak ada hubungannya dengan hasil perdagangan nyata di bursa.  Ini hanya model realitas.  Model yang sering mengandung banyak asumsi. <br><br>  Ada dua jenis utama backtester - for-loop dan event-driven. <br><br>  Ketika mengembangkan sistem seperti itu, selalu ada kebutuhan untuk kompromi antara akurasi dan kompleksitas implementasi.  Kedua jenis backtester ini mewakili berbagai pilihan untuk kompromi semacam itu. <br><br><h2>  Tantangan Backtesting </h2><br>  Menguji data historis membawa banyak kesulitan.  Semuanya terhubung dengan fakta bahwa keseluruhan proses hanyalah simulasi dari kenyataan.  Berikut ini beberapa di antaranya: <br><br><ul><li>  <b>Pengujian dalam sampel</b> - masalah muncul saat menggunakan data yang sama untuk model perdagangan pelatihan dan untuk pengujian lebih lanjut.  Dalam hal ini, produktivitas yang ditunjukkan terdepresiasi secara signifikan - karena hasilnya dicapai pada sistem data yang diketahui sebelumnya.  Pada kenyataannya, data yang paling sering akan berbeda secara signifikan dari pelatihan.  Sebenarnya, ini adalah bentuk pelatihan ulang. </li><li>  <b>Kesalahan Survivor</b> - indeks saham (misalnya, S &amp; P500) ditandai dengan proses pencatatan dan penghapusan pencatatan ketika saham tertentu dan instrumen keuangan muncul atau dikeluarkan dari mereka.  Jika perubahan ini tidak diperhitungkan selama pengujian ulang, maka strategi yang tidak memperhitungkan saham perusahaan yang dikeluarkan dari indeks karena kapitalisasi rendah dapat dianggap berhasil.  Untuk menghindari masalah seperti itu, saat menjalankan tes ulang dalam periode waktu yang lama, Anda perlu menggunakan data yang tidak tunduk pada kesalahan survivor. </li><li>  <b>Kesalahan prediksi (bias lihat-depan)</b> - data dari masa depan juga dapat mempengaruhi hasil backtest.  Sebagai contoh, perhatikan kasus ketika indeks regresi linier dihitung pada interval waktu tertentu.  Jika indikator ini kemudian digunakan dalam sampel yang sama, ternyata data dari masa depan menembus ke dalamnya, yang berarti bahwa produktivitas strategi yang dihasilkan terdepresiasi secara signifikan.  Backtester yang berorientasi pada peristiwa membantu menyelesaikan masalah ini. </li><li> <b>Perubahan dalam kondisi pasar</b> - parameter pasar keuangan tidak stasioner.  Ini berarti bahwa proses yang menghasilkan pergerakan harga saham tidak bergantung pada parameter yang konstan dari waktu ke waktu.  Fakta ini menyulitkan generalisasi model parameter (banyak strategi perdagangan adalah kasus khusus dari strategi tersebut), yang mengarah pada fakta bahwa efektivitas strategi pada data historis jauh lebih baik daripada dalam perdagangan nyata. </li><li>  <b>Biaya transaksi</b> - banyak backtester siklik tidak memperhitungkan bahkan informasi paling mendasar tentang biaya transaksi, seperti berbagai biaya dan ongkos.  Seringkali, para penulis makalah ilmiah berdosa yang memilih untuk tidak tunduk pada hal-hal sepele seperti itu.  Menemukan strategi yang sangat menguntungkan dalam kondisi ideal tanpa biaya sangat mudah.  Masalahnya adalah bahwa ketika berdagang dalam kondisi nyata, strategi seperti itu bisa sangat tidak menguntungkan.  Sangat penting untuk memperhitungkan spread, situasi pasar, berbagai biaya, kelesuan (dalam transaksi dengan aset yang sangat fluktuatif, harga transaksi yang sebenarnya mungkin sedikit berbeda dari yang diharapkan ketika menempatkan aplikasi - baik dalam arah yang menguntungkan maupun yang negatif). </li></ul><br>  Ada juga masalah lain yang tidak sering dibahas, tetapi tetap sangat penting untuk menciptakan backtester yang berkualitas.  Diantaranya adalah: <br><br><ul><li>  <b>Data OHLC</b> adalah informasi tentang harga pembukaan, harga tertinggi dari instrumen keuangan selama sesi perdagangan, nilai terendah dan harga penutupan periode perdagangan (grafik buka-tinggi-rendah-tutup, OHLC).  Biasanya diimpor dari sumber seperti Yahoo Finance.  Dalam hal ini, bisa jadi kombinasi dari berbagai umpan data.  Ini berarti bahwa mendapatkan nilai ekstrem (termasuk harga Tinggi dan Rendah) untuk sistem perdagangan waktu nyata akan sulit.  Ini juga perlu diperhitungkan dalam model perdagangan. </li><li>  <b>Batasan kapasitif</b> - Backtesting menggoda untuk menggunakan persediaan uang tanpa batas.  Pada kenyataannya, jumlah dana yang tersedia untuk perdagangan selalu terbatas (seperti jumlah dana pinjaman yang dimungkinkan untuk perdagangan margin).  Penting juga untuk tidak melupakan volume perdagangan harian rata-rata (ADV), terutama untuk stok rendah likuiditas, ketika ada risiko tinggi bahwa sistem perdagangan akan menyebabkan perubahan nyata dalam harga.  Efek pasar ini juga harus dipertimbangkan. </li><li>  <b>Pemilihan patokan</b> - perlu untuk menjawab pertanyaan apakah patokan dipilih secara tepat dengan mana strategi yang diuji akan dibandingkan.  Misalnya, jika Anda berdagang komoditas berjangka yang netral dengan indeks S &amp; P500, apakah layak menggunakan indeks ini sebagai patokan?  Sangat mungkin bahwa sekeranjang dana komoditas lain akan menjadi pilihan yang lebih tepat. </li><li>  <b>Ketegaran</b> - jika Anda mengubah waktu mulai strategi selama backtest, seberapa banyak ini mempengaruhi hasilnya?  Untuk strategi jangka panjang, waktu mulai pekerjaan mereka seharusnya tidak memengaruhi produktivitas secara serius - tidak masalah jika tes ulang dimulai pada hari Senin atau Kamis.  Jika terlalu sensitif terhadap kondisi awal, ini berarti bahwa tidak ada cara untuk memprediksi kemungkinan produktivitasnya pada awal perdagangan nyata. </li><li>  <b>Pelatihan ulang dan variasi</b> - kami telah menyentuh masalah pelatihan ulang di atas, tetapi ini adalah masalah yang lebih luas yang melekat dalam semua metode pembelajaran mesin yang diawasi.  Masalah ini hanya dapat diselesaikan dengan menggunakan teknik cross-validasi secara cermat.  Dan bahkan dalam kasus ini, seseorang harus sangat berhati-hati ketika mengadaptasi strategi dengan noise dalam set data uji. </li><li>  <b>Toleransi</b> psikologis - psikologi sering diabaikan ketika membuat sistem perdagangan otomatis, karena pengaruhnya harus diminimalkan oleh algoritma.  Namun, orang tetap manusia, bahkan ketika mereka berdagang bukan dengan tangan, tetapi dengan bantuan robot.  Akibatnya, ini dapat mempengaruhi hasil.  Sebagai contoh, jika selama tes mundur penarikan setoran 50% tampaknya risiko yang dapat diterima, maka pada kenyataannya kehilangan setengah nilai aset ternyata menjadi pengalaman yang jauh lebih traumatis.  Tidak mudah untuk menolak tindakan yang tidak direncanakan dalam situasi seperti itu. </li></ul><br>  Itu semua dengan masalah pengujian sejarah, sekarang kita beralih ke deskripsi sistem itu sendiri untuk pengujian semacam itu. <br><br><h2>  Dua jenis penguji punggung </h2><br>  Pertama, pertimbangkan sistem siklik.  Ini adalah jenis backtester paling sederhana yang paling sering dijelaskan dalam berbagai posting blog keuangan. <br><br><h3>  Ulangi Backtest </h3><br>  Mereka bekerja seperti ini - sistem hanya berulang melalui setiap hari perdagangan (atau bar OHLC), membuat perhitungan terkait dengan harga aset yang diinginkan (misalnya, menghitung harga penutupan rata-rata bergerak), dan kemudian melakukan operasi yang sesuai (memasuki posisi panjang atau pendek).  Iterasi lebih lanjut berlanjut.  Dalam prosesnya, informasi tentang kinerja disimpan untuk membangun grafik (kurva ekuitas) sebagai hasilnya. <br>  Ini adalah seperti apa pseudocode dari suatu algoritma seperti: <br><br><pre><code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each trading bar: do_something_with_prices(); buy_sell_or_hold_something(); next_bar();PythonCopy</code> </pre> <br>  Seperti yang Anda lihat, sistem ini sangat sederhana, yang membuat penguji balik seperti itu merupakan pilihan yang sangat baik untuk mendapatkan perkiraan pertama tentang prospek sistem perdagangan. <br><br><h3>  Pro </h3><br>  Cyclic backtester sangat mudah diimplementasikan menggunakan hampir semua bahasa pemrograman, dan melakukannya dengan cepat.  Ini berguna ketika Anda ingin menguji efek dari berbagai parameter. <br><br><h3>  Cons </h3><br>  Kerugian utama adalah hasil yang tidak realistis.  Seringkali dalam backtester siklik bahkan tidak ada fungsi dasar untuk menghitung biaya transaksi, itu harus dilaksanakan secara terpisah.  Yang juga umum digunakan hanya pesanan PASAR. <br><br>  Juga, kemungkinan menggunakan kembali kode untuk pengujian dan sistem produktif sangat minim, jadi Anda harus menulisnya lagi.  Ini meningkatkan kemungkinan kesalahan perangkat lunak. <br><br>  Penguji loopback rentan terhadap kesalahan prediksi.  Mereka harus digunakan secara eksklusif sebagai alat penyaringan untuk menolak strategi yang jelas-jelas tidak berhasil.  Pada saat yang sama, penting untuk tetap sangat skeptis terhadap strategi yang telah menunjukkan hasil yang baik.  Penting untuk diingat bahwa dalam kehidupan nyata, strategi jarang berkinerja lebih baik daripada saat backtest. <br><br><h3>  Sistem Berorientasi Kejadian </h3><br>  Sistem jenis ini berada di sisi berlawanan dari spektrum.  Mereka jauh lebih dekat dengan kenyataan.  Biasanya mereka bekerja di loop sementara besar, di mana "peristiwa" terus-menerus dicari dalam "antrian acara" khusus, termasuk: <br><br><ul><li>  <b>ticks</b> - munculnya data pasar baru; </li><li>  <b>peristiwa pensinyalan</b> - tampilan sinyal perdagangan; </li><li>  <b>pesanan acara</b> - pesanan untuk menyelesaikan transaksi siap dikirim ke sistem broker; </li><li>  <b>acara transaksi</b> - tanda terima dari broker informasi tentang pelaksanaan aplikasi. </li></ul><br>  Ketika suatu peristiwa tertentu dikenali, itu ditransmisikan ke modul yang sesuai dalam infrastruktur sistem perdagangan untuk diproses lebih lanjut dan berpotensi menghasilkan peristiwa baru yang lagi-lagi jatuh ke dalam antrian. <br><br>  Kode pseud dari backtester tersebut adalah sebagai berikut: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> event_queue_isnt_empty(): event = get_latest_event_from_queue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.type == <span class="hljs-string"><span class="hljs-string">"tick"</span></span>: strategy.calculate_trading_signals(event); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.type == <span class="hljs-string"><span class="hljs-string">"signal"</span></span>: portfolio.handle_signal(event); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.type == <span class="hljs-string"><span class="hljs-string">"order"</span></span>: portfolio.handle_order(event); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.type == <span class="hljs-string"><span class="hljs-string">"fill"</span></span>: portfolio.handle_fill(event) sleep(600); <span class="hljs-comment"><span class="hljs-comment"># Sleep for, say, 10 minsPythonCopy</span></span></code> </pre> <br>  Seperti yang Anda lihat, sistem ini sangat tergantung pada modul pemrosesan portofolio - ini adalah jantung nyata dalam sistem yang berorientasi pada peristiwa. <br><br><h3>  Pro </h3><br>  Backtester jenis ini memiliki banyak keunggulan: <br><br><ul><li>  <b>Mengurangi kemungkinan kesalahan peramalan</b> - karena struktur, yang mengasumsikan pengiriman pesan secara bertahap, kesalahan peramalan lebih kecil kemungkinannya terjadi dalam sistem yang berorientasi pada peristiwa, setidaknya di tingkat perdagangan.  Namun, kemungkinan kemunculannya masih dipertahankan, karena kesalahan mungkin terdapat pada model itu sendiri. </li><li>  <b>Kemampuan untuk menggunakan kembali kode</b> - untuk menggunakan strategi dalam perdagangan nyata, Anda hanya perlu mengganti modul pemrosesan data dan mesin eksekusi pesanan.  Deskripsi strategi, modul manajemen risiko dan manajemen posisi, kode untuk menilai produktivitas sistem - semua ini dapat digunakan tanpa perubahan.  Ini mengurangi kemungkinan bug baru. </li><li>  <b>Tingkat portofolio</b> - Strategi yang didorong oleh peristiwa memudahkan untuk berpikir di tingkat portofolio.  Pada akhirnya, ini membuatnya lebih mudah untuk membuat perubahan pada strategi dan mengembangkan metode lindung nilai. </li><li>  <b>Manajemen risiko "Benar"</b> - dalam sistem seperti itu lebih mudah untuk "memodulasi" manajemen risiko.  Seorang trader dapat dengan mudah menggunakan teknik seperti kriteria Kelly, dan juga memasukkan berbagai peringatan, menetapkan batas (misalnya, tentang volatilitas). </li><li>  <b>Penyebaran dan pemantauan jarak jauh</b> - prinsip modular kode penulisan menyederhanakan penyebarannya di cloud atau sesuai dengan skema kolokasi pertukaran. </li></ul><br><h3>  Cons </h3><br>  Keuntungan dari sistem yang berorientasi peristiwa dapat dimengerti, tetapi ada beberapa kelemahan.  Diantaranya adalah: <br><br><ul><li>  <b>Kode kompleks</b> - mengembangkan sistem yang sepenuhnya dicakup oleh pengujian akan membutuhkan waktu berminggu-minggu dan berbulan-bulan dalam mode penuh waktu. </li><li>  <b>Orientasi objek</b> - desain modular sistem memerlukan pendekatan berorientasi objek untuk pemrograman.  Jadi, kita membutuhkan bahasa yang mendukung prinsip-prinsip ini.  Pengujian unit tidak akan menjadi lebih mudah. </li><li>  <b>Ambang entri tinggi</b> - pendatang baru dalam pemrograman tidak akan dapat membuat sistem seperti itu.  Pengalaman teknik yang signifikan akan diperlukan, yang akan memungkinkan untuk berurusan dengan kode penulisan, mengimplementasikan logging, melakukan pengujian unit, menerapkan kontrol versi dan praktik integrasi berkelanjutan. </li><li>  <b>Kecepatan rendah</b> - suatu pendekatan di mana pesan-pesan di dalam sistem ditransmisikan secara berurutan dalam level-levelnya yang berbeda, memperlambat kecepatan eksekusi aplikasi dibandingkan dengan pendekatan siklik yang vektor.  Menghitung berbagai kombinasi parameter dapat memakan waktu. </li></ul><br><h2>  Materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkait</a> pasar keuangan dan saham lainnya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ITI Capital</a> : </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis dan ulasan pasar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kembali ke masa depan: memeriksa kinerja robot dagang menggunakan data historis</a> </li><li>  Event backtesting Python yang dikendalikan oleh langkah demi langkah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5</a> ) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414273/">https://habr.com/ru/post/id414273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414263/index.html">Apakah ada kehidupan di luar Roscosmos? Tinjauan eksplorasi ruang angkasa pribadi Rusia</a></li>
<li><a href="../id414265/index.html">Richard Hamming: Bab 7. Kecerdasan Buatan - II</a></li>
<li><a href="../id414267/index.html">Bagaimana cara mengganti akuntan dengan robot?</a></li>
<li><a href="../id414269/index.html">"20.000 IOPS per node adalah kinerja yang baik dengan latensi 5 ms." Untuk OLTP - no</a></li>
<li><a href="../id414271/index.html">Cara menjinakkan hard drive di laptop dan mencegah parkir dalam 8 detik downtime</a></li>
<li><a href="../id414277/index.html">Manusia, lingkungannya dan internet hal-hal</a></li>
<li><a href="../id414279/index.html">Voting untuk laporan pada pertemuan DIY kedelapan di Grup Mail.Ru (07.07.2018)</a></li>
<li><a href="../id414281/index.html">Pengembangan speedometer sepeda berdasarkan tampilan dari Nokia 3310</a></li>
<li><a href="../id414283/index.html">Cara membedakan cryptocurrency dari non-cryptocurrency</a></li>
<li><a href="../id414285/index.html">Kami menggunakan saklar nirkabel 433MHz untuk mengontrol PC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>