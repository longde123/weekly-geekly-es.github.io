<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóùÔ∏è üìû üëåüèª Einf√ºhrung in ECMAScript 6 (ES-2015) üë©üèº‚Äçü§ù‚Äçüë®üèª ü•§ üë®üèø‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung in ES6 

 Inhaltsverzeichnis 
 1. Vorlagenliterale 
 2. let und const 
 3. Pfeilfunktionsausdr√ºcke 
 4. F√ºr ... von 
 5. Berechnete Eigensc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in ECMAScript 6 (ES-2015)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460741/"><h2>  Einf√ºhrung in ES6 </h2><br><br>  <b>Inhaltsverzeichnis</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Vorlagenliterale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. let und const</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Pfeilfunktionsausdr√ºcke</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. F√ºr ... von</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Berechnete Eigenschaftsnamen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Object.assign ()</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Ruheparameter</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Standardparameter</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9. Destrukturierungsauftrag</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">10. Karte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11. Stellen Sie ein</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12. Klassen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">13. Versprechen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">14. Iteratoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">15. Generatoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">16. Sumbol</a> <br><br><a name="section001"></a><h2>  Vorlagenliterale (Vorlagenzeichenfolgen) </h2><br>  Vorlagenliterale sind Zeichenfolgenliterale, die die Verwendung von Ausdr√ºcken im Inneren erm√∂glichen.  Mit ihnen k√∂nnen Sie mehrzeilige Literale und Zeichenfolgeninterpolation verwenden. <br><br>  Vorlagenliterale sind in Backticks (``) anstelle von Double oder Single eingeschlossen.  Sie k√∂nnen Platzhalter enthalten, die durch ein Dollarzeichen und geschweifte Klammern ($ {expression}) gekennzeichnet sind.  Substitutionsausdr√ºcke und der Text zwischen ihnen werden an die Funktion √ºbergeben.  Standardm√§√üig verkettet die Funktion einfach alle Teile zu einer Zeichenfolge.  Wenn vor der Zeile ein Ausdruck steht (hier ist es ein Tag), wird die Vorlagenzeile als "Tag-Vorlage" bezeichnet.  In diesem Fall wird der Tag-Ausdruck (normalerweise eine Funktion) mit dem verarbeiteten Vorlagenliteral aufgerufen, das Sie vor der Ausgabe √§ndern k√∂nnen.  Geben Sie den Backslash \ an, um das Backquote in Vorlagenliteralen zu umgehen. <br><a name="habracut"></a><br>  <b>Mehrzeilige Literale</b> <br>  Zeilenumbruchzeichen sind Teil von Platzhalterliteralen.  Bei Verwendung regul√§rer Zeichenfolgen w√ºrde das Einf√ºgen von Wraps die folgende Syntax erfordern: <br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'string text line 1\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'string text line 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br>  Gleiches gilt f√ºr die Verwendung von Vorlagenliteralen: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`string text line 1 string text line 2`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br><br>  <b>Ausdrucksinterpolation</b> <br>  Um Ausdr√ºcke in regul√§re Zeichenfolgen einzuf√ºgen, m√ºssten Sie die folgende Syntax verwenden: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Fifteen is '</span></span> + (a + b) + <span class="hljs-string"><span class="hljs-string">' and not '</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> * a + b) + <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <br><br>  Mit Hilfe von Vorlagenliteralen k√∂nnen Sie jetzt "syntaktischen Zucker" verwenden, wodurch solche Substitutionen besser lesbar werden: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fifteen is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a + b}</span></span></span><span class="hljs-string"> and not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> * a + b}</span></span></span><span class="hljs-string">.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <cut></cut><br><br>  <b>Verschachtelte Vorlagen</b> <br>  Manchmal ist das Verschachteln eines Musters die k√ºrzeste und vielleicht besser lesbare M√∂glichkeit, eine Zeichenfolge zu erstellen.  F√ºgen Sie einfach eine weitere in die hinter zitierte Vorlage ein und verpacken Sie sie in die $ {} -Ersetzung.  Wenn der Ausdruck beispielsweise true ist, k√∂nnen Sie ein Vorlagenliteral zur√ºckgeben. <br>  In ES5: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classes = <span class="hljs-string"><span class="hljs-string">'header'</span></span> classes += (isLargeScreen() ? <span class="hljs-string"><span class="hljs-string">''</span></span> : item.isCollapsed ? <span class="hljs-string"><span class="hljs-string">' icon-expander'</span></span> : <span class="hljs-string"><span class="hljs-string">' icon-collapser'</span></span>);</code> </pre> <br>  In ES2015 mit Vorlagenliteralen ohne Verschachtelung: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : (item.isCollapsed ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-expander'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-collapser'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br>  In ES2015 mit verschachtelten Vorlagenliteralen: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`icon-</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.isCollapsed ? </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'expander'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"> : </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'collapser'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br><cut></cut><br>  <b>Tag-Vorlagen</b> <br>  Eine erweiterte Form von Vorlagenliteralen wird mit Vorlagen versehen.  Mit ihnen k√∂nnen Sie Vorlagenliterale mithilfe einer Funktion analysieren.  Das erste Argument einer solchen Funktion enth√§lt ein Array von Zeichenfolgenwerten, und der Rest enth√§lt Ausdr√ºcke aus Substitutionen.  Infolgedessen sollte die Funktion die zusammengesetzte Zeichenfolge zur√ºckgeben (oder etwas v√∂llig anderes, wie sp√§ter gezeigt wird).  Der Name der Funktion kann beliebig sein. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings, personExp, ageExp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "That " var str1 = strings[1]; // " is a " // ,     // (  )    , //    (""),    . // var str2 = strings[2]; var ageStr; if (ageExp &gt; 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } //     ,     return `${str0}${personExp}${str1}${ageStr}`; } var output = myTag`That ${ person } is a ${ age }`; console.log(output);// That Mike is a youngster</span></span></code> </pre> <br>  Die Tag-Funktion ist nicht erforderlich, um eine Zeichenfolge zur√ºckzugeben. <br><cut></cut><br>  <b>Rohe Linien</b> <br>  Mit der speziellen Raw-Eigenschaft, die f√ºr das erste Argument der Tag-Vorlage verf√ºgbar ist, k√∂nnen Sie die Zeichenfolge ohne Interpretation in der Form abrufen, in der sie eingegeben wurde. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.raw[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } tag<span class="hljs-string"><span class="hljs-string">`string text line 1 \\n string text line 2`</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "string text line 1 \\n string text line 2", //  'n'    '\'</span></span></code> </pre> <br>  Dar√ºber hinaus gibt es eine String.raw () -Methode, die genau dieselbe Quellzeichenfolge zur√ºckgibt, die die Standardvorlagenfunktion und die Zeichenfolgenverkettung zusammen zur√ºckgeben w√ºrden. <br><cut></cut><br>  In ECMAScript 2016 folgen getaggte Vorlagen den Regeln f√ºr das Escapezeichen der folgenden Zeichen: <br><ul><li>  Unicode-Zeichen, die mit "\ u" beginnen, z. B. \ u00A9 </li><li>  Unicode-Codepunkte, die mit "\ u {}" beginnen, z. B. \ u {2F804} </li><li>  hexadezimale Zeichendarstellungen, die mit "\ x" beginnen, z. B. \ xA9 </li><li>  Oktale Darstellungen von Zeichen, die mit "\" beginnen, z. B. \ 251 </li></ul><br><cut></cut><br><a name="section002"></a><h2>  let und const </h2><br>  Der Umfang der Variablen, die durch die Schl√ºsselw√∂rter let und const deklariert werden, ist der Block, in dem sie deklariert werden, und alles unter den Bl√∂cken.  In diesem Fall √§hnelt die Funktionsweise der let-Direktive der der var-Direktive.  Der Hauptunterschied besteht darin, dass der Umfang der von der var-Direktive deklarierten Variablen die gesamte Funktion ist, in der sie deklariert ist.  Zus√§tzlich zu Variablen kann der Wert von Konstanten weder durch eine neue Zuweisung ge√§ndert noch neu definiert werden.  Wenn Sie eine Variable mit dem Schl√ºsselwort const deklarieren, m√ºssen Sie den Zuweisungsoperator verwenden, um den Wert der Konstante festzulegen. <br><br>  Globale Konstanten werden im Gegensatz zu var-Variablen nicht zu Eigenschaften des Fensterobjekts. <br>  Die Initialisierung einer Konstante ist erforderlich. <br>  Sie m√ºssen gleichzeitig mit der Deklaration einen Wert angeben (der Punkt ist, dass dieser Wert dann nicht mehr ge√§ndert werden kann). <br>  Durch das Deklarieren von Variablen mit dem Schl√ºsselwort const wird eine Konstante (eine neue benannte Referenz auf einen Speicherbereich) erstellt, die schreibgesch√ºtzt ist. <br>  Dies bedeutet nicht, dass der angegebene Wert unver√§ndert bleibt, aber es bedeutet, dass der Bezeichner nicht neu zugewiesen werden kann.  Wenn beispielsweise eine Konstante auf ein Objekt zeigt, kann das Objekt selbst ge√§ndert werden. <br>  Namen von Konstanten d√ºrfen nicht mit Namen von Funktionen oder Variablen desselben Bereichs √ºbereinstimmen. <cut></cut><br><br>  Ein Beispiel f√ºr den Unterschied zwischen globalem und Blockbereich: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">//SyntaxError   a     if if (true) var b = 5; console.log(b); //5   b     }</span></span></code> </pre> <br><br><a name="section003"></a><h2>  Pfeilfunktionsausdr√ºcke </h2><br>  Pfeilfunktionsausdr√ºcke haben eine k√ºrzere Syntax als funktionale Ausdr√ºcke und sind lexikalisch an den Wert von this gebunden (aber nicht an ihre eigenen Argumente, super oder new.target).  Der Ausdruck von Pfeilfunktionen erm√∂glicht es Ihnen nicht, einen Namen anzugeben. Daher sind Pfeilfunktionen anonym, sofern sie nichts zugewiesen sind. <br><cut></cut><br>  <b>Grundlegende Syntax</b> <br><pre> <code class="javascript hljs">(param1, param2, ‚Ä¶, paramN) =&gt; { statements } (param1, param2, ‚Ä¶, paramN) =&gt; expression <span class="hljs-comment"><span class="hljs-comment">// : (param1, param2, ‚Ä¶, paramN) =&gt; { return expression; } //       : (singleParam) =&gt; { statements } singleParam =&gt; { statements } //       : () =&gt; { statements } () =&gt; expression // : () =&gt; { return expression; }</span></span></code> </pre> <br><br>  <b>Erweiterte Syntax</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     params =&gt; ({foo: bar}) // Rest       (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, ‚Ä¶, paramN = defaultValueN) =&gt; { statements } //    var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6</span></span></code> </pre> <br>  Weitere Informationen zu Pfeilfunktionen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><a name="section004"></a><h2>  F√ºr ... von </h2><br>  Die for ... of-Anweisung f√ºhrt eine Schleife durch iterierbare Objekte (einschlie√ülich Array, Map, Set, ein Objekt mit Argumenten und dergleichen) aus und ruft bei jedem Iterationsschritt die Operatoren f√ºr jeden Wert aus verschiedenen Eigenschaften des Objekts auf. <br><cut></cut><br>  Warum sollte eine for ... in-Schleife NICHT zum Iterieren verwendet werden?  Denn je nach Engine kann JavaScript in zuf√§lliger Reihenfolge iterieren, was zu unvorhersehbaren Ergebnissen f√ºhren kann.  Wenn sich eine Eigenschaft in einer Iteration √§ndert und sich dann erneut √§ndert, ist ihr Wert in der Schleife der letzte Wert.  Eine Eigenschaft, die vor Erreichen des Zyklus gel√∂scht wurde, nimmt nicht daran teil.  Eigenschaften, die Objekten in der Schleife hinzugef√ºgt wurden, k√∂nnen √ºbersprungen werden.  Im Allgemeinen ist es am besten, w√§hrend der Iteration keine Eigenschaft zum Objekt hinzuzuf√ºgen, zu √§ndern oder zu l√∂schen, wenn Sie sie noch nicht √ºbergeben haben.  Es gibt keine Garantie daf√ºr, dass die hinzugef√ºgte Eigenschaft vom Zyklus besucht, nach den √Ñnderungen ge√§ndert und nach dem L√∂schen gel√∂scht wird.  Dar√ºber hinaus ist die iterative Variable eine Zeichenfolge und keine Zahl. Wenn Sie also Berechnungen mit der Variablen durchf√ºhren m√∂chten, m√ºssen Sie die Zeichenfolgen verketten, anstatt sie hinzuzuf√ºgen.  Um logische Fehler zu vermeiden, sollten Sie es nicht verwenden! <br><br>  Im Gegensatz zur for ... of-Schleife gibt die for ... in-Schleife alle aufgez√§hlten Eigenschaften zur√ºck, einschlie√ülich derjenigen mit nicht ganzzahligen und geerbten Namen. <br><br>  <b>F√ºr ... der Schleifensyntax</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) <span class="hljs-comment"><span class="hljs-comment">//for ( of ) arr[i] = "something value"</span></span></code> </pre> <br>  Beispiele: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterable = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]; iterable.foo = <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">// 0, 1, 2, "foo", "arrCustom", "objCustom" for (let i in iterable) { if (iterable.hasOwnProperty(i)) console.log(i); //  0, 1, 2, "foo" } for (let i of iterable) console.log(i); // 3, 5, 7</span></span></code> </pre><cut></cut><br>  Jedes Objekt erbt die objCustom-Methode und jedes Array erbt die arrCustom-Methode, indem es sie in Object.prototype und Array.prototype erstellt.  Das iterierbare Objekt erbt die Methoden objCustom und arrCustom aufgrund der Vererbung von Prototypen. <br><br>  Die Schleife zeigt nur die aufgez√§hlten Eigenschaften des iterierbaren Objekts in der Reihenfolge an, in der sie erstellt wurden.  Die Werte 3, 5, 7 und Hallo werden nicht gedruckt, da sie nicht aufz√§hlbar sind.  Die Namen von Eigenschaften und Methoden werden angezeigt, z. B. arrCustom und objCustom. <br><br>  Die Schleife √§hnelt der vorherigen, verwendet jedoch hasOwnProperty (), um zu √ºberpr√ºfen, ob diese Eigenschaft des Objekts eine eigene oder eine geerbte ist.  Es werden nur eigene Eigenschaften angezeigt.  Die Namen 0, 1, 2 und foo geh√∂ren nur zur Instanz des Objekts (nicht vererbt).  Die Methoden arrCustom und objCustom werden nicht ausgegeben, da sie vererbt werden. <br><br>  Diese Schleife umgeht iterierbar und zeigt die Werte des iterierbaren Objekts an, die in der Methode des Iterierens definiert sind, d. H.  nicht die Eigenschaften des Objekts, sondern die Werte des Arrays 3, 5, 7. <br><br><a name="section005"></a><h2>  Berechnete Eigenschaftsnamen </h2><br>  Die Syntax zum Deklarieren von Objekten und ihren Elementen unterst√ºtzt berechnete Eigenschaftsnamen.  Auf diese Weise k√∂nnen Sie den Klammern [] einen Ausdruck hinzuf√ºgen, der als Name der Eigenschaft ausgewertet wird.  Es √§hnelt Vorlagenliteralen. <br><br>  <b>Beispiel f√ºr berechnete Namen:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { [<span class="hljs-string"><span class="hljs-string">"a"</span></span> + (<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span>)]: { [<span class="hljs-string"><span class="hljs-string">"some"</span></span> + <span class="hljs-string"><span class="hljs-string">"string"</span></span>]: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span>]: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-string"><span class="hljs-string">`hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a()}</span></span></span><span class="hljs-string">`</span></span>]: a() } }</code> </pre> <br><cut></cut><br><br><a name="section006"></a><h2>  Object.assign () </h2><br>  Die Object.assign () -Methode wird verwendet, um die Werte aller eigenen aufgez√§hlten Eigenschaften von einem oder mehreren Quellobjekten in das Zielobjekt zu kopieren.  Nach dem Kopieren wird das Zielobjekt zur√ºckgegeben. <br><br>  Die Object.assign () -Methode kopiert nur aufgez√§hlte und native Eigenschaften von den Quellobjekten in das Zielobjekt.  Es verwendet die interne [[Get]] - Methode f√ºr die Quellobjekte und die interne [[Set]] - Methode f√ºr das Zielobjekt, ruft also auch Getter und Setter auf.  Aus diesem Grund werden Eigenschaften zugewiesen, anstatt einfach neue Eigenschaften zu kopieren oder zu definieren.  Dieses Verhalten kann dazu f√ºhren, dass die Methode nicht zum Einf√ºgen neuer Eigenschaften in den Prototyp geeignet ist, wenn die eingef√ºgten Quellobjekte Getter enthalten.  Stattdessen sollten die Methoden Object.getOwnPropertyDescriptor () und Object.defineProperty () verwendet werden, um Prototypen von Eigenschaftsdefinitionen einschlie√ülich eines Zeichens ihrer Aufz√§hlung zu kopieren. <br><br>  Die Eigenschaften der Typen von String und Symbol werden kopiert. <br><br>  Im Fehlerfall, wenn die Eigenschaft beispielsweise nicht beschreibbar ist, wird eine TypeError-Ausnahme ausgel√∂st und das Zielobjekt bleibt unver√§ndert. <br><br>  Beachten Sie, dass die Object.assign () -Methode keine Ausnahme ausl√∂st, wenn die Anfangswerte null oder undefiniert sind. <br><br>  <b>Beispiel: Klonen eines Objekts</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> copy = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(copy); <span class="hljs-comment"><span class="hljs-comment">// { a: 1 }</span></span></code> </pre> <br>  <b>Beispiel: Objekte zusammenf√ºhren</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o1 = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o2 = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o3 = { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(o1, o2, o3); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { a: 1, b: 2, c: 3 } console.log(o1); // { a: 1, b: 2, c: 3 },     .</span></span></code> </pre> <br><br><a name="section007"></a><h2>  Ruheparameter </h2><br>  Die Syntax der verbleibenden Parameter der Funktion erm√∂glicht es Ihnen, eine unbegrenzte Anzahl von Argumenten in Form eines Arrays darzustellen. <br><br>  Wenn das zuletzt genannte Funktionsargument ein Pr√§fix ... hat, wird es automatisch zu einem Array mit Elementen von 0 bis theArgs.length entsprechend der tats√§chlichen Anzahl der an die Funktion √ºbergebenen Argumente. <br><br>  <b>Syntax</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...theArgs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  <b>Ein Beispiel f√ºr die Verwendung der Syntax der verbleibenden Parameter:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...c</span></span></span><span class="hljs-function">) </span></span>{} name (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,)</code> </pre> <br>  In diesem Beispiel ist a = 0 b = 1 c [0] = 2 c [1] = 3 <br>  Wenn der verbleibende Parameter nicht √ºbergeben wird, handelt es sich um ein leeres Array (im Gegensatz zu normalen Parametern ist es niemals undefiniert). <br><br>  Diese Syntax kann nicht nur in Funktionsargumenten verwendet werden, sondern auch an anderen Stellen, beispielsweise zum Kopieren und Kombinieren von Arrays: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = [ ...a, ...b ]; <span class="hljs-comment"><span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span></code> </pre> <br><br><a name="section008"></a><h2>  Standardparameter </h2><br>  Mit Standardparametern k√∂nnen Sie formale Funktionsparameter auf Standardwerte setzen, wenn die Funktion ohne Argumente aufgerufen wird oder wenn der Parameter explizit undefiniert √ºbergeben wird. <br><br>  In JavaScript nehmen die Parameter einer Funktion, deren Werte beim Aufruf nicht √ºbergeben werden, den undefinierten Standardwert an.  In einigen F√§llen kann es jedoch n√ºtzlich sein, einen anderen Standardwert festzulegen.  In solchen F√§llen sind die Standardeinstellungen vorgesehen. <br><br>  Der Standardwert wird einem formalen Parameter nur zugewiesen, wenn w√§hrend eines Funktionsaufrufs der Wert f√ºr diesen Parameter nicht oder undefiniert explizit √ºbergeben wurde. <br><br>  <b>Ein Beispiel f√ºr die Verwendung von Standardparametern:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFun()); <span class="hljs-comment"><span class="hljs-comment">// 25</span></span></code> </pre> <cut></cut><br><br><a name="section009"></a><h2>  Zerst√∂rungsauftrag </h2><br>  Mit der Destrukturierungszuweisungssyntax in JavaScript-Ausdr√ºcken k√∂nnen Sie Daten aus Arrays oder Objekten mithilfe einer Syntax abrufen, die der Deklaration eines Arrays oder von Literalen in einem Objekt √§hnelt. <br><br>  Objekt- oder Arraydeklarationsausdr√ºcke bieten eine einfache M√∂glichkeit, ein homogenes Datenpaket zu erstellen.  Wenn Sie ein solches Paket erstellen, haben Sie die M√∂glichkeit, es auf jede m√∂gliche Weise zu verwenden.  Sie k√∂nnen es auch in Funktionen zur√ºckgeben. <br><br>  Eine der wichtigsten M√∂glichkeiten zur Verwendung der destruktiven Zuweisung besteht darin, die Datenstruktur mit einem Operator zu lesen, obwohl Sie neben dieser Funktion noch viele andere Verwendungsm√∂glichkeiten finden k√∂nnen. <br><br>  <b>Beispiel f√ºr eine destruktive Zuordnung:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, rest; [a, b] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(b); // 2 [a, b, ...rest] = [1, 2, 3, 4, 5]; console.log(a); // 1 console.log(b); // 2 console.log(rest); // [3, 4, 5] ({a, b} = {a:1, b:2}); console.log(a); // 1 console.log(b); // 2</span></span></code> </pre> <br>  Weitere Beispiele finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><a name="section010"></a><h2>  Karte </h2><br>  Map - Ein Objekt, das Schl√ºssel-Wert-Paare enth√§lt und die Einf√ºgereihenfolge beibeh√§lt.  Jeder Wert (sowohl Objekte als auch Grundelemente) kann als Schl√ºssel verwendet werden. <br><br>  <b>Ein Beispiel:</b> <cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, keyString = <span class="hljs-string"><span class="hljs-string">"a string"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, "value associated with 'a string'"); myMap.set(keyObj, "value associated with keyObj"); myMap.set(keyFunc, "value associated with keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // "value associated with 'a string'" myMap.get(keyObj); // "value associated with keyObj" myMap.get(keyFunc); // "value associated with keyFunc" myMap.get("a string"); // "value associated with 'a string'" //   keyString === 'a string' myMap.get({}); // undefined,   keyObj !== {} myMap.get(function() {}) // undefined,   keyFunc !== function () {}</span></span></code> </pre> <br>  <b>Unterschied der Karte vom Objekt:</b> <br><br><ul><li>  Objektschl√ºssel sind Linien und Symbole, w√§hrend jeder Wert ein Kartenschl√ºssel sein kann, einschlie√ülich Funktionen, Objekten und Grundelementen. </li><li>  Im Gegensatz zu Objekten sind die Schl√ºssel in Map geordnet.  W√§hrend der Map-Iteration werden die Schl√ºssel daher in der Einf√ºgereihenfolge zur√ºckgegeben. </li><li>  Sie k√∂nnen die Anzahl der Elemente in einer Karte mithilfe der size-Eigenschaft leicht ermitteln, w√§hrend die Anzahl der Elemente in einem Objekt nur manuell bestimmt werden kann. </li><li>  Map ist ein iterierbares Objekt und kann direkt iteriert werden, w√§hrend das Objekt den manuellen Empfang der Liste der Schl√ºssel und ihrer Iteration erfordert. </li><li>  Das Objekt hat einen Prototyp und daher einen Standardschl√ºsselsatz, der sich bei Unachtsamkeit mit Ihren Schl√ºsseln √ºberschneiden kann.  Seit der Ver√∂ffentlichung von ES5 kann dies mit map = Object.create (null) ge√§ndert werden. </li><li>  Map kann bei h√§ufigem Hinzuf√ºgen oder Entfernen von Schl√ºsseln eine bessere Leistung erzielen. </li></ul><cut></cut><br>  <b>Eigenschaften und Methoden:</b> <br><br><ul><li>  Map.prototype.size - Gibt die Anzahl der Schl√ºssel / Wert-Paare auf einer Karte zur√ºck </li><li>  Map.prototype.set (Schl√ºssel, Wert) - F√ºgt Map das √ºbergebene Schl√ºssel / Wert-Paar hinzu.  Wenn der angegebene Schl√ºssel bereits vorhanden ist, wird er mit dem neuen Wert √ºberschrieben. </li><li>  Map.prototype.get (Schl√ºssel) - Gibt den Wert des √ºbergebenen Schl√ºssels zur√ºck.  Wenn kein Schl√ºssel vorhanden ist, wird undefined zur√ºckgegeben </li><li>  Map.prototype.has (Schl√ºssel) - Gibt true zur√ºck, wenn der √ºbergebene Schl√ºssel vorhanden ist, und false, wenn dies nicht der Fall ist </li><li>  Map.prototype.delete (Schl√ºssel) - L√∂scht das angegebene Schl√ºssel-Wert-Paar und gibt true zur√ºck.  Gibt false zur√ºck, wenn der Schl√ºssel nicht vorhanden ist. </li><li>  Map.prototype.clear () - Entfernt alle Schl√ºssel / Wert-Paare aus Map </li><li>  Map.prototype.keys () - Gibt f√ºr jedes Element einen Iterator von Schl√ºsseln auf einer Map zur√ºck </li><li>  Map.prototype.values ‚Äã‚Äã() - Gibt f√ºr jedes Element einen Iterator von Werten auf der Map zur√ºck </li><li>  Map.prototype.entries () - Gibt f√ºr jedes Element einen Iterator des Arrays [Schl√ºssel, Wert] auf Map zur√ºck </li></ul><cut></cut><br><br><a name="section011"></a><h2>  Stellen Sie ein </h2><br>  Erm√∂glicht das Speichern eindeutiger Werte eines beliebigen Typs, sowohl von Grundelementen als auch von anderen Objekttypen. <br><br>  Festgelegte Objekte stellen Sammlungen von Werten dar, die Sie in der Reihenfolge durchlaufen k√∂nnen, in der die Elemente eingef√ºgt werden.  Der Wert eines Elements in Set kann nur in einer Instanz vorhanden sein, wodurch seine Eindeutigkeit in der Set-Auflistung sichergestellt wird. <br><br>  Eigenschaften und Instanzmethoden festgelegt <br><ul><li>  size - Gibt die Anzahl der Elemente im Set-Objekt zur√ºck. </li><li>  add (Wert) - F√ºgt dem Set-Objekt ein neues Element mit dem angegebenen Wert hinzu.  Gibt ein Set-Objekt zur√ºck. </li><li>  clear () - Entfernt alle Elemente aus dem Set-Objekt. </li><li>  delete (value) - L√∂scht das dem Wert zugeordnete Element und gibt den Wert zur√ºck, der (value) zuvor zur√ºckgegeben hat.  has (value) gibt sp√§ter false zur√ºck. </li><li>  entry () - Gibt ein neues Iterator-Objekt zur√ºck, das ein Array von [Wert, Wert] f√ºr jedes Element im Set-Objekt in Einf√ºgereihenfolge enth√§lt.  Dies wird √§hnlich wie das Map-Objekt gespeichert, sodass jeder Eintrag hier den gleichen Wert f√ºr seinen Schl√ºssel und Wert hat. </li><li>  forEach (callbackFn [, thisArg]) - Ruft callbackFn einmal f√ºr jeden im Set-Objekt vorhandenen Wert in Einf√ºgereihenfolge auf.  Wenn thisArg f√ºr thisEach angegeben ist, wird es f√ºr diesen R√ºckruf als this-Wert verwendet. </li><li>  has (Wert) - Gibt einen booleschen Wert zur√ºck, der best√§tigt, ob das Element mit dem angegebenen Wert im Set-Objekt vorhanden ist oder nicht. </li><li>  values ‚Äã‚Äã() - Gibt ein neues Iterator-Objekt zur√ºck, das die Werte f√ºr jedes Element im Set-Objekt in Einf√ºgereihenfolge enth√§lt. </li></ul><br>  <b>Verwenden des Set-Objekts</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); mySet.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add("some text"); // Set { 1, 5, 'some text' } var o = {a: 1, b: 2}; mySet.add(o); mySet.add({a: 1, b: 2}); //  o    ,      mySet.has(1); // true mySet.has(3); // false, 3     set mySet.has(5); // true mySet.has(Math.sqrt(25)); // true mySet.has("Some Text".toLowerCase()); // true mySet.has(o); // true mySet.size; // 5 mySet.delete(5); //  5  set mySet.has(5); // false, 5   mySet.size; // 4,     console.log(mySet); // Set {1, 'some text', Object {a: 1, b: 2}, Object {a: 1, b: 2}}</span></span></code> </pre> <br>  <b>Bypass-Set</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.keys()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.values()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} //(key  value    ) for (let [key, value] of mySet.entries()) console.log(key); //  Set  Array var myArr = Array.from(mySet); // [1, "some text", {"a": 1, "b": 2}] //       HTML  mySet.add(document.body); mySet.has(document.querySelector("body")); // true //   Array  Set   mySet2 = new Set([1,2,3,4]); mySet2.size; // 4 [...mySet2]; // [1,2,3,4] //      var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); //      var difference = new Set([...set1].filter(x =&gt; !set2.has(x))); //   set   forEach mySet.forEach(function(value) { console.log(value); }); // 1 // 2 // 3 // 4</span></span></code> </pre> <br><cut></cut><br><br><a name="section012"></a><h2>  Klassen </h2><br>  Klassen in JavaScript wurden in ECMAScript 2015 eingef√ºhrt und sind syntaktischer Zucker √ºber die Vererbung von Prototypen in JavaScript.  Die Klassensyntax f√ºhrt kein neues objektorientiertes Modell ein, bietet jedoch eine einfachere und intuitivere M√∂glichkeit, Objekte zu erstellen und die Vererbung zu organisieren. <br><br>  Klassen sind eigentlich ‚ÄûSonderfunktionen‚Äú. So wie Sie Funktionen (Funktionsausdr√ºcke und Funktionsdeklarationen) definieren, k√∂nnen Sie Klassen definieren mit: Klassendeklarationen und Klassenausdr√ºcken. <br><br>  Der Unterschied zwischen einer Funktionsdeklaration und einer Klassendeklaration besteht darin, dass eine Funktionsdeklaration angehoben wird, eine Klassendeklaration jedoch nicht.  Daher m√ºssen Sie zuerst Ihre Klasse deklarieren und erst dann damit arbeiten, da sonst eine Ausnahme vom Typ ReferenceError ausgel√∂st wird. <br><cut></cut><br><h4>  Klassenerkl√§rung </h4><br>  Die erste M√∂glichkeit, eine Klasse zu definieren, besteht in einer Klassendeklaration.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie dazu das Schl√ºsselwort class und geben Sie den Klassennamen an (im Beispiel ‚ÄûmyClass‚Äú). </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myClass</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } }</code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite M√∂glichkeit, eine Klasse zu definieren, ist der Klassenausdruck. </font><font style="vertical-align: inherit;">Sie k√∂nnen benannte und namenlose Ausdr√ºcke erstellen. </font><font style="vertical-align: inherit;">Im ersten Fall befindet sich der Name des Klassenausdrucks im lokalen Bereich der Klasse und kann √ºber die Eigenschaften der Klasse selbst und nicht √ºber ihre Instanz abgerufen werden.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var myClass = class { constructor(height, width) { this.height = height; this.width = width; } }; //  var myClass = class myClass { constructor(height, width) { this.height = height; this.width = width; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassenausdr√ºcke unterliegen denselben Hebeproblemen wie Klassendeklarationen! </font></font><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassendeklarationsk√∂rper und Klassenausdr√ºcke werden im strengen Modus ausgef√ºhrt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der strikte Modus √§ndert die Syntax und das Verhalten der Laufzeit. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genauer gesagt ist der strenge Modus durch Folgendes gekennzeichnet:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konvertieren Sie Fehler in Ausnahmen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ñnderungen, die die Berechnung einer Variablen in bestimmten F√§llen der Verwendung ihres Namens vereinfachen; </font></font></li><li> ,  eval  arguments; </li><li> ,   ¬´¬ª JavaScript; </li></ul><br> <b>   </b> <br><ol><li>        . </li><li>     . </li><li> ,      ,  . </li><li>        (           ). </li><li>  ,    ,     .       ,      . </li><li>         .             . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Syntax des Oktalzahlensystems ist verboten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Festlegen von Eigenschaften mit primitiven Werten ist verboten. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachung der Arbeit mit Variablen Der</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> strenge Modus vereinfacht den Vergleich des Namens einer Variablen mit dem Ort ihrer Definition im Code.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung mit ist verboten. </font><font style="vertical-align: inherit;">Das Problem bei ist, dass zur Laufzeit jeder Name innerhalb des Blocks entweder auf eine Eigenschaft des zu verarbeitenden Objekts oder auf eine Variable im umgebenden (oder sogar globalen) Kontext verweisen kann - es ist unm√∂glich, dies vorher zu wissen. </font><font style="vertical-align: inherit;">Eine einfache Alternative mit besteht bereits darin, das Objekt einer Variablen mit einem Kurznamen zuzuweisen und dann auf die gew√ºnschte Eigenschaft als Eigenschaft dieser Variablen zuzugreifen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eval () im strengen Modus f√ºgt dem umgebenden Kontext keine neuen Variablen hinzu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist verboten, einfache Namen zu l√∂schen. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachung von Auswertung und Argumenten Der</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> strikte Modus reduziert die Anzahl der Kuriosit√§ten im Verhalten von Argumenten und Auswertung, die beide eine gewisse Menge Magie in regul√§ren Code mischen. </font><font style="vertical-align: inherit;">Eval f√ºgt also Variablen hinzu oder entfernt sie und √§ndert ihre Werte. Die Argumentvariable kann Sie mit ihren indizierten Eigenschaften √ºberraschen, die Referenzen (Synonyme) f√ºr benannte Funktionsargumente sind.</font></font><cut></cut><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Schl√ºsselw√∂rter eval und Argumente k√∂nnen nicht √ºberschrieben oder ge√§ndert werden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Felder des Argumentobjekts sind nicht den benannten Funktionsargumenten zugeordnet, sondern sind ihre duplizierten Kopien der Werte. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eigenschaft rules.callee wird nicht unterst√ºtzt. </font><font style="vertical-align: inherit;">Im regul√§ren Code bezieht sich die Eigenschaft rules.callee auf die Funktion selbst, f√ºr deren Aufruf das Argumentobjekt erstellt wurde.</font></font></li></ol><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Sicheres" JavaScript</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einige Websites bieten Benutzern die M√∂glichkeit, JavaScript zu schreiben, das auf der Website im Auftrag anderer Benutzer ausgef√ºhrt wird. </font><font style="vertical-align: inherit;">In Browsern hat JavaScript m√∂glicherweise Zugriff auf private Informationen, was eine Sicherheitsl√ºcke in JavaScript darstellt.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der an die Funktion √ºbergebene Wert wird im strengen Modus nicht in das Objekt umgewandelt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist nicht m√∂glich, den JavaScript-Stack √ºber die grundlegenden ECMAScript-Erweiterungen auszuf√ºhren. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In Funktionen bietet die Eigenschaft rules keinen Zugriff mehr auf Variablen, die innerhalb der Funktion erstellt wurden. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen zum Strict-Modus finden </font><font style="vertical-align: inherit;">Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECMAScript 5.1- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Spezifikation</font></a><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Mozilla.</font></font><br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruktoren </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Konstruktor ist eine spezielle Methode zum Erstellen und Initialisieren von Objekten, die mit der Klasse erstellt wurden. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.name); <span class="hljs-comment"><span class="hljs-comment">// Outputs 'Robert'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen neuer Objekte aus der Klasse wird Konstruktor () gestartet, der zum Initialisieren der Objekte erforderlich ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer Klasse namens Konstruktor kann es nur eine Methode geben. </font><font style="vertical-align: inherit;">Wenn die Klasse mehr als einen Konstruktor enth√§lt, wird eine SyntaxError-Ausnahme ausgel√∂st. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schl√ºsselwort super kann im Konstruktor verwendet werden, um den Konstruktor der √ºbergeordneten Klasse aufzurufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie keine Konstruktormethode definiert haben, wird der Standardkonstruktor verwendet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr Basisklassen lautet der Standardkonstruktor:</font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºr abgeleitete Klassen lautet der Standardkonstruktor: </font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(...args) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(...args); }</code> </pre> <br><cut></cut><br><h4>  Methoden </h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax der Methodendeklaration:</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { property([parameters]) {}, get property() {}, set property(value) {}, * generator() {} };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abk√ºrzung f√ºr Generatormethoden</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { * g() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> index++; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = obj.g(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(it.next().value); // 1</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Methodendefinitionen au√üer Generatormethoden k√∂nnen keine Konstruktoren sein und l√∂sen einen TypeError aus, wenn Sie versuchen, sie zu instanziieren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnete Eigenschaftsnamen</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { [<span class="hljs-string"><span class="hljs-string">"foo"</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>](){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo2()); <span class="hljs-comment"><span class="hljs-comment">// 2 };</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schl√ºsselwort static definiert statische Methoden f√ºr eine Klasse. </font><font style="vertical-align: inherit;">Statische Methoden werden aufgerufen, ohne ihre Klasse zu instanziieren, und k√∂nnen nicht f√ºr Instanzen der Klasse aufgerufen werden.</font></font><br><cut></cut><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax von Gettern und Setzern</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } get Name() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } set Name(newName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(newName) != <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Name is not a string!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; <span class="hljs-comment"><span class="hljs-comment">// Robert } } var robert = new Student('robert'); robert.Name = "Robert"; console.log(robert.Name);</span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setter - Erforderlich f√ºr die Validierung geschriebener Parameter (wie im obigen Beispiel) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter - Wird ben√∂tigt, um Eigenschaften zu erhalten (obwohl sie direkt erhalten werden k√∂nnen). </font><font style="vertical-align: inherit;">Kann keine Argumente haben</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In ES6 ist keine Kapselung integriert, Sie k√∂nnen sie jedoch selbst organisieren. </font></font> Zum Beispiel so: <br><cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Student = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateProps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, Age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-comment"><span class="hljs-comment">// public privateProps.set(this, {age: Age}); // private } get Age() { return privateProps.get(this).age; } set Age (newAge) { privateProps.set(this, {age: newAge}); } } return Person; })(); var robert = new Student('Robert', 19); robert.Age = 20; console.log(robert.Age); // 20</span></span></code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vererbung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Schl√ºsselwort extens wird in Klassendeklarationen und Klassenausdr√ºcken verwendet, um eine Klasse zu erstellen, die ein untergeordnetes Element einer anderen Klasse ist. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } sayAge () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (name, age) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(age); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayFull () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello my name is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.sayAge()}</span></span></span><span class="hljs-string"> years old`</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">"Robert"</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.sayFull()); <span class="hljs-comment"><span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Konstruktor wird das Schl√ºsselwort super () als Funktion verwendet, die den √ºbergeordneten Konstruktor aufruft. </font><font style="vertical-align: inherit;">Es muss vor dem ersten Aufruf des Schl√ºsselworts this im Hauptteil des Konstruktors aufgerufen werden. </font><font style="vertical-align: inherit;">Das Schl√ºsselwort super kann auch zum Aufrufen von Funktionen des √ºbergeordneten Objekts verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Methoden der √ºbergeordneten Klasse in der untergeordneten Klasse √ºberschreiben, werden die Methoden der untergeordneten Klasse standardm√§√üig aufgerufen. Sie k√∂nnen die Methoden der √ºbergeordneten Klasse jedoch explizit mit der Funktion super () aufrufen.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } displayName(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name.length; } } <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); } displayName() { <span class="hljs-comment"><span class="hljs-comment">//     return [this.name, super.displayName()]; } } var Obj = new obj_2("obj_2"); console.log(Obj.displayName()); // Array [ "obj_2", 5 ]</span></span></code> </pre><cut></cut><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweitern von Inline-Objekten mit Erweitern In</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diesem Beispiel wird ein Inline-Datumsobjekt erweitert.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } getFormattedDate() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'Jan'</span></span>, <span class="hljs-string"><span class="hljs-string">'Feb'</span></span>, <span class="hljs-string"><span class="hljs-string">'Mar'</span></span>, <span class="hljs-string"><span class="hljs-string">'Apr'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jun'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jul'</span></span>, <span class="hljs-string"><span class="hljs-string">'Aug'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sep'</span></span>, <span class="hljs-string"><span class="hljs-string">'Oct'</span></span>, <span class="hljs-string"><span class="hljs-string">'Nov'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dec'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDate() + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + months[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMonth()] + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getFullYear(); } }</code> </pre> <br><br><a name="section013"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versprich es mir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Promise-Objekt wird f√ºr verz√∂gerte und asynchrone Berechnungen verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen kann in drei Staaten sein:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausstehend: Ausgangszustand, nicht abgeschlossen und nicht abgelehnt. </font></font></li><li>  (fulfilled):   . </li><li>  (rejected):    . </li></ul><br>       (pending),      (fulfilled),    (),   (rejected),   .       ,     then. (         ,     , ..           ¬´ ¬ª, , ,      DOM.) <br><br>    Promise.prototype.then()  Promise.prototype.catch()   ,    ,  . <br><img src="https://habrastorage.org/getpro/habr/post_images/835/119/a5c/835119a5c72db92a1ae89730a7af1251.png" alt="Bild"><br><br> <b>  (promise)</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Promise-Objekt wird mit dem neuen Schl√ºsselwort und seinem Konstruktor erstellt. </font><font style="vertical-align: inherit;">Der Promise-Konstruktor verwendet ein Argument, das als Executor-Funktion bezeichnet wird, als Argument. </font><font style="vertical-align: inherit;">Diese Funktion sollte zwei R√ºckruffunktionen als Parameter akzeptieren. </font><font style="vertical-align: inherit;">Die erste (Aufl√∂sung) wird aufgerufen, wenn die asynchrone Operation erfolgreich abgeschlossen wurde und das Ergebnis ihrer Ausf√ºhrung als Wert zur√ºckgegeben hat. </font><font style="vertical-align: inherit;">Der zweite R√ºckruf (Zur√ºckweisen) wird aufgerufen, wenn die Operation fehlgeschlagen ist, und gibt einen Wert zur√ºck, der den Grund f√ºr den Fehler angibt, meistens ein Fehlerobjekt.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    : resolve(someValue); //   //  reject("failure reason"); //  });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Funktionsobjekt mit zwei Argumenten, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufl√∂sen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ablehnen,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bewirkt </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> dass das Versprechen erfolgreich ist, das zweite lehnt es ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um der Funktion die Versprechensfunktionalit√§t zur Verf√ºgung zu stellen, m√ºssen Sie nur das darin enthaltene Versprechungsobjekt zur√ºckgeben.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAsyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url); xhr.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(xhr.responseText); xhr.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> reject(xhr.statusText); xhr.send(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Hilfe. </font><font style="vertical-align: inherit;">Dann werden Ausf√ºhrungs- und Ablehnungshandler angeh√§ngt.</font></font><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methoden</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.all (iterable) - Wartet darauf, dass alle Versprechen f√ºr eines von ihnen ausgef√ºhrt oder abgelehnt werden. </font><font style="vertical-align: inherit;">Gibt ein Versprechen zur√ºck, das ausgef√ºhrt wird, nachdem alle Versprechen iterabel ausgef√ºhrt wurden. </font><font style="vertical-align: inherit;">F√ºr den Fall, dass eines der Versprechen abgelehnt wird, wird Promise.all ebenfalls abgelehnt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.allSettled (iterable) - Wartet auf die Erf√ºllung aller empfangenen Versprechen (sowohl Ausf√ºhrung als auch Ablehnung). </font><font style="vertical-align: inherit;">Gibt ein Versprechen zur√ºck, das ausgef√ºhrt wird, wenn alle empfangenen Versprechen abgeschlossen (ausgef√ºhrt oder abgelehnt) sind, und enth√§lt ein Array der Ergebnisse der Ausf√ºhrung der empfangenen Versprechen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race (iterable) - Wartet auf die Ausf√ºhrung oder Ablehnung eines der erhaltenen Versprechen. </font><font style="vertical-align: inherit;">Gibt ein Versprechen zur√ºck, das mit dem Ergebnis der Ausf√ºhrung des ersten ausgef√ºhrten oder abgelehnten Versprechens von .iterable ausgef√ºhrt oder abgelehnt wird.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.reject (Grund) - Gibt ein aus einem Grund abgelehntes Versprechen zur√ºck. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve (Wert) - Gibt das mit dem Ergebniswert ausgef√ºhrte Versprechen zur√ºck. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen Prototyp</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> catch (onRejected) - F√ºgt eine R√ºckruffunktion hinzu, um die Ablehnung eines Versprechens zu behandeln, die ein neues Versprechen zur√ºckgibt, das mit dem √ºbergebenen Wert gemacht wurde, wenn es aufgerufen wird, oder den urspr√ºnglichen Aufl√∂sungswert, wenn das Versprechen gemacht wurde. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then (onFulfilled, onRejected) - F√ºgt einen Handler f√ºr die Erf√ºllung und Ablehnung von Versprechen hinzu und gibt ein neues Versprechen zur√ºck, das mit dem Wert des aufgerufenen Handlers oder dem urspr√ºnglichen Wert ausgef√ºhrt wurde, wenn das Versprechen nicht verarbeitet wurde (d. h. wenn der entsprechende Handler f√ºr onFulfilled oder onRejected keine Funktion ist). </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen einer asynchronen http-Anforderung: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  API      function asyncHttpRequest (url) { return new Promise((resolve, reject) =&gt; { //  promise if (url == undefined) //     url reject(new Error("Expected url and received nothing")); else { resolve(() =&gt; { fetch(url).then((response) =&gt; { //   return response.json(); //    JSON   }).then((myJson) =&gt; { return(console.log(myJson)); //      }); }); } } );} asyncHttpRequest(URL).then((result) =&gt; result(), (error) =&gt; console.log(error));</span></span></code> </pre> <br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Beispiele und Informationen zu Versprechungen finden Sie in der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie in der Mozilla- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="section014"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iteratoren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verarbeitung jedes Elements in einer Sammlung ist eine sehr h√§ufige Operation. JavaScript bietet verschiedene M√∂glichkeiten zum Durchlaufen einer Sammlung, von einer einfachen for-Schleife bis hin zu Map- (), Filter- () und Array-Verst√§ndnis. Iteratoren und Generatoren implementieren das Konzept der Aufz√§hlung direkt in den Kern der Sprache und bieten einen Mechanismus zum Festlegen des Verhaltens f√ºr ... von Schleifen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objekt ist ein Iterator, wenn es einzeln auf die Elemente der Sammlung zugreifen kann, w√§hrend es seine aktuelle Position innerhalb dieser Sequenz verfolgt. In JavaScript ist ein Iterator ein Objekt, das eine next () -Methode bereitstellt, die das n√§chste Element einer Sequenz zur√ºckgibt. Diese Methode gibt ein Objekt mit zwei Eigenschaften zur√ºck: done und value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Erstellung kann das Iteratorobjekt explizit verwendet werden, indem die next () -Methode aufgerufen wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterable - Dies ist ein Objekt, dessen Inhalt wiederholt werden kann. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das iterierbare Objekt unterscheidet sich vom nicht iterierbaren darin, dass es eine spezielle Methode hat, die ein Objekt f√ºr den Zugriff zur√ºckgibt, auf das ein spezielles Symbol verwendet wird: Symbol.iterator</font></font><br><pre> <code class="javascript hljs">Iterable { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Objekt, das die Methode zur√ºckgibt, wird formal als Iterator bezeichnet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Iterator hat nur eine next () -Methode</font></font><br><pre> <code class="javascript hljs">Iterator { next(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies gibt ein Objekt (nennen wir es itreratorResult) mit zwei Eigenschaften done und value zur√ºck </font></font><br><pre> <code class="javascript hljs">IteratorResult { done, value }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> done gibt an, ob die gesuchte Sequenz noch einen Wert enth√§lt und der Wert das n√§chste Element der Sequenz enth√§lt. </font></font><br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Initialisierung kann die next () -Methode aufgerufen werden, um nacheinander auf die Schl√ºssel-Wert-Paare im Objekt zuzugreifen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objekt ist iterierbar, wenn es eine Methode zum Auflisten von Werten definiert, dh wie Werte im Konstrukt for..of aufgelistet werden. </font><font style="vertical-align: inherit;">Einige integrierte Typen wie Array oder Map sind standardm√§√üig iterierbar, andere Typen wie Object hingegen nicht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um iterierbar zu sein, muss ein Objekt die Iteratormethode implementieren. Dies bedeutet, dass es (oder eines der Objekte in der Prototypenkette) eine Eigenschaft namens Symbol.iterator haben muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So sieht der Standard-Iterator aus:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextIndex &lt; array.length ? { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: array[nextIndex++], <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } : { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; } } }</code> </pre> <br><br><a name="section015"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generatoren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren sind eine spezielle Art von Funktion, die wie eine Iteratorfabrik funktioniert. </font><font style="vertical-align: inherit;">Eine Funktion wird zum Generator, wenn sie eine oder mehrere Yield-Anweisungen enth√§lt und die Funktionssyntax * verwendet.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren sind eine neue Art von Funktion, die ihre Ausf√ºhrung unterbrechen und ein Zwischenergebnis zur√ºckgeben und die Ausf√ºhrung sp√§ter fortsetzen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns eine regul√§re Funktion an, die etwas rechnet und ein Ergebnis zur√ºckgibt:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 9</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen Sie sich nun eine √§hnliche Generatorfunktion an: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = generator(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 10 console.log(it.next().value); // 9&lt;/i&gt;</span></span></code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erw√§hnt, k√∂nnen Generatoren ihre Ausf√ºhrung unterbrechen und ein Zwischenergebnis zur√ºckgeben. Dieses Beispiel zeigt, dass zum Zeitpunkt des ersten Aufrufs die Funktion, als ob sie ihre Ausf√ºhrung beim ersten Haltepunktausbruch anh√§lt, das Ergebnis des ersten Ausdrucks zur√ºckgibt. Beim zweiten Aufruf wird die Funktion vom vorherigen Haltepunkt fortgesetzt und zum n√§chsten verschoben, wobei das Ergebnis des n√§chsten Ausdrucks zur√ºckgegeben wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsgeneratoren bieten ein leistungsstarkes Werkzeug zum Schreiben komplexer sequentieller Funktionen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren berechnen die Ergebnisse ihrer Ertragsausdr√ºcke nach Bedarf, wodurch sie effizient mit Sequenzen mit hohem Rechenaufwand oder sogar mit unendlichen Sequenzen arbeiten k√∂nnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die next () -Methode verwendet auch einen Wert, mit dem der interne Zustand des Generators ge√§ndert werden kann. Der an next () √ºbergebene Wert wird als Ergebnis des letzten Ertragsausdrucks betrachtet, der den Generator angehalten hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen den Generator zwingen, eine Ausnahme auszul√∂sen, indem Sie seine throw () -Methode aufrufen und den Wert der Ausnahme √ºbergeben, die als Parameter ausgel√∂st werden soll. Diese Ausnahme wird aus dem aktuell angehaltenen Kontext des Generators ausgel√∂st, als w√§re die aktuell angehaltene Yield-Anweisung eine throw-Anweisung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Yield-Anweisung w√§hrend der Verarbeitung der ausgel√∂sten Ausnahme nicht auftritt, wird die Ausnahme oben √ºber den Aufruf throw () √ºbergeben, und das Ergebnis nachfolgender Aufrufe von next () wird als Eigenschaft true ausgef√ºhrt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generatoren haben eine R√ºckgabemethode (Wert), die den angegebenen Wert zur√ºckgibt und den Generator stoppt. </font></font><br><br><a name="section016"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Symbol </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol ist ein primitiver Datentyp, dessen Instanzen eindeutig und unver√§nderlich sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der JavaScript-Laufzeit wird durch Aufrufen der Funktion Symbol () ein Symbolwert erstellt, der dynamisch einen anonymen und eindeutigen Wert erstellt. </font><font style="vertical-align: inherit;">Die einzig sinnvolle Verwendung besteht darin, das Zeichen zu speichern und dann den gespeicherten Wert zu verwenden, um die Eigenschaft des Objekts zu erstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Zeichen als Bezeichner in einer Eigenschaftszuweisung verwendet wird, ist die Eigenschaft (z. B. ein Zeichen) anonym. </font><font style="vertical-align: inherit;">und auch nicht z√§hlbar. </font><font style="vertical-align: inherit;">Da die Eigenschaft nicht berechenbar ist, wird sie nicht in der Schleife "for (... in ...)" angezeigt, und da die Eigenschaft anonym ist, wird sie nicht im Ergebnisarray "Object.getOwnPropertyNames ()" angezeigt. </font><font style="vertical-align: inherit;">Auf diese Eigenschaft kann mit dem Anfangswert des Symbols zugegriffen werden, mit dem sie erstellt wurde, oder indem das Ergebnisarray ‚ÄûObject.getOwnPropertySymbols ()‚Äú durchlaufen wird.</font></font><br><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So k√∂nnen Sie eine Zeicheneigenschaft erstellen: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"password"</span></span>)]: <span class="hljs-string"><span class="hljs-string">"12hsK3I"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Object.getOwnPropertySymbols (obj) -Eigenschaft, um ein Array von Zeichenobjekten abzurufen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Methoden Symbol.for () und Symbol.keyFor (), um auf eine beliebige Stelle in Ihrem Code zuzugreifen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen zum Datentyp Sumbol finden Sie in der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie in der </font><font style="vertical-align: inherit;">Mozilla- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460741/">https://habr.com/ru/post/de460741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460729/index.html">Angenehm und n√ºtzlich im Unterricht</a></li>
<li><a href="../de460731/index.html">Die US-Beh√∂rden schlie√üen 2017 eine Untersuchung eines Roboter-Busunfalls ab</a></li>
<li><a href="../de460735/index.html">CI \ CD f√ºr Startups: Welche Tools gibt es und warum werden sie nicht nur von gro√üen und bekannten Unternehmen verwendet?</a></li>
<li><a href="../de460737/index.html">H√∂ren Sie Hintergrund: Projektmanagement-Podcasts</a></li>
<li><a href="../de460739/index.html">Wir kamen in Frieden von der ganzen Menschheit</a></li>
<li><a href="../de460743/index.html">Flutter Anf√§ngerleitfaden</a></li>
<li><a href="../de460745/index.html">Erfahrung in der Verwendung eines GSM-Moduls in der Hausautomation</a></li>
<li><a href="../de460747/index.html">Nach Gewinnen suchen oder Muttern festziehen: Spotify arbeitet nicht mehr direkt mit Autoren zusammen - was bedeutet das?</a></li>
<li><a href="../de460751/index.html">Wie wir Roboter im kleinen Tschernobyl gestartet haben. Teil 1</a></li>
<li><a href="../de460755/index.html">ROS Trolley Robot - Teil 1: Eisen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>