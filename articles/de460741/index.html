<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗝️ 📞 👌🏻 Einführung in ECMAScript 6 (ES-2015) 👩🏼‍🤝‍👨🏻 🥤 👨🏿‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung in ES6 

 Inhaltsverzeichnis 
 1. Vorlagenliterale 
 2. let und const 
 3. Pfeilfunktionsausdrücke 
 4. Für ... von 
 5. Berechnete Eigensc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in ECMAScript 6 (ES-2015)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460741/"><h2>  Einführung in ES6 </h2><br><br>  <b>Inhaltsverzeichnis</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Vorlagenliterale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. let und const</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Pfeilfunktionsausdrücke</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Für ... von</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Berechnete Eigenschaftsnamen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Object.assign ()</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Ruheparameter</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Standardparameter</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">9. Destrukturierungsauftrag</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">10. Karte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">11. Stellen Sie ein</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">12. Klassen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">13. Versprechen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">14. Iteratoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">15. Generatoren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">16. Sumbol</a> <br><br><a name="section001"></a><h2>  Vorlagenliterale (Vorlagenzeichenfolgen) </h2><br>  Vorlagenliterale sind Zeichenfolgenliterale, die die Verwendung von Ausdrücken im Inneren ermöglichen.  Mit ihnen können Sie mehrzeilige Literale und Zeichenfolgeninterpolation verwenden. <br><br>  Vorlagenliterale sind in Backticks (``) anstelle von Double oder Single eingeschlossen.  Sie können Platzhalter enthalten, die durch ein Dollarzeichen und geschweifte Klammern ($ {expression}) gekennzeichnet sind.  Substitutionsausdrücke und der Text zwischen ihnen werden an die Funktion übergeben.  Standardmäßig verkettet die Funktion einfach alle Teile zu einer Zeichenfolge.  Wenn vor der Zeile ein Ausdruck steht (hier ist es ein Tag), wird die Vorlagenzeile als "Tag-Vorlage" bezeichnet.  In diesem Fall wird der Tag-Ausdruck (normalerweise eine Funktion) mit dem verarbeiteten Vorlagenliteral aufgerufen, das Sie vor der Ausgabe ändern können.  Geben Sie den Backslash \ an, um das Backquote in Vorlagenliteralen zu umgehen. <br><a name="habracut"></a><br>  <b>Mehrzeilige Literale</b> <br>  Zeilenumbruchzeichen sind Teil von Platzhalterliteralen.  Bei Verwendung regulärer Zeichenfolgen würde das Einfügen von Wraps die folgende Syntax erfordern: <br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'string text line 1\n'</span></span> + <span class="hljs-string"><span class="hljs-string">'string text line 2'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br>  Gleiches gilt für die Verwendung von Vorlagenliteralen: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`string text line 1 string text line 2`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "string text line 1 // string text line 2"</span></span></code> </pre> <br><br>  <b>Ausdrucksinterpolation</b> <br>  Um Ausdrücke in reguläre Zeichenfolgen einzufügen, müssten Sie die folgende Syntax verwenden: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Fifteen is '</span></span> + (a + b) + <span class="hljs-string"><span class="hljs-string">' and not '</span></span> + (<span class="hljs-number"><span class="hljs-number">2</span></span> * a + b) + <span class="hljs-string"><span class="hljs-string">'.'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <br><br>  Mit Hilfe von Vorlagenliteralen können Sie jetzt "syntaktischen Zucker" verwenden, wodurch solche Substitutionen besser lesbar werden: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fifteen is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a + b}</span></span></span><span class="hljs-string"> and not </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> * a + b}</span></span></span><span class="hljs-string">.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fifteen is 15 and not 20."</span></span></code> </pre> <cut></cut><br><br>  <b>Verschachtelte Vorlagen</b> <br>  Manchmal ist das Verschachteln eines Musters die kürzeste und vielleicht besser lesbare Möglichkeit, eine Zeichenfolge zu erstellen.  Fügen Sie einfach eine weitere in die hinter zitierte Vorlage ein und verpacken Sie sie in die $ {} -Ersetzung.  Wenn der Ausdruck beispielsweise true ist, können Sie ein Vorlagenliteral zurückgeben. <br>  In ES5: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> classes = <span class="hljs-string"><span class="hljs-string">'header'</span></span> classes += (isLargeScreen() ? <span class="hljs-string"><span class="hljs-string">''</span></span> : item.isCollapsed ? <span class="hljs-string"><span class="hljs-string">' icon-expander'</span></span> : <span class="hljs-string"><span class="hljs-string">' icon-collapser'</span></span>);</code> </pre> <br>  In ES2015 mit Vorlagenliteralen ohne Verschachtelung: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : (item.isCollapsed ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-expander'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'icon-collapser'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br>  In ES2015 mit verschachtelten Vorlagenliteralen: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> classes = <span class="hljs-string"><span class="hljs-string">`header </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ isLargeScreen() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">''</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`icon-</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${item.isCollapsed ? </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'expander'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"> : </span></span></span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'collapser'</span></span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">`</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span>;</code> </pre> <br><cut></cut><br>  <b>Tag-Vorlagen</b> <br>  Eine erweiterte Form von Vorlagenliteralen wird mit Vorlagen versehen.  Mit ihnen können Sie Vorlagenliterale mithilfe einer Funktion analysieren.  Das erste Argument einer solchen Funktion enthält ein Array von Zeichenfolgenwerten, und der Rest enthält Ausdrücke aus Substitutionen.  Infolgedessen sollte die Funktion die zusammengesetzte Zeichenfolge zurückgeben (oder etwas völlig anderes, wie später gezeigt wird).  Der Name der Funktion kann beliebig sein. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings, personExp, ageExp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "That " var str1 = strings[1]; // " is a " // ,     // (  )    , //    (""),    . // var str2 = strings[2]; var ageStr; if (ageExp &gt; 99){ ageStr = 'centenarian'; } else { ageStr = 'youngster'; } //     ,     return `${str0}${personExp}${str1}${ageStr}`; } var output = myTag`That ${ person } is a ${ age }`; console.log(output);// That Mike is a youngster</span></span></code> </pre> <br>  Die Tag-Funktion ist nicht erforderlich, um eine Zeichenfolge zurückzugeben. <br><cut></cut><br>  <b>Rohe Linien</b> <br>  Mit der speziellen Raw-Eigenschaft, die für das erste Argument der Tag-Vorlage verfügbar ist, können Sie die Zeichenfolge ohne Interpretation in der Form abrufen, in der sie eingegeben wurde. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tag</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strings</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings.raw[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } tag<span class="hljs-string"><span class="hljs-string">`string text line 1 \\n string text line 2`</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "string text line 1 \\n string text line 2", //  'n'    '\'</span></span></code> </pre> <br>  Darüber hinaus gibt es eine String.raw () -Methode, die genau dieselbe Quellzeichenfolge zurückgibt, die die Standardvorlagenfunktion und die Zeichenfolgenverkettung zusammen zurückgeben würden. <br><cut></cut><br>  In ECMAScript 2016 folgen getaggte Vorlagen den Regeln für das Escapezeichen der folgenden Zeichen: <br><ul><li>  Unicode-Zeichen, die mit "\ u" beginnen, z. B. \ u00A9 </li><li>  Unicode-Codepunkte, die mit "\ u {}" beginnen, z. B. \ u {2F804} </li><li>  hexadezimale Zeichendarstellungen, die mit "\ x" beginnen, z. B. \ xA9 </li><li>  Oktale Darstellungen von Zeichen, die mit "\" beginnen, z. B. \ 251 </li></ul><br><cut></cut><br><a name="section002"></a><h2>  let und const </h2><br>  Der Umfang der Variablen, die durch die Schlüsselwörter let und const deklariert werden, ist der Block, in dem sie deklariert werden, und alles unter den Blöcken.  In diesem Fall ähnelt die Funktionsweise der let-Direktive der der var-Direktive.  Der Hauptunterschied besteht darin, dass der Umfang der von der var-Direktive deklarierten Variablen die gesamte Funktion ist, in der sie deklariert ist.  Zusätzlich zu Variablen kann der Wert von Konstanten weder durch eine neue Zuweisung geändert noch neu definiert werden.  Wenn Sie eine Variable mit dem Schlüsselwort const deklarieren, müssen Sie den Zuweisungsoperator verwenden, um den Wert der Konstante festzulegen. <br><br>  Globale Konstanten werden im Gegensatz zu var-Variablen nicht zu Eigenschaften des Fensterobjekts. <br>  Die Initialisierung einer Konstante ist erforderlich. <br>  Sie müssen gleichzeitig mit der Deklaration einen Wert angeben (der Punkt ist, dass dieser Wert dann nicht mehr geändert werden kann). <br>  Durch das Deklarieren von Variablen mit dem Schlüsselwort const wird eine Konstante (eine neue benannte Referenz auf einen Speicherbereich) erstellt, die schreibgeschützt ist. <br>  Dies bedeutet nicht, dass der angegebene Wert unverändert bleibt, aber es bedeutet, dass der Bezeichner nicht neu zugewiesen werden kann.  Wenn beispielsweise eine Konstante auf ein Objekt zeigt, kann das Objekt selbst geändert werden. <br>  Namen von Konstanten dürfen nicht mit Namen von Funktionen oder Variablen desselben Bereichs übereinstimmen. <cut></cut><br><br>  Ein Beispiel für den Unterschied zwischen globalem und Blockbereich: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">//SyntaxError   a     if if (true) var b = 5; console.log(b); //5   b     }</span></span></code> </pre> <br><br><a name="section003"></a><h2>  Pfeilfunktionsausdrücke </h2><br>  Pfeilfunktionsausdrücke haben eine kürzere Syntax als funktionale Ausdrücke und sind lexikalisch an den Wert von this gebunden (aber nicht an ihre eigenen Argumente, super oder new.target).  Der Ausdruck von Pfeilfunktionen ermöglicht es Ihnen nicht, einen Namen anzugeben. Daher sind Pfeilfunktionen anonym, sofern sie nichts zugewiesen sind. <br><cut></cut><br>  <b>Grundlegende Syntax</b> <br><pre> <code class="javascript hljs">(param1, param2, …, paramN) =&gt; { statements } (param1, param2, …, paramN) =&gt; expression <span class="hljs-comment"><span class="hljs-comment">// : (param1, param2, …, paramN) =&gt; { return expression; } //       : (singleParam) =&gt; { statements } singleParam =&gt; { statements } //       : () =&gt; { statements } () =&gt; expression // : () =&gt; { return expression; }</span></span></code> </pre> <br><br>  <b>Erweiterte Syntax</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,     params =&gt; ({foo: bar}) // Rest       (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; { statements } //    var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6</span></span></code> </pre> <br>  Weitere Informationen zu Pfeilfunktionen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><a name="section004"></a><h2>  Für ... von </h2><br>  Die for ... of-Anweisung führt eine Schleife durch iterierbare Objekte (einschließlich Array, Map, Set, ein Objekt mit Argumenten und dergleichen) aus und ruft bei jedem Iterationsschritt die Operatoren für jeden Wert aus verschiedenen Eigenschaften des Objekts auf. <br><cut></cut><br>  Warum sollte eine for ... in-Schleife NICHT zum Iterieren verwendet werden?  Denn je nach Engine kann JavaScript in zufälliger Reihenfolge iterieren, was zu unvorhersehbaren Ergebnissen führen kann.  Wenn sich eine Eigenschaft in einer Iteration ändert und sich dann erneut ändert, ist ihr Wert in der Schleife der letzte Wert.  Eine Eigenschaft, die vor Erreichen des Zyklus gelöscht wurde, nimmt nicht daran teil.  Eigenschaften, die Objekten in der Schleife hinzugefügt wurden, können übersprungen werden.  Im Allgemeinen ist es am besten, während der Iteration keine Eigenschaft zum Objekt hinzuzufügen, zu ändern oder zu löschen, wenn Sie sie noch nicht übergeben haben.  Es gibt keine Garantie dafür, dass die hinzugefügte Eigenschaft vom Zyklus besucht, nach den Änderungen geändert und nach dem Löschen gelöscht wird.  Darüber hinaus ist die iterative Variable eine Zeichenfolge und keine Zahl. Wenn Sie also Berechnungen mit der Variablen durchführen möchten, müssen Sie die Zeichenfolgen verketten, anstatt sie hinzuzufügen.  Um logische Fehler zu vermeiden, sollten Sie es nicht verwenden! <br><br>  Im Gegensatz zur for ... of-Schleife gibt die for ... in-Schleife alle aufgezählten Eigenschaften zurück, einschließlich derjenigen mit nicht ganzzahligen und geerbten Namen. <br><br>  <b>Für ... der Schleifensyntax</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) <span class="hljs-comment"><span class="hljs-comment">//for ( of ) arr[i] = "something value"</span></span></code> </pre> <br>  Beispiele: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> iterable = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>]; iterable.foo = <span class="hljs-string"><span class="hljs-string">'hello'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iterable) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">// 0, 1, 2, "foo", "arrCustom", "objCustom" for (let i in iterable) { if (iterable.hasOwnProperty(i)) console.log(i); //  0, 1, 2, "foo" } for (let i of iterable) console.log(i); // 3, 5, 7</span></span></code> </pre><cut></cut><br>  Jedes Objekt erbt die objCustom-Methode und jedes Array erbt die arrCustom-Methode, indem es sie in Object.prototype und Array.prototype erstellt.  Das iterierbare Objekt erbt die Methoden objCustom und arrCustom aufgrund der Vererbung von Prototypen. <br><br>  Die Schleife zeigt nur die aufgezählten Eigenschaften des iterierbaren Objekts in der Reihenfolge an, in der sie erstellt wurden.  Die Werte 3, 5, 7 und Hallo werden nicht gedruckt, da sie nicht aufzählbar sind.  Die Namen von Eigenschaften und Methoden werden angezeigt, z. B. arrCustom und objCustom. <br><br>  Die Schleife ähnelt der vorherigen, verwendet jedoch hasOwnProperty (), um zu überprüfen, ob diese Eigenschaft des Objekts eine eigene oder eine geerbte ist.  Es werden nur eigene Eigenschaften angezeigt.  Die Namen 0, 1, 2 und foo gehören nur zur Instanz des Objekts (nicht vererbt).  Die Methoden arrCustom und objCustom werden nicht ausgegeben, da sie vererbt werden. <br><br>  Diese Schleife umgeht iterierbar und zeigt die Werte des iterierbaren Objekts an, die in der Methode des Iterierens definiert sind, d. H.  nicht die Eigenschaften des Objekts, sondern die Werte des Arrays 3, 5, 7. <br><br><a name="section005"></a><h2>  Berechnete Eigenschaftsnamen </h2><br>  Die Syntax zum Deklarieren von Objekten und ihren Elementen unterstützt berechnete Eigenschaftsnamen.  Auf diese Weise können Sie den Klammern [] einen Ausdruck hinzufügen, der als Name der Eigenschaft ausgewertet wird.  Es ähnelt Vorlagenliteralen. <br><br>  <b>Beispiel für berechnete Namen:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { [<span class="hljs-string"><span class="hljs-string">"a"</span></span> + (<span class="hljs-number"><span class="hljs-number">10</span></span> - <span class="hljs-number"><span class="hljs-number">6</span></span>)]: { [<span class="hljs-string"><span class="hljs-string">"some"</span></span> + <span class="hljs-string"><span class="hljs-string">"string"</span></span>]: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span>]: <span class="hljs-number"><span class="hljs-number">10</span></span>, [<span class="hljs-string"><span class="hljs-string">`hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${a()}</span></span></span><span class="hljs-string">`</span></span>]: a() } }</code> </pre> <br><cut></cut><br><br><a name="section006"></a><h2>  Object.assign () </h2><br>  Die Object.assign () -Methode wird verwendet, um die Werte aller eigenen aufgezählten Eigenschaften von einem oder mehreren Quellobjekten in das Zielobjekt zu kopieren.  Nach dem Kopieren wird das Zielobjekt zurückgegeben. <br><br>  Die Object.assign () -Methode kopiert nur aufgezählte und native Eigenschaften von den Quellobjekten in das Zielobjekt.  Es verwendet die interne [[Get]] - Methode für die Quellobjekte und die interne [[Set]] - Methode für das Zielobjekt, ruft also auch Getter und Setter auf.  Aus diesem Grund werden Eigenschaften zugewiesen, anstatt einfach neue Eigenschaften zu kopieren oder zu definieren.  Dieses Verhalten kann dazu führen, dass die Methode nicht zum Einfügen neuer Eigenschaften in den Prototyp geeignet ist, wenn die eingefügten Quellobjekte Getter enthalten.  Stattdessen sollten die Methoden Object.getOwnPropertyDescriptor () und Object.defineProperty () verwendet werden, um Prototypen von Eigenschaftsdefinitionen einschließlich eines Zeichens ihrer Aufzählung zu kopieren. <br><br>  Die Eigenschaften der Typen von String und Symbol werden kopiert. <br><br>  Im Fehlerfall, wenn die Eigenschaft beispielsweise nicht beschreibbar ist, wird eine TypeError-Ausnahme ausgelöst und das Zielobjekt bleibt unverändert. <br><br>  Beachten Sie, dass die Object.assign () -Methode keine Ausnahme auslöst, wenn die Anfangswerte null oder undefiniert sind. <br><br>  <b>Beispiel: Klonen eines Objekts</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> copy = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(copy); <span class="hljs-comment"><span class="hljs-comment">// { a: 1 }</span></span></code> </pre> <br>  <b>Beispiel: Objekte zusammenführen</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o1 = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o2 = { <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o3 = { <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(o1, o2, o3); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// { a: 1, b: 2, c: 3 } console.log(o1); // { a: 1, b: 2, c: 3 },     .</span></span></code> </pre> <br><br><a name="section007"></a><h2>  Ruheparameter </h2><br>  Die Syntax der verbleibenden Parameter der Funktion ermöglicht es Ihnen, eine unbegrenzte Anzahl von Argumenten in Form eines Arrays darzustellen. <br><br>  Wenn das zuletzt genannte Funktionsargument ein Präfix ... hat, wird es automatisch zu einem Array mit Elementen von 0 bis theArgs.length entsprechend der tatsächlichen Anzahl der an die Funktion übergebenen Argumente. <br><br>  <b>Syntax</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...theArgs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><br>  <b>Ein Beispiel für die Verwendung der Syntax der verbleibenden Parameter:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, ...c</span></span></span><span class="hljs-function">) </span></span>{} name (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>,)</code> </pre> <br>  In diesem Beispiel ist a = 0 b = 1 c [0] = 2 c [1] = 3 <br>  Wenn der verbleibende Parameter nicht übergeben wird, handelt es sich um ein leeres Array (im Gegensatz zu normalen Parametern ist es niemals undefiniert). <br><br>  Diese Syntax kann nicht nur in Funktionsargumenten verwendet werden, sondern auch an anderen Stellen, beispielsweise zum Kopieren und Kombinieren von Arrays: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = [ <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = [ <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = [ ...a, ...b ]; <span class="hljs-comment"><span class="hljs-comment">// [ 0, 1, 2, 3, 4, 5 ]</span></span></code> </pre> <br><br><a name="section008"></a><h2>  Standardparameter </h2><br>  Mit Standardparametern können Sie formale Funktionsparameter auf Standardwerte setzen, wenn die Funktion ohne Argumente aufgerufen wird oder wenn der Parameter explizit undefiniert übergeben wird. <br><br>  In JavaScript nehmen die Parameter einer Funktion, deren Werte beim Aufruf nicht übergeben werden, den undefinierten Standardwert an.  In einigen Fällen kann es jedoch nützlich sein, einen anderen Standardwert festzulegen.  In solchen Fällen sind die Standardeinstellungen vorgesehen. <br><br>  Der Standardwert wird einem formalen Parameter nur zugewiesen, wenn während eines Funktionsaufrufs der Wert für diesen Parameter nicht oder undefiniert explizit übergeben wurde. <br><br>  <b>Ein Beispiel für die Verwendung von Standardparametern:</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFun()); <span class="hljs-comment"><span class="hljs-comment">// 25</span></span></code> </pre> <cut></cut><br><br><a name="section009"></a><h2>  Zerstörungsauftrag </h2><br>  Mit der Destrukturierungszuweisungssyntax in JavaScript-Ausdrücken können Sie Daten aus Arrays oder Objekten mithilfe einer Syntax abrufen, die der Deklaration eines Arrays oder von Literalen in einem Objekt ähnelt. <br><br>  Objekt- oder Arraydeklarationsausdrücke bieten eine einfache Möglichkeit, ein homogenes Datenpaket zu erstellen.  Wenn Sie ein solches Paket erstellen, haben Sie die Möglichkeit, es auf jede mögliche Weise zu verwenden.  Sie können es auch in Funktionen zurückgeben. <br><br>  Eine der wichtigsten Möglichkeiten zur Verwendung der destruktiven Zuweisung besteht darin, die Datenstruktur mit einem Operator zu lesen, obwohl Sie neben dieser Funktion noch viele andere Verwendungsmöglichkeiten finden können. <br><br>  <b>Beispiel für eine destruktive Zuordnung:</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, rest; [a, b] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); <span class="hljs-comment"><span class="hljs-comment">// 1 console.log(b); // 2 [a, b, ...rest] = [1, 2, 3, 4, 5]; console.log(a); // 1 console.log(b); // 2 console.log(rest); // [3, 4, 5] ({a, b} = {a:1, b:2}); console.log(a); // 1 console.log(b); // 2</span></span></code> </pre> <br>  Weitere Beispiele finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><a name="section010"></a><h2>  Karte </h2><br>  Map - Ein Objekt, das Schlüssel-Wert-Paare enthält und die Einfügereihenfolge beibehält.  Jeder Wert (sowohl Objekte als auch Grundelemente) kann als Schlüssel verwendet werden. <br><br>  <b>Ein Beispiel:</b> <cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keyObj = {}, keyFunc = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, keyString = <span class="hljs-string"><span class="hljs-string">"a string"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   myMap.set(keyString, "value associated with 'a string'"); myMap.set(keyObj, "value associated with keyObj"); myMap.set(keyFunc, "value associated with keyFunc"); myMap.size; // 3 //   myMap.get(keyString); // "value associated with 'a string'" myMap.get(keyObj); // "value associated with keyObj" myMap.get(keyFunc); // "value associated with keyFunc" myMap.get("a string"); // "value associated with 'a string'" //   keyString === 'a string' myMap.get({}); // undefined,   keyObj !== {} myMap.get(function() {}) // undefined,   keyFunc !== function () {}</span></span></code> </pre> <br>  <b>Unterschied der Karte vom Objekt:</b> <br><br><ul><li>  Objektschlüssel sind Linien und Symbole, während jeder Wert ein Kartenschlüssel sein kann, einschließlich Funktionen, Objekten und Grundelementen. </li><li>  Im Gegensatz zu Objekten sind die Schlüssel in Map geordnet.  Während der Map-Iteration werden die Schlüssel daher in der Einfügereihenfolge zurückgegeben. </li><li>  Sie können die Anzahl der Elemente in einer Karte mithilfe der size-Eigenschaft leicht ermitteln, während die Anzahl der Elemente in einem Objekt nur manuell bestimmt werden kann. </li><li>  Map ist ein iterierbares Objekt und kann direkt iteriert werden, während das Objekt den manuellen Empfang der Liste der Schlüssel und ihrer Iteration erfordert. </li><li>  Das Objekt hat einen Prototyp und daher einen Standardschlüsselsatz, der sich bei Unachtsamkeit mit Ihren Schlüsseln überschneiden kann.  Seit der Veröffentlichung von ES5 kann dies mit map = Object.create (null) geändert werden. </li><li>  Map kann bei häufigem Hinzufügen oder Entfernen von Schlüsseln eine bessere Leistung erzielen. </li></ul><cut></cut><br>  <b>Eigenschaften und Methoden:</b> <br><br><ul><li>  Map.prototype.size - Gibt die Anzahl der Schlüssel / Wert-Paare auf einer Karte zurück </li><li>  Map.prototype.set (Schlüssel, Wert) - Fügt Map das übergebene Schlüssel / Wert-Paar hinzu.  Wenn der angegebene Schlüssel bereits vorhanden ist, wird er mit dem neuen Wert überschrieben. </li><li>  Map.prototype.get (Schlüssel) - Gibt den Wert des übergebenen Schlüssels zurück.  Wenn kein Schlüssel vorhanden ist, wird undefined zurückgegeben </li><li>  Map.prototype.has (Schlüssel) - Gibt true zurück, wenn der übergebene Schlüssel vorhanden ist, und false, wenn dies nicht der Fall ist </li><li>  Map.prototype.delete (Schlüssel) - Löscht das angegebene Schlüssel-Wert-Paar und gibt true zurück.  Gibt false zurück, wenn der Schlüssel nicht vorhanden ist. </li><li>  Map.prototype.clear () - Entfernt alle Schlüssel / Wert-Paare aus Map </li><li>  Map.prototype.keys () - Gibt für jedes Element einen Iterator von Schlüsseln auf einer Map zurück </li><li>  Map.prototype.values ​​() - Gibt für jedes Element einen Iterator von Werten auf der Map zurück </li><li>  Map.prototype.entries () - Gibt für jedes Element einen Iterator des Arrays [Schlüssel, Wert] auf Map zurück </li></ul><cut></cut><br><br><a name="section011"></a><h2>  Stellen Sie ein </h2><br>  Ermöglicht das Speichern eindeutiger Werte eines beliebigen Typs, sowohl von Grundelementen als auch von anderen Objekttypen. <br><br>  Festgelegte Objekte stellen Sammlungen von Werten dar, die Sie in der Reihenfolge durchlaufen können, in der die Elemente eingefügt werden.  Der Wert eines Elements in Set kann nur in einer Instanz vorhanden sein, wodurch seine Eindeutigkeit in der Set-Auflistung sichergestellt wird. <br><br>  Eigenschaften und Instanzmethoden festgelegt <br><ul><li>  size - Gibt die Anzahl der Elemente im Set-Objekt zurück. </li><li>  add (Wert) - Fügt dem Set-Objekt ein neues Element mit dem angegebenen Wert hinzu.  Gibt ein Set-Objekt zurück. </li><li>  clear () - Entfernt alle Elemente aus dem Set-Objekt. </li><li>  delete (value) - Löscht das dem Wert zugeordnete Element und gibt den Wert zurück, der (value) zuvor zurückgegeben hat.  has (value) gibt später false zurück. </li><li>  entry () - Gibt ein neues Iterator-Objekt zurück, das ein Array von [Wert, Wert] für jedes Element im Set-Objekt in Einfügereihenfolge enthält.  Dies wird ähnlich wie das Map-Objekt gespeichert, sodass jeder Eintrag hier den gleichen Wert für seinen Schlüssel und Wert hat. </li><li>  forEach (callbackFn [, thisArg]) - Ruft callbackFn einmal für jeden im Set-Objekt vorhandenen Wert in Einfügereihenfolge auf.  Wenn thisArg für thisEach angegeben ist, wird es für diesen Rückruf als this-Wert verwendet. </li><li>  has (Wert) - Gibt einen booleschen Wert zurück, der bestätigt, ob das Element mit dem angegebenen Wert im Set-Objekt vorhanden ist oder nicht. </li><li>  values ​​() - Gibt ein neues Iterator-Objekt zurück, das die Werte für jedes Element im Set-Objekt in Einfügereihenfolge enthält. </li></ul><br>  <b>Verwenden des Set-Objekts</b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Set</span></span>(); mySet.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set { 1 } mySet.add(5); // Set { 1, 5 } mySet.add(5); // Set { 1, 5 } mySet.add("some text"); // Set { 1, 5, 'some text' } var o = {a: 1, b: 2}; mySet.add(o); mySet.add({a: 1, b: 2}); //  o    ,      mySet.has(1); // true mySet.has(3); // false, 3     set mySet.has(5); // true mySet.has(Math.sqrt(25)); // true mySet.has("Some Text".toLowerCase()); // true mySet.has(o); // true mySet.size; // 5 mySet.delete(5); //  5  set mySet.has(5); // false, 5   mySet.size; // 4,     console.log(mySet); // Set {1, 'some text', Object {a: 1, b: 2}, Object {a: 1, b: 2}}</span></span></code> </pre> <br>  <b>Bypass-Set</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.keys()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} for (let item of mySet.values()) console.log(item); //    : 1, "some text", {"a": 1, "b": 2} //(key  value    ) for (let [key, value] of mySet.entries()) console.log(key); //  Set  Array var myArr = Array.from(mySet); // [1, "some text", {"a": 1, "b": 2}] //       HTML  mySet.add(document.body); mySet.has(document.querySelector("body")); // true //   Array  Set   mySet2 = new Set([1,2,3,4]); mySet2.size; // 4 [...mySet2]; // [1,2,3,4] //      var intersection = new Set([...set1].filter(x =&gt; set2.has(x))); //      var difference = new Set([...set1].filter(x =&gt; !set2.has(x))); //   set   forEach mySet.forEach(function(value) { console.log(value); }); // 1 // 2 // 3 // 4</span></span></code> </pre> <br><cut></cut><br><br><a name="section012"></a><h2>  Klassen </h2><br>  Klassen in JavaScript wurden in ECMAScript 2015 eingeführt und sind syntaktischer Zucker über die Vererbung von Prototypen in JavaScript.  Die Klassensyntax führt kein neues objektorientiertes Modell ein, bietet jedoch eine einfachere und intuitivere Möglichkeit, Objekte zu erstellen und die Vererbung zu organisieren. <br><br>  Klassen sind eigentlich „Sonderfunktionen“. So wie Sie Funktionen (Funktionsausdrücke und Funktionsdeklarationen) definieren, können Sie Klassen definieren mit: Klassendeklarationen und Klassenausdrücken. <br><br>  Der Unterschied zwischen einer Funktionsdeklaration und einer Klassendeklaration besteht darin, dass eine Funktionsdeklaration angehoben wird, eine Klassendeklaration jedoch nicht.  Daher müssen Sie zuerst Ihre Klasse deklarieren und erst dann damit arbeiten, da sonst eine Ausnahme vom Typ ReferenceError ausgelöst wird. <br><cut></cut><br><h4>  Klassenerklärung </h4><br>  Die erste Möglichkeit, eine Klasse zu definieren, besteht in einer Klassendeklaration.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verwenden Sie dazu das Schlüsselwort class und geben Sie den Klassennamen an (im Beispiel „myClass“). </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myClass</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(height, width) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = width; } }</code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite Möglichkeit, eine Klasse zu definieren, ist der Klassenausdruck. </font><font style="vertical-align: inherit;">Sie können benannte und namenlose Ausdrücke erstellen. </font><font style="vertical-align: inherit;">Im ersten Fall befindet sich der Name des Klassenausdrucks im lokalen Bereich der Klasse und kann über die Eigenschaften der Klasse selbst und nicht über ihre Instanz abgerufen werden.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  var myClass = class { constructor(height, width) { this.height = height; this.width = width; } }; //  var myClass = class myClass { constructor(height, width) { this.height = height; this.width = width; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassenausdrücke unterliegen denselben Hebeproblemen wie Klassendeklarationen! </font></font><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Klassendeklarationskörper und Klassenausdrücke werden im strengen Modus ausgeführt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der strikte Modus ändert die Syntax und das Verhalten der Laufzeit. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Genauer gesagt ist der strenge Modus durch Folgendes gekennzeichnet:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konvertieren Sie Fehler in Ausnahmen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Änderungen, die die Berechnung einer Variablen in bestimmten Fällen der Verwendung ihres Namens vereinfachen; </font></font></li><li> ,  eval  arguments; </li><li> ,   «» JavaScript; </li></ul><br> <b>   </b> <br><ol><li>        . </li><li>     . </li><li> ,      ,  . </li><li>        (           ). </li><li>  ,    ,     .       ,      . </li><li>         .             . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Syntax des Oktalzahlensystems ist verboten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Festlegen von Eigenschaften mit primitiven Werten ist verboten. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachung der Arbeit mit Variablen Der</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> strenge Modus vereinfacht den Vergleich des Namens einer Variablen mit dem Ort ihrer Definition im Code.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung mit ist verboten. </font><font style="vertical-align: inherit;">Das Problem bei ist, dass zur Laufzeit jeder Name innerhalb des Blocks entweder auf eine Eigenschaft des zu verarbeitenden Objekts oder auf eine Variable im umgebenden (oder sogar globalen) Kontext verweisen kann - es ist unmöglich, dies vorher zu wissen. </font><font style="vertical-align: inherit;">Eine einfache Alternative mit besteht bereits darin, das Objekt einer Variablen mit einem Kurznamen zuzuweisen und dann auf die gewünschte Eigenschaft als Eigenschaft dieser Variablen zuzugreifen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eval () im strengen Modus fügt dem umgebenden Kontext keine neuen Variablen hinzu. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist verboten, einfache Namen zu löschen. </font></font></li></ol><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vereinfachung von Auswertung und Argumenten Der</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> strikte Modus reduziert die Anzahl der Kuriositäten im Verhalten von Argumenten und Auswertung, die beide eine gewisse Menge Magie in regulären Code mischen. </font><font style="vertical-align: inherit;">Eval fügt also Variablen hinzu oder entfernt sie und ändert ihre Werte. Die Argumentvariable kann Sie mit ihren indizierten Eigenschaften überraschen, die Referenzen (Synonyme) für benannte Funktionsargumente sind.</font></font><cut></cut><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Schlüsselwörter eval und Argumente können nicht überschrieben oder geändert werden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Felder des Argumentobjekts sind nicht den benannten Funktionsargumenten zugeordnet, sondern sind ihre duplizierten Kopien der Werte. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Eigenschaft rules.callee wird nicht unterstützt. </font><font style="vertical-align: inherit;">Im regulären Code bezieht sich die Eigenschaft rules.callee auf die Funktion selbst, für deren Aufruf das Argumentobjekt erstellt wurde.</font></font></li></ol><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Sicheres" JavaScript</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einige Websites bieten Benutzern die Möglichkeit, JavaScript zu schreiben, das auf der Website im Auftrag anderer Benutzer ausgeführt wird. </font><font style="vertical-align: inherit;">In Browsern hat JavaScript möglicherweise Zugriff auf private Informationen, was eine Sicherheitslücke in JavaScript darstellt.</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der an die Funktion übergebene Wert wird im strengen Modus nicht in das Objekt umgewandelt. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist nicht möglich, den JavaScript-Stack über die grundlegenden ECMAScript-Erweiterungen auszuführen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In Funktionen bietet die Eigenschaft rules keinen Zugriff mehr auf Variablen, die innerhalb der Funktion erstellt wurden. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen zum Strict-Modus finden </font><font style="vertical-align: inherit;">Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ECMAScript 5.1- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Spezifikation</font></a><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und auch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Mozilla.</font></font><br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstruktoren </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Konstruktor ist eine spezielle Methode zum Erstellen und Initialisieren von Objekten, die mit der Klasse erstellt wurden. </font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">'Robert'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.name); <span class="hljs-comment"><span class="hljs-comment">// Outputs 'Robert'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Erstellen neuer Objekte aus der Klasse wird Konstruktor () gestartet, der zum Initialisieren der Objekte erforderlich ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einer Klasse namens Konstruktor kann es nur eine Methode geben. </font><font style="vertical-align: inherit;">Wenn die Klasse mehr als einen Konstruktor enthält, wird eine SyntaxError-Ausnahme ausgelöst. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schlüsselwort super kann im Konstruktor verwendet werden, um den Konstruktor der übergeordneten Klasse aufzurufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie keine Konstruktormethode definiert haben, wird der Standardkonstruktor verwendet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für Basisklassen lautet der Standardkonstruktor:</font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Für abgeleitete Klassen lautet der Standardkonstruktor: </font></font><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(...args) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(...args); }</code> </pre> <br><cut></cut><br><h4>  Methoden </h4><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax der Methodendeklaration:</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { property([parameters]) {}, get property() {}, set property(value) {}, * generator() {} };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abkürzung für Generatormethoden</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { * g() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> index++; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = obj.g(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(it.next().value); // 1</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle Methodendefinitionen außer Generatormethoden können keine Konstruktoren sein und lösen einen TypeError aus, wenn Sie versuchen, sie zu instanziieren. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnete Eigenschaftsnamen</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { [<span class="hljs-string"><span class="hljs-string">"foo"</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>](){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo2()); <span class="hljs-comment"><span class="hljs-comment">// 2 };</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Schlüsselwort static definiert statische Methoden für eine Klasse. </font><font style="vertical-align: inherit;">Statische Methoden werden aufgerufen, ohne ihre Klasse zu instanziieren, und können nicht für Instanzen der Klasse aufgerufen werden.</font></font><br><cut></cut><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax von Gettern und Setzern</font></font></b> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } get Name() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } set Name(newName) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(newName) != <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Name is not a string!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = newName; <span class="hljs-comment"><span class="hljs-comment">// Robert } } var robert = new Student('robert'); robert.Name = "Robert"; console.log(robert.Name);</span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Setter - Erforderlich für die Validierung geschriebener Parameter (wie im obigen Beispiel) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter - Wird benötigt, um Eigenschaften zu erhalten (obwohl sie direkt erhalten werden können). </font><font style="vertical-align: inherit;">Kann keine Argumente haben</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In ES6 ist keine Kapselung integriert, Sie können sie jedoch selbst organisieren. </font></font> Zum Beispiel so: <br><cut></cut><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Student = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> privateProps = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name, Age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-comment"><span class="hljs-comment">// public privateProps.set(this, {age: Age}); // private } get Age() { return privateProps.get(this).age; } set Age (newAge) { privateProps.set(this, {age: newAge}); } } return Person; })(); var robert = new Student('Robert', 19); robert.Age = 20; console.log(robert.Age); // 20</span></span></code> </pre> <br><cut></cut><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vererbung </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Schlüsselwort extens wird in Klassendeklarationen und Klassenausdrücken verwendet, um eine Klasse zu erstellen, die ein untergeordnetes Element einer anderen Klasse ist. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } sayAge () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Student</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span> (name, age) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(age); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } sayFull () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Hello my name is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.sayAge()}</span></span></span><span class="hljs-string"> years old`</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> robert = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Student(<span class="hljs-string"><span class="hljs-string">"Robert"</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(robert.sayFull()); <span class="hljs-comment"><span class="hljs-comment">// Hello my name is Robert and I'm 19 years old</span></span></code> </pre> <br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Konstruktor wird das Schlüsselwort super () als Funktion verwendet, die den übergeordneten Konstruktor aufruft. </font><font style="vertical-align: inherit;">Es muss vor dem ersten Aufruf des Schlüsselworts this im Hauptteil des Konstruktors aufgerufen werden. </font><font style="vertical-align: inherit;">Das Schlüsselwort super kann auch zum Aufrufen von Funktionen des übergeordneten Objekts verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie die Methoden der übergeordneten Klasse in der untergeordneten Klasse überschreiben, werden die Methoden der untergeordneten Klasse standardmäßig aufgerufen. Sie können die Methoden der übergeordneten Klasse jedoch explizit mit der Funktion super () aufrufen.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } displayName(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name.length; } } <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj_2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); } displayName() { <span class="hljs-comment"><span class="hljs-comment">//     return [this.name, super.displayName()]; } } var Obj = new obj_2("obj_2"); console.log(Obj.displayName()); // Array [ "obj_2", 5 ]</span></span></code> </pre><cut></cut><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweitern von Inline-Objekten mit Erweitern In</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diesem Beispiel wird ein Inline-Datumsobjekt erweitert.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } getFormattedDate() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'Jan'</span></span>, <span class="hljs-string"><span class="hljs-string">'Feb'</span></span>, <span class="hljs-string"><span class="hljs-string">'Mar'</span></span>, <span class="hljs-string"><span class="hljs-string">'Apr'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jun'</span></span>, <span class="hljs-string"><span class="hljs-string">'Jul'</span></span>, <span class="hljs-string"><span class="hljs-string">'Aug'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sep'</span></span>, <span class="hljs-string"><span class="hljs-string">'Oct'</span></span>, <span class="hljs-string"><span class="hljs-string">'Nov'</span></span>, <span class="hljs-string"><span class="hljs-string">'Dec'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getDate() + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + months[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getMonth()] + <span class="hljs-string"><span class="hljs-string">'-'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getFullYear(); } }</code> </pre> <br><br><a name="section013"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versprich es mir </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Promise-Objekt wird für verzögerte und asynchrone Berechnungen verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen kann in drei Staaten sein:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausstehend: Ausgangszustand, nicht abgeschlossen und nicht abgelehnt. </font></font></li><li>  (fulfilled):   . </li><li>  (rejected):    . </li></ul><br>       (pending),      (fulfilled),    (),   (rejected),   .       ,     then. (         ,     , ..           « », , ,      DOM.) <br><br>    Promise.prototype.then()  Promise.prototype.catch()   ,    ,  . <br><img src="https://habrastorage.org/getpro/habr/post_images/835/119/a5c/835119a5c72db92a1ae89730a7af1251.png" alt="Bild"><br><br> <b>  (promise)</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Promise-Objekt wird mit dem neuen Schlüsselwort und seinem Konstruktor erstellt. </font><font style="vertical-align: inherit;">Der Promise-Konstruktor verwendet ein Argument, das als Executor-Funktion bezeichnet wird, als Argument. </font><font style="vertical-align: inherit;">Diese Funktion sollte zwei Rückruffunktionen als Parameter akzeptieren. </font><font style="vertical-align: inherit;">Die erste (Auflösung) wird aufgerufen, wenn die asynchrone Operation erfolgreich abgeschlossen wurde und das Ergebnis ihrer Ausführung als Wert zurückgegeben hat. </font><font style="vertical-align: inherit;">Der zweite Rückruf (Zurückweisen) wird aufgerufen, wenn die Operation fehlgeschlagen ist, und gibt einen Wert zurück, der den Grund für den Fehler angibt, meistens ein Fehlerobjekt.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   ,    : resolve(someValue); //   //  reject("failure reason"); //  });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Funktionsobjekt mit zwei Argumenten, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auflösen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ablehnen,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bewirkt </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> dass das Versprechen erfolgreich ist, das zweite lehnt es ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um der Funktion die Versprechensfunktionalität zur Verfügung zu stellen, müssen Sie nur das darin enthaltene Versprechungsobjekt zurückgeben.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAsyncFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url); xhr.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(xhr.responseText); xhr.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> reject(xhr.statusText); xhr.send(); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Hilfe. </font><font style="vertical-align: inherit;">Dann werden Ausführungs- und Ablehnungshandler angehängt.</font></font><br><cut></cut><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methoden</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.all (iterable) - Wartet darauf, dass alle Versprechen für eines von ihnen ausgeführt oder abgelehnt werden. </font><font style="vertical-align: inherit;">Gibt ein Versprechen zurück, das ausgeführt wird, nachdem alle Versprechen iterabel ausgeführt wurden. </font><font style="vertical-align: inherit;">Für den Fall, dass eines der Versprechen abgelehnt wird, wird Promise.all ebenfalls abgelehnt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.allSettled (iterable) - Wartet auf die Erfüllung aller empfangenen Versprechen (sowohl Ausführung als auch Ablehnung). </font><font style="vertical-align: inherit;">Gibt ein Versprechen zurück, das ausgeführt wird, wenn alle empfangenen Versprechen abgeschlossen (ausgeführt oder abgelehnt) sind, und enthält ein Array der Ergebnisse der Ausführung der empfangenen Versprechen.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Promise.race (iterable) - Wartet auf die Ausführung oder Ablehnung eines der erhaltenen Versprechen. </font><font style="vertical-align: inherit;">Gibt ein Versprechen zurück, das mit dem Ergebnis der Ausführung des ersten ausgeführten oder abgelehnten Versprechens von .iterable ausgeführt oder abgelehnt wird.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.reject (Grund) - Gibt ein aus einem Grund abgelehntes Versprechen zurück. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Promise.resolve (Wert) - Gibt das mit dem Ergebniswert ausgeführte Versprechen zurück. </font></font></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versprechen Prototyp</font></font></b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> catch (onRejected) - Fügt eine Rückruffunktion hinzu, um die Ablehnung eines Versprechens zu behandeln, die ein neues Versprechen zurückgibt, das mit dem übergebenen Wert gemacht wurde, wenn es aufgerufen wird, oder den ursprünglichen Auflösungswert, wenn das Versprechen gemacht wurde. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then (onFulfilled, onRejected) - Fügt einen Handler für die Erfüllung und Ablehnung von Versprechen hinzu und gibt ein neues Versprechen zurück, das mit dem Wert des aufgerufenen Handlers oder dem ursprünglichen Wert ausgeführt wurde, wenn das Versprechen nicht verarbeitet wurde (d. h. wenn der entsprechende Handler für onFulfilled oder onRejected keine Funktion ist). </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erstellen einer asynchronen http-Anforderung: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> URL = <span class="hljs-string"><span class="hljs-string">"https://getfestivo.com/v1/holidays?api_key=f8f42551-eb66-49d2-bcba-b8e42727ddfb&amp;country=US&amp;year=2019"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  API      function asyncHttpRequest (url) { return new Promise((resolve, reject) =&gt; { //  promise if (url == undefined) //     url reject(new Error("Expected url and received nothing")); else { resolve(() =&gt; { fetch(url).then((response) =&gt; { //   return response.json(); //    JSON   }).then((myJson) =&gt; { return(console.log(myJson)); //      }); }); } } );} asyncHttpRequest(URL).then((result) =&gt; result(), (error) =&gt; console.log(error));</span></span></code> </pre> <br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Beispiele und Informationen zu Versprechungen finden Sie in der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie in der Mozilla- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="section014"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iteratoren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verarbeitung jedes Elements in einer Sammlung ist eine sehr häufige Operation. JavaScript bietet verschiedene Möglichkeiten zum Durchlaufen einer Sammlung, von einer einfachen for-Schleife bis hin zu Map- (), Filter- () und Array-Verständnis. Iteratoren und Generatoren implementieren das Konzept der Aufzählung direkt in den Kern der Sprache und bieten einen Mechanismus zum Festlegen des Verhaltens für ... von Schleifen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objekt ist ein Iterator, wenn es einzeln auf die Elemente der Sammlung zugreifen kann, während es seine aktuelle Position innerhalb dieser Sequenz verfolgt. In JavaScript ist ein Iterator ein Objekt, das eine next () -Methode bereitstellt, die das nächste Element einer Sequenz zurückgibt. Diese Methode gibt ein Objekt mit zwei Eigenschaften zurück: done und value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Erstellung kann das Iteratorobjekt explizit verwendet werden, indem die next () -Methode aufgerufen wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterable - Dies ist ein Objekt, dessen Inhalt wiederholt werden kann. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das iterierbare Objekt unterscheidet sich vom nicht iterierbaren darin, dass es eine spezielle Methode hat, die ein Objekt für den Zugriff zurückgibt, auf das ein spezielles Symbol verwendet wird: Symbol.iterator</font></font><br><pre> <code class="javascript hljs">Iterable { [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.iterator]() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Objekt, das die Methode zurückgibt, wird formal als Iterator bezeichnet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Iterator hat nur eine next () -Methode</font></font><br><pre> <code class="javascript hljs">Iterator { next(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies gibt ein Objekt (nennen wir es itreratorResult) mit zwei Eigenschaften done und value zurück </font></font><br><pre> <code class="javascript hljs">IteratorResult { done, value }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> done gibt an, ob die gesuchte Sequenz noch einen Wert enthält und der Wert das nächste Element der Sequenz enthält. </font></font><br><cut></cut><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Initialisierung kann die next () -Methode aufgerufen werden, um nacheinander auf die Schlüssel-Wert-Paare im Objekt zuzugreifen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Objekt ist iterierbar, wenn es eine Methode zum Auflisten von Werten definiert, dh wie Werte im Konstrukt for..of aufgelistet werden. </font><font style="vertical-align: inherit;">Einige integrierte Typen wie Array oder Map sind standardmäßig iterierbar, andere Typen wie Object hingegen nicht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um iterierbar zu sein, muss ein Objekt die Iteratormethode implementieren. Dies bedeutet, dass es (oder eines der Objekte in der Prototypenkette) eine Eigenschaft namens Symbol.iterator haben muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So sieht der Standard-Iterator aus:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeIterator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">array</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nextIndex &lt; array.length ? { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: array[nextIndex++], <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } : { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; } } }</code> </pre> <br><br><a name="section015"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generatoren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren sind eine spezielle Art von Funktion, die wie eine Iteratorfabrik funktioniert. </font><font style="vertical-align: inherit;">Eine Funktion wird zum Generator, wenn sie eine oder mehrere Yield-Anweisungen enthält und die Funktionssyntax * verwendet.</font></font><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren sind eine neue Art von Funktion, die ihre Ausführung unterbrechen und ein Zwischenergebnis zurückgeben und die Ausführung später fortsetzen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns eine reguläre Funktion an, die etwas rechnet und ein Ergebnis zurückgibt:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myFunction(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// 9</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen Sie sich nun eine ähnliche Generatorfunktion an: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ a = a*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; a = a - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> it = generator(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(it.next().value); <span class="hljs-comment"><span class="hljs-comment">// 10 console.log(it.next().value); // 9&lt;/i&gt;</span></span></code> </pre> <cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie bereits erwähnt, können Generatoren ihre Ausführung unterbrechen und ein Zwischenergebnis zurückgeben. Dieses Beispiel zeigt, dass zum Zeitpunkt des ersten Aufrufs die Funktion, als ob sie ihre Ausführung beim ersten Haltepunktausbruch anhält, das Ergebnis des ersten Ausdrucks zurückgibt. Beim zweiten Aufruf wird die Funktion vom vorherigen Haltepunkt fortgesetzt und zum nächsten verschoben, wobei das Ergebnis des nächsten Ausdrucks zurückgegeben wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsgeneratoren bieten ein leistungsstarkes Werkzeug zum Schreiben komplexer sequentieller Funktionen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generatoren berechnen die Ergebnisse ihrer Ertragsausdrücke nach Bedarf, wodurch sie effizient mit Sequenzen mit hohem Rechenaufwand oder sogar mit unendlichen Sequenzen arbeiten können.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die next () -Methode verwendet auch einen Wert, mit dem der interne Zustand des Generators geändert werden kann. Der an next () übergebene Wert wird als Ergebnis des letzten Ertragsausdrucks betrachtet, der den Generator angehalten hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können den Generator zwingen, eine Ausnahme auszulösen, indem Sie seine throw () -Methode aufrufen und den Wert der Ausnahme übergeben, die als Parameter ausgelöst werden soll. Diese Ausnahme wird aus dem aktuell angehaltenen Kontext des Generators ausgelöst, als wäre die aktuell angehaltene Yield-Anweisung eine throw-Anweisung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Yield-Anweisung während der Verarbeitung der ausgelösten Ausnahme nicht auftritt, wird die Ausnahme oben über den Aufruf throw () übergeben, und das Ergebnis nachfolgender Aufrufe von next () wird als Eigenschaft true ausgeführt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generatoren haben eine Rückgabemethode (Wert), die den angegebenen Wert zurückgibt und den Generator stoppt. </font></font><br><br><a name="section016"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Symbol </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbol ist ein primitiver Datentyp, dessen Instanzen eindeutig und unveränderlich sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der JavaScript-Laufzeit wird durch Aufrufen der Funktion Symbol () ein Symbolwert erstellt, der dynamisch einen anonymen und eindeutigen Wert erstellt. </font><font style="vertical-align: inherit;">Die einzig sinnvolle Verwendung besteht darin, das Zeichen zu speichern und dann den gespeicherten Wert zu verwenden, um die Eigenschaft des Objekts zu erstellen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Zeichen als Bezeichner in einer Eigenschaftszuweisung verwendet wird, ist die Eigenschaft (z. B. ein Zeichen) anonym. </font><font style="vertical-align: inherit;">und auch nicht zählbar. </font><font style="vertical-align: inherit;">Da die Eigenschaft nicht berechenbar ist, wird sie nicht in der Schleife "for (... in ...)" angezeigt, und da die Eigenschaft anonym ist, wird sie nicht im Ergebnisarray "Object.getOwnPropertyNames ()" angezeigt. </font><font style="vertical-align: inherit;">Auf diese Eigenschaft kann mit dem Anfangswert des Symbols zugegriffen werden, mit dem sie erstellt wurde, oder indem das Ergebnisarray „Object.getOwnPropertySymbols ()“ durchlaufen wird.</font></font><br><br><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So können Sie eine Zeicheneigenschaft erstellen: </font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> user = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Alex"</span></span>, [<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"password"</span></span>)]: <span class="hljs-string"><span class="hljs-string">"12hsK3I"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Object.getOwnPropertySymbols (obj) -Eigenschaft, um ein Array von Zeichenobjekten abzurufen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Methoden Symbol.for () und Symbol.keyFor (), um auf eine beliebige Stelle in Ihrem Code zuzugreifen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weitere Informationen zum Datentyp Sumbol finden Sie in der offiziellen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie in der </font><font style="vertical-align: inherit;">Mozilla- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460741/">https://habr.com/ru/post/de460741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460729/index.html">Angenehm und nützlich im Unterricht</a></li>
<li><a href="../de460731/index.html">Die US-Behörden schließen 2017 eine Untersuchung eines Roboter-Busunfalls ab</a></li>
<li><a href="../de460735/index.html">CI \ CD für Startups: Welche Tools gibt es und warum werden sie nicht nur von großen und bekannten Unternehmen verwendet?</a></li>
<li><a href="../de460737/index.html">Hören Sie Hintergrund: Projektmanagement-Podcasts</a></li>
<li><a href="../de460739/index.html">Wir kamen in Frieden von der ganzen Menschheit</a></li>
<li><a href="../de460743/index.html">Flutter Anfängerleitfaden</a></li>
<li><a href="../de460745/index.html">Erfahrung in der Verwendung eines GSM-Moduls in der Hausautomation</a></li>
<li><a href="../de460747/index.html">Nach Gewinnen suchen oder Muttern festziehen: Spotify arbeitet nicht mehr direkt mit Autoren zusammen - was bedeutet das?</a></li>
<li><a href="../de460751/index.html">Wie wir Roboter im kleinen Tschernobyl gestartet haben. Teil 1</a></li>
<li><a href="../de460755/index.html">ROS Trolley Robot - Teil 1: Eisen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>