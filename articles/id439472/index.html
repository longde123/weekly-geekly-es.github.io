<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱 🤞🏽 ☪️ Otomatisasi kontrol perbatasan dalam perusahaan 🔶 🎷 ❄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sepotong buku teks tentang pemrograman bisnis. 


 Proses perbatasan adalah yang terbaik secara otomatis. Kedengarannya klise, tetapi rekomendasi sepe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Otomatisasi kontrol perbatasan dalam perusahaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439472/"><p>  Sepotong buku teks tentang pemrograman bisnis. </p><br><p>  Proses perbatasan adalah yang terbaik secara otomatis.  Kedengarannya klise, tetapi rekomendasi seperti itu masih jauh dari selalu dilaksanakan. </p><br><p>  Situasi masih umum ketika proses melintasi perbatasan tanpa menggunakan sistem otomatis.  Di banyak perusahaan, memo kertas, aplikasi, pesanan, dll sedang digunakan.  Tentu saja, ini tidak hanya berlaku untuk batas antara departemen - karyawan dari layanan yang sama juga berdosa dengan selembar kertas. </p><br><p>  Jika satu karyawan menyerahkan proses ke yang lain dalam bentuk kertas, melacak status tugas ini sangat sulit.  Metode dasar, luas kehilangan tugas semacam itu diungkapkan dalam ungkapan "bersih di bawah kain".  Ada baiknya jika karyawan menumpukkan kertas seperti itu di desktopnya - maka volume aplikasi setidaknya terlihat.  Secara teoritis, selembar kertas tertentu dalam tumpukan ini bahkan dapat ditemukan, dan tentukan sudah berapa lama antrian ini. </p><br><p> Metode mentransfer proses melalui email juga umum.  Sayangnya, pendekatan ini juga tidak bagus.  Dalam arti tertentu, itu bahkan lebih buruk daripada setumpuk kertas, karena  klien email tidak memiliki fungsionalitas yang memadai untuk mengelola surat sebagai tugas.  Seseorang hanya akan memiliki segunung surat, yang hampir tidak mungkin untuk menentukan keadaan antrian. </p><br><p>  Tentang pemindahan tugas secara lisan dan tidak layak dibicarakan.  Seperti yang mereka katakan, terbang ke satu telinga, terbang ke yang lain. <a name="habracut"></a></p><br><p>  Ada momen tidak menyenangkan lain yang terkait dengan pengetahuan tentang perbatasan.  Ketika satu orang telah menyerahkan tugas kepada orang lain - di atas kertas, secara lisan atau melalui email - maka pembawa tugas sekarang menjadi milik orang kedua.  Dari sudut pandang formal, moral, dan sering teknis, yang pertama tidak bisa lagi mempelajari tugas-tugas yang kedua.  Dengan struktur subordinasi tertentu, Anda tentu saja dapat menggali lebih dalam tumpukan kertas, tetapi membaca email orang lain sudah terlalu banyak.  Entah bagaimana masih mungkin untuk mengetahui keadaan satu atau lebih aplikasi Anda, contoh proses Anda, tetapi hampir tidak mungkin untuk menilai keadaan umum antrian “di perbatasan”. </p><br><p>  Jadi, kita memerlukan sistem kontrol perbatasan otomatis.  Ini memiliki beberapa persyaratan penting. </p><br><p>  <em>Persyaratan pertama</em> adalah bahwa sistem harus secara jelas mengidentifikasi antrian dan tugas di dalamnya.  Bahkan dalam sistem otomatis yang dikembangkan, ini tidak selalu memungkinkan.  Jika Anda meminta seseorang untuk menunjukkan pergantian tugasnya dalam program, ia akan dapat menunjukkan sesuatu - ia akan menunjukkan daftar dokumen, menerapkan beberapa filter dan penyortiran, dan Anda mendapatkan daftar tugas.  Jika Anda bertanya kepada programmer, ia akan melakukan hal yang sama, hanya saja tidak ada dalam daftar dokumen, tetapi, kemungkinan besar, dengan menanyakan data. </p><br><p>  Ungkapan kunci di sini adalah "jika Anda bertanya."  Dan jika Anda tidak bertanya?  Untuk seorang programmer bisnis, pertanyaan sederhana ini (“bagaimana jika Anda tidak bertanya?”) Dapat menjadi kriteria yang jelas untuk identifikasi perbatasan yang benar.  Jika Anda, sebagai pengamat luar, dapat, tanpa meminta karyawan, melihat daftar tugasnya, maka persyaratan pertama terpenuhi - antrian diidentifikasi. </p><br><p>  Dengan kesederhanaan yang tampak dari kriteria ini, Anda akan menemukan bahwa kebanyakan sistem otomatis tidak memenuhinya.  Memahami antrian seperti itu hanya di kepala seorang karyawan, bahkan di bawah Tsar Gorokh dan memo kantor, tetap dalam sistem otomatis.  Situasi ini akrab dan tampak normal, karena "semua orang memilikinya".  Tetapi jika Anda, sebagai programmer bisnis, ingin meningkatkan proses ini, maka Anda harus melakukan identifikasi antrian. </p><br><p>  <em>Persyaratan kedua</em> adalah bahwa antrian harus didekomposisi sebelum tugas, mis.  untuk entitas sederhana yang membutuhkan tindakan yang bisa dimengerti.  Terjadi bahwa antrian tampaknya diidentifikasi, tetapi tugas-tugas dari berbagai proses dicampur di dalamnya.  Dalam hal ini, kemampuan kontrol dan kemampuan kontrol antrian adalah pertanyaan serius. </p><br><p>  Kriteria sederhana: jika Anda, tanpa meminta seorang karyawan, dapat memberi tahu Anda untuk setiap tugas spesifik apa yang perlu dilakukan, maka antrian diurai dengan benar.  Jika jawabannya "perlu dipahami", atau "perlu untuk memperbaikinya", atau "belum melihat", maka penguraiannya buruk.  Sistem, dan prosesnya, terus bergantung pada karyawan. </p><br><p>  <em>Persyaratan ketiga</em> adalah bahwa prioritas untuk menyelesaikan tugas harus jelas.  Prinsipnya sama dengan kriteria sebelumnya.  Jika Anda, melihat antrian dari samping, melihat urutan tugas, maka prioritasnya jelas.  Jika Anda, atau konsumen proses, perlu bertanya kepada karyawan tentang prioritas, atau mengatur ulang prioritas ini setiap hari, maka antriannya tidak dikelola dengan baik. </p><br><p>  <em>Persyaratan keempat</em> adalah bahwa waktu yang dihabiskan oleh tugas dalam antrian, yaitu  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip "Gunung Es"</a> diterapkan.  Waktu yang dihabiskan biasanya terkait dengan prioritas eksekusi, tetapi ada juga konflik. </p><br><p>  Misalnya, sistem prioritas dibangun berdasarkan penyortiran ganda - pertama pentingnya, kemudian tanggal tugas.  Dalam hal ini, dengan volume besar tugas-tugas penting, itu tidak akan pernah mencapai yang tidak penting.  Jika prosesnya sedemikian rupa sehingga kekal pemenuhan beberapa tugas dianggap sebagai norma, maka tidak apa-apa.  Tapi, sebagai aturan, dalam proses streaming, penting untuk menyelesaikan semua tugas. </p><br><p>  Oleh karena itu, pengaruh timbal balik antara prioritas dan waktu yang dihabiskan dalam antrian harus dipantau.  Misalnya, setelah menetapkan sistem prioritas, tambahkan koefisien bobot ke waktu yang dihabiskan dalam antrian, sehingga pada nilai tertentu, tugas akan mengambang ke permukaan, terlepas dari pentingnya. </p><br><p>  Jadi, kriterianya sederhana: jika Anda melihat setiap tugas memiliki waktu dalam antrian, maka persyaratannya terpenuhi.  Kesalahan umum adalah pendapat bahwa itu cukup untuk mengetahui dan melihat tanggal dari pernyataan masalah, karena dalam kasus ini waktu yang dihabiskan dalam antrian dapat dengan mudah dihitung.  Otomasi sangat mudah dilakukan.  Tetapi menghitung dalam pikiran jauh lebih sulit, dan tidak satu pun karyawan waras yang akan melakukan ini.  Oleh karena itu, waktu yang dihabiskan dalam antrian tidak akan diperhitungkan dalam pekerjaan. </p><br><p>  <em>Persyaratan kelima</em> adalah tidak peduli seberapa usang, tetapi pelaksana tugas harus diketahui.  Jika pilihan kontraktor diatur oleh algoritma otomatis, maka momen ketika algoritma ini dijalankan harus dipahami. </p><br><p>  Selama tugas tidak memiliki pelaksana, itu tidak akan diselesaikan.  Kontraktor tidak harus ditugaskan untuk setiap tugas khusus - cukup untuk memahami bahwa solusi untuk semua tugas dari antrian yang diidentifikasi ditugaskan kepada orang tertentu. </p><br><p>  Pilihan kontraktor sering menyebabkan antrian menjadi menganggur dalam kasus di mana kontraktor dalam proses tidak menunjuk orang tertentu, tetapi posisi atau departemen.  Dalam hal ini, direkomendasikan bahwa pilihan pelaksana dilakukan sebagai tugas terpisah, yang harus dilakukan manajer atau operator tertentu.  Meskipun pilihan kontraktor bukanlah tugas, tetapi hak istimewa, antrian akan terus macet pada titik ini. </p><br><p>  Kriteria sederhana: melihat dari sisi garis, Anda harus tahu persis siapa yang akan melakukan tugas itu. </p><br><p>  <em>Persyaratan keenam</em> , dari area pemrograman bisnis yang lebih tinggi: sistem harus dapat melihat dan membandingkan antrian dari berbagai proses.  Dalam kasus umum, persyaratan seperti itu tidak pernah dipenuhi, jadi kita hanya bisa berbicara tentang tingkat kepatuhan. </p><br><p>  Masalahnya, biasanya, adalah bahwa antrian, tugas, dan proses yang berbeda adalah entitas sistem yang berbeda, dengan sekumpulan properti yang terpisah.  Ada contoh proses dalam satu antrian, tetapi tidak dalam yang lain.  Satu tugas memiliki tanggal produksi, sedangkan yang lainnya tidak.  Dll </p><br><p>  Mengingat keragaman entitas, biasanya tidak ada yang menyelesaikan tugas mengendalikan semua antrian "dalam satu jendela" - baik dalam sistem otomatis, maupun dalam kontrol manual.  Oleh karena itu, keadaan antrian - baik instan dan metrik per periode - tetap menjadi misteri, yang mengurangi efektivitas manajemen dan analisis. </p><br><p>  Sebagian bantuan adalah sistem kontrol proses yang "merangkai" berbagai dokumen utama menjadi entitas tunggal.  Ini adalah bagaimana kartu proses, tugas umum dan entitas pengalamatan muncul. </p><br><p>  Tetapi untuk seorang programmer bisnis, sayangnya, pendekatan ini sangat tidak cocok. </p><br><p>  Pertama, penerapan proses biasanya mengarah pada komplikasi otomatisasi - tidak begitu banyak dari periode pengembangan sebagai perubahan selanjutnya.  Proses, dengan kartu, pelaksana, tindakan dan kondisi, dengan sendirinya, adalah objek otomatisasi, dengan semua konsekuensi yang terjadi - kebutuhan untuk pemeliharaan, debugging, koordinasi, dll. </p><br><p>  Kedua, gambaran nyata dari proses, sebagai suatu peraturan, tidak dapat ditarik karena konflik “satu-banyak”.  Sebagian besar sistem gambar proses ingin satu objek berjalan pada satu waktu, bahkan jika objek tersebut berganda. </p><br><p>  Misalnya, proses mengeksekusi daftar permintaan pembelian.  Jika Anda menggambar peta ujung ke ujung dari proses ini, ternyata aplikasi yang sama berjalan dari awal hingga akhir.  Pemasok yang sama, dilihat dari peta proses, harus bekerja dengan setiap aplikasi secara terpisah, sebagai bagian dari contoh proses. </p><br><p>  Pada kenyataannya, pemasok sama sekali tidak berpartisipasi dalam proses ujung ke ujung.  Dia memiliki kartu sendiri, di pintu masuk yang merupakan array aplikasi.  Selain itu, setiap hari - dengan volume yang berbeda (termasuk, kadang-kadang, kosong).  Setelah menjalankan aplikasi spesifik dari instance pertama itu, manajemen kembali ke proses tunggal. </p><br><p>  Proses seperti itu hanya dapat ditarik menggunakan proses bersarang, yang biasanya berhasil, tetapi kesederhanaan dan kejelasan algoritma hilang - itu menjadi teknis, dapat dimengerti oleh programmer, tetapi tidak cocok untuk orang hidup dan manajemen. </p><br><p>  Ketiga, proses-proses semacam itu rentan terhadap birokratisasi - mereka berusaha menjadikannya “beton bertulang”, berkoordinasi, mencetak, dan meletakkannya di rak.  Pendekatan ini bertentangan dengan prinsip-prinsip otomasi cepat dan, oleh karena itu, tidak cocok untuk pemrograman bisnis.  Proses konkret, terutama selama periode debugging, sama dengan mencetak kode program. </p><br><p>  Dan, keempat, pengembang mekanisme untuk proses menggambar, hanya dipandu oleh logika programmer, tidak menyediakan alat manajemen antrian.  Dengan demikian, untuk menganalisis semua garis di perbatasan, untuk membandingkannya satu sama lain, saat bepergian tidak akan berfungsi.  Anda masih harus menemukan alat Anda sendiri. </p><br><p>  Metode menggambar "beton bertulang" proses dapat digunakan sebagai alat bantu, tidak akan ada banyak bahaya.  Atau, dapat digunakan pada akhir proyek, sebagai cara untuk melestarikan proses yang dikonfigurasi.  Sampai proyek selanjutnya. </p><br><p>  Namun, jangan lupakan poin ketiga - kecenderungan birokratisasi.  Jika menurut Anda Anda dapat mempertahankan sistem untuk sementara waktu, maka karyawan dan manajer lainnya memiliki pendapat yang berlawanan: jangan menyentuh apa yang berhasil.  Sistem yang dibuat, didebug dan diimplementasikan oleh Anda akan mulai melawan Anda. </p><br><p>  Jauh lebih baik menggunakan prinsip "Tugas Otomatis" atau serupa ketika sistem Anda memiliki entitas yang dapat "melampirkan" ke proses yang sedang berlangsung dan membangun tugas dalam antrian.  Prinsip itu sendiri akan dipertimbangkan kemudian. </p><br><p>  Sebuah entitas tunggal untuk mengelola antrian di perbatasan memberikan, pertama-tama, sistem koordinat tunggal - metrik semua proses dalam unit yang sama.  Setiap proses dapat dievaluasi - baik secara instan maupun dalam retrospeksi - pada skala yang sama. </p><br><p>  Evaluasi instan dapat diimplementasikan, misalnya, dalam panel kontrol proses umum.  Tidak dalam peta proses umum tradisional, yang tidak dapat dilihat pada satu layar tanpa menggulir, tetapi dalam bentuk daftar sederhana, bahkan tanpa angka, menggunakan tampilan warna, seperti lampu lalu lintas.  Ini akan menghasilkan daftar dua kolom: proses dan status. </p><br><p>  Opsi ini sedikit lebih menarik - bukan daftar proses, tetapi daftar poin masalah.  Intinya, dalam hal ini, adalah autotask, simpul tertentu dari proses tertentu, yang jelas dapat dibandingkan dengan kehidupan.  Misalnya, "perjanjian kontrak oleh pengacara".  Cukup dengan mendaftar semua poin, menunjukkan statusnya, dan mengurutkannya sehingga poin yang paling bermasalah muncul di bagian atas. </p><br><p>  Penilaian seketika atas semua proses, terlepas dari kesederhanaan dan kejelasannya, sangat jarang.  Sekarang kamu mengerti kenapa. </p><br><p>  Analisis antrian retrospektif adalah kejadian yang bahkan lebih jarang terjadi karena kebanyakan sistem tidak mengandung data yang diperlukan sama sekali.  Data tersebut hanya tersedia jika prinsip Iceberg sepenuhnya digunakan, ketika tidak hanya waktu keadaan sesaat disimpan, tetapi juga sejarahnya. </p><br><p>  Secara umum, seperti yang Anda lihat, tidak ada yang rumit dalam mengotomatisasi kontrol perbatasan.  Penting untuk tidak membuat kesulitan secara artifisial menggunakan proses "beton bertulang" dan mengabaikan prinsip-prinsip otomatisasi cepat.  Pendekatan dan kriteria yang perlu Anda gunakan saat mengotomatiskan keadaan batas proses sekarang diketahui oleh Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439472/">https://habr.com/ru/post/id439472/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439462/index.html">Peradaban Musim Semi, 5/5</a></li>
<li><a href="../id439464/index.html">VXinspect: kontrol kualitas bagian dalam 10 menit</a></li>
<li><a href="../id439466/index.html">Penyelidikan orbit bulan NASA mengambil gambar pertama dari stasiun China Chang'e-4 - dua piksel cahaya</a></li>
<li><a href="../id439468/index.html">Di mana pencarian SCADA yang sempurna mengarah</a></li>
<li><a href="../id439470/index.html">Jerman berencana untuk meninggalkan batubara dalam waktu dekat</a></li>
<li><a href="../id439476/index.html">Bahasa gaul Cockney: sejarah modern dan status sosial</a></li>
<li><a href="../id439478/index.html">Menghibur C #. Lima contoh rehat kopi</a></li>
<li><a href="../id439480/index.html">Beri jalan, atau Mengapa CRM Anda (dan CRM) melambat?</a></li>
<li><a href="../id439482/index.html">devleads - (un) motivasi finansial</a></li>
<li><a href="../id439484/index.html">Mendapatkan data enum dalam perspektif Automapper</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>