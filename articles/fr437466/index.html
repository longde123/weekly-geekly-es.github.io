<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏼 💇🏾 🍠 Octet-machine pour le fort (et pas seulement) en amérindien (partie 4) 😧 💓 🤙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Et encore une fois, j'ai surestimé le volume de l'article! J'ai prévu que ce serait le dernier article, où nous ferons un compilateur et effectuerons ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Octet-machine pour le fort (et pas seulement) en amérindien (partie 4)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437466/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Fort Byte Car (et plus) Native American"><br><br>  Et encore une fois, j'ai surestimé le volume de l'article!  J'ai prévu que ce serait le dernier article, où nous ferons un compilateur et effectuerons des tests.  Mais le volume s'est avéré important et j'ai décidé de diviser l'article en deux. <br><br>  Dans cet article, nous ferons presque toutes les fonctions de base du compilateur.  Il prendra vie et il sera possible d'écrire, de compiler et d'exécuter du code assez sérieux.  Et nous ferons des tests dans la partie suivante.  (Au fait, les parties précédentes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trois</a> ). <br><br>  J'écris pour la première fois à Habré, ce n'est peut-être pas toujours bien.  À mon avis, les articles 2, 3 se sont révélés plutôt secs, beaucoup de code, peu de description.  Cette fois, je vais essayer de faire quelque chose de différent, en me concentrant sur la description des idées elles-mêmes.  Eh bien, le code ... le code, bien sûr qu'il le sera!  Qui veut bien comprendre, une telle opportunité sera.  Dans de nombreux cas, je mettrai le code sous le spoiler.  Et, bien sûr, vous pouvez toujours consulter la source complète sur le github. <br><br>  Le compilateur continuera à écrire pendant un certain temps dans l'assembleur, mais ensuite aller au fort et continuer à écrire le compilateur sur nous-mêmes.  Cela ressemblera au baron Munchausen, qui s'est tiré par les cheveux du marais.  Mais, pour commencer, je vais décrire comment fonctionne le compilateur sur le fort.  Bienvenue au chat! <br><a name="habracut"></a><br><h4>  Comment fonctionne le compilateur? </h4><br>  La mémoire du fort consiste en un fragment continu dans lequel les entrées du dictionnaire sont disposées séquentiellement.  Après leur achèvement est suivi d'une zone de mémoire libre.  Le premier octet libre est indiqué par la variable h.  Il y a aussi le mot souvent utilisé ici, qui pousse l'adresse du premier octet libre sur la pile, il est déterminé très simplement: <br><br><pre><code class="cpp hljs">: here h @ ;</code> </pre> <br><img src="https://habrastorage.org/webt/bd/eg/sq/bdegsqg7t06egwbvxoib9lqk_nc.png"><br><br>  Il convient de mentionner le mot allot, qui réserve le nombre spécifié d'octets en déplaçant le pointeur h.  Le mot attribuer peut être défini comme suit: <br><br><pre> <code class="cpp hljs">: allot h +! ;</code> </pre> <br>  En fait, le compilateur utilise un mode interpréteur spécial et quelques mots spéciaux.  Donc, avec une phrase, vous pouvez décrire tout le principe du compilateur dans le fort.  Le mode de fonctionnement de l'interpréteur est déterminé par la variable d'état.  S'il est nul, le mode d'exécution est défini, sinon - le mode de compilation.  Nous connaissons déjà le mode d'exécution, les mots du tampon d'entrée y sont simplement exécutés l'un après l'autre.  Mais en mode compilation, ils ne sont pas exécutés, mais sont compilés en mémoire par le pointeur h.  Par conséquent, le pointeur avance. <br><br>  Dans le fort classique, le mot "," est utilisé pour compiler une valeur entière, le mot "c", est utilisé pour compiler un octet.  Notre système utilise des valeurs de différentes profondeurs de bits (8, 16, 32, 64), par conséquent, nous allons également créer les mots «w» et «i».  Nous créons également le mot «str», qui compilera la chaîne, en prenant deux valeurs dans la pile - l'adresse et la longueur de la chaîne. <br><br>  Des mots de compilation spéciaux sont utilisés pour former des structures de contrôle.  Ce sont les mots if, do, loop, et autres.  Ces mots sont exécutés même en mode compilation.  Par exemple, le mot if compile une commande d'octet de branche conditionnelle (? Nbranch) à l'exécution.  Pour que le système sache quels mots doivent être exécutés en mode compilation et non compilés, le drapeau immédiat (signe) est utilisé.  Nous l'avons déjà dans le champ indicateur de l'entrée du dictionnaire.  Dans le code source de l'assembleur, il est appelé f_immediate.  Pour définir ce drapeau, utilisez le mot immédiat.  Il n'a pas de paramètres, l'indicateur immédiat est positionné au dernier mot du dictionnaire. <br><br>  Passons maintenant de la théorie à la pratique! <br><br><h4>  La préparation </h4><br>  Au début, nous devons faire quelques commandes d'octets simples en langage assembleur dont nous avons besoin.  Les voici: déplacer (copier la zone mémoire), remplir (remplir la zone mémoire), opérations sur les bits (et, ou, xor, inverser), commandes de décalage des bits (rshift, lshift).  Faisons le même rpick (c'est la même chose que pick, cela ne fonctionne qu'avec la pile de retour, pas la pile de données). <br><br><div class="spoiler">  <b class="spoiler_title">Ces commandes sont très simples, voici leur code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_move = <span class="hljs-number"><span class="hljs-number">0x66</span></span> bcmd_move: pop rcx pop rdi pop rsi repz movsb jmp _next b_fill = <span class="hljs-number"><span class="hljs-number">0x67</span></span> bcmd_fill: pop rax pop rcx pop rdi repz stosb jmp _next b_rpick = <span class="hljs-number"><span class="hljs-number">0x63</span></span> bcmd_rpick: pop rcx push [rbp + rcx * <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_and = <span class="hljs-number"><span class="hljs-number">0x58</span></span> bcmd_and: pop rax <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [rsp], rax jmp _next b_or = <span class="hljs-number"><span class="hljs-number">0x59</span></span> bcmd_or: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [rsp], rax jmp _next b_xor = <span class="hljs-number"><span class="hljs-number">0x5A</span></span> bcmd_xor: pop rax xor [rsp], rax jmp _next b_invert = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> bcmd_invert: notq [rsp] jmp _next b_rshift = <span class="hljs-number"><span class="hljs-number">0x5C</span></span> bcmd_rshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shrq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next b_lshift = <span class="hljs-number"><span class="hljs-number">0x5D</span></span> bcmd_lshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shlq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next</code> </pre> </div></div><br>  Encore faut-il faire le mot mot.  C'est la même chose que blword, mais un délimiteur spécifique est indiqué sur la pile.  Je ne fournis pas le code, il peut être trouvé dans la source.  J'ai fait copier / coller les mots blworld et remplacé les commandes de comparaison. <br><br>  En conclusion, nous faisons le mot syscall.  Avec lui, il sera possible de faire les opérations système manquantes, par exemple, en travaillant avec des fichiers.  Une telle solution ne fonctionnera pas si l'indépendance de la plateforme est requise.  Mais ce système est maintenant utilisé pour les tests, alors qu'il en soit ainsi pour l'instant.  Si nécessaire, toutes les opérations peuvent être converties en commandes d'octets, ce n'est pas du tout difficile.  La commande syscall acceptera 6 paramètres pour l'appel système et le numéro d'appel de la pile.  Il renverra un paramètre.  Les affectations de paramètres et la valeur de retour sont déterminées par le numéro d'appel système. <br><br><pre> <code class="cpp hljs">b_syscall = <span class="hljs-number"><span class="hljs-number">0xFF</span></span> bcmd_syscall: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 pop rax pop r9 pop r8 pop r10 pop rdx pop rsi pop rdi syscall push rax mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre><br>  Et maintenant, passons directement au compilateur. <br><br><h4>  Compilateur </h4><br>  Créons la variable h, tout est simple ici. <br><br><pre> <code class="cpp hljs"> item h h: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre>  Nous écrirons son initialisation dans la ligne de départ: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! h dup 8 + swap ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call16 .word h - . - 2 .byte b_dup, b_num8, b_add, b_swap, b_set .byte b_quit</span></span></code> </pre><br>  Faisons le mot ici: <br><br><pre> <code class="cpp hljs"> item here .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_get .byte b_exit</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Et aussi des mots pour compiler les valeurs: "allot" et "c,", "w,", "i,", ",", "str,"</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : allot h +! ; item allot allot: .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_setp, b_exit # : , here ! <span class="hljs-number"><span class="hljs-number">8</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">","</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set, b_num8, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : i, here i! <span class="hljs-number"><span class="hljs-number">4</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"i,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set32, b_num4, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : w, here w! <span class="hljs-number"><span class="hljs-number">2</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"w,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set16, b_num2, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : c, here c! <span class="hljs-number"><span class="hljs-number">1</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"c,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set8, b_num1, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : str, dup -rot dup c, here swap move <span class="hljs-number"><span class="hljs-number">1</span></span>+ h +!; item <span class="hljs-string"><span class="hljs-string">"str,"</span></span> c_str: .byte b_dup, b_mrot, b_dup callb c_8 callb here .byte b_swap, b_move callb h .byte b_setp .byte b_exit</code> </pre></div></div><br>  Faisons maintenant la variable d'état et deux mots pour contrôler sa valeur: "[" et "]".  Habituellement, ces mots sont utilisés pour effectuer quelque chose au moment de la compilation.  Par conséquent, le mot "[" désactive le mode de compilation et le mot "]" le active.  Mais rien ne les empêche d'être utilisés dans d'autres cas lorsqu'il est nécessaire d'activer ou de désactiver le mode de compilation.  Le mot "[" sera notre premier mot avec le signe immédiat.  Sinon, il ne pourra pas désactiver le mode de compilation, car il sera compilé et non exécuté. <br><br><pre> <code class="cpp hljs"> item state .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-string"><span class="hljs-string">"]"</span></span> .byte b_num1 callb state .byte b_set, b_exit item <span class="hljs-string"><span class="hljs-string">"["</span></span>, f_immediate .byte b_num0 callb state .byte b_set, b_exit</code> </pre><br>  Le tour est venu pour le mot $ compile.  Il prendra l'adresse de l'entrée du dictionnaire de la pile et compilera le mot spécifié.  Pour compiler un mot dans des implémentations de Fort ordinaires, il suffit d'appliquer le mot "," à l'adresse d'exécution.  Tout est beaucoup plus compliqué ici.  Premièrement, il existe deux types de mots - le bytecode et le code machine.  Les premiers sont compilés par octet et les seconds par la commande call byte.  Et deuxièmement - nous avons jusqu'à quatre variantes de la commande d'appel: call8, call16, call32 et call64.  Quatre?  Non!  Quand j'ai écrit le compilateur, j'en ai ajouté 16 de plus à ces quatre!  :) <br><br>  Comment est-ce arrivé?  Nous devons faire une petite digression. <br><br><h4>  Amélioration de la commande d'appel </h4><br>  Lorsque le compilateur a commencé à fonctionner, j'ai constaté que dans de nombreux cas (mais pas tous) la commande call8 était suffisante.  C'est lorsque le mot appelé est dans les 128 octets.  J'ai pensé - et comment faire en sorte que cela se produise dans presque tous les cas?  Comment mettre plus de 256 valeurs dans un octet? <br>  Le premier point que j'ai remarqué est que dans le fort, l'appel va toujours vers des adresses plus basses.  Cela signifie que vous pouvez refaire la commande d'appel de telle manière qu'elle ne puisse appeler que des adresses inférieures, mais pour 256 octets, pas 128. C'est mieux. <br><br>  Mais si vous mettez quelques morceaux quelque part ... Il s'avère qu'il y a où!  Nous avons deux octets: un octet est la commande, le second est l'offset.  Mais rien n'empêche les bits inférieurs de la commande de placer les bits hauts du paramètre (offset).  Pour une machine à octets, il semble qu'au lieu d'une commande d'appel, il y en ait plusieurs.  Oui, de cette façon, nous occupons plusieurs cellules de la table de code d'octet-commande avec une seule commande, mais parfois cela vaut la peine.  La commande d'appel est l'une des commandes les plus utilisées, j'ai donc décidé de mettre 4 bits de décalage dans la commande.  Ainsi, vous pouvez effectuer un appel à une distance pouvant atteindre 4095 octets!  Cela signifie qu'une commande d'appel aussi courte sera utilisée presque toujours.  J'ai placé ces commandes avec le code 0xA0 et les lignes suivantes sont apparues dans le tableau de commandes: <br><br><pre> <code class="cpp hljs">.quad bcmd_call8b0, bcmd_call8b1, bcmd_call8b2, bcmd_call8b3, bcmd_call8b4, bcmd_call8b5, bcmd_call8b6, bcmd_call8b7 # <span class="hljs-number"><span class="hljs-number">0xA0</span></span> .quad bcmd_call8b8, bcmd_call8b9, bcmd_call8b10, bcmd_call8b11, bcmd_call8b12, bcmd_call8b13, bcmd_call8b14, bcmd_call8b15</code> </pre> <br>  La première de ces commandes d'octets effectue simplement un appel en direction d'adresses inférieures à l'offset spécifié dans le paramètre (jusqu'à 255).  Les autres ajoutent le décalage correspondant au paramètre.  bcmd_call8b1 ajoute 256, bcmd_call8b2 ajoute 512, et ainsi de suite.  J'ai fait la première commande d'appel séparément, le reste avec une macro. <br><br>  Première commande: <br><br><pre> <code class="cpp hljs">b_call8b0 = <span class="hljs-number"><span class="hljs-number">0xA0</span></span> bcmd_call8b0: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 sub r8, rax jmp _next</code> </pre><br>  Macro et création du reste des commandes d'appel: <br><br><pre> <code class="cpp hljs">.macro call8b N b_call8b\N = <span class="hljs-number"><span class="hljs-number">0xA</span></span>\N bcmd_call8b\N: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 add rax, \N * <span class="hljs-number"><span class="hljs-number">256</span></span> mov [rbp], r8 sub r8, rax jmp _next .endm call8b <span class="hljs-number"><span class="hljs-number">1</span></span> call8b <span class="hljs-number"><span class="hljs-number">2</span></span> call8b <span class="hljs-number"><span class="hljs-number">3</span></span> call8b <span class="hljs-number"><span class="hljs-number">4</span></span> call8b <span class="hljs-number"><span class="hljs-number">5</span></span> call8b <span class="hljs-number"><span class="hljs-number">6</span></span> call8b <span class="hljs-number"><span class="hljs-number">7</span></span> call8b <span class="hljs-number"><span class="hljs-number">8</span></span> call8b <span class="hljs-number"><span class="hljs-number">9</span></span> call8b <span class="hljs-number"><span class="hljs-number">10</span></span> call8b <span class="hljs-number"><span class="hljs-number">11</span></span> call8b <span class="hljs-number"><span class="hljs-number">12</span></span> call8b <span class="hljs-number"><span class="hljs-number">13</span></span> call8b <span class="hljs-number"><span class="hljs-number">14</span></span> call8b <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Eh bien, j'ai refait l'ancienne commande call8 pour faire un renvoi, car nous avons déjà 16 équipes qui font un rappel.  Quelle que soit la confusion, je l'ai renommé b_call8f: <br><br><pre> <code class="cpp hljs">b_call8f = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8f: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next</code> </pre><br>  Soit dit en passant, pour plus de commodité, j'ai créé une macro qui, dans l'assembleur, compile automatiquement l'appel correspondant dans 4095. Et je n'en ai jamais eu besoin :) <br><br><pre> <code class="cpp hljs">.macro callb adr .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \adr &gt; . .error <span class="hljs-string"><span class="hljs-string">"callb do not for forward!"</span></span> .endif .byte b_call8b0 + (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> .byte (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> .endm</code> </pre> <br>  Et maintenant ... <br><br><h4>  Compilation d'équipe </h4><br>  Nous obtenons donc un algorithme de compilation de commandes assez compliqué.  S'il s'agit d'une commande d'octets, compilez juste un octet (code de commande d'octets).  Et si ce mot est déjà écrit en bytecode, vous devez compiler son appel avec la commande call, en choisissant un parmi vingt.  Plus précisément 19, nous n'avons donc pas de renvoi d'appel, et call8f ne sera pas utilisé pour le fort. <br><br>  Donc, le choix est le suivant.  Si le décalage est compris entre 0 et 4095, sélectionnez la commande bcmd_call8b avec le code 0xA0, en plaçant les quatre bits de décalage les plus significatifs dans les bits les moins significatifs de la commande.  Dans le même temps, pour la machine d'octets, le code de l'une des commandes bcmd_call8b0 est bcmd_call8b15. <br><br>  Si le décalage vers l'arrière est supérieur ou égal à 4095, nous déterminons dans quelle dimension le décalage est placé et utilisons la commande appropriée à partir de call16 / 32/64.  Il ne faut pas oublier que la compensation pour ces équipes est signée.  Ils peuvent provoquer à la fois en avant et en arrière.  Par exemple, call16 peut appeler une distance de 32767 dans les deux sens. <br><br>  Voici l'implémentation en conséquence: <br><br>  <b>$ compiler</b> <br><br>  Compile un mot.  En paramètre, prend l'adresse de l'entrée du dictionnaire du mot compilé.  En fait, il vérifie l'indicateur f_code, calcule l'adresse de code (cfa) et appelle compile_b ou compile_c (si l'indicateur est défini). <br><br>  <b>compile_c</b> <br><br>  Compile une commande d'octets.  Le mot le plus simple ici est décrit sur le fort comme ceci: <br><br><pre> <code class="cpp hljs">: compile_c c@ c, ;</code> </pre> <br>  <b>compile_b</b> <br>  Il prend une adresse de bytecode sur la pile et compile son appel. <br><br>  <b>test_bv</b> <br><br>  Il prend un décalage par rapport à la pile (avec un signe) et détermine la profondeur de bits à utiliser (1, 2, 4 ou 8 octets).  Renvoie la valeur 0, 1, 2 ou 3. En utilisant ce mot, vous pouvez déterminer celui à utiliser à partir des commandes call16 / 32/64.  Ce mot sera utile lors de la compilation de nombres (un choix parmi lit8 / 16/32/64). <br><br>  Au fait, vous pouvez démarrer le système et «jouer» dans la console du fort avec l'un de ces mots.  Par exemple: <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 222 test_bv ( 2 ): 222 1 &gt; drop drop ( 0 ): &gt; 1000000 test_bv ( 2 ): 1000000 2 &gt; drop drop ( 0 ): &gt; -33 test_bv ( 2 ): -33 0 &gt;</code> </pre> <br>  <b>test_bvc</b> <br><br>  Il prend un décalage (avec un signe) de la pile et détermine la commande d'appel à utiliser.  En fait, il vérifie si le décalage se situe dans la plage de 0 à -4095 et renvoie 0. Dans ce cas, s'il n'y a pas de résultat dans cet intervalle, il appelle test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">C'est tout ce qu'il faut pour compiler la commande.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : test_bvc dup <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= over FFF &lt;= <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... item test_bvc test_bvc: .byte b_dup, b_neg .byte b_num0 .byte b_gteq .byte b_over, b_neg .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0xFFF</span></span> .byte b_lteq .byte b_and .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_num0 .byte b_exit item test_bv test_bv: .byte b_dup, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_gteq, b_over, b_lit8, <span class="hljs-number"><span class="hljs-number">0x7f</span></span>, b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_num0 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x8001</span></span> .byte b_gteq .byte b_over .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x7ffe</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_num1, b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_dup .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80000002</span></span> .byte b_gteq .byte b_over .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x7ffffffd</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_num2, b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_num3 .byte b_exit #  - item compile_c compile_c: .byte b_get8 callb c_8 .byte b_exit #   - item compile_b compile_b: callb here .byte b_num2, b_add .byte b_sub callb test_bvc .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop .byte b_neg .byte b_dup .byte b_lit8, <span class="hljs-number"><span class="hljs-number">8</span></span> .byte b_rshift .byte b_lit8, b_call8b0 .byte b_or callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_call16 callb c_8 .byte b_wm callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_call32 callb c_8 .byte b_num3, b_sub callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_call64 callb c_8 .byte b_lit8, <span class="hljs-number"><span class="hljs-number">7</span></span>, b_sub callb c_64 .byte b_exit #: $compile dup c@ <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa compile_c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa compile_b then ; item <span class="hljs-string"><span class="hljs-string">"$compile"</span></span> _compile: .byte b_dup, b_get8, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_cfa callb compile_c .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_cfa callb compile_b .byte b_exit</code> </pre><br></div></div><br>  Maintenant, nous devons compiler le nombre. <br><br><h4>  Compilation d'un nombre (littéral) </h4><br>  A écrit un sous-titre entier, préparé pour décrire spécifiquement la compilation du littéral, mais il s'avère qu'il n'y a rien de spécial à décrire :) <br><br>  Nous avons déjà fait la moitié du travail dans le mot test_bv.  Il ne reste plus qu'à appeler test_bv, et, selon le résultat, compiler lit8 / 16/32/64, puis la valeur correspondante de 1, 2, 4 ou 8 octets. <br><br><div class="spoiler">  <b class="spoiler_title">Nous le faisons en définissant le mot compile_n</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#   item compile_n compile_n: callb test_bv .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop, b_lit8, b_lit8 callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_lit16 callb c_8 callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_lit32 callb c_8 callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_lit64 callb c_8 callb c_64 .byte b_exit</code> </pre></div></div><br><h4>  Modifier l'interprète </h4><br>  Tout est prêt pour compiler la commande et les littéraux.  Maintenant, il doit être intégré à l'interpréteur.  Cette modification est simple.  Où la commande a été exécutée, ajoutez la vérification d'état.  Si l'état n'est pas nul et que le mot ne contient pas le drapeau immédiat, au lieu de l'exécution, vous devez appeler $ compile.  Et à peu près la même chose à faire lorsque le nombre est obtenu à partir du flux d'entrée.  Si l'état est nul, laissez simplement le numéro sur la pile et sinon, appelez compile_n. <br><br><div class="spoiler">  <b class="spoiler_title">Voici l'interprète</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop callb state .byte b_get .byte b_qnbranch8, irpt_execute - . #  <span class="hljs-number"><span class="hljs-number">0</span></span>,    .byte b_dup, b_get8, b_lit8, f_immediate, b_and #  immediate    .byte b_qbranch8, irpt_execute - . #    -   #   ! callb _compile .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . irpt_execute: .byte b_cfa #  ,    (state = <span class="hljs-number"><span class="hljs-number">0</span></span>  immediate  ) .byte b_execute .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) #   -   callb state # ,    .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . #   -     ;   -   #   callb compile_n <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre></div></div><br>  Maintenant, nous sommes à un pas du compilateur ... <br><br><h4>  Définition de nouveaux mots (mot ":") </h4><br>  Maintenant, si nous définissons la variable d'état sur une valeur non nulle, le processus de compilation commencera.  Mais le résultat sera inutile, nous ne pourrons ni le réaliser, ni même le retrouver en mémoire.  Pour permettre de faire tout cela, il faut formater le résultat de la compilation sous la forme d'un article de dictionnaire.  Pour ce faire, avant d'activer le mode de compilation, vous devez créer un titre pour le mot. <br><br>  L'en-tête doit contenir des drapeaux, un champ de communication et un nom.  Ici, nous avons une histoire familière - le champ de communication peut être de 1, 2, 4 ou 8 octets.  Faisons le mot compile_1248, qui nous aidera à former un tel champ de communication.  Il faudra deux nombres sur la pile - l'offset et la valeur générée par la commande test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">compile_1248</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#    , ,     #     ,  test_dv item compile_1248 compile_1248: .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_drop callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: callb c_64 .byte b_exit</code> </pre></div></div><br>  Maintenant, créez le mot $ create.  Il nous sera utile plus d'une fois.  Vous pouvez l'utiliser chaque fois que vous devez créer un titre pour une entrée de dictionnaire.  Il prendra deux valeurs de la pile - l'adresse du nom du mot créé et sa longueur.  Après avoir exécuté ce mot, l'adresse de l'entrée de dictionnaire créée apparaîtra sur la pile. <br><br><div class="spoiler">  <b class="spoiler_title">$ créer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : $create here current @ @ here - test_bv dup c, compile_1248 -rot str, current @ ! <span class="hljs-string"><span class="hljs-string">' var0 here c!; item "$create" create: callb here callb current .byte b_get, b_get callb here .byte b_sub callb test_bv .byte b_dup callb c_8 callb compile_1248 .byte b_mrot callb c_str #       callb current .byte b_get, b_set #     - var0,      here #   ,    -    ,    #     ,     #    1 allot   ,   .byte b_lit8, b_var0 callb here .byte b_set8 .byte b_exit</span></span></code> </pre> </div></div><br>  Le mot suivant récupérera le nom du nouveau mot dans le flux d'entrée en utilisant le mot blword et appellera $ create, créant un nouveau mot avec le nom spécifié. <br><br><div class="spoiler">  <b class="spoiler_title">create_in</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item <span class="hljs-string"><span class="hljs-string">"create_in"</span></span> create_in: .byte b_blword .byte b_dup .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> #     <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\ncreate_in - name not found!\n"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: callb create .byte b_exit</code> </pre></div></div><br>  Et enfin, faites le mot ":".  Il va créer un nouveau mot en utilisant create_in et définir le mode de compilation, il n'est pas installé.  Et s'il est installé, il donne une erreur.  Le mot ":" aura le signe immédiat. <br><br><div class="spoiler">  <b class="spoiler_title">le mot:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : : create_in <span class="hljs-number"><span class="hljs-number">1</span></span> state dup @ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .<span class="hljs-string"><span class="hljs-string">" : - no execute state!"</span></span> then ! <span class="hljs-number"><span class="hljs-number">110</span></span> ; immediate item <span class="hljs-string"><span class="hljs-string">":"</span></span>, f_immediate colon: callb create_in .byte b_num1 callb state .byte b_dup .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">3f</span></span> #     <span class="hljs-number"><span class="hljs-number">3</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n: - no execute state!\n"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_set .byte b_lit8, <span class="hljs-number"><span class="hljs-number">110</span></span> .byte b_exit</code> </pre></div></div><br>  Si quelqu'un a regardé le code, il a vu que ce mot fait autre chose :) <br><br>  Et voici 110 ??? <br><br>  Oui, ce mot pousse également le nombre 110 sur la pile, et c'est pourquoi.  Une fois compilées, les différentes constructions doivent être un seul ensemble.  Par exemple, après si doit être alors.  Et le mot créé en utilisant ":" devrait se terminer par ";".  Pour vérifier ces conditions, des mots spéciaux du compilateur mettent certaines valeurs sur la pile et vérifient leur présence.  Par exemple, le mot ":" met la valeur 110 et le mot ";"  vérifie que 110 se trouve en haut de la pile. Si ce n'est pas le cas, c'est une erreur.  Ainsi, les structures de contrôle n'étaient pas appariées. <br><br>  Une telle vérification est effectuée dans tous ces mots du compilateur, par conséquent, nous allons faire un mot spécial pour cela - "? Paires".  Il prendra deux valeurs de la pile et générera une erreur si elles ne sont pas égales. <br><br>  De plus, en de tels mots, vous devez souvent vérifier que le mode de compilation est défini.  Faisons le mot "? État" pour cela. <br><br><div class="spoiler">  <b class="spoiler_title">? paires? état</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#: ?pairs = ifnot <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> then .<span class="hljs-string"><span class="hljs-string">" \nerror: no pairs operators"</span></span> quit then ; item <span class="hljs-string"><span class="hljs-string">"?pairs"</span></span> .byte b_eq, b_qbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no pairs operators"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit #: ?state state @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span><span class="hljs-string"><span class="hljs-string">" error: no compile state"</span></span> then ; item <span class="hljs-string"><span class="hljs-string">"?state"</span></span> callb state .byte b_get, b_zeq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no compile state"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit</code> </pre></div></div><br>  C’est tout!  Nous ne compilerons rien d'autre dans l'assembleur manuellement :) <br><br>  Mais jusqu'à la fin, le compilateur n'a pas encore été écrit, donc au début vous devrez utiliser des méthodes inhabituelles ... <br><br><h4>  Préparons-nous à compiler le compilateur créé avec le compilateur créé </h4><br>  Pour commencer, vous pouvez vérifier le fonctionnement du mot ":" en compilant quelque chose de simple.  Faisons, par exemple, le mot: <br><br><pre> <code class="cpp hljs">: ^<span class="hljs-number"><span class="hljs-number">2</span></span> dup * ;</code> </pre> <br>  Ce mot est quadratique.  Mais nous n'avons pas le mot ";" que faire?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous écrivons le mot exit à la place et il se compile. </font><font style="vertical-align: inherit;">Et puis désactivez le mode de compilation avec le mot "[" et supprimez la valeur 110:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^2 dup * exit [ drop ( 0 ): &gt; 4 ^2 ( 1 ): 16 &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ça marche! </font><font style="vertical-align: inherit;">Continuons </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous continuerons d'écrire le fort sur le fort, nous devons penser à où sera le code source du fort, et quand le compiler. </font><font style="vertical-align: inherit;">Faisons l'option la plus simple. </font><font style="vertical-align: inherit;">Le code source du fort sera placé dans le code source dans l'assembleur, sous forme de chaîne de texte. </font><font style="vertical-align: inherit;">Et pour qu'il ne prenne pas trop de place, nous le placerons immédiatement après l'adresse ici, dans la zone mémoire libre. </font><font style="vertical-align: inherit;">Bien sûr, nous avons besoin de cette zone pour la compilation, mais la vitesse de «fugue» de l'interprétation sera supérieure au besoin de nouvelle mémoire. </font><font style="vertical-align: inherit;">Ainsi, le code compilé commencera à écraser la source sur le fort, à partir du début, mais nous n'en aurons plus besoin, car nous avons déjà lu et utilisé cette section.</font></font><br><br><pre> <code class="cpp hljs">fcode: .ascii <span class="hljs-string"><span class="hljs-string">" 2 2 + . quit"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais, au début de la ligne, cela vaut la peine de placer une douzaine d'espaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que cela fonctionne, nous modifions le bytecode de départ afin que tib, #tib pointe vers cette ligne. </font><font style="vertical-align: inherit;">À la fin, il y a un arrêt pour entrer dans la ligne de commande normale du système.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le démarrage du bytecode est devenu comme ça</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_call16 .word vhere - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word h - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word definitions - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word fcode_end - fcode .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_quit</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancez! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth 4 ( 0 ): &gt;</code> </pre><br>  Super! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compilez le compilateur avec le compilateur </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous écrivons le code dans la ligne fcode. </font><font style="vertical-align: inherit;">La première chose à faire, bien sûr, est le mot ";".</font></font><br><br><pre> <code class="cpp hljs">: ; ?state <span class="hljs-number"><span class="hljs-number">110</span></span> ?pairs lit8 [ blword <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> find cfa c@ c, ] c, <span class="hljs-number"><span class="hljs-number">0</span></span> state ! <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> [ current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! drop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je ferai quelques explications. </font></font><br><br><pre> <code class="plaintext hljs">?state 110 ?pairs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici on vérifie que l'état de compilation est bien défini, et 110 est sur la pile, sinon il y aura une interruption par erreur. </font></font><br><br><pre> <code class="plaintext hljs">lit8 [ blword exit find cfa c@ c, ]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci nous compilons la commande allumée avec le bytecode de la commande exit. </font><font style="vertical-align: inherit;">J'ai dû passer en mode d'exécution, trouver le mot exit, obtenir l'adresse d'exécution et récupérer le code de commande à partir de là. </font><font style="vertical-align: inherit;">Tout cela était nécessaire car nous n'avons pas encore le mot compiler. </font><font style="vertical-align: inherit;">Si c'était le cas, au lieu de tout cela, il suffirait d'écrire simplement «compiler exit» :)</font></font><br><br><pre> <code class="plaintext hljs">c, 0 state !</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela compilera la commande exit lorsque le mot ";" est exécuté, puis le mode d'interprétation sera défini. </font><font style="vertical-align: inherit;">Le mot "[" ne peut pas être utilisé ici, car il a le signe immédiat et est exécuté </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais nous devons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ces commandes dans le mot ";" afin qu'elles désactivent le mode de compilation.</font></font><br><br><pre> <code class="plaintext hljs">exit [</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous l'avons déjà vécu. </font><font style="vertical-align: inherit;">Le mot exit est compilé et le mode de compilation est désactivé. </font><font style="vertical-align: inherit;">Tout, le mot ";" </font><font style="vertical-align: inherit;">compilé. </font><font style="vertical-align: inherit;">Et quoi d'autre est écrit là-bas?</font></font><br><br><pre> <code class="plaintext hljs">current @ @ dup c@ 96 or swap c! drop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez définir le drapeau immédiat pour le nouveau mot. </font><font style="vertical-align: inherit;">C'est exactement ce que fait la séquence indiquée, à l'exception du mot drop. </font><font style="vertical-align: inherit;">Le mot drop supprime le 110 oublié qui a placé le mot ":" au début de la création. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant c'est tout! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous lançons et essayons.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^3 dup dup * * ; ( 0 ): &gt; 6 ^3 . 216 ( 0 ): &gt;</code> </pre><br>  Voilà!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est le premier mot que notre compilateur a compilé «pour de vrai». </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous n'avons toujours pas de conditions, pas de boucles, et bien plus encore ... Commençons par un petit mais très nécessaire mot pour créer un compilateur: immédiat. </font><font style="vertical-align: inherit;">Il définit l'attribut immédiat sur le dernier mot créé:</font></font><br><br><pre> <code class="cpp hljs">: immediate current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une séquence familière :) Récemment, elle a été écrite manuellement, elle ne sera plus nécessaire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons maintenant quelques mots petits mais utiles:</font></font><br><br><pre> <code class="cpp hljs">: hex <span class="hljs-number"><span class="hljs-number">16</span></span> base ! ; : decimal <span class="hljs-number"><span class="hljs-number">10</span></span> base ! ; : bl <span class="hljs-number"><span class="hljs-number">32</span></span> ; : tab <span class="hljs-number"><span class="hljs-number">9</span></span> ; : lf <span class="hljs-number"><span class="hljs-number">10</span></span> ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hex et décimal définissent le système numérique correspondant. </font><font style="vertical-align: inherit;">Les autres sont des constantes permettant d'obtenir les codes de caractères correspondants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous créons également un mot pour copier une ligne avec un compteur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: cmove sur c @ 1+ move; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant, nous serons engagés dans des conditions. </font><font style="vertical-align: inherit;">En général, s'il y avait un mot compilé, il ressemblerait à ceci:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous ces mots au début vérifient que le mode de compilation est défini et génèrent une erreur si ce n'est pas le cas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot if compile une branche conditionnelle, réserve un octet pour le paramètre de commande de branche conditionnelle et pousse l'adresse de cet octet sur la pile. Il pousse ensuite la valeur de contrôle 111 sur la pile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot vérifie alors la présence de la valeur de contrôle 111, puis écrit le décalage dans l'adresse sur la pile.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et faites immédiatement le mot d'autre. </font><font style="vertical-align: inherit;">Au début, il compile la commande de saut inconditionnel pour contourner la branche else. </font><font style="vertical-align: inherit;">De la même manière que si, le décalage de transition n'est pas encore connu, il est simplement réservé et son adresse est poussée sur la pile. </font><font style="vertical-align: inherit;">Eh bien, après cela, exactement la même chose se fait qu'avec then: l'adresse de la transition catch est définie sur la branche else. </font><font style="vertical-align: inherit;">Quelque chose est plus difficile à décrire que le code lui-même :) Si quelqu'un veut le comprendre à fond, il vaut mieux analyser le travail d'un tel code simplifié au maximum:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, ; immediate : then dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, maintenant nous programmons le vrai code. </font><font style="vertical-align: inherit;">Comme nous n'avons pas le mot compiler, nous appliquons la même astuce que lors de la création du mot ";":</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state lit8 [ blword ?nbranch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs lit8 [ blword branch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, swap dup here swap - swap c! <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez maintenant essayer de compiler la condition. </font><font style="vertical-align: inherit;">Faisons, par exemple, un mot qui imprime 1000 s'il y en a 5 sur la pile, et 0 dans les autres cas:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = if 1000 . else 0 . then ; ( 0 ): &gt; 22 test 0 ( 0 ): &gt; 3 test 0 ( 0 ): &gt; 5 test 1000 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est clair qu'un tel résultat n'a pas fonctionné tout de suite, il y a eu des erreurs, il y a eu un débogage. </font><font style="vertical-align: inherit;">Mais au final, les conditions ont fonctionné!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une petite digression sur la longueur des commandes de transition</font></font></b> <div class="spoiler_text">  ,       ,      127 .       . ,  ,       .     ,   ,        .   8   ,    40  127    .   ,       ? <br><br>   .   —    16 . <br><br>      . 16        —    . ,      ,     call,      . , 11     ( 1023   ).         300  1000  .      ,        .      3  ,     8    .    :   (?nbranch),    (?branch)   (branch).  — 24 . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons des conditions, la vie devient plus facile :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons un mot. "(Point-quote). Il affiche le texte spécifié lors de son exécution. Il est utilisé de cette façon:</font></font><br><br><pre> <code class="cpp hljs">.<span class="hljs-string"><span class="hljs-string">"    "</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous ne pouvez utiliser ce mot qu'en mode compilation. </font><font style="vertical-align: inherit;">Cela deviendra apparent après avoir analysé le dispositif de ce mot:</font></font><br><br><pre> <code class="cpp hljs">: .<span class="hljs-string"><span class="hljs-string">" ?state 34 word dup if lit8 [ blword (."</span></span>) find cfa c@ c, ] c, str, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop then ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce mot est exécuté en mode compilation. Il prend une chaîne du flux d'entrée jusqu'aux guillemets (34 mots). Si la ligne n'a pas pu être obtenue, elle ne fait rien. Bien, ici, il serait préférable de dériver un diagnostic. Mais pour la sortie de la ligne, ce mot est exactement ce que nous faisons :) Si nécessaire, vous pouvez à nouveau redéfinir ce mot, déjà avec des diagnostics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il était possible d'obtenir la chaîne, la commande d'octets (. ") Est compilée, puis la chaîne reçue. Cette commande d'octets (guillemets pointillés entre crochets), lorsqu'elle est exécutée, affiche la chaîne qui a été compilée derrière l'octet de commande. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérifiez.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test ."    " ; ( 0 ): &gt; test     ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, faisons compiler le mot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est clair qu'en mode compilation ce mot doit prendre le nom du mot suivant du flux, le trouver dans le dictionnaire. Et puis il y aura des options: ce peut être une commande d'octets, ou ce peut être un mot écrit en code octet. Ces mots doivent être compilés de différentes manières. Par conséquent, nous allons créer deux mots auxiliaires: "(compile_b)" et "(compile_c)". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) compilera la commande d'appel pour appeler le bytecode. Le paramètre sera un mot de 64 bits - l'adresse du bytecode appelé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_c) compilera la commande byte. Par conséquent, le paramètre de cette commande sera un octet - le code de commande. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, le mot compiler lui-même compilera (compile_b) ou (compile_c) avec les paramètres correspondants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par (compile_c),comme avec le plus simple:</font></font><br><br><pre> <code class="cpp hljs">: (compile_c) r&gt; dup c@ swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ &gt;rc, ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgré sa simplicité, nous écrivons d'abord un mot en bytecode, qui en lui-même a des paramètres. Je vais donc commenter. Après avoir entré (compile_c), l'adresse de retour se trouve sur la pile de retour, car elle n'est pas banale. Il s'agit de l'adresse de l'octet suivant après la commande d'appel. La situation au moment de l'appel est indiquée ci-dessous. A0 - code de commande d'appel, XX - paramètre de commande d'appel - adresse d'appel (décalage) du code d'octet du mot (compile_c).</font></font><br><br><img src="https://habrastorage.org/webt/vj/jh/kh/vjjhkhqa7e35ygxdzclv0lf4-pw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'adresse de retour indique l'octet NN. Il existe généralement le code de l'octet suivant de la commande. Mais notre mot a des paramètres, donc NN n'est que les paramètres du mot "(compile_c)", à savoir le code d'octet de la commande compilée. Vous devez lire cet octet et modifier l'adresse de retour en la déplaçant vers la commande d'octet suivante. Cela se fait par la séquence «r&gt; dup c @ swap 1+&gt; r». Cette séquence extrait l'adresse de retour de la pile de retour vers la pile normale, en extrait un octet, y ajoute un (adresse de retour) et la renvoie à la pile de retour. La commande restante «c» compile le code de commande octet obtenu à partir des paramètres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) n'est pas beaucoup plus compliqué:</font></font><br><br><pre> <code class="cpp hljs">: (compile_b) r&gt; dup @ swap <span class="hljs-number"><span class="hljs-number">8</span></span> + &gt;r compile_b ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, tout est pareil, seul le paramètre 64 bits est lu et le mot compile_b est utilisé pour compiler le mot que nous avons déjà créé pour le compilateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant, le mot compile. </font><font style="vertical-align: inherit;">Comme déjà discuté, il lit le nom du mot, le trouve et compile l'une des deux commandes précédentes. </font><font style="vertical-align: inherit;">Je ne le commenterai pas, nous avons déjà appliqué et démonté toutes les constructions utilisées.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilation de mots</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">: compile blword over over find dup <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dup c@ <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa c@ (compile_b) [ blword (compile_c) find cfa , ] c, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa (compile_b) [ blword (compile_b) find cfa , ] , then drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop .<span class="hljs-string"><span class="hljs-string">" compile: "</span></span> type .<span class="hljs-string"><span class="hljs-string">" - not found"</span></span> then ; immediate</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour vérifier le mot créé, nous créons, avec son aide, le mot ifnot. </font></font><br><br><pre> <code class="cpp hljs">: ifnot ?state compile ?branch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Découvrez-le! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = ifnot 1000 . else 0 . then ; ( 0 ): &gt; 22 test 1000 ( 0 ): &gt; 3 test 1000 ( 0 ): &gt; 5 test 0 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout va bien! Et il est temps de faire des cycles ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article nous allons faire des cycles avec une condition. Le fort a deux options pour un cycle avec une condition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première option est de commencer ... jusqu'à. Le mot jusqu'à ce que supprime la valeur de la pile, et si elle n'est pas égale à zéro, le cycle se termine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième option est commencer ... tandis que ... répéter. Dans ce cas, la vérification se produit lorsque le mot while est exécuté. La boucle se termine si la valeur sur la pile est nulle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cycles sur le fort se font de la même manière que les conditions - sur les transitions conditionnelles et inconditionnelles. J'apporte le code, les commentaires, je pense, ne sont pas nécessaires.</font></font><br><br><pre> <code class="cpp hljs">: begin ?state here <span class="hljs-number"><span class="hljs-number">112</span></span> ; immediate : until ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here - c, ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">113</span></span> ; immediate : repeat ?state <span class="hljs-number"><span class="hljs-number">113</span></span> ?pairs swap compile branch8 here - c, dup here swap - swap c! ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aujourd'hui, nous avons terminé avec le compilateur. </font><font style="vertical-align: inherit;">Il en reste très peu. </font><font style="vertical-align: inherit;">Des fonctions clés qui n'ont pas encore été implémentées ne sont que des cycles avec un compteur. </font><font style="vertical-align: inherit;">Et cela vaut également la peine de quitter la commande de boucle de sortie. </font><font style="vertical-align: inherit;">Nous le ferons la prochaine fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous n'avons pas expérimenté la commande de cycle! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous le faisons en écrivant les mots standard. </font><font style="vertical-align: inherit;">Il faut enfin voir notre dictionnaire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, au début, nous faisons le mot lien @. </font><font style="vertical-align: inherit;">Il extraira le champ de communication de l'entrée du dictionnaire (décalé par rapport à l'entrée précédente). </font><font style="vertical-align: inherit;">Comme nous nous en souvenons, le champ de communication peut avoir une taille différente: 1, 2, 4 ou 8 octets. </font><font style="vertical-align: inherit;">Ce mot prendra sur la pile l'adresse de l'entrée du dictionnaire et renverra deux valeurs: l'adresse du champ de nom et la valeur du champ de communication.</font></font><br><br><pre> <code class="cpp hljs">: link@ dup c@ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap dup <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap c@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">2</span></span> + swap w@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">4</span></span> + swap i@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop dup <span class="hljs-number"><span class="hljs-number">8</span></span> + swap @ then then then ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant, vous pouvez créer les mots: </font></font><br><br><pre> <code class="cpp hljs">: words context @ @ <span class="hljs-number"><span class="hljs-number">0</span></span> begin + dup link@ swap count type tab emit dup <span class="hljs-number"><span class="hljs-number">0</span></span>= until drop drop ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancement ... </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; words words link@ repeat while until begin ifnot compile (compile_b) (compile_c) ." else then if cmove tab bl decimal hex immediate ; bye ?state ?pairs : str, interpret $compile compile_b compile_n compile_1248 compile_c c, w, i, , allot here h test_bv test_bvc [ ] state .s &gt;in #tib tib . #&gt; #s 60 # hold span holdpoint holdbuf base quit execute cfa find word blword var16 var8 (.") (") count emit expect type lshift rshift invert xor or and &gt;= &lt;= &gt; &lt; = 0&gt; 0&lt; 0= bfind compare syscall fill move rpick r@ r&gt; &gt;r -! +! i! i@ w! w@ c! c@ ! @ depth roll pick over -rot rot swap drop dup abs /mod mod / * - + 1+ 1- exit ?nbranch16 ?nbranch8 ?branch16 ?branch8 branch16 branch8 call8b0 call64 call32 call16 call8f lit64 lit32 lit16 lit8 8 4 3 2 1 0 context definitions current forth ( 0 ): &gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ça y est, notre richesse :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je voulais tout dire ... non, permettons néanmoins de spécifier un fichier avec un programme fort pour la compilation et l'exécution en paramètre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous faisons des commandes syscall pour ouvrir, fermer et lire le fichier. </font><font style="vertical-align: inherit;">Nous définissons les constantes qui leur sont nécessaires.</font></font><br><br><pre> <code class="cpp hljs">: file_open <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> syscall ; : file_close <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> syscall ; : file_read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> syscall ; : file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> ; : file_O_WRONLY <span class="hljs-number"><span class="hljs-number">1</span></span> ; : file_O_RDWR <span class="hljs-number"><span class="hljs-number">3</span></span> ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez maintenant créer le mot de départ _start: </font></font><br><br><pre> <code class="cpp hljs">: _start <span class="hljs-number"><span class="hljs-number">0</span></span> pick <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pick file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> file_open dup <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .\<span class="hljs-string"><span class="hljs-string">" error: \" . quit then dup here 32 + 32768 file_read dup 0&lt; if .\" error: \" . quit then swap file_close drop #tib ! here 32 + tib ! 0 &gt;in ! interpret then ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce mot se chargera du fichier et exécutera n'importe quel programme fort. </font><font style="vertical-align: inherit;">Plus précisément, l'interpréteur exécutera tout ce qui sera dans ce fichier. </font><font style="vertical-align: inherit;">Et il peut y avoir, par exemple, une compilation de nouveaux mots et leur exécution. </font><font style="vertical-align: inherit;">Le nom du fichier est indiqué par le premier paramètre au démarrage. </font><font style="vertical-align: inherit;">Je n'entrerai pas dans les détails, mais les paramètres de lancement sous Linux sont passés à travers la pile. </font><font style="vertical-align: inherit;">Le mot _start les atteindra avec les commandes 0 pick (nombre de paramètres) et 2 pick (pointeur sur le premier paramètre). </font><font style="vertical-align: inherit;">Pour un système de fort, ces valeurs se trouvent en dehors de la pile, mais vous pouvez les obtenir avec la commande pick. </font><font style="vertical-align: inherit;">La taille du fichier est limitée à 32 Ko, alors qu'il n'y a pas de gestion de la mémoire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste maintenant à écrire dans la ligne fcode à la fin:</font></font><br><br><pre> <code class="cpp hljs">_start quit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un fichier test.f et écrivez quelque chose sur le fort. </font><font style="vertical-align: inherit;">Par exemple, l'algorithme euclidien pour trouver le plus grand facteur commun:</font></font><br><br><pre> <code class="cpp hljs">: NOD begin over over &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> over over &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> swap over - swap <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> over - then repeat drop ; <span class="hljs-number"><span class="hljs-number">23101</span></span> <span class="hljs-number"><span class="hljs-number">44425</span></span> NOD . bye</code> </pre><br>  Nous commençons. <br><br><pre> <code class="plaintext hljs">$ ./forth test.f 1777 Bye! $</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La réponse est correcte. </font><font style="vertical-align: inherit;">Le mot a été compilé, puis rempli. </font><font style="vertical-align: inherit;">Le résultat s'affiche, puis la commande bye a été exécutée. </font><font style="vertical-align: inherit;">Si vous supprimez les deux dernières lignes, le mot NOD sera ajouté au dictionnaire et le système ira à sa ligne de commande. </font><font style="vertical-align: inherit;">Vous pouvez déjà écrire des programmes :-)</font></font><br><br>  C’est tout.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peu importe, vous pouvez télécharger la source ou le binaire prêt à l'emploi pour Linux sur x86-64 depuis Github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64 Les</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sources sont livrées avec une licence </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU GPL v2</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCH v1 - Faites ce que vous voulez :-)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437466/">https://habr.com/ru/post/fr437466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437454/index.html">Test de l'arithmomètre Felix M</a></li>
<li><a href="../fr437456/index.html">Plus jeune: Examen des téléphones IP Snom D315 et D305</a></li>
<li><a href="../fr437458/index.html">Inscription obligatoire par IMEI offre de faire payé</a></li>
<li><a href="../fr437460/index.html">Exemple de faux lecteur flash de 32 Go</a></li>
<li><a href="../fr437464/index.html">Prix ​​TypeScript</a></li>
<li><a href="../fr437468/index.html">Retropie Dreamcast</a></li>
<li><a href="../fr437470/index.html">Quelques mots simples sur la défense antimissile</a></li>
<li><a href="../fr437472/index.html">Transition du bureau à udalenka: partage d'expérience et hacks de vie</a></li>
<li><a href="../fr437474/index.html">Optimisez les performances du jeu avec les options d'importation du son Unity</a></li>
<li><a href="../fr437476/index.html">Ok Yandex! Où sont nos objectifs de portée?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>