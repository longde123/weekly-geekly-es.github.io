<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèΩ‚Äçü§ù‚Äçüßëüèº üíáüèæ üç† Octet-machine pour le fort (et pas seulement) en am√©rindien (partie 4) üòß üíì ü§ôüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Et encore une fois, j'ai surestim√© le volume de l'article! J'ai pr√©vu que ce serait le dernier article, o√π nous ferons un compilateur et effectuerons ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Octet-machine pour le fort (et pas seulement) en am√©rindien (partie 4)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437466/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Fort Byte Car (et plus) Native American"><br><br>  Et encore une fois, j'ai surestim√© le volume de l'article!  J'ai pr√©vu que ce serait le dernier article, o√π nous ferons un compilateur et effectuerons des tests.  Mais le volume s'est av√©r√© important et j'ai d√©cid√© de diviser l'article en deux. <br><br>  Dans cet article, nous ferons presque toutes les fonctions de base du compilateur.  Il prendra vie et il sera possible d'√©crire, de compiler et d'ex√©cuter du code assez s√©rieux.  Et nous ferons des tests dans la partie suivante.  (Au fait, les parties pr√©c√©dentes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deux</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trois</a> ). <br><br>  J'√©cris pour la premi√®re fois √† Habr√©, ce n'est peut-√™tre pas toujours bien.  √Ä mon avis, les articles 2, 3 se sont r√©v√©l√©s plut√¥t secs, beaucoup de code, peu de description.  Cette fois, je vais essayer de faire quelque chose de diff√©rent, en me concentrant sur la description des id√©es elles-m√™mes.  Eh bien, le code ... le code, bien s√ªr qu'il le sera!  Qui veut bien comprendre, une telle opportunit√© sera.  Dans de nombreux cas, je mettrai le code sous le spoiler.  Et, bien s√ªr, vous pouvez toujours consulter la source compl√®te sur le github. <br><br>  Le compilateur continuera √† √©crire pendant un certain temps dans l'assembleur, mais ensuite aller au fort et continuer √† √©crire le compilateur sur nous-m√™mes.  Cela ressemblera au baron Munchausen, qui s'est tir√© par les cheveux du marais.  Mais, pour commencer, je vais d√©crire comment fonctionne le compilateur sur le fort.  Bienvenue au chat! <br><a name="habracut"></a><br><h4>  Comment fonctionne le compilateur? </h4><br>  La m√©moire du fort consiste en un fragment continu dans lequel les entr√©es du dictionnaire sont dispos√©es s√©quentiellement.  Apr√®s leur ach√®vement est suivi d'une zone de m√©moire libre.  Le premier octet libre est indiqu√© par la variable h.  Il y a aussi le mot souvent utilis√© ici, qui pousse l'adresse du premier octet libre sur la pile, il est d√©termin√© tr√®s simplement: <br><br><pre><code class="cpp hljs">: here h @ ;</code> </pre> <br><img src="https://habrastorage.org/webt/bd/eg/sq/bdegsqg7t06egwbvxoib9lqk_nc.png"><br><br>  Il convient de mentionner le mot allot, qui r√©serve le nombre sp√©cifi√© d'octets en d√©pla√ßant le pointeur h.  Le mot attribuer peut √™tre d√©fini comme suit: <br><br><pre> <code class="cpp hljs">: allot h +! ;</code> </pre> <br>  En fait, le compilateur utilise un mode interpr√©teur sp√©cial et quelques mots sp√©ciaux.  Donc, avec une phrase, vous pouvez d√©crire tout le principe du compilateur dans le fort.  Le mode de fonctionnement de l'interpr√©teur est d√©termin√© par la variable d'√©tat.  S'il est nul, le mode d'ex√©cution est d√©fini, sinon - le mode de compilation.  Nous connaissons d√©j√† le mode d'ex√©cution, les mots du tampon d'entr√©e y sont simplement ex√©cut√©s l'un apr√®s l'autre.  Mais en mode compilation, ils ne sont pas ex√©cut√©s, mais sont compil√©s en m√©moire par le pointeur h.  Par cons√©quent, le pointeur avance. <br><br>  Dans le fort classique, le mot "," est utilis√© pour compiler une valeur enti√®re, le mot "c", est utilis√© pour compiler un octet.  Notre syst√®me utilise des valeurs de diff√©rentes profondeurs de bits (8, 16, 32, 64), par cons√©quent, nous allons √©galement cr√©er les mots ¬´w¬ª et ¬´i¬ª.  Nous cr√©ons √©galement le mot ¬´str¬ª, qui compilera la cha√Æne, en prenant deux valeurs dans la pile - l'adresse et la longueur de la cha√Æne. <br><br>  Des mots de compilation sp√©ciaux sont utilis√©s pour former des structures de contr√¥le.  Ce sont les mots if, do, loop, et autres.  Ces mots sont ex√©cut√©s m√™me en mode compilation.  Par exemple, le mot if compile une commande d'octet de branche conditionnelle (? Nbranch) √† l'ex√©cution.  Pour que le syst√®me sache quels mots doivent √™tre ex√©cut√©s en mode compilation et non compil√©s, le drapeau imm√©diat (signe) est utilis√©.  Nous l'avons d√©j√† dans le champ indicateur de l'entr√©e du dictionnaire.  Dans le code source de l'assembleur, il est appel√© f_immediate.  Pour d√©finir ce drapeau, utilisez le mot imm√©diat.  Il n'a pas de param√®tres, l'indicateur imm√©diat est positionn√© au dernier mot du dictionnaire. <br><br>  Passons maintenant de la th√©orie √† la pratique! <br><br><h4>  La pr√©paration </h4><br>  Au d√©but, nous devons faire quelques commandes d'octets simples en langage assembleur dont nous avons besoin.  Les voici: d√©placer (copier la zone m√©moire), remplir (remplir la zone m√©moire), op√©rations sur les bits (et, ou, xor, inverser), commandes de d√©calage des bits (rshift, lshift).  Faisons le m√™me rpick (c'est la m√™me chose que pick, cela ne fonctionne qu'avec la pile de retour, pas la pile de donn√©es). <br><br><div class="spoiler">  <b class="spoiler_title">Ces commandes sont tr√®s simples, voici leur code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">b_move = <span class="hljs-number"><span class="hljs-number">0x66</span></span> bcmd_move: pop rcx pop rdi pop rsi repz movsb jmp _next b_fill = <span class="hljs-number"><span class="hljs-number">0x67</span></span> bcmd_fill: pop rax pop rcx pop rdi repz stosb jmp _next b_rpick = <span class="hljs-number"><span class="hljs-number">0x63</span></span> bcmd_rpick: pop rcx push [rbp + rcx * <span class="hljs-number"><span class="hljs-number">8</span></span>] jmp _next b_and = <span class="hljs-number"><span class="hljs-number">0x58</span></span> bcmd_and: pop rax <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [rsp], rax jmp _next b_or = <span class="hljs-number"><span class="hljs-number">0x59</span></span> bcmd_or: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> [rsp], rax jmp _next b_xor = <span class="hljs-number"><span class="hljs-number">0x5A</span></span> bcmd_xor: pop rax xor [rsp], rax jmp _next b_invert = <span class="hljs-number"><span class="hljs-number">0x5B</span></span> bcmd_invert: notq [rsp] jmp _next b_rshift = <span class="hljs-number"><span class="hljs-number">0x5C</span></span> bcmd_rshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shrq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next b_lshift = <span class="hljs-number"><span class="hljs-number">0x5D</span></span> bcmd_lshift: pop rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz _next <span class="hljs-number"><span class="hljs-number">1</span></span>: shlq [rsp] dec rcx jnz <span class="hljs-number"><span class="hljs-number">1b</span></span> jmp _next</code> </pre> </div></div><br>  Encore faut-il faire le mot mot.  C'est la m√™me chose que blword, mais un d√©limiteur sp√©cifique est indiqu√© sur la pile.  Je ne fournis pas le code, il peut √™tre trouv√© dans la source.  J'ai fait copier / coller les mots blworld et remplac√© les commandes de comparaison. <br><br>  En conclusion, nous faisons le mot syscall.  Avec lui, il sera possible de faire les op√©rations syst√®me manquantes, par exemple, en travaillant avec des fichiers.  Une telle solution ne fonctionnera pas si l'ind√©pendance de la plateforme est requise.  Mais ce syst√®me est maintenant utilis√© pour les tests, alors qu'il en soit ainsi pour l'instant.  Si n√©cessaire, toutes les op√©rations peuvent √™tre converties en commandes d'octets, ce n'est pas du tout difficile.  La commande syscall acceptera 6 param√®tres pour l'appel syst√®me et le num√©ro d'appel de la pile.  Il renverra un param√®tre.  Les affectations de param√®tres et la valeur de retour sont d√©termin√©es par le num√©ro d'appel syst√®me. <br><br><pre> <code class="cpp hljs">b_syscall = <span class="hljs-number"><span class="hljs-number">0xFF</span></span> bcmd_syscall: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 pop rax pop r9 pop r8 pop r10 pop rdx pop rsi pop rdi syscall push rax mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre><br>  Et maintenant, passons directement au compilateur. <br><br><h4>  Compilateur </h4><br>  Cr√©ons la variable h, tout est simple ici. <br><br><pre> <code class="cpp hljs"> item h h: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre>  Nous √©crirons son initialisation dans la ligne de d√©part: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! h dup 8 + swap ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call16 .word h - . - 2 .byte b_dup, b_num8, b_add, b_swap, b_set .byte b_quit</span></span></code> </pre><br>  Faisons le mot ici: <br><br><pre> <code class="cpp hljs"> item here .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_get .byte b_exit</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Et aussi des mots pour compiler les valeurs: "allot" et "c,", "w,", "i,", ",", "str,"</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : allot h +! ; item allot allot: .byte b_call8, h - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_setp, b_exit # : , here ! <span class="hljs-number"><span class="hljs-number">8</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">","</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set, b_num8, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : i, here i! <span class="hljs-number"><span class="hljs-number">4</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"i,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set32, b_num4, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : w, here w! <span class="hljs-number"><span class="hljs-number">2</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"w,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set16, b_num2, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : c, here c! <span class="hljs-number"><span class="hljs-number">1</span></span> allot ; item <span class="hljs-string"><span class="hljs-string">"c,"</span></span> .byte b_call8, here - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_set8, b_num1, b_call8, allot - . - <span class="hljs-number"><span class="hljs-number">1</span></span>, b_exit # : str, dup -rot dup c, here swap move <span class="hljs-number"><span class="hljs-number">1</span></span>+ h +!; item <span class="hljs-string"><span class="hljs-string">"str,"</span></span> c_str: .byte b_dup, b_mrot, b_dup callb c_8 callb here .byte b_swap, b_move callb h .byte b_setp .byte b_exit</code> </pre></div></div><br>  Faisons maintenant la variable d'√©tat et deux mots pour contr√¥ler sa valeur: "[" et "]".  Habituellement, ces mots sont utilis√©s pour effectuer quelque chose au moment de la compilation.  Par cons√©quent, le mot "[" d√©sactive le mode de compilation et le mot "]" le active.  Mais rien ne les emp√™che d'√™tre utilis√©s dans d'autres cas lorsqu'il est n√©cessaire d'activer ou de d√©sactiver le mode de compilation.  Le mot "[" sera notre premier mot avec le signe imm√©diat.  Sinon, il ne pourra pas d√©sactiver le mode de compilation, car il sera compil√© et non ex√©cut√©. <br><br><pre> <code class="cpp hljs"> item state .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-string"><span class="hljs-string">"]"</span></span> .byte b_num1 callb state .byte b_set, b_exit item <span class="hljs-string"><span class="hljs-string">"["</span></span>, f_immediate .byte b_num0 callb state .byte b_set, b_exit</code> </pre><br>  Le tour est venu pour le mot $ compile.  Il prendra l'adresse de l'entr√©e du dictionnaire de la pile et compilera le mot sp√©cifi√©.  Pour compiler un mot dans des impl√©mentations de Fort ordinaires, il suffit d'appliquer le mot "," √† l'adresse d'ex√©cution.  Tout est beaucoup plus compliqu√© ici.  Premi√®rement, il existe deux types de mots - le bytecode et le code machine.  Les premiers sont compil√©s par octet et les seconds par la commande call byte.  Et deuxi√®mement - nous avons jusqu'√† quatre variantes de la commande d'appel: call8, call16, call32 et call64.  Quatre?  Non!  Quand j'ai √©crit le compilateur, j'en ai ajout√© 16 de plus √† ces quatre!  :) <br><br>  Comment est-ce arriv√©?  Nous devons faire une petite digression. <br><br><h4>  Am√©lioration de la commande d'appel </h4><br>  Lorsque le compilateur a commenc√© √† fonctionner, j'ai constat√© que dans de nombreux cas (mais pas tous) la commande call8 √©tait suffisante.  C'est lorsque le mot appel√© est dans les 128 octets.  J'ai pens√© - et comment faire en sorte que cela se produise dans presque tous les cas?  Comment mettre plus de 256 valeurs dans un octet? <br>  Le premier point que j'ai remarqu√© est que dans le fort, l'appel va toujours vers des adresses plus basses.  Cela signifie que vous pouvez refaire la commande d'appel de telle mani√®re qu'elle ne puisse appeler que des adresses inf√©rieures, mais pour 256 octets, pas 128. C'est mieux. <br><br>  Mais si vous mettez quelques morceaux quelque part ... Il s'av√®re qu'il y a o√π!  Nous avons deux octets: un octet est la commande, le second est l'offset.  Mais rien n'emp√™che les bits inf√©rieurs de la commande de placer les bits hauts du param√®tre (offset).  Pour une machine √† octets, il semble qu'au lieu d'une commande d'appel, il y en ait plusieurs.  Oui, de cette fa√ßon, nous occupons plusieurs cellules de la table de code d'octet-commande avec une seule commande, mais parfois cela vaut la peine.  La commande d'appel est l'une des commandes les plus utilis√©es, j'ai donc d√©cid√© de mettre 4 bits de d√©calage dans la commande.  Ainsi, vous pouvez effectuer un appel √† une distance pouvant atteindre 4095 octets!  Cela signifie qu'une commande d'appel aussi courte sera utilis√©e presque toujours.  J'ai plac√© ces commandes avec le code 0xA0 et les lignes suivantes sont apparues dans le tableau de commandes: <br><br><pre> <code class="cpp hljs">.quad bcmd_call8b0, bcmd_call8b1, bcmd_call8b2, bcmd_call8b3, bcmd_call8b4, bcmd_call8b5, bcmd_call8b6, bcmd_call8b7 # <span class="hljs-number"><span class="hljs-number">0xA0</span></span> .quad bcmd_call8b8, bcmd_call8b9, bcmd_call8b10, bcmd_call8b11, bcmd_call8b12, bcmd_call8b13, bcmd_call8b14, bcmd_call8b15</code> </pre> <br>  La premi√®re de ces commandes d'octets effectue simplement un appel en direction d'adresses inf√©rieures √† l'offset sp√©cifi√© dans le param√®tre (jusqu'√† 255).  Les autres ajoutent le d√©calage correspondant au param√®tre.  bcmd_call8b1 ajoute 256, bcmd_call8b2 ajoute 512, et ainsi de suite.  J'ai fait la premi√®re commande d'appel s√©par√©ment, le reste avec une macro. <br><br>  Premi√®re commande: <br><br><pre> <code class="cpp hljs">b_call8b0 = <span class="hljs-number"><span class="hljs-number">0xA0</span></span> bcmd_call8b0: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 sub r8, rax jmp _next</code> </pre><br>  Macro et cr√©ation du reste des commandes d'appel: <br><br><pre> <code class="cpp hljs">.macro call8b N b_call8b\N = <span class="hljs-number"><span class="hljs-number">0xA</span></span>\N bcmd_call8b\N: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 add rax, \N * <span class="hljs-number"><span class="hljs-number">256</span></span> mov [rbp], r8 sub r8, rax jmp _next .endm call8b <span class="hljs-number"><span class="hljs-number">1</span></span> call8b <span class="hljs-number"><span class="hljs-number">2</span></span> call8b <span class="hljs-number"><span class="hljs-number">3</span></span> call8b <span class="hljs-number"><span class="hljs-number">4</span></span> call8b <span class="hljs-number"><span class="hljs-number">5</span></span> call8b <span class="hljs-number"><span class="hljs-number">6</span></span> call8b <span class="hljs-number"><span class="hljs-number">7</span></span> call8b <span class="hljs-number"><span class="hljs-number">8</span></span> call8b <span class="hljs-number"><span class="hljs-number">9</span></span> call8b <span class="hljs-number"><span class="hljs-number">10</span></span> call8b <span class="hljs-number"><span class="hljs-number">11</span></span> call8b <span class="hljs-number"><span class="hljs-number">12</span></span> call8b <span class="hljs-number"><span class="hljs-number">13</span></span> call8b <span class="hljs-number"><span class="hljs-number">14</span></span> call8b <span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Eh bien, j'ai refait l'ancienne commande call8 pour faire un renvoi, car nous avons d√©j√† 16 √©quipes qui font un rappel.  Quelle que soit la confusion, je l'ai renomm√© b_call8f: <br><br><pre> <code class="cpp hljs">b_call8f = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8f: movzx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next</code> </pre><br>  Soit dit en passant, pour plus de commodit√©, j'ai cr√©√© une macro qui, dans l'assembleur, compile automatiquement l'appel correspondant dans 4095. Et je n'en ai jamais eu besoin :) <br><br><pre> <code class="cpp hljs">.macro callb adr .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \adr &gt; . .error <span class="hljs-string"><span class="hljs-string">"callb do not for forward!"</span></span> .endif .byte b_call8b0 + (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> .byte (. - \adr + <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">255</span></span> .endm</code> </pre> <br>  Et maintenant ... <br><br><h4>  Compilation d'√©quipe </h4><br>  Nous obtenons donc un algorithme de compilation de commandes assez compliqu√©.  S'il s'agit d'une commande d'octets, compilez juste un octet (code de commande d'octets).  Et si ce mot est d√©j√† √©crit en bytecode, vous devez compiler son appel avec la commande call, en choisissant un parmi vingt.  Plus pr√©cis√©ment 19, nous n'avons donc pas de renvoi d'appel, et call8f ne sera pas utilis√© pour le fort. <br><br>  Donc, le choix est le suivant.  Si le d√©calage est compris entre 0 et 4095, s√©lectionnez la commande bcmd_call8b avec le code 0xA0, en pla√ßant les quatre bits de d√©calage les plus significatifs dans les bits les moins significatifs de la commande.  Dans le m√™me temps, pour la machine d'octets, le code de l'une des commandes bcmd_call8b0 est bcmd_call8b15. <br><br>  Si le d√©calage vers l'arri√®re est sup√©rieur ou √©gal √† 4095, nous d√©terminons dans quelle dimension le d√©calage est plac√© et utilisons la commande appropri√©e √† partir de call16 / 32/64.  Il ne faut pas oublier que la compensation pour ces √©quipes est sign√©e.  Ils peuvent provoquer √† la fois en avant et en arri√®re.  Par exemple, call16 peut appeler une distance de 32767 dans les deux sens. <br><br>  Voici l'impl√©mentation en cons√©quence: <br><br>  <b>$ compiler</b> <br><br>  Compile un mot.  En param√®tre, prend l'adresse de l'entr√©e du dictionnaire du mot compil√©.  En fait, il v√©rifie l'indicateur f_code, calcule l'adresse de code (cfa) et appelle compile_b ou compile_c (si l'indicateur est d√©fini). <br><br>  <b>compile_c</b> <br><br>  Compile une commande d'octets.  Le mot le plus simple ici est d√©crit sur le fort comme ceci: <br><br><pre> <code class="cpp hljs">: compile_c c@ c, ;</code> </pre> <br>  <b>compile_b</b> <br>  Il prend une adresse de bytecode sur la pile et compile son appel. <br><br>  <b>test_bv</b> <br><br>  Il prend un d√©calage par rapport √† la pile (avec un signe) et d√©termine la profondeur de bits √† utiliser (1, 2, 4 ou 8 octets).  Renvoie la valeur 0, 1, 2 ou 3. En utilisant ce mot, vous pouvez d√©terminer celui √† utiliser √† partir des commandes call16 / 32/64.  Ce mot sera utile lors de la compilation de nombres (un choix parmi lit8 / 16/32/64). <br><br>  Au fait, vous pouvez d√©marrer le syst√®me et ¬´jouer¬ª dans la console du fort avec l'un de ces mots.  Par exemple: <br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 222 test_bv ( 2 ): 222 1 &gt; drop drop ( 0 ): &gt; 1000000 test_bv ( 2 ): 1000000 2 &gt; drop drop ( 0 ): &gt; -33 test_bv ( 2 ): -33 0 &gt;</code> </pre> <br>  <b>test_bvc</b> <br><br>  Il prend un d√©calage (avec un signe) de la pile et d√©termine la commande d'appel √† utiliser.  En fait, il v√©rifie si le d√©calage se situe dans la plage de 0 √† -4095 et renvoie 0. Dans ce cas, s'il n'y a pas de r√©sultat dans cet intervalle, il appelle test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">C'est tout ce qu'il faut pour compiler la commande.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : test_bvc dup <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= over FFF &lt;= <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... item test_bvc test_bvc: .byte b_dup, b_neg .byte b_num0 .byte b_gteq .byte b_over, b_neg .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0xFFF</span></span> .byte b_lteq .byte b_and .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_num0 .byte b_exit item test_bv test_bv: .byte b_dup, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_gteq, b_over, b_lit8, <span class="hljs-number"><span class="hljs-number">0x7f</span></span>, b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_num0 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x8001</span></span> .byte b_gteq .byte b_over .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">0x7ffe</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_num1, b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_dup .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80000002</span></span> .byte b_gteq .byte b_over .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x7ffffffd</span></span> .byte b_lteq, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_num2, b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_num3 .byte b_exit #  - item compile_c compile_c: .byte b_get8 callb c_8 .byte b_exit #   - item compile_b compile_b: callb here .byte b_num2, b_add .byte b_sub callb test_bvc .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop .byte b_neg .byte b_dup .byte b_lit8, <span class="hljs-number"><span class="hljs-number">8</span></span> .byte b_rshift .byte b_lit8, b_call8b0 .byte b_or callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_call16 callb c_8 .byte b_wm callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_call32 callb c_8 .byte b_num3, b_sub callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_call64 callb c_8 .byte b_lit8, <span class="hljs-number"><span class="hljs-number">7</span></span>, b_sub callb c_64 .byte b_exit #: $compile dup c@ <span class="hljs-number"><span class="hljs-number">0x80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa compile_c <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa compile_b then ; item <span class="hljs-string"><span class="hljs-string">"$compile"</span></span> _compile: .byte b_dup, b_get8, b_lit8, <span class="hljs-number"><span class="hljs-number">0x80</span></span>, b_and, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - ., b_cfa callb compile_c .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_cfa callb compile_b .byte b_exit</code> </pre><br></div></div><br>  Maintenant, nous devons compiler le nombre. <br><br><h4>  Compilation d'un nombre (litt√©ral) </h4><br>  A √©crit un sous-titre entier, pr√©par√© pour d√©crire sp√©cifiquement la compilation du litt√©ral, mais il s'av√®re qu'il n'y a rien de sp√©cial √† d√©crire :) <br><br>  Nous avons d√©j√† fait la moiti√© du travail dans le mot test_bv.  Il ne reste plus qu'√† appeler test_bv, et, selon le r√©sultat, compiler lit8 / 16/32/64, puis la valeur correspondante de 1, 2, 4 ou 8 octets. <br><br><div class="spoiler">  <b class="spoiler_title">Nous le faisons en d√©finissant le mot compile_n</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#   item compile_n compile_n: callb test_bv .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop, b_lit8, b_lit8 callb c_8 callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - ., b_drop, b_lit8, b_lit16 callb c_8 callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - ., b_lit8, b_lit32 callb c_8 callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_lit8, b_lit64 callb c_8 callb c_64 .byte b_exit</code> </pre></div></div><br><h4>  Modifier l'interpr√®te </h4><br>  Tout est pr√™t pour compiler la commande et les litt√©raux.  Maintenant, il doit √™tre int√©gr√© √† l'interpr√©teur.  Cette modification est simple.  O√π la commande a √©t√© ex√©cut√©e, ajoutez la v√©rification d'√©tat.  Si l'√©tat n'est pas nul et que le mot ne contient pas le drapeau imm√©diat, au lieu de l'ex√©cution, vous devez appeler $ compile.  Et √† peu pr√®s la m√™me chose √† faire lorsque le nombre est obtenu √† partir du flux d'entr√©e.  Si l'√©tat est nul, laissez simplement le num√©ro sur la pile et sinon, appelez compile_n. <br><br><div class="spoiler">  <b class="spoiler_title">Voici l'interpr√®te</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop callb state .byte b_get .byte b_qnbranch8, irpt_execute - . #  <span class="hljs-number"><span class="hljs-number">0</span></span>,    .byte b_dup, b_get8, b_lit8, f_immediate, b_and #  immediate    .byte b_qbranch8, irpt_execute - . #    -   #   ! callb _compile .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . irpt_execute: .byte b_cfa #  ,    (state = <span class="hljs-number"><span class="hljs-number">0</span></span>  immediate  ) .byte b_execute .byte b_branch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) #   -   callb state # ,    .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . #   -     ;   -   #   callb compile_n <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre></div></div><br>  Maintenant, nous sommes √† un pas du compilateur ... <br><br><h4>  D√©finition de nouveaux mots (mot ":") </h4><br>  Maintenant, si nous d√©finissons la variable d'√©tat sur une valeur non nulle, le processus de compilation commencera.  Mais le r√©sultat sera inutile, nous ne pourrons ni le r√©aliser, ni m√™me le retrouver en m√©moire.  Pour permettre de faire tout cela, il faut formater le r√©sultat de la compilation sous la forme d'un article de dictionnaire.  Pour ce faire, avant d'activer le mode de compilation, vous devez cr√©er un titre pour le mot. <br><br>  L'en-t√™te doit contenir des drapeaux, un champ de communication et un nom.  Ici, nous avons une histoire famili√®re - le champ de communication peut √™tre de 1, 2, 4 ou 8 octets.  Faisons le mot compile_1248, qui nous aidera √† former un tel champ de communication.  Il faudra deux nombres sur la pile - l'offset et la valeur g√©n√©r√©e par la commande test_bv. <br><br><div class="spoiler">  <b class="spoiler_title">compile_1248</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#    , ,     #     ,  test_dv item compile_1248 compile_1248: .byte b_dup .byte b_zeq .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_drop callb c_8 .byte b_exit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_dup, b_num1, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_drop callb c_16 .byte b_exit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_num2, b_eq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . callb c_32 .byte b_exit <span class="hljs-number"><span class="hljs-number">3</span></span>: callb c_64 .byte b_exit</code> </pre></div></div><br>  Maintenant, cr√©ez le mot $ create.  Il nous sera utile plus d'une fois.  Vous pouvez l'utiliser chaque fois que vous devez cr√©er un titre pour une entr√©e de dictionnaire.  Il prendra deux valeurs de la pile - l'adresse du nom du mot cr√©√© et sa longueur.  Apr√®s avoir ex√©cut√© ce mot, l'adresse de l'entr√©e de dictionnaire cr√©√©e appara√Ætra sur la pile. <br><br><div class="spoiler">  <b class="spoiler_title">$ cr√©er</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : $create here current @ @ here - test_bv dup c, compile_1248 -rot str, current @ ! <span class="hljs-string"><span class="hljs-string">' var0 here c!; item "$create" create: callb here callb current .byte b_get, b_get callb here .byte b_sub callb test_bv .byte b_dup callb c_8 callb compile_1248 .byte b_mrot callb c_str #       callb current .byte b_get, b_set #     - var0,      here #   ,    -    ,    #     ,     #    1 allot   ,   .byte b_lit8, b_var0 callb here .byte b_set8 .byte b_exit</span></span></code> </pre> </div></div><br>  Le mot suivant r√©cup√©rera le nom du nouveau mot dans le flux d'entr√©e en utilisant le mot blword et appellera $ create, cr√©ant un nouveau mot avec le nom sp√©cifi√©. <br><br><div class="spoiler">  <b class="spoiler_title">create_in</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> item <span class="hljs-string"><span class="hljs-string">"create_in"</span></span> create_in: .byte b_blword .byte b_dup .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> #     <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\ncreate_in - name not found!\n"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: callb create .byte b_exit</code> </pre></div></div><br>  Et enfin, faites le mot ":".  Il va cr√©er un nouveau mot en utilisant create_in et d√©finir le mode de compilation, il n'est pas install√©.  Et s'il est install√©, il donne une erreur.  Le mot ":" aura le signe imm√©diat. <br><br><div class="spoiler">  <b class="spoiler_title">le mot:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"># : : create_in <span class="hljs-number"><span class="hljs-number">1</span></span> state dup @ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .<span class="hljs-string"><span class="hljs-string">" : - no execute state!"</span></span> then ! <span class="hljs-number"><span class="hljs-number">110</span></span> ; immediate item <span class="hljs-string"><span class="hljs-string">":"</span></span>, f_immediate colon: callb create_in .byte b_num1 callb state .byte b_dup .byte b_get .byte b_qnbranch8, <span class="hljs-number"><span class="hljs-number">2f</span></span> - . .byte b_strp #   (     ) .byte <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">3f</span></span> #     <span class="hljs-number"><span class="hljs-number">3</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n: - no execute state!\n"</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_set .byte b_lit8, <span class="hljs-number"><span class="hljs-number">110</span></span> .byte b_exit</code> </pre></div></div><br>  Si quelqu'un a regard√© le code, il a vu que ce mot fait autre chose :) <br><br>  Et voici 110 ??? <br><br>  Oui, ce mot pousse √©galement le nombre 110 sur la pile, et c'est pourquoi.  Une fois compil√©es, les diff√©rentes constructions doivent √™tre un seul ensemble.  Par exemple, apr√®s si doit √™tre alors.  Et le mot cr√©√© en utilisant ":" devrait se terminer par ";".  Pour v√©rifier ces conditions, des mots sp√©ciaux du compilateur mettent certaines valeurs sur la pile et v√©rifient leur pr√©sence.  Par exemple, le mot ":" met la valeur 110 et le mot ";"  v√©rifie que 110 se trouve en haut de la pile. Si ce n'est pas le cas, c'est une erreur.  Ainsi, les structures de contr√¥le n'√©taient pas appari√©es. <br><br>  Une telle v√©rification est effectu√©e dans tous ces mots du compilateur, par cons√©quent, nous allons faire un mot sp√©cial pour cela - "? Paires".  Il prendra deux valeurs de la pile et g√©n√©rera une erreur si elles ne sont pas √©gales. <br><br>  De plus, en de tels mots, vous devez souvent v√©rifier que le mode de compilation est d√©fini.  Faisons le mot "? √âtat" pour cela. <br><br><div class="spoiler">  <b class="spoiler_title">? paires? √©tat</b> <div class="spoiler_text"><pre> <code class="cpp hljs">#: ?pairs = ifnot <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> then .<span class="hljs-string"><span class="hljs-string">" \nerror: no pairs operators"</span></span> quit then ; item <span class="hljs-string"><span class="hljs-string">"?pairs"</span></span> .byte b_eq, b_qbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no pairs operators"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit #: ?state state @ <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">abort</span></span><span class="hljs-string"><span class="hljs-string">" error: no compile state"</span></span> then ; item <span class="hljs-string"><span class="hljs-string">"?state"</span></span> callb state .byte b_get, b_zeq, b_qnbranch8, <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">3f</span></span> - <span class="hljs-number"><span class="hljs-number">2f</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\nerror: no compile state"</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_quit <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_exit</code> </pre></div></div><br>  C‚Äôest tout!  Nous ne compilerons rien d'autre dans l'assembleur manuellement :) <br><br>  Mais jusqu'√† la fin, le compilateur n'a pas encore √©t√© √©crit, donc au d√©but vous devrez utiliser des m√©thodes inhabituelles ... <br><br><h4>  Pr√©parons-nous √† compiler le compilateur cr√©√© avec le compilateur cr√©√© </h4><br>  Pour commencer, vous pouvez v√©rifier le fonctionnement du mot ":" en compilant quelque chose de simple.  Faisons, par exemple, le mot: <br><br><pre> <code class="cpp hljs">: ^<span class="hljs-number"><span class="hljs-number">2</span></span> dup * ;</code> </pre> <br>  Ce mot est quadratique.  Mais nous n'avons pas le mot ";" que faire?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous √©crivons le mot exit √† la place et il se compile. </font><font style="vertical-align: inherit;">Et puis d√©sactivez le mode de compilation avec le mot "[" et supprimez la valeur 110:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^2 dup * exit [ drop ( 0 ): &gt; 4 ^2 ( 1 ): 16 &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√áa marche! </font><font style="vertical-align: inherit;">Continuons </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous continuerons d'√©crire le fort sur le fort, nous devons penser √† o√π sera le code source du fort, et quand le compiler. </font><font style="vertical-align: inherit;">Faisons l'option la plus simple. </font><font style="vertical-align: inherit;">Le code source du fort sera plac√© dans le code source dans l'assembleur, sous forme de cha√Æne de texte. </font><font style="vertical-align: inherit;">Et pour qu'il ne prenne pas trop de place, nous le placerons imm√©diatement apr√®s l'adresse ici, dans la zone m√©moire libre. </font><font style="vertical-align: inherit;">Bien s√ªr, nous avons besoin de cette zone pour la compilation, mais la vitesse de ¬´fugue¬ª de l'interpr√©tation sera sup√©rieure au besoin de nouvelle m√©moire. </font><font style="vertical-align: inherit;">Ainsi, le code compil√© commencera √† √©craser la source sur le fort, √† partir du d√©but, mais nous n'en aurons plus besoin, car nous avons d√©j√† lu et utilis√© cette section.</font></font><br><br><pre> <code class="cpp hljs">fcode: .ascii <span class="hljs-string"><span class="hljs-string">" 2 2 + . quit"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais, au d√©but de la ligne, cela vaut la peine de placer une douzaine d'espaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour que cela fonctionne, nous modifions le bytecode de d√©part afin que tib, #tib pointe vers cette ligne. </font><font style="vertical-align: inherit;">√Ä la fin, il y a un arr√™t pour entrer dans la ligne de commande normale du syst√®me.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le d√©marrage du bytecode est devenu comme √ßa</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_call16 .word vhere - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word h - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word definitions - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word fcode_end - fcode .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_quit</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancez! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth 4 ( 0 ): &gt;</code> </pre><br>  Super! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant ... </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compilez le compilateur avec le compilateur </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous √©crivons le code dans la ligne fcode. </font><font style="vertical-align: inherit;">La premi√®re chose √† faire, bien s√ªr, est le mot ";".</font></font><br><br><pre> <code class="cpp hljs">: ; ?state <span class="hljs-number"><span class="hljs-number">110</span></span> ?pairs lit8 [ blword <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> find cfa c@ c, ] c, <span class="hljs-number"><span class="hljs-number">0</span></span> state ! <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> [ current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! drop</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je ferai quelques explications. </font></font><br><br><pre> <code class="plaintext hljs">?state 110 ?pairs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici on v√©rifie que l'√©tat de compilation est bien d√©fini, et 110 est sur la pile, sinon il y aura une interruption par erreur. </font></font><br><br><pre> <code class="plaintext hljs">lit8 [ blword exit find cfa c@ c, ]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci nous compilons la commande allum√©e avec le bytecode de la commande exit. </font><font style="vertical-align: inherit;">J'ai d√ª passer en mode d'ex√©cution, trouver le mot exit, obtenir l'adresse d'ex√©cution et r√©cup√©rer le code de commande √† partir de l√†. </font><font style="vertical-align: inherit;">Tout cela √©tait n√©cessaire car nous n'avons pas encore le mot compiler. </font><font style="vertical-align: inherit;">Si c'√©tait le cas, au lieu de tout cela, il suffirait d'√©crire simplement ¬´compiler exit¬ª :)</font></font><br><br><pre> <code class="plaintext hljs">c, 0 state !</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela compilera la commande exit lorsque le mot ";" est ex√©cut√©, puis le mode d'interpr√©tation sera d√©fini. </font><font style="vertical-align: inherit;">Le mot "[" ne peut pas √™tre utilis√© ici, car il a le signe imm√©diat et est ex√©cut√© </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintenant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais nous devons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ces commandes dans le mot ";" afin qu'elles d√©sactivent le mode de compilation.</font></font><br><br><pre> <code class="plaintext hljs">exit [</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous l'avons d√©j√† v√©cu. </font><font style="vertical-align: inherit;">Le mot exit est compil√© et le mode de compilation est d√©sactiv√©. </font><font style="vertical-align: inherit;">Tout, le mot ";" </font><font style="vertical-align: inherit;">compil√©. </font><font style="vertical-align: inherit;">Et quoi d'autre est √©crit l√†-bas?</font></font><br><br><pre> <code class="plaintext hljs">current @ @ dup c@ 96 or swap c! drop</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez d√©finir le drapeau imm√©diat pour le nouveau mot. </font><font style="vertical-align: inherit;">C'est exactement ce que fait la s√©quence indiqu√©e, √† l'exception du mot drop. </font><font style="vertical-align: inherit;">Le mot drop supprime le 110 oubli√© qui a plac√© le mot ":" au d√©but de la cr√©ation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant c'est tout! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous lan√ßons et essayons.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : ^3 dup dup * * ; ( 0 ): &gt; 6 ^3 . 216 ( 0 ): &gt;</code> </pre><br>  Voil√†!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est le premier mot que notre compilateur a compil√© ¬´pour de vrai¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous n'avons toujours pas de conditions, pas de boucles, et bien plus encore ... Commen√ßons par un petit mais tr√®s n√©cessaire mot pour cr√©er un compilateur: imm√©diat. </font><font style="vertical-align: inherit;">Il d√©finit l'attribut imm√©diat sur le dernier mot cr√©√©:</font></font><br><br><pre> <code class="cpp hljs">: immediate current @ @ dup c@ <span class="hljs-number"><span class="hljs-number">96</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> swap c! ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une s√©quence famili√®re :) R√©cemment, elle a √©t√© √©crite manuellement, elle ne sera plus n√©cessaire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons maintenant quelques mots petits mais utiles:</font></font><br><br><pre> <code class="cpp hljs">: hex <span class="hljs-number"><span class="hljs-number">16</span></span> base ! ; : decimal <span class="hljs-number"><span class="hljs-number">10</span></span> base ! ; : bl <span class="hljs-number"><span class="hljs-number">32</span></span> ; : tab <span class="hljs-number"><span class="hljs-number">9</span></span> ; : lf <span class="hljs-number"><span class="hljs-number">10</span></span> ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hex et d√©cimal d√©finissent le syst√®me num√©rique correspondant. </font><font style="vertical-align: inherit;">Les autres sont des constantes permettant d'obtenir les codes de caract√®res correspondants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous cr√©ons √©galement un mot pour copier une ligne avec un compteur </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:: cmove sur c @ 1+ move; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant, nous serons engag√©s dans des conditions. </font><font style="vertical-align: inherit;">En g√©n√©ral, s'il y avait un mot compil√©, il ressemblerait √† ceci:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous ces mots au d√©but v√©rifient que le mode de compilation est d√©fini et g√©n√®rent une erreur si ce n'est pas le cas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot if compile une branche conditionnelle, r√©serve un octet pour le param√®tre de commande de branche conditionnelle et pousse l'adresse de cet octet sur la pile. Il pousse ensuite la valeur de contr√¥le 111 sur la pile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mot v√©rifie alors la pr√©sence de la valeur de contr√¥le 111, puis √©crit le d√©calage dans l'adresse sur la pile.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et faites imm√©diatement le mot d'autre. </font><font style="vertical-align: inherit;">Au d√©but, il compile la commande de saut inconditionnel pour contourner la branche else. </font><font style="vertical-align: inherit;">De la m√™me mani√®re que si, le d√©calage de transition n'est pas encore connu, il est simplement r√©serv√© et son adresse est pouss√©e sur la pile. </font><font style="vertical-align: inherit;">Eh bien, apr√®s cela, exactement la m√™me chose se fait qu'avec then: l'adresse de la transition catch est d√©finie sur la branche else. </font><font style="vertical-align: inherit;">Quelque chose est plus difficile √† d√©crire que le code lui-m√™me :) Si quelqu'un veut le comprendre √† fond, il vaut mieux analyser le travail d'un tel code simplifi√© au maximum:</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, ; immediate : then dup here swap - swap c! ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, maintenant nous programmons le vrai code. </font><font style="vertical-align: inherit;">Comme nous n'avons pas le mot compiler, nous appliquons la m√™me astuce que lors de la cr√©ation du mot ";":</font></font><br><br><pre> <code class="cpp hljs">: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ?state lit8 [ blword ?nbranch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate : then ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs dup here swap - swap c! ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ?state <span class="hljs-number"><span class="hljs-number">111</span></span> ?pairs lit8 [ blword branch8 find cfa c@ c, ] c, here <span class="hljs-number"><span class="hljs-number">0</span></span> c, swap dup here swap - swap c! <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez maintenant essayer de compiler la condition. </font><font style="vertical-align: inherit;">Faisons, par exemple, un mot qui imprime 1000 s'il y en a 5 sur la pile, et 0 dans les autres cas:</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = if 1000 . else 0 . then ; ( 0 ): &gt; 22 test 0 ( 0 ): &gt; 3 test 0 ( 0 ): &gt; 5 test 1000 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est clair qu'un tel r√©sultat n'a pas fonctionn√© tout de suite, il y a eu des erreurs, il y a eu un d√©bogage. </font><font style="vertical-align: inherit;">Mais au final, les conditions ont fonctionn√©!</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une petite digression sur la longueur des commandes de transition</font></font></b> <div class="spoiler_text">  ,       ,      127 .       . ,  ,       .     ,   ,        .   8   ,    40  127    .   ,       ? <br><br>   .   ‚Äî    16 . <br><br>      . 16        ‚Äî    . ,      ,     call,      . , 11     ( 1023   ).         300  1000  .      ,        .      3  ,     8    .    :   (?nbranch),    (?branch)   (branch).  ‚Äî 24 . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons des conditions, la vie devient plus facile :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faisons un mot. "(Point-quote). Il affiche le texte sp√©cifi√© lors de son ex√©cution. Il est utilis√© de cette fa√ßon:</font></font><br><br><pre> <code class="cpp hljs">.<span class="hljs-string"><span class="hljs-string">"    "</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous ne pouvez utiliser ce mot qu'en mode compilation. </font><font style="vertical-align: inherit;">Cela deviendra apparent apr√®s avoir analys√© le dispositif de ce mot:</font></font><br><br><pre> <code class="cpp hljs">: .<span class="hljs-string"><span class="hljs-string">" ?state 34 word dup if lit8 [ blword (."</span></span>) find cfa c@ c, ] c, str, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop then ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce mot est ex√©cut√© en mode compilation. Il prend une cha√Æne du flux d'entr√©e jusqu'aux guillemets (34 mots). Si la ligne n'a pas pu √™tre obtenue, elle ne fait rien. Bien, ici, il serait pr√©f√©rable de d√©river un diagnostic. Mais pour la sortie de la ligne, ce mot est exactement ce que nous faisons :) Si n√©cessaire, vous pouvez √† nouveau red√©finir ce mot, d√©j√† avec des diagnostics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il √©tait possible d'obtenir la cha√Æne, la commande d'octets (. ") Est compil√©e, puis la cha√Æne re√ßue. Cette commande d'octets (guillemets pointill√©s entre crochets), lorsqu'elle est ex√©cut√©e, affiche la cha√Æne qui a √©t√© compil√©e derri√®re l'octet de commande. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V√©rifiez.</font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test ."    " ; ( 0 ): &gt; test     ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin, faisons compiler le mot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est clair qu'en mode compilation ce mot doit prendre le nom du mot suivant du flux, le trouver dans le dictionnaire. Et puis il y aura des options: ce peut √™tre une commande d'octets, ou ce peut √™tre un mot √©crit en code octet. Ces mots doivent √™tre compil√©s de diff√©rentes mani√®res. Par cons√©quent, nous allons cr√©er deux mots auxiliaires: "(compile_b)" et "(compile_c)". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) compilera la commande d'appel pour appeler le bytecode. Le param√®tre sera un mot de 64 bits - l'adresse du bytecode appel√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_c) compilera la commande byte. Par cons√©quent, le param√®tre de cette commande sera un octet - le code de commande. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, le mot compiler lui-m√™me compilera (compile_b) ou (compile_c) avec les param√®tres correspondants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par (compile_c),comme avec le plus simple:</font></font><br><br><pre> <code class="cpp hljs">: (compile_c) r&gt; dup c@ swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ &gt;rc, ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgr√© sa simplicit√©, nous √©crivons d'abord un mot en bytecode, qui en lui-m√™me a des param√®tres. Je vais donc commenter. Apr√®s avoir entr√© (compile_c), l'adresse de retour se trouve sur la pile de retour, car elle n'est pas banale. Il s'agit de l'adresse de l'octet suivant apr√®s la commande d'appel. La situation au moment de l'appel est indiqu√©e ci-dessous. A0 - code de commande d'appel, XX - param√®tre de commande d'appel - adresse d'appel (d√©calage) du code d'octet du mot (compile_c).</font></font><br><br><img src="https://habrastorage.org/webt/vj/jh/kh/vjjhkhqa7e35ygxdzclv0lf4-pw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'adresse de retour indique l'octet NN. Il existe g√©n√©ralement le code de l'octet suivant de la commande. Mais notre mot a des param√®tres, donc NN n'est que les param√®tres du mot "(compile_c)", √† savoir le code d'octet de la commande compil√©e. Vous devez lire cet octet et modifier l'adresse de retour en la d√©pla√ßant vers la commande d'octet suivante. Cela se fait par la s√©quence ¬´r&gt; dup c @ swap 1+&gt; r¬ª. Cette s√©quence extrait l'adresse de retour de la pile de retour vers la pile normale, en extrait un octet, y ajoute un (adresse de retour) et la renvoie √† la pile de retour. La commande restante ¬´c¬ª compile le code de commande octet obtenu √† partir des param√®tres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(compile_b) n'est pas beaucoup plus compliqu√©:</font></font><br><br><pre> <code class="cpp hljs">: (compile_b) r&gt; dup @ swap <span class="hljs-number"><span class="hljs-number">8</span></span> + &gt;r compile_b ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, tout est pareil, seul le param√®tre 64 bits est lu et le mot compile_b est utilis√© pour compiler le mot que nous avons d√©j√† cr√©√© pour le compilateur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et maintenant, le mot compile. </font><font style="vertical-align: inherit;">Comme d√©j√† discut√©, il lit le nom du mot, le trouve et compile l'une des deux commandes pr√©c√©dentes. </font><font style="vertical-align: inherit;">Je ne le commenterai pas, nous avons d√©j√† appliqu√© et d√©mont√© toutes les constructions utilis√©es.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compilation de mots</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">: compile blword over over find dup <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dup c@ <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cfa c@ (compile_b) [ blword (compile_c) find cfa , ] c, <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cfa (compile_b) [ blword (compile_b) find cfa , ] , then drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop .<span class="hljs-string"><span class="hljs-string">" compile: "</span></span> type .<span class="hljs-string"><span class="hljs-string">" - not found"</span></span> then ; immediate</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour v√©rifier le mot cr√©√©, nous cr√©ons, avec son aide, le mot ifnot. </font></font><br><br><pre> <code class="cpp hljs">: ifnot ?state compile ?branch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">111</span></span> ; immediate</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©couvrez-le! </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; : test 5 = ifnot 1000 . else 0 . then ; ( 0 ): &gt; 22 test 1000 ( 0 ): &gt; 3 test 1000 ( 0 ): &gt; 5 test 0 ( 0 ): &gt;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout va bien! Et il est temps de faire des cycles ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article nous allons faire des cycles avec une condition. Le fort a deux options pour un cycle avec une condition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re option est de commencer ... jusqu'√†. Le mot jusqu'√† ce que supprime la valeur de la pile, et si elle n'est pas √©gale √† z√©ro, le cycle se termine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxi√®me option est commencer ... tandis que ... r√©p√©ter. Dans ce cas, la v√©rification se produit lorsque le mot while est ex√©cut√©. La boucle se termine si la valeur sur la pile est nulle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cycles sur le fort se font de la m√™me mani√®re que les conditions - sur les transitions conditionnelles et inconditionnelles. J'apporte le code, les commentaires, je pense, ne sont pas n√©cessaires.</font></font><br><br><pre> <code class="cpp hljs">: begin ?state here <span class="hljs-number"><span class="hljs-number">112</span></span> ; immediate : until ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here - c, ; immediate : <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ?state <span class="hljs-number"><span class="hljs-number">112</span></span> ?pairs compile ?nbranch8 here <span class="hljs-number"><span class="hljs-number">0</span></span> c, <span class="hljs-number"><span class="hljs-number">113</span></span> ; immediate : repeat ?state <span class="hljs-number"><span class="hljs-number">113</span></span> ?pairs swap compile branch8 here - c, dup here swap - swap c! ; immediate</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aujourd'hui, nous avons termin√© avec le compilateur. </font><font style="vertical-align: inherit;">Il en reste tr√®s peu. </font><font style="vertical-align: inherit;">Des fonctions cl√©s qui n'ont pas encore √©t√© impl√©ment√©es ne sont que des cycles avec un compteur. </font><font style="vertical-align: inherit;">Et cela vaut √©galement la peine de quitter la commande de boucle de sortie. </font><font style="vertical-align: inherit;">Nous le ferons la prochaine fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous n'avons pas exp√©riment√© la commande de cycle! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous le faisons en √©crivant les mots standard. </font><font style="vertical-align: inherit;">Il faut enfin voir notre dictionnaire. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, au d√©but, nous faisons le mot lien @. </font><font style="vertical-align: inherit;">Il extraira le champ de communication de l'entr√©e du dictionnaire (d√©cal√© par rapport √† l'entr√©e pr√©c√©dente). </font><font style="vertical-align: inherit;">Comme nous nous en souvenons, le champ de communication peut avoir une taille diff√©rente: 1, 2, 4 ou 8 octets. </font><font style="vertical-align: inherit;">Ce mot prendra sur la pile l'adresse de l'entr√©e du dictionnaire et renverra deux valeurs: l'adresse du champ de nom et la valeur du champ de communication.</font></font><br><br><pre> <code class="cpp hljs">: link@ dup c@ <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> swap <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap dup <span class="hljs-number"><span class="hljs-number">0</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">1</span></span>+ swap c@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">2</span></span> + swap w@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop dup <span class="hljs-number"><span class="hljs-number">4</span></span> + swap i@ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drop dup <span class="hljs-number"><span class="hljs-number">8</span></span> + swap @ then then then ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant, vous pouvez cr√©er les mots: </font></font><br><br><pre> <code class="cpp hljs">: words context @ @ <span class="hljs-number"><span class="hljs-number">0</span></span> begin + dup link@ swap count type tab emit dup <span class="hljs-number"><span class="hljs-number">0</span></span>= until drop drop ;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancement ... </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; words words link@ repeat while until begin ifnot compile (compile_b) (compile_c) ." else then if cmove tab bl decimal hex immediate ; bye ?state ?pairs : str, interpret $compile compile_b compile_n compile_1248 compile_c c, w, i, , allot here h test_bv test_bvc [ ] state .s &gt;in #tib tib . #&gt; #s 60 # hold span holdpoint holdbuf base quit execute cfa find word blword var16 var8 (.") (") count emit expect type lshift rshift invert xor or and &gt;= &lt;= &gt; &lt; = 0&gt; 0&lt; 0= bfind compare syscall fill move rpick r@ r&gt; &gt;r -! +! i! i@ w! w@ c! c@ ! @ depth roll pick over -rot rot swap drop dup abs /mod mod / * - + 1+ 1- exit ?nbranch16 ?nbranch8 ?branch16 ?branch8 branch16 branch8 call8b0 call64 call32 call16 call8f lit64 lit32 lit16 lit8 8 4 3 2 1 0 context definitions current forth ( 0 ): &gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√áa y est, notre richesse :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je voulais tout dire ... non, permettons n√©anmoins de sp√©cifier un fichier avec un programme fort pour la compilation et l'ex√©cution en param√®tre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous faisons des commandes syscall pour ouvrir, fermer et lire le fichier. </font><font style="vertical-align: inherit;">Nous d√©finissons les constantes qui leur sont n√©cessaires.</font></font><br><br><pre> <code class="cpp hljs">: file_open <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> syscall ; : file_close <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> syscall ; : file_read <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> syscall ; : file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> ; : file_O_WRONLY <span class="hljs-number"><span class="hljs-number">1</span></span> ; : file_O_RDWR <span class="hljs-number"><span class="hljs-number">3</span></span> ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez maintenant cr√©er le mot de d√©part _start: </font></font><br><br><pre> <code class="cpp hljs">: _start <span class="hljs-number"><span class="hljs-number">0</span></span> pick <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> pick file_O_RDONLY <span class="hljs-number"><span class="hljs-number">0</span></span> file_open dup <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .\<span class="hljs-string"><span class="hljs-string">" error: \" . quit then dup here 32 + 32768 file_read dup 0&lt; if .\" error: \" . quit then swap file_close drop #tib ! here 32 + tib ! 0 &gt;in ! interpret then ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce mot se chargera du fichier et ex√©cutera n'importe quel programme fort. </font><font style="vertical-align: inherit;">Plus pr√©cis√©ment, l'interpr√©teur ex√©cutera tout ce qui sera dans ce fichier. </font><font style="vertical-align: inherit;">Et il peut y avoir, par exemple, une compilation de nouveaux mots et leur ex√©cution. </font><font style="vertical-align: inherit;">Le nom du fichier est indiqu√© par le premier param√®tre au d√©marrage. </font><font style="vertical-align: inherit;">Je n'entrerai pas dans les d√©tails, mais les param√®tres de lancement sous Linux sont pass√©s √† travers la pile. </font><font style="vertical-align: inherit;">Le mot _start les atteindra avec les commandes 0 pick (nombre de param√®tres) et 2 pick (pointeur sur le premier param√®tre). </font><font style="vertical-align: inherit;">Pour un syst√®me de fort, ces valeurs se trouvent en dehors de la pile, mais vous pouvez les obtenir avec la commande pick. </font><font style="vertical-align: inherit;">La taille du fichier est limit√©e √† 32 Ko, alors qu'il n'y a pas de gestion de la m√©moire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il reste maintenant √† √©crire dans la ligne fcode √† la fin:</font></font><br><br><pre> <code class="cpp hljs">_start quit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un fichier test.f et √©crivez quelque chose sur le fort. </font><font style="vertical-align: inherit;">Par exemple, l'algorithme euclidien pour trouver le plus grand facteur commun:</font></font><br><br><pre> <code class="cpp hljs">: NOD begin over over &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> over over &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> swap over - swap <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> over - then repeat drop ; <span class="hljs-number"><span class="hljs-number">23101</span></span> <span class="hljs-number"><span class="hljs-number">44425</span></span> NOD . bye</code> </pre><br>  Nous commen√ßons. <br><br><pre> <code class="plaintext hljs">$ ./forth test.f 1777 Bye! $</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La r√©ponse est correcte. </font><font style="vertical-align: inherit;">Le mot a √©t√© compil√©, puis rempli. </font><font style="vertical-align: inherit;">Le r√©sultat s'affiche, puis la commande bye a √©t√© ex√©cut√©e. </font><font style="vertical-align: inherit;">Si vous supprimez les deux derni√®res lignes, le mot NOD sera ajout√© au dictionnaire et le syst√®me ira √† sa ligne de commande. </font><font style="vertical-align: inherit;">Vous pouvez d√©j√† √©crire des programmes :-)</font></font><br><br>  C‚Äôest tout.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peu importe, vous pouvez t√©l√©charger la source ou le binaire pr√™t √† l'emploi pour Linux sur x86-64 depuis Github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64 Les</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sources sont livr√©es avec une licence </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GNU GPL v2</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCH v1 - Faites ce que vous voulez :-)</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437466/">https://habr.com/ru/post/fr437466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437454/index.html">Test de l'arithmom√®tre Felix M</a></li>
<li><a href="../fr437456/index.html">Plus jeune: Examen des t√©l√©phones IP Snom D315 et D305</a></li>
<li><a href="../fr437458/index.html">Inscription obligatoire par IMEI offre de faire pay√©</a></li>
<li><a href="../fr437460/index.html">Exemple de faux lecteur flash de 32 Go</a></li>
<li><a href="../fr437464/index.html">Prix ‚Äã‚ÄãTypeScript</a></li>
<li><a href="../fr437468/index.html">Retropie Dreamcast</a></li>
<li><a href="../fr437470/index.html">Quelques mots simples sur la d√©fense antimissile</a></li>
<li><a href="../fr437472/index.html">Transition du bureau √† udalenka: partage d'exp√©rience et hacks de vie</a></li>
<li><a href="../fr437474/index.html">Optimisez les performances du jeu avec les options d'importation du son Unity</a></li>
<li><a href="../fr437476/index.html">Ok Yandex! O√π sont nos objectifs de port√©e?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>