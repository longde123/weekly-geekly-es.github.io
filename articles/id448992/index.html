<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¦ğŸ¿ ğŸš ğŸŒ¾ Hashing serbaguna dan sempurna ğŸ‘¨ğŸ½â€ğŸŒ¾ ğŸŒ ğŸ¤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami memulai minggu ini dengan materi bermanfaat yang didedikasikan untuk peluncuran kursus "Algoritma untuk Pengembang" . Selamat membaca. 



 1. Ik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hashing serbaguna dan sempurna</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/448992/">  Kami memulai minggu ini dengan materi bermanfaat yang didedikasikan untuk peluncuran kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Algoritma untuk Pengembang"</a> .  Selamat membaca. <br><br><img src="https://habrastorage.org/webt/na/5_/ja/na5_jaknhrabunnqxjqmc1yjtvi.png"><br><br>  <b>1. Ikhtisar</b> <br><br>  Hashing adalah alat praktis yang hebat, dengan teori yang menarik dan halus.  Selain menggunakan data sebagai struktur kosa kata, hashing juga ditemukan di berbagai bidang, termasuk teori kriptografi dan kompleksitas.  Dalam kuliah ini, kami menjelaskan dua konsep penting: hashing universal (juga dikenal sebagai keluarga universal fungsi hash) dan hashing ideal. <a name="habracut"></a><br><br>  Materi yang disorot dalam kuliah ini meliputi: <br><br><ul><li>  Pengaturan formal dan ide umum hashing. </li><li>  Hashing universal. </li><li>  Hashing sempurna. </li></ul><br>  <b>2. Pendahuluan</b> <br><br>  Kami akan mempertimbangkan masalah utama dengan kamus yang telah kami diskusikan sebelumnya, dan mempertimbangkan dua versi: statis dan dinamis: <br><br><ul><li>  <i>Statis</i> : diberi banyak elemen S, kami ingin menyimpannya sedemikian rupa sehingga kami dapat dengan cepat melakukan pencarian. </li><li>  Misalnya, kamus tetap. </li><li>  <i>Dinamis</i> : di sini kami memiliki urutan permintaan untuk penyisipan, pencarian, dan kemungkinan penghapusan.  Kami ingin melakukan semua ini dengan efektif. </li></ul><br>  Untuk masalah pertama, kita bisa menggunakan array yang diurutkan dan pencarian biner.  Untuk yang kedua, kita bisa menggunakan pohon pencarian seimbang.  Namun, hashing menyediakan pendekatan alternatif, yang seringkali merupakan cara tercepat dan paling nyaman untuk menyelesaikan masalah ini.  Sebagai contoh, misalkan Anda sedang menulis sebuah program untuk pencarian AI dan ingin menyimpan situasi yang telah Anda selesaikan (posisi di papan tulis atau elemen ruang keadaan) agar tidak mengulangi perhitungan yang sama ketika Anda bertemu lagi.  Hashing menyediakan cara mudah untuk menyimpan informasi ini.  Ada juga banyak aplikasi dalam kriptografi, jaringan, teori kompleksitas. <br><br>  <b>3. Dasar-dasar hash</b> <br><br>  Pengaturan formal untuk hashing adalah sebagai berikut. <br><br><ul><li>  Kunci-kunci tersebut dimiliki oleh sejumlah besar U. (Misalnya, bayangkan bahwa U adalah kumpulan semua string dengan panjang maksimum 80 karakter ascii.) </li><li>  Ada beberapa kunci S di U yang benar-benar kita butuhkan (kunci bisa statis atau dinamis).  Biarkan N = | S |.  Bayangkan bahwa N jauh lebih kecil dari ukuran U. Misalnya, S adalah himpunan nama siswa di kelas yang jauh lebih kecil dari 128 ^ 80. </li><li>  Kami akan melakukan sisipan dan pencarian menggunakan array A dengan beberapa ukuran M dan <b>fungsi hash</b> h: U â†’ {0, ..., M - 1}.  Diberikan elemen x, ide hashing adalah bahwa kita ingin menyimpannya dalam A [h (x)].  Perhatikan bahwa jika Anda kecil (misalnya, string 2-karakter), maka Anda bisa menyimpan x dalam A [x], seperti dalam penyortiran blok.  Masalahnya adalah U itu besar, jadi kita butuh fungsi hash. </li><li>  Kami membutuhkan metode untuk menyelesaikan tabrakan.  Tabrakan adalah ketika h (x) = h (y) untuk dua kunci berbeda x dan y.  Dalam kuliah ini, kami akan menangani tabrakan dengan mendefinisikan setiap elemen A sebagai daftar tertaut.  Ada sejumlah metode lain, tetapi untuk masalah yang akan kita fokuskan di sini, ini yang paling cocok.  Metode ini disebut metode chaining.  Untuk memasukkan item, kami cukup meletakkannya di bagian atas daftar.  Jika h adalah fungsi hash yang baik, maka kami berharap daftar akan kecil. </li></ul><br>  Salah satu hal hebat tentang hashing adalah bahwa semua operasi kamus sangat mudah diimplementasikan.  Untuk mencari kunci x, cukup menghitung indeks i = h (x) dan kemudian pergi melalui daftar di A [i] sampai Anda menemukannya (atau keluar dari daftar).  Untuk menyisipkan, cukup tempatkan item baru di bagian atas daftar.  Untuk menghapus, Anda hanya perlu melakukan operasi hapus pada daftar yang ditautkan.  Sekarang kita beralih ke pertanyaan: apa yang kita butuhkan untuk mencapai kinerja yang baik? <br><br>  Properti yang diinginkan.  Properti yang diinginkan utama untuk skema hash yang baik: <br><br><ol><li>  Kunci tersebar dengan baik sehingga kami tidak memiliki terlalu banyak tabrakan, karena tabrakan memengaruhi waktu pencarian dan penghapusan. </li><li>  M = O (N): khususnya, kami ingin sirkuit kami mencapai properti (1) tanpa perlu ukuran tabel M menjadi jauh lebih besar dari jumlah elemen N. </li><li>  Fungsi h harus dihitung dengan cepat.  Dalam analisis kami hari ini, kami akan mempertimbangkan waktu untuk menghitung h (x) sebagai konstanta.  Namun, perlu diingat bahwa itu tidak boleh terlalu rumit karena itu mempengaruhi waktu eksekusi keseluruhan. </li></ol><br>  Dengan ini, waktu pencarian untuk elemen x adalah O (ukuran daftar adalah A [h (x)]).  Hal yang sama berlaku untuk penghapusan.  Penyisipan membutuhkan waktu O (1) terlepas dari panjang daftar.  Jadi, kami ingin menganalisis seberapa besar daftar ini. <br><br>  Intuisi dasar: satu cara untuk mendistribusikan elemen dengan indah adalah dengan mendistribusikannya secara acak.  Sayangnya, kita tidak bisa hanya menggunakan generator angka acak untuk memutuskan di mana mengarahkan elemen berikutnya, karena dengan begitu kita tidak akan pernah bisa menemukannya lagi.  Jadi, kami ingin h menjadi sesuatu yang "pseudo-random" dalam arti formal. <br><br>  Sekarang kami akan menyajikan beberapa kabar buruk, dan kemudian kabar baik. <br><br>  Pernyataan 1 (Berita Buruk) Untuk fungsi hash h jika | U |  â‰¥ (N âˆ’1) M +1, ada himpunan elemen S dari N yang semuanya hash di satu tempat. <br><br>  Bukti: dengan prinsip Dirichlet.  Khususnya, untuk mempertimbangkan titik tandingan, jika setiap lokasi memiliki tidak lebih dari N - 1 elemen U yang hash, maka U dapat memiliki ukuran tidak lebih dari M (N - 1). <br><br>  Ini sebagian mengapa hashing tampak begitu misterius - bagaimana bisa dikatakan bahwa hashing bagus jika untuk fungsi hash apa pun Anda dapat memikirkan cara untuk mencegahnya?  Salah satu jawabannya adalah bahwa ada banyak fungsi hash sederhana yang bekerja dengan baik dalam praktik untuk set S yang khas. <br><br>  Inilah ide kuncinya: mari gunakan pengacakan di konstruk h kami, mirip dengan quicksort acak.  (Tak perlu dikatakan, h akan menjadi fungsi deterministik).  Kami akan menunjukkan bahwa untuk setiap urutan penyisipan dan operasi pencarian (kita tidak perlu berasumsi bahwa himpunan elemen yang dimasukkan S adalah acak), jika kita memilih h dengan cara probabilistik ini, kinerja h dalam urutan ini akan baik dalam mengantisipasi.  Dengan demikian, ini adalah jaminan yang sama seperti dalam quicksort atau perangkap acak.  Secara khusus, ini adalah ide hashing universal. <br><br>  Setelah kami mengembangkan ide ini, kami akan menggunakannya untuk aplikasi yang sangat menyenangkan yang disebut "hashing sempurna". <br><br>  <b>4. hashing Universal</b> <br><br>  Definisi 1. Algoritma acak H untuk membangun fungsi hash h: U â†’ {1, ..., M} <br>  universal jika untuk semua x! = y di dalam U yang kita miliki <br><br><img src="https://habrastorage.org/webt/bj/h3/hd/bjh3hdghlrhmfl-4mf6i3xybf14.png"><br><br>  Kita juga dapat mengatakan bahwa himpunan fungsi hash adalah keluarga universal dari fungsi hash jika prosedur "pilih acak h âˆˆ H" bersifat universal.  (Di sini kami mengidentifikasi set fungsi dengan distribusi seragam atas set.) <br><br>  Teorema 2. Jika H adalah universal, maka untuk setiap himpunan S âŠ† U dengan ukuran N, untuk x âˆˆ U (misalnya, yang dapat kita cari), jika kita membangun h secara acak sesuai dengan H, jumlah tumbukan yang diharapkan antara x dan lainnya elemen dalam S tidak lebih dari N / M. <br><br>  Bukti: setiap y âˆˆ S (y! = X) memiliki paling tidak 1 / M peluang tabrakan dengan x dengan definisi "universal".  Jadi <br><br><ul><li>  Biarkan Cxy = 1 jika x dan y bertabrakan, dan 0 sebaliknya. </li><li>  Biarkan Cx menunjukkan jumlah total tabrakan untuk x.  Jadi, Cx = PyâˆˆS, y! = X Cxy. </li><li>  Kita tahu bahwa E [Cxy] = Pr (x dan y bertabrakan) â‰¤ 1 / M. </li><li>  Jadi, dalam linearitas ekspektasi, E [Cx] = Py E [Cxy] &lt;N / M. </li></ul><br>  Sekarang kita mendapatkan akibat wajar berikut. <br><br>  Konsekuensi 3. Jika H bersifat universal, maka untuk setiap urutan operasi penyisipan, pencarian, dan penghapusan L, di mana tidak boleh ada lebih dari elemen M dalam suatu sistem pada suatu waktu, total biaya operasi L yang diharapkan untuk acak h âˆˆ H hanya O (L) (melihat waktu) untuk menghitung h sebagai konstanta). <br><br>  Bukti: untuk setiap operasi tertentu dalam urutan, biaya yang diharapkan adalah konstan oleh Teorema 2, sehingga total biaya yang diharapkan dari operasi L adalah O (L) dalam linearitas ekspektasi. <br><br>  Pertanyaan: bisakah kita benar-benar membangun H universal?  Jika tidak, maka ini semua tidak ada gunanya.  Untungnya, jawabannya adalah ya. <br><br>  <i><b>4.1.</b></i>  <i><b>Menciptakan keluarga hash universal: metode matriks</b></i> <br><br>  Misalkan kuncinya panjang u-bit.  Katakanlah, ukuran tabel M sama dengan derajat 2, oleh karena itu, indeks b-bit panjang dengan M = 2b. <br><br>  Apa yang akan kita lakukan adalah memilih h sebagai matriks acak 0/1 b-by-u dan mendefinisikan h (x) = hx, di mana kita menambahkan mod 2. Matriks ini pendek dan tebal.  Sebagai contoh: <br><br><img src="https://habrastorage.org/webt/ly/q4/4k/lyq44kg-g4d8iloztroepglar9k.png"><br><br>  Proposisi 4. Untuk x! = Y Prh [h (x) = h (y)] = 1 / M = 1 / 2b. <br><br>  Bukti: Pertama, apa artinya mengalikan x dengan x?  Kita dapat menganggapnya sebagai menambahkan beberapa kolom h (melakukan penambahan vektor mod 2), di mana 1 bit dalam x menunjukkan mana yang akan ditambahkan.  (misalnya, kami menambahkan kolom 1 dan 3 dari h di atas) <br><br>  Sekarang ambil pasangan kunci acak x, y sedemikian rupa sehingga x! = Y.  Mereka pasti berbeda di suatu tempat, sehingga, katakanlah, mereka berbeda dalam koordinat ith, dan untuk konkretnya kita katakan xi = 0 dan yi = 1. Bayangkan bahwa kita pertama-tama memilih semua h kecuali kolom ke-i.  Untuk sisa sampel kolom ke-i, h (x) ditetapkan.  Namun, masing-masing 2b pengaturan yang berbeda pada kolom ke-i memberikan nilai h (y) yang berbeda (khususnya, setiap kali kita mengubah sedikit dalam kolom ini, kita mengubah bit yang sesuai menjadi h (y)).  Jadi ada kemungkinan 1 / 2b bahwa h (x) = h (y). <br><br>  Ada metode lain untuk membangun keluarga hash universal, yang juga didasarkan pada penggandaan bilangan prima (lihat Bagian 6.1). <br><br>  Pertanyaan selanjutnya yang akan kita pertimbangkan: jika kita memperbaiki set S, dapatkah kita menemukan fungsi hash sehingga semua pencarian akan memiliki waktu yang konstan?  Jawabannya adalah ya, dan ini mengarah ke topik hashing sempurna. <br><br>  <b>5. hashing sempurna</b> <br><br>  Kami mengatakan bahwa fungsi hash ideal untuk S jika semua pencarian terjadi di O (1).  Berikut adalah dua cara untuk membangun fungsi hash yang sempurna untuk himpunan S. <br><br>  <i><b>5.1 Metode 1: solusi di ruang O (N2)</b></i> <br><br>  Katakanlah kita ingin memiliki tabel yang ukurannya kuadratik dalam ukuran N dari kamus kita S. Maka di sini adalah metode sederhana untuk membangun fungsi hash yang ideal.  Biarkan H menjadi universal dan M = N2.  Kemudian pilih saja h acak dari H dan coba!  Pernyataannya adalah bahwa setidaknya ada kemungkinan 50% bahwa dia tidak akan mengalami tabrakan. <br><br>  Proposisi 5. Jika H adalah universal dan M = N2, maka Prhâˆ¼H (tidak ada tabrakan dalam S) â‰¥ 1/2. <br><br>  Bukti: <br><br>  â€¢ Berapa banyak pasangan (x, y) yang ada di S?  Jawabannya adalah: <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png"><br>  â€¢ Untuk setiap pasangan, probabilitas tumbukan mereka adalah â‰¤ 1 / M menurut definisi universalitas. <br>  â€¢ Jadi Pr (ada tabrakan) â‰¤ <img src="https://habrastorage.org/webt/1n/oh/w7/1nohw79oejhbrsciul36nklg4sq.png">  / M &lt;1/2. <br><br>  Ini seperti sisi lain dari "paradoks ulang tahun".  Jika jumlah hari jauh lebih besar dari jumlah orang yang dikuadratkan, maka ada kemungkinan yang masuk akal bahwa tidak ada pasangan yang akan berulang tahun. <br><br>  Jadi, kami hanya memilih h acak dari H, dan jika ada tabrakan, kami hanya memilih h baru.  Rata-rata, kita hanya perlu melakukan ini dua kali.  Sekarang, bagaimana jika kita hanya ingin menggunakan ruang O (N)? <br><br>  5.2 Metode 2: solusi di ruang O (N) <br><br>  Pertanyaan apakah mungkin untuk mencapai hashing sempurna di ruang O (N) telah terbuka untuk beberapa waktu: "Haruskah tabel diurutkan?"  Artinya, untuk set tetap, Anda bisa mendapatkan waktu pencarian konstan hanya dengan ruang linear?  Ada serangkaian upaya yang semakin kompleks, sampai akhirnya diselesaikan dengan ide bagus fungsi hash universal dalam skema dua tingkat. <br><br>  Metodenya adalah sebagai berikut.  Pertama, kita akan hash ke tabel ukuran N menggunakan hashing universal.  Ini akan menyebabkan beberapa tabrakan (kecuali jika kita beruntung).  Namun, kami mengulangi setiap keranjang menggunakan metode 1, mengkuadratkan ukuran keranjang untuk mendapatkan tabrakan nol.  Dengan demikian, skema terdiri dalam kenyataan bahwa kita memiliki fungsi hash dari tingkat pertama h dan tabel A dari tingkat pertama, dan kemudian fungsi hash N dari tingkat kedua h1, ..., hN dan N dari tabel tingkat kedua A1, ..., . ... Untuk menemukan elemen x, pertama-tama kita menghitung i = h (x), dan kemudian menemukan elemen dalam Ai [hi (x)].  (Jika Anda melakukan ini dalam praktiknya, Anda dapat mengatur bendera sehingga Anda akan mengambil langkah kedua hanya jika benar-benar ada konflik dengan indeks i, jika tidak, Anda hanya akan menempatkan x sendiri di A [i], tetapi mari jangan khawatir tentang itu di sini.) <br><br>  Katakan fungsi hash h hashes n elemen S ke lokasi i.  Kami telah membuktikan (dengan menganalisis metode 1) bahwa kami dapat menemukan h1, ..., hN, sehingga total ruang yang digunakan dalam tabel sekunder adalah Pi (ni) 2. Tetap menunjukkan bahwa kami dapat menemukan fungsi tingkat pertama h sedemikian rupa sehingga Pi (ni) 2 = O (N).  Bahkan, kami akan menunjukkan hal berikut: <br><br>  Teorema 6. Jika kita memilih titik awal h dari set universal H, maka <br><br><pre><code class="plaintext hljs">Pr[X i (ni)2 &gt; 4N] &lt; 1/2.</code> </pre> <br>  Bukti.  Mari kita buktikan dengan menunjukkan bahwa E [Pi (ni) 2] &lt;2N.  Ini menyiratkan apa yang kita inginkan dari ketidaksetaraan Markov.  (Jika ada kemungkinan bahkan 1/2 bahwa jumlahnya bisa lebih dari 4N, fakta ini saja akan berarti bahwa ekspektasi harus lebih dari 2N. Jadi, jika ekspektasinya kurang dari 2N, probabilitas kegagalan harus lebih kecil. 1/2.) <br><br>  Sekarang, trik rumitnya adalah bahwa salah satu cara untuk menghitung jumlah ini adalah dengan menghitung jumlah pasangan berurutan yang memiliki tabrakan, termasuk tabrakan dengan diri sendiri.  Misalnya, jika keranjang memiliki {d, e, f}, maka d akan memiliki konflik dengan masing-masing {d, e, f}, e akan memiliki konflik dengan masing-masing {d, e, f}, dan f akan memiliki konflik dengan masing-masing dari {d, e, f}, jadi kita mendapatkan 9. Jadi, kita memiliki: <br><br><pre> <code class="plaintext hljs">E[X i (ni)2] = E[X x X y Cxy] (Cxy = 1 if x and y collide, else Cxy = 0) = N +X x X y6=x E[Cxy] â‰¤ N + N(N âˆ’ 1)/M (where the 1/M comes from the definition of universal) &lt; 2N. (since M = N)</code> </pre><br>  Jadi, kami hanya mencoba h acak dari H sampai kami menemukan satu sehingga Pi n2 i &lt;4N, dan kemudian memperbaiki fungsi ini h, kami menemukan N fungsi hash sekunder h1, ..., hN seperti pada metode 1. <br><br>  <b>6. Diskusi lebih lanjut</b> <br><br>  <i><b>6.1 Metode hashing universal lainnya</b></i> <br><br>  Berikut adalah metode lain untuk membangun fungsi hash universal, yang sedikit lebih efisien daripada metode matriks yang diberikan sebelumnya. <br><br>  Dalam metode matriks, kami menganggap kunci sebagai vektor bit.  Dalam metode ini, kita akan mempertimbangkan kunci x sebagai vektor bilangan bulat [x1, x2, ..., xk] dengan satu-satunya persyaratan bahwa setiap xi berada dalam kisaran {0, 1, ..., M-1}.  Misalnya, jika kita memiliki string hash dengan panjang k, maka xi dapat menjadi karakter ke-i (jika ukuran tabel kita setidaknya 256) atau pasangan karakter ke-5 (jika ukuran tabel kita setidaknya 65536).  Selain itu, kami akan meminta ukuran meja kami M menjadi prima.  Untuk memilih fungsi hash h, kami memilih k angka acak r1, r2, ..., pk dari {0, 1, ..., M - 1} dan menentukan: <br><br><pre> <code class="plaintext hljs">h(x) = r1x1 + r2x2 + . . . + rkxk mod M.</code> </pre> <br>  Bukti bahwa metode ini bersifat universal dibangun dengan cara yang sama seperti bukti metode matriks.  Biarkan x dan y menjadi dua kunci yang berbeda.  Kami ingin menunjukkan bahwa Prh (h (x) = h (y)) â‰¤ 1 / M. Karena x! = Y, harus ada kasus ketika ada beberapa indeks i sedemikian rupa sehingga xi! = Yi.  Sekarang bayangkan Anda pertama kali memilih semua angka acak rj untuk j! = I.  Biarkan h â€² (x) = Pj6 = i rjxj.  Jadi, dengan memilih ri, kita mendapatkan h (x) = h â€² (x) + rixi.  Ini berarti bahwa kita memiliki konflik antara x dan y kapan tepatnya <br><br><pre> <code class="plaintext hljs">hâ€²(x) + rixi = hâ€²(y) + riyi mod M, or equivalently when ri(xi âˆ’ yi) = hâ€²(y) âˆ’ hâ€²(x) mod M.</code> </pre> <br>  Karena M adalah bilangan prima, membaginya dengan nilai bukan nol dari mod M adalah valid (setiap bilangan bulat dari 1 hingga M-1 memiliki modul invers multiplikatif M), yang berarti bahwa ada tepat satu nilai ri modulo M dimana persamaan di atas berlaku true, yaitu ri = (h â€² (y) - h â€² (x)) / (xi - yi) mod M. Dengan demikian, probabilitas kejadian ini tepat 1 / M. <br><br>  <b><i>6.2 Penggunaan hashing lainnya</i></b> <br><br>  Misalkan kita memiliki urutan elemen yang panjang, dan kita ingin melihat berapa banyak elemen yang berbeda dalam daftar.  Apakah ada cara yang baik untuk melakukan ini? <br><br>  Salah satu caranya adalah dengan membuat tabel hash, dan kemudian membuat satu melewati urutan dengan melakukan pencarian untuk setiap elemen dan kemudian memasukkan jika belum ada dalam tabel.  Jumlah elemen individu hanyalah jumlah sisipan. <br><br>  Dan sekarang, bagaimana jika daftar itu sangat besar dan kami tidak punya tempat untuk menyimpannya, tetapi jawaban perkiraan cocok untuk kami.  Sebagai contoh, bayangkan kita adalah router dan amati berapa banyak paket yang dilalui, dan kami ingin (kurang-lebih) melihat berapa banyak alamat IP sumber berbeda yang ada. <br><br>  Ini adalah ide yang bagus: katakanlah kita memiliki fungsi hash h yang berperilaku seperti fungsi acak, dan mari kita bayangkan bahwa h (x) adalah bilangan real dari 0 hingga 1. Satu hal yang bisa kita lakukan adalah tetap melacak minimum nilai hash telah diproduksi sejauh ini (jadi kami tidak akan memiliki meja sama sekali).  Misalnya, jika kuncinya adalah 3,10,3,3,12,10,12 dan h (3) = 0,4, h (10) = 0,2, h (12) = 0,7, maka kita mendapatkan 0, 2. <br><br>  Faktanya adalah bahwa jika kita memilih N angka acak dalam [0, 1], nilai minimum yang diharapkan adalah 1 / (N + 1).  Selain itu, ada kemungkinan bagus bahwa itu cukup dekat (kita dapat meningkatkan perkiraan kami dengan menjalankan beberapa fungsi hash dan mengambil median dari posisi terendah). <br><br>  Pertanyaan: mengapa menggunakan fungsi hash, dan tidak hanya memilih nomor acak setiap kali?  Ini karena kami peduli dengan jumlah elemen yang berbeda, dan bukan hanya jumlah total elemen (masalah ini jauh lebih sederhana: cukup gunakan penghitung ...). <br><br>  Teman-teman, apakah artikel ini bermanfaat bagi Anda?  Tuliskan di komentar dan bergabunglah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hari terbuka</a> , yang akan diadakan pada tanggal 25 April. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id448992/">https://habr.com/ru/post/id448992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id448976/index.html">Peristiwa musim semi Gamedev di HSE</a></li>
<li><a href="../id448980/index.html">Makan siang pertama kami bersama: mengapa dan bagaimana kami menghabiskan hari ujian kami</a></li>
<li><a href="../id448982/index.html">CMS tanpa kepala. Kenapa aku menulis milikku</a></li>
<li><a href="../id448986/index.html">Rekayasa balik 3D dengan pemindaian 3D</a></li>
<li><a href="../id448988/index.html">Kingston SSD menjadi lebih luas, mempertahankan biaya yang hampir sama - kami memenuhi seri A400-R</a></li>
<li><a href="../id448994/index.html">Apakah sulit untuk memulai jalur perekrut TI?</a></li>
<li><a href="../id448996/index.html">Membuat kebijakan kata sandi di Linux</a></li>
<li><a href="../id449002/index.html">Verifikasi formal pada contoh masalah serigala, kambing dan kubis</a></li>
<li><a href="../id449004/index.html">Baru dalam sertifikasi keamanan informasi</a></li>
<li><a href="../id449006/index.html">Kompleksitas tersembunyi dari slot video game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>