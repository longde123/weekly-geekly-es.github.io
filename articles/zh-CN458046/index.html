<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔬 🕡 ✊🏻 摇篮备忘单 👨🏻‍⚕️ 🤾🏿 👨🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我看来，大多数人只有在需要向项目中添加某些内容或突然中断了某些内容时才开始处理gradle-并且在解决了“劳累所致”的问题之后，安全地忘记了经验。 此外，Internet上的许多示例都与高度专业化的咒语相似，它们并不能增加对正在发生的事情的理解： 


android { compileSdkVe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>摇篮备忘单</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458046/"><p> 在我看来，大多数人只有在需要向项目中添加某些内容或突然中断了某些内容时才开始处理gradle-并且在解决了“劳累所致”的问题之后，安全地忘记了经验。 此外，Internet上的许多示例都与高度专业化的咒语相似，它们并不能增加对正在发生的事情的理解： </p><br><pre><code class="java hljs">android { compileSdkVersion <span class="hljs-number"><span class="hljs-number">28</span></span> defaultConfig { applicationId <span class="hljs-string"><span class="hljs-string">"com.habr.hello"</span></span> minSdkVersion <span class="hljs-number"><span class="hljs-number">20</span></span> targetSdkVersion <span class="hljs-number"><span class="hljs-number">28</span></span> } buildTypes { release { minifyEnabled <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> } } }</code> </pre> <br><p> 我不会详细描述以上各行的用途-这些是android插件实现的私有细节。 还有一些更有价值的东西-了解一切的组织方式。 这些信息散布在各个站点/官方文档/通讯座和插件的来源中-总的来说，这是我不希望忘记的通用性知识。 </p><br><p> 对于刚刚掌握了gradle或已被遗忘的人，可以将其他文本视为备忘单。 </p><a name="habracut"></a><br><h2 id="poleznye-ssylki"> 有用的链接 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a>非常丰富，但是在某些地方可能缺少详细信息。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">javadoc</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上的源代码</a> -由于groovy中的动态键入，开发环境远不能总是提供可用字段/方法的列表，并且通过方法和参数类型的简短名称（闭包），并非总是能够理解为什么需要它们。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于集线器的一篇文章，其中包含大量示例，</a>是《用gradle构建和测试》一书第二章的翻译。 这本书也可以阅读，可以免费获得。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一篇文章-关于buildSrc</a> </li></ul><br><h1 id="konsol"> 主控台 </h1><br><p>  Android studio / IDEA辛苦地隐藏了开发人员的gradle命令，即使更改build.gradle文件，它也会开始变得愚蠢或重新启动项目。 </p><br><p> 在这种情况下，从控制台调用gradle会变得更加轻松快捷。  grapper包装器通常随项目一起提供，并且可以在linux / macos / windows中正常工作，除非在后者中您需要调用bat文件而不是包装器。 </p><br><h2 id="vyzov-zadach"> 挑战任务 </h2><br><pre> <code class="plaintext hljs">./gradlew tasks</code> </pre> <br><p> 编写可用的任务。 </p><br><pre> <code class="plaintext hljs">./gradlew subprojectName:tasks --all</code> </pre> <br><p> 您可以显示一个单独的子项目的任务，即使使用<code>--all</code>选项，也将显示所有任务，包括次要任务。 </p><br><p> 您可以调用任何任务，并且依赖它的所有任务都将被调用。 </p><br><pre> <code class="plaintext hljs">./gradlew app:assembleDevelopDebug</code> </pre> <br><p> 如果您懒得写全名，可以扔掉小写字母： </p><br><pre> <code class="plaintext hljs">./gradlew app:assembleDD</code> </pre> <br><p> 如果冰雹不能清楚地猜出他们打算要完成的任务，它将显示适当选项的列表。 </p><br><h2 id="logging"> 记录中 </h2><br><p> 启动任务时控制台中显示的信息量在很大程度上取决于日志记录的级别。 <br> 除了缺省值外，还有<code>-q, -w, -i, -d</code> ，well或<code>--quiet, --warn, --info, --debug</code>越来越大。 在复杂的项目中，带有-d的输出可能会占用一个兆字节以上的空间，因此最好立即将其保存到文件中并通过搜索关键字查找该文件： </p><br><pre> <code class="bash hljs">./gradlew app:build -d &gt; myLog.txt</code> </pre> <br><p> 如果在某处引发异常，则堆栈跟踪的选项<code>-s</code> 。 </p><br><p> 您可以自己写日志： </p><br><pre> <code class="java hljs">logger.warn(<span class="hljs-string"><span class="hljs-string">'A warning log message.'</span></span>)</code> </pre> <br><p> 记录器是SLF4J的实现。 </p><br><h2 id="groovy">  Groovy </h2><br><p>  <code>build.gradle</code>文件中发生的只是常规代码。 </p><br><p> 由于某种原因，Groovy作为一种编程语言并不是很受欢迎，尽管就我看来，至少值得研究一下。 语言诞生于2003年，并且发展缓慢。 有趣的功能： </p><br><ul><li> 几乎所有的Java代码都是有效的Groovy代码。 直观地编写工作代码很有帮助。 </li><li> 同时在凹槽中支持静态，动态键入，而不是<code>String a = "a"</code>您可以放心地写<code>def a = "a"</code>甚至<code>def map = ['one':1, 'two':2, 'list' = [1,false]]</code> </li><li> 有些闭包可以动态确定执行上下文。 那些相同的<code>android {...}</code>块接受闭包，然后对某个对象执行它们。 </li><li> 存在字符串<code>"$a, ${b}"</code> ，多行字符串<code>"""yep, ${c}"""</code>插值，普通的Java字符串用单引号引起来： <code>'text'</code> </li><li> 有很多种扩展方法。 标准语言集合已经具有任何，每个，每个findAll之类的方法。 就我个人而言，这些方法的名称似乎并不寻常，但主要是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">它们是</a> 。 </li><li> 美味的语法糖，代码更短，更简单。 对于列表和哈希<code>[a,b,c], [key1: value1, key2: value2]</code>的声明，您不必在函数的参数周围加上括号<code>[a,b,c], [key1: value1, key2: value2]</code>漂亮的语法是： <code>[a,b,c], [key1: value1, key2: value2]</code> </li></ul><br><p> 总的来说，为什么Python / Javascript之类的语言飞速发展，而Groovy却没有？-这对我来说是个谜。 当时，当Java中甚至没有lambda时，诸如kotlin / scala之类的替代物就刚刚出现或尚不存在，Groovy必须看起来像一种非常有趣的语言。 </p><br><p>  groovy语法和动态类型的灵活性使我们能够在gradle中创建简洁的DSL。 </p><br><p> 现在，在Gradle的官方文档中，示例在Kotlin上重复了，并且似乎计划切换到它，但是代码不再看起来那么简单，而变得更像常规代码： </p><br><pre> <code class="java hljs">task hello { doLast { println <span class="hljs-string"><span class="hljs-string">"hello"</span></span> } }</code> </pre> <br><p> 与 </p><br><pre> <code class="kotlin hljs">tasks.register(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) { doLast { println(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) } }</code> </pre> <br><p> 但是，尚未计划在Kradle中重命名。 </p><br><h2 id="stadii-sborki"> 组装阶段 </h2><br><p> 它们分为初始化，配置和执行。 </p><br><p> 这个想法是gradle收集一个非循环的依赖图，并仅调用它们中所需的最小值。 如果我理解正确，那么初始化阶段将在执行build.gradle中的代码时发生。 </p><br><p> 例如，这： </p><br><pre> <code class="java hljs">copy { from source to dest }</code> </pre> <br><p> 或像这样： </p><br><pre> <code class="java hljs">task epicFail { copy{ from source to dest } }</code> </pre> <br><p> 也许这并不明显，但是上面的操作会减慢初始化速度。 为了在每次初始化时不处理复制文件，您需要在任务中使用<code>doLast{...}</code>或<code>doFirst{...}</code>块-然后将代码包装在闭包中，并在任务完成时调用它。 </p><br><pre> <code class="java hljs">task properCopy { doLast { copy { from dest to source } } }</code> </pre> <br><p> 大概 </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">properCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type: Copy)</span></span></span><span class="hljs-function"> </span></span>{ from dest to source }</code> </pre> <br><p> 在旧示例中​​， <code>doLast</code>可以看到<code>&lt;&lt;</code>运算符，而不是<code>doLast</code> ，但是由于行为不明显，他们后来放弃了它。 </p><br><pre> <code class="java hljs">task properCopy &lt;&lt; { println(<span class="hljs-string"><span class="hljs-string">"files copied"</span></span>) }</code> </pre> <br><h2 id="tasksall"> 所有任务 </h2><br><p> 有趣的是，使用<code>doLast</code>和<code>doFirst</code>您可以在任何任务上挂起某种动作： </p><br><pre> <code class="kotlin hljs">tasks.all { doFirst { println(<span class="hljs-string"><span class="hljs-string">"task </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> started"</span></span>) } }</code> </pre> <br><p>  IDE建议<code>tasks</code>具有一个<code>whenTaskAdded(Closure ...)</code>方法，但是<code>all(Closure ...)</code>方法的作用要有趣得多-所有现有任务以及添加新任务时都会调用闭包。 </p><br><p> 创建一个打印所有任务相关性的任务： </p><br><pre> <code class="kotlin hljs">task printDependencies { doLast { tasks.all { println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string"> dependsOn </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$dependsOn</span></span></span><span class="hljs-string">"</span></span>) } } }</code> </pre> <br><p> 左右： </p><br><pre> <code class="kotlin hljs">task printDependencies { doLast { tasks.all { Task task -&gt; println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${task.name}</span></span></span><span class="hljs-string"> dependsOn </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${task.dependsOn}</span></span></span><span class="hljs-string">"</span></span>) } } }</code> </pre> <br><p> 如果在运行时（在<code>doLast</code>块中）调用<code>tasks.all{}</code> ，那么我们将看到所有任务和依赖项。 <br> 如果在没有<code>doLast</code>的情况<code>doLast</code> （即在初始化过程中）执行相同的操作，则由于尚未添加打印任务，因此它们可能缺少依赖项。 </p><br><p> 哦，是的，上瘾！ 如果另一个任务应该取决于实现的结果，那么值得添加一个依赖项： </p><br><pre> <code class="java hljs">anotherTask.dependsOn properCopy</code> </pre> <br><p> 甚至像这样： </p><br><pre> <code class="kotlin hljs">tasks.all{ task -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (task.name.toLowerCase().contains(<span class="hljs-string"><span class="hljs-string">"debug"</span></span>)) { task.dependsOn properCopy } }</code> </pre> <br><h2 id="inputs-outputs-i-inkrementalnaya-sborka"> 输入，输出和增量装配 </h2><br><p> 每次都会调用一个常见任务。 如果您指定基于文件A的任务生成文件B，则在这些文件未更改的情况下gradle将跳过该任务。 而且gradle不会检查文件修改日期，而是检查其内容。 </p><br><pre> <code class="kotlin hljs">task generateCode(type: Exec) { commandLine <span class="hljs-string"><span class="hljs-string">"generateCode.sh"</span></span>, <span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"output.java"</span></span> inputs.file <span class="hljs-string"><span class="hljs-string">"input.txt"</span></span> output.file <span class="hljs-string"><span class="hljs-string">"output.java"</span></span> }</code> </pre> <br><p> 同样，您可以指定文件夹以及一些值： <code>inputs.property(name, value)</code> 。 </p><br><h2 id="task-description"> 任务描述 </h2><br><p> 调用<code>./gradlew tasks --all</code>标准任务都有漂亮的描述，并且以某种方式进行了分组。 对于您的任务，这非常简单地添加： </p><br><pre> <code class="kotlin hljs">task hello { group <span class="hljs-string"><span class="hljs-string">"MyCustomGroup"</span></span> description <span class="hljs-string"><span class="hljs-string">"Prints 'hello'"</span></span> doLast{ print <span class="hljs-string"><span class="hljs-string">'hello'</span></span> } }</code> </pre> <br><h3 id="taskenabled"> 启用任务 </h3><br><p> 您可以“关闭”任务-然后仍会调用其依赖项，但不会调用它。 </p><br><pre> <code class="java hljs">taskName.enabled <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br><h2 id="neskolko-proektov-moduley"> 几个项目（模块） </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中的多项目构建</a> </p><br><p> 在主项目中，您可以放置​​更多模块。 例如，它用于android项目-根项目中几乎没有任何内容，子项目中包含android插件。 如果要添加新模块，则可以添加另一个模块，例如，您还可以连接android插件，但对其使用其他设置。 </p><br><p> 另一个例子：当使用jitpack发布项目时，根项目描述了使用什么设置来发布甚至不会怀疑发布的子模块。 </p><br><p> 子模块在settings.gradle中指定： </p><br><pre> <code class="java hljs">include <span class="hljs-string"><span class="hljs-string">'name'</span></span></code> </pre> <br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读有关项目之间的依赖关系的更多信息<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> </p><br><h2 id="buildsrc">  buildSrc </h2><br><p> 如果<code>build.gradle</code>很多代码或重复了这些代码，则可以将其移到单独的模块中。 我们需要一个魔术名称为<code>buildSrc</code>的文件夹，您可以在其中将代码放入groovy或java中。  （或者，或者在<code>buildSrc/src/main/java/com/smth/</code>代码中，可以将测试添加到<code>buildSrc/src/test</code> ）。 例如，如果您需要其他功能，请在scala上编写任务或使用一些依赖项，然后直接在<code>buildSrc</code>中创建<code>build.gradle</code>并在它/ enable插件中指定必要的依赖项。 </p><br><p> 不幸的是，对于<code>buildSrc</code>的项目<code>buildSrc</code> IDE可能会愚蠢<code>buildSrc</code>有提示，在那里您将不得不编写导入和类/任务，还必须将其导入到通常的<code>build.gradle</code> 。  <code>import com.smth.Taskname</code>并不困难，您只需要记住这一点，而不必<code>buildSrc</code>为什么<code>buildSrc</code>的任务）。 </p><br><p> 因此，先编写直接在<code>build.gradle</code>中<code>build.gradle</code> ，然后再将代码传输到<code>buildSrc</code> ，这是很方便的。 </p><br><h2 id="svoy-tip-zadachi"> 自己的任务类型 </h2><br><p> 该任务继承自<code>DefaultTask</code> ，其中有许多很多字段，方法和其他内容。  <a href="">从DefaultTask继承的AbstractTask代码。</a> </p><br><p> 有用的要点： </p><br><ul><li> 您可以对它们使用字段和注释，而不是手动添加<code>inputs</code>和<code>outputs</code> ： <code>@Input, @OutputFile</code>等。 </li><li> 执行任务时将运行的方法： <code>@TaskAction</code> 。 </li><li> 仍然可以调用诸如<code>copy{from ... , into... }</code>这样的便捷方法，但是您必须为项目显式调用它们： <code>project.copy{...}</code> </li></ul><br><p> 当<code>build.gradle</code>某人为我们的任务写信时 </p><br><pre> <code class="java hljs">taskName { ... <span class="hljs-comment"><span class="hljs-comment">//some code }</span></span></code> </pre> <br><p> 在任务上调用<code>configure(Closure)</code>方法。 </p><br><p> 我不确定这是否是正确的方法，但是如果一个任务有多个字段，并且相互之间的状态很​​难用getter-setter来控制，那么重新定义该方法似乎很方便，如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">override def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Closure closure)</span></span></span></span>{ def result = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>().configure(closure) <span class="hljs-comment"><span class="hljs-comment">//    / - return result; }</span></span></code> </pre> <br><p> 即使你写 </p><br><pre> <code class="java hljs">taskName.fieldName value</code> </pre> <br><p> 那么仍然会调用<code>configure</code>方法。 </p><br><h2 id="svoy-plagin"> 自己的插件 </h2><br><p> 像任务一样，您可以编写自己的插件，该插件将配置某些内容或创建任务。 例如， <code>android{...}</code>发生的事情完全是一个优点。 <del> 黑暗魔法 </del>  Android插件，它另外创建了一堆任务，例如app：assembleDevelopDebug，用于风味/构建类型/尺寸的所有可能组合。 编写插件没有什么复杂的，为了更好地理解，您可以查看其他插件的代码。 </p><br><p> 第三步-您可以将代码放置在<code>buildSrc</code> ，而不是将其放置在单独的项目中。 然后，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://jitpack.io</a>或其他方式发布插件，并将其与其他插件类似地连接。 </p><br><h2 id="the-end"> 结束 </h2><br><p> 上面的示例可能包括错别字和不正确之处。 写个人笔记或用<code>ctrl+enter</code>标记-我会予以纠正。 最好从文档中获取特定的示例，并将本文作为“如何做”的一些清单。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458046/">https://habr.com/ru/post/zh-CN458046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458026/index.html">序列化格式比较</a></li>
<li><a href="../zh-CN458030/index.html">功能性JavaScript：查找数组元素和.reduce（）方法的算术平均值的五种方法</a></li>
<li><a href="../zh-CN458040/index.html">从莫斯科到托木斯克。 一招的故事</a></li>
<li><a href="../zh-CN458042/index.html">我如何在NSU组织机器学习培训</a></li>
<li><a href="../zh-CN458044/index.html">省级信息安全-停滞还是发展？</a></li>
<li><a href="../zh-CN458048/index.html">委托作为管理工具</a></li>
<li><a href="../zh-CN458050/index.html">Mobius 2019 Piter的情况如何（以及有关下一个Mobius的一些知识）</a></li>
<li><a href="../zh-CN458052/index.html">AMA与Habr.10。 最后*问题</a></li>
<li><a href="../zh-CN458056/index.html">Martin Kleppmann的大型访谈：“弄清楚分布式数据系统的未来”</a></li>
<li><a href="../zh-CN458060/index.html">在Unity引擎中创建草着色器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>