<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óÄÔ∏è üíΩ üë©üèø‚Äçü§ù‚Äçüë©üèª Fun√ß√µes para documentar bancos de dados PostgreSQL. Parte dois üï∫ üôè üíÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta √© a segunda parte do artigo que descreve fun√ß√µes definidas pelo usu√°rio para trabalhar com diret√≥rios do sistema: pg_class, pg_attribute, pg_cons...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fun√ß√µes para documentar bancos de dados PostgreSQL. Parte dois</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415897/">  Esta √© a segunda parte do artigo que descreve fun√ß√µes definidas pelo usu√°rio para trabalhar com diret√≥rios do sistema: pg_class, pg_attribute, pg_constraints etc. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zc/rx/ta/zcrxta08dnfat5cqpgid4lyq7by.png"></div><br>  Esta parte do artigo discute fun√ß√µes que <b>retornam as caracter√≠sticas de restri√ß√µes e √≠ndices</b> . <br><a name="habracut"></a><br>  A primeira metade do artigo fornece coment√°rios sobre a implementa√ß√£o de fun√ß√µes.  O segundo √© o c√≥digo fonte das fun√ß√µes.  Para os leitores que est√£o interessados ‚Äã‚Äãapenas nos textos originais, sugerimos seguir imediatamente para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ap√™ndice</a> . <br><p>  <b>Veja tamb√©m</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fun√ß√µes para documentar bancos de dados PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte um</a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fun√ß√µes para documentar bancos de dados PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte tr√™s</a> .</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fun√ß√µes para documentar bancos de dados PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O fim (parte quatro)</a> .</b> <br><br></p><h3>  admtf_Table_Constraintes lista de restri√ß√µes da tabela do banco de dados e suas caracter√≠sticas </h3><br><a name="tfTableC_def"></a><br><p>  A fun√ß√£o admtf_Table_Constraintes retorna uma lista de restri√ß√µes (CONSTRAINT) da tabela do banco de dados e suas caracter√≠sticas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O c√≥digo-fonte pode ser visualizado e baixado aqui</a> , e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° uma vers√£o de uma fun√ß√£o que n√£o usa um cursor</a> . </p><br><br>  Como par√¢metros, a fun√ß√£o assume o nome da tabela de origem ( <b>a_TableName</b> ) e o nome do esquema no qual a tabela √© criada ( <b>a_SchemaName</b> ). <br><br><p>  A descri√ß√£o de uma restri√ß√£o espec√≠fica √© uma combina√ß√£o do registro em <b>pg_class</b> descrevendo-o como uma rela√ß√£o f√≠sica e o registro em <b>pg_constraint</b> contendo dados sobre as caracter√≠sticas espec√≠ficas da restri√ß√£o. </p><br><br><img src="https://habrastorage.org/webt/q8/xc/ll/q8xcllhdjgtvndtzraq2ofsssti.png"><br><div class="spoiler">  <b class="spoiler_title">o c√≥digo fonte do operador na figura</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tbl.OID,con.conname,con.contype,con.conkey,reftbl.OID, reftbl.relname,con.confkey,con.consrc <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint con <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.connamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.conrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class reftbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.confrelid=reftbl.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableOID) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.contype <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>,con.conname;</code> </pre> <br></div></div><br><p>  Os dados principais (nome e tipo de restri√ß√£o) s√£o recuperados da <b>entrada do</b> diret√≥rio <b>pg_constraint</b> .  As caracter√≠sticas de cada restri√ß√£o s√£o extra√≠das do mesmo cat√°logo, que s√£o apresentadas na forma de tabelas OID ( <b>conrelid</b> , <b>confrelid</b> ) ou matrizes de n√∫meros de s√©rie de atributos ( <b>conkey</b> , <b>confkey</b> ) que participam da restri√ß√£o. </p><br><br><p>  A fun√ß√£o retorna caracter√≠sticas de restri√ß√£o na forma de nomes e atributos de tabela.  Nesse caso, os nomes da tabela s√£o extra√≠dos da <b>entrada do</b> cat√°logo <b>pg_class</b> pelo identificador (OID) e os nomes dos atributos das <b>entradas do</b> cat√°logo <b>pg_attribute</b> pelo identificador da tabela e n√∫mero de s√©rie do atributo.  Porque  Como os n√∫meros de s√©rie s√£o armazenados no diret√≥rio principal na forma de uma matriz (lista), as listas de nomes de atributos s√£o formadas dentro da fun√ß√£o usando um loop. </p><br><p>  A fun√ß√£o retorna uma caracter√≠stica especial - a regra para verificar os valores dos campos nas entradas da tabela (restri√ß√£o CHECK).  Essa caracter√≠stica √© armazenada como um valor de texto no campo <b>consrc do</b> diret√≥rio <b>pg_constraint</b> . </p><br>  <strong>Tabela 7. O resultado da execu√ß√£o da fun√ß√£o admtf_Table_Constraintes ('public', 'Street').</strong> <br><img src="https://habrastorage.org/webt/gd/x6/ny/gdx6ny5rnukyvjntf4bjirkwlye.png"><br><div class="spoiler">  <b class="spoiler_title">A vers√£o em texto da tabela na figura</b> <div class="spoiler_text"><table width="80" border="1"><tbody><tr><th width="15">  T√≠tulo </th><th width="5">  Tipo </th><th width="20">  Atributos da tabela de origem </th><th width="10">  O nome da tabela externa </th><th width="15">  Atributos de uma tabela externa </th><th width="15">  Regra de valida√ß√£o </th></tr><tr><td width="15">  xpkstreet </td><td width="5">  p </td><td width="20">  wcrccode, localityid, streetid </td><td width="10"></td><td width="15"></td><td width="15"></td></tr><tr><td width="15">  fk_street_locality </td><td width="5">  f </td><td width="20">  wcrccode, localityid </td><td width="10">  localidade </td><td width="15">  wcrccode, localityid </td><td width="15"></td></tr><tr><td width="15">  fk_street_streettype </td><td width="5">  f </td><td width="20">  streettypeacrm </td><td width="10">  streettype </td><td width="15">  streettypeacrm </td><td width="15"></td></tr><tr><td width="15">  ck_street_streetname </td><td width="5">  c </td><td width="20">  nome da rua </td><td width="10"></td><td width="15"></td><td width="15">  ((nome da rua) :: texto! ~ * '[az]' :: texto) </td></tr><tr><td width="15">  ck_street_streettypeacrm </td><td width="5">  c </td><td width="20">  streettypeacrm </td><td width="10"></td><td width="15"></td><td width="15">  ((streettypeacrm) :: bpchar! ~ * '[az]' :: texto) </td></tr></tbody></table><br></div></div><br><a name="tfTableC_woc_def"></a><br><h4>  Vers√£o sem cursor </h4><br><p>  Prevejo perguntas e coment√°rios sobre o uso do cursor na vers√£o principal da fun√ß√£o. </p><br><p>  N√£o vou responder - n√£o h√° camaradas pelo gosto e cor.  Mas darei uma vers√£o da fun√ß√£o sem um cursor.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A vers√£o da implementa√ß√£o da fun√ß√£o sem usar o cursor pode ser visualizada e baixada aqui</a> . </p><br><p>  A principal dificuldade √© organizar a jun√ß√£o (JOIN) das tabelas pelos valores localizados no tipo de atributo da matriz de uma delas.  Tais matrizes neste caso s√£o <b>conkey</b> e <b>confkey</b> . </p><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.conname,c.contype,c.conkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[], GENERATE_SUBSCRIPTS(c.conkey, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.conname=<span class="hljs-string"><span class="hljs-string">'fk_street_locality'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span>;</code> </pre><br><p>  Para resolver esse problema, o PostgrSQL cont√©m fun√ß√µes que retornam uma tabela de valores de ponteiros para elementos da matriz.  No nosso caso, a fun√ß√£o <b>generate_subscripts</b> ser√° usada.  Al√©m de gerar muitos ponteiros para a posi√ß√£o da matriz passada como par√¢metro, ele tamb√©m transforma um registro que cont√©m a matriz em v√°rios pelo n√∫mero de elementos na matriz.  Cada registro dessa tabela cont√©m um valor exclusivo - a posi√ß√£o da matriz. </p><br><br>  <strong>Tabela 8. Propagando a sequ√™ncia original usando <b>generate_subscripts</b> .</strong> <br><br><table width="95" border="1"><tbody><tr><th width="15">  Nome da restri√ß√£o </th><th width="5">  Tipo </th><th width="10">  Matriz de n√∫meros de atributo </th><th width="10">  Ponteiro para uma posi√ß√£o de matriz </th></tr><tr><td width="15">  fk_street_locality </td><td width="5">  f </td><td width="10">  {1,2} </td><td width="10">  1 </td></tr><tr><td width="15">  fk_street_locality </td><td width="5">  f </td><td width="10">  {1,2} </td><td width="10">  2 </td></tr></tbody></table><br><br><img src="https://habrastorage.org/webt/0t/yn/9_/0tyn9__z3p-g8knkavap0aluta8.png"><br><div class="spoiler">  <b class="spoiler_title">o c√≥digo fonte do operador na figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> con.conname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ConstraintName,con.contype::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ConstraintType, STRING_AGG(attr.attname, <span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.No) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_ConstraintKeyNames, reftbl.relname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> RefTableName, STRING_AGG(rattr.attname,<span class="hljs-string"><span class="hljs-string">', '</span></span><span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.No) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_RefTableKeyNames, con.consrc <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ConstraintSource <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.oid, c.conrelid,c.confrelid,c.conname,c.contype, c.conkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],c.consrc, c.confkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[], generate_subscripts(c.conkey, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint c) con <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.conrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.attrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum=con.conkey[con.No] <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class reftbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> con.confrelid=reftbl.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute rattr <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rattr.attrelid=reftbl.oid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rattr.attnum=con.confkey[con.No] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.conname,con.contype,reftbl.relname,con.consrc <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> con.contype <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>,con.conname;</code> </pre><br></div></div><br><p>  Essa tabela pode ser conectada ao <b>cat√°logo de</b> atributos <b>pg_attribute</b> extraindo nomes de atributos sob a condi√ß√£o <b>attr.attrelid = tbl.oid AND attr.attnum = con.conkey [con.No]</b> . <br>  Agora resta remover registros desnecess√°rios agrupando registros e criar uma sequ√™ncia a partir dos nomes dos atributos. </p><br><p>  A cria√ß√£o de uma linha √© realizada usando a fun√ß√£o de agrega√ß√£o <b>STRING_AGG</b> , na qual voc√™ deve especificar a op√ß√£o de classifica√ß√£o (ORDER BY), caso contr√°rio, a ordem dos atributos pode n√£o estar de acordo com a ordem de declara√ß√£o dos atributos no √≠ndice. </p><br><br><p>  O tempo de execu√ß√£o de ambas as vers√µes das fun√ß√µes coincidiu.  Foram necess√°rios 20 ms para gerar os dados na tabela de resultados. </p><br><h3>  Lista de fun√ß√µes Admtf_Table_Indexes dos √≠ndices da tabela do banco de dados e suas caracter√≠sticas </h3><br><a name="tfTableI_def"></a><br><p>  A fun√ß√£o admtf_Table_Indexes retorna uma lista de √≠ndices (INDEX) da tabela do banco de dados e suas caracter√≠sticas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O c√≥digo-fonte pode ser visualizado e baixado aqui</a> , e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° uma vers√£o de uma fun√ß√£o que n√£o usa um cursor</a> . </p><br>  Como par√¢metros, a fun√ß√£o assume o nome da tabela de origem ( <b>a_TableName</b> ) e o nome do esquema no qual a tabela √© criada ( <b>a_SchemaName</b> ). <br><img src="https://habrastorage.org/webt/fb/wv/jm/fbwvjmsipergemhoi8u1dyf8z3m.png"><br><div class="spoiler">  <b class="spoiler_title">o c√≥digo fonte do operador na figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tbl.oid,inxcls.relname,inxam.amname,inx.indisunique,inx.indisprimary, inx.indkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],inx.indoption::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],inxam.amcanorder <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index inx <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class inxcls <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indexrelid=inxcls.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace inxnsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inxcls.relnamespace=inxnsp.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_am inxam <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inxcls.relam=inxam.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableOID) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inxam.amname, inxcls.relname;</code> </pre><br></div></div><br><p>  A descri√ß√£o de um √∫nico √≠ndice √© uma combina√ß√£o de um registro em <b>pg_class</b> descrevendo-o como uma rela√ß√£o f√≠sica e um registro em <b>pg_index</b> contendo dados sobre as caracter√≠sticas espec√≠ficas do √≠ndice.  Al√©m disso, informa√ß√µes sobre m√©todos de acesso ao √≠ndice s√£o armazenadas no diret√≥rio do sistema pg_am. </p><br><pre> <code class="sql hljs">CASE inxam.amcanorder WHEN true THEN CASE inx.indoption[inx.No] &amp; 1 WHEN 1 THEN ' DESC' ELSE ' ASC' <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre><br><p>  <b>Um</b> atributo de exclusividade do √≠ndice ( <b>indisunique</b> ), um sinal de que o √≠ndice √© constru√≠do de acordo com a descri√ß√£o da chave prim√°ria ( <b>indisprimary</b> ), bem como matrizes de n√∫meros de s√©rie dos atributos da tabela, com base nos valores dos quais o √≠ndice ( <b>indkey</b> ) e os sinais da ordem de classifica√ß√£o dos valores dos atributos s√£o extra√≠dos da <b>entrada do</b> cat√°logo <b>pg_index.</b> no √≠ndice ( <b>introdu√ß√£o</b> ). </p><br><p>  Na entrada do cat√°logo que descreve o m√©todo de acesso do √≠ndice <b>pg_am,</b> s√£o <b>extra√≠dos</b> o atributo de adequa√ß√£o dos dados inclu√≠dos no √≠ndice para classifica√ß√£o ( <b>amcanorder</b> ) e o nome ou o tipo do m√©todo de acesso do √≠ndice ( <b>amname</b> ). </p><p></p><p>  Em outras palavras, o atributo amcanorder indica se √© poss√≠vel estabelecer uma ordem de classifica√ß√£o para os valores dos atributos inclu√≠dos no √≠ndice.  Se <b>amcanorder = true</b> , a ordem de classifica√ß√£o pode ser especificada, caso contr√°rio n√£o.  Na mesma figura, o significado dos valores da matriz de <b>op√ß√µes</b> √© <b>vis√≠vel</b> - se o bit direito da forma bin√°ria do valor contiver 1B, o valor do atributo correspondente ser√° classificado em ordem decrescente, caso contr√°rio - em ordem crescente. </p><br><p>  Listas de nomes de atributos inclu√≠dos no √≠ndice, bem como sinais da ordem dos valores dos atributos, s√£o formados dentro da fun√ß√£o usando um ciclo. </p><br><br>  <strong>Tabela 9. O resultado da execu√ß√£o da fun√ß√£o admtf_Table_Indexes ('public', 'Street').</strong> <strong><br></strong> <br><img src="https://habrastorage.org/webt/u0/ft/uz/u0ftuzwae5ew1anmkqwjgvqlrbg.png"><br><div class="spoiler">  <b class="spoiler_title">A vers√£o em texto da tabela na figura</b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="15">  Nome do √≠ndice </th><th width="5">  M√©todo </th><th width="5">  ?  √önico </th><th width="5">  ?  chave prim√°ria </th><th width="20">  Atributos no √≠ndice </th></tr><tr><td width="15">  xie1street </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  ASC wcrccode, ASC localityid, ASC streettypeacrm, ASC nome da rua </td></tr><tr><td width="15">  xie2stree </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  ASC wcrccode, ASC localityid, nome da rua ASC </td></tr><tr><td width="15">  xie3street </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  nome da rua ASC </td></tr><tr><td width="15">  xie9street </td><td width="5">  btree </td><td width="5">  f </td><td width="5">  f </td><td width="20">  wcrccode ASC, localityid ASC, nome da rua DESC </td></tr><tr><td width="15">  xpkstreet </td><td width="5">  btree </td><td width="5">  t </td><td width="5">  t </td><td width="20">  wcrccode ASC, localityid ASC, streetid ASC </td></tr><tr><td width="15">  xts1street </td><td width="5">  gim </td><td width="5">  f </td><td width="5">  f </td><td width="20">  streettsvector </td></tr><tr><td width="15">  xts2street </td><td width="5">  gim </td><td width="5">  f </td><td width="5">  f </td><td width="5">  streettsvector </td></tr></tbody></table><br></div></div><br><h4>  Vers√£o sem cursor </h4><br><p>  A abordagem para criar uma vers√£o de uma fun√ß√£o sem cursor √© exatamente a mesma descrita na se√ß√£o anterior: </p><br><ul><li>  reprodu√ß√£o de registros usando generate_subscripts; </li><li>  agrupamento subsequente de registros; </li><li>  Criando uma lista de atributos de √≠ndice usando a fun√ß√£o STRING_AGG com a op√ß√£o ORDER BY. </li></ul><br><img src="https://habrastorage.org/webt/7f/3y/bm/7f3ybmq5e8bd7auydle70utg8-k.png"><br><div class="spoiler">  <b class="spoiler_title">o c√≥digo fonte do operador na figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> inxcls.relname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_IndexName ,inxam.amname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_IndexType, inx.indisunique <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_isUnique,inx.indisprimary <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r_isPrimary, STRING_AGG(attr.attname|| <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> inxam.amcanorder <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> inx.indoption[inx.No] &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">' DESC'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">' ASC'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, c_Delimiter <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inx.No) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i.indrelid, i.indexrelid,i.indisunique,i.indisprimary, i.indkey::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],i.indoption::<span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[], generate_subscripts(i.indkey, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index i) inx <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class inxcls <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indexrelid=inxcls.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_am inxam <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inxcls.relam=inxam.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> inx.indrelid=tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.attrelid=tbl.OID <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum=inx.indkey[inx.No] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inxcls.relname,inxam.amname,inx.indisunique,inx.indisprimary <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> inxcls.relname;</code> </pre><br></div></div><br><br><p>  O tempo de execu√ß√£o de ambas as vers√µes das fun√ß√µes coincidiu, levei 20 ms para gerar os dados na tabela de resultados. </p><br><p>  Portanto, n√£o vou mais produzir vers√µes de fun√ß√µes, pois  quem quiser pode refaz√™-los ao seu gosto ou <b>entrar em contato comigo, enviarei uma vers√£o modificada gratuitamente</b> . </p><p>  <b>Veja tamb√©m a</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">terceira</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quarta</a> partes do artigo. </p><br><a name="Script2"></a><br><h2>  AP√äNDICE 1. Scripts </h2><br><a name="tfTableC"></a><br><h3>  Criando a fun√ß√£o admtf_Table_Constraintes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coment√°rios sobre o c√≥digo fonte da fun√ß√£o podem ser encontrados aqui.</a> <br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte da fun√ß√£o</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_ConstraintName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_RefTableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_RefTableKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_ConstraintSource <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_Scale <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintRec RECORD; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_ConstraintName name; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintType name; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_isUnique BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_isPrimary BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*      Primary KEY */</span></span> v_AttributeNum INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_AttributeName name; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_ConstraintKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_RefTableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID ,     */</span></span> v_RefTableName name;<span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> v_RefTableKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_RefTableKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     ,    */</span></span> v_ConstraintSource TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     CHECK*/</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN FOR v_ConstraintRec IN SELECT con.oid AS ConstraintOID ,tbl.OID AS TableOID, con.conname AS ConstraintName, con.contype AS ConstraintType, con.conkey AS ConstraintKeyNos, reftbl.OID AS RefTableOID, reftbl.relname AS RefTableName, con.confkey AS RefTableKeyNos, con.consrc AS ConstraintSource FROM pg_constraint con INNER JOIN pg_class tbl ON con.conrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid LEFT OUTER JOIN pg_class reftbl ON con.confrelid=reftbl.oid WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) ORDER BY con.contype DESC,con.conname LOOP v_ConstraintOID:=v_ConstraintRec.ConstraintOID; v_TableOID:=v_ConstraintRec.TableOID; v_ConstraintName:=v_ConstraintRec.ConstraintName; v_ConstraintType:=v_ConstraintRec.ConstraintType; v_ConstraintKeyNos:=v_ConstraintRec.ConstraintKeyNos; v_RefTableOID:=v_ConstraintRec.RefTableOID; v_RefTableName:=v_ConstraintRec.RefTableName; v_RefTableKeyNos:=v_ConstraintRec.RefTableKeyNos; v_ConstraintSource:=v_ConstraintRec.ConstraintSource; v_ConstraintKeyNames:=''; FOREACH v_AttributeNum IN ARRAY v_ConstraintKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_TableOID AND attr.attnum=v_AttributeNum; v_ConstraintKeyNames:=v_ConstraintKeyNames|| CASE WHEN v_ConstraintKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; v_RefTableKeyNames:=''; IF v_RefTableKeyNos IS NOT NULL THEN FOREACH v_AttributeNum IN ARRAY v_RefTableKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_RefTableOID AND attr.attnum=v_AttributeNum; v_RefTableKeyNames:=v_RefTableKeyNames|| CASE WHEN v_RefTableKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; END IF; RETURN QUERY SELECT v_ConstraintName,v_ConstraintType,v_ConstraintKeyNames, v_RefTableName,v_RefTableKeyNames, v_ConstraintSource; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Constraintes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Constraintes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_ConstraintName VARCHAR(256),r_ConstraintType VARCHAR(256),r_ConstraintKeyNames Text,r_RefTableName VARCHAR(256),r_RefTableKeyNames Text,r_ConstraintSource Text) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT tc.r_ConstraintName::VARCHAR(256), tc.r_ConstraintType::VARCHAR(256),tc.r_ConstraintKeyNames::TEXT, tc.r_RefTableName::VARCHAR(256),tc.r_RefTableKeyNames::TEXT, tc.r_ConstraintSource::TEXT FROM admtf_Table_Constraintes(a_SchemaName::NAME,a_TableName::NAME) tc; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Constraintes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Constraintes('public'::name,'Street'::name);</span></span></code> </pre><br></div></div><br><a name="tfTableC_woc"></a><br><h3>  Criando uma vers√£o do admtf_Table_Constraintes sem um cursor </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coment√°rios sobre o c√≥digo fonte da fun√ß√£o podem ser encontrados aqui.</a> <br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte da fun√ß√£o</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Constraintes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_ConstraintName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_ConstraintKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_RefTableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_RefTableKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,r_ConstraintSource <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_Scale <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintRec RECORD; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_ConstraintKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_ConstraintName name; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_ConstraintType name; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_isUnique BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_isPrimary BOOLEAN;<span class="hljs-comment"><span class="hljs-comment">/*      Primary KEY */</span></span> v_AttributeNum INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_AttributeName name; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_ConstraintKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_RefTableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID ,     */</span></span> v_RefTableName name;<span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> v_RefTableKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_RefTableKeyNames TEXT;<span class="hljs-comment"><span class="hljs-comment">/*     ,    */</span></span> v_ConstraintSource TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     CHECK*/</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN FOR v_ConstraintRec IN SELECT con.oid AS ConstraintOID , tbl.OID AS TableOID, con.conname AS ConstraintName, con.contype AS ConstraintType, con.conkey AS ConstraintKeyNos, reftbl.OID AS RefTableOID, reftbl.relname AS RefTableName, con.confkey AS RefTableKeyNos, con.consrc AS ConstraintSource FROM pg_constraint con INNER JOIN pg_class tbl ON con.conrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid LEFT OUTER JOIN pg_class reftbl ON con.confrelid=reftbl.oid WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) ORDER BY con.contype DESC,con.conname LOOP v_ConstraintOID:=v_ConstraintRec.ConstraintOID; v_TableOID:=v_ConstraintRec.TableOID; v_ConstraintName:=v_ConstraintRec.ConstraintName; v_ConstraintType:=v_ConstraintRec.ConstraintType; v_ConstraintKeyNos:=v_ConstraintRec.ConstraintKeyNos; v_RefTableOID:=v_ConstraintRec.RefTableOID; v_RefTableName:=v_ConstraintRec.RefTableName; v_RefTableKeyNos:=v_ConstraintRec.RefTableKeyNos; v_ConstraintSource:=v_ConstraintRec.ConstraintSource; v_ConstraintKeyNames:=''; FOREACH v_AttributeNum IN ARRAY v_ConstraintKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_TableOID AND attr.attnum=v_AttributeNum; v_ConstraintKeyNames:=v_ConstraintKeyNames|| CASE WHEN v_ConstraintKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; v_RefTableKeyNames:=''; IF v_RefTableKeyNos IS NOT NULL THEN FOREACH v_AttributeNum IN ARRAY v_RefTableKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_RefTableOID AND attr.attnum=v_AttributeNum; v_RefTableKeyNames:=v_RefTableKeyNames|| CASE WHEN v_RefTableKeyNames='' THEN '' ELSE c_Delimiter END ||v_AttributeName; END LOOP; END IF; RETURN QUERY SELECT v_ConstraintName,v_ConstraintType,v_ConstraintKeyNames, v_RefTableName,v_RefTableKeyNames, v_ConstraintSource; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Constraintes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Constraintes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_ConstraintName VARCHAR(256),r_ConstraintType VARCHAR(256),r_ConstraintKeyNames Text,r_RefTableName VARCHAR(256),r_RefTableKeyNames Text,r_ConstraintSource Text) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT tc.r_ConstraintName::VARCHAR(256), tc.r_ConstraintType::VARCHAR(256), tc.r_ConstraintKeyNames::TEXT, tc.r_RefTableName::VARCHAR(256), tc.r_RefTableKeyNames::TEXT, tc.r_ConstraintSource::TEXT FROM admtf_Table_Constraintes(a_SchemaName::NAME,a_TableName::NAME) tc; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Constraintes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Constraintes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Constraintes('public'::name,'Street'::name);</span></span></code> </pre><br></div></div><br><a name="tfTableI"></a><br><h3>  Criando a fun√ß√£o admtf_Table_Indexes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coment√°rios sobre o c√≥digo fonte da fun√ß√£o podem ser encontrados aqui.</a> <br><div class="spoiler">  <b class="spoiler_title">c√≥digo fonte da fun√ß√£o</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_IndexName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_IndexType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isUnique <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,r_isPrimary <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_IndexKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_IndexKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'i'</span></span>; v_IndexRec RECORD; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_Scale INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_IndexOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_IndexKeyNos SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> v_IndexName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_IndexAMName NAME; <span class="hljs-comment"><span class="hljs-comment">/*    ( ) */</span></span> v_isUnique BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_isPrimary BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">/*      Primary KEY */</span></span> v_AttributeNum INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_AttributeName NAME; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_IndexKeyNames TEXT; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN FOR v_IndexRec IN SELECT inxcls.oid AS IndexOID,tbl.oid AS TableOID, inxcls.relname AS IndexName,inxam.amname AS IndexAMName, inx.indisunique AS isUnique,inx.indisprimary isPrimary, inx.indkey::SMALLINT[] AS IndexKeyNos FROM pg_index inx INNER JOIN pg_class inxcls ON inx.indexrelid=inxcls.oid INNER JOIN pg_am inxam ON inxcls.relam=inxam.oid INNER JOIN pg_class tbl ON inx.indrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND inxcls.relkind=c_IndexKind AND tbl.relname=LOWER(a_TableName) ORDER BY inxam.amname, inxcls.relname LOOP v_IndexOID:=v_IndexRec.IndexOID; v_TableOID:=v_IndexRec.TableOID; v_IndexName:=v_IndexRec.IndexName; v_IndexAMName:=v_IndexRec.IndexAMName; v_isUnique:=v_IndexRec.isUnique; v_isPrimary:=v_IndexRec.isPrimary; v_IndexKeyNos:=v_IndexRec.IndexKeyNos; v_IndexKeyNames:=''; FOREACH v_AttributeNum IN ARRAY v_IndexKeyNos LOOP SELECT INTO v_AttributeName attr.attname::VARCHAR(100) AS r_AttributeName FROM pg_attribute attr WHERE attr.attrelid=v_TableOID AND attr.attnum=v_AttributeNum; v_IndexKeyNames:=v_IndexKeyNames|| CASE WHEN v_IndexKeyNames='' THEN '' ELSE c_Delimiter||' ' END || v_AttributeName; END LOOP; RETURN QUERY SELECT v_IndexName,v_IndexAMName,v_isUnique, v_isPrimary,v_IndexKeyNames; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Indexes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Indexes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_IndexName VARCHAR(256),r_IndexType VARCHAR(256),r_isUnique BOOLEAN,r_isPrimary BOOLEAN, r_IndexKeyNames TEXT) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT ti.r_IndexName::VARCHAR(256), ti.r_IndexType::VARCHAR(256), ti.r_isUnique::BOOLEAN, ti.r_isPrimary::BOOLEAN, ti.r_IndexKeyNames::TEXT FROM admtf_Table_Indexes(a_SchemaName::NAME,a_TableName::NAME) ti; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Indexes('public'::NAME,'Street'::NAME); SELECT * FROM admtf_Table_Indexes('public'::VARCHAR(256),'Street'::VARCHAR(256));</span></span></code> </pre><br></div></div><br><a name="tfTableI_woc"></a><br><h3>  Criando uma vers√£o do admtf_Table_Indexes sem um cursor </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Indexes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_IndexName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_IndexType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isUnique <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,r_isPrimary <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_IndexKeyNames <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_IndexKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'i'</span></span>; c_Delimiter CONSTANT VARCHAR(2):=', '; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN RETURN QUERY SELECT inxcls.relname AS r_IndexName, inxam.amname AS r_IndexType, inx.indisunique AS r_isUnique, inx.indisprimary r_isPrimary, STRING_AGG(attr.attname||CASE inxam.amcanorder WHEN true THEN CASE inx.indoption[inx.No] &amp; 1 WHEN 1 THEN ' DESC' ELSE ' ASC' END ELSE '' END, c_Delimiter ORDER BY inx.No) FROM (SELECT i.indrelid, i.indexrelid,i.indisunique, i.indisprimary,i.indkey::SMALLINT[], i.indoption::SMALLINT[], generate_subscripts(i.indkey, 1) as No FROM pg_index i) inx INNER JOIN pg_class inxcls ON inx.indexrelid=inxcls.oid INNER JOIN pg_am inxam ON inxcls.relam=inxam.oid INNER JOIN pg_class tbl ON inx.indrelid=tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid INNER JOIN pg_attribute attr ON attr.attrelid=tbl.OID AND attr.attnum=inx.indkey[inx.No] WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND inxcls.relkind=c_IndexKind AND tbl.relname=LOWER(a_TableName) GROUP BY inxcls.relname,inxam.amname,inx.indisunique,inx.indisprimary ORDER BY inxcls.relname; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName NAME, a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Indexes (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Indexes (a_SchemaName VARCHAR(256) default 'public', /*    */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_IndexName VARCHAR(256),r_IndexType VARCHAR(256),r_isUnique BOOLEAN,r_isPrimary BOOLEAN, r_IndexKeyNames TEXT) AS $BODY$ DECLARE --****************************************************************************************************** BEGIN RETURN QUERY SELECT ti.r_IndexName::VARCHAR(256), ti.r_IndexType::VARCHAR(256), ti.r_isUnique::BOOLEAN, ti.r_isPrimary::BOOLEAN, ti.r_IndexKeyNames::TEXT FROM admtf_Table_Indexes(a_SchemaName::NAME,a_TableName::NAME) ti; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Indexes(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Indexes('public'::NAME,'Street'::NAME); SELECT * FROM admtf_Table_Indexes('public'::VARCHAR(256),'Street'::VARCHAR(256));</span></span></code> </pre><br></div></div><br><h3>   </h3><br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     PostgreSQL.  </a> ;</b> <br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     PostgreSQL.  </a> .</b> <br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     PostgreSQL. ( )</a> .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415897/">https://habr.com/ru/post/pt415897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415881/index.html">Como o JS funciona: tecnologia Shadow DOM e componentes da Web</a></li>
<li><a href="../pt415887/index.html">Que tipo de rob√¥s-aranha sobrevoam est√°dios e jogam futebol. Entrevista com o criador do Robycam</a></li>
<li><a href="../pt415891/index.html">Quais s√£o os jogos de sequela legais?</a></li>
<li><a href="../pt415893/index.html">Como tornar os processos Java em execu√ß√£o no Linux / Docker simples e diretos</a></li>
<li><a href="../pt415895/index.html">O padr√£o mais importante na programa√ß√£o</a></li>
<li><a href="../pt415899/index.html">O Office 365 Outlook encontrou APIs n√£o documentadas com logs detalhados de atividades do usu√°rio</a></li>
<li><a href="../pt415901/index.html">A Comiss√£o do Conselho da Federa√ß√£o apoiou a ideia de criar uma base IMEI para todos os telefones brancos</a></li>
<li><a href="../pt415903/index.html">Bem-vindo ao ver√£o DIYorDIE Meetup em 7 de julho</a></li>
<li><a href="../pt415905/index.html">Como cultivar um produto saud√°vel (exemplo Juno)</a></li>
<li><a href="../pt415907/index.html">Como demitir funcion√°rios sem arriscar a imagem da empresa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>