<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∫ üÜñ üõÅ Sicherheitskrippen: JWT üéé üö∂üèæ üë®üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Anwendungen verwenden JSON Web Tokens (JWT), damit sich der Client nach der Authentifizierung f√ºr den weiteren Informationsaustausch identifizie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sicherheitskrippen: JWT</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acribia/blog/457090/"><img src="https://habrastorage.org/webt/db/hk/3r/dbhk3r8z4e24imgvw6mjwyuat4m.png"><br><br>  Viele Anwendungen verwenden JSON Web Tokens (JWT), damit sich der Client nach der Authentifizierung f√ºr den weiteren Informationsaustausch identifizieren kann. <br><br>  JSON Web Token ist ein offener Standard (RFC 7519), der eine kompakte und eigenst√§ndige Methode zum sicheren √úbertragen von Informationen zwischen Parteien als JSON-Objekt definiert. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/oq/x9/6o/oqx96ozecxiq4qbsrzrk-dw7n5u.png"><br>  Diese Informationen sind verifiziert und zuverl√§ssig, da sie digital signiert sind. <br>  JWTs k√∂nnen mit einem geheimen (unter Verwendung des HMAC-Algorithmus) oder √∂ffentlichen / privaten Schl√ºsselpaaren unter Verwendung von RSA oder ECDSA signiert werden. <br><br>  JSON Web Token wird verwendet, um Informationen √ºber die Identit√§t und Eigenschaften des Clients zu √ºbertragen.  Dieser "Container" wird vom Server signiert, damit der Client ihn nicht st√∂rt und beispielsweise keine Identifikationsdaten oder Merkmale √§ndern kann (z. B. die Rolle eines einfachen Benutzers zu einem Administrator oder die Anmeldung des Clients). <br><br>  Dieses Token wird bei erfolgreicher Authentifizierung erstellt und vom Server vor dem Starten jeder Clientanforderung √ºberpr√ºft.  Das Token wird von der Anwendung als ‚ÄûAusweis‚Äú des Kunden verwendet (ein Container mit allen Informationen √ºber ihn).  Der Server kann die G√ºltigkeit und Integrit√§t des Tokens auf sichere Weise √ºberpr√ºfen.  Auf diese Weise kann die Anwendung zustandslos sein (eine zustandslose Anwendung speichert keine in einer Sitzung generierten Clientdaten zur Verwendung in der n√§chsten Sitzung mit diesem Client (jede Sitzung ist unabh√§ngig)), und der Authentifizierungsprozess ist unabh√§ngig von den verwendeten Diensten (in dem Sinne, dass Client- und Servertechnologien) kann variieren, einschlie√ülich des Transportkanals, obwohl HTTP am h√§ufigsten verwendet wird). <br><br><h2>  √úberlegungen zur Verwendung von JWT </h2><br>  Selbst wenn das JWT-Token einfach zu verwenden ist und es Ihnen erm√∂glicht, Dienste (haupts√§chlich REST) ‚Äã‚Äãohne Status (zustandslos) bereitzustellen, ist diese L√∂sung nicht f√ºr alle Anwendungen geeignet, da sie einige Einschr√§nkungen aufweist, z. B. das Problem des Speicherns des Tokens. <br><br>  Wenn die Anwendung nicht vollst√§ndig zustandslos sein muss, k√∂nnen Sie das herk√∂mmliche Sitzungssystem verwenden, das von allen Webplattformen bereitgestellt wird.  F√ºr zustandslose Anwendungen ist JWT jedoch eine gute Option, wenn es korrekt implementiert ist. <br><br>
<h2>  JWT-Probleme und Angriffe </h2><br><h4>  Verwenden des NONE-Hash-Algorithmus </h4><br>  Ein √§hnlicher Angriff tritt auf, wenn ein Angreifer das Token und auch den Hashing-Algorithmus (Feld "alg") √§ndert, um durch das Schl√ºsselwort none anzuzeigen, dass die Token-Integrit√§t bereits √ºberpr√ºft wurde.  Einige Bibliotheken betrachteten Token, die mit dem Algorithmus none signiert wurden, als g√ºltiges Token mit einer verifizierten Signatur, sodass ein Angreifer die Nutzlast des Tokens √§ndern konnte und die Anwendung dem Token vertrauen w√ºrde. <br><br>  Um einen Angriff zu verhindern, m√ºssen Sie die JWT-Bibliothek verwenden, die von dieser Sicherheitsanf√§lligkeit nicht betroffen ist.  W√§hrend der Validierung des Tokens m√ºssen Sie au√üerdem explizit die Verwendung des erwarteten Algorithmus anfordern. <br><br>  <b><u>Implementierungsbeispiel:</u></b> <br><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //        //    HMAC-256 - JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)).build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Token-Abfangen </h4><br>  Der Angriff tritt auf, wenn ein Token von einem Angreifer abgefangen oder gestohlen wurde und er verwendet, um mithilfe der Anmeldeinformationen eines bestimmten Benutzers Zugriff auf das System zu erhalten. <br><br>  Der Schutz besteht darin, dem Token einen ‚ÄûBenutzerkontext‚Äú hinzuzuf√ºgen.  Der Benutzerkontext besteht aus folgenden Informationen: <br><br><ol><li>  Eine zuf√§llige Zeichenfolge, die in der Authentifizierungsphase generiert und im Token enthalten ist und auch als sichereres Cookie an den Client gesendet wird (Flags: HttpOnly + Secure + SameSite + Cookie-Pr√§fixe). </li><li>  Der SHA256-Hash aus der zuf√§lligen Zeichenfolge wird im Token gespeichert, sodass der Angreifer bei einem XSS-Problem den Wert der zuf√§lligen Zeichenfolge nicht lesen und das erwartete Cookie setzen kann. </li></ol><br>  Die IP-Adresse wird im Kontext nicht verwendet, da es Situationen gibt, in denen sich die IP-Adresse w√§hrend einer Sitzung √§ndern kann, z. B. wenn ein Benutzer √ºber sein Mobiltelefon auf die Anwendung zugreift.  Dann √§ndert sich die IP-Adresse st√§ndig rechtm√§√üig.  Dar√ºber hinaus kann die Verwendung einer IP-Adresse m√∂glicherweise Probleme bei der Einhaltung der europ√§ischen DSGVO verursachen. <br><br>  Wenn das empfangene Token w√§hrend der Token√ºberpr√ºfung nicht den richtigen Kontext enth√§lt, muss es abgelehnt werden. <br>  <b><u>Implementierungsbeispiel:</u></b> <br><br>  <i>Code zum Erstellen eines Tokens nach erfolgreicher Authentifizierung:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; //    private SecureRandom secureRandom = new SecureRandom(); ... //   ,     byte[] randomFgp = new byte[50]; secureRandom.nextBytes(randomFgp); String userFingerprint = DatatypeConverter.printHexBinary(randomFgp); //    cookie String fingerprintCookie = "__Secure-Fgp=" + userFingerprint + "; SameSite=Strict; HttpOnly; Secure"; response.addHeader("Set-Cookie", fingerprintCookie); // SHA256          // (  )  XSS      //     cookie MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      15     Calendar c = Calendar.getInstance(); Date now = c.getTime(); c.add(Calendar.MINUTE, 15); Date expirationDate = c.getTime(); Map&lt;String, Object&gt; headerClaims = new HashMap&lt;&gt;(); headerClaims.put("typ", "JWT"); String token = JWT.create().withSubject(login) .withExpiresAt(expirationDate) .withIssuer(this.issuerID) .withIssuedAt(now) .withNotBefore(now) .withClaim("userFingerprint", userFingerprintHash) .withHeader(headerClaims) .sign(Algorithm.HMAC256(this.keyHMAC));</span></span></code> </pre> <br><br>  <i>Code zur √úberpr√ºfung der G√ºltigkeit des Tokens:</i> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  HMAC   String   JVM private transient byte[] keyHMAC = ...; ... //     cookie String userFingerprint = null; if (request.getCookies() != null &amp;&amp; request.getCookies().length &gt; 0) { List&lt;Cookie&gt; cookies = Arrays.stream(request.getCookies()).collect(Collectors.toList()); Optional&lt;Cookie&gt; cookie = cookies.stream().filter(c -&gt; "__Secure-Fgp" .equals(c.getName())).findFirst(); if (cookie.isPresent()) { userFingerprint = cookie.get().getValue(); } } //  SHA256      cookie  //       MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] userFingerprintDigest = digest.digest(userFingerprint.getBytes("utf-8")); String userFingerprintHash = DatatypeConverter.printHexBinary(userFingerprintDigest); //      JWTVerifier verifier = JWT.require(Algorithm.HMAC256(keyHMAC)) .withIssuer(issuerID) .withClaim("userFingerprint", userFingerprintHash) .build(); //   DecodedJWT decodedToken = verifier.verify(token);</span></span></code> </pre> <br><h4>  Expliziter Widerruf des Tokens durch den Benutzer </h4><br>  Da das Token erst nach Ablauf ung√ºltig wird, verf√ºgt der Benutzer nicht √ºber eine integrierte Funktion, mit der Sie das Token explizit abbrechen k√∂nnen.  Im Falle eines Diebstahls kann der Benutzer den Token daher nicht selbst zur√ºckziehen und den Angreifer dann blockieren. <br><br>  Eine der Schutzmethoden ist die Einf√ºhrung einer schwarzen Liste von Token, die zur Simulation der in einem herk√∂mmlichen Sitzungssystem vorhandenen "Abmelde" -Funktion geeignet ist. <br><br>  Die Sammlung (in SHA-256-Codierung in HEX) des Tokens mit dem Stornierungsdatum, das die G√ºltigkeitsdauer des ausgestellten Tokens √ºberschreiten sollte, wird in der schwarzen Liste gespeichert. <br><br>  Wenn der Benutzer sich "abmelden" m√∂chte, ruft er einen speziellen Dienst auf, der das bereitgestellte Benutzertoken zur schwarzen Liste hinzuf√ºgt, was zur sofortigen L√∂schung des Tokens zur weiteren Verwendung in der Anwendung f√ºhrt. <br><br>  <u><b>Implementierungsbeispiel:</b></u> <br><br>  <i>Blacklist-Repository:</i> <br>  F√ºr die zentrale Speicherung der schwarzen Liste wird eine Datenbank mit folgender Struktur verwendet: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">create table </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> not exists </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revoked_token</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jwt_token_digest varchar(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> primary key, revokation_date timestamp </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">now</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <i>Token-Widerrufsverwaltung:</i> <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    (logout). //  ,      //         . public class TokenRevoker { //    @Resource("jdbc/storeDS") private DataSource storeDS; //      public boolean isTokenRevoked(String jwtInHex) throws Exception { boolean tokenIsPresent = false; if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //     try (Connection con = this.storeDS.getConnection()) { String query = "select jwt_token_digest from revoked_token where jwt_token_digest = ?"; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); try (ResultSet rSet = pStatement.executeQuery()) { tokenIsPresent = rSet.next(); } } } } return tokenIsPresent; } //    HEX      public void revokeToken(String jwtInHex) throws Exception { if (jwtInHex != null &amp;&amp; !jwtInHex.trim().isEmpty()) { //   byte[] cipheredToken = DatatypeConverter.parseHexBinary(jwtInHex); //  SHA256   MessageDigest digest = MessageDigest.getInstance("SHA-256"); byte[] cipheredTokenDigest = digest.digest(cipheredToken); String jwtTokenDigestInHex = DatatypeConverter.printHexBinary(cipheredTokenDigest); //             //   if (!this.isTokenRevoked(jwtInHex)) { try (Connection con = this.storeDS.getConnection()) { String query = "insert into revoked_token(jwt_token_digest) values(?)"; int insertedRecordCount; try (PreparedStatement pStatement = con.prepareStatement(query)) { pStatement.setString(1, jwtTokenDigestInHex); insertedRecordCount = pStatement.executeUpdate(); } if (insertedRecordCount != 1) { throw new IllegalStateException("Number of inserted record is invalid," + " 1 expected but is " + insertedRecordCount); } } } } }</span></span></code> </pre><br><h4>  Token-Offenlegung </h4><br>  Dieser Angriff tritt auf, wenn ein Angreifer Zugriff auf ein Token (oder eine Reihe von Token) erh√§lt und die darin gespeicherten Informationen extrahiert (Informationen zum JWT-Token werden mit base64 codiert), um Informationen √ºber das System zu erhalten.  Informationen k√∂nnen beispielsweise Sicherheitsrollen, Anmeldeformat usw. sein. <br><br>  Die Schutzmethode liegt auf der Hand und besteht in der Verschl√ºsselung des Tokens.  Es ist auch wichtig, verschl√ºsselte Daten mithilfe der Kryptoanalyse vor Angriffen zu sch√ºtzen.  Um all diese Ziele zu erreichen, wird der AES-GCM-Algorithmus verwendet, der die authentifizierte Verschl√ºsselung mit zugeh√∂rigen Daten (AEAD) erm√∂glicht.  Das AEAD-Grundelement bietet symmetrische authentifizierte Verschl√ºsselungsfunktionen.  Implementierungen dieses Grundelements sind vor adaptiven Angriffen basierend auf ausgew√§hltem Chiffretext gesch√ºtzt.  Bei der Verschl√ºsselung von Klartext k√∂nnen Sie optional verwandte Daten angeben, die authentifiziert, aber nicht verschl√ºsselt werden m√ºssen. <br><br>  Das hei√üt, die Verschl√ºsselung mit den relevanten Daten stellt die Authentizit√§t und Integrit√§t der Daten sicher, nicht jedoch deren Geheimhaltung. <br><br>  Es ist jedoch zu beachten, dass die Verschl√ºsselung haupts√§chlich hinzugef√ºgt wird, um interne Informationen zu verbergen. Es ist jedoch sehr wichtig, sich daran zu erinnern, dass der anf√§ngliche Schutz vor F√§lschungen des JWT-Tokens die Signatur ist. Daher sollte immer die Signatur des Tokens und seine √úberpr√ºfung verwendet werden. <br><br><h4>  Clientseitiger Token-Speicher </h4><br>  Wenn die Anwendung das Token so speichert, dass eine oder mehrere der folgenden Situationen auftreten: <br><br><ul><li>  Das Token wird automatisch vom Browser gesendet (Cookie-Speicher). </li><li>  Das Token wird auch dann erhalten, wenn der Browser neu gestartet wird (mithilfe des Browsers localStorage container). </li><li>  Das Token wird im Falle eines XSS-Angriffs abgerufen (Cookie f√ºr JavaScript-Code verf√ºgbar oder ein Token, das in localStorage oder sessionStorage gespeichert ist). </li></ul><br>  So verhindern Sie einen Angriff: <br><br><ol><li>  Speichern Sie das Token im Browser mithilfe des sessionStorage-Containers. </li><li>  F√ºgen Sie es mithilfe des Bearer-Schemas zum Authorization-Header hinzu.  Der Titel sollte folgenderma√üen aussehen: <br><br><pre> <code class="xml hljs">Authorization: Bearer <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">token</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </li><li>  F√ºgen Sie dem Token Fingerabdruckinformationen hinzu. </li></ol><br>  Durch Speichern des Tokens im sessionStorage-Container wird im Fall von XSS ein Token f√ºr Diebstahl bereitgestellt.  Ein dem Token hinzugef√ºgter Fingerabdruck verhindert jedoch, dass ein Angreifer das gestohlene Token auf seinem Computer wiederverwendet.  F√ºgen Sie eine Inhaltssicherheitsrichtlinie hinzu, um den Ausf√ºhrungskontext einzuschr√§nken, um die maximalen Nutzungsbereiche f√ºr einen Angreifer zu schlie√üen. <br><br>  Es bleibt ein Fall, in dem ein Angreifer den Browserkontext des Benutzers als Proxyserver verwendet, um die Zielanwendung √ºber einen legitimen Benutzer zu verwenden. Die Inhaltssicherheitsrichtlinie kann jedoch die Kommunikation mit unerwarteten Dom√§nen verhindern. <br><br>  Es ist auch m√∂glich, einen Authentifizierungsdienst zu implementieren, sodass das Token in einem sicheren Cookie ausgegeben wird. In diesem Fall sollte jedoch ein Schutz gegen CSRF implementiert werden. <br><br><h4>  Verwenden eines schwachen Schl√ºssels zum Erstellen eines Tokens </h4><br>  Wenn das im Fall des HMAC-SHA256-Algorithmus verwendete Geheimnis, das zum Signieren des Tokens erforderlich ist, schwach ist, kann es gehackt werden (mithilfe eines Brute-Force-Angriffs aufgegriffen werden).  Infolgedessen kann ein Angreifer ein beliebig g√ºltiges Token als Signatur vort√§uschen. <br><br>  Um dieses Problem zu vermeiden, m√ºssen Sie einen komplexen geheimen Schl√ºssel verwenden: alphanumerisch (gemischte Gro√ü- und Kleinschreibung) + Sonderzeichen. <br><br>  Da der Schl√ºssel nur f√ºr Computerberechnungen ben√∂tigt wird, kann die Gr√∂√üe des geheimen Schl√ºssels 50 Positionen √ºberschreiten. <br><br>  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">A&amp;'/}Z57M(2hNg=;LE?~]YtRMS5(yZ&lt;vcZTA3N-($&gt;2j:ZeX-BGftaVk`)jKP~q?,jk)EMbgt*kW'</code> </pre> <br>  Um die Komplexit√§t des f√ºr Ihre Tokensignatur verwendeten geheimen Schl√ºssels zu beurteilen, k√∂nnen Sie in Kombination mit der JWT-API einen Kennwortw√∂rterbuchangriff auf das Token anwenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457090/">https://habr.com/ru/post/de457090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457072/index.html">So l√∂sen Sie ein altes Problem mit ML in Python und .Net</a></li>
<li><a href="../de457074/index.html">Die Entwicklung der Entwickler: Welche Spiele sollten wir in Zukunft erwarten?</a></li>
<li><a href="../de457078/index.html">So verwandeln Sie Ihren Telegramm-Avatar in eine Uhr</a></li>
<li><a href="../de457082/index.html">Nicht wahrnehmbare Gew√§hrung von Administratorrechten</a></li>
<li><a href="../de457086/index.html">Architekturmuster "Builder" im Universum von "Swift" und "iOS" / "macOS"</a></li>
<li><a href="../de457092/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Ger√§tezugriff. Teil 5</a></li>
<li><a href="../de457094/index.html">Excel-Add-In, mit dem Filter bei der Arbeit mit Cubes (VBA) einfach festgelegt werden k√∂nnen</a></li>
<li><a href="../de457096/index.html">Wir geben mehreren Analysten die Hand: API Livy zur Automatisierung typischer Bankaufgaben</a></li>
<li><a href="../de457098/index.html">Elegante JavaScript-Fehlerbehandlung mit der Entweder-Monade</a></li>
<li><a href="../de457100/index.html">AWS Lambda - Theorie, Bekanntschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>