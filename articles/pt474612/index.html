<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèæ ü§π ü¶Ü Arquitetura EBA, tamb√©m conhecida como reatividade total üë®üèø‚Äçüíª üì† üéá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu vim para Tinkoff h√° alguns anos, em um novo projeto, Customers and Projects , que estava come√ßando naquele momento. 
 Agora, n√£o me lembro dos meus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arquitetura EBA, tamb√©m conhecida como reatividade total</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/474612/"><p>  Eu vim para Tinkoff h√° alguns anos, em um novo projeto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Customers and Projects</a> , que estava come√ßando naquele momento. <br>  Agora, n√£o me lembro dos meus sentimentos da ent√£o nova arquitetura para mim.  Mas lembro com certeza: era incomum que o Rx fosse usado em outro lugar, al√©m das viagens usuais √† rede e √† base.  Agora que essa arquitetura j√° passou por um caminho evolutivo de desenvolvimento, quero finalmente falar sobre o que aconteceu e o que aconteceu. </p><br><p><img src="https://habrastorage.org/webt/gk/ru/ve/gkruveswoxzhqfxjfasm_vaf2qq.png"></p><br><p>  Na minha opini√£o, todas as arquiteturas atualmente populares - MVP, MVVM e at√© MVI - est√£o h√° muito tempo na arena e nem sempre s√£o bem merecidas.  Eles n√£o t√™m falhas?  Eu vejo muitos deles.  Decidimos em nosso lugar que √© suficiente suportar isso e (re) inventamos uma nova arquitetura ass√≠ncrona. </p><a name="habracut"></a><br><p>  Descreverei brevemente o que n√£o gosto nas arquiteturas atuais.  Alguns pontos podem ser controversos.  Talvez voc√™ nunca tenha encontrado isso, voc√™ escreve programa√ß√£o Jedi perfeita e geralmente.  Ent√£o me perdoe, um pecador. <br>  Ent√£o, minha dor √©: </p><br><ul><li>  Apresentador enorme / ViewModel. </li><li>  Uma enorme quantidade de casos de troca no MVI. </li><li>  Incapacidade de reutilizar partes do Presenter / ViewModel e, como resultado, a necessidade de duplicar o c√≥digo. </li><li>  Montes de vari√°veis ‚Äã‚Äãmut√°veis ‚Äã‚Äãque podem ser modificadas de qualquer lugar.  Assim, √© dif√≠cil manter e modificar esse c√≥digo. </li><li>  Atualiza√ß√£o de tela n√£o decomposta. </li><li>  √â dif√≠cil escrever testes. </li></ul><br><h2 id="problematika">  <strong>Edi√ß√£o</strong> </h2><br><blockquote>  A todo momento, o aplicativo tem um determinado estado que define seu comportamento e o que o usu√°rio v√™.  Esse estado inclui todos os valores das vari√°veis ‚Äã‚Äã- de simples sinalizadores a objetos individuais.  Cada uma dessas vari√°veis ‚Äã‚Äãtem vida pr√≥pria e √© controlada por diferentes partes do c√≥digo.  Voc√™ pode determinar o estado atual do aplicativo apenas verificando todos, um ap√≥s o outro. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um artigo sobre a moderna arquitetura Kotlin MVI</a> <br><cut></cut><br></blockquote><br><h2 id="glava-1-evolyuciya--nashe-vsyo">  <strong>Cap√≠tulo 1. A evolu√ß√£o √© o nosso tudo</strong> </h2><br><p>  Inicialmente, escrevemos no MVP, mas um pouco modificado.  Foi uma mistura de MVP e MVI.  Havia entidades do MVP na forma de um apresentador e da interface View: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewTaskView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newTaskAction: Observable&lt;NewTaskAction&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> taskNameChangeAction: Observable&lt;String&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onChangeState: Consumer&lt;SomeViewState&gt; }</code> </pre> <br><p>  J√° aqui voc√™ pode perceber o problema: a exibi√ß√£o aqui est√° muito longe dos c√¢nones do MVP.  Havia um m√©todo no apresentador: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeView</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Disposable</code> </pre> <br><p>  L√° fora, foi aprovada uma implementa√ß√£o de interface que assinava reativamente as altera√ß√µes na interface do usu√°rio.  E j√° cheira a MVI! </p><br><p>  Mais √© mais.  No Presenter, diferentes interatores foram criados e inscritos nas altera√ß√µes de exibi√ß√£o, mas n√£o chamaram diretamente os m√©todos de interface do usu√°rio, mas retornaram algum estado global, no qual havia todos os poss√≠veis estados de tela: </p><br><pre> <code class="kotlin hljs">compositeDisposable.add( Observable.merge(firstAction, secondAction) .observeOn(AndroidSchedulers.mainThread()) .subscribe(view.onChangeState)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compositeDisposable</code> </pre> <br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewState</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> progress: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> error: Throwable? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorMessage: String? = error?.message, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result: TaskUi? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre><br><p>  Activity foi o descendente da interface SomeViewStateMachine: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateMachine</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSuccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(task: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeUiModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toProgress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeSomeButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buttonEnabled: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Quando o usu√°rio clicou em algo na tela, um evento chegou ao apresentador e ele criou um novo modelo, desenhado por uma classe especial: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeViewStateResolver</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stateMachine: SomeViewStateMachine) : Consumer&lt;SomeViewState&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stateUpdate: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">SomeViewState</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.toSuccess(stateUpdate.result) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.error != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { stateMachine.toError(stateUpdate.errorMessage) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.progress == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { stateMachine.toProgress() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateUpdate.someButtonEnabled != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { stateMachine.changeSomeButton(stateUpdate.someButtonEnabled) } } }</code> </pre> <br><p>  Concordo, algum MVP estranho, e at√© longe do MVI.  Procurando inspira√ß√£o. </p><br><h2 id="glava-2-redux">  <strong>Cap√≠tulo 2. Redux</strong> </h2><br><p><img src="https://habrastorage.org/webt/sw/bm/pf/swbmpfddkyjohcxemag4a0zdatm.jpeg"></p><br><p>  Falando sobre seus problemas com outros desenvolvedores, nosso (ent√£o ainda) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">l√≠der Sergey Boishtyan</a> aprendeu sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Redux</a> . </p><br><p>  Depois de assistir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√† conversa de Dorfman sobre todas as arquiteturas</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">brincar</a> com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Redux</a> , decidimos us√°-lo para atualizar nossa arquitetura. <br>  Mas primeiro, vamos examinar mais de perto a arquitetura e seus pr√≥s e contras. </p><br><p>  <strong>Ac√ß√£o</strong> <br>  Descreve a a√ß√£o. </p><br><p>  <strong>Actioncreator</strong> <br>  Ele √© como um analista de sistemas: formata, complementa a especifica√ß√£o de requisitos do cliente para que os programadores o entendam. <br>  Quando o usu√°rio clica na tela, o ActionsCreator forma uma a√ß√£o que vai para o middleware (algum tipo de l√≥gica de neg√≥cios).  A l√≥gica de neg√≥cios nos fornece novos dados que um determinado redutor recebe e extrai. </p><br><p>  Se voc√™ olhar a imagem novamente, poder√° observar um objeto como Loja.  Armazenar lojas Redutores.  Ou seja, vemos que os irm√£os front-end - irm√£os infelizes - imaginaram que um objeto grande pode ser visto em muitos pequenos, cada um dos quais ser√° respons√°vel por sua pr√≥pria parte da tela.  E este √© apenas um pensamento maravilhoso! </p><br><p>  C√≥digo de exemplo para ActionCreators simples (cuidado, JavaScript!): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ADD_TODO, text } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toggleTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: TOGGLE_TODO, index } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setVisibilityFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: SET_VISIBILITY_FILTER, filter } }</code> </pre> <br><p>  <strong>Redutor</strong> </p><br><blockquote>  A√ß√µes descreve o fato de que algo aconteceu, mas n√£o indica como o estado do aplicativo deve mudar em resposta; isso √© trabalho para o Redutor. </blockquote><p>  Em resumo, o Redutor sabe como atualizar decompositivamente a tela / view. </p><br><p>  Pr√≥s: </p><br><ul><li>  Atualiza√ß√£o da tela decomposta. </li><li>  Fluxo de dados unidirecional. </li></ul><br><p>  Contras: </p><br><ul><li>  Mudar favorito novamente. <br><pre> <code class="kotlin hljs">function todoApp(state = initialState, action) { switch (action.type) { case SET_VISIBILITY_FILTER: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { visibilityFilter: action.filter }) case ADD_TODO: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Object.assign({}, state, { todos: [ ...state.todos, { text: action.text, completed: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ] }) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state }</code> </pre> </li><li>  Um monte de objetos de estado. </li><li>  Separa√ß√£o da l√≥gica no ActionCreator e Reducer. </li></ul><br><p>  Sim, pareceu-nos que a separa√ß√£o do ActionCreator e do Redutor n√£o √© a melhor op√ß√£o para conectar o modelo e a tela, porque escrever instanceof (is) √© uma p√©ssima abordagem.  E aqui n√≥s inventamos nossa arquitetura! </p><br><h2 id="glava-3-eba">  <strong>Cap√≠tulo 3. EBA</strong> </h2><br><p><img src="https://habrastorage.org/webt/os/6w/7_/os6w7_sgmegw6nsh7lyebs_o9de.jpeg"></p><br><p>  O que √© Action e ActionCreator no contexto da EBA: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionCreator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"></span></span><span class="hljs-class"><span class="hljs-type"></span></span>(T) -&gt; (Observable&lt;Action&gt;)</code> </pre> <br><p>  Sim, metade da arquitetura √© tipealias e uma interface.  Simplicidade √© igual a eleg√¢ncia! </p><br><p>  √â necess√°ria uma a√ß√£o para chamar algo sem transmitir dados.  Como o ActionCreator retorna um Observable, tivemos que agrupar o Action em outro lambda para transmitir alguns dados.  E assim resultou o ActionMapper - uma a√ß√£o digitada pela qual podemos passar o que precisamos para atualizar a tela / exibi√ß√£o. <br><br>  <strong>Postulados b√°sicos:</strong> <br></p><div class="spoiler">  <b class="spoiler_title">Um ActionCreator - uma parte da tela</b> <div class="spoiler_text"><p>  Com o primeiro par√°grafo, tudo fica claro: para que n√£o haja um inferno de atualiza√ß√µes cruzadas incompreens√≠veis, concordamos que um ActionCreator pode atualizar apenas sua parte da tela.  Se for uma lista, ele atualiza apenas a lista, se apenas o bot√£o. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Punhal n√£o √© necess√°rio</b> <div class="spoiler_text"><p>  Mas, uma pergunta, por que Dagger n√£o nos agradou?  Eu te digo. <br>  Uma hist√≥ria t√≠pica √© quando um Sergey abstrato, tamb√©m conhecido como mestre das adagas, conhecido como ‚ÄúO que esse abstrato faz?‚Äù Est√° no projeto. </p><br><p>  Acontece que, se voc√™ experimentou uma adaga, precisa explicar cada vez para cada novo (e n√£o apenas novo) desenvolvedor.  Ou talvez voc√™ j√° tenha esquecido o que faz esta anota√ß√£o e acessado o Google. </p><br><p>  Tudo isso complica muito o processo de cria√ß√£o de recursos sem introduzir muita conveni√™ncia.  Portanto, decidimos criar as coisas de que precisamos com nossas m√£os, para que seja mais r√°pido montar, porque n√£o h√° gera√ß√£o de c√≥digo.  Sim, gastaremos mais cinco minutos escrevendo todas as depend√™ncias com as m√£os, mas economizaremos muito tempo na compila√ß√£o.  Sim, em todo lugar n√£o abandonamos a adaga, ela √© usada em n√≠vel global, cria algumas coisas comuns, mas as escrevemos em Java para melhor otimiza√ß√£o, para n√£o atrair o kapt. </p></div></div><br><p>  <strong>Esquema de arquitetura</strong> : </p><br><p><img src="https://habrastorage.org/webt/1w/m6/1a/1wm61atrwg2dmy4hkzfherwsbqc.png"></p><br><p>  Component √© um an√°logo do mesmo componente do Dagger, apenas sem o Dagger.  Sua tarefa √© criar um fich√°rio.  Pasta vincula ActionCreators juntos.  De Visualizar para Eventos do Fich√°rio acontecem o que aconteceu, e de Fich√°rio para Visualizar, s√£o enviadas a√ß√µes que atualizam a tela. </p><br><p>  <strong>Actioncreator</strong> </p><br><p><img src="https://habrastorage.org/webt/8v/nw/3p/8vnw3p52mcfzyyhegcxtkexgokm.png"></p><br><p>  Agora vamos ver que tipo de coisa √© essa - ActionCreator.  No caso mais simples, ele simplesmente processa a a√ß√£o unidirecionalmente.  Suponha que exista um cen√°rio assim: o usu√°rio clicou no bot√£o "Criar uma tarefa".  Outra tela deve abrir, onde a descreveremos, sem solicita√ß√µes adicionais. </p><br><p>  Para fazer isso, basta assinar o bot√£o usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RxBinding</a> do nosso amado Jake e esperar o usu√°rio clicar nele.  Assim que um clique ocorrer, o Binder enviar√° o evento para um ActionCreator espec√≠fico, que chamar√° nossa Action, que abrir√° uma nova tela para n√≥s.  Observe que n√£o houve interruptores.  Em seguida, mostrarei no c√≥digo por que isso acontece. <br>  Se subitamente precisarmos acessar a rede ou o banco de dados, faremos essas solicita√ß√µes logo ali, mas atrav√©s dos interatores que passamos ao construtor ActionCreator por meio da interface para cham√°-los: </p><br><blockquote>  Isen√ß√£o de responsabilidade: a formata√ß√£o do c√≥digo n√£o est√° bem aqui, eu tenho suas regras para o artigo, para que o c√≥digo seja bem lido. </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoadItemsActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> getItems: () -&gt; Observable&lt;List&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> showLoadedItems: ActionMapper&lt;DiffResult&lt;ViewTyped&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> diffCalculator: DiffCalculator&lt;ViewTyped&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> errorItem: ErrorView, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> emptyItem: ViewTyped? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) : ActionOnEvent</code> </pre> <br><p>  Pelas palavras "pela interface da chamada", quis dizer exatamente como getItems √© declarado (aqui ViewTyped √© a nossa interface para trabalhar com listas).  A prop√≥sito, reutilizamos este ActionCreator em oito partes diferentes do aplicativo, porque ele foi escrito o mais vers√°til poss√≠vel. </p><br><p>  Como os eventos s√£o de natureza reativa, podemos montar uma cadeia adicionando outros operadores, como startWith (showLoadingAction) para mostrar carregamento e onErrorReturn (errorAction) para mostrar um estado de tela com erro. <br>  E tudo isso √© reativo! </p><br><h2 id="primer-">  <strong>Exemplo</strong> </h2><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CompositionFragment</span></span></span></span>(R.layout.fragment_about) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.clicks(), openProcessingPersDataEvent = personalDataProtection.clicks(), unbindEvent = unBindEvent) component.binder().bind(events) }</code> </pre> <br><p>  Vamos finalmente olhar para a arquitetura usando o c√≥digo como exemplo.  Para come√ßar, escolhi uma das telas mais simples - sobre o aplicativo, porque √© uma tela est√°tica. <br>  Considere criar um componente: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> component = AboutComponent( setVersionName = { { appVersion.text = it } }, openPdfAction = { (url, name) -&gt; { openPdf(url, name) } } )</code> </pre> <br><p>  Argumentos de componentes - Actions / ActionMappers - ajudam a associar o View ao ActionCreators.  No ActionMapper'e setVersionName, passamos a vers√£o do projeto e atribu√≠mos esse valor ao texto na tela.  No openPdfAction, um par de um link de documento e um nome para abrir a pr√≥xima tela em que o usu√°rio pode ler este documento. </p><br><p>  Aqui est√° o pr√≥prio componente: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutComponent</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionMapper&lt;String&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, someUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, anotherUrlString) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName = setVersionName.toSimpleActionCreator( moreComponent::currentVersionName ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AboutEventsBinder(setVersionName, openPolicyPrivacy, openProcessingPersonalData) } }</code> </pre> <br><p>  Deixe-me lembr√°-lo que: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Action = () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> ActionMapper&lt;T&gt; = (T) -&gt; Action</code> </pre> <br><p>  OK, vamos seguir em frente. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">binder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: AboutEventsBinder</code> </pre> <br><p>  Vamos dar uma olhada no AboutEventsBinder em mais detalhes. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEventsBinder</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> setVersionName: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData: ActionOnEvent) : BaseEventsBinder&lt;AboutEvents&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AboutEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.merge( setVersionName(events.bindEvent), openPolicyPrivacy(events.openPolicyPrivacyEvent), openProcessingPersonalData(events.openProcessingPersDataEvent)) } }</code> </pre> <br><p>  ActionOnEvent √© outra tipealias, para n√£o escrever sempre. </p><br><pre> <code class="kotlin hljs">ActionCreator&lt;Observable&lt;*&gt;&gt;</code> </pre> <br><p>  No AboutEventsBinder, transmitimos ActionCreators e, invocando-os, vinculamos a um evento espec√≠fico.  Mas, para entender como tudo isso se conecta, vejamos a classe base - BaseEventsBinder. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread() ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(events).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  Vemos o m√©todo bindInternal familiar, que redefinimos no sucessor.  Agora considere o m√©todo de liga√ß√£o.  Toda a magia est√° aqui.  Aceitamos o herdeiro da interface BaseEvents, passamos para bindInternal para conectar eventos e a√ß√µes.  Quando dizemos que o que quer que venha, executamos no fluxo da interface do usu√°rio e assinamos.  Tamb√©m vemos um hack interessante - takeUntil. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEvents</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable }</code> </pre> <br><p>  Depois de definir o campo unbindEvent em BaseEvents para controlar o cancelamento de assinatura, devemos implement√°-lo em todos os herdeiros.  Esse maravilhoso campo permite que voc√™ cancele automaticamente a inscri√ß√£o na cadeia assim que esse evento for conclu√≠do.  √â simplesmente √≥timo!  Agora voc√™ n√£o pode seguir e n√£o se preocupar com o ciclo de vida e dormir em paz. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacy = OpenPdfActionCreator(openPdfAction, policyPrivacyUrl) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersonalData = OpenPdfActionCreator(openPdfAction, personalDataUrl)</code> </pre> <br><p>  De volta ao componente.  E aqui voc√™ j√° pode ver o m√©todo de reutiliza√ß√£o.  N√≥s escrevemos uma classe que pode abrir a tela de visualiza√ß√£o em pdf e n√£o importa para n√≥s qual √© o URL.  Sem duplica√ß√£o de c√≥digo. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OpenPdfActionCreator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPdfAction: ActionMapper&lt;Pair&lt;String, String&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pdfUrl: String) : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { openPdfAction(pdfUrl to pdfUrl.substringAfterLast(FILE_NAME_DELIMITER)) } } }</code> </pre> <br><p>  O c√≥digo do ActionCreator tamb√©m √© o mais simples poss√≠vel, aqui apenas realizamos algumas manipula√ß√µes de string. </p><br><p>  Vamos voltar ao componente e considerar o seguinte ActionCreator: </p><br><pre> <code class="kotlin hljs">setVersionName.toSimpleActionCreator(moreComponent::currentVersionName)</code> </pre> <br><p>  Certa vez, ficamos com pregui√ßa de escrever os mesmos e inerentemente simples ActionCreators.  Usamos o poder de Kotlin e escrevemos extension'y.  Por exemplo, neste caso, n√≥s apenas precisamos passar uma sequ√™ncia est√°tica para o ActionMapper. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function"> ActionMapper</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toSimpleActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( mapper: ()</span></span></span></span> -&gt; R): ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionCreator&lt;Observable&lt;*&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Observable</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;*&gt;)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toSimpleActionCreator</span></span>(mapper()) } } } }</code> </pre> <br><p>  H√° momentos em que n√£o precisamos transmitir nada, mas apenas chamamos A√ß√£o - por exemplo, para abrir a seguinte tela: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Action.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toActionCreator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ActionOnEvent { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EventObservable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> event.map { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@toActionCreator</span></span> } } } }</code> </pre> <br><p>  Ent√£o, com o componente terminado, volte ao fragmento: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> events = AboutEventsImpl( bindEvent = bindEvent, openPolicyPrivacyEvent = confidentialityPolicy.throttleFirstClicks(), openProcessingPersDataEvent = personalDataProtection.throttleFirstClicks(), unbindEvent = unBindEvent)</code> </pre> <br><p>  Aqui vemos a cria√ß√£o de uma classe respons√°vel por receber eventos do usu√°rio.  Desvincular e vincular s√£o apenas eventos de ciclo de vida da tela que captamos usando a biblioteca Navi do Trello. </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;T&gt; NaviComponent.observe(event: Event&lt;T&gt;): Observable&lt;T&gt; = RxNavi.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this, event)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unBindEvent: Observable&lt;*&gt; = observe(Event.DESTROY_VIEW) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: Observable&lt;*&gt; = Observable.just(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)  <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent = observe(Event.POST_CREATE)</code> </pre> <br><p>  A interface Events descreve os eventos de uma tela espec√≠fica, al√©m de herdar BaseEvents.  A seguir, √© sempre uma implementa√ß√£o da interface.  Nesse caso, os eventos acabaram sendo um com os que v√™m da tela, mas acontece que voc√™ precisa manter dois eventos juntos. </p><br><p>  Por exemplo, eventos de carregamento da tela ao abrir e recarregar em caso de erro devem ser combinados em um - basta carregar a tela. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AboutEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseEvents { val bindEvent: EventObservable val openPolicyPrivacyEvent: EventObservable val openProcessingPersDataEvent: EventObservable } class AboutEventsImpl</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openPolicyPrivacyEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openProcessingPersDataEvent: EventObservable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unbindEvent: EventObservable) : AboutEvents</code> </pre> <br><p>  Voltamos ao fragmento e combinamos tudo!  Pedimos ao componente que crie e devolva o fich√°rio para n√≥s e, em seguida, chamamos o m√©todo bind, onde passamos o objeto que observa os eventos da tela. </p><br><pre> <code class="kotlin hljs">component.binder().bind(events)</code> </pre> <br><p>  Estamos escrevendo um projeto nessa arquitetura h√° cerca de dois anos.  E n√£o h√° limite para a felicidade dos gerentes na velocidade do compartilhamento de recursos!  Eles n√£o t√™m tempo para criar um novo, pois j√° estamos terminando o antigo.  A arquitetura √© muito flex√≠vel e permite reutilizar muito c√≥digo. <br>  A desvantagem dessa arquitetura pode ser chamada de n√£o conserva√ß√£o de estado.  N√£o temos um modelo inteiro que descreva o estado da tela, como no MVI, mas podemos lidar com isso.  Como - veja abaixo. </p><br><h2 id="glava-4-bonus">  <strong>Cap√≠tulo 4. B√¥nus</strong> </h2><br><p>  Acho que todo mundo conhece o problema da an√°lise: ningu√©m gosta de escrev√™-lo, porque ele percorre todas as camadas e desfigura os desafios.  Algum tempo atr√°s, e tivemos que enfrent√°-lo.  Mas, gra√ßas √† nossa arquitetura, uma implementa√ß√£o muito bonita foi obtida. </p><br><p>  Ent√£o, qual foi a minha ideia: a an√°lise geralmente sai em resposta √†s a√ß√µes do usu√°rio.  E n√≥s apenas temos uma classe que acumula a√ß√µes do usu√°rio.  Ok, vamos come√ßar. </p><br><p>  <strong>Etapa 1</strong>  Alteramos ligeiramente a classe base BaseEventsBinder agrupando eventos em trackAnalytics: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEventsBinder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">in EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> trackAnalytics: TrackAnalytics&lt;EVENTS&gt; = EmptyAnalyticsTracker(), <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uiScheduler: Scheduler = AndroidSchedulers.mainThread()) { <span class="hljs-meta"><span class="hljs-meta">@SuppressLint(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CheckResult"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { bindInternal(trackAnalytics(events)).observeOn(uiScheduler) .takeUntil(events.unbindEvent) .subscribe(Action::invoke) } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Observable&lt;Action&gt; }</code> </pre><br><p>  <strong>Etapa 2</strong>  Criamos uma implementa√ß√£o est√°vel da vari√°vel trackAnalytics para manter a compatibilidade com vers√µes anteriores e n√£o prejudicar os herdeiros que ainda n√£o precisam de an√°lises: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyAnalyticsTracker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS : BaseEvents</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EVENTS</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EVENTS</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: EVENTS = events }</code> </pre> <br><p>  <strong>Etapa 3</strong>  Escrevemos a implementa√ß√£o da interface TrackAnalytics para a tela desejada - por exemplo, para a tela da lista de projetos: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrackProjectsEvents</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TrackAnalytics</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ProjectsEvents</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(events: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ProjectsEvents</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: ProjectsEvents { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ProjectsEvents <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> events { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boardClickEvent = events.boardClickEvent.trackTypedEvent { allProjectsProjectClick(it.title) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoardCreationEvent = events.openBoardCreationEvent.trackEvent { allProjectsAddProjectClick() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardsSearchEvent = events.openCardsSearchEvent.trackEvent { allProjectsSearchBarClick() } } } }</code> </pre> <br><p>  Aqui novamente usamos o poder de Kotlin na forma de delegados.  J√° temos um herdador de interface criado por n√≥s - nesse caso, ProjectsEvents.  Mas, para alguns eventos, voc√™ precisa redefinir como os eventos ocorrem e adicionar uma liga√ß√£o em torno deles com o envio de an√°lises.  De fato, trackEvent √© apenas doOnNext: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec) } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Observable</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackTypedEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">AnalyticsSpec</span></span></span></span><span class="hljs-function"><span class="hljs-params">.(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): Observable&lt;T&gt; = doOnNext { event(analyticsSpec, it) }</code> </pre> <br><p>  <strong>Etapa 4</strong>  Resta transferir isso para o Binder.  Como a constru√≠mos em um componente, temos a oportunidade, se voc√™ precisar de repente, de adicionar depend√™ncias adicionais ao construtor.  Agora o construtor ProjectsEventsBinder ter√° a seguinte apar√™ncia: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectsEventsBinder</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loadItems: LoadItemsActionCreator, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshBoards: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openBoard: ActionCreator&lt;Observable&lt;BoardId&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openScreen: ActionOnEvent, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> openCardSearch: ActionOnEvent, trackAnalytics: TrackAnalytics&lt;ProjectsEvents&gt;) : BaseEventsBinder&lt;ProjectsEvents&gt;(trackAnalytics)</code> </pre> <br><p>  Voc√™ pode ver outros exemplos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>GitHub</strong></a> . </p><br><h2 id="voprosy-i-otvety">  <strong>Perguntas e Respostas</strong> </h2><br><div class="spoiler">  <b class="spoiler_title">Como voc√™ mant√©m o estado da tela?</b> <div class="spoiler_text"><p>  De jeito nenhum.  Bloqueamos a orienta√ß√£o.  Mas tamb√©m usamos argumentos / inten√ß√£o e salvamos a vari√°vel OPENED_FROM_BACKSTACK l√°.  E ao projetar o Binder, olhamos para ele.  Se for falso - carregue dados da rede.  Se verdadeiro - a partir do cache.  Isso permite que voc√™ recrie rapidamente a tela. </p><br><p>  Para todos que s√£o contra o bloqueio de orienta√ß√£o: tente testar e depositar an√°lises sobre a frequ√™ncia com que os usu√°rios viram o telefone e quantas est√£o em uma orienta√ß√£o diferente.  Os resultados podem surpreender. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">N√£o quero escrever componentes, como posso fazer amizade com a adaga?</b> <div class="spoiler_text"><p>  Eu n√£o aconselho, mas se voc√™ n√£o se importa com o tempo de compila√ß√£o, tamb√©m pode criar o Component atrav√©s de um punhal.  Mas n√≥s n√£o tentamos. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Eu n√£o escrevo no kotlin, quais s√£o as dificuldades com a implementa√ß√£o em Java?</b> <div class="spoiler_text"><p>  Tudo o mesmo pode ser escrito em Java, mas n√£o ficar√° t√£o bonito. </p></div></div><br><p>  Se voc√™ gostou do artigo, a pr√≥xima parte ser√° sobre como escrever testes em uma arquitetura (ent√£o ficar√° claro por que existem tantas interfaces).  Spoiler - a grava√ß√£o √© f√°cil e voc√™ pode escrever em todas as camadas, exceto no componente, mas n√£o precisa test√°-lo, apenas cria um objeto fich√°rio. </p><br><p>  Agradecemos aos colegas da equipe de desenvolvimento m√≥vel da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tinkoff Business</a> por ajudarem a escrever este artigo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474612/">https://habr.com/ru/post/pt474612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474596/index.html">Aplicativo no TSD e comunica√ß√£o com 1C: Enterprise 8.3 atrav√©s do servi√ßo HTTP. Parte 5 (Menu, objeto complementar)</a></li>
<li><a href="../pt474598/index.html">Como obter uma entrevista com um engenheiro de controle de qualidade sem experi√™ncia profissional</a></li>
<li><a href="../pt474602/index.html">Resolva a equa√ß√£o de regress√£o linear simples</a></li>
<li><a href="../pt474606/index.html">Como funciona o Blogspam</a></li>
<li><a href="../pt474610/index.html">Sistema de m√≠dia baseado em NUC - Experi√™ncia dom√©stica</a></li>
<li><a href="../pt474618/index.html">Criando um configurador 3D para WooCommerce</a></li>
<li><a href="../pt474620/index.html">Seguran√ßa da informa√ß√£o do data center</a></li>
<li><a href="../pt474622/index.html">34 bibliotecas Python de c√≥digo aberto (2019)</a></li>
<li><a href="../pt474626/index.html">Terminologia do Google Analytics e Yandex.Metrica: como n√£o se confundir com todos esses dados</a></li>
<li><a href="../pt474628/index.html">Apresentando o novo Microsoft Edge e Bing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>