<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç± ü§æüèø ‚ôìÔ∏è Eclair - Deklarative Java Spring-Protokollierungsbibliothek üëèüèª üîØ üíÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt viele Fragen zur Arbeit von Diensten in den Phasen Entwicklung, Test und Support, und alle sind auf den ersten Blick anders als: "Was ist pass...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eclair - Deklarative Java Spring-Protokollierungsbibliothek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/412871/"><img src="https://habrastorage.org/webt/c5/hp/zh/c5hpzhb2lfd56lwayott-mqlusi.jpeg"><br><br>  Es gibt viele Fragen zur Arbeit von Diensten in den Phasen Entwicklung, Test und Support, und alle sind auf den ersten Blick anders als: <i>"Was ist passiert?"</i>  <i>"Gab es eine Anfrage?"</i>  , <i>"Was ist das Datumsformat?"</i>  , <i>"Warum reagiert der Dienst nicht?"</i>  usw. <br><br>  Ein korrekt zusammengestelltes Protokoll kann diese und viele andere Fragen ohne Beteiligung der Entwickler absolut autonom im Detail beantworten.  Um dieses verlockende Ziel zu erreichen, wurde die Eclair-Protokollbibliothek ins Leben gerufen, die darauf ausgelegt ist, mit allen Teilnehmern des Prozesses in einen Dialog zu treten, ohne zu viele Decken zu ziehen. <br><br>  √úber die Decke und die Funktionen der L√∂sung - unten. <br><a name="habracut"></a><br><h2>  Was ist das Problem der Protokollierung </h2><br><blockquote>  Wenn Sie nicht sehr daran interessiert sind, die R√§umlichkeiten zu verstehen, k√∂nnen Sie sofort mit der Beschreibung unserer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">L√∂sung</a> fortfahren. </blockquote><br><ul><li>  Das Anwendungsprotokoll ist sein Alibi. <br>  Meistens kann nur er den Erfolg der Bewerbung nachweisen.  In einem Mikrodienst gibt es keinen Zustand, benachbarte Systeme sind mobil und pingelig.  "Wiederholen", "neu erstellen", "√ºberpr√ºfen" - all dies ist schwierig und / oder unm√∂glich.  Das Protokoll sollte informativ genug sein, um die Frage <i>‚ÄûWas ist passiert?‚Äú</i> Zu beantworten <i>.</i>  .  Das Protokoll sollte f√ºr alle klar sein: f√ºr den Entwickler, den Tester, manchmal f√ºr den Analysten, manchmal f√ºr den Administrator, manchmal f√ºr die erste Supportlinie - alles passiert. </li><li>  Bei Microservices geht es um Multithreading. <br>  An den Dienst kommende Anforderungen (oder vom Dienst angeforderte Daten) werden meistens von mehreren Threads verarbeitet.  Das Protokoll aller Threads wird normalerweise gemischt.  M√∂chten Sie zwischen parallelen Threads und zwischen "sequentiellen" Threads unterscheiden?  Derselbe Stream wird f√ºr die sequentielle Verarbeitung von Anforderungen wiederverwendet, wobei immer wieder eine eigene Logik f√ºr verschiedene Datens√§tze ausgef√ºhrt wird.  Diese "sequentiellen" Fl√ºsse flie√üen aus einer anderen Ebene, aber ihre Grenzen sollten dem Leser klar sein. </li><li>  Das Protokoll sollte das urspr√ºngliche Datenformat speichern. <br>  Wenn in Wirklichkeit Dienste √ºber XML ausgetauscht werden, sollte das entsprechende Protokoll XML speichern.  Es ist nicht immer kompakt und nicht immer sch√∂n (aber praktisch).  Es ist einfacher, den Erfolg zu erkennen und Fehler zu analysieren.  In einigen F√§llen kann das Protokoll verwendet werden, um die Anforderung manuell abzuspielen oder erneut zu verarbeiten. </li><li>  Ein Teil der Daten im Protokoll erfordert eine spezielle Beziehung. <br>  Eingehende Daten (Anforderungen), ausgehende Daten (Antworten), Anforderungen an Systeme von Drittanbietern und Antworten von diesen m√ºssen h√§ufig separat gespeichert werden.  Sie unterliegen besonderen Anforderungen: Haltbarkeit oder Zuverl√§ssigkeit.  Dar√ºber hinaus k√∂nnen diese Daten im Vergleich zu einer typischen Protokollzeile eine beeindruckende Menge aufweisen. </li><li>  Ein Teil der Daten ist nicht f√ºr das Protokoll. <br>  Folgendes sollte normalerweise aus dem regul√§ren Protokoll ausgeschlossen werden: Bin√§rdaten (Byte-Arrays, base64, ..), personenbezogene Daten von Kunden / Partnern / anderen Personen und juristischen Personen.  Es ist immer eine individuelle Geschichte, aber systematisch und eignet sich nicht f√ºr die manuelle Steuerung. </li></ul><br><h2>  Warum nicht H√§nde </h2><br>  Nehmen Sie <code>org.slf4j.Logger</code> ( <code>org.slf4j.Logger</code> mit Appenders eines beliebigen Anzugs) und schreiben Sie alles, was erforderlich ist, in das Log.  Eing√§nge zu den Hauptmethoden, Exits spiegeln bei Bedarf abgefangene Fehler, einige Daten wider.  Ist das notwendig?  Ja, aber: <br><br><ul><li>  Die Menge an Code w√§chst unangemessen (ungew√∂hnlich).  Dies ist zun√§chst nicht sehr auff√§llig, wenn Sie nur die grundlegendsten protokollieren (erfolgreiche Unterst√ºtzung √ºbrigens mit diesem Ansatz). </li><li>  Das Anrufen des Loggers mit den H√§nden wird schnell zu Faulheit.  Das Deklarieren eines <code>static</code> Feldes mit einem Logger ist zu faul (nun, Lombok kann dies f√ºr uns tun).  Wir Entwickler sind faul.  Und wir h√∂ren auf unsere Faulheit, das ist edle Faulheit: Sie ver√§ndert die Welt beharrlich zum Besseren. </li><li>  Microservices sind nicht auf allen Seiten gut.  Ja, sie sind klein und h√ºbsch, aber es gibt eine Kehrseite: Es gibt viele!  Eine einzelne Anwendung von Anfang bis Ende wird h√§ufig von einem Entwickler geschrieben.  Das Erbe taucht nicht vor seinen Augen auf.  Gl√ºcklich, nicht mit auferlegten Regeln belastet, sieht der Entwickler es als Pflicht an, sein eigenes Protokollformat, sein Prinzip und seine eigenen Regeln zu erfinden.  Dann setzt die Erfindung brillant um.  Jede Klasse ist anders.  Das ist ein Problem?  Kolossal. </li><li>  Durch Refactoring wird Ihr Protokoll besch√§digt.  Selbst die allm√§chtige Idee wird ihn nicht retten.  Das Aktualisieren des Protokolls ist ebenso unm√∂glich wie das Aktualisieren des Javadoc.  Gleichzeitig wird zumindest Javadoc nur von Entwicklern gelesen (nein, niemand liest), aber die Zielgruppe der Protokolle ist viel breiter und das Entwicklungsteam ist nicht begrenzt. </li><li>  MDC (Mapped Diagnostic Context) ist ein integraler Bestandteil einer Multithread-Anwendung.  Das manuelle Bef√ºllen des MDC erfordert eine rechtzeitige Reinigung am Ende der Arbeit im Stream.  Andernfalls besteht die Gefahr, dass Sie einen <code>ThreadLocal</code> an nicht verwandte Daten binden.  H√§nde und Augen, um dies zu kontrollieren, ist unm√∂glich zu sagen. </li></ul><br>  Und so l√∂sen wir diese Probleme in unseren Anwendungen. <br><a name="eclair-decision"></a><br><h2>  Was ist Eclair und was kann es? </h2><br>  Eclair ist ein Tool, das das Schreiben von protokolliertem Code vereinfacht.  Es ist hilfreich, die erforderlichen Metainformationen zum Quellcode zu sammeln, sie zur Laufzeit mit den in der Anwendung fliegenden Daten zu verkn√ºpfen und an das √ºbliche Protokollrepository zu senden, w√§hrend ein Minimum an Code generiert wird. <br><br>  Das Hauptziel ist es, das Protokoll f√ºr alle Teilnehmer am Entwicklungsprozess verst√§ndlich zu machen.  Daher endet die Bequemlichkeit des Schreibens von Code und die Vorteile von Eclair nicht, sondern beginnen erst. <br><br>  Eclair protokolliert kommentierte Methoden und Parameter: <br><br><ul><li>  Protokolliert den Methodenein- / -ausgang aus der von der Methode zur√ºckgegebenen Methode / Ausnahmen / Argumente / Werte </li><li>  filtert Ausnahmen, um sie spezifisch nach Typen zu protokollieren: <i>nur bei Bedarf</i> </li><li>  Variiert das "Detail" des Protokolls basierend auf den Anwendungseinstellungen f√ºr den aktuellen Speicherort: Im <i>detailliertesten Fall werden beispielsweise die Werte der Argumente (alle oder einige) in der k√ºrzesten Version gedruckt - nur die Tatsache, dass die Methode eingegeben wurde</i> </li><li>  druckt Daten als JSON / XML / in einem anderen Format (sofort einsatzbereit f√ºr Jackson, JAXB): <i>versteht, welches Format f√ºr einen bestimmten Parameter am besten geeignet ist</i> </li><li>  versteht SpEL (Spring Expression Language) f√ºr die deklarative Installation und die automatische MDC-Reinigung </li><li>  schreibt in N Logger, der "Logger" im Verst√§ndnis von Eclair ist eine Bean in dem Kontext, der die <code>EclairLogger</code> Schnittstelle implementiert: Sie k√∂nnen <i>den Logger angeben, der die Annotation nach Namen, Alias ‚Äã‚Äãoder Standard verarbeiten soll</i> </li><li>  informiert den Programmierer √ºber einige Fehler bei der Verwendung von Anmerkungen: <i>Eclair wei√ü beispielsweise, dass es auf dynamischen Proxys (mit allen zugeh√∂rigen Funktionen) funktioniert, sodass es Ihnen mitteilen kann, dass die Anmerkung auf der <code>private</code> Methode niemals funktioniert</i> </li><li>  Akzeptiert Meta-Annotationen (wie Spring sie nennt): <i>Sie k√∂nnen Ihre Annotationen f√ºr die Protokollierung mithilfe einiger grundlegender Annotationen definieren, um den Code zu reduzieren</i> </li><li>  In der Lage, "sensible" Daten beim Drucken zu maskieren: <i>sofort einsatzbereites XPath-Shielding-XML</i> </li><li>  schreibt ein Protokoll im "manuellen" Modus, definiert den Aufrufer und "erweitert" die Argumente, die den <code>Supplier</code> implementieren: <i>Geben Sie die M√∂glichkeit, die Argumente "tr√§ge" zu initialisieren.</i> </li></ul><br><h2>  So verbinden Sie Eclair </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Quellcode wird auf GitHub</a> unter der Apache 2.0-Lizenz ver√∂ffentlicht. <br><br>  Zum Herstellen einer Verbindung ben√∂tigen Sie Java 8, Maven und Spring Boot 1.5+.  Vom Maven Central Repository gehostetes Artefakt: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>ru.tinkoff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>eclair-spring-boot-starter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>0.8.3<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Der Starter enth√§lt eine Standardimplementierung von <code>EclairLogger</code> , die ein von Spring Boot initialisiertes Protokollierungssystem mit einigen √ºberpr√ºften Einstellungen verwendet. <br><br><h2>  Beispiele </h2><br>  Hier einige Beispiele f√ºr die typische Bibliotheksnutzung.  Zuerst wird ein Codefragment angegeben, dann das entsprechende Protokoll, abh√§ngig von der Verf√ºgbarkeit einer bestimmten Protokollierungsstufe.  Eine vollst√§ndigere Reihe von Beispielen finden Sie im Projekt-Wiki im Abschnitt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele</a> . <br><br><h3>  Einfachstes Beispiel </h3><br>  Die Standardstufe ist DEBUG. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><table><tbody><tr><th>  Wenn Level verf√ºgbar ist </th><th>  ... dann wird das Protokoll so sein </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>DEBUG [] rteeExample.simple &gt; <br> DEBUG [] rteeExample.simple &lt;</code> </td> </tr><tr><td> <code>INFO <br> WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Die Protokolldetails h√§ngen von der verf√ºgbaren Protokollierungsstufe ab. </h3><br>  Die am aktuellen Speicherort verf√ºgbare Protokollierungsstufe wirkt sich auf die Protokolldetails aus.  Je niedriger die verf√ºgbare Ebene (dh je n√§her an TRACE), desto detaillierter ist das Protokoll. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>(INFO) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verbose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s, Integer i, Double d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><table><tbody><tr><th>  Level </th><th>  Protokoll </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>INFO [] rteeExample.verbose &gt; s="s", i=4, d=5.6 <br> INFO [] rteeExample.verbose &lt; false</code> </td> </tr><tr><td> <code>INFO</code> </td> <td> <code>INFO [] rteeExample.verbose &gt; <br> INFO [] rteeExample.verbose &lt;</code> </td> </tr><tr><td> <code>WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Feinabstimmung der Ausnahmeprotokollierung </h3><br>  Arten von protokollierten Ausnahmen k√∂nnen gefiltert werden.  Ausgew√§hlte Ausnahmen und deren Nachkommen werden verpf√§ndet.  In diesem Beispiel wird <code>NullPointerException</code> auf der WARN-Ebene, <code>Exception</code> auf der ERROR-Ebene (standardm√§√üig) und <code>Error</code> nicht protokolliert (da <code>Error</code> nicht im Filter der ersten Annotation <code>@Log.error</code> und explizit vom Filter der zweiten Annotation ausgeschlossen wird). <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.error(level = WARN, ofType = {NullPointerException.class, IndexOutOfBoundsException.class}) <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.error(exclude = Error.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable throwable)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> throwable; } <span class="hljs-comment"><span class="hljs-comment">//       filterErrors(new NullPointerException()); filterErrors(new Exception()); filterErrors(new Error());</span></span></code> </pre><table><tbody><tr><th>  Level </th><th>  Protokoll </th></tr><tr><td> <code>TRACE <br> DEBUG <br> INFO <br> WARN</code> </td> <td> <code>WARN  [] rteeExample.filterErrors ! java.lang.NullPointerException <br> java.lang.NullPointerException: null <br> at rteeExampleTest.filterErrors(ExampleTest.java:0) <br> .. <br> ERROR [] rteeExample.filterErrors ! java.lang.Exception <br> java.lang.Exception: null <br> at rteeExampleTest.filterErrors(ExampleTest.java:0) <br> .. <br></code> </td></tr><tr><td> <code>ERROR</code> </td> <td> <code>ERROR [] rteeExample.filterErrors ! java.lang.Exception <br> java.lang.Exception: null <br> at rteeExampleTest.filterErrors(ExampleTest.java:0) <br> ..</code> </td> </tr></tbody></table><h3>  Stellen Sie jeden Parameter separat ein </h3><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.in(INFO) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parameterLevels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Log(INFO)</span></span></span><span class="hljs-function"> Double d, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DEBUG)</span></span></span><span class="hljs-function"> String s, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TRACE)</span></span></span><span class="hljs-function"> Integer i) </span></span>{ }</code> </pre><table><tbody><tr><th>  Level </th><th>  Protokoll </th></tr><tr><td> <code>TRACE</code> </td> <td> <code>INFO [] rteeExample.parameterLevels &gt; d=9.4, s="v", i=7</code> </td> </tr><tr><td> <code>DEBUG</code> </td> <td> <code>INFO [] rteeExample.parameterLevels &gt; d=9.4, s="v"</code> </td> </tr><tr><td> <code>INFO</code> </td> <td> <code>INFO [] rteeExample.parameterLevels &gt; 9.4</code> </td> </tr><tr><td> <code>WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Druckformat ausw√§hlen und anpassen </h3><br>  Die f√ºr das Druckformat verantwortlichen ‚ÄûDrucker‚Äú k√∂nnen von Vor- und Nachbearbeitern konfiguriert werden.  Im obigen Beispiel ist <code>maskJaxb2Printer</code> konfiguriert, dass Elemente, die dem XPath-Ausdruck <code>"//s"</code> entsprechen, mit <code>"********"</code> maskiert werden.  Gleichzeitig druckt <code>Dto</code> "wie es ist". <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.out(printer = <span class="hljs-string"><span class="hljs-string">"maskJaxb2Printer"</span></span>) <span class="hljs-function"><span class="hljs-function">Dto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Log(printer = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"maskJaxb2Printer"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Dto xml, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(printer = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"jacksonPrinter"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Dto json, Integer i) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xml; }</code> </pre><table><tbody><tr><th>  Level </th><th>  Protokoll </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>DEBUG [] rteeExample.printers &gt; <br> xml=&lt;dto&gt;&lt;i&gt;5&lt;/i&gt;&lt;s&gt;********&lt;/s&gt;&lt;/dto&gt;, json={"i":5,"s":"password"} <br> DEBUG [] rteeExample.printers &lt; <br> &lt;dto&gt;&lt;i&gt;5&lt;/i&gt;&lt;s&gt;********&lt;/s&gt;&lt;/dto&gt;</code> </td> </tr><tr><td> <code>INFO <br> WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h3>  Mehrere Logger im Kontext </h3><br>  Die Methode wird mit mehreren Loggern gleichzeitig protokolliert: Standardm√§√üig Logger (mit <code>@Primary</code> kommentiert) und auditLogger <code>auditLogger</code> .  Sie k√∂nnen mehrere Protokollierer definieren, wenn Sie protokollierte Ereignisse nicht nur nach Ebenen (TRACE - ERROR) trennen, sondern auch an verschiedene Speicher senden m√∂chten.  Beispielsweise kann der <code>auditLogger</code> mit slf4j ein Protokoll in eine Datei auf der Festplatte schreiben, und <code>auditLogger</code> kann ein spezielles Daten-Slice in seinem eigenen Format in einen ausgezeichneten Speicher (z. B. in Kafka) schreiben. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>(logger = <span class="hljs-string"><span class="hljs-string">"auditLogger"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">twoLoggers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><h3>  MDC-Verwaltung </h3><br>  Mit Annotation festgelegte MDCs werden nach dem Beenden der annotierten Methode automatisch gel√∂scht.  Ein MDC-Datensatzwert kann mithilfe von SpEL dynamisch berechnet werden.  Beispiele sind: eine statische Zeichenfolge, die von einer Konstanten wahrgenommen wird, die den Ausdruck <code>1 + 1</code> <code>jacksonPrinter</code> , die <code>jacksonPrinter</code> aufruft und die <code>static</code> Methode <code>randomUUID</code> . <br>  MDCs mit dem Attribut <code>global = true</code> werden nach dem Beenden der Methode nicht gel√∂scht: Wie Sie sehen, ist der einzige Datensatz, der bis zum Ende des Protokolls im MDC verbleibt, die <code>sum</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ self.mdc(); } <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"static"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"string"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"sum"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"1 + 1"</span></span>, global = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"beanReference"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"@jacksonPrinter.print(new ru.tinkoff.eclair.example.Dto())"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Mdc</span></span>(key = <span class="hljs-string"><span class="hljs-string">"staticMethod"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"T(java.util.UUID).randomUUID()"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mdc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ self.inner(); } <span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.<span class="hljs-function"><span class="hljs-function">in </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br>  Protokoll bei der Ausf√ºhrung des obigen Codes: <br> <code>DEBUG [] rteeExample.outer &gt; <br> DEBUG [beanReference={"i":0,"s":null}, sum=2, static=string, staticMethod=01234567-89ab-cdef-ghij-klmnopqrstuv] rteeExample.mdc &gt; <br> DEBUG [beanReference={"i":0,"s":null}, sum=2, static=string, staticMethod=01234567-89ab-cdef-ghij-klmnopqrstuv] rteeExample.inner &gt; <br> DEBUG [beanReference={"i":0,"s":null}, sum=2, static=string, staticMethod=01234567-89ab-cdef-ghij-klmnopqrstuv] rteeExample.mdc &lt; <br> DEBUG [sum=2] rteeExample.outer &lt;</code> <br> <br><h3>  Parameterbasierte MDC-Installation </h3><br>  Wenn Sie den MDC mithilfe der Anmerkung zum Parameter angeben, ist der mit Anmerkungen versehene Parameter als Stammobjekt des Auswertungskontexts verf√ºgbar.  Hier ist <code>"s"</code> ein Feld der Klasse <code>Dto</code> Typ <code>String</code> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Log</span></span>.<span class="hljs-function"><span class="hljs-function">in </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mdcByArgument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Mdc(key = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"dto"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"#this"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mdc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"length"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"s.length()"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Dto dto) </span></span>{ }</code> </pre><br>  Protokoll bei der Ausf√ºhrung des obigen Codes: <br> <code>DEBUG [length=8, dto=Dto{i=12, s='password'}] rteeExample.mdcByArgument &gt; dto=Dto{i=12, s='password'}</code> <br> <br><h3>  Manuelle Protokollierung </h3><br>  F√ºr die "manuelle" Protokollierung reicht es aus, die Implementierung von <code>ManualLogger</code> zu implementieren.  √úbergebene Argumente, die den Schnittstellenanbieter implementieren, werden nur bei Bedarf "erweitert". <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ManualLogger logger; <span class="hljs-meta"><span class="hljs-meta">@Log</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ logger.info(<span class="hljs-string"><span class="hljs-string">"Eager logging: {}"</span></span>, Math.PI); logger.debug(<span class="hljs-string"><span class="hljs-string">"Lazy logging: {}"</span></span>, (Supplier) () -&gt; Math.PI); }</code> </pre><table><tbody><tr><th>  Level </th><th>  Protokoll </th></tr><tr><td> <code>TRACE <br> DEBUG</code> </td> <td> <code>DEBUG [] rteeExample.manual &gt; <br> INFO  [] rteeExample.manual - Eager logging: 3.141592653589793 <br> DEBUG [] rteeExample.manual - Lazy logging: 3.141592653589793 <br> DEBUG [] rteeExample.manual &lt;</code> </td> </tr><tr><td> <code>INFO</code> </td> <td> <code>INFO [] rteeExample.manual - Eager logging: 3.141592653589793</code> </td> </tr><tr><td> <code>WARN <br> ERROR</code> </td> <td> <code>-</code> </td> </tr></tbody></table><h2>  Was macht Eclair nicht? </h2><br>  Eclair wei√ü nicht, wo Sie Ihre Protokolle wie lange und im Detail speichern werden.  Eclair wei√ü nicht, wie Sie Ihr Protokoll verwenden m√∂chten.  Eclair extrahiert sorgf√§ltig alle ben√∂tigten Informationen aus Ihrer Anwendung und leitet sie an den von Ihnen konfigurierten Speicher weiter. <br><br>  Eine Beispielkonfiguration von <code>EclairLogger</code> , die ein Protokoll an einen Logback-Logger mit einem bestimmten Appender weiterleitet: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EclairLogger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eclairLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LoggerFacadeFactory factory = loggerName -&gt; { ch.qos.logback.classic.LoggerContext context = (LoggerContext) LoggerFactory.getILoggerFactory(); ch.qos.logback.classic.Logger logger = context.getLogger(loggerName); <span class="hljs-comment"><span class="hljs-comment">// Appender&lt;ILoggingEvent&gt; appender = ? // logger.addAppender(appender); return new Slf4JLoggerFacade(logger); }; return new SimpleLogger(factory, LoggingSystem.get(SimpleLogger.class.getClassLoader())); }</span></span></code> </pre><br><h2>  Diese L√∂sung ist nicht jedermanns Sache. </h2><br>  Bevor Sie Eclair als Hauptwerkzeug f√ºr die Protokollierung verwenden, sollten Sie sich mit einer Reihe von Funktionen dieser L√∂sung vertraut machen.  Diese ‚ÄûFunktionen‚Äú sind darauf zur√ºckzuf√ºhren, dass Eclair auf dem Standard-Proxy-Mechanismus f√ºr Spring basiert. <br><br>  - Die Ausf√ºhrungsgeschwindigkeit des im n√§chsten Proxy eingeschlossenen Codes ist unbedeutend, sinkt jedoch.  F√ºr uns sind diese Verluste selten signifikant.  Wenn sich die Frage nach einer Verk√ºrzung der Vorlaufzeit stellt, gibt es viele effektive Optimierungsma√ünahmen.  Die Ablehnung eines praktischen informativen Protokolls kann als eine der Ma√ünahmen angesehen werden, jedoch nicht in erster Linie. <br><br>  - StackTrace "aufbl√§hen" etwas mehr.  Wenn Sie nicht an die langen StackTrace of Spring-Proxys gew√∂hnt sind, kann dies ein √Ñrgernis f√ºr Sie sein.  Aus einem ebenso offensichtlichen Grund wird das Debuggen von Proxy-Klassen schwierig sein. <br><br>  - <b>Nicht jede Klasse und nicht jede Methode kann als Proxy verwendet werden</b> : <code>private</code> Methoden k√∂nnen nicht als Proxy verwendet werden. Um eine Methodenkette in einer Bean zu protokollieren, die Sie selbst ben√∂tigen, k√∂nnen Sie nichts als Proxy verwenden, das keine Bean ist usw. <br><br><h2>  Am Ende </h2><br>  Es ist v√∂llig klar, dass dieses Tool wie jedes andere verwendet werden kann, um davon zu profitieren.  Und dieses Material beleuchtet nur oberfl√§chlich die Seite, auf der wir uns auf die Suche nach der perfekten L√∂sung gemacht haben. <br><br>  Kritik, Gedanken, Hinweise, Links - Ich begr√º√üe Ihre Teilnahme am Leben des Projekts sehr!  Ich w√ºrde mich freuen, wenn Sie Eclair f√ºr Ihre Projekte n√ºtzlich finden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412871/">https://habr.com/ru/post/de412871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412861/index.html">Erstellen einer Benutzerpfadzuordnung f√ºr Dummies</a></li>
<li><a href="../de412863/index.html">Dialogflower - Google Dialogflow f√ºr Yandex Alice</a></li>
<li><a href="../de412865/index.html">So schie√üen Sie eine Motion Eye-Kamera im Sony Xperia XZ2</a></li>
<li><a href="../de412867/index.html">Kompilieren der DOS-COM-Datei mit dem GCC-Compiler</a></li>
<li><a href="../de412869/index.html">Interview mit einem Experten f√ºr Tissue Engineering und regenerative Medizin, Professor Tal Tal Dvir</a></li>
<li><a href="../de412873/index.html">Festplatten, die durch den Ton gew√∂hnlicher Laptop-Lautsprecher beeintr√§chtigt werden</a></li>
<li><a href="../de412877/index.html">Ruthenium (Ru) - das vierte Element mit ferromagnetischen Eigenschaften bei Raumtemperatur</a></li>
<li><a href="../de412879/index.html">Problem Nr. 24: IT-Schulung - aktuelle Probleme und Herausforderungen f√ºhrender Unternehmen</a></li>
<li><a href="../de412881/index.html">Bj√∂rn Straustrup: Problem mit der Programmierung</a></li>
<li><a href="../de412885/index.html">Pathologische Wissenschaft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>