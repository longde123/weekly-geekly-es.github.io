<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙🏼 🙍🏻 👨🏼‍💼 Pembelajaran Mesin untuk berburu flat Anda. Bagian 1 🚜 👩🏻‍🤝‍👨🏼 🧜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernahkah Anda mencari flat? Apakah Anda ingin menambahkan beberapa pembelajaran mesin dan membuat proses lebih menarik? 



 Hari ini kami akan mempe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pembelajaran Mesin untuk berburu flat Anda. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468053/"><p>  Pernahkah Anda mencari flat?  Apakah Anda ingin menambahkan beberapa pembelajaran mesin dan membuat proses lebih menarik? </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/af/w7/7e/afw77esq32gd2e0admnmjfby4kk.png" alt="Apartemen di Yekaterinburg"></div><a name="habracut"></a><br><p>  Hari ini kami akan mempertimbangkan menerapkan Pembelajaran Mesin untuk menemukan flat yang optimal. </p><br><h2 id="introduction">  Pendahuluan </h2><br><p> Pertama-tama, saya ingin memperjelas momen ini dan menjelaskan apa arti "flat optimal".  Ini adalah flat dengan serangkaian karakteristik yang berbeda seperti "area", "distrik", "jumlah balkon" dan sebagainya.  Dan untuk fitur flat ini, kami mengharapkan harga tertentu.  Tampak seperti fungsi yang mengambil beberapa parameter dan mengembalikan angka.  Atau mungkin kotak hitam yang menyediakan sihir. </p><br><p>  Tapi ... ada "tapi" besar, kadang-kadang Anda dapat menghadapi flat yang terlalu mahal karena serangkaian alasan seperti posisi geografis yang baik.  Juga, ada distrik yang lebih bergengsi di pusat kota dan distrik di luar kota.  Atau ... kadang-kadang orang ingin menjual apartemen mereka karena mereka pindah ke titik lain di Bumi.  Dengan kata lain, ada banyak faktor yang dapat mempengaruhi harga.  Apakah itu terdengar familier? </p><br><h2 id="little-stepaside">  Sedikit minggir </h2><br><p>  Sebelum saya melanjutkan, izinkan saya membuat sedikit penyimpangan lirik. <br>  Saya tinggal di Yekaterinburg (kota antara Eropa dan Asia, salah satu kota yang pernah menyelenggarakan Kejuaraan Dunia Sepakbola pada 2018) selama 5 tahun. </p><br><p>  Saya jatuh cinta dengan hutan beton ini.  Dan saya benci kota itu untuk musim dingin dan transportasi umum.  Ini adalah kota yang berkembang dan setiap bulan ada ribuan dan ribuan flat untuk dijual. </p><br><p>  Ya, itu adalah kota yang penuh sesak dan tercemar.  Pada saat yang sama - ini adalah tempat yang baik untuk menganalisis pasar real estat.  Saya menerima banyak iklan flat, dari Internet.  Dan saya akan menggunakan informasi itu lebih jauh. </p><br><p>  Juga, saya mencoba memvisualisasikan berbagai tawaran di peta Yekaterinburg.  Ya, itu adalah gambar menarik dari habracut, itu dibuat di Kepler.gl </p><br><p><img src="https://habrastorage.org/webt/af/w7/7e/afw77esq32gd2e0admnmjfby4kk.png" alt="gambar"></p><br><p>  Ada lebih dari 2 ribu flat 1 kamar tidur yang telah dijual pada bulan Juli 2019 di Yekaterinburg.  Mereka memiliki harga yang berbeda, dari kurang dari satu juta hingga hampir 14 juta rubel. </p><br><p>  Poin-poin ini merujuk pada posisi geografis mereka.  Warna titik pada peta mewakili harga, semakin rendah harga mendekati warna biru, semakin tinggi harga mendekati merah.  Anda dapat menganggapnya sebagai analogi dengan warna dingin dan hangat, semakin hangat warna semakin besar harga. <br>  Tolong, ingatlah saat itu, semakin merah warnanya, semakin tinggi nilai sesuatu.  Gagasan yang sama berlaku untuk warna biru tetapi ke arah harga terendah. </p><br><p>  Sekarang Anda memiliki gambaran <em>umum</em> tentang gambar dan waktu untuk menganalisis akan datang. </p><br><h3 id="goal">  Tujuan </h3><br><p>  Apa yang saya inginkan ketika saya tinggal di Yekaterinburg?  Saya mencari flat yang cukup baik, atau jika kita berbicara tentang ML - saya ingin membangun model yang akan memberi saya rekomendasi tentang pembelian. </p><br><p>  Di satu sisi, jika flat terlalu mahal, model harus merekomendasikan menunggu penurunan harga dengan menunjukkan harga yang diharapkan untuk flat itu. <br>  Di sisi lain - jika harga cukup bagus, menurut keadaan pasar - mungkin saya harus mempertimbangkan tawaran itu. </p><br><p>  Tentu saja, tidak ada yang ideal dan saya siap menerima kesalahan dalam perhitungan.  Biasanya, untuk jenis tugas ini gunakan rata-rata kesalahan prediksi dan saya siap untuk kesalahan 10%.  Misalnya, jika Anda memiliki 2-3 juta rubel Rusia, Anda dapat mengabaikan kesalahan dalam 200-300 ribu, Anda dapat membelinya.  Seperti yang menurut saya. </p><br><h2 id="preparing">  Siapkan </h2><br><p>  Seperti yang saya sebutkan sebelumnya, ada banyak apartemen, mari kita lihat dari dekat. <br>  impor panda sebagai pd </p><br><pre><code class="python hljs">df = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'flats.csv'</span></span>) df.shape</code> </pre> <br><p><img src="https://habrastorage.org/webt/qx/_0/qg/qx_0qgrsiuprxgsbno2ccihjdia.png" alt="gambar"></p><br><p>  2310 flat selama satu bulan, kita bisa mengekstraksi sesuatu yang bermanfaat dari itu.  Bagaimana dengan gambaran umum data? </p><br><pre> <code class="python hljs">df.describe()</code> </pre> <br><p><img src="https://habrastorage.org/webt/is/pi/tj/ispitjyk3gpg-cbkhwfwnrayloa.png" alt="gambar"><br>  Tidak ada sesuatu yang luar biasa - bujur, lintang, harga flat (label " <em>biaya</em> "), dan sebagainya.  Ya, untuk saat itu saya menggunakan " <em>biaya</em> " alih-alih " <em>harga</em> ", saya harap itu tidak akan menyebabkan kesalahpahaman, harap menganggapnya sama. </p><br><h2 id="cleaning">  Membersihkan </h2><br><p>  Apakah setiap rekaman memiliki arti yang sama?  Beberapa dari mereka diwakili flat seperti bilik, Anda dapat bekerja di sana, tetapi Anda tidak ingin tinggal di sana.  Mereka adalah kamar sempit kecil, bukan flat nyata.  Biarkan menghapusnya. </p><br><pre> <code class="python hljs">df = df[df.total_area &gt;= <span class="hljs-number"><span class="hljs-number">20</span></span>]</code> </pre> <br><p>  Prediksi harga flat berasal dari masalah tertua di bidang ekonomi dan bidang terkait.  Tidak ada yang terkait dengan istilah "ML" dan orang-orang mencoba menebak harga berdasarkan meter persegi. <br>  Jadi, kita melihat kolom / label ini dan mencoba untuk mendapatkan distribusi mereka. </p><br><pre> <code class="python hljs">numerical_fields = [<span class="hljs-string"><span class="hljs-string">'total_area'</span></span>,<span class="hljs-string"><span class="hljs-string">'cost'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> col <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numerical_fields: mask = ~np.isnan(df[col]) sns.distplot(df[col][mask], color=<span class="hljs-string"><span class="hljs-string">"r"</span></span>,label=col) plot.show()</code> </pre> <br><p><img src="https://habrastorage.org/webt/w2/kj/eq/w2kjeqg-gr-qzcum6hcgqnoz6eo.png" alt="gambar"></p><br><p>  Yah ... tidak ada yang istimewa, sepertinya distribusi normal.  Mungkin kita perlu masuk lebih dalam? </p><br><pre> <code class="python hljs">sns.pairplot(df[numerical_fields])</code> </pre> <br><p><img src="https://habrastorage.org/webt/df/fw/lg/dffwlggd_vemlbfl96qdw-0h3fw.png" alt="gambar"></p><br><p>  Ups ... ada yang salah di sana.  Bersihkan pencilan di bidang ini dan coba menganalisis data kami lagi. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Remove outliers df = df[abs(df.total_area - df.total_area.mean()) &lt;= (3 * df.total_area.std())] df = df[abs(df.cost - df.cost.mean()) &lt;= (3 * df.cost.std())] #Redraw our data sns.pairplot(df[numerical_fields])</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/uu/zp/ok/uuzpokfgmae_4d2bxqvsmp53jns.png" alt="gambar"></p><br><p>  Pencilan telah hilang, dan sekarang terlihat lebih baik. </p><br><h2 id="transformation">  Transformasi </h2><br><p>  Label "tahun", yang menunjuk pada tahun konstruksi harus diubah menjadi sesuatu yang lebih informatif.  Biarlah itu usia bangunan, dengan kata lain berapa lama rumah tertentu. </p><br><pre> <code class="python hljs">df[<span class="hljs-string"><span class="hljs-string">'age'</span></span>] = <span class="hljs-number"><span class="hljs-number">2019</span></span> -df[<span class="hljs-string"><span class="hljs-string">'year'</span></span>]</code> </pre> <br><p>  Mari kita lihat hasilnya. </p><br><pre> <code class="python hljs">df.head()</code> </pre> <br><p><img src="https://habrastorage.org/webt/wq/j_/h-/wqj_h-w8jwshp3fi0ofyhhuanca.png" alt="gambar"></p><br><p>  Ada semua jenis data, kategorikal, nilai Nan, deskripsi teks dan beberapa informasi geografis (bujur dan lintang).  Mari kita kesampingkan yang terakhir karena pada tahap itu mereka tidak berguna.  Kami akan kembali kepada mereka nanti. </p><br><pre> <code class="python hljs">df.drop(columns=[<span class="hljs-string"><span class="hljs-string">"lon"</span></span>,<span class="hljs-string"><span class="hljs-string">"lat"</span></span>,<span class="hljs-string"><span class="hljs-string">"description"</span></span>],inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><h3 id="categorical-data">  Data kategorikal </h3><br><p>  Biasanya, untuk data kategorikal, orang menggunakan berbagai jenis pengkodean atau hal-hal seperti CatBoost yang memberikan peluang untuk bekerja dengannya seperti halnya dengan variabel numerik. <br>  Tapi, bisakah kita menggunakan sesuatu yang lebih logis dan lebih intuitif?  Sekaranglah waktunya untuk membuat data kita lebih mudah dipahami tanpa kehilangan arti dari data itu. </p><br><h3 id="districts">  Distrik </h3><br><p>  Ya, ada lebih dari dua puluh kabupaten yang memungkinkan, dapatkah kita menambahkan lebih dari 20 variabel tambahan dalam model kita?  Tentu saja, kita bisa, tetapi ... haruskah kita?  Kita adalah manusia dan kita dapat membandingkan berbagai hal, bukan? <br>  Pertama-tama - tidak setiap kabupaten setara dengan yang lain.  Di pusat kota harga untuk satu meter persegi lebih tinggi, jauh dari pusat kota - itu menjadi menurun.  Apakah ini terdengar logis?  Bisakah kita menggunakannya? <br>  Ya, pasti kami dapat mencocokkan kabupaten mana pun dengan koefisien tertentu dan kabupaten selanjutnya adalah flat yang lebih murah. </p><br><p>  Setelah mencocokkan kota dan menggunakan peta layanan web lain (ArcGIS Online) berubah dan memiliki tampilan yang sama <br><img src="https://habrastorage.org/webt/ji/a6/sw/jia6swan_kxipvxp4y2p1ycfqk4.png" alt="gambar"></p><br><p>  Saya menggunakan ide yang sama dengan visualisasi flat.  Distrik yang paling "bergengsi" dan "mahal" diwarnai merah dan paling tidak - biru.  Temperatur warna, apakah Anda ingat tentang itu? <br>  Juga, kita harus melakukan manipulasi atas kerangka data kita. </p><br><pre> <code class="python hljs">district_map = {<span class="hljs-string"><span class="hljs-string">'alpha'</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'beta'</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, ... <span class="hljs-string"><span class="hljs-string">'delta'</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>, ... <span class="hljs-string"><span class="hljs-string">'epsilon'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>} df.district = df.district.str.lower() df.replace({<span class="hljs-string"><span class="hljs-string">"district"</span></span>: district_map}, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Pendekatan yang sama akan digunakan untuk menggambarkan kualitas internal flat.  Terkadang butuh perbaikan, terkadang flat cukup baik dan siap untuk hidup.  Dan dalam kasus lain, Anda harus mengeluarkan uang tambahan untuk membuatnya terlihat lebih baik (untuk mengganti keran, untuk mengecat dinding).  Ada juga bisa menggunakan koefisien. </p><br><pre> <code class="python hljs">repair = {<span class="hljs-string"><span class="hljs-string">'A'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>: <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>: <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>: <span class="hljs-number"><span class="hljs-number">0.8</span></span>} df.repair.fillna(<span class="hljs-string"><span class="hljs-string">'D'</span></span>, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) df.replace({<span class="hljs-string"><span class="hljs-string">"repair"</span></span>: repair}, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Ngomong-ngomong, tentang dinding.  Tentu saja, itu juga mempengaruhi harga flat.  Material modern lebih baik daripada yang tua, bata lebih baik dari beton.  Dinding dari kayu adalah momen yang cukup kontroversial, mungkin itu adalah pilihan yang baik untuk pedesaan, tetapi tidak begitu baik untuk kehidupan kota. </p><br><p>  Kami menggunakan pendekatan yang sama seperti sebelumnya, ditambah membuat saran tentang baris yang tidak kami ketahui.  Ya, terkadang orang tidak memberikan semua informasi tentang flat mereka.  Selanjutnya berdasarkan sejarah kita bisa mencoba menebak tentang bahan dinding.  Dalam periode waktu tertentu (misalnya periode terkemuka Khrushchev) - kita tahu tentang bahan khas untuk bangunan. </p><br><pre> <code class="python hljs">walls_map = {<span class="hljs-string"><span class="hljs-string">'brick'</span></span>: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, ... <span class="hljs-string"><span class="hljs-string">'concrete'</span></span>: <span class="hljs-number"><span class="hljs-number">0.8</span></span>, <span class="hljs-string"><span class="hljs-string">'block'</span></span>: <span class="hljs-number"><span class="hljs-number">0.8</span></span>, ... <span class="hljs-string"><span class="hljs-string">'monolith'</span></span>: <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-string"><span class="hljs-string">'wood'</span></span>: <span class="hljs-number"><span class="hljs-number">0.4</span></span>} mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()][df.year &gt;= <span class="hljs-number"><span class="hljs-number">2010</span></span>].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'monolith'</span></span> mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()][df.year &gt;= <span class="hljs-number"><span class="hljs-number">2000</span></span>].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'concrete'</span></span> mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()][df.year &gt;= <span class="hljs-number"><span class="hljs-number">1990</span></span>].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'block'</span></span> mask = df[df[<span class="hljs-string"><span class="hljs-string">'walls'</span></span>].isna()].index df.loc[mask, <span class="hljs-string"><span class="hljs-string">'walls'</span></span>] = <span class="hljs-string"><span class="hljs-string">'block'</span></span> df.replace({<span class="hljs-string"><span class="hljs-string">"walls"</span></span>: walls_map}, inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) df.drop(columns=[<span class="hljs-string"><span class="hljs-string">'year'</span></span>],inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Juga, ada informasi tentang balkon.  Menurut pendapat saya yang sederhana - balkon adalah hal yang sangat berguna, jadi saya tidak bisa menahan diri untuk mempertimbangkannya. <br>  Sayangnya, ada beberapa nilai null.  Jika pembuat iklan memeriksa informasi tentang itu, kami akan mendapatkan informasi yang lebih realistis. <br>  Nah, jika tidak ada informasi itu berarti "tidak ada balkon". </p><br><pre> <code class="python hljs">df.balcony.fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>,inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Setelah itu, kami menjatuhkan kolom dengan informasi tentang tahun pembangunan (kami memiliki alternatif yang baik untuk itu).  Selain itu, kami menghapus kolom dengan informasi tentang jenis bangunan karena memiliki banyak nilai NaN dan saya belum menemukan peluang untuk mengisi celah ini.  Dan kita drop semua baris dengan NaN yang kita miliki. </p><br><pre> <code class="python hljs">df.drop(columns=[<span class="hljs-string"><span class="hljs-string">'type_house'</span></span>],inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) df = df.astype(np.float64) df.dropna(inplace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><h2 id="checking">  Memeriksa </h2><br><p>  Jadi ... kami menggunakan pendekatan yang tidak standar dan mengganti nilai kategorikal ke representasi numerik mereka.  Dan sekarang kami selesai dengan transformasi data kami. <br>  Sebagian dari data telah dihapus, tetapi secara umum, itu adalah dataset yang cukup bagus.  Mari kita lihat korelasi antara variabel independen. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_correlation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span> sns.set(style=<span class="hljs-string"><span class="hljs-string">"whitegrid"</span></span>) corr = df.corr() * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment"># Select upper triangle of correlation matrix mask = np.zeros_like(corr, dtype=np.bool) mask[np.triu_indices_from(mask)] = True # Set up the matplotlib figure f, ax = plt.subplots(figsize=(15, 11)) # Generate a custom diverging colormap cmap = sns.diverging_palette(220, 10) # Draw the heatmap with the mask and correct aspect ratio sns.heatmap(corr, mask=mask, cmap=cmap, center=0, linewidths=1, cbar_kws={"shrink": .7}, annot=True, fmt=".2f") plot.show() # df[columns] = scale(df[columns]) return df df1 = show_correlation(df.drop(columns=['cost']))</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/ht/dv/ir/htdvirxheiytace3nmaujf3wet8.png" alt="gambar"></p><br><p>  Erm ... itu menjadi sangat menarik. <br>  <strong>Korelasi positif</strong> <br>  <em>Total area - balkon</em> .  Kenapa tidak  Jika flat kami besar, akan ada balkon. <br>  <strong>Korelasi negatif</strong> <br>  <em>Total area - umur</em> .  Semakin baru flat, semakin besar area untuk hidup.  Terdengar logis, flat baru lebih luas daripada flat lama. <br>  <em>Umur - balkon</em> .  Semakin tua flat semakin sedikit balkon yang dimilikinya.  Tampak seperti korelasi melalui variabel lain.  Mungkin itu adalah segitiga Umur-Balkon-Area di mana satu variabel memiliki pengaruh implisit pada variabel lain.  Tunggu sebentar. <br>  <em>Umur - distrik.</em>  Flat yang lebih tua adalah probabilitas besar yang akan ditempatkan di distrik yang lebih bergengsi.  Mungkinkah itu terkait dengan harga yang lebih tinggi di dekat pusat? </p><br><p>  Juga, kita bisa melihat korelasi dengan variabel dependen </p><br><pre> <code class="python hljs">plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>)) corr = df.corr()*<span class="hljs-number"><span class="hljs-number">100.0</span></span> sns.heatmap(corr[[<span class="hljs-string"><span class="hljs-string">'cost'</span></span>]], cmap= sns.diverging_palette(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), center=<span class="hljs-number"><span class="hljs-number">0</span></span>, linewidths=<span class="hljs-number"><span class="hljs-number">1</span></span>, cbar_kws={<span class="hljs-string"><span class="hljs-string">"shrink"</span></span>: <span class="hljs-number"><span class="hljs-number">.7</span></span>}, annot=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, fmt=<span class="hljs-string"><span class="hljs-string">".2f"</span></span>)</code> </pre> <br><p><img src="https://habrastorage.org/webt/o7/ax/m1/o7axm1zph-x3eterypsfcod38zo.png" alt="gambar"></p><br><p>  Ini dia ... </p><br><p>  Korelasi yang sangat kuat antara bidang flat dan harga.  Jika Anda ingin memiliki tempat yang lebih besar untuk hidup maka akan membutuhkan lebih banyak uang. <br>  Ada korelasi negatif antara pasangan " <em>umur / biaya</em> " dan " <em>kabupaten / biaya</em> ".  Sebuah flat di rumah baru lebih murah dari yang lama.  Dan di pedesaan flat lebih murah. <br>  Bagaimanapun, itu tampak jelas dan dapat dimengerti, jadi saya memutuskan untuk menggunakannya. </p><br><h2 id="model">  Model </h2><br><p>  Untuk tugas-tugas yang terkait dengan harga flat prediksi biasanya, gunakan regresi linier.  Menurut korelasi signifikan dari tahap sebelumnya, kita bisa mencoba menggunakannya juga.  Ini adalah pekerja keras yang cocok untuk banyak tugas. <br>  Siapkan data kami untuk tindakan selanjutnya </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> train_test_split y = df.cost X = df.drop(columns=[<span class="hljs-string"><span class="hljs-string">'cost'</span></span>]) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number"><span class="hljs-number">0.2</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><p>  Kami juga membuat beberapa fungsi sederhana untuk prediksi dan evaluasi hasil.  Mari lakukan percobaan pertama kami untuk memperkirakan harga! </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, y_test, model)</span></span></span><span class="hljs-function">:</span></span> y = model.predict(X) score = round((r2_score(y_test, y) * <span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span>) print(<span class="hljs-string"><span class="hljs-string">f'Score on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{model.__class__.__name__}</span></span></span><span class="hljs-string"> is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{score}</span></span></span><span class="hljs-string">'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> score <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, y, regressor)</span></span></span><span class="hljs-function">:</span></span> model = regressor.fit(X, y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LinearRegression regressor = LinearRegression() model = train_model(X_train, y_train, regressor) predict(X_test, y_test, model)</code> </pre> <br><p><img src="https://habrastorage.org/webt/ak/v3/_a/akv3_antf7wwaxndcpjwx90rvju.png" alt="gambar"></p><br><p>  Yah ... akurasi 76,67%.  Apakah jumlahnya banyak atau tidak?  Menurut sudut pandang saya, itu tidak buruk.  Selain itu, ini adalah titik awal yang baik.  Tentu saja, itu tidak ideal, dan ada potensi untuk perbaikan. </p><br><p>  Pada saat yang sama - kami mencoba memprediksi hanya satu bagian dari data.  Bagaimana dengan menerapkan strategi yang sama untuk data lain?  Ya, waktu untuk validasi silang. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_cross_validation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, y, model)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> KFold, cross_val_score regressor_name = model.__class__.__name__ fold = KFold(n_splits=<span class="hljs-number"><span class="hljs-number">10</span></span>, shuffle=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">0</span></span>) scores_on_this_split = cross_val_score(estimator=model, X=X, y=y, cv=fold, scoring=<span class="hljs-string"><span class="hljs-string">'r2'</span></span>) scores_on_this_split = np.round(scores_on_this_split * <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) mean_accuracy = scores_on_this_split.mean() print(<span class="hljs-string"><span class="hljs-string">f'Crossvaladaion accuracy on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{model.__class__.__name__}</span></span></span><span class="hljs-string"> is </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{mean_accuracy}</span></span></span><span class="hljs-string">'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mean_accuracy do_cross_validation(X, y, model)</code> </pre> <br><p><img src="https://habrastorage.org/webt/yn/uf/3y/ynuf3yr9ew4kgjrvnb-nifevbnq.png" alt="gambar"></p><br><p>  Hasil validasi silang. Sekarang kita ambil hasil lain.  73 kurang dari 76. Tapi, itu juga kandidat yang baik sampai saat ketika kita akan memiliki yang lebih baik.  Juga, itu berarti bahwa regresi linier bekerja cukup stabil pada dataset kami. </p><br><p>  Dan sekarang adalah waktu untuk langkah terakhir. </p><br><p>  Kami akan melihat fitur terbaik dari regresi linier - <strong>interpretabilitas</strong> . <br>  Keluarga model ini, berlawanan dengan model yang lebih kompleks, memiliki kemampuan pemahaman yang lebih baik.  Hanya ada beberapa angka dengan koefisien dan Anda dapat memasukkan angka-angka Anda dalam persamaan, membuat matematika sederhana dan mendapatkan hasilnya. </p><br><p>  Mari kita coba menafsirkan model kita </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">estimate_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model)</span></span></span><span class="hljs-function">:</span></span> sns.set(style=<span class="hljs-string"><span class="hljs-string">"white"</span></span>, context=<span class="hljs-string"><span class="hljs-string">"talk"</span></span>) f, ax = plot.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, figsize=(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), sharex=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) sns.barplot(x=model.coef_, y=X.columns, palette=<span class="hljs-string"><span class="hljs-string">"vlag"</span></span>, ax=ax) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(model.coef_.astype(int)): ax.text(v + <span class="hljs-number"><span class="hljs-number">3</span></span>, i + <span class="hljs-number"><span class="hljs-number">.25</span></span>, str(v), color=<span class="hljs-string"><span class="hljs-string">'black'</span></span>) ax.set_title(<span class="hljs-string"><span class="hljs-string">f"Coefficients"</span></span>) estimate_model(regressor)</code> </pre> <br><p><img src="https://habrastorage.org/webt/1j/bc/_a/1jbc_apacascsr3cakmwz4qbnu8.png" alt="Koefisien model kami"></p><br><p>  Gambarnya terlihat cukup logis.  <em>Balkon / Dinding / Area / Perbaikan</em> memberikan kontribusi <strong>positif</strong> pada harga datar. <br>  Flat lebih lanjut adalah semakin besar <strong>kontribusi negatif</strong> .  Juga berlaku untuk usia.  Flat yang lebih tua adalah harga yang lebih rendah. </p><br><p>  Jadi, itu adalah perjalanan yang menakjubkan. <br>  Kami mulai dari awal, menggunakan pendekatan tidak tipikal untuk transformasi data berdasarkan sudut pandang manusia (angka bukan variabel dummy), memeriksa variabel dan hubungannya satu sama lain.  Setelah itu, kami membangun model sederhana kami, menggunakan validasi silang untuk menguji modelnya.  Dan sebagai ceri pada kue - melihat model internal, apa yang memberi kita kepercayaan diri tentang cara kita. </p><br><p>  Tapi!  Itu bukan menyelesaikan perjalanan kita tetapi hanya istirahat.  Kami akan mencoba mengubah model kami di masa depan dan mungkin (mungkin saja) itu meningkatkan akurasi prediksi. </p><br><p>  <strong>Terima kasih sudah membaca!</strong> </p><br><blockquote>  Bagian kedua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada di sana</a> <br></blockquote><p>  PS Sumber data dan Ipython-notebook terletak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sana</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468053/">https://habr.com/ru/post/id468053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468041/index.html">Pengumuman antarmuka web Kubernetes Web View (dan ikhtisar singkat tentang UI web lain untuk Kubernetes)</a></li>
<li><a href="../id468043/index.html">Cara membuat kit UI yang dijual. Tahapan mengembangkan sistem desain komersial</a></li>
<li><a href="../id468047/index.html">Bekerja dengan hierarki di lsFusion</a></li>
<li><a href="../id468049/index.html">Menggunakan werf untuk meluncurkan grafik Helm yang kompleks</a></li>
<li><a href="../id468051/index.html">VDS dengan Windows Server berlisensi untuk 100 rubel: mitos atau kenyataan?</a></li>
<li><a href="../id468057/index.html">Pengembangan OS seperti Unix - Multitasking dan panggilan sistem (7)</a></li>
<li><a href="../id468061/index.html">Cron di Linux: History, Usage, dan Device</a></li>
<li><a href="../id468063/index.html">Angulareact</a></li>
<li><a href="../id468065/index.html">Model manajemen produk mental untuk semua orang</a></li>
<li><a href="../id468067/index.html">Cara kerja penggabungan alfa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>