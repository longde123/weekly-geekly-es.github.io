<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎓 ⏹️ 🎸 Go pratique: conseils pour écrire des programmes pris en charge dans le monde réel 🏼 👰🏼 👎🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article se concentre sur les meilleures pratiques pour écrire du code Go. Il est composé dans le style de présentation, mais sans les diapositives...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Go pratique: conseils pour écrire des programmes pris en charge dans le monde réel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441842/">  Cet article se concentre sur les meilleures pratiques pour écrire du code Go.  Il est composé dans le style de présentation, mais sans les diapositives habituelles.  Nous allons essayer de parcourir brièvement et clairement chaque élément. <br><br>  Vous devez d'abord convenir de ce que signifient les <i>meilleures</i> pratiques pour un langage de programmation.  Ici, vous pouvez vous rappeler les mots de Russ Cox, directeur technique de Go: <br><br><blockquote>  Le génie logiciel est ce qui arrive à la programmation, si vous ajoutez le facteur temps et d'autres programmeurs. </blockquote><br>  Ainsi, Russ fait la distinction entre les concepts de <i>programmation</i> et <i>de génie logiciel</i> .  Dans le premier cas, vous écrivez un programme pour vous-même, dans le second, vous créez un produit sur lequel d'autres programmeurs travailleront au fil du temps.  Les ingénieurs vont et viennent.  Les équipes s'agrandissent ou se rétrécissent.  De nouvelles fonctionnalités sont ajoutées et des bugs sont corrigés.  Telle est la nature du développement logiciel. <br><a name="habracut"></a><br><a name="0"></a><h1>  Table des matières </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Table des matières</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Principes fondamentaux</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Simplicité</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lisibilité</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La productivité</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Identifiants</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Identificateurs de nom basés sur la clarté plutôt que sur la brièveté</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Longueur ID</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ne nommez pas les variables par type</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisez un seul style de dénomination</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisez un style de déclaration unique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailler pour l'équipe</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Commentaires</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les commentaires dans les variables et les constantes doivent décrire leur contenu, pas leur objectif</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentez toujours les caractères accessibles au public</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Structure du package</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un bon package commence par un bon nom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Évitez les noms comme base, commun ou util</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Revenez rapidement sans plonger profondément</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendre la valeur nulle utile</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Évitez l'état au niveau du package</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Structure du projet</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moins de paquets mais plus gros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le plus petit paquet principal</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Structure de l'API</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API de conception difficiles à abuser par conception</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Concevoir une API pour un cas d'utilisation de base</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Laissez les fonctions déterminer le comportement souhaité.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Gestion des erreurs</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Élimine le besoin de gestion des erreurs en supprimant les erreurs elles-mêmes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traiter l'erreur une seule fois</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Concurrence</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Faites du travail tout le temps.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Laisser le parallélisme à l'appelant</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ne courez jamais de goroutine sans savoir quand elle s'arrêtera</a> </li></ul></li></ul><br><a name="1"></a><h1>  1. Principes fondamentaux </h1><br>  Je suis peut-être l'un des premiers utilisateurs de Go parmi vous, mais ce n'est pas mon opinion personnelle.  Ces principes de base sous-tendent Go lui-même: <br><br><ol><li>  Simplicité </li><li>  Lisibilité </li><li>  La productivité </li></ol><br>  <i>Remarque</i>  <i>Veuillez noter que je n'ai pas mentionné «performance» ou «simultanéité».</i>  <i>Il existe des langues plus rapides que Go, mais elles ne peuvent certainement pas être comparées en termes de simplicité.</i>  <i>Il existe des langages qui placent le parallélisme au premier rang des priorités, mais ils ne peuvent être comparés en termes de lisibilité ou de productivité de programmation.</i> <i><br><br></i>  <i>Les performances et la simultanéité sont des attributs importants, mais pas aussi importants que la simplicité, la lisibilité et la productivité.</i> <br><br><a name="1_1"></a><h2>  Simplicité </h2><br><blockquote>  <i>«La simplicité est une condition préalable à la fiabilité»</i> - Edsger Dijkstra </blockquote><br>  Pourquoi viser la simplicité?  Pourquoi est-il important que les programmes Go soient simples? <br><br>  Chacun de nous est tombé sur un code incompréhensible, non?  Lorsque vous avez peur de faire un changement, car cela interrompra une autre partie du programme que vous ne comprenez pas bien et que vous ne savez pas comment résoudre.  Telle est la difficulté. <br><br><blockquote>  <i>«Il y a deux façons de concevoir un logiciel: la première consiste à le rendre si simple qu'il n'y a pas de défauts évidents, et la seconde est de le rendre si complexe qu'il n'y a pas de défauts évidents.</i>  <i>Le premier est beaucoup plus difficile. »</i> - C.E. R. Hoar </blockquote><br>  La complexité transforme un logiciel fiable en peu fiable.  La complexité est ce qui tue les projets logiciels.  Par conséquent, la simplicité est l'objectif ultime de Go.  Quels que soient les programmes que nous écrivons, ils devraient être simples. <br><br><a name="1_2"></a><h2>  1.2.  Lisibilité </h2><br><blockquote>  <i>«La lisibilité fait partie intégrante de la maintenabilité»</i> - Mark Reinhold, JVM Conference, 2018 </blockquote><br>  Pourquoi est-il important que le code soit lisible?  Pourquoi devrions-nous nous efforcer de lisibilité? <br><br><blockquote>  <i>«Les programmes doivent être écrits pour les gens, et les machines doivent simplement les exécuter»</i> - Hal Abelson et Gerald Sassman, «Structure et interprétation des programmes informatiques» </blockquote><br>  Non seulement les programmes Go, mais généralement tous les logiciels sont écrits par des personnes pour des personnes.  Le fait que les machines traitent également le code est secondaire. <br><br>  Une fois écrit, le code sera lu à plusieurs reprises par des personnes: des centaines, voire des milliers de fois. <br><br><blockquote>  <i>«La compétence la plus importante pour un programmeur est la capacité de communiquer efficacement des idées.»</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gaston Horker</a> </blockquote><br>  La lisibilité est la clé pour comprendre ce que fait un programme.  Si vous ne comprenez pas le code, comment le maintenir?  Si le logiciel ne peut pas être pris en charge, il sera réécrit;  et c'est peut-être la dernière fois que votre entreprise utilise Go. <br><br>  Si vous écrivez un programme pour vous-même, faites ce qui vous convient.  Mais si cela fait partie d'un projet commun ou si le programme sera utilisé assez longtemps pour changer les exigences, les fonctions ou l'environnement dans lequel il fonctionne, alors votre objectif est de rendre le programme maintenable. <br><br>  La première étape pour écrire un logiciel pris en charge est de s'assurer que le code est clair. <br><br><a name="1_3"></a><h2>  1.3.  La productivité </h2><br><blockquote>  <i>«Le design est l'art d'organiser le code pour qu'il fonctionne aujourd'hui, mais il soutient toujours le changement.»</i> - Sandy Mets </blockquote><br>  Comme dernier principe de base, je veux nommer la productivité du développeur.  C'est un gros sujet, mais cela se résume au rapport: combien de temps vous passez sur un travail utile et combien - en attendant une réponse d'outils ou d'errances désespérées dans une base de code incompréhensible.  Les programmeurs de Go devraient sentir qu'ils peuvent gérer beaucoup de travail. <br><br>  C'est une blague que le langage Go a été développé pendant la compilation du programme C ++.  La compilation rapide est une caractéristique clé de Go et un facteur clé pour attirer de nouveaux développeurs.  Bien que les compilateurs soient améliorés, en général, la compilation de minutes dans d'autres langues prend quelques secondes sur Go.  Les développeurs de Go sont donc aussi productifs que les programmeurs dans les langages dynamiques, mais sans aucun problème avec la fiabilité de ces langages. <br><br>  Si nous parlons fondamentalement de la productivité des développeurs, les programmeurs Go comprennent que la lecture de code est essentiellement plus importante que son écriture.  Dans cette logique, Go va même jusqu'à utiliser les outils pour formater tout le code dans un certain style.  Cela élimine la moindre difficulté à apprendre le dialecte spécifique d'un projet particulier et aide à identifier les erreurs car elles <i>semblent</i> fausses par rapport au code normal. <br><br>  Les programmeurs Go ne passent pas des jours à déboguer des erreurs de compilation étranges, des scripts de construction complexes ou à déployer du code dans un environnement de production.  Et surtout, ils ne perdent pas de temps à essayer de comprendre ce qu'un collègue a écrit. <br><br>  Lorsque les développeurs Go parlent d' <i>évolutivité</i> , ils parlent de productivité. <br><br><a name="2"></a><h1>  2. Identifiants </h1><br>  Le premier sujet que nous aborderons - les <i>identificateurs</i> , est un synonyme de <i>noms</i> : noms de variables, fonctions, méthodes, types, packages, etc. <br><br><blockquote>  <i>«Le mauvais nom est un symptôme d'une mauvaise conception»</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dave Cheney</a> </blockquote><br>  Étant donné la syntaxe limitée de Go, les noms d'objets ont un impact énorme sur la lisibilité du programme.  La lisibilité est un facteur clé d'un bon code, il est donc crucial de choisir de bons noms. <br><br><a name="2_1"></a><h2>  2.1.  Identificateurs de nom basés sur la clarté plutôt que sur la brièveté </h2><br><blockquote>  <i>«Il est important que le code soit évident.</i>  <i>Ce que vous pouvez faire en une ligne, vous devez le faire en trois. »</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ukia Smith</a> </blockquote><br>  Go n'est pas optimisé pour les lignes simples délicates ou le nombre minimum de lignes dans un programme.  Nous n'optimisons pas la taille du code source sur le disque, ni le temps nécessaire pour taper le programme dans l'éditeur. <br><br><blockquote>  <i>«Un bon nom est comme une bonne blague.</i>  <i>Si vous avez besoin de l'expliquer, alors ce n'est plus drôle. »</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dave Cheney</a> </blockquote><br>  La clé d'une clarté maximale réside dans les noms que nous choisissons pour identifier les programmes.  Quelles qualités sont inhérentes à une bonne réputation? <br><br><ul><li>  <b>Un bon nom est concis</b> .  Il ne doit pas nécessairement être le plus court, mais ne contient pas d'excès.  Il a un rapport signal / bruit élevé. </li><li>  <b>Un bon nom est descriptif</b> .  Il décrit l'utilisation d'une variable ou d'une constante, <i>pas le</i> contenu.  Un bon nom décrit le résultat d'une fonction ou le comportement d'une méthode, <i>pas une</i> implémentation.  Le but de l'emballage, <i>pas</i> son contenu.  Plus le nom décrit avec précision la chose qui l'identifie, mieux c'est. </li><li>  <b>Un bon nom est prévisible</b> .  Par un nom, vous devez comprendre comment l'objet sera utilisé.  Les noms doivent être descriptifs, mais il est également important de suivre la tradition.  C'est ce que les programmeurs Go veulent dire quand ils disent <i>"idiomatique"</i> . </li></ul><br>  Examinons plus en détail chacune de ces propriétés. <br><br><a name="2_2"></a><h2>  2.2.  Longueur ID </h2><br>  Parfois, le style de Go est critiqué pour les noms de variables courts.  Comme l'a dit Rob Pike, "les programmeurs Go veulent des identifiants de la <i>bonne</i> longueur." <br><br>  Andrew Gerrand propose des identifiants plus longs pour indiquer l'importance. <br><br><blockquote>  <i>«Plus la distance entre la déclaration d'un nom et l'utilisation d'un objet est grande, plus le nom doit être long»</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrew Gerrand</a> </blockquote><br>  Ainsi, quelques recommandations peuvent être faites: <br><br><ul><li>  Les noms de variables courts sont bons si la distance entre la déclaration et la <i>dernière</i> utilisation est petite. <br></li><li>  Les noms de variables longs doivent se justifier;  plus ils sont longs, plus ils devraient être importants.  Les titres verbeux contiennent peu de signal par rapport à leur poids sur la page. <br></li><li>  N'incluez pas le nom du type dans le nom de la variable. <br></li><li>  Les noms de constantes doivent décrire la valeur interne, pas comment la valeur est utilisée. <br></li><li>  Préférez les variables à une lettre pour les boucles et les branches, des mots séparés pour les paramètres et les valeurs de retour, plusieurs mots pour les fonctions et les déclarations au niveau du package. <br></li><li>  Préférez des mots simples pour les méthodes, les interfaces et les packages. <br></li><li>  N'oubliez pas que le nom du package fait partie du nom que l'appelant utilise pour référence. </li></ul><br>  Prenons un exemple. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Age <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-comment"><span class="hljs-comment">// AverageAge returns the average age of people. func AverageAge(people []Person) int { if len(people) == 0 { return 0 } var count, sum int for _, p := range people { sum += p.Age count += 1 } return sum / count }</span></span></code> </pre> <br>  Dans la dixième ligne, une variable de plage <code>p</code> déclarée et elle n'est appelée qu'une seule fois à partir de la ligne suivante.  Autrement dit, la variable vit sur la page pendant très peu de temps.  Si le lecteur s'intéresse au rôle de <code>p</code> dans le programme, il n'a qu'à lire deux lignes. <br><br>  A titre de comparaison, les <code>people</code> déclarées dans les paramètres de fonction et sept lignes sont en direct.  Il en va de même pour la <code>sum</code> et le <code>count</code> , ils justifient donc leurs noms plus longs.  Le lecteur doit scanner plus de code pour les trouver: cela justifie les noms les plus distingués. <br><br>  Vous pouvez choisir <code>s</code> pour <code>sum</code> et <code>c</code> (ou <code>n</code> ) pour <code>count</code> , mais cela réduit l'importance de toutes les variables du programme au même niveau.  Vous pouvez remplacer les <code>people</code> par <code>p</code> , mais il y aura un problème, comment appeler la variable d'itération <code>for ... range</code> .  Une seule <code>person</code> aura l'air étrange, car une variable d'itération de courte durée obtient un nom plus long que plusieurs valeurs dont elle est dérivée. <br><br><blockquote>  <b>Astuce</b> .  Séparez le flux de fonctions par des lignes vides, car les lignes vides entre les paragraphes interrompent le flux de texte.  Dans <code>AverageAge</code> , nous avons trois opérations consécutives.  Tout d'abord, vérifier la division par zéro, puis la conclusion de l'âge total et du nombre de personnes, et la dernière - le calcul de l'âge moyen. </blockquote><br><h3>  2.2.1.  L'essentiel est le contexte </h3><br>  Il est important de comprendre que la plupart des conseils de dénomination sont spécifiques au contexte.  J'aime dire que c'est un principe, pas une règle. <br><br>  Quelle est la différence entre <code>i</code> et <code>index</code> ?  Par exemple, vous ne pouvez pas dire sans équivoque qu'un tel code <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index := <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); index++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  fondamentalement plus lisible que <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(s); i++ { <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre> <br>  Je crois que la deuxième option n'est pas pire, car dans ce cas, la région <code>i</code> ou l' <code>index</code> limitée par le corps de la boucle <code>for</code> , et la verbosité supplémentaire ajoute peu à la compréhension du programme. <br><br>  Mais laquelle de ces fonctions est la plus lisible? <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oid []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, index </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  ou <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *SNMP)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span></code> </pre> <br>  Dans cet exemple, <code>oid</code> est une abréviation de SNMP Object ID, et l'abréviation supplémentaire de <code>o</code> oblige lors de la lecture du code à passer d'une notation documentée à une notation plus courte dans le code.  De même, la réduction de l' <code>index</code> à <code>i</code> rend la compréhension plus difficile, car dans les messages SNMP, la sous-valeur de chaque OID est appelée index. <br><br><blockquote>  <b>Astuce</b> .  Ne combinez pas les paramètres formels longs et courts dans une seule annonce. </blockquote><br><a name="2_3"></a><h2>  2.3.  Ne nommez pas les variables par type </h2><br>  Vous n'appelez pas vos animaux de compagnie "chien" et "chat", non?  Pour la même raison, vous ne devez pas inclure le nom du type dans le nom de la variable.  Il doit décrire le contenu, pas son type.  Prenons un exemple: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*User</code> </pre> <br>  À quoi sert cette annonce?  Nous voyons que c'est une carte, et cela a quelque chose à voir avec le <code>*User</code> type d' <code>*User</code> : c'est probablement bon.  Mais <code>usersMap</code> est <i>vraiment une</i> carte, et Go en tant que langage de type statique ne permettra pas d'utiliser accidentellement un tel nom où une variable scalaire est requise, donc le suffixe <code>Map</code> est redondant. <br><br>  Considérez une situation où d'autres variables sont ajoutées: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( companiesMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Company productsMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Products )</code> </pre> <br>  Nous avons maintenant trois variables de type map: <code>usersMap</code> , <code>companiesMap</code> et <code>productsMap</code> , et toutes les lignes sont mappées à différents types.  Nous savons que ce sont des cartes et nous savons également que le compilateur générera une erreur si nous essayons d'utiliser <code>companiesMap</code> là où le code attend <code>map[string]*User</code> .  Dans cette situation, il est clair que le suffixe <code>Map</code> n'améliore pas la clarté du code, ce ne sont que des caractères supplémentaires. <br><br>  Je suggère d'éviter tout suffixe qui ressemble au type d'une variable. <br><br><blockquote>  <b>Astuce</b> .  Si le nom des <code>users</code> ne décrit pas l'essence de manière suffisamment claire, alors <code>usersMap</code> aussi. </blockquote><br>  Cette astuce s'applique également aux paramètres de fonction.  Par exemple: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// } func WriteConfig(w io.Writer, config *Config)</span></span></code> </pre> <br>  Le nom de <code>*Config</code> paramètre <code>*Config</code> est redondant.  Nous savons déjà qu'il s'agit de <code>*Config</code> , il est immédiatement écrit à côté. <br><br>  Dans ce cas, considérez <code>conf</code> ou <code>c</code> si la durée de vie de la variable est suffisamment courte. <br><br>  Si à un moment donné dans notre région il y a plus d'une <code>*Config</code> , alors les noms <code>conf1</code> et <code>conf2</code> moins significatifs que l' <code>original</code> et <code>updated</code> , car ces derniers sont plus difficiles à mélanger. <br><br><blockquote>  <b>Remarque</b>  Ne laissez pas les noms de package voler de bons noms de variables. <br><br>  Le nom de l'identifiant importé contient le nom du package.  Par exemple, le type de <code>Context</code> dans le package de <code>context</code> sera appelé <code>context.Context</code> .  Cela rend impossible l'utilisation d'une variable ou d'un type de <code>context</code> dans votre package. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  Cela ne se compilera pas.  C'est pourquoi lors de la déclaration de types <code>ctx</code> localement, par exemple, des noms comme <code>ctx</code> sont traditionnellement utilisés. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, message </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> </blockquote><br><a name="2_4"></a><h2>  2.4.  Utilisez un seul style de dénomination </h2><br>  Une autre propriété d'une bonne réputation est qu'elle doit être prévisible.  Le lecteur doit le comprendre immédiatement.  S'il s'agit d'un nom <i>commun</i> , le lecteur a le droit de supposer qu'il n'a pas changé le sens par rapport à la fois précédente. <br><br>  Par exemple, si le code fait le tour du descripteur de base de données, chaque fois que le paramètre est affiché, il doit avoir le même nom.  Au lieu de toutes sortes de combinaisons comme <code>d *sql.DB</code> , <code>dbase *sql.DB</code> , <code>DB *sql.DB</code> et <code>database *sql.DB</code> il est préférable d'utiliser une chose: <br><br><pre> <code class="go hljs">db *sql.DB</code> </pre> <br>  Il est plus facile de comprendre le code.  Si vous voyez <code>db</code> , alors vous savez qu'il s'agit de <code>*sql.DB</code> et qu'il est déclaré localement ou fourni par l'appelant. <br><br>  Conseils similaires concernant les destinataires d'une méthode;  utilisez le même nom de destinataire pour chaque méthode de ce type.  Il sera donc plus facile pour le lecteur d'apprendre l'utilisation du destinataire parmi les différentes méthodes de ce type. <br><br><blockquote>  <b>Remarque</b>  L'accord sur le nom abrégé du destinataire Go est en contradiction avec les recommandations exprimées précédemment.  C'est l'un de ces cas où le choix fait à un stade précoce devient le style standard, comme l'utilisation de <code>CamelCase</code> au lieu de <code>snake_case</code> . </blockquote><br><blockquote>  <b>Astuce</b> .  Le style Go pointe vers des noms à une seule lettre ou des abréviations pour les destinataires dérivés de leur type.  Il peut s'avérer que le nom du destinataire entre parfois en conflit avec le nom du paramètre dans la méthode.  Dans ce cas, il est recommandé d'allonger un peu le nom du paramètre et de ne pas l'oublier. </blockquote><br>  Enfin, certaines variables d'une lettre sont traditionnellement associées aux boucles et au comptage.  Par exemple, <code>i</code> , <code>j</code> et <code>k</code> sont généralement des variables inductives dans les boucles <code>for</code> , <code>n</code> généralement associé à un compteur ou un additionneur cumulatif, <code>v</code> est une abréviation typique pour la valeur dans une fonction de codage, <code>k</code> généralement utilisé pour une clé de mappage et <code>s</code> souvent utilisé comme abréviation pour les paramètres de type <code>string</code> . <br><br>  Comme avec l'exemple <code>db</code> ci-dessus, les programmeurs <i>s'attendent</i> <code>i</code> <i>ce que</i> <code>i</code> soit une variable inductive.  S'ils le voient dans le code, ils s'attendent à voir une boucle bientôt. <br><br><blockquote>  <b>Astuce</b> .  Si vous avez tellement de boucles imbriquées que vous n'avez plus de variables <code>i</code> , <code>j</code> et <code>k</code> , vous souhaiterez peut-être diviser la fonction en unités plus petites. </blockquote><br><a name="2_5"></a><h2>  2.5.  Utilisez un style de déclaration unique </h2><br>  Go a au moins six façons différentes de déclarer une variable. <br><br><ul><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; x = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li><li><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> </li><li><pre> <code class="go hljs">x := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </li></ul><br>  Je suis sûr que je ne me suis pas encore souvenu de tout.  Les développeurs de Go considèrent probablement cela comme une erreur, mais il est trop tard pour changer quoi que ce soit.  Avec ce choix, comment assurer un style uniforme? <br><br>  Je veux proposer un style de déclaration de variables que j'essaie moi-même d'utiliser dans la mesure du possible. <br><br><ul><li>  <b>Lorsque vous déclarez une variable sans initialisation, utilisez <code>var</code></b> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 var things []Thing // an empty slice of Things var thing Thing // empty Thing struct json.Unmarshall(reader, &amp;thing)</span></span></code> </pre> <br>  <code>var</code> agit comme un indice que cette variable est <i>intentionnellement</i> déclarée comme une valeur nulle du type spécifié.  Ceci est cohérent avec l'exigence de déclarer des variables au niveau du package avec <code>var</code> par opposition à la syntaxe de déclaration courte, bien que je soutienne plus tard que les variables au niveau du package ne devraient pas être utilisées du tout. </li><li>  <b>Lors de la déclaration avec initialisation, utilisez <code>:=</code></b> .  Cela montre clairement au lecteur que la variable à gauche de <code>:=</code> intentionnellement initialisée. <br><br>  Pour expliquer pourquoi, regardons l'exemple précédent, mais cette fois nous initialisons spécialement chaque variable: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing *Thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> </li></ul><br>  Étant donné que Go n'a pas de conversions automatiques d'un type à un autre, dans les premier et troisième exemples, le type sur le côté gauche de l'opérateur d'affectation doit être identique au type sur le côté droit.  Le compilateur peut déduire le type de la variable déclarée à partir du type de droite, donc l'exemple peut être écrit de manière plus concise: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing) json.Unmarshall(reader, thing)</code> </pre> <br>  Ici, les <code>players</code> explicitement initialisés à <code>0</code> , ce qui est redondant, car la valeur initiale des <code>players</code> est nulle dans tous les cas.  Par conséquent, il est préférable de préciser que nous voulons utiliser une valeur nulle: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> players <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  Et le deuxième opérateur?  Nous ne pouvons pas déterminer le type et écrire <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br>  Parce que <code>nil</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas de type</a> .  Au lieu de cela, nous avons le choix: ou nous utilisons une valeur nulle pour trancher ... <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things []Thing</code> </pre> <br>  ... ou créer une tranche avec zéro élément? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> things = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Dans le second cas, la valeur de la tranche n'est <i>pas</i> nulle, et nous le précisons au lecteur en utilisant une forme courte de déclaration: <br><br><pre> <code class="go hljs">things := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]Thing, <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Cela indique au lecteur que nous avons décidé d'initialiser explicitement les <code>things</code> . <br><br>  Nous arrivons donc à la troisième déclaration: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Ici, à la fois l'initialisation explicite de la variable et l'introduction du <code>new</code> mot-clé «unique», que certains programmeurs Go n'aiment pas.  Utilisation des rendements de syntaxe courts recommandés <br><br><pre> <code class="go hljs">thing := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Thing)</code> </pre> <br>  Cela montre clairement que la <code>thing</code> explicitement initialisée au résultat de <code>new(Thing)</code> , mais laisse toujours un <code>new</code> atypique.  Le problème pourrait être résolu en utilisant un littéral: <br><br><pre> <code class="go hljs">thing := &amp;Thing{}</code> </pre> <br>  Ce qui est similaire à <code>new(Thing)</code> , et une telle duplication dérange certains programmeurs Go.  Cependant, cela signifie que nous initialisons explicitement la <code>thing</code> avec un pointeur sur <code>Thing{}</code> et une valeur <code>Thing</code> de zéro. <br><br>  Mais il vaut mieux prendre en compte le fait que la <code>thing</code> déclarée avec une valeur nulle, et utiliser l'adresse de l'opérateur pour passer l'adresse de la <code>thing</code> dans <code>json.Unmarshall</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thing Thing json.Unmarshall(reader, &amp;thing)</code> </pre> <br><blockquote>  <b>Remarque</b>  Bien sûr, il existe des exceptions à toute règle.  Par exemple, parfois deux variables sont étroitement liées, il sera donc étrange d'écrire <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max := <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Déclaration plus lisible: <br><br><pre> <code class="go hljs">min, max := <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> </blockquote><br>  Pour résumer: <br><br><ul><li>  Lorsque vous déclarez une variable sans initialisation, utilisez la syntaxe <code>var</code> . <br></li><li>  Lors de la déclaration et de l'initialisation explicite d'une variable, utilisez <code>:=</code> . </li></ul><br><blockquote>  <b>Astuce</b> .  Soulignez explicitement des choses complexes. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> = <span class="hljs-number"><span class="hljs-number">0x80</span></span></code> </pre> <br>  Ici, la <code>length</code> peut être utilisée avec la bibliothèque, qui nécessite un type numérique spécifique, et cette option indique plus clairement que la longueur du type est spécifiquement choisie comme uint32 que dans la déclaration courte: <br><br><pre> <code class="go hljs">length := <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span>(<span class="hljs-number"><span class="hljs-number">0x80</span></span>)</code> </pre> <br>  Dans le premier exemple, j'ai violé intentionnellement ma règle en utilisant la déclaration var avec une initialisation explicite.  Une dérogation à la norme fait comprendre au lecteur que quelque chose d'inhabituel se produit. </blockquote><br><a name="2_6"></a><h2>  2.6.  Travailler pour l'équipe </h2><br>  J'ai déjà dit que l'essence du développement logiciel est la création de code pris en charge lisible.  La majeure partie de votre carrière sera probablement consacrée à des projets communs.  Mon conseil dans cette situation: suivez le style adopté dans l'équipe. <br><br>  Changer de style au milieu du fichier est ennuyeux.  La cohérence est importante, mais au détriment des préférences personnelles.  Ma règle d'or est la suivante: si le code passe par <code>gofmt</code> , le problème ne vaut généralement pas la peine d'être discuté. <br><br><blockquote>  <b>Astuce</b> .  Si vous souhaitez renommer tout au long de la base de code, ne mélangez pas cela avec d'autres modifications.  Si quelqu'un utilise git bisect, il n'aimera pas parcourir des milliers de renommages pour trouver un autre code modifié. </blockquote><br><h1>  3. Commentaires </h1><br>  Avant de passer à des points plus importants, je voudrais prendre quelques minutes pour commenter. <br><br><blockquote>  <i>«Un bon code a beaucoup de commentaires et un mauvais code a besoin de beaucoup de commentaires.»</i> - Dave Thomas et Andrew Hunt, programmeur pragmatique </blockquote><br>  Les commentaires sont très importants pour la lisibilité du programme.  Chaque commentaire doit faire une - et une seule - de trois choses: <br><br><ol><li>  Expliquez <i>ce que fait le</i> code. </li><li>  Expliquez <i>comment</i> il le fait. </li><li>  Expliquez <i>pourquoi</i> . </li></ol><br>  Le premier formulaire est idéal pour commenter des personnages publics: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Open     . //           .</span></span></code> </pre> <br>  Le second est idéal pour les commentaires à l'intérieur d'une méthode: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//     var results []chan error for _, dep := range a.Deps { results = append(results, execute(seen, dep)) }</span></span></code> </pre> <br>  La troisième forme («pourquoi») est unique en ce qu'elle ne remplace ni ne remplace les deux premières.  Ces commentaires expliquent les facteurs externes qui ont conduit à l'écriture du code dans sa forme actuelle.  Souvent sans ce contexte, il est difficile de comprendre pourquoi le code est écrit de cette manière. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;v2.Cluster_CommonLbConfig{ <span class="hljs-comment"><span class="hljs-comment">//  HealthyPanicThreshold HealthyPanicThreshold: &amp;envoy_type.Percent{ Value: 0, }, }</span></span></code> </pre> <br>  Dans cet exemple, il peut ne pas être immédiatement clair ce qui se passe lorsque HealthyPanicThreshold est défini sur zéro pour cent.  Le commentaire est destiné à préciser qu'une valeur de 0 désactive le seuil de panique. <br><br><a name="3_1"></a><h2>  3.1.  Les commentaires dans les variables et les constantes doivent décrire leur contenu, pas leur objectif </h2><br>  J'ai dit plus tôt que le nom d'une variable ou d'une constante devrait décrire son objectif.  Mais un commentaire sur une variable ou une constante doit décrire exactement le <i>contenu</i> , pas le <i>but</i> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br>  Dans cet exemple, un commentaire décrit <i>pourquoi</i> <code>randomNumber</code> sur 6 et d'où il provient.  Le commentaire ne décrit pas où <code>randomNumber</code> sera utilisé.  Voici quelques exemples supplémentaires: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( StatusContinue = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-comment"><span class="hljs-comment">// RFC 7231, 6.2.1 StatusSwitchingProtocols = 101 // RFC 7231, 6.2.2 StatusProcessing = 102 // RFC 2518, 10.1 StatusOK = 200 // RFC 7231, 6.3.1</span></span></code> </pre> <br>  <i>Dans le contexte de HTTP, le</i> nombre <code>100</code> appelé <code>StatusContinue</code> , tel que défini dans la RFC 7231, section 6.2.1. <br><br><blockquote>  <b>Astuce</b> .  Pour les variables sans valeur initiale, le commentaire doit décrire qui est responsable de l'initialisation de cette variable. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sizeCalculationDisabled ,   //     . . dowidth. var sizeCalculationDisabled bool</span></span></code> </pre> <br>  Ici, un commentaire indique au lecteur que la fonction <code>dowidth</code> responsable du maintien de l'état de <code>sizeCalculationDisabled</code> . </blockquote><br><blockquote>  <b>Astuce</b> .  Cachez-vous en vue.  Voici les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conseils de Kate Gregory</a> .  Parfois, le meilleur nom d'une variable est masqué dans les commentaires. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   SQL var registry = make(map[string]*sql.Driver)</span></span></code> </pre> <br>  Un commentaire a été ajouté par l'auteur parce que le <code>registry</code> noms n'explique pas suffisamment son but - c'est un registre, mais qu'est-ce que le registre? <br><br>  Si vous renommez une variable en sqlDrivers, il devient clair qu'elle contient des pilotes SQL. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlDrivers = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*sql.Driver)</code> </pre> <br>  Maintenant, le commentaire est devenu redondant et peut être supprimé. </blockquote><br><a name="3_2"></a><h2>  3.2.  Documentez toujours les caractères accessibles au public </h2><br>  La documentation de votre package est générée par godoc, vous devez donc ajouter un commentaire à chaque caractère public déclaré dans le package: une variable, une constante, une fonction et une méthode. <br><br>  Voici deux consignes du Google Style Guide: <br><br><ul><li>  Toute fonction publique qui n'est pas à la fois évidente et concise doit être commentée. <br></li><li>  Toute fonction de la bibliothèque doit être commentée, quelle que soit sa longueur ou sa complexité. </li></ul><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ioutil <span class="hljs-comment"><span class="hljs-comment">// ReadAll   r      (EOF)   // ..    err == nil, not err == EOF. //  ReadAll     ,     //  . func ReadAll(r io.Reader) ([]byte, error)</span></span></code> </pre> <br>  Il existe une exception à cette règle: vous n'avez pas besoin de documenter les méthodes qui implémentent l'interface.  Plus précisément, ne procédez pas ainsi: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Read   io.Reader func (r *FileReader) Read(buf []byte) (int, error)</span></span></code> </pre> <br>  Ce commentaire ne veut rien dire.  Il ne dit pas ce que fait la méthode: pire, il envoie quelque part chercher de la documentation.  Dans cette situation, je propose de supprimer complètement le commentaire. <br><br>  Voici un exemple du package <code>io</code> . <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// LimitReader  Reader,    r, //    EOF  n . //   *LimitedReader. func LimitReader(r Reader, n int64) Reader { return &amp;LimitedReader{r, n} } // LimitedReader   R,     //   N .   Read  N  //    . // Read  EOF,  N &lt;= 0    R  EOF. type LimitedReader struct { R Reader // underlying reader N int64 // max bytes remaining } func (l *LimitedReader) Read(p []byte) (n int, err error) { if lN &lt;= 0 { return 0, EOF } if int64(len(p)) &gt; lN { p = p[0:lN] } n, err = lRRead(p) lN -= int64(n) return }</span></span></code> </pre> <br>  Notez que la déclaration <code>LimitedReader</code> est immédiatement précédée de la fonction qui l'utilise et la déclaration <code>LimitedReader.Read</code> suit la déclaration de <code>LimitedReader</code> elle-même.  Bien que <code>LimitedReader.Read</code> lui-même ne soit pas documenté, il peut être compris qu'il s'agit d'une implémentation d' <code>io.Reader</code> . <br><br><blockquote>  <b>Astuce</b> .  Avant d'écrire une fonction, écrivez un commentaire la décrivant.  Si vous trouvez difficile d'écrire un commentaire, cela signifie que le code que vous êtes sur le point d'écrire sera difficile à comprendre. </blockquote><br><h3>  3.2.1.  Ne commentez pas le mauvais code, réécrivez-le </h3><br><blockquote>  <i>«Ne commentez pas le mauvais code - réécrivez-le»</i> - Brian Kernighan </blockquote><br>  Il ne suffit pas d'indiquer dans les commentaires la difficulté du fragment de code.  Si vous rencontrez l'un de ces commentaires, vous devez commencer un ticket avec un rappel de refactoring.  Vous pouvez vivre avec une dette technique tant que son montant est connu. <br><br>  Il est habituel de laisser des commentaires dans la bibliothèque standard dans le style TODO avec le nom de l'utilisateur qui a remarqué le problème. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// TODO(dfc)  O(N^2),     .</span></span></code> </pre> <br>  Ce n'est pas une obligation de résoudre le problème, mais l'utilisateur spécifié peut être la meilleure personne à contacter pour une question.  D'autres projets accompagnent TODO avec une date ou un numéro de ticket. <br><br><h3>  3.2.2.  Au lieu de commenter le code, refactorisez-le </h3><br><blockquote>  <i>«Un bon code est la meilleure documentation.</i>  <i>Lorsque vous êtes sur le point d'ajouter un commentaire, posez-vous la question: "Comment améliorer le code pour que ce commentaire ne soit pas nécessaire?"</i>  <i>Refactorisez et laissez un commentaire pour le rendre encore plus clair. »</i> - Steve McConnell </blockquote><br>  Les fonctions ne doivent effectuer qu'une seule tâche.  Si vous souhaitez écrire un commentaire car un fragment n'est pas lié au reste de la fonction, envisagez de l'extraire dans une fonction distincte. <br><br>  Les fonctionnalités plus petites sont non seulement plus claires, mais plus faciles à tester séparément les unes des autres.  Lorsque vous avez isolé le code dans une fonction distincte, son nom peut remplacer un commentaire. <br><br><a name="4"></a><h1>  4. Structure du package </h1><br><blockquote>  <i>«Écrivez un code modeste: des modules qui ne montrent rien de superflu aux autres modules et qui ne dépendent pas de l'implémentation d'autres modules»</i> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dave Thomas</a> </blockquote><br>  Chaque package est essentiellement un petit programme Go distinct.  Tout comme l'implémentation d'une fonction ou d'une méthode n'a pas d'importance pour l'appelant, l'implémentation des fonctions, des méthodes et des types qui composent l'API publique de votre package n'a pas d'importance non plus. <br><br>  Un bon package Go aspire à une connectivité minimale avec d'autres packages au niveau du code source, de sorte que, à mesure que le projet se développe, les modifications d'un package ne sont pas répercutées dans la base de code.  De telles situations empêchent considérablement les programmeurs de travailler sur cette base de code. <br><br>  Dans cette section, nous parlerons de la conception d'un package, y compris son nom et des conseils pour écrire des méthodes et des fonctions. <br><br><a name="4_1"></a><h2>  4.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Un bon package commence par un bon nom </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un bon forfait Go commence par un nom de qualité. </font><font style="vertical-align: inherit;">Considérez-le comme une courte présentation limitée à un seul mot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme les noms de variables dans la section précédente, le nom du package est très important. </font><font style="vertical-align: inherit;">Pas besoin de penser aux types de données de ce package, il vaut mieux se poser la question: "Quel service ce package propose-t-il?" </font><font style="vertical-align: inherit;">Habituellement, la réponse n'est pas «Ce package fournit le type X», mais «Ce package vous permet de vous connecter via HTTP».</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Choisissez un nom de package par sa fonctionnalité et non par son contenu.</font></font></blockquote><br><h3>  4.1.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les bons noms de colis doivent être uniques </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque package a un nom unique dans le projet. </font><font style="vertical-align: inherit;">Il n'y a aucune difficulté si vous avez suivi les conseils de donner des noms aux fins des packages. </font><font style="vertical-align: inherit;">S'il s'avère que les deux packages portent le même nom, le plus probable:</font></font><br><br><ol><li>     . </li><li>       .       ,     . </li></ol><br><a name="4_2"></a><h2> 4.2.    <code>base</code> , <code>common</code>  <code>util</code> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une raison courante des mauvais noms est les soi-disant </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packages de services</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où au fil du temps divers assistants et codes de service s'accumulent. Puisqu'il est difficile d'y trouver un nom unique. Cela conduit souvent au fait que le nom du package est dérivé de ce qu'il </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : les utilitaires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des noms comme </font></font><code>utils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou se </font></font><code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouvent généralement dans les grands projets, dans lesquels une profonde hiérarchie de packages est enracinée, et les fonctions auxiliaires sont partagées. Si vous extrayez une fonction dans un nouveau package, l'importation échoue. Dans ce cas, le nom du package ne reflète pas l'objectif du package, mais uniquement le fait que la fonction d'importation a échoué en raison d'une mauvaise organisation du projet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans de telles situations, je recommande d'analyser d'où les packages sont appelés.</font></font><code>utils</code> <code>helpers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et, si possible, déplacez les fonctions correspondantes vers le paquet appelant. </font><font style="vertical-align: inherit;">Même si cela implique la duplication d'un code auxiliaire, c'est mieux que d'introduire une dépendance d'importation entre deux packages.</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«[Un peu] de duplication est beaucoup moins cher qu'une mauvaise abstraction»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Sandy Mets</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si les fonctions utilitaires sont utilisées dans de nombreux endroits, au lieu d'un package monolithique avec des fonctions utilitaires, il est préférable de créer plusieurs packages, chacun se concentrant sur un aspect. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Utilisez le pluriel pour les packages de services. </font><font style="vertical-align: inherit;">Par exemple, </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les utilitaires de traitement de chaîne.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les packages portant des noms tels que </font></font><code>base</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont souvent trouvés lorsqu'un certain package de fonctionnalités communes de deux ou plusieurs implémentations ou types communs est fusionné dans un package distinct pour le client et le serveur. </font><font style="vertical-align: inherit;">Je pense que dans de tels cas, il est nécessaire de réduire le nombre de packages en combinant le client, le serveur et le code commun dans un package avec un nom qui correspond à sa fonction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, pour </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pas faire les paquets individuels </font></font><code>client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, à la </font><font style="vertical-align: inherit;">place, il y a des </font><font style="vertical-align: inherit;">fichiers </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les types de données correspondants, ainsi que </font></font><code>transport.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour le transport total.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il est important de se rappeler que le nom de l'identifiant inclut le nom du package.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fonction </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'un package </font></font><code>net/http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devient un </font></font><code>http.Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien à partir d'un autre package.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un type </font></font><code>Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'un package est </font></font><code>strings</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transformé en lors de son importation dans d'autres packages </font></font><code>strings.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interface </font></font><code>Error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">du package est </font></font><code>net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clairement associée à des erreurs de réseau.</font></font></li></ul></blockquote><br><a name="4_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3. </font><font style="vertical-align: inherit;">Revenez rapidement sans plonger profondément</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que Go n'utilise pas d'exceptions dans le flux de contrôle, il n'est pas nécessaire de creuser profondément dans le code pour fournir une structure de niveau supérieur pour les blocs </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu d'une hiérarchie à plusieurs niveaux, le code Go descend l'écran pendant que la fonction progresse. </font><font style="vertical-align: inherit;">Mon ami Matt Ryer appelle cette pratique une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«ligne de vue»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est réalisé en utilisant </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des opérateurs de limites</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : des blocs conditionnels avec une condition préalable à l'entrée de la fonction. </font><font style="vertical-align: inherit;">Voici un exemple du package </font></font><code>bytes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &lt;= opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En entrant dans la fonction </font></font><code>UnreadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, l'état est vérifié </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et si l'opération précédente ne l'était pas </font></font><code>ReadRune</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, une erreur est immédiatement renvoyée. Le reste de la fonction fonctionne en fonction de ce qui est </font></font><code>b.lastRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supérieur à </font></font><code>opInvalid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparez avec la même fonction, mais sans l'opérateur de frontière:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *Buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnreadRune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.lastRead &gt; opInvalid { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.off &gt;= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) { b.off -= <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(b.lastRead) } b.lastRead = opInvalid <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le corps d'une branche réussie plus probable est intégré dans la première condition </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et la condition pour une sortie réussie </font></font><code>return nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être découverte en faisant correspondre soigneusement les </font><font style="vertical-align: inherit;">crochets de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fermeture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La dernière ligne de la fonction renvoie maintenant une erreur et vous devez suivre l'exécution de la fonction jusqu'au </font><font style="vertical-align: inherit;">crochet d' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ouverture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondant </font><font style="vertical-align: inherit;">pour savoir comment y parvenir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette option est plus difficile à lire, ce qui dégrade la qualité de la programmation et la prise en charge du code, donc Go préfère utiliser les opérateurs de limites et renvoyer les erreurs à un stade précoce.</font></font><br><br><a name="4_4"></a><h2>  4.4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendre la valeur nulle utile </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque déclaration de variable, en supposant l'absence d'un initialiseur explicite, sera automatiquement initialisée avec une valeur correspondant au contenu de la mémoire mise à zéro, c'est-à-dire </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zéro</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le type de valeur est déterminé par l'une des options: pour les types numériques - zéro, pour les types de pointeurs - nul, le même pour les tranches, les cartes et les canaux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La possibilité de toujours définir une valeur par défaut connue est importante pour la sécurité et l'exactitude de votre programme et peut rendre vos programmes Go plus faciles et plus compacts. C'est ce que les programmeurs Go ont en tête lorsqu'ils disent: «Donnez aux structures une valeur zéro utile». </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considérons un type </font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui contient deux champs entiers représentant l'état interne du mutex. Ces champs sont automatiquement nuls dans toute déclaration.</font></font><code>sync.Mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ce fait est pris en compte dans le code, donc le type peut être utilisé sans initialisation explicite.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyInt <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mu sync.Mutex val <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i MyInt <span class="hljs-comment"><span class="hljs-comment">// i.mu is usable without explicit initialisation. i.mu.Lock() i.val++ i.mu.Unlock() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre exemple de type avec une valeur nulle utile est </font></font><code>bytes.Buffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vous pouvez le déclarer et commencer à y écrire sans initialisation explicite.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b bytes.Buffer b.WriteString(<span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span>) io.Copy(os.Stdout, &amp;b) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur zéro de cette structure signifie que les </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux </font></font><code>cap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont égaux </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et y </font></font><code>array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le pointeur vers la mémoire avec le contenu du tableau de tranches de sauvegarde, valeur </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela signifie que vous n'avez pas besoin de couper explicitement, vous pouvez simplement le déclarer.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// s := make([]string, 0) // s := []string{} var s []string s = append(s, "Hello") s = append(s, "world") fmt.Println(strings.Join(s, " ")) }</span></span></code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>var s []string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">similaire aux deux lignes commentées en haut, mais pas identique à elles. </font><font style="vertical-align: inherit;">Il existe une différence entre une valeur de tranche nulle et une valeur de tranche de longueur nulle. </font><font style="vertical-align: inherit;">Le code suivant s'imprime faux.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1 = []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2 []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fmt.Println(reflect.DeepEqual(s1, s2)) }</code> </pre> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une propriété utile, quoique inattendue, des variables de pointeur non initialisées - pointeurs nil - est la possibilité d'appeler des méthodes sur des types qui sont nuls. </font><font style="vertical-align: inherit;">Cela peut être utilisé pour fournir facilement des valeurs par défaut.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/usr/home"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.path } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c1 *Config <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c2 = &amp;Config{ path: <span class="hljs-string"><span class="hljs-string">"/export"</span></span>, } fmt.Println(c1.Path(), c2.Path()) }</code> </pre> <br><a name="4_5"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5. </font><font style="vertical-align: inherit;">Évitez l'état au niveau du package</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La clé pour écrire des programmes faciles à prendre en charge dans des environnements mal couplés est que la modification d'un package devrait avoir une faible probabilité d'affecter un autre package qui ne dépend pas directement du premier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe deux excellents moyens d'obtenir une connectivité faible dans Go:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisez des interfaces pour décrire le comportement requis par les fonctions ou les méthodes. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Évitez le statut global. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Go, nous pouvons déclarer des variables dans la portée d'une fonction ou d'une méthode, ainsi que dans la portée d'un package. </font><font style="vertical-align: inherit;">Lorsqu'une variable est accessible au public, avec un identifiant avec une majuscule, sa portée est en fait globale pour tout le programme: n'importe quel package </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à tout moment</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voit le type et le contenu de cette variable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'état global mutable fournit une relation étroite entre les parties indépendantes du programme, car les variables globales deviennent un paramètre invisible pour chaque fonction du programme! </font><font style="vertical-align: inherit;">Toute fonction qui s'appuie sur une variable globale peut être violée lorsque le type de cette variable change. </font><font style="vertical-align: inherit;">Toute fonction qui dépend de l'état d'une variable globale peut être violée si une autre partie du programme modifie cette variable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment réduire la connectivité créée par une variable globale: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Déplacez les variables correspondantes sous forme de champs vers les structures qui en ont besoin. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisez des interfaces pour réduire la connexion entre le comportement et la mise en œuvre de ce comportement. </font></font></li></ol><br><a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Structure du projet </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parlons de la façon dont les packages sont combinés dans un projet. </font><font style="vertical-align: inherit;">Il s'agit généralement d'un seul référentiel Git. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme le package, chaque projet doit avoir un objectif clair. </font><font style="vertical-align: inherit;">S'il s'agit d'une bibliothèque, elle doit faire une chose, par exemple, l'analyse XML ou la journalisation. </font><font style="vertical-align: inherit;">Vous ne devez pas combiner plusieurs objectifs dans un même projet, cela vous évitera une bibliothèque effrayante </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">D'après mon expérience, le référentiel </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est en fin de compte étroitement associé au plus grand consommateur, ce qui rend difficile d'apporter des corrections aux versions précédentes (correctifs de port arrière) sans mettre à jour à la fois le </font></font><code>common</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le consommateur au stade du blocage, ce qui conduit à de nombreux changements non liés, et ils se brisent en cours de route API</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez une application (application web, contrôleur Kubernetes, etc.), le projet peut avoir un ou plusieurs packages principaux. </font><font style="vertical-align: inherit;">Par exemple, dans mon contrôleur Kubernetes, il existe un package </font></font><code>cmd/contour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui sert de serveur déployé dans un cluster Kubernetes et de client de débogage.</font></font><br><br><a name="5_1"></a><h2>  5.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moins de paquets mais plus gros </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la revue de code, j'ai remarqué l'une des erreurs typiques des programmeurs qui sont passés à Go à partir d'autres langues: ils ont tendance à abuser des packages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go ne fournit pas le système complexe de visibilité: la langue n'est pas assez modificateurs d'accès comme dans Java ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>protected</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>private</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et implicite </font></font><code>default</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Il n'y a pas d'analogue des classes amies de C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Go, nous n'avons que deux modificateurs d'accès: ce sont des identifiants publics et privés, qui sont indiqués par la première lettre de l'identifiant (majuscule / minuscule). </font><font style="vertical-align: inherit;">Si l'identifiant est public, son nom commence par une lettre majuscule, il peut être référencé par tout autre package Go.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">On pouvait entendre les mots «exporté» ou «non exporté» comme synonymes de public et privé.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compte tenu des fonctionnalités de contrôle d'accès limitées, quelles méthodes peuvent être utilisées pour éviter les hiérarchies de packages trop complexes? </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans chaque package, en plus </font></font><code>cmd/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit être présent le code source.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai dit à plusieurs reprises qu'il vaut mieux préférer moins de gros paquets. </font><font style="vertical-align: inherit;">Votre position par défaut doit être de ne pas créer de nouveau package. </font><font style="vertical-align: inherit;">Cela fait que trop de types deviennent publics, créant une large et petite étendue d'API disponibles. </font><font style="vertical-align: inherit;">Ci-dessous, nous considérons cette thèse plus en détail.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Vous êtes venu de Java? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous venez du monde Java ou C #, souvenez-vous de la règle tacite: un package Java est équivalent à un seul fichier source </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le package Go est équivalent à l'ensemble du module Maven ou de l'assembly .NET.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.1. </font><font style="vertical-align: inherit;">Tri du code par fichier à l'aide des instructions d'importation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous organisez des packages par service, devez-vous faire de même pour les fichiers du package? </font><font style="vertical-align: inherit;">Comment savoir quand diviser un fichier </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en plusieurs? </font><font style="vertical-align: inherit;">Comment savoir si vous êtes allé trop loin et devez penser à fusionner des fichiers? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici les recommandations que j'utilise:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démarrez chaque package avec un fichier </font></font><code>.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Donnez à ce fichier le même nom que le répertoire. </font><font style="vertical-align: inherit;">Par exemple, le package </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit se trouver dans un fichier </font></font><code>http.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un répertoire </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au fur et à mesure que le package se développe, vous pouvez diviser les différentes fonctions en plusieurs fichiers. </font><font style="vertical-align: inherit;">Par exemple, le fichier </font></font><code>messages.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiendra des types </font></font><code>Request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Response</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un </font></font><code>client.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type de </font></font><code>Client</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fichier </font></font><code>server.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un serveur de type </font><font style="vertical-align: inherit;">fichier </font><font style="vertical-align: inherit;">.</font></font><br></li><li>       ,    .  ,       . <br></li><li>        . , <code>messages.go</code>     HTTP-       , <code>http.go</code>      , <code>client.go</code>  <code>server.go</code> —    HTTP     . </li></ul><br><blockquote> <b></b> .      . </blockquote><br><blockquote> <b></b> .  Go    .      <i></i> ( —      Go).           . </blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1.2. </font><font style="vertical-align: inherit;">Préférez les tests internes aux tests externes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'outil </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend en charge le package </font></font><code>testing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à deux endroits. </font><font style="vertical-align: inherit;">Si vous avez un package </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez écrire un fichier </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et utiliser la déclaration de package </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il compile le code </font></font><code>http2_test.go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> il fait partie du paquet </font></font><code>http2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans le langage courant, un tel test est appelé interne. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'outil </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend également en charge une déclaration de package spéciale qui se termine par </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-à-dire </font></font><code>http_test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela permet aux fichiers de test de vivre dans un seul package avec le code, mais lorsque ces tests sont compilés, ils ne font pas partie du code de votre package, mais vivent dans leur propre package. </font><font style="vertical-align: inherit;">Cela vous permet d'écrire des tests comme si un autre paquet appelait votre code. </font><font style="vertical-align: inherit;">Ces tests sont appelés externes.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je recommande d'utiliser des tests internes pour les tests unitaires unitaires. Cela vous permet de tester directement chaque fonction ou méthode, en évitant la bureaucratie des tests externes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nécessaire</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de placer des exemples de fonctions de test ( </font></font><code>Example</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">dans un fichier de test externe </font><font style="vertical-align: inherit;">. Cela garantit que lorsqu'ils sont visualisés dans godoc, les exemples reçoivent le préfixe de package approprié et peuvent être facilement copiés.</font></font><br><br><blockquote> <b></b> .    ,     . <br><br>   ,    ,   Go      <code>go</code> . ,  <code>net/http</code>       <code>net</code> . <br><br>           <code>.go</code> , ,    . </blockquote><br><h3> 5.1.3.   ,     API </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si votre projet comporte plusieurs packages, vous pouvez trouver des fonctions exportées destinées à être utilisées par d'autres packages, mais pas pour l'API publique. </font><font style="vertical-align: inherit;">Dans une telle situation, l'outil </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reconnaît un nom de dossier spécial </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui peut être utilisé pour placer du code ouvert pour votre projet, mais fermé aux autres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour créer un tel package, placez-le dans un répertoire avec un nom </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou dans son sous-répertoire. </font><font style="vertical-align: inherit;">Lorsque l'équipe </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voit l'importation du package avec le chemin d'accès </font></font><code>internal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, elle vérifie l'emplacement du package appelant dans un répertoire ou un sous-répertoire </font></font><code>internal/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, un package </font></font><code>.../a/b/c/internal/d/e/f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut importer uniquement un package à partir d'une arborescence de répertoires </font></font><code>.../a/b/c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais pas du tout </font></font><code>.../a/b/g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou tout autre référentiel (voir</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><a name="5_2"></a><h2>  5.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le plus petit paquet principal </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une fonction </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et un package </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doivent avoir des fonctionnalités minimales, car ils </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agissent comme un singleton: un programme ne peut avoir qu'une seule fonction </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y compris les tests. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme il </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'agit d'un singleton, il existe de nombreuses restrictions sur les objets appelés: ils ne sont appelés que pendant </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>main.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seule </font><i><font style="vertical-align: inherit;">fois</font></i><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cela rend difficile l'écriture de tests pour le code </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ainsi, vous devez vous efforcer de tirer le plus de logique possible de la fonction principale et, idéalement, du package principal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><code>func main()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit analyser les indicateurs, ouvrir les connexions aux bases de données, les enregistreurs, etc., puis transférer l'exécution vers un objet de haut niveau.</font></font></blockquote><br><a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Structure de l'API </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le dernier conseil de conception pour le projet que je considère comme le plus important. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les phrases précédentes ne sont en principe pas contraignantes. </font><font style="vertical-align: inherit;">Ce ne sont que des recommandations basées sur l'expérience personnelle. </font><font style="vertical-align: inherit;">Je ne pousse pas trop ces recommandations dans une revue de code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'API est une autre affaire. Ici, les erreurs sont prises plus au sérieux, car tout le reste peut être corrigé sans briser la compatibilité descendante: pour la plupart, ce ne sont que des détails d'implémentation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En ce qui concerne les API publiques, il convient de considérer sérieusement la structure dès le début, car les modifications ultérieures seront destructrices pour les utilisateurs.</font></font><br><br><a name="6_1"></a><h2>  6.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API de conception difficiles à abuser par conception </font></font></h2><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Les API doivent être simples pour une utilisation correcte et difficiles pour des erreurs»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Josh Bloch</font></font></a> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les conseils de Josh Bloch sont peut-être les plus précieux de cet article. </font><font style="vertical-align: inherit;">Si l'API est difficile à utiliser pour des choses simples, chaque appel d'API est plus compliqué que nécessaire. </font><font style="vertical-align: inherit;">Lorsqu'un appel d'API est complexe et non évident, il est probable qu'il soit ignoré.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.1.1. </font><font style="vertical-align: inherit;">Soyez prudent avec les fonctions qui acceptent plusieurs paramètres du même type.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un bon exemple d'une API simple à première vue, mais difficile à utiliser, est lorsqu'elle nécessite deux ou plusieurs paramètres du même type. </font><font style="vertical-align: inherit;">Comparez deux signatures de fonction:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la différence entre ces deux fonctions? </font><font style="vertical-align: inherit;">Évidemment, l'un renvoie un maximum de deux nombres et l'autre copie le fichier. </font><font style="vertical-align: inherit;">Mais ce n'est pas la question.</font></font><br><br><pre> <code class="go hljs">Max(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 10 Max(10, 8) // 10</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Max est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commutatif</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : l'ordre des paramètres n'a pas d'importance. </font><font style="vertical-align: inherit;">Un maximum de huit et dix est égal à dix, que huit et dix ou dix et huit soient comparés. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais dans le cas de CopyFile, ce n'est pas le cas.</font></font><br><br><pre> <code class="go hljs">CopyFile(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>) CopyFile(<span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lequel de ces opérateurs sauvegardera votre présentation et lequel la remplacera par la version de la semaine dernière? </font><font style="vertical-align: inherit;">Vous ne pouvez pas le dire avant d'avoir vérifié la documentation. </font><font style="vertical-align: inherit;">Au cours de la révision du code, il n'est pas clair si l'ordre des arguments est correct ou non. </font><font style="vertical-align: inherit;">Encore une fois, regardez la documentation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une solution possible consiste à introduire un type auxiliaire responsable de l'appel correct </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Source <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src Source)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dest </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CopyFile(dest, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(src)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> from Source = <span class="hljs-string"><span class="hljs-string">"presentation.md"</span></span> from.CopyTo(<span class="hljs-string"><span class="hljs-string">"/tmp/backup"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est </font></font><code>CopyFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toujours appelé correctement ici - cela peut être déclaré à l'aide d'un test unitaire - et peut être effectué en privé, ce qui réduit encore plus la probabilité d'une utilisation incorrecte.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Une API avec plusieurs paramètres du même type est difficile à utiliser correctement.</font></font></blockquote><br><a name="6_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2. </font><font style="vertical-align: inherit;">Concevoir une API pour un cas d'utilisation de base</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a quelques années, j'ai fait une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">présentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur l'utilisation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des options fonctionnelles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour rendre l'API plus simple par défaut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'essence de la présentation était que vous deviez développer une API pour le cas d'utilisation principal. </font><font style="vertical-align: inherit;">En d'autres termes, l'API ne doit pas obliger l'utilisateur à fournir des paramètres supplémentaires qui ne l'intéressent pas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.1. </font><font style="vertical-align: inherit;">L'utilisation de nil comme paramètre n'est pas recommandée</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai commencé par dire qu'il ne fallait pas forcer l'utilisateur à fournir des paramètres API qui ne l'intéressaient pas. </font><font style="vertical-align: inherit;">Cela signifie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">concevoir les API pour le cas d'utilisation principal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (option par défaut). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un exemple du package net / http.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-comment"><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls // Serve with handler to handle requests on incoming connections. // Accepted connections are configured to enable TCP keep-alives. // // The handler is typically nil, in which case the DefaultServeMux is used. // // ListenAndServe always returns a non-nil error. func ListenAndServe(addr string, handler Handler) error {</span></span></code> </pre> <br> <code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepte deux paramètres: une adresse TCP pour écouter les connexions entrantes et </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour traiter une requête HTTP entrante. </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permet au deuxième paramètre d'être </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans les commentaires, il est à noter qu'en général, l'objet appelant </font><font style="vertical-align: inherit;">passera </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectivement</font></font></i><font style="vertical-align: inherit;"></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , indiquant une volonté de l'utiliser </font></font><code>http.DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme paramètre implicite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, l'appelant </font></font><code>Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a deux façons de faire de même.</font></font><br><br><pre> <code class="go hljs">http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les deux options font la même chose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette application </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se propage comme un virus. </font><font style="vertical-align: inherit;">Le package a également </font></font><code>http</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une aide </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous pouvez donc imaginer la structure de la fonction </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListenAndServe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> l.Close() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Serve(l, handler) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permet à l'appelant de passer </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour le deuxième paramètre, il </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend également en charge ce comportement. </font><font style="vertical-align: inherit;">En fait, c'est dans la </font></font><code>http.Serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logique implémentée "si le gestionnaire est égal </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, utilisez </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">L'acceptation </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d'un paramètre peut amener l'appelant à penser qu'il peut être transmis </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour les deux paramètres. </font><font style="vertical-align: inherit;">Mais tel</font></font><code>Serve</code> <br><br><pre> <code class="go hljs">http.Serve(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conduit à une terrible panique. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ne mélangez pas les paramètres dans la même signature de fonction </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et non </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'auteur a </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenté de simplifier la vie des utilisateurs d'API pour le cas par défaut, mais la sécurité a été affectée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En présence, </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il </font><font style="vertical-align: inherit;">n'y a </font><font style="vertical-align: inherit;">pas de différence de nombre de lignes entre utilisation explicite et indirecte </font></font><code>DefaultServeMux</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comparé à </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) http.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, http.DefaultServeMux)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vaut-il la peine de garder une ligne? </font></font><br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> root = http.Dir(<span class="hljs-string"><span class="hljs-string">"/htdocs"</span></span>) mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, http.FileServer(root)) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux)</code> </pre> <br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Réfléchissez sérieusement au temps que les fonctions d'assistance permettront au programmeur. </font><font style="vertical-align: inherit;">La clarté vaut mieux que la brièveté.</font></font></blockquote><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Évitez les API publiques avec des paramètres dont seuls les tests ont besoin. </font><font style="vertical-align: inherit;">Évitez d'exporter des API avec des paramètres dont les valeurs ne diffèrent que pendant les tests. </font><font style="vertical-align: inherit;">Au lieu de cela, exportez les fonctions d'encapsuleur qui masquent le transfert de ces paramètres et, dans les tests, utilisez des fonctions d'assistance similaires qui transmettent les valeurs nécessaires au test.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.2.2. </font><font style="vertical-align: inherit;">Utilisez des arguments de longueur variable au lieu de [] T</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Très souvent, une fonction ou une méthode prend une tranche de valeurs. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShutdownVMs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ids []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce n'est qu'un exemple inventé, mais c'est très courant. Le problème est que ces signatures supposent qu'elles seront appelées avec plusieurs enregistrements. Comme l'expérience le montre, ils sont souvent appelés avec un seul argument, qui doit être «compressé» à l'intérieur de la tranche afin de répondre aux exigences de la signature de fonction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, puisque le paramètre </font></font><code>ids</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est une tranche, vous pouvez passer une tranche vide ou zéro à la fonction, et le compilateur sera content. Cela ajoute une charge de test supplémentaire car les tests devraient couvrir de tels cas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour donner un exemple d'une telle classe d'API, j'ai récemment refactorisé la logique qui nécessitait l'installation de certains champs supplémentaires si au moins un des paramètres n'était pas nul. La logique ressemblait à ceci:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> svc.MaxConnections &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxPendingRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> || svc.MaxRetries &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que l'opérateur </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devenait très long, je voulais tirer la logique de validation dans une fonction distincte. </font><font style="vertical-align: inherit;">Voici ce que j'ai trouvé:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(values ...int) bool { for _, v := range values { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela a permis d'indiquer clairement la condition dans laquelle l'unité intérieure sera exécutée: </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) { <span class="hljs-comment"><span class="hljs-comment">// apply the non zero parameters }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il y a un problème avec </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, quelqu'un pourrait l'appeler accidentellement comme ceci:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> anyPositive() { ... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reviendra </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ce n'est pas la pire option. </font><font style="vertical-align: inherit;">Pire si </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retourné </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en l'absence d'arguments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il serait préférable de pouvoir modifier la signature de anyPositive pour garantir qu'au moins un argument est passé à l'appelant. </font><font style="vertical-align: inherit;">Cela peut être fait en combinant les paramètres des arguments normaux et des arguments de longueur variable (varargs):</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero. func anyPositive(first int, rest ...int) bool { if first &gt; 0 { return true } for _, v := range rest { if v &gt; 0 { return true } } return false }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>anyPositive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous ne pouvez pas appeler avec moins d'un argument.</font></font><br><br><a name="6_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.3. </font><font style="vertical-align: inherit;">Laissez les fonctions déterminer le comportement souhaité.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supposons que l'on m'ait donné la tâche d'écrire une fonction qui préserve la structure </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le disque.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      f. func Save(f *os.File, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pourrais écrire une fonction </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui écrit </font></font><code>Document</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans un fichier </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mais il y a quelques problèmes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La signature </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">élimine la possibilité d'enregistrer des données sur le réseau. Si une telle exigence apparaît à l'avenir, la signature de la fonction devra être modifiée, ce qui affectera tous les objets appelants. </font></font><br><br> <code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">également désagréable à tester, car il fonctionne directement avec les fichiers sur disque. Ainsi, pour vérifier son fonctionnement, le test doit lire le contenu du fichier après l'écriture. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et je dois m'assurer qu'il est </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">écrit dans un dossier temporaire puis supprimé. </font></font><br><br> <code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définit également de nombreuses méthodes qui ne sont pas liées </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, par exemple, à la lecture de répertoires et à la vérification si un chemin est un lien symbolique. Eh bien, si la signature</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décrit uniquement les parties pertinentes </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  Que peut-on faire? <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // ReadWriterCloser. func Save(rwc io.ReadWriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'aide de </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">celui </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">ci, vous pouvez appliquer le principe de séparation d'interface - et le redéfinir </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur une interface qui décrit les propriétés plus générales du fichier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après une telle modification, tout type qui implémente l'interface </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être remplacé par le précédent </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela étend simultanément la portée </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et clarifie à l'appelant quels types de méthodes </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont liés à son fonctionnement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et l'auteur </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut plus appeler ces méthodes indépendantes </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il est caché derrière l'interface </font></font><code>io.ReadWriteCloser</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous pouvons étendre encore plus le principe de la séparation des interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord si</font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> suit le principe de la responsabilité unique, il est peu probable qu'il lise le fichier qu'il vient d'écrire pour vérifier son contenu - un autre code devrait le faire. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // WriteCloser. func Save(wc io.WriteCloser, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par conséquent, vous pouvez affiner les spécifications de l'interface pour </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplement écrire et fermer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, le mécanisme de fermeture des threads y </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est un héritage du temps où il fonctionnait avec le fichier. </font><font style="vertical-align: inherit;">La question est de savoir dans quelles circonstances </font></font><code>wc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il sera fermé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que ce </font><font style="vertical-align: inherit;">soit la </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cause de </font></font><code>Close</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manière inconditionnelle, que ce </font><font style="vertical-align: inherit;">soit dans le cas de succès. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela présente un problème pour l'appelant car il peut souhaiter ajouter des données au flux une fois le document écrit.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Save      // Writer. func Save(w io.Writer, doc *Document) error</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La meilleure option est de redéfinir Enregistrer pour ne fonctionner qu'avec </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en sauvant l'opérateur de toutes les autres fonctionnalités, à l'exception de l'écriture de données dans le flux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir appliqué le principe de séparation d'interface, la fonction est devenue à la fois plus spécifique en termes d'exigences (elle n'a besoin que d'un objet où elle peut être écrite), et plus générale en termes de fonctionnalité, puisque maintenant nous pouvons l'utiliser </font></font><code>Save</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour enregistrer des données partout où elle est implémentée </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Gestion des erreurs </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai donné </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plusieurs présentations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">écrit </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaucoup</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur ce sujet sur le blog, donc je ne le répéterai pas. </font><font style="vertical-align: inherit;">Au lieu de cela, je veux couvrir deux autres domaines liés à la gestion des erreurs.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><a name="7_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1. </font><font style="vertical-align: inherit;">Élimine le besoin de gestion des erreurs en supprimant les erreurs elles-mêmes</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai fait de nombreuses suggestions pour améliorer la syntaxe de gestion des erreurs, mais la meilleure option est de ne pas les gérer du tout. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Je ne dis pas «supprimer la gestion des erreurs». </font><font style="vertical-align: inherit;">Je suggère de changer le code afin qu'il n'y ait aucune erreur de traitement.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le récent livre sur la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">philosophie du développement logiciel de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> John Osterhout m'a inspiré pour faire cette suggestion </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'un des chapitres est intitulé «Éliminer les erreurs de la réalité». </font><font style="vertical-align: inherit;">Essayons d'appliquer ce conseil.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.1. </font><font style="vertical-align: inherit;">Nombre de lignes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous allons écrire une fonction pour compter le nombre de lignes dans un fichier. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous suivons les conseils des sections précédentes, </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepte </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, non </font></font><code>*os.File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; c’est déjà la tâche de l’appelant de fournir </font></font><code>io.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le contenu dont nous voulons compter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous créons </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis appelons la méthode en boucle </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en augmentant le compteur, jusqu'à ce que nous atteignions la fin du fichier, puis nous renvoyons le nombre de lignes lues. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au moins, nous voulons écrire un tel code, mais la fonction est gênée par la gestion des erreurs. Par exemple, il y a une construction si étrange:</font></font><br><br><pre> <code class="go hljs"> _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous augmentons le nombre de lignes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avant de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rechercher des erreurs - cela semble étrange. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La raison pour laquelle nous devons l'écrire de cette façon est qu'il </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retournera une erreur s'il rencontre la fin du fichier plus tôt que le caractère de nouvelle ligne. </font><font style="vertical-align: inherit;">Cela peut se produire s'il n'y a pas de nouvelle ligne à la fin du fichier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour essayer de résoudre ce problème, modifiez la logique du compteur de lignes, puis voyez si nous devons quitter la boucle.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cette logique n'est pas encore parfaite, pouvez-vous trouver une erreur?</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous n'avons pas fini de vérifier les erreurs. </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retournera </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quand il rencontrera la fin du fichier. </font><font style="vertical-align: inherit;">C'est la situation attendue, donc pour que </font></font><code>ReadString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous ayez besoin de dire "arrêtez, il n'y a plus rien à lire". </font><font style="vertical-align: inherit;">Par conséquent, avant de renvoyer l'erreur à l'objet appelant </font></font><code>CountLine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vous devez vérifier que l'erreur n'est pas liée à </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis la transmettre, sinon nous revenons </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et disons que tout va bien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je pense que c'est un bon exemple de la thèse de Russ Cox sur la façon dont la gestion des erreurs peut masquer la fonction. </font><font style="vertical-align: inherit;">Regardons la version améliorée.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette version améliorée utilise à la </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous le capot </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise </font></font><code>bufio.Reader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais ajoute un bon niveau d'abstraction, ce qui permet de supprimer la gestion des erreurs.</font></font><br><br><blockquote> <b></b> . <code>bufio.Scanner</code>    ,      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode </font></font><code>sc.Scan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie une valeur </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si le scanner a rencontré une chaîne et n'a pas trouvé d'erreur. Ainsi, le corps de la boucle n'est </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelé que s'il y a une ligne de texte dans le tampon du scanner. Cela signifie que le nouveau </font></font><code>CountLines</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gère les cas lorsqu'il n'y a pas de nouvelle ligne ou lorsque le fichier est vide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, puisqu'il </font></font><code>sc.Scan</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">revient </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'une erreur est détectée, le cycle </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se termine lorsqu'il atteint la fin du fichier ou qu'une erreur est détectée. Le type se </font></font><code>bufio.Scanner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">souvient de la première erreur qu'il a rencontrée, et en utilisant la méthode, </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous pouvons restaurer cette erreur dès que nous quittons la boucle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, il </font></font><code>sc.Err()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prend en charge le traitement </font></font><code>io.EOF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le convertit </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la fin du fichier est atteinte sans erreur.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous rencontrez un traitement d'erreur excessif, essayez d'extraire certaines opérations dans un type d'assistance.</font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1.2. </font><font style="vertical-align: inherit;">Writeresponse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mon deuxième exemple est inspiré de l'article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«Les erreurs sont des valeurs»</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus tôt, nous avons vu des exemples de la façon dont un fichier est ouvert, écrit et fermé. </font><font style="vertical-align: inherit;">Il existe une gestion des erreurs, mais ce n'est pas trop, car les opérations peuvent être encapsulées dans des assistants, tels que </font></font><code>ioutil.ReadFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>ioutil.WriteFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais lorsque vous travaillez avec des protocoles réseau de bas niveau, il est nécessaire de créer une réponse directement à l'aide de primitives d'E / S. </font><font style="vertical-align: inherit;">Dans ce cas, la gestion des erreurs peut devenir intrusive. </font><font style="vertical-align: inherit;">Considérons un fragment d'un serveur HTTP qui crée une réponse HTTP.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commencez par créer la barre d'état avec </font></font><code>fmt.Fprintf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et vérifiez l'erreur. Ensuite, pour chaque rubrique, nous écrivons une clé et une valeur de rubrique, vérifiant à chaque fois une erreur. Enfin, nous complétons la section d'en-tête par une autre </font></font><code>\r\n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, vérifions l'erreur et copions le corps de la réponse au client. Enfin, bien que nous n'ayons pas besoin de vérifier l'erreur </font></font><code>io.Copy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous devons la traduire de deux valeurs de retour à la seule qui retourne </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est beaucoup de travail monotone. Mais vous pouvez faciliter votre tâche en appliquant un petit type d'emballage </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">satisfait le contrat </font></font><code>io.Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il peut donc être utilisé comme emballage. </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmet les enregistrements via la fonction jusqu'à ce qu'une erreur soit détectée. Dans ce cas, il rejette les entrées et renvoie l'erreur précédente.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il est appliqué </font></font><code>errWriter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font></font><code>WriteResponse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la clarté du code est considérablement améliorée. </font><font style="vertical-align: inherit;">Vous n'avez plus besoin de vérifier les erreurs dans chaque opération individuelle. </font><font style="vertical-align: inherit;">Le message d'erreur se déplace à la fin de la fonction en tant que vérification de champ </font></font><code>ew.err</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, évitant la traduction gênante des valeurs io.Copy renvoyées.</font></font><br><br><a name="7_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2. </font><font style="vertical-align: inherit;">Traiter l'erreur une seule fois</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, je tiens à noter que les erreurs ne doivent être traitées qu'une seule fois. </font><font style="vertical-align: inherit;">Le traitement signifie vérifier la signification de l'erreur et prendre une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seule</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décision.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer. func WriteAll(w io.Writer, buf []byte) { w.Write(buf) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous prenez moins d'une décision, vous ignorez l'erreur. </font><font style="vertical-align: inherit;">Comme nous le voyons ici, l'erreur de est </font></font><code>w.WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ignorée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais prendre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus d'une</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décision en réponse à une erreur est également une erreur. </font><font style="vertical-align: inherit;">Voici le code que je rencontre souvent.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"unable to write:"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// annotated error goes to log file return err // unannotated error returned to caller } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet exemple, si une erreur se produit pendant le temps </font></font><code>w.Write</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la ligne est écrite dans le journal et également renvoyée à l'objet appelant, qui, peut-être, le journalisera également et le transmettra, jusqu'au niveau supérieur du programme. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Très probablement, l'appelant fait de même:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainsi, une pile de lignes répétitives est créée dans le journal. </font></font><br><br><pre> <code class="go hljs">unable to write: io.EOF could not write config: io.EOF</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais en haut du programme, vous obtenez une erreur d'origine sans aucun contexte. </font></font><br><br><pre> <code class="go hljs">err := WriteConfig(f, &amp;conf) fmt.Println(err) <span class="hljs-comment"><span class="hljs-comment">// io.EOF</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je souhaite analyser ce sujet plus en détail, car je ne considère pas le problème du renvoi simultané d'une erreur et de l'enregistrement de mes préférences personnelles. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">// oops, forgot to return } if err := WriteAll(w, buf); err != nil { log.Println("could not write config: %v", err) return err } return nil }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je rencontre souvent un problème qu'un programmeur oublie de renvoyer d'une erreur. Comme nous l'avons dit plus tôt, le style de Go est d'utiliser des opérateurs de limites, de vérifier les prérequis lors de l'exécution de la fonction et de revenir tôt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet exemple, l'auteur a vérifié l'erreur, l'a enregistrée, mais a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oublié</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de revenir. Pour cette raison, un problème subtil se pose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le contrat de gestion des erreurs Go indique qu'en présence d'une erreur, aucune hypothèse ne peut être émise sur le contenu des autres valeurs de retour. Comme le marshaling JSON a échoué, le contenu est </font></font><code>buf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inconnu: il peut ne rien contenir, mais pire, il peut contenir un fragment JSON à moitié écrit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que le programmeur a oublié de revenir après avoir vérifié et enregistré l'erreur, le tampon endommagé sera transféré </font></font><code>WriteAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">L'opération est susceptible de réussir et le fichier de configuration ne sera donc pas écrit correctement. </font><font style="vertical-align: inherit;">Cependant, la fonction se termine normalement et le seul signe qu'un problème s'est produit est une ligne dans le journal où le marshaling JSON a échoué, et non un échec d'enregistrement de configuration.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.1. </font><font style="vertical-align: inherit;">Ajout de contexte aux erreurs</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une erreur s'est produite car l'auteur tentait d'ajouter du contexte au message d'erreur. </font><font style="vertical-align: inherit;">Il a tenté de laisser une marque pour indiquer la source de l'erreur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons une autre façon de faire de même </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, conf *Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { buf, err := json.Marshal(conf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not marshal config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := WriteAll(w, buf); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"could not write config: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := w.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"write failed: %v"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous combinez l'enregistrement d'erreur avec le retour sur une seule ligne, il est plus difficile d'oublier de revenir et d'éviter une continuation accidentelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si une erreur d'E / S se produit lors de l'écriture du fichier, la méthode </font></font><code>Error()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">produira quelque chose comme ceci:</font></font><br><br><pre> <code class="go hljs">could not write config: write failed: input/output error</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2.2. </font><font style="vertical-align: inherit;">Erreur d'encapsulation avec github.com/pkg/errors</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le modèle </font></font><code>fmt.Errorf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionne bien pour l'enregistrement </font><font style="vertical-align: inherit;">des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">messages d'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erreur, mais le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type d'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erreur passe par le chemin. </font><font style="vertical-align: inherit;">J'ai soutenu que la gestion des erreurs en tant que valeurs opaques est importante pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projets à </font><i><font style="vertical-align: inherit;">couplage lâche</font></i><font style="vertical-align: inherit;"> , donc le type de l'erreur d'origine ne devrait pas avoir d'importance si nous avons seulement besoin de travailler avec sa valeur:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assurez-vous qu'il n'est pas nul. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affichez-le à l'écran ou enregistrez-le. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il arrive que vous deviez restaurer l'erreur d'origine. </font><font style="vertical-align: inherit;">Pour annoter de telles erreurs, vous pouvez utiliser quelque chose comme mon package </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { f, err := os.Open(path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"open failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> f.Close() buf, err := ioutil.ReadAll(f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"read failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { home := os.Getenv(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>) config, err := ReadFile(filepath.Join(home, <span class="hljs-string"><span class="hljs-string">".settings.xml"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config, errors.WithMessage(err, <span class="hljs-string"><span class="hljs-string">"could not read config"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, le message devient un joli bug de style K &amp; D: </font></font><br><br><pre> <code class="go hljs">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et sa valeur contient un lien vers la raison d'origine. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := ReadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"original error: %T %v\n"</span></span>, errors.Cause(err), errors.Cause(err)) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"stack trace:\n%+v\n"</span></span>, err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ainsi, vous pouvez restaurer l'erreur d'origine et afficher la trace de la pile: </font></font><br><br><pre> <code class="plaintext hljs">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory stack trace: open /Users/dfc/.settings.xml: no such file or directory open failed main.ReadFile /Users/dfc/devel/practical-go/src/errors/readfile2.go:16 main.ReadConfig /Users/dfc/devel/practical-go/src/errors/readfile2.go:29 main.main /Users/dfc/devel/practical-go/src/errors/readfile2.go:35 runtime.main /Users/dfc/go/src/runtime/proc.go:201 runtime.goexit /Users/dfc/go/src/runtime/asm_amd64.s:1333 could not read config</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le package </font></font><code>errors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous permet d'ajouter du contexte aux valeurs d'erreur dans un format pratique pour une personne et une machine. </font><font style="vertical-align: inherit;">Lors d'une récente présentation, je vous ai dit que dans la prochaine version de Go, un tel wrapper apparaîtra dans la bibliothèque standard.</font></font><br><br><a name="8"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Concurrence </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go est souvent choisi en raison de ses capacités de concurrence. Les développeurs ont fait beaucoup pour augmenter son efficacité (en termes de ressources matérielles) et sa productivité, mais les fonctions de parallélisme de Go peuvent être utilisées pour écrire du code qui n'est ni productif ni fiable. À la fin de l'article, je veux donner quelques conseils sur la façon d'éviter certains des pièges des fonctions de concurrence de Go. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prise en charge simultanée de premier ordre de Go est fournie par des canaux, ainsi que des instructions </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si vous avez étudié la théorie du Go dans des manuels ou dans une université, vous avez peut-être remarqué que la section sur le parallélisme est toujours l'une des dernières du cours. </font><font style="vertical-align: inherit;">Notre article n'est pas différent: j'ai décidé de parler du parallélisme à la fin, comme quelque chose en plus des compétences habituelles que le programmeur Go devrait apprendre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe une certaine dichotomie, car la caractéristique principale de Go est notre modèle simple et facile de parallélisme. </font><font style="vertical-align: inherit;">En tant que produit, notre langue se vend aux dépens de presque cette seule fonction. </font><font style="vertical-align: inherit;">D'un autre côté, la simultanéité n'est en fait pas si facile à utiliser, sinon les auteurs n'en auraient pas fait le dernier chapitre de leurs livres, et nous n'aurions pas regardé avec regret notre code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette section traite de certains des pièges de l'utilisation naïve des fonctions de concurrence Go.</font></font><br><br><a name="8_1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.1. </font><font style="vertical-align: inherit;">Faites du travail tout le temps.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quel est le problème avec ce programme? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le programme fait ce que nous voulions: il sert un simple serveur Web. </font><font style="vertical-align: inherit;">En même temps, il passe du temps CPU dans une boucle infinie, car </font></font><code>for{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la dernière ligne, il </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloque gorutin main, sans effectuer d'E / S, il n'y a pas d'attente pour bloquer, envoyer ou recevoir des messages, ou une sorte de connexion avec le sheduler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que le temps d'exécution Go est généralement servi par un sheduler, ce programme s'exécute de manière insensée sur le processeur et peut se retrouver dans un verrou actif (live-lock). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment y remédier? </font><font style="vertical-align: inherit;">Voici une option.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { runtime.Gosched() } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela peut sembler idiot, mais c'est une solution courante qui me vient à l'esprit dans la vraie vie. </font><font style="vertical-align: inherit;">Il s'agit d'un symptôme d'une mauvaise compréhension du problème sous-jacent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous êtes un peu plus expérimenté avec Go, vous pouvez écrire quelque chose comme ça.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une instruction vide est </font></font><code>select</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloquée pour toujours. </font><font style="vertical-align: inherit;">C'est utile, car maintenant nous ne faisons pas tourner le processeur entier juste pour un appel </font></font><code>runtime.GoSched()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cependant, nous ne traitons que le symptôme, pas la cause. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je veux vous montrer une autre solution qui, je l'espère, vous est déjà venue à l'esprit. </font><font style="vertical-align: inherit;">Au lieu de courir </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans goroutine, laissant le problème principal de goroutine, exécutez simplement </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le goroutine principal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si vous quittez la fonction </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le programme Go se termine inconditionnellement, indépendamment de ce que font les autres goroutines en cours d'exécution pendant l'exécution du programme.</font></font></blockquote><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintln(w, <span class="hljs-string"><span class="hljs-string">"Hello, GopherCon SG"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est donc mon premier conseil: si le goroutin ne peut pas progresser tant qu'il n'a pas reçu le résultat d'un autre, alors il est souvent plus facile de faire le travail soi-même, plutôt que de le déléguer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela élimine souvent beaucoup de suivi d'état et de manipulation de canal nécessaires pour retransférer le résultat de la goroutine à l'initiateur du processus.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De nombreux programmeurs Go abusent des goroutines, surtout au début. </font><font style="vertical-align: inherit;">Comme tout le reste de la vie, la clé du succès est la modération.</font></font></blockquote><br><a name="8_2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.2. </font><font style="vertical-align: inherit;">Laisser le parallélisme à l'appelant</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelle est la différence entre les deux API? </font></font><br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns the contents of dir. func ListDirectory(dir string) ([]string, error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ListDirectory returns a channel over which // directory entries will be published. When the list // of entries is exhausted, the channel will be closed. func ListDirectory(dir string) chan string</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous mentionnons les différences évidentes: le premier exemple lit le répertoire dans une tranche, puis retourne la tranche entière ou l'erreur en cas de problème. Cela se produit de manière synchrone, l'appelant bloque </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'à ce que toutes les entrées du répertoire aient été lues. Selon la taille du répertoire, cela peut prendre beaucoup de temps et potentiellement beaucoup de mémoire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prenons le deuxième exemple. C'est un peu plus comme la programmation Go classique, ici elle </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie le canal par lequel les entrées du répertoire seront transmises. Lorsque le canal est fermé, cela signifie qu'il n'y a plus d'entrées de catalogue. Puisque le remplissage du canal a lieu après le retour </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, on peut supposer que les goroutines commencent à remplir le canal.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dans la deuxième option, il n'est pas nécessaire d'utiliser réellement goroutine: vous pouvez sélectionner un canal suffisant pour stocker toutes les entrées du répertoire sans les bloquer, le remplir, le fermer, puis renvoyer le canal à l'appelant. </font><font style="vertical-align: inherit;">Mais cela est peu probable, car dans ce cas, les mêmes problèmes se poseront lors de l'utilisation d'une grande quantité de mémoire pour mettre en mémoire tampon tous les résultats dans le canal.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version du </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canal a deux autres problèmes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation d'un canal fermé comme signal qu'il n'y a plus d'éléments à traiter </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut pas informer l'appelant d'un ensemble d'éléments incomplet en raison d'une erreur. </font><font style="vertical-align: inherit;">L'appelant n'a aucun moyen de transmettre la différence entre un répertoire vide et une erreur. </font><font style="vertical-align: inherit;">Dans les deux cas, il semble que la chaîne sera immédiatement fermée.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'appelant doit continuer à lire à partir du canal lorsqu'il est fermé, car c'est la seule façon de comprendre que le goroutine de remplissage du canal a cessé de fonctionner. </font><font style="vertical-align: inherit;">Il s'agit d'une sérieuse restriction d'utilisation </font></font><code>ListDirectory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: l'appelant passe du temps à lire sur le canal, même s'il a reçu toutes les données nécessaires. </font><font style="vertical-align: inherit;">C'est probablement plus efficace en termes d'utilisation de la mémoire pour les répertoires moyens et grands, mais la méthode n'est pas plus rapide que la méthode basée sur la tranche d'origine.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans les deux cas, la solution consiste à utiliser un rappel: une fonction qui est appelée dans le contexte de chaque entrée de répertoire lors de son exécution. </font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sans surprise, la fonction </font></font><code>filepath.WalkDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctionne de cette façon.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si votre fonction lance goroutine, vous devez fournir à l'appelant un moyen d'arrêter explicitement cette routine. </font><font style="vertical-align: inherit;">Il est souvent plus facile de laisser le mode d'exécution asynchrone à l'appelant.</font></font></blockquote><br><a name="8_3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.3. </font><font style="vertical-align: inherit;">Ne jamais courir de goroutine sans savoir quand elle s'arrêtera</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans l'exemple précédent, la goroutine a été utilisée inutilement. </font><font style="vertical-align: inherit;">Mais l'une des principales forces de Go est ses capacités de concurrence de première classe. </font><font style="vertical-align: inherit;">En effet, dans de nombreux cas, un travail parallèle est tout à fait approprié, et il est alors nécessaire d'utiliser des goroutines. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette application simple sert le trafic http sur deux ports différents: le port 8080 pour le trafic d'application et le port 8001 pour l'accès au point de terminaison </font></font><code>/debug/pprof</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> _ <span class="hljs-string"><span class="hljs-string">"net/http/pprof"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) <span class="hljs-comment"><span class="hljs-comment">// debug http.ListenAndServe("0.0.0.0:8080", mux) // app traffic }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que le programme ne soit pas compliqué, il est le fondement d'une véritable application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'application dans sa forme actuelle présente plusieurs problèmes qui apparaîtront au fur et à mesure de leur croissance, alors examinons immédiatement certains d'entre eux.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() serveApp() }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gestionnaires de </font><font style="vertical-align: inherit;">rupture </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de fonctions distinctes, nous avons séparé les de </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous avons également suivi les conseils et précédent assurés </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">laisser la tâche d'assurer le parallélisme de l'appelant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais il y a quelques problèmes avec la performance d'un tel programme. </font><font style="vertical-align: inherit;">Si nous quittons </font></font><code>serveApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puis </font><font style="vertical-align: inherit;">quittons </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le programme se termine et sera redémarré par le gestionnaire de processus.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tout comme les fonctions de Go laissent le parallélisme à l'appelant, les applications doivent cesser de surveiller leur état et redémarrer le programme qui les a appelées. </font><font style="vertical-align: inherit;">Ne rendez pas vos applications responsables du redémarrage elles-mêmes: cette procédure est mieux gérée depuis l'extérieur de l'application.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commence dans un goroutine séparé, et en cas de sortie, le goroutine se termine, tandis que le reste du programme continue. </font><font style="vertical-align: inherit;">Vos développeurs n'aimeront pas le fait que vous ne puissiez pas obtenir de statistiques sur les applications, car le gestionnaire </font></font><code>/debug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a longtemps cessé de fonctionner. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons nous assurer que l'application est fermée si </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> goroutine le servant </font><font style="vertical-align: inherit;">s'arrête </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveDebug() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> serveApp() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>serverApp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ils </font></font><code>serveDebug</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vérifient les erreurs </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et, si nécessaire, les appellent </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Puisque les deux gestionnaires travaillent dans des goroutines, nous établissons la routine principale en </font></font><code>select{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette approche pose un certain nombre de problèmes:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">revient avec une erreur </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il n'y aura pas d'appel </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le service HTTP sur ce port se fermera sans arrêter l'application.</font></font><br></li><li> <code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les appels </font></font><code>os.Exit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui quittent inconditionnellement le programme; </font><font style="vertical-align: inherit;">les appels différés ne fonctionneront pas, les autres goroutines ne seront pas informés de la fermeture, le programme s'arrêtera simplement. </font><font style="vertical-align: inherit;">Cela rend difficile l'écriture de tests pour ces fonctions.</font></font></li></ol><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Utiliser uniquement </font></font><code>log.Fatal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur les fonctions </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, nous voulons transmettre toute erreur qui se produit au créateur de la goroutine, afin qu'il puisse découvrir pourquoi elle a arrêté et terminé proprement le processus.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { mux := http.NewServeMux() mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span></span></span> { fmt.Fprintln(resp, <span class="hljs-string"><span class="hljs-string">"Hello, QCon!"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"0.0.0.0:8080"</span></span>, mux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serveDebug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">"127.0.0.1:8001"</span></span>, http.DefaultServeMux) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveDebug() }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { done &lt;- serveApp() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>(done); i++ { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := &lt;-done; err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"error: %v"</span></span>, err) } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le statut de retour de la goroutine peut être obtenu via le canal. La taille du canal est égale au nombre de goroutines que nous voulons contrôler, donc l'envoi vers le canal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne sera pas bloqué, car cela bloquera l'arrêt des goroutines et provoquera une fuite. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que le canal </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne peut pas être fermé en toute sécurité, nous ne pouvons pas utiliser l'idiome pour le cycle du canal </font></font><code>for range</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'à ce que tous les goroutines aient signalé. Au lieu de cela, nous exécutons tous les goroutines en cours d'exécution dans un cycle, qui est égal à la capacité du canal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant un moyen de quitter proprement chaque goroutine et de corriger toutes les erreurs qu'ils rencontrent. Il ne reste plus qu'à envoyer un signal pour terminer le travail du premier goroutine à tout le monde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'appel à</font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à propos de l'achèvement, j'ai donc enveloppé cette logique dans une fonction d'aide. </font><font style="vertical-align: inherit;">L'assistant </font></font><code>serve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accepte l'adresse et </font></font><code>http.Handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, de même </font></font><code>http.ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le canal </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous utilisons pour exécuter la méthode </font></font><code>Shutdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, handler http.Handler, stop &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { s := http.Server{ Addr: addr, Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { &lt;-stop <span class="hljs-comment"><span class="hljs-comment">// wait for stop signal s.Shutdown(context.Background()) }() return s.ListenAndServe() } func serveApp(stop &lt;-chan struct{}) error { mux := http.NewServeMux() mux.HandleFunc("/", func(resp http.ResponseWriter, req *http.Request) { fmt.Fprintln(resp, "Hello, QCon!") }) return serve("0.0.0.0:8080", mux, stop) } func serveDebug(stop &lt;-chan struct{}) error { return serve("127.0.0.1:8001", http.DefaultServeMux, stop) } func main() { done := make(chan error, 2) stop := make(chan struct{}) go func() { done &lt;- serveDebug(stop) }() go func() { done &lt;- serveApp(stop) }() var stopped bool for i := 0; i &lt; cap(done); i++ { if err := &lt;-done; err != nil { fmt.Println("error: %v", err) } if !stopped { stopped = true close(stop) } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, pour chaque valeur du canal, </font></font><code>done</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous </font></font><code>stop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fermons le </font><font style="vertical-align: inherit;">canal </font><font style="vertical-align: inherit;">, ce qui fait que chaque gorutine sur ce canal se ferme </font></font><code>http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">À son tour, cela conduit à un retour de tous les goroutines restants </font></font><code>ListenAndServe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lorsque tous les gorutins en cours d'exécution se sont arrêtés, il </font></font><code>main.main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se termine et le processus s'arrête proprement.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Astuce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Écrire une telle logique par vous-même est un travail répétitif et le risque d'erreurs. </font><font style="vertical-align: inherit;">Regardez quelque chose comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce package</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui fera la plupart du travail pour vous.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441842/">https://habr.com/ru/post/fr441842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441826/index.html">Ce qui se passe sur le marché du streaming audio: discuter du développement des plateformes de streaming</a></li>
<li><a href="../fr441830/index.html">Guide de l'utilisateur Kibana. Visualisation. Partie 4</a></li>
<li><a href="../fr441832/index.html">Qui est le chef de projet de l'avis du propriétaire d'entreprise et comment y faire face</a></li>
<li><a href="../fr441834/index.html">Ne prenez pas au travail. Mais que faire si l'affaire est en vous?</a></li>
<li><a href="../fr441836/index.html">One Cloud Story: Huawei + 3data = Cloud</a></li>
<li><a href="../fr441844/index.html">iRobot Scooba: expérience et solutions aux problèmes courants d'un robot de lavage</a></li>
<li><a href="../fr441848/index.html">Stages pour développeurs à Avito: missions de combat et travail avec des mentors expérimentés</a></li>
<li><a href="../fr441850/index.html">Dire la fortune sur les réseaux de neurones: si l'auteur lui-même l'a noté dans les commentaires sur le post</a></li>
<li><a href="../fr441852/index.html">42 Silicon Valley: comment être sélectionné</a></li>
<li><a href="../fr441854/index.html">REPOS? Prenez un JSON-RPC stupide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>