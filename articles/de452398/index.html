<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëâüèΩ üéå üç≠ EFORTH f√ºr programmierbaren Rechner üíáüèº üìå üóÇÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der erste Artikel in der 161eForth v0.5b-Reihe, der hier endet: habr.com/en/post/452572 

 Der EFORTH-√úbersetzer ist jetzt auch auf dem inl√§n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>EFORTH f√ºr programmierbaren Rechner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452398/">  <i>Dies ist der erste Artikel in der 161eForth v0.5b-Reihe, der hier endet:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/en/post/452572</a> <br><br>  Der EFORTH-√úbersetzer ist jetzt auch auf dem inl√§ndischen MK-161-Elektronikrechner verf√ºgbar!  Am 17. Mai hat Version v0.5b meine Tests sowie f√ºnf TEST-TEST4-Authoring-Tests erfolgreich bestanden.  Ich habe erreicht, was allein getan werden kann, aber ich denke, dies ist nur die halbe Miete.  Es ist an der Zeit, der Community ein neues Tool vorzustellen, indem der 161eForth-Code f√ºr √∂ffentliche Tests ge√∂ffnet wird.  Ich habe eine Liste, was ich verbessern und wo ich "an Stabilit√§t arbeiten" kann.  Ihre Vorschl√§ge und Kommentare werden bei Abschluss der Arbeiten und der Ver√∂ffentlichung von Version 1.0 ber√ºcksichtigt <br><br>  Bei der Portierung der neuesten Version von eForth auf die heimische Plattform wurden zwei Hindernisse erfolgreich √ºberwunden - die relativ niedrige Geschwindigkeit der 8-Bit-Maschine, die in ihrer eigenen Eingabesprache programmiert ist, und die bescheidene Menge an verf√ºgbarem Bin√§rspeicher (siehe 2.4.1), nur 4096 Byte. <br><img src="https://habrastorage.org/webt/lx/76/pw/lx76pw2yfjmfnqz4wxg9pp_m6ya.jpeg"><br><a name="habracut"></a><br>  Beim Schreiben von 161eForth wurden vorgefertigte L√∂sungen f√ºr Callisto, die Eingabesprache der n√§chsten Generation f√ºr inl√§ndische PMK, verwendet.  Dies ist eine Technologie zur Implementierung einer Fort-Maschine √ºber der dezimalen ALU und der ‚ÄûHarvard‚Äú -Architektur, Konsolentreibern und einem alphanumerischen Tastaturlayout sowie einem darauf basierenden Software-Terminal, das √ºber die serielle RS-232-Schnittstelle betrieben wird.  Zus√§tzlich zu Electronics MK-161 und der 161eForth-Distribution ben√∂tigen Sie m√∂glicherweise eine selbstgemachte Patch-Tastatur, auf der die Buchstaben des russischen und englischen Alphabets auf den Tasten signiert sind.  Die Buchstaben sind alphabetisch Zeile f√ºr Zeile von links nach rechts und von oben nach unten angeordnet. <br><img src="https://habrastorage.org/webt/ff/pu/ry/ffpury7pflujlbysn28jipoylgg.png"><br><br>  Dr. Chen-Hanson Ting, Autor moderner Versionen von eForth, betont in seinem Buch [1], wie wichtig es ist, die beiden Komponenten des Forts zu verstehen.  Dies ist ein interner ("Adresse") Dolmetscher, mit dem das Ger√§t den gen√§hten Code von Fort ausf√ºhren kann, und ein externer ("Text") Dolmetscher, der f√ºr den Dialog mit einer Person verantwortlich ist. <br><br>  In zwei Artikeln werde ich detailliert auf die radikalsten L√∂sungen eingehen, die bei der Implementierung jedes dieser beiden Interpreten bei Electronics verwendet werden.  Das Erlernen dieser L√∂sungen kann n√ºtzlich und inspirierend sein, um eForth auf andere Ger√§te mit begrenztem Speicher und begrenzter Leistung zu migrieren.  Das Verst√§ndnis der Artikel hilft bei einer ersten Einf√ºhrung in programmierbare Mikrokalkulatoren (PMCs) und Fort.  Ich werde schwierige Momente erkl√§ren, die nur f√ºr Electronics MK und den eForth-√úbersetzer gelten. <br><br>  Zun√§chst werden die W√∂rter eForth in allgemein und systemisch unterteilt.  <b>Die Gr√∂√üe der Buchstaben ist wichtig.</b>  <b>Die Namen gew√∂hnlicher W√∂rter werden in Gro√übuchstaben und in Kleinbuchstaben definiert.</b>  Ich habe meine Innovationen auch in eForth in Kleinbuchstaben gemacht.  Der Autor von eForth schl√§gt vor, den Hauptdialog im CAPS-Modus durchzuf√ºhren.  Wenn Sie das Systemwort verwenden m√ºssen, stellen Sie die Zeit auf Kleinbuchstaben um (FP-Tastenkombination). <br><br>  In dem Artikel werden alle W√∂rter in Gro√übuchstaben geschrieben, um sich vom Text abzuheben.  In mehreren fr√ºhen eForth-Implementierungen wurden Systemwort-Header ausgeschlossen und nicht vom Befehl WORDS ausgegeben.  Dies hat dazu beigetragen, das Erscheinungsbild von eForth zu vereinfachen und die Aufmerksamkeit derjenigen zu sparen, die Fort zum ersten Mal verwenden.  In 161eForth wurden die √úberschriften dieser W√∂rter haupts√§chlich aufgrund des Vorhandenseins des SEE-Doppelpunkt-Wortdekompilierers gespeichert (siehe Video Nr. 3 am Ende des Artikels), der die Namen von Systemw√∂rtern nicht anzeigt, wenn ihre √úberschriften entfernt werden. <br><br>  Um den Artikel zu optimieren und als Referenz n√ºtzlich zu machen, musste ich mehrere Begriffe verwenden, bevor ich sie definierte.  Fort- und PMK-Profis sollten mit diesen Begriffen vertraut sein.  Anf√§nger m√ºssen manchmal in den benachbarten Abschnitten nachsehen (ich setze die Links an die richtigen Stellen) oder den Artikel ein paar Mal neu lesen. <br><br>  161eForth selbst ist hier zusammen mit dem Quelltext, einer grafischen Bildschirmtastatur und help words.txt mit einer Beschreibung aller implementierten W√∂rter dargestellt: <a href="">http://the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  Ich habe auch 5 kleine Videos auf YouTube gepostet, die die Funktionsweise des 161eForth f√ºr diejenigen veranschaulichen, die den MK-161 nicht haben.  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die gesamte Wiedergabeliste auf YouTube ansehen</a> .  Unten ist der erste von ihnen, die restlichen 4 am Ende des Artikels. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RxarUWHdNTE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  eForth und seine Umsetzung </h2><br>  eForth wurde als moderner Ersatz f√ºr den weithin bekannten fig-Fort-√úbersetzer entwickelt.  F√ºr die √úbertragung auf den MK-161 habe ich eine 32-Bit-Version 5.2 des 86eForth-√úbersetzers mit indirekt gen√§htem Code ausgew√§hlt, die 2016 auf MASM Assembler f√ºr das Windows-Betriebssystem geschrieben wurde.  Diese Version wird in der dritten Ausgabe von eForth und Zen [1] ausf√ºhrlich beschrieben.  Wenn Sie Englisch sprechen, empfehle ich Ihnen, dieses Buch zu finden und zu studieren. Es ist sehr n√ºtzlich, um 161eForth zu verstehen. <br><br>  In einem pers√∂nlichen Brief best√§tigte der Autor, dass 86eForth502.asm aus diesem Buch die neueste Version von eForth ist.  Im Internet finden Sie viele englischsprachige Informationen zu diesem und fr√ºheren Versionen von eForth. <br><br>  Die Entwicklung von eForth folgte einem wissenschaftlichen Weg, den Professor Wirth am Beispiel seiner Programmiersprache Oberon lehrte.  Jede nachfolgende Version von eForth war eine Vereinfachung der vorherigen Version.  Alles, worauf verzichtet werden kann, wurde von der Zunge entfernt.  Es bleibt eine sorgf√§ltig durchdachte Reihe starker, ausdrucksstarker Sprachkonstrukte √ºbrig, deren Leistungsf√§higkeit an mehr als 40 eForth-Implementierungen f√ºr verschiedene Plattformen getestet wurde.  Jetzt auf dem Rechner! <br><br>  Als minimalistischer Fort-Dialekt will eForth nicht das Rennen gegen das kleinste Fort gewinnen.  Die von ihm angebotenen W√∂rter sind sehr praktisch und k√∂nnen vom Programmierer leicht in die f√ºr seine Aufgaben erforderliche Richtung erweitert werden. <br><br>  Die erste Version von eForth wurde 1990 in MASM Assembler f√ºr 8086-Prozessoren ver√∂ffentlicht und arbeitete unter MS-DOS.  Es enthielt 31 maschinenabh√§ngige Kernw√∂rter und 191 √ºbergeordnete W√∂rter.  Die Idee war einfach: Sie √ºbersetzen nur 31 W√∂rter in Ihren Assembler und erhalten eForth sofort auf Ihrem Computer. <br><br>  Dieser Ansatz wurde im Internet kritisiert, da die Minimierung der Anzahl der W√∂rter im Assembler zu einer √§u√üerst geringen Leistung f√ºr eingebettete Systeme gef√ºhrt hat.  Bereits in der zweiten Version von eForth wurde die maximale Anzahl von W√∂rtern in Assembler implementiert, was die Neigung nicht nur zu einem leicht tragbaren, sondern auch zu einem praktischen Programmiersystem begradigte. <br><br>  Bill Munch, der urspr√ºngliche Autor von eForth, und sein Kollege Dr. Chen-Hanson Ting ver√∂ffentlichten mehrere Jahre lang parallel ihre eForth-Ver√∂ffentlichungen.  Jede Version hatte ihre eigenen Eigenschaften.  Die eForth-Optionen f√ºr verschiedene Plattformen wurden auch von anderen Programmierern eingef√ºhrt. <br><br>  Die 2016 ver√∂ffentlichte Version 5.2 enth√§lt 71 W√∂rter ‚ÄûCode‚Äú und 110 W√∂rter ‚ÄûDoppelpunkt‚Äú.  Ein Vierteljahrhundert der Suche nach dem Ideal hat zu einer signifikanten Reduzierung der Gesamtzahl der W√∂rter gef√ºhrt.  Gleichzeitig stieg aus Leistungsgr√ºnden der Prozentsatz der auf einer niedrigen Ebene implementierten W√∂rter. <br><br>  Der vorgeschlagene 161eForth genie√üt die gro√üz√ºgigen Vorteile dieses Fortschritts, gibt jedoch nicht vor, die Fernleitung weiterzuentwickeln.  Meine Implementierung stellt dem Programmierer alle in Version 5.2 vorhandenen Tools zur Verf√ºgung.  Wenn die MK-161-Architektur die Implementierung einiger 86eForth-W√∂rter unm√∂glich oder bedeutungslos macht, anstatt den √úberschuss wegzuwerfen, gebe ich den Programmierern einen vollst√§ndigen Ersatz, der dem ANSI / ISO-Standard [4] entnommen ist.  Wer Minimalismus sucht, kann selbst√§ndig ‚Äûzus√§tzliche‚Äú W√∂rter wegwerfen, da 161eForth traditionell mit Quellcode geliefert wird. <br><br>  Bei der Implementierung von eForth habe ich mich an das Verst√§ndnis des Autors gehalten.  Zum Beispiel sollte meiner Meinung nach eine FOR NEXT-Schleife mit einem Anfangswert von n genau n-mal ausgef√ºhrt werden.  Die gleiche Schlussfolgerung kam schlie√ülich Chuck Moore, der Autor der Sprachen Forth und colorForth.  Leider verwendet eForth eine veraltete Konvention und f√ºhrt einen solchen Zyklus n + 1 Mal mit einem Z√§hler von n bis 0 aus. Ich habe diesen und einige andere M√§ngel nicht behoben und die 161eForth-Kompatibilit√§t mit Implementierungen f√ºr andere Plattformen bevorzugt. <br><br>  Da 161eForth mit Ausnahme der Werkssprache das erste praktische On-Board-Programmiersystem f√ºr die MK-161-Elektronik ist, habe ich die lange Geschichte von eForth nachverfolgt und einige W√∂rter in die Sprache zur√ºckgegeben, die auf anderen Plattformen n√ºtzlich waren und jetzt m√∂glicherweise gefragt sind. <br><br>  Beispielsweise enth√§lt die neu-alte Variable 'BOOT' das Token (siehe 3.1) des Wortes, das zuerst ausgef√ºhrt wird, nachdem die Umgebung initialisiert wurde, aber bevor der Dialog beginnt.  Standardm√§√üig enth√§lt 'BOOT ein TLOAD-Token zum Interpretieren von Code aus dem ‚ÄûTextbereich‚Äú (siehe 2.4.2).  Dies erm√∂glicht es dem Programmierer, eForth f√ºr sich selbst anzupassen, ohne die Umgebung neu zu kompilieren, was an Bord der "Electronics" immer noch nicht m√∂glich ist. <br><br>  Die vorrangigen Aufgaben der Implementierung waren das Speichern von Bin√§rspeicher (siehe 2.4.1) und die Verbesserung der Leistung.  Ihre L√∂sung f√ºhrte zu einer dramatischen Verringerung der Anzahl von W√∂rtern auf hoher Ebene, da ihr Code diesen wertvollen Speicher belegt, da die Anzahl der im billigen Programmspeicher implementierten schnellen Kernw√∂rter zunimmt (siehe 2.4.3). <br><br>  Infolgedessen enth√§lt 161eForth 129 Codew√∂rter, 78 √ºbergeordnete W√∂rter und belegt 1816 Byte MK-161-Bin√§rspeicher, dh weniger als die H√§lfte davon.  Dies gibt Hoffnung auf die Metakompilierung seines hochrangigen Teils direkt an Bord der Elektronik. <br><br>  Der Quellcode f√ºr eForth MK-161 ist in zwei gro√üe Teile unterteilt.  Der im MK-161-Befehlssystem geschriebene Kern ist in der Datei eForth0.mkl enthalten.  √úbergeordnete W√∂rter werden in SP-Forth definiert und in der Datei eForth.f abgelegt. <br><br>  Die Distribution hat auch eine Hilfedatei words.txt, die alle 161eForth-W√∂rter mit Stack-Notation und einer kurzen Erkl√§rung in einer Zeile dokumentiert. <br><br><h3>  1.1 Der Quellcode des Kernels eForth0.mkl </h3><br>  Der eForth-Kern enth√§lt ausf√ºhrbaren Code, der im Speicher von MK-161-Programmen (siehe 2.4.3) ausgef√ºhrt wird und auf einem Computer mit Standardmitteln, z. B. dem propriet√§ren MKL2MKP-Compiler, in die Datei eForth0.mkp kompiliert wird. <br><br>  Der in der Datei eForth0.mkl enthaltene Kernel-Quellcode ist in <i>lateinischer Mnemonik geschrieben</i> .  Beispielsweise wird in dieser Mnemonik ein IPE-Befehl zum Lesen des Registers E (auch bekannt als R14) als RME geschrieben.  Lateinische Mnemonik ist f√ºr die Besitzer der sowjetischen PMK ungew√∂hnlich und eignet sich zum Tippen √ºber eine Computertastatur.  In der Tat ist es einfacher, seltsame FX ^ 2 zu tippen, als es aus Kindheits-Fx¬≤ bekannt ist. <br><br>  Die Datei eForth0.mkp ist eine Kernel-Voreinstellung.  Zus√§tzlich zum Code der Grundelemente enth√§lt es einen Kernel-Header und eine Tabelle mit Namen tblNames, die eForth.f w√§hrend der Decodierung in Dezimalregister √ºbertr√§gt (siehe 2.4.4).  Auf der Grundlage von eForth0.mkp wird der eForth.mkp-Kern erstellt (siehe 2.4.3), daher muss eForth0.mkl zuerst kompiliert werden. <br><br><h3>  1.2 Quellcode f√ºr √ºbergeordnete W√∂rter eForth.f </h3><br>  Die Datei eForth.f wird der Eingabe des wunderbaren inl√§ndischen Compilers SP-Forth [5] zugef√ºhrt.  Die Datei enth√§lt Definitionen aller √ºbergeordneten W√∂rter.  Im Laufe der Zeit k√∂nnen sie auf dem eForth selbst identifiziert und m√∂glicherweise direkt an Bord der Electronics MK-161 kompiliert werden. <br><br>  W√§hrend der Kompilierung liest eForth.f das Kernleerzeichen eForth0.mkp und erstellt mit seiner Hilfe drei Dateien im aktuellen Verzeichnis zum anschlie√üenden Laden in MK-161: eForth.mkp, eForth.mkd und eForth.mkb.  Es ist eForth.mkb, das die Hauptteile von W√∂rtern auf hoher Ebene enth√§lt, obwohl sich ihre √úberschriften in der Datei eForth.mkd befinden. <br><br>  Die vierte Datei, eForth.mkt, wird manuell in eForth geschrieben und kann mit dem integrierten Texteditor an Bord des MK-161 bearbeitet werden.  Jede dieser vier Dateien werde ich weiter unten genauer analysieren (siehe 2.4). <br><br><h2>  2. Elektronik MK-161 </h2><br>  Ein Hersteller aus Nowosibirsk nennt den MK-161 ein altes Akronym.  Das war der Name der allerersten Taschenrechner in der UdSSR.  Das Befehlssystem MK-161 erbt das Befehlssystem der sowjetischen Taschenrechner "Electronics B3-34" und "Electronics MK-61".  Dies bedeutet, dass Programme, die f√ºr sowjetische Taschenrechner geschrieben wurden, ohne √Ñnderungen oder mit geringf√ºgigen √Ñnderungen auf dem MK-161 ausgef√ºhrt werden. <br><br>  Das Gegenteil ist nicht wahr.  eForth wird nicht zur sowjetischen PMK gehen, weil  verwendet viele Ressourcen, die zuerst im MK-152/161 erschienen sind und in fr√ºheren Modellen der Serie nicht verf√ºgbar waren. <br><br>  Betrachten Sie die Merkmale der Eingabesprache und -architektur des MK-161, die 161eForth (im Folgenden einfach als eForth bezeichnet) beeinflussten und der diskutierten Implementierung von eForth einen ‚Äûrussischen Akzent‚Äú verliehen. <br><br>  Das erste dieser Merkmale ist die <b>Vereinbarung ‚ÄûSenior at Junior Address‚Äú, die</b> in MK-161 konsequent beibehalten wird.  Beispielsweise wird die Zahl 1000 = 3 √ó 256 + 232 in zwei aufeinanderfolgenden Bytes wie 3 und 232 geschrieben. <br><br><h3>  2.1 Indirekte Adressierung </h3><br>  Programmierung Sowjetische PMK h√∂rte von indirekter Adressierung.  F√ºr die <i>direkte Adressierung geben</i> wir explizit die Registernummer <i>an,</i> auf die wir uns beziehen.  Zum Beispiel ber√ºcksichtigt   44 den Inhalt des Registers 44. Mit der Taste , die in MK-152 erschien, wird auf Register mit der Nummer 15 und mehr zugegriffen - diese Register fehlten im sowjetischen PMK. <br><br>  Bei der <i>indirekten Adressierung ist die</i> Nummer des erforderlichen Registers nicht im Voraus bekannt.  Diese Nummer befindet sich in einem anderen Register.  Wenn beispielsweise Register 8 die Nummer 44 enth√§lt, ber√ºcksichtigt der Befehl K PI 8 den Inhalt von Register 44 (R44). <br><br>  Die Tasten K und P k√∂nnen kombiniert werden.  Beispielsweise √ºbertr√§gt der Befehl R K BP 20 die Steuerung (GOTO in Latin Mnemonics) an die in R20 gespeicherte Adresse. <br><br>  Die Funktion, die sich f√ºr den internen eForth-Interpreter als wichtig herausstellte, h√§ngt mit der vorl√§ufigen Erh√∂hung / Verringerung der Register w√§hrend der indirekten Adressierung zusammen.  Diese Funktion wurde von der sowjetischen PMK geerbt. <br><br>  Beispielsweise reduzieren die indirekten Lesebefehle KI 0, KI 1, KI 2 und KI 3 den Inhalt der Register 0, 1, 2 oder 3 um eins auf das gew√ºnschte Register. Die Befehle KI 4, KI 5 und KI 6 Erh√∂hen Sie vor dem Lesen den Inhalt der Register 4, 5 oder 6 um eins. <br><br>  Diese ‚Äû√Ñnderung‚Äú des Adressregisters erm√∂glicht es Ihnen, ganze Registergruppen in einer Schleife zu verarbeiten.  Es √§hnelt ++ R und --R in C.  Die Registerregisternummer ist wichtig.  Er bestimmt, ob er bei indirekter Adressierung zunimmt (Register 4-6) oder abnimmt (Register 0-3). <br><br>  Die 161eForth-Architektur wurde durch die Tatsache beeinflusst, dass die Erh√∂hung der Register 4-6 mit indirekter Adressierung <i>vorl√§ufig ist</i> .  Infolgedessen zeigt der Interpretationszeiger (IP) in R6 immer <i>auf das letzte Byte des</i> gen√§hten Codes.  In 86eForth gibt IP immer ein nachfolgendes Byte an, das noch nicht gelesen wurde. <br><br>  Dies gilt auch f√ºr den in Register 2 gespeicherten R√ºckgabestapelzeiger (RP). R2 zeigt immer auf die Oberseite des R√ºckgabestapels. <br><br>  Ein n√ºtzliches Merkmal des MK-161 ist das Fehlen einer Zunahme / Abnahme des Registers, wenn eine indirekte Adressierung mit dem neuen Schl√ºssel R auftritt. Beispielsweise z√§hlt RKIP02 die Nummer von der Oberseite des R√ºckgabestapels, ohne den Zeiger zu √§ndern.  Dies ist ein fertiges Fort R @ -Team.  Aus dem Obigen folgt, dass der Lesewert eins weniger ist als die Adresse des n√§chsten Tokens, das ausgef√ºhrt wird, nachdem vom Wort "Doppelpunkt" zur√ºckgekehrt wurde. <br><br>  Wenn Sie W√∂rter entwickeln oder studieren m√ºssen, die eng mit dem internen eForth-Interpreter interagieren, m√ºssen Sie diesen subtilen Punkt, der mit <b>√úbertreibung</b> verbunden ist, vollst√§ndig verstehen. <br><br><h3>  2.2 Tabellen, geordnet und assoziativ </h3><br>  Die MK-161-Tabellen befinden sich im Programmspeicher (siehe 2.4.3).  Sie erschienen in der "Electronics MK" in Nowosibirsk und sind Experten f√ºr sowjetische PMK v√∂llig unbekannt.  Die Adresse der verwendeten Tabelle wird immer im Register 9042 gespeichert, der Zugriff darauf ist jedoch unterschiedlich. <br><br>  <i>Eine geordnete Tabelle</i> ist ein Array von vorzeichenlosen 16-Bit-Ganzzahlen.  eForth enth√§lt eine solche tblTokens-Tabelle mit den Adressen von Grundelementen (siehe 3.1.1) - Fort-W√∂rter, die im MK-161-Befehlssystem geschrieben wurden.  Der Adressinterpreter (siehe 3.2) verwendet tblTokens, um gen√§hten Code schnell auszuf√ºhren. Daher versucht eForth, die Adresse dieser Tabelle in R9042 immer zu enthalten. <br><br>  Um auf eine bestellte Tabelle zugreifen zu k√∂nnen, m√ºssen Sie die Nummer des gew√ºnschten Artikels in R9210 schreiben.  Die Zahl n im Register X wird durch den Wert des Tabellenelements durch die Zahl n ersetzt, die Z√§hlung beginnt bei Null. <br><br>  <i>Assoziative Tabellen</i> ("Suche nach Wert") werden von eForth aktiv verwendet, haupts√§chlich vom Grundelement (FIND), das nach einem Wort mit seinem Namen sucht.  Die assoziative Tabelle tblCHPUT wird auch verwendet, wenn Buchstaben auf den Bildschirm gedruckt werden, um Zeilenvorsch√ºbe und andere Steuercodes zu verarbeiten. <br><br>  Um nach dem Element n in der assoziativen Tabelle zu suchen, schreiben Sie n in R9212.  Die Nummer n im Register X (das Management nennt sie den "Index") wird durch den 16-Bit-Wert ersetzt, der unmittelbar nach seinem "Index" n in der Tabelle aufgezeichnet ist. <br><br>  Das Vorhandensein dieser schnellen, wenn auch einfachen Suchfunktion, die in Assemblersprache in der MK-161-Firmware implementiert ist, hat eForth dabei geholfen, eine akzeptable Leistung beim Erkennen von Wortnamen und beim Kompilieren von Programmen zu erzielen.  Dazu musste ich nat√ºrlich nicht die einfachsten Namenserkennungstabellen entwickeln, die f√ºr diese Funktion ‚Äûgesch√§rft‚Äú wurden.  Wir werden im zweiten Artikel ausf√ºhrlicher darauf eingehen. <br><br><h3>  2.3 Interrupts und Konsole </h3><br>  Mit ‚ÄûMK Electronics‚Äú k√∂nnen Besitzer Programme in der Eingabesprache schreiben, die auf bestimmte Ereignisse reagieren - z. B. Dr√ºcken oder Loslassen einer Taste, Beenden einer Timer-Z√§hlung. <br><br>  eForth verwendet dieses <i>Interrupt-System aktiv</i> sowohl f√ºr die Tastatureingabe als auch f√ºr einen blinkenden Cursor, wenn Sie zur Eingabe aufgefordert werden, sowie f√ºr die Eingabe / Ausgabe √ºber eine universelle serielle Schnittstelle (RS-232). <br><br>  Die √ºber die Tastatur eingegebenen Buchstaben werden beim Dr√ºcken der Tasten bufKbd in die Warteschlange gestellt.  Dies ist sehr praktisch und spart Zeit bei Systemen mit niedriger Geschwindigkeit.  Das Umschalten von Alphabet und Gro√ü- / Kleinschreibung wird vom KeyPress-Interrupt √ºbernommen und belegt keinen Platz in der Warteschlange.  Durch langes Dr√ºcken der Taste wird die automatische Wiederholung aufgerufen. <br><br>  Wenn die Zeile mit 8 Buchstaben voll ist und eForth noch nicht bereit ist, die Eingabe zu verarbeiten (die Situation ist sehr selten), gibt der MK-161 ein ungl√ºckliches Quietschen aus.  Nat√ºrlich m√∂chte ich nicht all diese nat√ºrliche Arbeit der Tastatur im √úbersetzer implementieren, sondern den MK-161 als Service der Firmware (Firmware) "out of the box" bekommen.  Aber was, wie sie sagen, ist reich. <br><br>  Nach Arbeitsbeginn wird die gesamte eForth-Ausgabe auf <i>den Grafikbildschirm</i> MK-161 geleitet.  Die Ausgabe von Buchstaben darauf erfolgt durch eine relativ einfache Routine des CNCut.  Die einzige Schwierigkeit hierbei ist die Implementierung des BS-Steuercodes, des "Space Back".  MK-161 verwendet eine proportionale Schriftart.  Daher m√ºssen Sie sich in einem speziellen Puffer tblBS die Positionen der angezeigten Zeichen merken, von denen der BS-Ausgabecode sie sp√§ter √ºbernimmt. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hrend des Dialogs kann der Benutzer das Wort IO&gt; verwenden, um alle E / A an die serielle RS-232-Schnittstelle umzuleiten, wodurch </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der MK-161 von einer bekannten Computertastatur oder von einem anderen MK-161 aus programmiert werden kann</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Das Wort CON&gt; gibt die Steuerung an die Rechner-Konsole zur√ºck.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4 Speicherbereiche und Installation von eForth auf dem MK-161 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Speicher ‚ÄûMK-161 Electronics‚Äú besteht aus einem separat adressierbaren Programmspeicher und einem Datenregisterspeicher. Der Registerspeicher ist wiederum heterogen und in drei gro√üe Bereiche unterteilt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register mit Zahlen von 0 bis 999 speichern "Dezimalzahlen". Dies sind gew√∂hnliche Register wie in "Electronics B3-34" und anderen Taschenrechnern. Sie k√∂nnen einfach nicht 8, sondern 12 Dezimalstellen der ‚ÄûMantisse‚Äú speichern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register mit Nummern von 1000 bis 8167 speichern Ganzzahlen von 0 bis 255. Die letzten 3 KB dieses Bereichs mit Adressen von 5096 bis 8167 werden als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textbereich bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register mit Nummern von 9000 bis 9999 werden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionsregister genannt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieser Servicebereich des Adressraums √§hnelt Mikroprozessor-E / A-Ports. </font><font style="vertical-align: inherit;">Mit Hilfe von Schreib- und Lesebefehlen werden diese Adressen f√ºr den Zugriff auf E / A-Ger√§te, Interrupt-Systeme usw. verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um eForth auf "Electronics MK-161" zu installieren, reicht es aus, vier Dateien auf den Taschenrechner zu √ºbertragen, beispielsweise mit dem Programm des Herstellers MK.EXE:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schreiben Sie eForth.mkp ab Seite 0 in den Programmspeicher. Version 0.5b belegt 74 Seiten. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schreiben Sie eForth.mkd in den dezimalen Datenspeicher </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schreiben Sie eForth.mkb in den Bin√§rdatenspeicher </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schreiben Sie eForth.mkt in den Textspeicher </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der √úbertragung auf den Taschenrechner empfehle ich </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, diese vier Dateien</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sofort </font><b><font style="vertical-align: inherit;">in einem separaten Verzeichnis der</font></b><font style="vertical-align: inherit;"> eingebauten ‚Äûelektronischen Festplatte‚Äú zu speichern. </font><font style="vertical-align: inherit;">Da sie denselben Namen haben, k√∂nnen Sie eForth sofort als ‚ÄûPaket‚Äú herunterladen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.1 Bin√§rspeicher ("Byte") MK-161: eForth.mkb </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die MK Electronics-Register mit Zahlen von 1000 bis 5095 werden zum Speichern von Zahlen von 0 bis 255 verwendet. Dieser Bereich des Registerspeichers des Rechners wird als bin√§r bezeichnet. Auf zwei aufeinanderfolgende Bin√§rregister kann von eForth als einzelne 16-Bit- "Zelle" zugegriffen werden, und (wie √ºberall beim MK-161) befinden sich die oberen 8 Bits im Register mit einer niedrigeren Nummer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth verwendet diesen winzigen ‚ÄûBin√§rspeicher‚Äú als prim√§ren Speicher. Worte funktionieren mit ihr! und @, HERE und ALLOT, nur von hier aus f√ºhrt der Adressinterpreter den gen√§hten Code aus (siehe 3.2). Hier sind die eForth-Variablen, der Texteingabepuffer (TIB), das W√∂rterbuch und der tblBS-Rollback-Stack zum Implementieren der R√ºcktaste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4096 Bytes sind f√ºr moderne Verh√§ltnisse sehr bescheiden. Daher wurden enorme Anstrengungen unternommen, um alles M√∂gliche in andere Bereiche des Ged√§chtnisses zu bringen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.2 Textbereich: eForth.mkt </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unmittelbar nachdem der </font><font style="vertical-align: inherit;">Bin√§rspeicher </font><font style="vertical-align: inherit;">ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textbereich ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , werden Register mit Zahlen von 5095 bis 8167 registriert. Technisch gesehen handelt es sich um dieselben Byteregister, aber die M√∂glichkeit, sie auf die Festplatte zu schreiben und als separate Datei zu lesen, macht diesen Bereich zu etwas Besonderem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wort TLOAD wird verwendet, um in eForth mit ‚ÄûText‚Äú zu arbeiten. </font><font style="vertical-align: inherit;">Dieser gesamte Bereich wird der Eingabe des Textinterpreters als Zeichenfolge mit einer L√§nge von 3072 Buchstaben zugef√ºhrt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Meinungsverschiedenheiten dar√ºber, wie Text in Zeilen unterteilt werden soll. </font><font style="vertical-align: inherit;">Ein in MK Electronics integrierter Editor besteht auf einer Zeilenl√§nge von 24 Zeichen. </font><font style="vertical-align: inherit;">Callisto verwendet die Fort-Konvention, bei der die Zeichenfolge 64 Zeichen enth√§lt. </font><font style="vertical-align: inherit;">eForth bietet dem Benutzer eine Auswahl, bei der der gesamte Text als eine lange Zeile gez√§hlt wird. </font><font style="vertical-align: inherit;">Sie k√∂nnen den eingebauten Editor MK-161 verwenden. </font><font style="vertical-align: inherit;">Sie k√∂nnen Ihre eigenen schreiben, kompatibel mit Callisto.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier ist der anf√§ngliche Inhalt von eForth.mkt der Einfachheit halber in drei Zeilen unterteilt: </font></font><br><br><pre><code class="plaintext hljs">: hi ." , %user%!" CR ; ' hi 'boot ! hi \</code> </pre> <br>  Die erste Zeile definiert das neue Wort hi, das den Benutzer begr√º√üt.  Die zweite Zeile nimmt das Token dieses Wortes (siehe 3.1) und platziert es in der Variablen 'BOOT (siehe 1).  Jetzt wird der Textbereich bei jedem Start von eForth nicht mehr kompiliert.  Stattdessen wird die bereits kompilierte Begr√º√üung ausgef√ºhrt. <br><br>  Die letzte Zeile beginnt mit dem Wort hi und zeigt eine Begr√º√üung auf dem Bildschirm an.  Das Wort \ vervollst√§ndigt die Interpretation des Textes und gibt die Steuerung an die Konsole zur√ºck. <br><br>  Um eine beliebige Textdatei zu kompilieren, m√ºssen Sie mit dem Befehl BYE zum Taschenrechner gehen, zum Hauptmen√º gehen und die gew√ºnschte Datei im DOS-Modus laden.  Sie k√∂nnen die mkt-Datei auch von einem Computer √ºbertragen.  Mit der C / P-Taste kehren Sie zu eForth zur√ºck. Anschlie√üend k√∂nnen Sie mit dem Befehl TLOAD die in den Textbereich geladene Datei kompilieren. <br><br><h4>  2.4.3 Programmspeicher: eForth.mkp </h4><br>  Der Programmspeicher MK-161 ist ein isolierter Adressraum.  Es werden auch Bytes gespeichert, die jedoch schreibgesch√ºtzt sind.  Der Programmspeicher enth√§lt 10.000 "Schritte", die sich f√ºr eForth als redundant herausstellten.  Mehr als ein Viertel des Programmspeichers erwies sich als frei, was eine gute Reserve f√ºr die Entwicklung des √úbersetzers darstellt. <br><br>  Nur im Programmspeicher k√∂nnen "Codew√∂rter" implementiert werden.  Au√üerdem werden hier Namenserkennungstabellen und alle bekannten Textzeichenfolgen gerendert, wodurch Bin√§rspeicher gespart wird. <br><br>  Einige W√∂rter wie C @, COUNT und TYPE k√∂nnen den Programmspeicher adressieren, wenn die Adresse keine positive Zahl ist.  Beispielsweise z√§hlt die Phrase 0 C @ als "Schritt" (Byte) von der Adresse 0 des Programmspeichers. <br><br><h4>  2.4.4 Dezimalspeicher: eForth.mkd </h4><br>  Die Register von MK Electronics mit Zahlen von 0 bis 999 werden als Dezimalzahlen bezeichnet und enthalten Zahlen, die f√ºr normale Berechnungen auf dem Taschenrechner verwendet werden - 12 Dezimalstellen der ‚ÄûMantisse‚Äú und 2 Dezimalstellen der ‚ÄûOrdnung‚Äú.  Das Fort ist f√ºr die Arbeit mit Ganzzahlen mit einer L√§nge von bis zu 4 Byte ausgelegt. Eine solche Ressource ist f√ºr eForth eindeutig redundant. <br><br>  Der Dezimalspeicher wird verwendet, um wertvollen Bin√§rspeicher zu speichern.  Hier werden Datenstapel und Retouren erstellt.  Hier werden die √úberschriften der W√∂rter gespeichert - sowohl benutzerdefiniert als auch eingebettet, ein Register pro Titel.  Mit diesem Ansatz k√∂nnen Sie auch W√∂rter mit Standardnamen neu definieren. <br><br>  Der Stapel im Dezimalspeicher f√ºhrt zu einer Reihe von Merkmalen, die f√ºr das Fort des MK-161 charakteristisch sind.  Erstens ist der Wertebereich der Stapelelemente sehr gro√ü und kann 32-Bit-Ganzzahlen aufnehmen.  Die Notwendigkeit f√ºr "doppelte Ganzzahlen" beim MK-161 verschwindet, obwohl ich aus Kompatibilit√§tsgr√ºnden die entsprechenden W√∂rter eForth implementiert habe.  "Doppelte Ganzzahlen" werden auf MK-161 als zwei Stapelelemente dargestellt, die Zahlen von 0 bis 65535 enthalten und eine 32-Bit-Ganzzahl mit einem Vorzeichen im zus√§tzlichen Code codieren.  Die hohen 16 Bits dieser Nummer werden oben platziert, dh an der niedrigsten Adresse. <br><br>  Die bitweisen logischen Operationen AND, OR, XOR und NOT behandeln ihre Argumente als 16-Bit-Ganzzahlen.  Ein Ergebnis von 32768 bis 65535 wird in negative Zahlen von -32768 bis -1 umgewandelt.  In eForth wird false mit Null und Wahrheit minus Eins codiert.  Ebenfalls wahr ist ein anderer Wert als Null. <br><br>  Das zweite Merkmal des 161eForth-Datenstapels besteht darin, dass er vorzeichenbehaftete Nummern enth√§lt.  Wenn das Wort @ die Nummer 65535 aus einer 16-Bit-Zelle liest, wird es automatisch in -1 konvertiert.  Ein <b>spezielles "vorzeichenloses" Wort U @ wird</b> bereitgestellt, um direkt 65535 mit einem Pluszeichen zu z√§hlen. <br><br>  Ich erinnere mich, dass sich die <b>beiden oberen Elemente des</b> Datenstapels der Geschwindigkeit halber nicht im Dezimalspeicher befinden, sondern direkt <b>in den X- und Y-Registern</b> . <br><br>  Die Tatsache, dass Dezimalregister Bruchzahlen und Gleitkommazahlen enthalten k√∂nnen, wird von eForth nicht verwendet.  Die virtuelle eForth-Maschine verwendet diese Register, um vorzeichenbehaftete 12-Bit-Dezimalzahlen zu speichern.  Auf Dezimalregister wird mit den W√∂rtern C @ und C zugegriffen!  - die gleichen, die mit einzelnen Registern arbeiten. <br><br><h2>  3. Der interne Interpreter </h2><br>  Der eForth-Kern ist ein Programm, das in der Eingabesprache MK-161 geschrieben ist.  Ihr erster MAIN-Befehl √ºbertr√§gt die Kontrolle auf den MAIN-Code, der zun√§chst die Umst√§nde des Neustarts ermittelt.  Wenn es durch den falschen Token verursacht wurde, quietscht MK-161.  Beim ersten Start und auch nach dem Einschalten des MK-161 wird der Bildschirm gel√∂scht.  Als n√§chstes ruft MAIN die Init-Subroutine auf, um das Interrupt-System und alles, was die MK-161-Konsolentreiber ben√∂tigen, zu initialisieren. <br><br>  Nach dem Initialisieren der Datenstapel und der R√ºckgabe ist der Teil des Starts auf niedriger Ebene abgeschlossen.  Unglaubliche Dinge passieren f√ºr Maschinen mit Harvard-Architektur - eForth f√ºhrt weiterhin ‚Äûverkabelten Code‚Äú aus dem Bytespeicher aus.  Die Ehre, der Erste zu sein, geh√∂rt zu einem Wort, dessen Kopfadresse in R43 aufgezeichnet ist.  Dies ist normalerweise das Wort KALT. <br><br>  Wie sind <i>hochrangige W√∂rter</i> (IEDs) angeordnet?  Jedes Wort besteht aus zwei Teilen, einem K√∂rper und einer √úberschrift.  <i>Der Header</i> wird dezimal gespeichert.  Es hilft dem externen Interpreter und Dekompiler, den Namen und den Textk√∂rper des Wortes zu finden.  Die √úberschrift enth√§lt auch <i>ein ‚ÄûLexikon‚Äú -Feld</i> - eine Reihe von Flags, die dem externen Interpreter helfen, das gefundene Wort korrekt zu verarbeiten.  Der interne Interpreter ist f√ºr den VCA-Body, der sich im Bin√§rspeicher befindet und im W√∂rterbuch gespeichert ist, viel wichtiger.  Er kann sogar W√∂rter ausf√ºhren, die keine √úberschrift haben. <br><br>  <i>Der Hauptteil des</i> VCA beginnt mit dem Byte des <i>Codefelds</i> , das die Adresse des <i>Prozessors des</i> angegebenen Wortes enth√§lt.  Vier VCA-Handler sind in der Eingabesprache MK-161 geschrieben und beginnen auf der ersten Seite des Programmspeichers.  Wir werden sie alle analysieren (siehe 3.3), aber die wichtigste hei√üt DOLST und befindet sich an der Adresse 02, unmittelbar nach dem bereits ber√ºcksichtigten Befehl MAIN BP.  Dieser Handler f√ºhrt Fort-W√∂rter aus, die mit einem Doppelpunkt definiert sind. <br><br>  Nach dem Byte des Codefeldes <i>befindet sich ein Parameterfeld</i> beliebiger L√§nge.  In den "Doppelpunktw√∂rtern" enth√§lt das Parameterfeld einen "gen√§hten Code" - eine Folge von 16-Bit-Token, von denen jeder eine ihm zugewiesene Aktion angibt. <br><br>  Zun√§chst werden wir das Token genauer betrachten.  Dann werden wir den internen INEXT-Interpreter untersuchen, der von einem Token zur Ausf√ºhrung des n√§chsten √ºbertr√§gt.  EForth nennt INEXT einen primitiven Handler.  Wir schlie√üen diese Tour durch den internen Interpreter mit der Analyse aller vier IED-Prozessoren ab. <br><br><h3>  3.1 Token </h3><br>  <i>Das Token</i> repr√§sentiert das Wort im gen√§hten Code und Stapel, sodass es schnell ausgef√ºhrt werden kann.  Das Token ist ein Zeiger auf den Wortk√∂rper, aber die raue Architektur des MK-161 hat diese einfache Idee selbst angepasst.  Lassen Sie uns alle Arten von Token analysieren, beginnend mit dem primitiven Token. <br><br><h4>  3.1.1 Primitives Token </h4><br>  Alle in der eForth-Verteilung enthaltenen W√∂rter sind von 0 bis 206 nummeriert. Diese Nummerierung erfolgt durchgehend, wobei sowohl Grundelemente als auch VCA ber√ºcksichtigt werden.  Dies geschieht so, dass es durch die Nummer des Wortes leicht war, seinen <i>Namen</i> wiederherzustellen.  Diese Namen werden im Programmspeicher gespeichert.  Der Link zum gew√ºnschten Namen ist leicht √ºber die Headertabelle zu finden. <br><br>  <b>Die primitive Zahl ist ihr Token</b> .  Wie jedes Token ben√∂tigt das Grundelement zwei Bytes im gen√§hten Code.  Der erste ist Null.  Der zweite enth√§lt seine Nummer.  In der Tabelle tblTokens k√∂nnen Sie die Adresse des primitiven Codes anhand dieser Nummer schnell finden.  Die tblTokens-Adresse ist permanent in R9042 gespeichert (siehe 2.2), dh es ist immer alles zur Hand, um das Grundelement auszuf√ºhren. <br><br>  Mit dem Wort XT&gt; k√∂nnen Sie die Adresse eines primitiven Codes anhand seiner Nummer (Token) ermitteln.  Da sich der Code der Grundelemente immer im Programmspeicher befindet, ist die empfangene Adresse immer negativ (siehe 2.4.3). <br><br><h4>  3.1.2 VCA-Token </h4><br>  VCA kann eine eigene Nummer und einen zugeh√∂rigen Standardnamen haben oder vom Benutzer erstellt werden.  In allen F√§llen ist das <b>VCA-Token die Adresse seines Codefelds</b> (siehe 3), dh eine Zahl von 1000 bis 5095. <br><br>  Im gen√§hten Code wird das VCA-Token auf sehr ungew√∂hnliche Weise geschrieben.  Die Anzahl von Hunderten (eine Zahl von 10 bis 50) wird in das erste Byte geschrieben, der Rest aus der Division des Tokens durch 100 (eine Zahl von 0 bis 99) im zweiten Byte. <br><br>  Beispielsweise wird das Token 1234 durch zwei Bytes 12 und 34 dargestellt. Die Kompilierung dieses und jedes anderen Tokens erfolgt unter Verwendung des aus dem ANSI-Standard entnommenen Wortes COMPILE.  Um VCA-Token im gen√§hten Code zu schreiben und zu lesen, m√ºssen die W√∂rter XT!  und XT @.  Sie greifen auf Adressen zu (siehe 3.1.4), und das Wort XT @ kann auch das primitive Token lesen. <br><br><h4>  3.1.3 Ganzzahlige Literale </h4><br>  <i>Ganze Literale</i> sind eine Art primitiver Token.  Sie sind ungew√∂hnlich genug, um separat betrachtet zu werden. <br><br>  Im gen√§hten Code belegen die Token DOLIT und DOLITM vier Bytes.  Die ersten beiden Bytes enthalten das bereits ber√ºcksichtigte primitive Token, dh 0, und die Nummer des Grundelements.  Die n√§chsten zwei Bytes enthalten eine Ganzzahl, die das angegebene Literal w√§hrend der Ausf√ºhrung auf den Datenstapel legt. <br><br>  DOLITM unterscheidet sich darin, dass es das Vorzeichen der Zahl √§ndert, bevor es auf den Stapel gelegt wird.  Es wurde entwickelt, um negative Zahlen zu implementieren. <br><br><h4>  3.1.4 Adressliterale </h4><br>  Wie ganze Literale belegen die drei <i>Adressliterale</i> BRANCH, BRANCH und DONXT jeweils 4 Bytes im gen√§hten Code.  Die ersten 2 Bytes enthalten das primitive Token, die letzten beiden Bytes sind die Sprungadresse. <br><br>  Die Adresse wird im gleichen Format wie das VCA-Token aufgezeichnet (siehe 3.1.2).  Das erste Byte enth√§lt die Anzahl von Hunderten, das zweite den Rest der Division der Adresse durch 100. Ich erinnere mich, dass die √úbergangsadresse aufgrund von √úbertreibung (siehe 2.1) nicht die Adresse des gew√ºnschten Tokens enth√§lt, sondern eine Zahl, die um eins kleiner ist. <br><br>  Das DONXT-Token hilft bei der Implementierung des FOR-NEXT-Endzyklus (siehe 1).  Der bedingungslose BRANCH-Sprung wird ben√∂tigt, um die Endlosschleife BEGIN-AGAIN zu implementieren.  Bedingte Verzweigung? BRANCH √ºbertr√§gt die Kontrolle, wenn sich Null oben im Datenstapel befindet (false).  Es dient zur Implementierung der bedingten IF-THEN-Anweisung, die aus "unbestimmten Schleifen" BEGIN-UNTIL und BEGIN-WHILE-REPEAT beendet wird. <br><br><h4>  3.1.5 String-Literale </h4><br>  <i>String-Literale</i> sind eine Art VCA-Token.  Im gen√§hten Code eines String-Literal gibt es nach dem Token ein Byte mit der L√§nge des Strings, nach dem der String selbst vom ersten bis zum letzten Byte ist. <br><br>  EForth hat drei String-Literale: $ "|,." |  und abort "|. Sie werden in der Datei eForth0.mkl als STRQP-, DOTQP- und ABORQ-Token definiert. Die Hauptarbeit" literal "wird durch das Wort do $, das DOSTR-Token, ausgef√ºhrt. <br><br>  Um die Artikelgr√∂√üe angemessen zu gestalten, kann ich mich nicht zu sehr mit diesem interessanten Thema befassen, aber es ist sch√∂n zu wissen, ob sie in eForth verf√ºgbar sind. <br><br><h3>  3.2 Adressinterpreter </h3><br>  Es ist Zeit, <i>den Token-Interpreter zu betrachten</i> , dessen Adresse immer in Register 9 geschrieben ist. Die meisten Grundelemente beenden ihre Arbeit mit dem Befehl K BP 9, der die Kontrolle an das INEXT-Label √ºbertr√§gt. <br><br><pre> <code class="plaintext hljs">INEXT: 6 Fx‚â†0 NPrime NData:  2 6 + 7 F‚ü≥ 7 8 F‚ü≥ 8</code> </pre> <br>  Zun√§chst liest der Adressinterpreter das erste Byte des n√§chsten Tokens mit dem Befehl KIP6.  Wenn es Null ist, ist dies ein Grundelement und der Code unter der Bezeichnung NPrime behandelt das Token. <br><br>  Das Label NData kennzeichnet die Verarbeitung des VCA-Tokens.  Das erste Byte wird mit dem Befehl VP 2 mit einhundert multipliziert. Danach addiert KIP6 + das zweite Byte des Tokens zum Ergebnis (siehe 3.1.2).  Das Lesetoken wird vom P7-Team in das Arbeitsregister WP (R7) eingetragen. <br><br>  Wir wissen, dass das VCA-Token die Adresse seines Codefelds ist, das die Adresse des Prozessors enth√§lt.  Die KIP7 P8-Befehle lesen das Byte des Codefelds in R8, und der KBP8-Befehl √ºbertr√§gt die Steuerung an den VCA-Prozessor.  Der Handler wei√ü, dass R7 eine Nummer eins enth√§lt, die kleiner ist als die Adresse des Parameterfelds des verarbeiteten Wortes. <br><br>  Befehle F‚ü≥ mit Code 25 werden auf dem Stapel ‚Äûaufger√§umt‚Äú.  Tatsache ist, dass eForth die beiden obersten Elemente des Datenstapels direkt in den X- und Y-Registern des MK-161-Stapels speichert.  Eine solche L√∂sung beschleunigt die Arbeit, muss jedoch sicherstellen, dass diese wichtigen Daten nicht verloren gehen. <br><br>  Es bleibt zu verstehen, wie der Adressinterpreter die Grundelemente ausf√ºhrt. <br><br><pre> <code class="plaintext hljs">NPrime: F‚ü≥ 6 9210 8 F‚ü≥ 8</code> </pre> <br>  Der KIP6-Befehl liest das zweite Byte des primitiven Tokens.  RRP9210 P8-Befehle lesen die Adresse dieses Grundelements aus der Tabelle tblTokens (siehe 2.2 und 3.1.1), und KBP8 √ºbertr√§gt die Steuerung an dieses Grundelement. <br><br>  Wie oben entfernt F‚ü≥ den √úberschuss vom Stapel und stellt den Inhalt der Register X und Y wieder her. <br><br>  Der eForth-Adressinterpreter ist so klein, dass er mehrmals im Programmspeicher dupliziert wird.  Die Hauptkopie wird mit dem Befehl K BP 9 ausgef√ºhrt, der die meisten Grundelemente vervollst√§ndigt. <br><br>  Als √úbung empfehle ich, die Implementierung des Wortes EXECUTE zu studieren, das nach dem EXECU-Label steht.  Dies ist eine INEXT-Variante, die das Token nicht aus dem gen√§hten Code liest, sondern aus dem Datenstapel entnimmt. <br><br><h3>  3.3 VCA-Handler </h3><br>  Vier VCA-Sorten haben vier verschiedene Handler: DOLST, DOVAR, DOCON und DOCONM.  Wir haben oben bereits gesehen, dass der Adressinterpreter vor dem Aufrufen des Handlers in R7 die Adresse des Codefeldes des zu verarbeitenden Wortes hinterl√§sst. <br><br>  eForth.f lernt die Adressen dieser Handler, indem es den Kernel-Header aus der Datei eForth0.mkp liest.  Dies hilft ihm, den VCA f√ºr den Electronics MK-161 korrekt zu kompilieren, indem das Ergebnis in die Datei eForth.mkb eingef√ºgt wird. <br><br><h4>  3.3.1 Doppelpunktw√∂rter: DOLST und EXIT </h4><br>  Das n√§chste wichtige Thema nach INEXT ist, was der interne Interpreter tut, wenn er auf das Token eines durch Doppelpunkte definierten Wortes st√∂√üt.  Das Codefeld eines solchen Wortes enth√§lt die Nummer 2, daher √ºbertr√§gt INEXT die Steuerung an den DOLST-Handler, der die erforderlichen Arbeiten ausf√ºhrt, um mit der Interpretation der neuen Liste von Token zu beginnen. <br><br><pre> <code class="plaintext hljs">DOLST: 6 2 F‚ü≥ 7 6 F‚ü≥ INEXT:</code> </pre> <br>  Register 2 enth√§lt, wie bereits erl√§utert (siehe 2.1), einen RP-R√ºckgabestapelzeiger.  Die IP6 KP2-Befehle schreiben den Wert von R6, dem Interpretation Pointer (IP), in den R√ºckgabestapel.  Sp√§ter hilft dies dabei, sich an die aktuelle Position in der alten Liste der Token zu erinnern, an der INEXT auf ein Doppelpunktwort gesto√üen ist.  Jetzt ordnet IP7 P6 IP an den Anfang einer neuen Liste. <br><br>  Unmittelbar nach dem DOLST-Code wird der INEXT-Code platziert, der das erste Wort der neuen Token-Liste ausf√ºhrt.  Wie an anderer Stelle helfen die Befehle F  dabei, die beiden obersten Elemente des Datenstapels beizubehalten. <br><br>  Doppelpunktw√∂rter enden normalerweise mit einem EXITT-Token, was im Vergleich zu DOLST das Gegenteil bewirkt - es nimmt den alten IP-Wert vom R√ºckgabestapel und kehrt zur Interpretation der alten Token-Liste zur√ºck. <br><br><pre> <code class="plaintext hljs">EXITT: 02 6 x 1 2 + 2 F‚ü≥ INEXT:</code> </pre> <br>  Die Befehle RKIP02 P6 lesen den alten IP-Wert vom oberen Rand des R√ºckgabestapels (siehe 2.1).  Danach korrigieren die Befehle Cx 1 IP2 + P2 den Wert von RP und erh√∂hen ihn um eins.  Der Befehl F‚ü≥ stellt den Stapel wieder her, wonach INEXT das n√§chste Wort aus der alten Token-Liste ausf√ºhrt. <br><br>  Nat√ºrlich kann INEXT nicht gleichzeitig nach DOLST und nach EXITT gehen.  Dazu habe ich einen alten Trick aus der Zeit der UdSSR angewendet.  Sie k√∂nnen es auch beherrschen, indem Sie die entsprechenden Zeilen in der Datei eForth0.mkl untersuchen. <br><br><h4>  3.3.2 DOVAR-, Variablen- und Array-Handler </h4><br>  W√∂rter, die durch die W√∂rter CREATE und VARIABLE generiert werden, verwenden denselben DOVAR-Handler.  Dieser Handler √ºbertr√§gt auf dem Stapel die Adresse der Variablen, die sich im Parameterfeld befindet und unmittelbar nach dem Byte des Codefelds steht.  VARIABLE-Variablen belegen 2 Bytes, und die mit CREATE erstellten Arrays enthalten so viele Bytes, wie der Programmierer m√∂chte. <br><br><pre> <code class="plaintext hljs">DOVAR: ‚áî 3 x 1 7 + 9</code> </pre> <br>  Befehle ‚áî KP3 speichern den Inhalt des Registers Y im Datenstapel. Gleichzeitig wird die Nummer von der Oberseite des Stapels in RY eingegeben, wodurch RX auf den neuen Wert freigegeben wird.  Nach Cx 1 IP7 + -Befehlen wird dieser neue Wert oben im Stapel zur Adresse des Parameterfelds des ausf√ºhrbaren Wortes.  KBP9 √ºbertr√§gt die Kontrolle ohne Tricks an INEXT und f√§hrt mit dem n√§chsten Wort fort. <br><br><h4>  3.3.3 Konstante Handler: DOCON und DOCONM </h4><br>  Im Gegensatz zu DOVAR greift <i>der Konstantenhandler</i> auf das Parameterfeld seines Wortes selbst zu.  DOCON liest einen 16-Bit-Konstantenwert daraus.  Dieser Wert ist immer positiv. <br><br><pre> <code class="plaintext hljs">DOCON: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + 9</code> </pre> <br>  Befehle ‚áî KP3 ‚áî speichern RY im Datenstapel.  Diesmal kehrt die alte Spitze des Datenstapels zu RX zur√ºck.  Die IP7 P5-Befehle erzwingen es zur√ºck in RY, w√§hrend das Zeigerregister R5 vorbereitet wird, um den Wert der Konstante zu lesen.  Als n√§chstes ersetzt Cx 256 den M√ºll in Register X durch die Nummer 256. <br><br>  Instrumente KIP5 √ó KIP5 + lesen eine Konstante aus dem Parameterfeld an die Spitze des Datenstapels, dh in RX.  Wie wir uns erinnern, ist in MK-161 das erste Byte immer hoch.  Es wird mit 256 multipliziert, wonach das niedrigstwertige Byte der Konstante zum Produkt hinzugef√ºgt wird.  Alle Arbeiten sind erledigt, KBP9 √ºbertr√§gt die Kontrolle auf das n√§chste Wort. <br><br>  DOCONM funktioniert genauso, nur das konstante Vorzeichen nach dem Lesen √§ndert sich in das Gegenteil.  Aus Gr√ºnden der Geschwindigkeit sind auf dem MK-161 negative Konstanten als separater Prozessor implementiert: <br><br><pre> <code class="plaintext hljs">DOCONM: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + /-/ 9</code> </pre> <br>  Jetzt haben wir vollst√§ndig herausgefunden, wie eForth seinen Code auf dem MK-161 Electronics aus dem Datenbereich ausf√ºhrt, und sogar ein tieferes Thema der String-Literale angesprochen (siehe 3.1.5). <br><br>  Im zweiten Artikel der Reihe werde ich √ºber den externen "Text" -Interpreter 161eForth sprechen, die Struktur der Headertabellen analysieren und die Namen erkennen.  F√ºr diesen Teil des √úbersetzers musste ich viel radikalere L√∂sungen entwickeln, vor deren Hintergrund das oben diskutierte traditionelle Fort alt und gut ist. <br><br>  Happy Fort Programmierung! <br><br><h2>  Literatur </h2><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth und Zen - 3. Ausgabe, 2017. Verf√ºgbar auf Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Fort Sprache und ihre Umsetzung.  - L.: Maschinenbau.  Leningrad  Abteilung, 1988. </li><li>  Semenov Yu.A.  Programmierung in der FORT-Sprache.  - M.: Radio und Kommunikation, 1991. </li><li>  ANS Vierter Standard.  X3.215-1994.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-Forth-Dokumentation</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Offete Store (Proceedings of Dr. Chen-Hanson Ting)</a> , in dem Sie 86eForth v5.2 f√ºr Windows herunterladen k√∂nnen, Dokumentation in englischer Sprache. </li></ol><br><br><h2>  Videoabbildungen </h2><br>  Diese vier kleinen 161eForth-Videos werden fortgesetzt.  Das erste Video am Anfang des Artikels. <br><br>  Teil 2 von 5. Testet TEST-TEST4 aus dem Buch "eForth and Zen", 3. Auflage, auf dem MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7UuQSozjuJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Teil 3 von 5. SIEHE Dekompiler. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K-mWJuL1fiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Teil 4 von 5. Haltepunkt BYE, RS-232-Terminal und Fernzugriff auf MK-161. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Cfj60ICJrHU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Teil 5 von 5. Schlussworte. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oAAX29TpH9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452398/">https://habr.com/ru/post/de452398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452384/index.html">Der Prozessor beschleunigt die Optik auf 800 Gbit / s: wie es funktioniert</a></li>
<li><a href="../de452388/index.html">Sieb von Eratosthenes jenseits von O (n). Beweis</a></li>
<li><a href="../de452390/index.html">Software Defined Radio - wie funktioniert es? Teil 3</a></li>
<li><a href="../de452392/index.html">Eine Auswahl von Datens√§tzen f√ºr maschinelles Lernen</a></li>
<li><a href="../de452394/index.html">Opus √ºber Seine Majest√§t Clay. Zweiter Teil - Viva, Cyanacrylat! Viva, Sekundenkleber</a></li>
<li><a href="../de452400/index.html">Ineffektives Gesch√§ft</a></li>
<li><a href="../de452402/index.html">Experimente mit einer analogen Tunneldiode</a></li>
<li><a href="../de452404/index.html">F√ºnf wichtige ITSM-Trends f√ºr dieses Jahr</a></li>
<li><a href="../de452408/index.html">Maine Coon Toilette</a></li>
<li><a href="../de452410/index.html">Bash-Start im Detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>