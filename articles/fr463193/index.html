<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐪 ☃️ 🧛🏼 Convertissez des images en noir et blanc en graphiques ASCII à l'aide d'une décomposition matricielle non négative 🎃 🧜🏽 👨🏻‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En général, la conversion d'une image en graphiques ASCII est une tâche assez longue, mais il existe des algorithmes qui automatisent ce processus. Ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Convertissez des images en noir et blanc en graphiques ASCII à l'aide d'une décomposition matricielle non négative</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463193/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hq/s7/wl/hqs7wlxixfh79akhz1b_mtsqdby.png" width="500"></div><br>  En général, la conversion d'une image en graphiques ASCII est une tâche assez longue, mais il existe des algorithmes qui automatisent ce processus.  Cet article traite de l'approche proposée par les chercheurs Paul D. O'Grady et Scott T. Rickard dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Conversion automatique ASCII des images binaires en utilisant des contraintes non négatives»</a> .  La méthode qu'ils décrivent consiste à représenter le processus de conversion d'image comme un problème d'optimisation et à résoudre ce problème en utilisant une décomposition matricielle non négative.  Voici une description de l'algorithme en question, ainsi que sa mise en œuvre: <br><a name="habracut"></a><br><h2>  Description de l'algorithme </h2><br>  L'image originale est divisée en blocs de taille <img src="https://habrastorage.org/getpro/habr/post_images/8ff/59f/7d7/8ff59f7d770613863cd2c0483685db98.svg" alt="M \ fois N">  où <img src="https://habrastorage.org/getpro/habr/post_images/8da/056/75e/8da05675e58b0287c1cca7e37cdc1d99.svg" alt="M">  et <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="N">  - largeur et hauteur d'un caractère en pixels.  Si la largeur \ hauteur de l'image n'est pas un multiple de la largeur \ hauteur du caractère, l'image est recadrée ou complétée par des zones blanches de la taille souhaitée. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/se/qe/pu/seqepumqylvcdk6upn-dd9vi_4q.png" width="250"></div><br>  Chacun <img src="https://habrastorage.org/getpro/habr/post_images/b95/4f4/3ce/b954f43ce67f65a92502a661914b76e4.svg" alt="K">  les blocs obtenus après la partition sont représentés comme un vecteur de longueur <img src="https://habrastorage.org/getpro/habr/post_images/840/ed3/a5a/840ed3a5a13dc397969bf6a205f84279.svg" alt="R = M * N">  dont les valeurs sont les intensités de couleur des pixels de l'image (valeurs de 0 à 255, où le pixel blanc correspond à la valeur 0 et le pixel noir correspond à 255).  Les vecteurs résultants doivent être normalisés en utilisant la norme <img src="https://habrastorage.org/getpro/habr/post_images/966/980/a89/966980a893368f21382de225cb386c40.svg" alt="l_2">  : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9d/025/739/b9d025739593e0f7204d847a453696f6.svg" alt="v_i = \ frac {v_i} {\ sqrt {\ sum ^ R_ {k = 1} {v ^ 2_k}}}"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/yp/lz/dyyplzoz5tqb1lcykfkm-4imbm8.png" width="500"></div><br>  Les vecteurs normalisés sont réécrits sous forme de colonnes, formant ainsi une matrice <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V">  la taille <img src="https://habrastorage.org/getpro/habr/post_images/083/983/d7b/083983d7b6c59f43192e4290078b5f25.svg" alt="R \ fois K">  . <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/86/sx/hn/86sxhn1rqtrj8zgc4ggxdysimxa.png" width="550"></div><br>  La matrice résultante <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V">  doivent être représentés comme un produit de matrices <img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W">  et <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H">  dont tous les éléments ne sont pas négatifs: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47e/bda/50f/47ebda50f4a5615da97271890fec3f87.svg" alt="V_ {R \ fois K} = W_ {R \ fois L} H_ {L \ fois K}"></div><br>  Matrix <img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W">  connu à l'avance: il est construit de manière similaire à la matrice <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V">  , mais au lieu de sections de l'image d'origine, des images de tous les symboles utilisés dans la génération de graphiques ASCII sont utilisées.  Si le kit applicable comprend <img src="https://habrastorage.org/getpro/habr/post_images/899/a67/551/899a675510d28419769a9b42281f0c65.svg" alt="L">  caractères puis la matrice <img src="https://habrastorage.org/getpro/habr/post_images/b01/e2a/c4f/b01e2ac4f751abe6f542b4e3e5d7ff46.svg" alt="W">  aura une taille <img src="https://habrastorage.org/getpro/habr/post_images/a76/a5a/884/a76a5a884fe0da7d2cdfeeab7d895c8f.svg" alt="R \ fois L">  . <br>  Il ne reste plus qu'à choisir une matrice <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H">  de manière à minimiser la valeur d'une fonction objective caractérisant la différence entre <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V">  et travailler <img src="https://habrastorage.org/getpro/habr/post_images/606/4df/837/6064df837796bdcfd80eee8bf2cb5eba.svg" alt="WH">  .  La dépendance suivante est utilisée comme une telle fonction: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35d/fe5/834/35dfe58346bb38035eb7f9f1e5c0cc2d.svg" alt="D (V, W, H, \ beta) = \ sum_ {ik} \ bigg ({v_ {ik} \ frac {v_ {ik} ^ {\ beta-1} - [WH] ^ {\ beta-1} _ {ik}} {\ beta (\ beta-1)}} + [WH] ^ {\ beta-1} _ {ik} \ frac {[WH] _ {ik} -v_ {ik}} {\ beta } \ bigg)"></div><br>  Cette expression combine essentiellement plusieurs fonctions objectives: lorsque <img src="https://habrastorage.org/getpro/habr/post_images/215/e6c/c96/215e6cc967c4f2092c353e52ef79ead5.svg" alt="\ beta = 2">  il est converti au carré de la distance euclidienne (Squared Euclidean Distance), lorsque <img src="https://habrastorage.org/getpro/habr/post_images/e2b/8cc/041/e2b8cc04156c65f9868bf19291640ceb.svg" alt="\ beta \ rightarrow 1">  s'approche de la distance de divergence Kullback-Leibler, et à <img src="https://habrastorage.org/getpro/habr/post_images/419/9a1/7fa/4199a17fa752d575915ac78f256b3ca4.svg" alt="\ beta \ rightarrow 0">  - à la distance d'Itakura-Saito (divergence Itakura-Saito). <br><br>  Sélection directe de matrice <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H">  produit comme suit: <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H">  initialisé avec des valeurs aléatoires de 0 à 1, après quoi ses valeurs sont mises à jour de manière itérative selon la règle suivante (le nombre d'itérations est fixé à l'avance): <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce2/ab9/9ba/ce2ab99baf9cf808d44be37992988bd9.svg" alt="h_ {jk} = h_ {jk} \ frac {\ sum ^ R_ {i = 1} {w_ {ij} \ frac {v_ {ik}} {[WH] ^ {2- \ beta} _ {ik}} }} {\ sum ^ R_ {i = 1} {w_ {ij} [WH] ^ {\ beta-1} _ {ik}}}"></div><br>  Chaque valeur <img src="https://habrastorage.org/getpro/habr/post_images/40e/522/a20/40e522a2076658bdacea86b0879cbd0e.svg" alt="h_ {ij}">  correspond au degré de similitude <img src="https://habrastorage.org/getpro/habr/post_images/75c/b01/aa8/75cb01aa8d9f97db4343ac0c5ef11b2d.svg" alt="je">  personnage de l'ensemble avec <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">  -ème section de l'image. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/jn/1m/pbjn1mivzxwizfdv4icdcxw-fam.png" width="380"></div><br>  Donc, pour déterminer quel caractère doit être remplacé <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">  section, il suffit de trouver la valeur maximale dans <img src="https://habrastorage.org/getpro/habr/post_images/c73/07a/1bf/c7307a1bf9d387db2abbcfc4215797c1.svg" alt="j">  e colonne de la matrice <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H">  .  Le numéro de ligne dans lequel se trouve cette valeur sera le numéro du caractère souhaité dans l'ensemble.  Vous pouvez également saisir une valeur seuil. <img src="https://habrastorage.org/getpro/habr/post_images/dfd/a20/501/dfda20501ea6a3b10420bbd24587e600.svg" alt="\ epsilon">  , et si la valeur maximale trouvée est inférieure à ce seuil, alors la section d'image est remplacée par un espace.  L'utilisation d'un espace peut avoir un effet positif sur l'apparence de l'image résultante par rapport à l'utilisation d'un symbole avec un faible degré de similitude. <br><br><h2>  Implémentation </h2><br>  L'algorithme est implémenté en C #.  Les graphiques ASCII sont générés à l'aide de 95 caractères (de 0x20 à 0x7E) avec une taille de 11x23 pixels;  La police utilisée est Courier.  Vous trouverez ci-dessous le code source de la fonction permettant de convertir l'image d'origine en graphiques ASCII: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[,] ConvertImage( Bitmap image, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> beta, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> threshold, <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> iterationsCount, <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> threadsNumber, Action&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ProgressUpdated) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumHor = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Width / glyphWidth); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumVert = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Height / glyphHeight); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> totalCharactersNumber = charNumVert * charNumHor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> glyphSetSize = wNorm.ColumnCount; Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; v = SplitImage(image, charNumVert, charNumHor); Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; h = Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;.Build.Random( glyphSetSize, totalCharactersNumber, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContinuousUniform()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> progress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> step = (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>)(iterationsCount / <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iterationsCount; i++) { UpdateH(v, wNorm, h, beta, threadsNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % step == <span class="hljs-number"><span class="hljs-number">0</span></span>) { progress += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(progress &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { ProgressUpdated(progress); } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = GetAsciiRepresentation(h, charNumVert, charNumHor, threshold); ProgressUpdated(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  Considérez chaque étape individuellement: <br><br>  1) Nous calculons le nombre de caractères pouvant tenir dans la largeur et la hauteur de l'image: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumHor = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Width / glyphWidth); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumVert = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Round((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)image.Height / glyphHeight);</code> </pre><br>  En utilisant les valeurs calculées, nous divisons l'image d'origine en blocs de la taille requise.  Pour chaque bloc, nous écrivons les valeurs de l'intensité de couleur des pixels dans la colonne de matrice correspondante <img src="https://habrastorage.org/getpro/habr/post_images/16c/36a/136/16c36a136a8b7f32e276c761a28366ad.svg" alt="V">  (si nécessaire, nous développons l'image d'origine en ajoutant des valeurs nulles correspondant à des pixels blancs à la matrice), après quoi nous normalisons toutes les colonnes: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Matrix&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SplitImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Bitmap image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> charNumVert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> charNumHor</span></span></span><span class="hljs-function">)</span></span> { Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; result = Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;.Build.Dense( glyphHeight * glyphWidth, charNumHor * charNumVert); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; charNumVert; y++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; charNumHor; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; glyphHeight; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; glyphWidth; i++) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x * glyphWidth + i &lt; image.Width) &amp;&amp; (y * glyphHeight + j &lt; image.Height)) { color = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> - image.GetPixel( x * glyphWidth + i, y * glyphHeight + j).R); } result[glyphWidth * j + i, charNumHor * y + x] = color; } } } } result = result.NormalizeColumns(<span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  2) Remplissez la matrice <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H">  valeurs aléatoires de 0 à 1: <br><br><pre> <code class="cs hljs">Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; h = Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;.Build.Random( glyphSetSize, totalCharactersNumber, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContinuousUniform());</code> </pre><br>  Nous appliquons la règle de mise à jour un nombre spécifié de fois à ses éléments: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; iterationsCount; i++) { UpdateH(v, wNorm, h, beta, threadsNumber); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % step == <span class="hljs-number"><span class="hljs-number">0</span></span>) { progress += <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(progress &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) { ProgressUpdated(progress); } } }</code> </pre><br>  La mise à jour directe des éléments de la matrice est implémentée comme suit (malheureusement, les problèmes associés à la division par zéro sont résolus à l'aide de quelques béquilles): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateH</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Matrix&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; v, Matrix&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; w, Matrix&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; h, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ushort</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threadsNumber</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> epsilon = <span class="hljs-number"><span class="hljs-number">1e-6</span></span>; Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; vApprox = w.Multiply(h); Parallel.For( <span class="hljs-number"><span class="hljs-number">0</span></span>, h.RowCount, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParallelOptions() { MaxDegreeOfParallelism = threadsNumber }, j =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; h.ColumnCount; k++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> numerator = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> denominator = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; w.RowCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(vApprox[i, k]) &gt; epsilon) { numerator += w[i, j] * v[i, k] / Math.Pow(vApprox[i, k], <span class="hljs-number"><span class="hljs-number">2.0</span></span> - beta); denominator += w[i, j] * Math.Pow(vApprox[i, k], beta - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { numerator += w[i, j] * v[i, k]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (beta - <span class="hljs-number"><span class="hljs-number">1.0</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { denominator += w[i, j] * Math.Pow(vApprox[i, k], beta - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { denominator += w[i, j]; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(denominator) &gt; epsilon) { h[j, k] = h[j, k] * numerator / denominator; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { h[j, k] = h[j, k] * numerator; } } }); }</code> </pre><br>  3) La dernière étape consiste à sélectionner un symbole approprié pour chaque section d'image en trouvant les valeurs maximales dans les colonnes de la matrice <img src="https://habrastorage.org/getpro/habr/post_images/799/e1a/b6e/799e1ab6e2aed6029f5258773ea6eba1.svg" alt="H">  : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[,] GetAsciiRepresentation( Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; h, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumVert, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> charNumHor, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> threshold) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[,] result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[charNumVert, charNumHor]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; h.ColumnCount; j++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> max = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; h.RowCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (max &lt; h[i, j]) { max = h[i, j]; maxIndex = i; } } result[j / charNumHor, j % charNumHor] = (max &gt;= threshold) ? (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)(firstGlyphCode + maxIndex) : <span class="hljs-string"><span class="hljs-string">' '</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  L'image résultante est écrite dans le fichier html.  Le code source complet du programme peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Exemples d'images générées </h2><br>  Voici des exemples d'images générées à différentes valeurs de paramètres <img src="https://habrastorage.org/getpro/habr/post_images/818/11b/0b2/81811b0b26d4b7e534b439a41d4eb61f.svg" alt="\ beta">  et le nombre d'itérations.  L'image originale avait une taille de 407x500 pixels, respectivement, l'image résultante avait une taille de 37x22 caractères. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t-/ah/4s/t-ah4s39lekdubpaxzd_jj8zhte.png" width="600"></div><br><h2>  Conclusion </h2><br>  Dans l'algorithme considéré, les inconvénients suivants peuvent être distingués: <br><br><ol><li>  Traitement d'image long: selon la taille de l'image et le nombre d'itérations, cela peut prendre de plusieurs dizaines de secondes à plusieurs dizaines de minutes. </li><li>  Traitement de mauvaise qualité des images détaillées.  Par exemple, une tentative de conversion d'une image d'un visage humain donne le résultat suivant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/mx/9c/uhmx9cl4ccuqhzhh1sydlp6ieai.png" width="600"></div></li></ol><br>  Dans le même temps, la réduction du nombre de pièces en augmentant la luminosité et le contraste de l'image peut améliorer considérablement l'apparence de l'image résultante: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l4/qs/qo/l4qsqozovwtwlkdw_ajn_wpbueq.png" width="600"></div><br>  En général, malgré les inconvénients ci-dessus, nous pouvons conclure que l'algorithme donne des résultats satisfaisants. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463193/">https://habr.com/ru/post/fr463193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463179/index.html">Big Data Big Billing: à propos du BigData dans les télécommunications</a></li>
<li><a href="../fr463181/index.html">Figma - une solution simple pour un concepteur, une solution difficile pour un concepteur de mise en page</a></li>
<li><a href="../fr463183/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 13. Configurer le VLAN</a></li>
<li><a href="../fr463185/index.html">Comment de puissants tremblements de terre en Bolivie ont découvert des montagnes à une profondeur de 660 kilomètres sous terre</a></li>
<li><a href="../fr463189/index.html">À propos de l'anonymat sur Internet, de la vie et de sa relativité</a></li>
<li><a href="../fr463195/index.html">Que se passe-t-il avec Internet Tele2</a></li>
<li><a href="../fr463197/index.html">Blazor + MVVM = Silverlight riposte parce que le mal ancien est invincible</a></li>
<li><a href="../fr463205/index.html">Initialement inutilisable: comment survivre avec un ordinateur portable sous Windows 10 et un lecteur de 32 gigaoctets</a></li>
<li><a href="../fr463213/index.html">Idées fausses pour les développeurs C # novices. Essayer de répondre à des questions standard</a></li>
<li><a href="../fr463215/index.html">Les ingénieurs et les architectes conçoivent déjà des établissements lunaires</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>