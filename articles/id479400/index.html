<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ğŸ» ğŸˆ ğŸš† Cara membuat jurnalis dari jaringan saraf, atau â€œRahasia mengurangi teks di HabrÃ© tanpa sepatah kata pun ğŸ‘µ ğŸ‚ ğŸ™ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hanya saja, jangan kaget, tetapi pos kedua ke posting ini menghasilkan jaringan saraf, atau lebih tepatnya, algoritma sammarisasi. Dan apa itu sammari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat jurnalis dari jaringan saraf, atau â€œRahasia mengurangi teks di HabrÃ© tanpa sepatah kata pun</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/479400/"><img src="https://habrastorage.org/webt/iq/f_/fg/iqf_fgkfyqb1rbtwvba0p4gbsiq.png" align="left">  Hanya saja, jangan kaget, tetapi pos kedua ke posting ini menghasilkan jaringan saraf, atau lebih tepatnya, algoritma sammarisasi.  Dan apa itu sammarisasi? <br><br>  Ini adalah salah satu <a href="https://habr.com/ru/company/abbyy/blog/437008/">tantangan</a> utama dan klasik <a href="https://habr.com/ru/company/abbyy/blog/437008/">dari Natural Language Processing (NLP)</a> .  Ini terdiri dalam menciptakan algoritma yang mengambil teks sebagai input dan output versi singkatnya.  Selain itu, struktur yang benar (sesuai dengan norma-norma bahasa) dipertahankan di dalamnya dan gagasan utama teks ditransmisikan dengan benar. <br><br>  Algoritma seperti ini banyak digunakan di industri.  Misalnya, mereka berguna untuk mesin pencari: menggunakan pengurangan teks, Anda dapat dengan mudah memahami apakah ide utama sebuah situs atau dokumen berkorelasi dengan permintaan pencarian.  Mereka digunakan untuk mencari informasi yang relevan dalam aliran besar data media dan untuk menyaring informasi sampah.  Pengurangan teks membantu dalam penelitian keuangan, dalam analisis kontrak hukum, anotasi makalah ilmiah dan banyak lagi.  Omong-omong, algoritma sammarisasi menghasilkan semua subpos untuk posting ini. <br><br>  Yang mengejutkan saya, di HabrÃ© ada sedikit artikel tentang sammarisasi, jadi saya memutuskan untuk membagikan penelitian dan hasil saya ke arah ini.  Tahun ini saya berpartisipasi dalam arena pacuan kuda di konferensi <a href="http://www.dialog-21.ru/">Dialog</a> dan bereksperimen dengan generator utama untuk item berita dan puisi menggunakan jaringan saraf.  Dalam posting ini, pertama-tama saya akan membahas secara singkat bagian teoritis dari sammarisasi, dan kemudian saya akan memberikan contoh dengan generasi judul, saya akan memberi tahu Anda apa kesulitan yang dimiliki model ketika mengurangi teks dan bagaimana model ini dapat ditingkatkan untuk mencapai judul yang lebih baik. <br><a name="habracut"></a><br>  Di bawah ini adalah contoh dari item berita dan headline referensi aslinya.  Model yang akan saya bicarakan akan melatih untuk menghasilkan header dengan contoh ini: <br><br><img src="https://habrastorage.org/webt/8n/yy/gc/8nyygcx_ymy38dwrqpbqdiylvsu.png" alt="gambar"><br><br><h2>  Rahasia memotong arsitektur teks seq2seq </h2><br>  Ada dua jenis metode pengurangan teks: <br><br><ol><li>  <b>Ekstraktif</b> .  Ini terdiri dari menemukan bagian-bagian paling informatif dari teks dan membangun dari mereka penjelasan yang benar untuk bahasa yang diberikan.  Kelompok metode ini hanya menggunakan kata-kata yang ada di teks sumber. </li><li>  <b>Abstrak</b>  Ini terdiri dari mengekstraksi tautan semantik dari teks, sambil mempertimbangkan dependensi bahasa akun.  Dengan sammarisasi abstrak, kata-kata penjelasan tidak dipilih dari teks yang disingkat, tetapi dari kamus (daftar kata-kata untuk bahasa tertentu) - dengan demikian mengulangi gagasan utama. </li></ol><br>  Pendekatan kedua menyiratkan bahwa algoritma harus memperhitungkan dependensi bahasa akun, menyusun ulang dan menggeneralisasi.  Dia juga ingin memiliki pengetahuan tentang dunia nyata untuk mencegah kesalahan faktual.  Untuk waktu yang lama, ini dianggap sebagai tugas yang sulit, dan para peneliti tidak bisa mendapatkan solusi berkualitas tinggi - teks yang secara tata bahasa benar sambil mempertahankan ide utama.  Itulah sebabnya di masa lalu, sebagian besar algoritma didasarkan pada pendekatan penggalian, karena pemilihan seluruh bagian teks dan mentransfernya ke hasilnya memungkinkan Anda untuk mempertahankan tingkat literasi yang sama dengan sumbernya. <br><br>  Tapi ini sebelum booming jaringan saraf dan penetrasi ke dalam NLP.  Pada tahun 2014, arsitektur <b>seq2seq diperkenalkan dengan mekanisme perhatian</b> yang dapat membaca beberapa urutan teks dan menghasilkan yang lain (yang tergantung pada apa yang dipelajari oleh model untuk dihasilkan) ( <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf">artikel</a> oleh Sutskever et al.).  Pada tahun 2016, arsitektur semacam itu diterapkan langsung ke solusi masalah sammarisasi, sehingga mewujudkan pendekatan abstrak dan memperoleh hasil yang sebanding dengan apa yang dapat ditulis oleh orang yang kompeten ( <a href="https://arxiv.org/pdf/1602.06023.pdf">artikel</a> dari Nallapati et al., 2016; <a href="https://arxiv.org/pdf/1509.00685.pdf">artikel</a> dari Rush et al., 2015; )  Bagaimana cara kerja arsitektur ini? <br><br><img src="https://habrastorage.org/webt/px/4x/wi/px4xwin577dd65z-lahsx7fvexs.png" alt="gambar"><br><br>  Seq2Seq terdiri dari dua bagian: <br><br><ol><li>  <b>Encoder</b> (Encoder) - RNN dua arah, yang digunakan untuk membaca urutan input, yaitu, secara berurutan memproses elemen input secara simultan dari kiri ke kanan dan dari kanan ke kiri untuk lebih mempertimbangkan konteksnya. </li><li>  <b>decoder</b> (Decoder) - RNN satu arah, yang secara berurutan dan elemen-bijaksana menghasilkan urutan output. </li></ol><br>  Pertama, urutan input diterjemahkan ke dalam urutan embedding (singkatnya, embedding adalah representasi singkat dari sebuah kata sebagai vektor).  Embeddings kemudian melalui jaringan rekursif encoder.  Jadi, untuk setiap kata, kita mendapatkan status tersembunyi pembuat enkode ( <i>ditunjukkan oleh segi empat merah pada diagram</i> ), dan mereka berisi informasi tentang token itu sendiri dan konteksnya, memungkinkan kita untuk memperhitungkan koneksi bahasa antara kata-kata tersebut. <br><br>  Setelah memproses input, encoder mentransfer status tersembunyi terakhirnya (yang berisi informasi terkompresi tentang seluruh teks) ke decoder, yang menerima token khusus <img src="https://habrastorage.org/webt/qn/ud/38/qnud38u15vpvzie4zkne-doze7k.png" alt="gambar">  dan menciptakan kata pertama dari urutan output ( <i>dalam gambar itu adalah "Jerman"</i> ).  Kemudian ia secara siklik mengambil output sebelumnya, mengumpankannya sendiri dan kembali menampilkan elemen output berikutnya ( <i>jadi setelah "Jerman" muncul "beat", dan setelah "beat" muncul kata berikutnya, dll</i> .).  Ini diulang sampai tanda khusus dikeluarkan <img src="https://habrastorage.org/webt/vw/kv/4g/vwkv4gs-ul7vlvnkjwxag8njicw.png" alt="gambar">  .  Ini berarti akhir generasi. <br><br>  Untuk menampilkan elemen berikutnya, decoder, seperti halnya encoder, mengubah token input menjadi embedding, mengambil langkah dari jaringan rekursif dan menerima keadaan tersembunyi berikutnya dari decoder ( <i>persegi panjang kuning pada diagram</i> ).  Kemudian, menggunakan lapisan yang terhubung penuh, distribusi probabilitas diperoleh untuk semua kata dari kamus model yang dikompilasi sebelumnya.  Kata-kata yang paling mungkin akan disimpulkan oleh model. <br><br>  Menambahkan <b>mekanisme perhatian</b> membantu decoder memanfaatkan informasi input dengan lebih baik.  Mekanisme pada setiap langkah generasi menentukan apa yang disebut <b>distribusi perhatian</b> ( <i>segi empat biru pada gambar adalah himpunan bobot yang sesuai dengan elemen-elemen dari urutan asli, jumlah bobot adalah 1, semua bobot&gt; = 0</i> ), dan dari itu menerima jumlah tertimbang dari semua status tersembunyi dari enkoder, dengan demikian membentuk vektor konteks ( <i>diagram menunjukkan persegi panjang merah dengan goresan biru</i> ).  Vektor ini diakhiri dengan menanamkan kata input dekoder pada tahap penghitungan keadaan laten dan dengan keadaan laten itu sendiri pada tahap penentuan kata berikutnya.  Jadi pada setiap langkah output, model dapat menentukan status encoder mana yang paling penting untuk saat ini.  Dengan kata lain, itu memutuskan konteks yang kata input harus paling diperhitungkan (misalnya, dalam gambar, menampilkan kata "beat", mekanisme perhatian memberikan bobot besar untuk token "menang" dan "menang", dan sisanya mendekati nol). <br><br>  Karena generasi header juga merupakan salah satu tugas sammarisasi, hanya dengan output seminimal mungkin (1-12 kata), saya memutuskan untuk menerapkan <b>seq2seq dengan mekanisme perhatian</b> untuk kasus kami.  Kami melatih sistem semacam itu pada teks dengan judul, misalnya, tentang berita.  Selain itu, disarankan pada tahap pelatihan untuk menyerahkan ke decoder bukan outputnya sendiri, tetapi kata-kata dari heading yang sebenarnya (guru memaksa), membuat hidup lebih mudah untuk dirinya sendiri dan modelnya.  Sebagai fungsi kesalahan, kami menggunakan fungsi kerugian lintas-entropi standar, menunjukkan seberapa dekat distribusi probabilitas kata output dan kata dari header sebenarnya adalah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3v/co/b9/3vcob9esvdhgsydjcnjfpzv2wbi.png"></div><br>  Saat menggunakan model terlatih, kami menggunakan pencarian ray untuk menemukan urutan kata yang lebih mungkin daripada menggunakan algoritma serakah.  Untuk melakukan ini, pada setiap langkah generasi, kami bukan berasal dari kata yang paling mungkin, tetapi pada saat yang sama melihat pada beam_size dari urutan kata yang paling mungkin.  Ketika mereka berakhir (masing-masing berakhir <img src="https://habrastorage.org/webt/vw/kv/4g/vwkv4gs-ul7vlvnkjwxag8njicw.png" alt="gambar">  ), kami memperoleh urutan yang paling mungkin. <br><br><img src="https://habrastorage.org/webt/t2/dt/ni/t2dtnicefjxn0hwd0elaeduekbk.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yx/ln/q-/yxlnq-7z2-lwuyylmz83pferopm.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/81/9u/ey819uvi_jhx4wbwchr-wsixvgs.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/q1/tn/zu/q1tnzuopjtdslrltsmn8euup-kq.png"></div><br><br><h2>  Evolusi model </h2><br>  Salah satu masalah model pada seq2seq adalah ketidakmampuan untuk mengutip kata-kata yang tidak ada dalam kamus.  Misalnya, model tidak memiliki kesempatan untuk menyimpulkan "obamacare" dari artikel di atas.  Hal yang sama berlaku untuk: <br><br><ul><li>  nama keluarga dan nama langka </li><li>  ketentuan baru </li><li>  kata dalam bahasa lain, </li><li>  pasangan kata yang berbeda dihubungkan oleh tanda hubung (sebagai "Senator Republik") </li><li>  dan desain lainnya. </li></ul><br>  Tentu saja, Anda dapat memperluas kamus, tetapi ini sangat meningkatkan jumlah parameter terlatih.  Selain itu, perlu untuk menyediakan sejumlah besar dokumen di mana kata-kata langka ini ditemukan, sehingga generator belajar untuk menggunakannya secara kualitatif. <br><br>  Solusi lain dan lebih elegan untuk masalah ini disajikan dalam artikel 2017 - " <a href="https://arxiv.org/pdf/1704.04368.pdf">Get To The Point: Summarization dengan Pointer-Generator Networks</a> " (Abigail See et al.).  Dia menambahkan mekanisme baru ke model kami - <b>mekanisme</b> penunjuk, yang dapat memilih kata-kata dari teks sumber dan langsung memasukkan ke dalam urutan yang dihasilkan.  Jika teks berisi OOV ( <i>dari kosakata - kata yang tidak ada dalam kamus</i> ), maka model, jika dianggap perlu, dapat mengisolasi OOV dan memasukkannya pada output.  Sistem seperti ini disebut <b>"</b> pointer-generator" (pointer-generator atau pg) dan merupakan sintesis dari dua pendekatan untuk sammarisasi.  Dia sendiri dapat memutuskan pada langkah apa dia harus abstrak, dan pada langkah apa - penggalian.  Bagaimana dia melakukannya, kita akan mencari tahu sekarang. <br><br><img src="https://habrastorage.org/webt/f-/9y/xw/f-9yxwborbgpjpalzwd5e_f74xi.png" alt="gambar"><br><br>  Perbedaan utama dari model seq2seq yang biasa adalah tindakan tambahan di mana p <sub>gen</sub> dihitung - probabilitas generasi.  Ini dilakukan dengan menggunakan status tersembunyi dari decoder dan vektor konteks.  Arti tindakan tambahan itu sederhana.  Semakin dekat p <sub>gen</sub> ke 1, semakin besar kemungkinan bahwa model akan mengeluarkan kata dari kamusnya menggunakan generasi abstrak.  Semakin dekat p <sub>gen</sub> ke 0, semakin besar kemungkinan bahwa generator akan mengekstrak kata dari teks, dipandu oleh distribusi perhatian yang diperoleh sebelumnya.  Distribusi probabilitas akhir dari hasil kata adalah jumlah dari distribusi probabilitas yang dihasilkan dari kata-kata (di mana tidak ada OOV) dikalikan dengan p <sub>gen</sub> dan distribusi perhatian (di mana OOV, misalnya, "2-0" pada gambar) dikalikan dengan (1 - p <sub>gen</sub> ). <br><br><img src="https://habrastorage.org/webt/iv/8f/8q/iv8f8qvol1j3bbyx79vt5zo7-oq.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/ew/s3/ifews3gqgojf5mclbxd0lpkz2q8.png"></div><br>  Selain mekanisme penunjuk, artikel ini memperkenalkan <b>mekanisme peliputan</b> , yang membantu menghindari pengulangan kata-kata.  Saya juga bereksperimen dengan itu, tetapi tidak melihat peningkatan signifikan dalam kualitas judul - itu tidak benar-benar diperlukan.  Kemungkinan besar, ini karena tugas spesifik: karena diperlukan untuk mengeluarkan sejumlah kecil kata-kata, generator tidak punya waktu untuk mengulang sendiri.  Tetapi untuk tugas sammarisasi lainnya, misalnya, anotasi, ini bisa berguna.  Jika tertarik, Anda bisa membacanya di <a href="https://arxiv.org/pdf/1704.04368.pdf">artikel</a> asli. <br><br><img src="https://habrastorage.org/webt/4q/bx/op/4qbxopqt862cphikmbezyaoadlk.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/--/3m/mz/--3mmzahhdk8kelwoqyh9rdjg8e.png"></div><br><h2>  Berbagai macam kata-kata Rusia </h2><br>  Cara lain untuk meningkatkan kualitas header output adalah dengan benar memproses urutan input.  Selain pembuangan karakter huruf besar yang jelas, saya juga mencoba mengubah kata-kata dari teks sumber menjadi pasangan gaya dan infleksi (mis. Fondasi dan akhir).  Untuk pemisahan, gunakan Porter Stemmer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/j8/-y/jyj8-yonzpmvpyoye6mbygrlcjg.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/_k/__/vy/_k__vyhouqm_ctxpsp8ukcselwe.png"></div><br>  Kami menandai semua infleksi dengan simbol "+" di awal untuk membedakannya dari token lain.  Kami menganggap setiap topik dan infleksi sebagai kata yang terpisah dan belajar dari mereka dengan cara yang sama seperti dalam kata-kata.  Artinya, kita mendapatkan embeddings dari mereka dan memperoleh urutan (juga dipecah menjadi fondasi dan ujung) yang dapat dengan mudah diubah menjadi kata-kata. <br><br>  Konversi semacam itu sangat berguna ketika bekerja dengan bahasa yang kaya secara morfologis seperti Rusia.  Alih-alih menyusun kamus besar dengan berbagai macam bentuk kata Rusia, Anda dapat membatasi diri Anda pada sejumlah besar batang kata-kata ini (mereka beberapa kali lebih kecil dari jumlah bentuk kata) dan satu set akhir yang sangat kecil (saya mendapatkan banyak infleksi sebanyak 450).  Dengan demikian, kami membuatnya lebih mudah bagi model untuk bekerja dengan "kekayaan" ini dan pada saat yang sama kami tidak menambah kompleksitas arsitektur dan jumlah parameter. <br><br><img src="https://habrastorage.org/webt/a4/es/s5/a4ess5qr3vaxprksv7avun3obl8.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/rk/6h/3drk6hntzcow2i3soi-heul7ckq.png"></div><br>  Saya juga mencoba menggunakan transformasi lemma + gramme.  Yaitu, dari setiap kata sebelum diproses, Anda bisa mendapatkan bentuk awal dan makna tata bahasa menggunakan paket pymorphy (misalnya, "sudah" <img src="https://habrastorage.org/webt/95/wb/-a/95wb-aopfalycfvrshqfynxnwd4.png" alt="gambar">  "Menjadi" dan "KATA KERJA | impf | masa lalu | sing | femn").  Jadi, saya mendapatkan sepasang urutan paralel (dalam satu - bentuk awal, yang lain - nilai-nilai tata bahasa).  Untuk setiap jenis urutan, saya menyusun embeddings saya, yang kemudian saya gabungkan dan kirimkan ke saluran pipa yang dijelaskan sebelumnya.  Di dalamnya, decoder tidak belajar mengeluarkan kata-kata, tetapi sebuah lemma dan tata bahasa.  Tetapi sistem seperti itu tidak membawa perbaikan yang terlihat dibandingkan dengan pg pada topik.  Mungkin itu adalah arsitektur yang terlalu sederhana untuk bekerja dengan nilai-nilai tata bahasa, dan layak membuat classifier terpisah untuk setiap kategori tata bahasa dalam output.  Tetapi saya tidak bereksperimen dengan model yang demikian atau lebih rumit. <br><br>  Saya bereksperimen dengan tambahan lain pada arsitektur asli dari pointer-generator, yang, bagaimanapun, tidak berlaku untuk preprocessing.  Ini adalah peningkatan jumlah lapisan (hingga 3) dari jaringan rekursif dari encoder dan decoder.  Meningkatkan kedalaman jaringan berulang dapat meningkatkan kualitas output, karena keadaan tersembunyi dari lapisan terakhir dapat berisi informasi tentang input yang jauh lebih lama daripada keadaan tersembunyi dari RNN lapisan tunggal.  Ini membantu untuk memperhitungkan koneksi semantik yang diperluas kompleks antar elemen dari urutan input.  Benar, ini memerlukan peningkatan yang signifikan dalam jumlah parameter model dan menyulitkan pembelajaran. <br><br><img src="https://habrastorage.org/webt/cf/7g/ej/cf7gejf-hxd5pbscvqgnvuuviqy.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4g/ww/zy/4gwwzytsrt506_xllgy5xcis6vk.png"></div><br><h2>  Eksperimen Header Generator </h2><br>  Semua percobaan saya pada generator judul dapat dibagi menjadi dua jenis: percobaan dengan artikel berita dan ayat.  Saya akan memberi tahu Anda tentang mereka secara berurutan. <br><br><h3>  Eksperimen Berita </h3><br>  Ketika bekerja dengan berita, saya menggunakan model seperti seq2seq, pg, pg dengan batang dan infleksi - single-layer dan three-layer.  Saya juga mempertimbangkan model yang bekerja dengan gram, tetapi semua yang ingin saya ceritakan tentangnya, sudah saya jelaskan di atas.  Saya harus mengatakan segera bahwa semua pg yang dijelaskan dalam bagian ini menggunakan mekanisme pelapisan, walaupun pengaruhnya terhadap hasilnya diragukan (karena tanpanya tidak jauh lebih buruk). <br><br>  Saya dilatih pada dataset RIA Novosti, yang disediakan oleh kantor berita Rossiya Segodnya untuk melakukan jalur pembuatan berita utama di konferensi Dialog.  Dataset berisi 1.003.869 artikel berita yang diterbitkan dari Januari 2010 hingga Desember 2014. <br><br>  Semua model yang dipelajari menggunakan embeddings yang sama (128), kosa kata (100k) dan status laten (256) dan dilatih untuk jumlah era yang sama.  Oleh karena itu, hanya perubahan kualitatif dalam arsitektur atau preprocessing yang dapat mempengaruhi hasilnya. <br><br>  Model yang disesuaikan untuk bekerja dengan teks yang sudah diproses memberikan hasil yang lebih baik daripada model yang bekerja dengan kata-kata.  Pg tiga lapis yang menggunakan informasi tentang topik dan infleksi bekerja paling baik.  Saat menggunakan pg apa pun, peningkatan yang diharapkan dalam kualitas header dibandingkan dengan seq2seq juga muncul, yang mengisyaratkan penggunaan pointer yang lebih disukai saat menghasilkan header.  Berikut adalah contoh pengoperasian semua model: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6w/4u/0r/6w4u0ruudngxtt2szek31w0achq.png"></div><br>  Melihat header yang dihasilkan, kita dapat membedakan masalah berikut dari model yang diteliti: <br><br><ol><li>  Model sering menggunakan bentuk kata yang tidak teratur.  Model dengan batang (seperti pada contoh di atas) lebih lega dari kelemahan ini; </li><li>  Semua model, kecuali yang bekerja dengan tema, dapat menghasilkan header yang tampaknya tidak lengkap, atau desain aneh yang tidak ada dalam bahasa (seperti pada contoh di atas); </li><li>  Semua model yang dipelajari sering membingungkan orang yang dijelaskan, mengganti tanggal yang salah atau menggunakan kata-kata yang tidak cocok. </li></ol><br><img src="https://habrastorage.org/webt/9c/-b/ot/9c-bote3bwomvfu_3bwaixhqnks.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e-/3c/px/e-3cpxuknykthyu-xvf-cp-rdsi.png"></div><br><img src="https://habrastorage.org/webt/lf/ry/ep/lfryepksl4kmcqxttb14ikgx4wg.png" alt="gambar"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b3/4m/fw/b34mfwpsffud2kaa93tccjvyja0.png"></div><br><h3>  Eksperimen dengan ayat-ayat </h3><br>  Karena pg tiga lapis dengan tema memiliki ketidakakuratan paling sedikit dalam header yang dihasilkan, ini adalah model yang saya pilih untuk eksperimen dengan ayat.  Saya mengajarinya tentang kasus ini, terdiri dari 6 juta puisi Rusia dari situs "stihi.ru".  Mereka termasuk cinta (sekitar setengah dari ayat-ayat yang dikhususkan untuk topik ini), civic (sekitar seperempat), puisi urban dan lansekap.  Periode penulisan: Januari 2014 - Mei 2019. Saya akan memberikan contoh judul yang dihasilkan untuk ayat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yv/mo/da/yvmodarkck7cgra-ymxigffwhik.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3u/mb/fn/3umbfnpzo1hwhqy0_glxyhxynu4.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tp/tk/5e/tptk5eoq9wa1xrnj9w0gewjeayk.png"></div><br><br>  Model itu ternyata sebagian besar mengekstraksi: hampir semua header adalah satu baris, sering diekstraksi dari bait pertama atau terakhir.  Dalam kasus luar biasa, model dapat menghasilkan kata-kata yang tidak ada dalam puisi.  Ini disebabkan oleh kenyataan bahwa sejumlah besar teks dalam kasus ini benar-benar memiliki salah satu baris sebagai sebuah nama. <br><br>  Sebagai kesimpulan, saya akan mengatakan bahwa generator indeks, bekerja pada batang dan menggunakan decoder dan encoder single-layer, mengambil tempat kedua di jalur <a href="https://vk.com/wall-177402111_31">kompetisi</a> untuk menghasilkan berita utama untuk artikel berita pada konferensi dialog ilmiah pada linguistik komputer "Dialog".  Penyelenggara utama konferensi ini adalah ABBYY, perusahaan ini terlibat dalam penelitian di hampir semua area modern Pengolahan Bahasa Alam. <br><br>  Akhirnya, saya sarankan Anda sedikit interaktif: kirim berita di komentar, dan lihat tajuk apa yang akan dihasilkan oleh jaringan saraf untuknya. <br><br>  <i>Matvey, pengembang di NLP Group di ABBYY</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479400/">https://habr.com/ru/post/id479400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479384/index.html">Apa yang dilakukan Big Data di MegaFon dan bagaimana menuju ke sana?</a></li>
<li><a href="../id479388/index.html">Fitur pembangunan pusat data nasional, Mikhalych</a></li>
<li><a href="../id479392/index.html">Pinebook Pro: Tidak lagi Chromebook</a></li>
<li><a href="../id479394/index.html">Bagaimana saya mencari helpdesk di antara 15 solusi dan ... tidak menemukan</a></li>
<li><a href="../id479398/index.html">Kami membawa persamaan regresi linier ke dalam bentuk matriks</a></li>
<li><a href="../id479402/index.html">Bagaimana cara resmi membayar layanan freelancer di luar negeri, membayar pajak 0% dan tidak memberi makan sistem pembayaran</a></li>
<li><a href="../id479404/index.html">Staf untuk Santa Claus</a></li>
<li><a href="../id479406/index.html">16 kiat pengembangan untuk Android di Kotlin. Bagian 1</a></li>
<li><a href="../id479414/index.html">Cara menemukan tujuannya. Peran peluang</a></li>
<li><a href="../id479416/index.html">Lihat ke mana Anda pergi (penglihatan tepi vs muatan kognitif)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>