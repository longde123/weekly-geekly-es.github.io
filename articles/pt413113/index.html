<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèæ üë®üèª‚Äçüè≠ ‚è∞ Classe JavaScript Suporte √† serializa√ß√£o de JavaScript üôéüèø üëçüèª üî°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√≥logo 


 Atualmente, estou desenvolvendo um editor de esquema Javascript e, no processo deste trabalho, encontrei um problema no qual este artigo s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Classe JavaScript Suporte √† serializa√ß√£o de JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413113/"><h3 id="prolog">  Pr√≥logo </h3><br><p>  Atualmente, estou desenvolvendo um editor de esquema Javascript e, no processo deste trabalho, encontrei um problema no qual este artigo se concentrar√°, a saber, serializa√ß√£o e desserializa√ß√£o de objetos de dados complexos. </p><br><p> Sem entrar em detalhes do projeto, observo que, de acordo com minha ideia, o esquema √© uma matriz de elementos (v√©rtices) herdados da classe base.  Consequentemente, cada classe filho implementa sua pr√≥pria l√≥gica.  Al√©m disso, os v√©rtices cont√™m links entre si (setas), que tamb√©m precisam ser preservados.  Teoricamente, os v√©rtices podem se referir a si mesmos diretamente ou atrav√©s de outros v√©rtices.  O JSON.stringify padr√£o n√£o pode serializar essa matriz, ent√£o decidi criar meu pr√≥prio serializador que resolve os dois problemas descritos: </p><br><ol><li>  Capacidade de salvar informa√ß√µes de classe durante a serializa√ß√£o e restaur√°-las durante a desserializa√ß√£o. </li><li>  A capacidade de salvar e restaurar links para objetos, incluindo  c√≠clico. </li></ol><br><p>  Leia mais sobre a declara√ß√£o do problema e sua solu√ß√£o sob o corte. </p><a name="habracut"></a><br><h3 id="proekt-serializatora-na-github">  Projeto de serializador do Github </h3><br><p>  Link para o projeto github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . <br>  Exemplos complexos tamb√©m est√£o na pasta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">test-src</a> . </p><br><p>  Serializador recursivo: <a href="">link</a> . <br>  Serializador plano: <a href="">link</a> . </p><br><h3 id="postanovka-zadachi">  Declara√ß√£o do problema </h3><br><p>  Como j√° observei, a tarefa inicial √© serializar circuitos arbitr√°rios para o editor.  Para n√£o perder tempo descrevendo o editor, facilitamos a tarefa.  Suponha que desejemos fazer uma descri√ß√£o formal de um esquema de algoritmo simples usando classes Javascript ES6 e depois serializar e desserializar esse esquema. </p><br><p>  Na Internet, encontrei uma imagem adequada do algoritmo mais simples para determinar o m√°ximo de dois valores: </p><br><p><img src="https://habrastorage.org/webt/dk/fa/yk/dkfaykajbnvk5ma4djpceof1wps.png" alt="imagem"></p><br><p>  Aqui devo dizer que n√£o sou desenvolvedor de Javascript e minha linguagem "nativa" √© C #, portanto a abordagem para resolver o problema √© ditada pela experi√™ncia do desenvolvimento orientado a objetos em C #.  Observando este diagrama, vejo os v√©rtices dos seguintes tipos (nomes condicionais e fun√ß√µes especiais n√£o desempenham): </p><br><ul><li>  Iniciar v√©rtice (Iniciar) </li><li>  Pico final (acabamento) </li><li>  Equipe Top (Comando) </li><li>  V√©rtice de atribui√ß√£o (Let) </li><li>  Verifica√ß√£o Verifica√ß√£o superior (se) </li></ul><br><p>  Esses v√©rtices t√™m algumas diferen√ßas entre si em seu conjunto de dados ou sem√¢ntica, mas s√£o todos herdados do v√©rtice base (N√≥).  No mesmo local, na classe Node, √© descrito o campo de links, que cont√©m links para outros v√©rtices, e o m√©todo addLink permite que esses links sejam adicionados.  O c√≥digo completo de todas as classes pode ser encontrado <a href="">aqui</a> . </p><br><p>  Vamos escrever o c√≥digo que coleta o circuito da imagem e tentar serializar o resultado. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de Design do Algoritmo</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let start = new Schema.Start(); let input = new Schema.Command(' A, B'); let check = new Schema.If('A &gt; B'); let maxIsA = new Schema.Let('Max', 'A'); let maxIsB = new Schema.Let('Max', 'B'); let output = new Schema.Command(' Max'); let finish = new Schema.Finish(); //   start.addLink(input); input.addLink(check); check.addLink(maxIsA, { condition: 'true' }); check.addLink(maxIsB, { condition: 'false' }); maxIsA.addLink(output); maxIsB.addLink(output); output.addLink(finish); //    ( ) let schema = [ start, input, check, maxIsA, maxIsB, output, finish ];</span></span></code> </pre> </div></div><br><p>  Se serializarmos esse esquema usando JSON.stringify, obteremos algo terr√≠vel.  Vou dar as primeiras linhas do resultado, nas quais adicionei meus coment√°rios: </p><br><div class="spoiler">  <b class="spoiler_title">Resultado JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">[ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d9c8ab69-e4fa-4433-80bb-1cc7173024d6"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"f87a3913-84b0-4b70-8927-6111c6628a1f"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"94a47403-13ab-4c83-98fe-3b201744c8f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"If"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { ...</code> </pre> </div></div><br><p>  Porque  o primeiro v√©rtice continha um link para o segundo e, para os subsequentes, ent√£o, como resultado de sua serializa√ß√£o, todo o circuito foi serializado.  Em seguida, o segundo pico foi serializado e tudo o que dependia dele, e assim por diante.  Voc√™ pode restaurar os links originais desse hash apenas por identificadores, mas eles n√£o ajudar√£o se algum dos v√©rtices se referir a si pr√≥prio diretamente ou atrav√©s de outros v√©rtices.  Nesse caso, o serializador <u>lan√ßar√° um</u> erro <u>TypeError Uncaught: Convertendo estrutura circular em</u> erro <u>JSON</u> .  Se n√£o estiver claro, eis o exemplo mais simples que gera esse erro: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://jsfiddle.net/L4guo86w/</a> . </p><br><p>  Al√©m disso, o JSON n√£o cont√©m nenhuma informa√ß√£o sobre as classes de origem, portanto, n√£o h√° como entender que tipo de v√©rtice era antes da serializa√ß√£o. </p><br><p>  Percebendo esses problemas, entrei na Internet e comecei a procurar solu√ß√µes prontas.  Havia muitos, mas a maioria era muito volumosa ou exigia uma descri√ß√£o especial das classes serializ√°veis, por isso foi decidido fabricar sua pr√≥pria bicicleta.  E sim, eu amo bicicletas. </p><br><h3 id="koncepciya-serializatora">  Conceito de serializador </h3><br><p>  Esta se√ß√£o √© para quem deseja participar da cria√ß√£o de um algoritmo de serializa√ß√£o comigo, embora virtualmente. </p><br><h4 id="sohranenie-informacii-o-tipah-dannyh">  Salvando informa√ß√µes de tipo de dados </h4><br><p>  Um dos problemas com o Javascript √© a falta de metadados que podem fazer maravilhas em linguagens como C # ou Java (atributos e reflex√£o).  Por outro lado, n√£o preciso de serializa√ß√£o super complexa com a capacidade de definir uma lista de campos serializ√°veis, valida√ß√£o e outros chips.  Portanto, a id√©ia principal √© adicionar informa√ß√µes sobre seu tipo ao objeto e serializ√°-lo com o JSON.stringify comum. </p><br><p>  Enquanto procurava solu√ß√µes, deparei-me com um artigo interessante cujo t√≠tulo se traduz em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"6 maneiras erradas de adicionar informa√ß√µes de tipo no JSON"</a> .  De fato, os m√©todos s√£o muito bons e eu escolhi o n√∫mero 5. Se voc√™ estiver com pregui√ßa de ler o artigo, mas eu recomendo faz√™-lo, descreverei brevemente este m√©todo: ao serializar um objeto, envolvemos-o em outro objeto com o √∫nico um campo cujo nome est√° no formato <code>"@&lt;type&gt;"</code> e o valor s√£o os dados do objeto.  Durante a desserializa√ß√£o, extra√≠mos o nome do tipo, recriamos o objeto do construtor e lemos os dados de seus campos. </p><br><p>  Se removermos os links do nosso exemplo acima, o JSON.stringify padr√£o serializa dados como este: </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> }, ... }</code> </pre> </div></div><br><p>  E o nosso serializador o envolver√° assim: </p><br><div class="spoiler">  <b class="spoiler_title">Resultado de serializa√ß√£o</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } }, ... }</code> </pre> </div></div><br><p>  Obviamente, h√° uma desvantagem: o serializador deve conhecer os tipos que ele pode serializar, e os pr√≥prios objetos n√£o devem conter campos cujo nome come√ßa com um cachorro.  No entanto, o segundo problema √© resolvido por acordo com os desenvolvedores ou substituindo o s√≠mbolo do c√£o por outra coisa, e o primeiro problema √© resolvido em uma linha de c√≥digo (abaixo ser√° um exemplo).  Sabemos exatamente o que serializaremos, certo? </p><br><h4 id="reshenie-problemy-so-ssylkami">  Resolvendo o problema do link </h4><br><p>  Ainda √© mais simples em termos de algoritmo, mas mais dif√≠cil de implementar. </p><br><p>  Ao serializar inst√¢ncias de classes registradas no serializador, as armazenaremos no cache e atribuiremos um n√∫mero de s√©rie.  Se no futuro encontrarmos essa inst√¢ncia novamente, na primeira defini√ß√£o, adicionaremos esse n√∫mero (o nome do campo assumir√° o formato <code>"@&lt;type&gt;|&lt;index&gt;"</code> ) e, no local da serializa√ß√£o, inseriremos o link na forma de um objeto </p><br><pre> <code class="hljs json"> { <span class="hljs-attr"><span class="hljs-attr">"@&lt;type&gt;"</span></span>: &lt;index&gt; }</code> </pre> <br><p>  Assim, durante a desserializa√ß√£o, observamos qual √© exatamente o valor do campo.  Se este for um n√∫mero, extra√≠mos o objeto do cache por esse n√∫mero.  Caso contr√°rio, esta √© sua primeira defini√ß√£o. </p><br><p>  Vamos retornar o link da primeira parte superior do esquema para a segunda e ver o resultado: </p><br><div class="spoiler">  <b class="spoiler_title">Resultado de serializa√ß√£o</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a26a3a29-9462-4c92-8d24-6a93dd5c819a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f4f5521-a2ee-4576-8aec-f61a08ed38dc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, ... }</code> </pre> </div></div><br><p>  N√£o parece muito claro √† primeira vista, porque  o segundo v√©rtice √© definido primeiro dentro do primeiro no objeto Link, mas √© importante que essa abordagem funcione.  Al√©m disso, criei a segunda vers√£o do serializador, que ignora a √°rvore n√£o em profundidade, mas em largura, o que evita essas "escadas". </p><br><h3 id="sozdanie-serializatora">  Criar serializador </h3><br><p>  Esta se√ß√£o √© direcionada para aqueles que est√£o interessados ‚Äã‚Äãem implementar as id√©ias descritas acima. </p><br><h4 id="zagotovka-serializatora">  Serializador em branco </h4><br><p>  Como qualquer outro, nosso serializador ter√° dois m√©todos principais - serializar e desserializar.  Al√©m disso, precisaremos de um m√©todo que informe ao serializador sobre as classes que ele deve serializar (registrar) e classes que n√£o devem (ignorar).  O √∫ltimo √© necess√°rio para n√£o serializar elementos DOM, objetos JQuery ou quaisquer outros tipos de dados que n√£o possam ser serializados ou que n√£o precisam ser serializados.  Por exemplo, no meu editor, guardo um elemento visual correspondente a um v√©rtice ou link.  Ele √© criado durante a inicializa√ß√£o e, √© claro, n√£o deve cair no banco de dados. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo do shell do serializador</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._nameToCtor = []; <span class="hljs-comment"><span class="hljs-comment">//    this._ctorToName = []; //    this._ignore = [Element]; //    } /** *   * @param {string} alias  * @param {Function} ctor  */ register(alias, ctor) { if (typeof ctor === 'undefined' &amp;&amp; typeof alias === 'function') { //    -  ctor = alias; alias = ctor.name; } this._nameToCtor[alias] = ctor; this._ctorToName[ctor] = alias; } /** *     * @param {Function} ctor  */ ignore(ctor) { if (this._ignore.indexOf(ctor) &lt; 0) { this._ignore.push(ctor); } } /** *   * @param {any} val  * @param {Function} [replacer]       * @param {string} [space]   * @returns {string}  */ serialize(val, replacer, space) { return JSON.stringify(new SerializationContext(this).serialize(val), replacer, space); } /** *     json * @param {any} val    json * @returns {any}  */ deserialize(val) { //     if (isString(val)) val = JSON.parse(val); return new DeserializationContext(this).deserialize(val); } }</span></span></code> </pre> </div></div><br><p>  Explica√ß√µes </p><br><p>  Para registrar uma classe, voc√™ deve passar seu construtor para o m√©todo register de uma das duas maneiras: </p><br><ol><li>  registrar (MyClass) </li><li>  register ('MyNamespace.MyClass', MyClass) </li></ol><br><p>  No primeiro caso, o nome da classe ser√° extra√≠do do nome da fun√ß√£o do construtor (n√£o suportado no IE); no segundo, voc√™ mesmo especificar√° o nome.  O segundo m√©todo √© prefer√≠vel, porque  permite que voc√™ use espa√ßos para nome, e o primeiro, por design, foi projetado para registrar tipos Javascript internos com l√≥gica de serializa√ß√£o redefinida. </p><br><p>  Para o nosso exemplo, a inicializa√ß√£o do serializador √© a seguinte: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Schema <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schema'</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//   let serializer = new Serializer(); //   Object.keys(Schema).forEach(key =&gt; serializer.register(`Schema.${key}`, Schema[key]));</span></span></code> </pre> <br><p>  O objeto Schema cont√©m descri√ß√µes de todas as classes de v√©rtice, portanto o c√≥digo de registro de classe se encaixa em uma linha. </p><br><h4 id="kontekst-serializacii-i-deserializacii">  O contexto de serializa√ß√£o e desserializa√ß√£o </h4><br><p>  Voc√™ deve ter notado as classes enigm√°ticas SerializationContext e DeserializationContext.  S√£o eles que fazem todo o trabalho e s√£o necess√°rios principalmente para separar os dados de diferentes processos de serializa√ß√£o / desserializa√ß√£o, porque  para cada chamada, eles precisam armazenar informa√ß√µes intermedi√°rias - um cache de objetos serializados e um n√∫mero de s√©rie para o link. </p><br><h4 id="serializationcontext">  SerializationContext </h4><br><p>  Analisarei em detalhes apenas o serializador recursivo, porque  sua contraparte "plana" √© um pouco mais complicada e difere apenas em sua abordagem ao processamento de uma √°rvore de objetos. </p><br><p>  Vamos come√ßar com o construtor: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  * @param {Serializer} ser  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(ser) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__.__proto__ = ser; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = []; <span class="hljs-comment"><span class="hljs-comment">//    this.index = 0; //     }</span></span></code> </pre> <br><p>  Vou <code>this.__proto__.__proto__ = ser;</code> explicar a linha misteriosa como <code>this.__proto__.__proto__ = ser;</code> <br>  Na entrada do construtor, aceitamos o objeto do serializador em si, e essa linha herda nossa classe.  Isso permite o acesso aos dados do serializador por meio <code>this</code> . <br>  Por exemplo, <code>this._ignore</code> refere-se a uma lista de classes ignoradas do pr√≥prio serializador (a "lista negra"), o que √© muito √∫til.  Caso contr√°rio, ter√≠amos que escrever algo como <code>this._serializer._ignore</code> . </p><br><p>  Principal m√©todo de serializa√ß√£o: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {any} val  * @returns {string}  */</span></span> serialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(val)) { <span class="hljs-comment"><span class="hljs-comment">//  return this.serializeArray(val); } else if (isObject(val)) { //  if (this._ignore.some(e =&gt; val instanceof e)) { //   return undefined; } else { return this.serializeObject(val); } } else { //   return val; } }</span></span></code> </pre> <br><p>  Note-se que existem tr√™s tipos b√°sicos de dados que processamos: matrizes, objetos e valores simples.  Se o construtor de um objeto estiver na "lista negra", esse objeto n√£o ser√° serializado. </p><br><p>  Serializa√ß√£o de matriz: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Array} val  * @returns {Array}  */</span></span> serializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serialize(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> e !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) res.push(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>  Voc√™ pode escrever mais curto via mapa, mas isso n√£o √© cr√≠tico.  Apenas uma coisa √© importante - verificar o valor para indefinido.  Se houver uma classe n√£o serializ√°vel na matriz, sem essa verifica√ß√£o, ela cair√° na matriz como indefinida, o que n√£o √© muito bom.  Tamb√©m na minha implementa√ß√£o, matrizes s√£o serializadas sem chaves.  Teoricamente, voc√™ pode refinar o algoritmo para serializar matrizes associativas, mas para esses fins, prefiro usar objetos.  Al√©m disso, o JSON.stringify tamb√©m n√£o gosta de matrizes associativas. </p><br><p>  Serializa√ß√£o de objetos: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObject(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctorToName[val.constructor]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name) { <span class="hljs-comment"><span class="hljs-comment">//     if (!val.__uuid) val.__uuid = ++uuid; let cached = this.cache[val.__uuid]; if (cached) { //     if (!cached.index) { //     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; } //     return { [`@${name}`]: cached.index }; } else { let res; let cached = { ref: { [`@${name}`]: {} } }; this.cache[val.__uuid] = cached; if (typeof val.serialize === 'function') { //     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res; return cached.ref; } } else { //   return this.serializeObjectInner(val); } }</span></span></code> </pre> </div></div><br><p>  Obviamente, esta √© a parte mais dif√≠cil do serializador, seu cora√ß√£o.  Vamos desmontar. </p><br><p>  Para come√ßar, verificamos se o construtor da classe est√° registrado no serializador.  Caso contr√°rio, esse √© um objeto simples para o qual o m√©todo utilit√°rio <code>serializeObjectInner</code> √© chamado. </p><br><p>  Caso contr√°rio, verificamos se o objeto recebe um identificador √∫nico <strong>__uuid</strong> .  Essa √© uma vari√°vel de contador simples que √© comum a todos os serializadores e √© usada para manter a refer√™ncia √† inst√¢ncia da classe no cache.  Voc√™ poderia ficar sem ele e armazenar a inst√¢ncia em si sem uma chave no cache, mas para verificar se o objeto est√° armazenado no cache, voc√™ precisaria passar por todo o cache e aqui √© suficiente verificar a chave.  Eu acho que isso √© mais r√°pido em termos de implementa√ß√£o interna de objetos nos navegadores.  Al√©m disso, intencionalmente n√£o serializo campos come√ßando com dois sublinhados, para que o campo <strong>__uuid</strong> n√£o caia no json resultante, como outros campos de classe privada.  Se isso for inaceit√°vel para sua tarefa, voc√™ poder√° alterar essa l√≥gica. </p><br><p>  Em seguida, pelo valor de <strong>__uuid,</strong> procuramos um objeto que descreva a inst√¢ncia da classe no cache (em <strong>cache</strong> ). </p><br><p>  Se esse objeto existir, o valor j√° foi serializado anteriormente.  Nesse caso, atribu√≠mos um n√∫mero de s√©rie ao objeto, se isso n√£o tiver sido feito antes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cached.index) { <span class="hljs-comment"><span class="hljs-comment">//     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; }</span></span></code> </pre> <br><p>  O c√≥digo parece confuso e pode ser simplificado atribuindo um n√∫mero a todas as classes que serializamos.  Mas para depurar e perceber o resultado, √© melhor quando o n√∫mero √© atribu√≠do apenas √†quelas classes √†s quais existem links no futuro. </p><br><p>  Quando o n√∫mero √© atribu√≠do, retornamos o link de acordo com o algoritmo: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     return { [`@${name}`]: cached.index };</span></span></code> </pre> <br><p>  Se o objeto for serializado pela primeira vez, criamos uma inst√¢ncia de seu cache: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = { <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: { [<span class="hljs-string"><span class="hljs-string">`@</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>]: {} } }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[val.__uuid] = cached;</code> </pre> <br><p>  E depois serialize-o: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> val.serialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res;</span></span></code> </pre> <br><p>  H√° uma verifica√ß√£o para a implementa√ß√£o da interface de serializa√ß√£o pela classe (que ser√° discutida posteriormente), bem como a constru√ß√£o de <code>Object.keys(cached.ref)[0]</code> .  O fato √© que cached.ref armazena um link para o objeto wrapper <code>{ "@&lt;type&gt;[|&lt;index&gt;]": &lt;&gt; }</code> , mas o nome do campo do objeto √© desconhecido para n√≥s, porque  ainda n√£o sabemos se o nome conter√° o n√∫mero do objeto (√≠ndice).  Essa constru√ß√£o simplesmente extrai o primeiro e √∫nico campo do objeto. </p><br><p>  Finalmente, o m√©todo utilit√°rio de serializar objetos internos: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObjectInner(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(val)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'__'</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//  ,      res[key] = this.serialize(val[key]); } } return res; }</span></span></code> </pre> <br><p>  Criamos um novo objeto e copiamos os campos do antigo para ele. </p><br><h4 id="deserializationcontext">  DeserializationContext </h4><br><p>  O processo de desserializa√ß√£o funciona na ordem inversa e n√£o precisa de coment√°rios especiais. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs powershell">/** *   */ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeserializationContext</span></span></span></span> { /** *  * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Serializer} ser  */ constructor(ser) { this.__proto__.__proto__ = ser; this.cache = []; //    } /** *   json * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {any} val  json * @returns {any}  */ deserialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeArray(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeObject(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Object} val  * @returns {Object}  */ deserializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val.map(item =&gt; this.deserialize(item)); } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Array} val  * @returns {Array}  */ deserializeObject(val) { let res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(val)) { let <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)) { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInteger(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { //  res = this.cache[<span class="hljs-type"><span class="hljs-type">data</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.error(`     <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>}`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   let [<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">id</span></span>] = key.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>).split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); let ctor = this._nameToCtor[<span class="hljs-type"><span class="hljs-type">name</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctor) { //     res = new ctor(); //   ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id) this.cache[<span class="hljs-type"><span class="hljs-type">id</span></span>] = res; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof res.deserialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { //     res.deserialize(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(data[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    console.error(`  <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{name}"</span></span>  .`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(val[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } }</code> </pre> </div></div><br><h3 id="dopolnitelnye-vozmozhnosti">  Recursos adicionais </h3><br><h4 id="interfeys-serializacii">  Interface de serializa√ß√£o </h4><br><p>  N√£o h√° suporte para interface em Javascript, mas podemos concordar que, se a classe implementar os m√©todos serialize e desserialize, esses m√©todos ser√£o usados ‚Äã‚Äãpara serializa√ß√£o / desserializa√ß√£o, respectivamente. </p><br><p>  Al√©m disso, o Javascript permite implementar esses m√©todos para tipos internos, por exemplo, para Data: </p><br><div class="spoiler">  <b class="spoiler_title">Serializar data para o formato ISO</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toISOString(); }; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.deserialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(val); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setDate(date.getDate()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setTime(date.getTime()); };</code> </pre> </div></div><br><p>  O principal √© lembrar de registrar o tipo de data: <code>serializer.register(Date);</code>  . </p><br><p>  Resultado: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"@Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-06-02T20:41:06.861Z"</span></span> }</code> </pre> <br><p>  A √∫nica limita√ß√£o: o resultado da serializa√ß√£o n√£o deve ser um n√∫mero inteiro, porque  neste caso, ser√° interpretado como uma refer√™ncia ao objeto. </p><br><p>  Da mesma forma, voc√™ pode serializar classes simples em strings.  Um exemplo de serializa√ß√£o da classe Color, que descreve a cor, para a linha <code>#rrggbb</code> est√° no <a href="">github</a> . </p><br><h4 id="ploskiy-serializator">  Serializador plano </h4><br><p>  Especialmente para voc√™s, queridos leitores, escrevi a <a href="">segunda vers√£o do serializador</a> , que atravessa a √°rvore de objetos n√£o de forma recursiva em profundidade, mas iterativamente em largura usando uma fila. </p><br><p>  Para compara√ß√£o, darei um exemplo de serializa√ß√£o dos dois primeiros v√©rtices do nosso esquema nos dois casos. </p><br><div class="spoiler">  <b class="spoiler_title">Serializador recursivo (serializa√ß√£o em profundidade)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5ec74f26-9515-4789-b852-12feeb258949"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"447f6299-4bd4-48e4-b271-016a0d47fc0e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Serializador plano (serializa√ß√£o ampla)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1412603f-24c2-4513-836e-f2b0c0392483"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a93e452e-4276-4d6a-86a1-0681226d79f0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } ]</code> </pre> </div></div><br><p>  Pessoalmente, eu gosto da segunda op√ß√£o ainda mais do que a primeira, mas deve-se lembrar que, escolhendo uma das op√ß√µes, voc√™ n√£o pode usar a outra.  √â tudo sobre os links.  Observe que no serializador plano, um link para o segundo v√©rtice √© anterior √† sua descri√ß√£o. </p><br><h3 id="plyusy-i-minusy-serializatora">  Pr√≥s e contras do serializador </h3><br><p>  Pr√≥s: </p><br><ul><li>  O c√≥digo do serializador √© bastante simples e compacto (cerca de 300 linhas, metade das quais s√£o coment√°rios). </li><li>  O serializador √© f√°cil de usar e n√£o requer bibliotecas de terceiros. </li><li>  H√° suporte interno para a interface de serializa√ß√£o para serializa√ß√£o arbitr√°ria de classes. </li><li>  O resultado √© agradavelmente agrad√°vel aos olhos (IMHO). </li><li>  Desenvolver um serializador / desserializador semelhante em outros idiomas n√£o √© um problema.  Isso pode ser necess√°rio se o resultado da serializa√ß√£o for processado na parte traseira. </li></ul><br><p>  Contras: </p><br><ul><li>  O serializador requer o registro de classes que ele pode serializar. </li><li>  Existem pequenas restri√ß√µes nos nomes de campo dos objetos. </li><li>  O serializador est√° escrito noob em Javascript, portanto pode conter bugs e erros. </li><li>  O desempenho em grandes quantidades de dados pode sofrer. </li></ul><br><p>  Tamb√©m um sinal de menos √© que o c√≥digo est√° escrito no ES6.  Obviamente, √© poss√≠vel converter para vers√µes anteriores do Javascript, mas n√£o verifiquei a compatibilidade do c√≥digo resultante com diferentes navegadores. </p><br><h3 id="drugie-moi-publikacii">  Minhas outras publica√ß√µes </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Localiza√ß√£o de projetos no .NET com um int√©rprete de fun√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Preenchendo modelos de texto com dados baseados em modelo.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o .NET usando fun√ß√µes din√¢micas de bytecode (IL)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413113/">https://habr.com/ru/post/pt413113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413103/index.html">Lan√ßamento do 3CX v15.5 Update 5 Beta e REST com AmoCRM</a></li>
<li><a href="../pt413105/index.html">Notas do provedor de IoT. Ativa√ß√£o e seguran√ßa no LoraWAN</a></li>
<li><a href="../pt413107/index.html">Tradu√ß√£o do wiki do projeto Svelto.ECS. Estrutura do ECS para Unity3D</a></li>
<li><a href="../pt413109/index.html">Como criar uma plataforma de integra√ß√£o de produtos SaaS: experi√™ncia de checkout na nuvem de p√¥steres</a></li>
<li><a href="../pt413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../pt413117/index.html">Como programar com seguran√ßa no bash</a></li>
<li><a href="../pt413119/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 317 (28 de maio a 3 de junho de 2018)</a></li>
<li><a href="../pt413121/index.html">Tour fotogr√°fico de Moscou coworking #tceh</a></li>
<li><a href="../pt413123/index.html">JOIN nos bancos de dados NoSQL</a></li>
<li><a href="../pt413125/index.html">A terapia g√™nica oferece aos pacientes pequenos com atrofia muscular a chance de sobreviver</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>