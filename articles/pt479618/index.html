<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶â üçñ üèÇüèΩ Lan√ßado o Postgres Pro Standard 12.1 üë©üèΩ‚Äç‚öïÔ∏è üò• üë•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O DBMS do Postgres Pro Standard foi projetado para entregar nossos produtos aos usu√°rios mais rapidamente do que podemos atrav√©s do PostgreSQL. Esses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lan√ßado o Postgres Pro Standard 12.1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/479618/">  O DBMS do Postgres Pro Standard foi projetado para entregar nossos produtos aos usu√°rios mais rapidamente do que podemos atrav√©s do PostgreSQL.  Esses recursos que ainda n√£o est√£o inclu√≠dos no PostgreSQL, mas est√£o em um caminho s√≥lido, incluem-se no Postgres Pro Standard.  Al√©m disso, o Postgres Pro Standard inclui algumas extens√µes exigidas por nossos clientes, mas n√£o est√£o dispon√≠veis na distribui√ß√£o padr√£o do PostgreSQL. <br><br>  √Äs vezes, h√° exce√ß√µes quando no Postgres Pro Standard, a pedido dos usu√°rios e para sua satisfa√ß√£o, s√£o inclu√≠dos recursos menos triviais, que em um bom local apenas no Postgres Pro Enterprise.  Em particular, √© o PTRACK, sobre isso abaixo. <br><br>  Nem todos, mas uma parte justa das extens√µes e utilit√°rios adicionais inclu√≠dos no Standard, foram desenvolvidos pelo Postgres Professional.  Todos os patches do Postgres Pro foram inventados e implementados por nossos pr√≥prios esfor√ßos.  Vamos come√ßar com as melhorias que exigiram interven√ß√£o no mecanismo de banco de dados. <br><a name="habracut"></a><br>  O Postgres Pro Standard difere do PostgreSQL em dois n√≠veis: o conjunto de extens√µes e utilit√°rios que est√£o na montagem e o pr√≥prio kernel.  Alguns patches √∫teis foram aplicados ao kernel que otimizam o desempenho (por exemplo, um detector de trava sem freio) e patches que aumentam a efici√™ncia de utilit√°rios e extens√µes (por exemplo, para fazer o pg_probackup funcionar com for√ßa total, o patch do PTRACK 2.0 √© aplicado).  As diferen√ßas entre a vers√£o principal do Standard e o PostgreSQL s√£o minimizadas para a maior compatibilidade poss√≠vel.  Por exemplo, a extens√£o pg_pathman est√° inclu√≠da no Standard, mas pode ser baixada no github, criada e instalada no PostgreSQL, e n√£o haver√° problemas de compatibilidade. <br>  Vamos come√ßar com as mudan√ßas no kernel. <br><br><h3>  Verificando vers√µes da UTI </h3><br>  No PostgreSQL, por padr√£o, eles s√£o usados ‚Äã‚Äãpara comparar cadeias, comparando-as usando a biblioteca padr√£o C. Mas tamb√©m h√° a possibilidade de usar a biblioteca <a href="http://site.icu-project.org/">ICU</a> desenvolvida pela IBM para o mesmo objetivo.  Essa biblioteca √© valiosa para n√≥s principalmente porque fornece classifica√ß√£o independente de plataforma.  √â por isso que, por exemplo, √© usado em 1C, e as montagens PostgreSQL "for one-es" est√£o trabalhando com essa biblioteca h√° muito tempo. <br><br>  Al√©m disso, as compara√ß√µes de cadeias de caracteres atrav√©s da UTI s√£o √†s vezes mais r√°pidas que atrav√©s da libc, e o n√∫mero de caracteres conhecidos por ela √© maior.  Em geral, uma biblioteca √∫til.  O Postgres Pro Standard trabalha com ele desde a primeira vers√£o (9.5).  No PostgreSQL, o trabalho com a UTI √© poss√≠vel desde a vers√£o 10. <br><br>  A biblioteca √© √∫til, mas voc√™ precisa ter em mente algumas situa√ß√µes de emerg√™ncia.  Suponha que um usu√°rio do DBMS tenha decidido atualizar o sistema operacional.  Juntamente com o sistema operacional, a biblioteca da ICU tamb√©m pode ser atualizada e a ordem das palavras na classifica√ß√£o ser√° alterada.  Depois disso, imediatamente todos os √≠ndices se tornar√£o inutiliz√°veis: a pesquisa de √≠ndices fornecer√° resultados incorretos.  Nesses casos, a base informou que a vers√£o da UTI havia mudado e parado. <br><br>  Mas esta √© uma decis√£o dolorosamente dif√≠cil.  Ap√≥s discuss√µes e uma pesquisa com os clientes, foi decidido suavizar o comportamento.  Agora apenas as vers√µes de COLLATION (regras de classifica√ß√£o) s√£o verificadas.  Se as vers√µes do COLLATION usadas no banco de dados foram alteradas, o banco de dados emitir√° um aviso quando o DBMS for iniciado, mas n√£o ser√° interrompido.  Ele tamb√©m lembra o usu√°rio no in√≠cio de cada sess√£o. <br><br><h3>  Otimiza√ß√£o de bloqueios, jun√ß√µes e GROUP BY </h3><br>  O mecanismo de detec√ß√£o de deadlock pode prejudicar o desempenho.  O padr√£o n√£o pode mais: o patch do kernel permite que ele funcione sem frear.  Ap√≥s grandes melhorias no mecanismo de verifica√ß√£o, esses problemas aparecem apenas em um grande n√∫mero de n√∫cleos e conex√µes. <br><br>  Melhor estimativa do n√∫mero de resultados de jun√ß√µes na presen√ßa de √≠ndices adequados. <br><br>  Agora voc√™ pode usar √≠ndices adequados para agrupar e classificar campos.  Esse recurso foi inclu√≠do pela primeira vez no Padr√£o 11.1.1 e no Enterprise 11.2.1.  Nosso padr√£o 12 tamb√©m possui um. <br><br>  Fedor Sigaev, CTO do Postgres Professional, ofereceu esses patches √∫teis √† comunidade, eles est√£o sendo considerados e, esperamos, ser√£o inclu√≠dos na vers√£o PG 13. <br><br>  Ilustramos a otimiza√ß√£o da opera√ß√£o GROUP BY com exemplos: eles s√£o claros e facilmente reproduz√≠veis. <br><br>  O ponto desse patch √© que o Postgres n√£o otimizou a ordem dos campos listados em GROUP BY.  E o tempo de execu√ß√£o depende da sequ√™ncia do agrupamento (com o mesmo resultado da consulta).  H√° detalhes na <a href="https://postgrespro.ru/list/thread-id/2388982">discuss√£o</a> na lista de discuss√£o dos <a href="https://postgrespro.ru/list/pgsql-hackers">hackers</a> . <br><br>  Se o valor na primeira coluna a ser processada for exclusivo, nada mais precisar√° ser comparado.  Se voc√™ come√ßar de outra coluna, precisar√° comparar. <br><br><br>  Chegando ao teste: <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> id, i/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> p, format(<span class="hljs-string"><span class="hljs-string">'%60s'</span></span>, i%<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>) i;</code> </pre> <br><br>  No campo de texto v, s√£o gerados 60 espa√ßos, seguidos pelos n√∫meros 0 ou 1. As entradas s√£o assim: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; id | p | v <span class="hljs-comment"><span class="hljs-comment">---------+--------+-------------------------------------------------------------- 1000000 | 500000 | 0 999999 | 499999 | 1 999998 | 499999 | 0 (3 rows)</span></span></code> </pre> <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">ANALYSE</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_hashagg=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> max_parallel_workers_per_gather = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><br>  Agrupe os resultados: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> p, v;</code> </pre> <br><br>  Plano do PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=843.999..1194.985 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=843.990..946.769 rows=1000000 loops=1) Sort Key: p, v Sort Method: external sort Disk: 73320kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.158..151.645 rows=1000000 loops=1) Planning time: 0.317 ms Execution time: 1250.086 ms (8 rows)</span></span></code> </pre> <br><br>  Agora na ordem inversa: ve somente ent√£o p: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------ GroupAggregate (cost=204036.84..218981.05 rows=494421 width=73) (actual time=2552.477..3353.890 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=204036.84..206536.84 rows=1000000 width=65) (actual time=2552.469..3111.516 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.082..126.578 rows=1000000 loops=1) Planning time: 0.060 ms Execution time: 3411.048 ms (8 rows)</span></span></code> </pre> <br><br>  Acontece que o inverso √© visivelmente mais lento.  Isso ocorre porque o primeiro campo <code>v</code> analisado com uma pequena dispers√£o de valores.  Voc√™ precisa fazer muitas verifica√ß√µes nos campos restantes (aqui - o campo p). <br><br>  Vamos ver como a mesma consulta funcionar√° com um patch que seleciona a ordem ideal para o processamento de colunas: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------- GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=415.541..703.647 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=415.533..507.785 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 73488kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.059..139.587 rows=1000000 loops=1) Planning Time: 0.123 ms Execution Time: 742.118 ms (8 rows)</span></span></code> </pre> <br><br>  E na ordem inversa: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=237400.11..252417.09 rows=501698 width=73) (actual time=414.322..714.593 rows=1000000 loops=1) Group Key: p, v -&gt; Sort (cost=237400.11..239900.11 rows=1000000 width=65) (actual time=414.312..517.707 rows=1000000 loops=1) Sort Key: p, v Sort Method: external merge Disk: 76384kB -&gt; Seq Scan on btg (cost=0.00..22346.00 rows=1000000 width=65) (actual time=0.071..129.835 rows=1000000 loops=1) Planning Time: 0.140 ms Execution Time: 753.031 ms (8 rows)</span></span></code> </pre> <br><br>  O plano diz que ali e ali a ordem de processamento √© a mesma: Chave de classifica√ß√£o: p, v.  Consequentemente, o tempo √© aproximadamente o mesmo.  Agora compare o que acontece quando o √≠ndice √© usado. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> btg(p, v); <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_bitmapscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> btg; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> btg <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> v, p ;</code> </pre> <br><br>  No PostgreSQL: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------- GroupAggregate (cost=0.55..74660.04 rows=494408 width=73) (actual time=0.013..391.317 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.009..120.298 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.078 ms Execution time: 442.923 ms (6 rows)</span></span></code> </pre> <br><br>  E na ordem inversa: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------ GroupAggregate (cost=243904.22..258848.04 rows=494408 width=73) (actual time=2558.485..3352.240 rows=1000000 loops=1) Group Key: v, p -&gt; Sort (cost=243904.22..246404.16 rows=999974 width=65) (actual time=2558.478..3110.242 rows=1000000 loops=1) Sort Key: v, p Sort Method: external merge Disk: 76264kB -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..62216.16 rows=999974 width=65) (actual time=0.011..133.563 rows=1000000 loops=1) Heap Fetches: 0 Planning time: 0.093 ms Execution time: 3409.335 ms (9 rows)</span></span></code> </pre> <br><br>  Agora no padr√£o: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.150..412.174 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.134..149.669 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.175 ms Execution Time: 448.635 ms (6 rows)</span></span></code> </pre> <br><br>  E na ordem inversa: <br><br><pre> <code class="pgsql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------- GroupAggregate (cost=0.55..74196.82 rows=501685 width=73) (actual time=0.014..307.258 rows=1000000 loops=1) Group Key: p, v -&gt; Index Only Scan using btg_p_v_idx on btg (cost=0.55..61680.16 rows=999974 width=65) (actual time=0.008..89.204 rows=1000000 loops=1) Heap Fetches: 0 Planning Time: 0.054 ms Execution Time: 337.766 ms (6 rows)</span></span></code> </pre> <br><br>  O tempo √© o mesmo novamente, o que √© natural: de fato, as a√ß√µes s√£o as mesmas. <br><br><h3>  Substituindo um byte nulo na inicializa√ß√£o </h3><br>  O Postgres Pro n√£o aceita zero bytes (0x00) nos dados; portanto, com COPY FROM eles devem ser substitu√≠dos, <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-compatible">caso contr√°rio, haver√° um erro</a> .  Esse √© o problema real que o cliente encontrou ao importar dados de um arquivo CSV.  Sua solu√ß√£o √© substituir bytes nulos pelo caractere ASCII fornecido.  Ele deve ser diferente dos caracteres QUOTE e DELIMITER usados ‚Äã‚Äãao executar COPY FROM;  caso contr√°rio, o resultado pode ser inesperado.  Por padr√£o, o valor da vari√°vel nul_byte_replacement_on_import (string) '\ 0', ou seja, nenhuma substitui√ß√£o √© executada. <br><br><h3>  WaitLSN </h3><br>  LSN √© um <a href="https://postgrespro.ru/docs/postgrespro/12/sql-waitlsn">n√∫mero seq√ºencial no log</a> , ou seja, um ponteiro para uma posi√ß√£o no WAL (Log Sequence Number).  O comando WAITLSN est√° aguardando para reproduzir o LSN especificado.  Se o aplicativo funcionar com o mestre e a r√©plica, ser√° necess√°rio garantir que eles sejam s√≠ncronos de tempos em tempos.  WAITLSN √© um mecanismo de interprocesso no PostgrePro que controla a sincroniza√ß√£o durante a <a href="https://postgrespro.ru/docs/postgrespro/12/runtime-config-replication">replica√ß√£o s√≠ncrona</a> .  Por padr√£o, o tempo de espera √© ilimitado.  Voc√™ pode interromper a espera pressionando Ctrl + C ou parando o servidor postgres.  Voc√™ tamb√©m pode definir o tempo limite adicionando a dica TIMEOUT ou verificar o status do LSN de destino sem esperar usando a dica NOWAIT. <br>  Suponha que um aplicativo execute uma determinada a√ß√£o, receba o n√∫mero LSN do DBMS no mestre e agora deseje garantir que as a√ß√µes na r√©plica sejam sincronizadas com o mestre, ou seja,  o aplicativo pode ter certeza de que o que foi gravado no assistente j√° chegou √† r√©plica e est√° pronto para ser lido.  Por padr√£o, isso geralmente n√£o √© garantido.  WAITLSN permite controlar essa intera√ß√£o e selecionar um modo de suspens√£o de INFINITELY por padr√£o, para TIMEOUT e NOWAIT. <br><br><h3>  Relendo vari√°veis ‚Äã‚Äãdo antigo recovery.conf </h3><br>  Em um sinal SIGHUP, o PostgreSQL rel√™ o postgresql.conf, mas n√£o o recovery.conf.  Um patch de kernel relativamente novo introduzido no Standard e Enterprise 10.4.1.  for√ßado a reler e recovery.conf.  Mas no Postgres 12 n√£o h√° nenhum arquivo recovery.conf: todas as vari√°veis ‚Äã‚Äãs√£o transferidas para o postgresql.conf.  No entanto, embora o arquivo inteiro seja relido, as vari√°veis ‚Äã‚Äãde recovery.conf n√£o foram redefinidas pelo SIGHUP, mas exigiram a reinicializa√ß√£o do Postgres.  No padr√£o, isso n√£o √© necess√°rio: tudo √© lido e redefinido. <br><br><h3>  Suporte para PTRACK </h3><br>  O PTRACK 2.0 √© um mecanismo PTRACK reprojetado para as vers√µes Standard e Enterprise 11 e anteriores.  No n√≠vel do DBMS, funcionou gra√ßas ao patch do kernel e agora a extens√£o ptrack foi adicionada ao <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">patch</a> .  O PTRACK 2.0 rastreia altera√ß√µes na p√°gina de dados e fornece uma interface para recuperar essas informa√ß√µes.  Ele pode ser usado tanto para fins de diagn√≥stico, por exemplo, para ter uma id√©ia de qu√£o fortemente a inst√¢ncia "sofreu muta√ß√£o" em rela√ß√£o a um determinado momento, definido como um n√∫mero sequencial no log (LSN) e para criar backups incrementais. <br><br>  A parte mais dif√≠cil e "cara" de um procedimento de backup incremental, como regra, √© isolar um subconjunto de p√°ginas alteradas de todo o conjunto de p√°ginas em um cluster.  Como o servidor pode executar essa tarefa e fornecer rapidamente informa√ß√µes sobre as p√°ginas alteradas, o tempo de backups incrementais usando o PTRACK √© reduzido significativamente. <br><br>  O PTRACK 2.0 usa uma tabela de hash de um tamanho especificado na mem√≥ria compartilhada, sincronizada periodicamente com o arquivo ptrack.map. <br><br>  Devido a uma altera√ß√£o fundamental do mecanismo interno de opera√ß√£o e uma interface de usu√°rio incompat√≠vel com vers√µes anteriores, a extens√£o ptrack est√° dispon√≠vel apenas na 12¬™ vers√£o do PostgresPro Standard e Enterprise, e estar√° dispon√≠vel como patch e extens√£o no PostgreSQL 12. <br><br><h3>  Editando comandos no psql para Windows </h3><br>  O suporte avan√ßado para editar comandos de entrada no psql para Windows √© implementado usando o WinEditLine.  Agora voc√™ pode exibir os caracteres de diferentes alfabetos simultaneamente (em particular, o cir√≠lico √© normalmente exibido no Windows n√£o russo). <br><br><h3>  Estrutura do pacote unificado </h3><br><br>  A estrutura dos pacotes de pacotes bin√°rios para todas as distribui√ß√µes Linux √© unificada, a fim de simplificar a migra√ß√£o entre elas e permitir a instala√ß√£o de v√°rios produtos diferentes baseados no PostgreSQL juntos, sem conflitos.  Isso pode ser encontrado no <a href="https://postgrespro.ru/docs/postgrespro/12/installation-bin">cap√≠tulo 16 da</a> documenta√ß√£o. <br><br>  Agora sobre as extens√µes: <br><br><h3>  dump_stat </h3><br>  Apareceu t√£o cedo quanto 9,5.  Ao transferir ou restaurar dados, as estat√≠sticas acumuladas geralmente n√£o s√£o transferidas.  Se voc√™ mont√°-lo novamente com o comando ANALYZE, ele ser√° executado para todo o cluster e n√£o para o banco de dados especificado.  Isso pode exigir muito tempo extra para bancos de dados grandes. <br><br>  A extens√£o dump_stat <a href="https://postgrespro.ru/docs/postgrespro/12/dump-stat">fornece fun√ß√µes</a> que permitem descarregar e restaurar o conte√∫do da tabela pg_statistic.  Ao executar o upload / recupera√ß√£o de dados, voc√™ pode usar dump_stat para transferir estat√≠sticas existentes para um novo servidor, sem precisar executar o comando ANALYZE para todo o cluster. <br><br>  A fun√ß√£o dump_statistic descarrega o conte√∫do do cat√°logo do sistema pg_statistic.  Ele produz um INSERT para cada tupla em pg_statistic, exceto aqueles que cont√™m estat√≠sticas sobre tabelas nos esquemas information_schema e pg_catalog. <br><br><h3>  jsquery </h3><br>  Lembre-se de que <a href="https://postgrespro.ru/docs/postgrespro/12/jsquery">essa √© uma extens√£o</a> para trabalhar com JSON (B), n√£o JS.  Ele fornece um conjunto de fun√ß√µes para processar esses tipos de dados.  Essa √© uma linguagem de consulta especial para pesquisa eficiente, usando √≠ndices, em JSON (B).  No <a href="https://habr.com/ru/company/postgrespro/blog/448612/">artigo no hub,</a> voc√™ pode ver alguns exemplos de jsquery e m√©todos alternativos de trabalho com JSON (B), por exemplo, JSONPath (ambos do desenvolvimento de nossa empresa). <br><br><h3>  online_analyze </h3><br>  Esta extens√£o <a href="https://postgrespro.ru/docs/postgrespro/12/online-analyze">fornece um</a> conjunto de fun√ß√µes que atualizam imediatamente as estat√≠sticas nas tabelas especificadas ap√≥s as opera√ß√µes INSERT, UPDATE, DELETE ou SELECT INTO nelas.  O autor da extens√£o √© Fedor Sigaev. <br><br>  Para usar o m√≥dulo online_analyze, voc√™ deve carregar a biblioteca compartilhada: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">LOAD</span></span> <span class="hljs-string"><span class="hljs-string">'online_analyze'</span></span>;</code> </pre> <br><br>  As atualiza√ß√µes de estat√≠sticas podem ser personalizadas.  Por exemplo, defina uma porcentagem do tamanho da tabela ou o n√∫mero m√≠nimo (limite) de altera√ß√µes de linha, ap√≥s o qual as estat√≠sticas ser√£o coletadas imediatamente. <br><br><h3>  pg_pathman </h3><br>  A <a href="https://postgrespro.ru/docs/postgrespro/12/pg-pathman">extens√£o pg_pathman</a> no Postgres Professional foi criada antes do kernel do PostgreSQL e implementou um conjunto completo de fun√ß√µes bastante completo para a cria√ß√£o de parti√ß√µes.  Portanto, muitas opera√ß√µes com se√ß√µes podem ser feitas com um e outro mecanismo.  √â aconselh√°vel n√£o misturar as se√ß√µes criadas pelo particionamento declarativo e pg_pathman. <br><br>  No entanto, muitas opera√ß√µes do pg_pathman ainda s√£o mais r√°pidas e alguns recursos est√£o ausentes no PostgreSQL.  Por exemplo, cria√ß√£o autom√°tica (corte) de se√ß√µes.  No PostgreSQL, voc√™ precisa definir os limites de cada se√ß√£o.  Se preenchermos dados sobre os quais n√£o se sabe antecipadamente quantas se√ß√µes podem e devem ser dispersas, √© conveniente simplesmente definir o intervalo e deixar o software cortar as se√ß√µes em si - o quanto for necess√°rio.  O pg_pathman sabe como o PostgreSQL n√£o.  Mas, come√ßando na PG 11, h√° uma se√ß√£o padr√£o (padr√£o), na qual voc√™ pode despejar todos os registros que n√£o se enquadram nas se√ß√µes com limites especificados. <br><br>  Existe um acordo b√°sico com os l√≠deres da comunidade PostgreSQL de que, no futuro, os melhores, enquanto os recursos exclusivos do pg_pathman ser√£o inclu√≠dos no ramo principal.  Mas at√© esse momento, o pg_pathman pode facilitar a vida dos administradores de banco de dados e programadores de aplicativos. <br><br>  Crie uma extens√£o: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_pathman;</code> </pre> <br><br>  O pg_pathman permite que voc√™ divida tabelas grandes em se√ß√µes e fornece uma API conveniente - um conjunto de fun√ß√µes para criar se√ß√µes e trabalhar com elas.  Por exemplo, usando a fun√ß√£o <br><br><pre> <code class="pgsql hljs">create_range_partitions(relation <span class="hljs-type"><span class="hljs-type">REGCLASS</span></span>, expression <span class="hljs-type"><span class="hljs-type">TEXT</span></span>, start_value <span class="hljs-type"><span class="hljs-type">ANYELEMENT</span></span>, p_interval <span class="hljs-type"><span class="hljs-type">INTERVAL</span></span>, p_count <span class="hljs-type"><span class="hljs-type">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, partition_data <span class="hljs-type"><span class="hljs-type">BOOLEAN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>);</code> </pre> <br>  n√≥s podemos perguntar <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  ap√≥s o qual adicionamos se√ß√µes: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_archive'</span></span>, <span class="hljs-string"><span class="hljs-string">'ts0'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'log_1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> add_range_partition(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-02-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-03-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span><span class="hljs-string"><span class="hljs-string">', log_2'</span></span>);</code> </pre> <br><br>  O log de archive ser√° criado no espa√ßo de tabela ts0, o restante √© por padr√£o.  Mas voc√™ n√£o pode especificar se√ß√µes explicitamente, mas confie nesta opera√ß√£o do DBMS configurando o intervalo e criando se√ß√µes em uma etapa: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'log'</span></span>, <span class="hljs-string"><span class="hljs-string">'dt'</span></span>, <span class="hljs-string"><span class="hljs-string">'2017-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>);</code> </pre> <br><br>  Em uma tabela simples, ser√° assim: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> pg_pathmania(id <span class="hljs-type"><span class="hljs-type">serial</span></span>, val <span class="hljs-type"><span class="hljs-type">float</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(val) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> random() * <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> create_range_partitions(<span class="hljs-string"><span class="hljs-string">'pg_pathmania'</span></span>, <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); test_parti=# \d+ pg_pathmania <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span> "public.pg_pathmania" <span class="hljs-keyword"><span class="hljs-keyword">Column</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Collation</span></span> | Nullable | <span class="hljs-keyword"><span class="hljs-keyword">Default</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span> | S tats target | Description <span class="hljs-comment"><span class="hljs-comment">--------+------------------+-----------+----------+-----------------------+---------+------+------ id | integer | | not null | nextval('pg_pathmania_id_seq'::regclass) | plain | | val | double precision | | | | plain | | Child tables: pg_pathmania_1, pg_pathmania_10, pg_pathmania_11, pg_pathmania_12, pg_pathmania_13, pg_pathmania_14, pg_pathmania_15, pg_pathmania_16, pg_pathmania_17, pg_pathmania_18, pg_pathmania_19, pg_pathmania_2, pg_pathmania_20, pg_pathmania_21, pg_pathmania_3, pg_pathmania_4, pg_pathmania_5, pg_pathmania_6, pg_pathmania_7, pg_pathmania_8, pg_pathmania_9</span></span></code> </pre> <br><br>  No PostgreSQL, ter√≠amos que criar cada se√ß√£o com nossa pr√≥pria equipe.  Nesses casos, √© claro, eles escrevem um script que gera o c√≥digo DDL necess√°rio automaticamente.  Voc√™ n√£o precisa escrever scripts no pg_pathman, tudo j√° est√° l√°.  Mas isso n√£o √© o mais interessante.  Vamos inserir um registro que n√£o s√≥ n√£o identifica o c√≥digo em nenhuma das se√ß√µes existentes, mas tamb√©m n√£o se enquadra no mais pr√≥ximo: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> pg_pathmania(id, val) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">277.835794724524</span></span>);</code> </pre> <br><br>  Mais uma vez, verifique o conte√∫do da tabela com \ d + pg_pathmania: <br><br><pre> <code class="pgsql hljs">Child <span class="hljs-keyword"><span class="hljs-keyword">tables</span></span>: pg_pathmania_1, pg_pathmania_10, ... pg_pathmania_39, pg_pathmania_4, pg_pathmania_40, pg_pathmania_41,</code> </pre> <br><br>  Aqui est√° o que aconteceu: pg_pathman viu que o registro com id = 2000 n√£o se enquadra nas se√ß√µes j√° criadas, calculou quantas precisam ser criadas, sabendo o intervalo RANGE com o qual a tabela foi particionada antes e criou a se√ß√£o em que o novo registro se encaixa e, √© claro, todas as se√ß√µes entre o limite superior das se√ß√µes antigas e o limite inferior da nova se√ß√£o.  Isso √© muito conveniente e, nos casos em que os valores do campo de divis√£o dos dados atualizados s√£o pouco previstos, essa √© uma s√©ria vantagem do pg_pathman. <br><br><h3>  pg_query_state </h3><br>  Essa extens√£o que desenvolvemos nos <a href="https://postgrespro.ru/docs/postgrespro/12/pg-query-state">permite descobrir o</a> estado atual das solicita√ß√µes no processo de veicula√ß√£o.  Existe desde a vers√£o 9.5 e √© devido ao nascimento de in√∫meras solicita√ß√µes de administradores de clientes. <br><br>  O fato √© que EXPLAIN ANALYZE permite visualizar estat√≠sticas de execu√ß√£o coletadas de cada n√≥ da √°rvore do plano, mas essas estat√≠sticas s√£o coletadas somente ap√≥s a conclus√£o da consulta.  Mas na vida, infelizmente, h√° situa√ß√µes em que voc√™ precisa examinar o que a solicita√ß√£o ainda n√£o foi conclu√≠da e talvez n√£o v√° terminar.  pg_query_state permite visualizar as estat√≠sticas atuais de uma consulta em execu√ß√£o em um processo de servi√ßo externo.  Nesse caso, o formato da sa√≠da resultante √© quase id√™ntico √† sa√≠da do comando EXPLAIN ANALYZE usual. <br><br>  Utilit√°rios: <br><br><h3>  pgBouncer </h3><br>  <a href="http://www.pgbouncer.org/">Este √©</a> um <a href="https://postgrespro.ru/docs/postgrespro/12/pgbouncer">extrator de conex√£o</a> t√£o <a href="https://postgrespro.ru/docs/postgrespro/12/pgbouncer">popular</a> que seria estranho falar sobre isso aqui.  √â apenas parte do Standard e ter√° que ser instalado separadamente no PostgreSQL de baunilha. <br><br><h3>  pg_probackup </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgprobackup">O pg_probackup</a> √© um dos nossos desenvolvimentos mais populares.  Este √© um gerenciador de backup e recupera√ß√£o que est√° sendo desenvolvido e atualizado principalmente por Anastasia Lubennikova, Grigory Smolkin e pela comunidade de usu√°rios. <br><br>  Vantagens competitivas do pg_probackup: backup incremental com granularidade de bloco (8 KB), tr√™s modos de backup incremental (PAGE, DELTA, PTRACK), verifica√ß√£o de integridade de backup sob demanda, verifica√ß√£o de cluster do PostgreSQL, compacta√ß√£o de backup, recupera√ß√£o parcial, etc. <br><br>  O modo de c√≥pia incremental do PTRACK, contando com <a href="https://postgrespro.ru/docs/postgrespro/12/ptrack">a extens√£o do mesmo nome</a> como parte do mecanismo reprojetado - PTRACK 2.0 - tornou-se ainda mais r√°pido e agora √© inequivocamente o mais r√°pido e mais barato dos modos pg_probackup. <br><br><h3>  pg_repack </h3><br>  <a href="https://postgrespro.ru/docs/postgrespro/12/app-pgrepack">O pg_repack √© um</a> utilit√°rio popular, sua opera√ß√£o √© semelhante ao VACUUM FULL ou <a href="https://postgrespro.ru/docs/postgrespro/12/sql-cluster">CLUSTER</a> .  Ele n√£o apenas reempacota as tabelas, remove os vazios, mas tamb√©m sabe como restaurar a ordem f√≠sica dos √≠ndices em cluster.  Ao contr√°rio do CLUSTER e do VACUUM FULL, ele realiza essas opera√ß√µes "on the go", sem bloqueios exclusivos de tabela e geralmente trabalhando com efici√™ncia.  N√£o est√° inclu√≠do na vers√£o baunilha. <br><br><h3>  pg_variables </h3><br>  Sobre esta extens√£o em um habr, h√° um <a href="https://habr.com/ru/company/postgrespro/blog/302200/">artigo</a> interessante <a href="https://habr.com/ru/company/postgrespro/blog/302200/">de</a> nosso funcion√°rio Ivan Frolkov.  O motivo da extens√£o √© que trabalhar com resultados intermedi√°rios √†s vezes √© inconveniente e caro.  O artigo explora alternativas.  O mais comum deles s√£o tabelas tempor√°rias. <br><br>  Como um data warehouse tempor√°rio, a extens√£o pg_variables √© muito mais produtiva que as tabelas tempor√°rias (os testes pgbench est√£o no artigo) e √© mais conveniente: o conjunto de dados √© definido por um par "pacote - vari√°vel", que pode ser passado como par√¢metros, retornado de uma fun√ß√£o etc. Existem fun√ß√µes set / get para trabalhar com vari√°veis.  Portanto, por exemplo, voc√™ pode armazenar muitas vari√°veis ‚Äã‚Äã(pacote √© o nome do pacote e a express√£o ap√≥s o ponto decimal s√£o as vari√°veis ‚Äã‚Äãdeste pacote: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_set_int(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'#'</span></span>||n,n), n <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n);</code> </pre> <br><br>  As vari√°veis ‚Äã‚Äãt√™m uma propriedade interessante: n√£o um bug ou vantagem, mas um recurso: os dados armazenados pelo meio de extens√£o existem fora das transa√ß√µes - eles s√£o salvos no caso de corrigir uma transa√ß√£o e no caso de revers√£o;  Al√©m disso, mesmo ao executar um comando separado, dados parciais podem ser obtidos: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgv_insert(<span class="hljs-string"><span class="hljs-string">'package'</span></span>, <span class="hljs-string"><span class="hljs-string">'errs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>(n)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> gs(n) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>/(n<span class="hljs-number"><span class="hljs-number">-3</span></span>)&lt;&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>; ERROR: there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-type"><span class="hljs-type">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the variable "errs" <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> same key test_parti=# <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgv_select(<span class="hljs-string"><span class="hljs-string">'package'</span></span>,<span class="hljs-string"><span class="hljs-string">'errs'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> r(i <span class="hljs-type"><span class="hljs-type">int</span></span>); i <span class="hljs-comment"><span class="hljs-comment">--- 1 2 (2 rows)</span></span></code> </pre> <br><br>  Por um lado, isso n√£o √© muito conveniente - em alguns casos √© necess√°rio prever a exclus√£o de dados inseridos incorretamente, mas em outros pode ser muito √∫til - por exemplo, salvando alguns dados mesmo no caso de uma revers√£o de transa√ß√£o.  A <a href="https://github.com/postgrespro/pg_variables">documenta√ß√£o</a> possui detalhes. <br><br>  Em conclus√£o, mais algumas extens√µes: <br><br><h3>  sr_plan, plantuner </h3><br>  <b>sr_plan</b> <a href="https://postgrespro.ru/docs/postgrespro/12/sr-plan">salva e restaura</a> planos de consulta.  Inclua-o assim: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> sr_plan.write_mode = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;</code> </pre> <br><br>  Depois disso, os planos para todas as consultas subseq√ºentes ser√£o armazenados na tabela sr_plans at√© que essa vari√°vel seja configurada como false.  Os planos para todas as solicita√ß√µes, incluindo repetidas, s√£o salvos. <br><br>  <b>O plantuner</b> <a href="https://postgrespro.ru/docs/postgrespro/12/plantuner">suporta</a> dicas para o planejador conectar ou desconectar √≠ndices especificados ao executar uma consulta.  Existem apenas duas vari√°veis ‚Äã‚ÄãGUC: enable_index / desable_index: <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> plantuner.disable_index=<span class="hljs-string"><span class="hljs-string">'id_idx2'</span></span>;</code> </pre> <br><br><h3>  Extens√µes para pesquisa de texto completo: shared_ispell, pg_tsparser </h3><br>  A extens√£o shared_ispell, que permite colocar <a href="https://postgrespro.ru/docs/postgrespro/12/hunspell-dict">dicion√°rios</a> na mem√≥ria compartilhada, est√° no Standard e n√£o no PostgreSQL.  Nosso conjunto hunspell-dict possui dicion√°rios para idiomas: <br><br><ul><li>  hunspell_en_us, </li><li>  hunspell_fr, </li><li>  hunspell_nl_nl, </li><li>  hunspell_ru_ru </li></ul><br><br>  A <b>extens√£o pg_tsparser</b> √© <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">um analisador de</a> pesquisa de texto <a href="https://postgrespro.ru/docs/postgrespro/12/pg-tsparser">alternativo</a> .  Essa extens√£o altera a estrat√©gia de an√°lise de texto padr√£o para palavras que incluem sublinhados, al√©m de n√∫meros e letras separados por sublinhados.  Al√©m das partes individuais da palavra retornadas por padr√£o, pg_tsparser tamb√©m retorna a palavra inteira.  Isso √© muito importante para documenta√ß√£o t√©cnica ou artigos como este, em que o c√≥digo do programa √© encontrado e nele existem palavras como "pg_tsparser", "pg_probackup", "jsonb_build_object".  Esse analisador percebe essas palavras n√£o apenas como um conjunto de componentes, mas tamb√©m como um √∫nico token e, assim, melhora a qualidade da pesquisa. <br><br><h3>  Extens√µes para 1C </h3><br><ul><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/mchar">mchar</a></b> √© um tipo de dados opcional para compatibilidade com o Microsoft SQL Server; </li><li>  <b><a href="https://postgrespro.ru/docs/postgrespro/12/fulleq">fulleq</a></b> - fornece um operador de igualdade adicional para compatibilidade com o Microsoft SQL Server; </li><li> <b><a href="https://postgrespro.ru/docs/postgrespro/12/fasttrun">fasttrun</a></b> ‚Äî  -     ,     pg_class. </li></ul><br><br>      ,    PostgresPro Standard  PostgreSQL.   ,     , , , <a href="https://postgrespro.ru/docs/postgrespro/12/index">  </a> . <br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479618/">https://habr.com/ru/post/pt479618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479590/index.html">As 10 principais empresas de desenvolvimento de aplicativos em 2020</a></li>
<li><a href="../pt479592/index.html">Como alcan√ßar seus objetivos?</a></li>
<li><a href="../pt479598/index.html">Gato e cachorro alimentam o rob√¥</a></li>
<li><a href="../pt479600/index.html">Outro DSL para valida√ß√µes</a></li>
<li><a href="../pt479602/index.html">Qual √© o genoma completo e por que √© necess√°rio</a></li>
<li><a href="../pt479620/index.html">L√≥gica reversa</a></li>
<li><a href="../pt479622/index.html">Como o prot√≥tipo de transa√ß√µes an√¥nimas na blockchain Waves funciona</a></li>
<li><a href="../pt479624/index.html">O profissional do Postgres, Oleg Bartunov, fala a Faride Roslovets sobre o PostgreSQL e neg√≥cios na R√∫ssia</a></li>
<li><a href="../pt479626/index.html">Ressonador com um toque que os f√≠sicos n√£o conhecem</a></li>
<li><a href="../pt479630/index.html">Lute por aten√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>