<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÆÔ∏è üçü ü§ûüèæ Vom Skript zur eigenen Plattform: Wie wir die Entwicklung am Cyan Institute automatisierten üö∂ üëµüèΩ üòÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auf der RIT 2019 berichtete unser Kollege Alexander Korotkov √ºber die Entwicklungsautomatisierung im CIAN: Um Leben und Arbeiten zu vereinfachen, nutz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vom Skript zur eigenen Plattform: Wie wir die Entwicklung am Cyan Institute automatisierten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/cian/blog/486056/"><img src="https://habrastorage.org/webt/di/vp/_w/divp_woyk4ubltspau3m_ogodkg.png"><br><br>  Auf der RIT 2019 berichtete unser Kollege Alexander Korotkov √ºber die Entwicklungsautomatisierung im CIAN: Um Leben und Arbeiten zu vereinfachen, nutzen wir unsere eigene Integro-Plattform.  Es verfolgt den Lebenszyklus von Aufgaben, entfernt Routineoperationen von Entwicklern und reduziert die Anzahl der Fehler in der Produktion erheblich.  In diesem Beitrag werden wir Alexanders Bericht erg√§nzen und Ihnen erl√§utern, wie wir von einfachen Skripten zum Kombinieren von Open Source-Produkten √ºber unsere eigene Plattform √ºbergegangen sind und was ein separates Automatisierungsteam tut. <br><a name="habracut"></a><br><h2>  Level Null </h2><br>  <i><b>"Es gibt kein Nullniveau, das wei√ü ich nicht."</b></i> <i><br></i>  <i>Shifu-Meister aus dem Film ‚ÄûKung Fu Panda‚Äú</i> <br><br>  Die Automatisierung bei CIAN begann 14 Jahre nach der Gr√ºndung des Unternehmens.  Dann waren 35 Leute im Entwicklerteam.  Schwer zu glauben, oder?  Zwar gab es eine gewisse Form der Automatisierung, aber seit 2015 gibt es einen eigenen Bereich f√ºr die kontinuierliche Integration und Codebereitstellung. <br><br>  Zu dieser Zeit hatten wir einen riesigen Monolithen aus Python, C # und PHP, der auf Linux / Windows-Servern bereitgestellt wurde.  F√ºr den Einsatz dieses Monsters hatten wir eine Reihe von Skripten, die wir manuell ausf√ºhrten.  Es gab auch eine Monolith-Baugruppe, die aufgrund von Konflikten beim Zusammenf√ºhren von Zweigen, Bearbeiten von Fehlern und Neuerstellen "mit einer anderen Aufgabengruppe im Build" Schmerzen und Leiden verursachte.  Der vereinfachte Prozess sah folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/bz/tn/ll/bztnllnatyoaiauwlw0xvvaatde.jpeg"><br><br>  Dies passte nicht zu uns und wir wollten einen wiederholbaren, automatisierten und kontrollierten Erstellungs- und Bereitstellungsprozess erstellen.  Dazu brauchten wir ein CI / CD-System und w√§hlten zwischen der kostenlosen Version von Teamcity und den kostenlosen Jenkins, da wir mit ihnen gearbeitet haben und beide f√ºr eine Reihe von Funktionen geeignet waren.  Wir haben Teamcity als neueres Produkt ausgew√§hlt.  Dann haben wir keine Microservice-Architektur verwendet und nicht mit einer gro√üen Anzahl von Aufgaben und Projekten gerechnet. <br><br><h2>  Wir kommen zur Idee unseres eigenen Systems </h2><br>  Mit der Implementierung von Teamcity wurde nur ein Teil der manuellen Arbeit entfernt: Es wurden noch Pull-Requests erstellt, Aufgaben nach Status in Jira bef√∂rdert und Aufgaben zur Freigabe ausgew√§hlt.  Teamcity kam damit nicht mehr klar.  Es war notwendig, den Weg der weiteren Automatisierung zu w√§hlen.  Wir haben Optionen f√ºr die Arbeit mit Skripten in Teamcity oder den Wechsel zu Automatisierungssystemen von Drittanbietern erwogen.  Letztendlich haben wir uns jedoch f√ºr die maximale Flexibilit√§t entschieden, die nur unsere eigene L√∂sung bietet.  So erschien die erste Version des internen Automatisierungssystems mit dem Namen Integro. <br><br>  Teamcity befasst sich mit der Automatisierung von Montage- und Bereitstellungsprozessen auf der Anfangsebene. Integro hat sich auf die Automatisierung von Entwicklungsprozessen auf h√∂chster Ebene konzentriert.  Es war notwendig, die Arbeit mit Aufgaben in Jira mit der Verarbeitung des zugeh√∂rigen Quellcodes in Bitbucket zu verbinden.  Zu diesem Zeitpunkt verf√ºgte Integro √ºber eigene Workflows f√ºr die Bearbeitung von Aufgaben verschiedener Art. <br><br>  Aufgrund der zunehmenden Automatisierung der Gesch√§ftsprozesse hat die Anzahl der Projekte und Abl√§ufe in Teamcity zugenommen.  Es gab also ein neues Problem: Es fehlte eine freie Teamcity-Instanz (3 Agenten und 100 Projekte), wir f√ºgten eine weitere Instanz (3 weitere Agenten und 100 Projekte) und dann eine weitere hinzu.  Als Ergebnis haben wir ein System mit mehreren Clustern erhalten, das schwierig zu verwalten war: <br><br><img src="https://habrastorage.org/webt/hb/gv/rp/hbgvrp2ms-wfixyw-v0wycqjphy.png"><br><br>  Als die Frage nach der 4-Instanz auftauchte, wurde uns klar, dass wir nicht mehr so ‚Äã‚Äãleben k√∂nnen, da die Gesamtkosten f√ºr die Unterst√ºtzung von 4 Instanzen nicht mehr in ein Framework passen.  Es stellte sich die Frage, ob Sie eine bezahlte Teamcity kaufen oder sich f√ºr einen kostenlosen Jenkins entscheiden sollten.  Wir haben Berechnungen an Instanzen und Pl√§nen f√ºr die Automatisierung durchgef√ºhrt und beschlossen, dass wir von Jenkins leben w√ºrden.  Nach ein paar Wochen sind wir zu Jenkins gewechselt und haben die Kopfschmerzen beseitigt, die mit der Unterst√ºtzung mehrerer Teamcity-Instanzen verbunden sind.  Daher konnten wir uns darauf konzentrieren, Integro zu entwickeln und Jenkins f√ºr uns selbst fertigzustellen. <br><br>  Mit dem Wachstum der Basisautomatisierung (in Form der automatischen Erstellung von Pull-Requests, der Erfassung und Ver√∂ffentlichung von Code-Coverage und anderen √úberpr√ºfungen) bestand ein starker Wunsch, manuelle Freigaben so weit wie m√∂glich abzulehnen und diese Arbeit Robotern zu √ºberlassen.  Dar√ºber hinaus begann das Unternehmen, auf Microservices umzusteigen, die h√§ufige und voneinander getrennte Ver√∂ffentlichungen erforderten.  So kamen wir nach und nach zur automatischen Freigabe unserer Mikrodienste (vorerst geben wir den Monolithen aufgrund der Komplexit√§t des Prozesses manuell frei).  Aber wie gew√∂hnlich ist eine neue Komplexit√§t entstanden. <br><br><h2>  Testen automatisieren </h2><br><img src="https://habrastorage.org/webt/kk/rc/v8/kkrcv8melsazessicjkebzle2s4.jpeg"><br><br>  Aufgrund der Automatisierung von Releases haben sich die Entwicklungsprozesse beschleunigt, auch weil einige Testphasen √ºbersprungen wurden.  Dies f√ºhrte zu einem vor√ºbergehenden Qualit√§tsverlust.  Es klingt kitschig, aber zusammen mit der Beschleunigung von Releases war es notwendig, die Methodik der Produktentwicklung zu √§ndern.  Es war notwendig, √ºber das Testen der Automatisierung nachzudenken und pers√∂nliche Verantwortung (hier geht es darum, ‚Äûeine Idee im Kopf zu akzeptieren‚Äú anstatt Geldstrafen) des Entwicklers f√ºr den ver√∂ffentlichten Code und die darin enthaltenen Fehler sowie √ºber die Entscheidung, die Aufgabe durch eine automatische Bereitstellung zu erteilen / nicht zu erteilen. <br><br>  Um Qualit√§tsprobleme zu beseitigen, haben wir zwei wichtige Entscheidungen getroffen: Wir haben mit der Durchf√ºhrung von Kanarientests begonnen und eine automatische √úberwachung des Fehlerhintergrunds mit automatischer Reaktion auf dessen √úberschuss implementiert.  Die erste L√∂sung erm√∂glichte es, offensichtliche Fehler zu finden, bevor der Code vollst√§ndig in Produktion ging, die zweite reduzierte die Reaktionszeit auf Probleme in der Produktion.  Nat√ºrlich treten Fehler auf, aber wir verwenden den gr√∂√üten Teil unserer Zeit und Energie nicht auf die Korrektur, sondern auf die Minimierung. <br><br><h2>  Automatisierungsteam </h2><br>  Mittlerweile besch√§ftigen wir 130 Entwickler und <a href="https://habr.com/ru/article/469965/">wachsen weiter</a> .  Das Team f√ºr kontinuierliche Integration und Codebereitstellung (im Folgenden als Deploy and Integration- oder DI-Team bezeichnet) besteht aus 7 Mitarbeitern und arbeitet in zwei Richtungen: Entwicklung der Integro-Automatisierungsplattform und von DevOps. <br><br>  DevOps ist verantwortlich f√ºr die Dev / Beta-Umgebung der CIAN-Website, die Integro-Umgebung, hilft Entwicklern bei der L√∂sung von Problemen und entwickelt neue Ans√§tze f√ºr die Skalierung von Umgebungen.  Das Gesch√§ftsfeld von Integro befasst sich sowohl mit Integro selbst als auch mit verwandten Diensten, z. B. Plug-Ins f√ºr Jenkins, Jira und Confluence, und entwickelt auch Hilfsprogramme und Anwendungen f√ºr Entwicklungsteams. <br><br>  Das DI-Team arbeitet mit dem Platform-Team zusammen, das Architekturen, Bibliotheken und Entwicklungsans√§tze innerhalb des Unternehmens entwickelt.  Gleichzeitig kann jeder Entwickler im CIAN einen Beitrag zur Automatisierung leisten, z. B. eine Mikroautomatisierung gem√§√ü den Anforderungen des Teams vornehmen oder eine coole Idee zur Verbesserung der Automatisierung teilen. <br><br><h2>  Puff Pie Automation in Cyan </h2><br><img src="https://habrastorage.org/webt/v8/xt/rz/v8xtrzfhj8bp-kzio9qduuixgf4.png"><br><br>  Alle an der Automatisierung beteiligten Systeme k√∂nnen in mehrere Ebenen unterteilt werden: <br><br><ol><li>  Externe Systeme (Jira, Bitbucket usw.).  Entwicklungsteams arbeiten mit ihnen. <br></li><li>  Plattform Integro.  Meistens arbeiten Entwickler nicht direkt damit, aber sie unterst√ºtzt die Arbeit der gesamten Automatisierung. <br></li><li>  Zustellungs-, Orchestrierungs- und Entdeckungsdienste (z. B. Jeknins, Consul, Nomad).  Mit ihrer Hilfe stellen wir den Code auf den Servern bereit und stellen die Dienste miteinander bereit. <br></li><li>  Physische Schicht (Server, Betriebssystem, zugeh√∂rige Software).  Auf dieser Ebene funktioniert unser Code.  Dies kann entweder ein physischer oder ein virtueller Server sein (LXC, KVM, Docker). <br></li></ol><br>  Basierend auf diesem Konzept teilen wir die Verantwortungsbereiche innerhalb des DI-Teams auf.  Die ersten beiden Ebenen liegen in der Verantwortung des Entwicklungsbereichs von Integro, und die letzten beiden Ebenen liegen bereits im Verantwortungsbereich von DevOps.  Diese Trennung erm√∂glicht es Ihnen, sich auf Aufgaben zu konzentrieren und beeintr√§chtigt nicht die Interaktion, da wir nebeneinander stehen und st√§ndig Wissen und Erfahrung austauschen. <br><br><h2>  Integro </h2><br>  Konzentrieren wir uns auf Integro und beginnen mit dem Technologie-Stack: <br><br><ul><li>  CentOs 7 <br></li><li>  Docker + Nomad + Consul + Vault <br></li><li>  Java 11 (der alte Integro-Monolith bleibt in Java 8 erhalten) <br></li><li>  Spring Boot 2.X + Spring Cloud Config <br></li><li>  PostgreSql 11 <br></li><li>  Rabbitmq <br></li><li>  Apache entz√ºnden <br></li><li>  Camunda (eingebettet) <br></li><li>  Grafana + Graphit + Prometheus + Jaeger + ELK <br></li><li>  Web-Benutzeroberfl√§che: Reagieren (CSR) + MobX <br></li><li>  SSO: Schl√ºsselmantel <br></li></ul><br>  Wir halten uns an das Prinzip der Microservice-Entwicklung, obwohl wir das Erbe eines Monolithen der fr√ºheren Version von Integro haben.  Jeder Mikrodienst dreht sich in seinem Docker-Container, die Dienste kommunizieren √ºber HTTP-Anforderungen und RabbitMQ-Nachrichten miteinander.  Microservices finden sich gegenseitig √ºber Consul und f√ºhren eine Anfrage durch, wobei die Autorisierung √ºber SSO (Keycloak, OAuth 2 / OpenID Connect) erfolgt. <br><br><img src="https://habrastorage.org/webt/ib/mn/ne/ibmnnec5ijrxrai9mpx_tdiipri.png"><br><br>  Betrachten Sie als reales Beispiel die Interaktion mit Jenkins, die aus den folgenden Schritten besteht: <br><br><ol><li>  Der Workflow-Management-Microservice (im Folgenden als Flow-Microservice bezeichnet) m√∂chte die Assembly in Jenkins ausf√ºhren.  Zu diesem Zweck findet er √ºber Consul IP: PORT eine Mikroservice-Integration mit Jenkins (im Folgenden: Jenkins-Mikroservice) und sendet ihm eine asynchrone Anforderung zum Starten der Assembly in Jenkins. <br></li><li>  Der Jenkins-Microservice generiert nach Eingang der Anfrage die Job-ID und gibt sie zur√ºck, anhand derer das Ergebnis der Arbeit identifiziert werden kann.  Gleichzeitig startet er den Build in Jenkins durch einen Aufruf der REST-API. <br></li><li>  Jenkins erstellt und sendet nach Abschluss einen Webhook mit den Ergebnissen an den Jenkins-Microservice. <br></li><li>  Ein Jenkins-Microservice, der einen Webhook erhalten hat, generiert eine Nachricht √ºber den Abschluss der Anforderungsverarbeitung und h√§ngt die Ausf√ºhrungsergebnisse an diese an.  Die generierte Nachricht wird an die RabbitMQ-Warteschlange gesendet. <br></li><li>  √úber RabbitMQ gelangt die ver√∂ffentlichte Nachricht an den Flow-Mikrodienst, der das Ergebnis der Verarbeitung seiner Aufgabe erf√§hrt, indem die Job-ID aus der Anforderung und der empfangenen Nachricht abgeglichen wird. <br></li></ol><br>  Jetzt haben wir ungef√§hr 30 Microservices, die in mehrere Gruppen unterteilt werden k√∂nnen: <br><br><ol><li>  Konfigurationsmanagement. <br></li><li>  Informieren und Interagieren mit Benutzern (Instant Messenger, E-Mail). <br></li><li>  Arbeite mit Quellcode. <br></li><li>  Integration mit Bereitstellungstools (Jenkins, Nomaden, Konsul usw.). <br></li><li>  √úberwachung (Releases, Bugs usw.). <br></li><li>  Webdienstprogramme (Benutzeroberfl√§che zum Verwalten von Testumgebungen, Sammeln von Statistiken usw.). <br></li><li>  Integration mit Task Trackern und √§hnlichen Systemen. <br></li><li>  Workflow f√ºr verschiedene Aufgaben verwalten. <br></li></ol><br><h2>  Workflow-Aufgaben </h2><br>  Integro automatisiert Aktivit√§ten im Zusammenhang mit dem Task-Lebenszyklus.  Vereinfacht durch den Task-Lebenszyklus meinen wir den Workflow einer Task in Jira.  In unseren Entwicklungsprozessen gibt es abh√§ngig vom Projekt, der Art der Aufgabe und den f√ºr eine bestimmte Aufgabe ausgew√§hlten Optionen verschiedene Variationen des Workflows. <br><br>  Betrachten Sie den Workflow, den wir am h√§ufigsten verwenden: <br><br><img src="https://habrastorage.org/webt/yu/va/8x/yuva8xxb7edyldadgxorqwixdtm.jpeg"><br><br>  Im Diagramm zeigt das Zahnrad an, dass der √úbergang von Integro automatisch aufgerufen wird, w√§hrend die menschliche Figur bedeutet, dass der √úbergang von der Person manuell aufgerufen wird.  Schauen wir uns einige M√∂glichkeiten an, wie eine Aufgabe diesen Workflow durchlaufen kann. <br><br>  Vollst√§ndig manuelles Testen f√ºr DEV + BETA ohne Kanarientests (normalerweise geben wir einen Monolithen frei): <br><br><img src="https://habrastorage.org/webt/nu/ab/be/nuabbeencu3tzfmryb2wpcya-cy.png"><br><br>  Es kann andere Kombinationen von √úberg√§ngen geben.  Manchmal kann der Pfad, den die Aufgabe nehmen wird, √ºber Optionen in Jira ausgew√§hlt werden. <br><br><h2>  Aufgabenbewegung </h2><br>  Ber√ºcksichtigen Sie die grundlegenden Schritte, die beim Verschieben der Aufgabe im Workflow "Testen auf DEV + -Kanarientests" ausgef√ºhrt werden: <br><br>  1. Der Entwickler oder die PM erstellt die Aufgabe. <br><br>  2. Der Entwickler √ºbernimmt die Aufgabe zur Arbeit.  √úbertr√§gt es nach Abschluss in den Status IN REVIEW. <br><br>  3. Jira sendet Webhook an den Jira-Microservice (ist f√ºr die Integration mit Jira verantwortlich). <br><br>  4. Der Jira Microservice sendet eine Anfrage an den Flow Service (er ist verantwortlich f√ºr die internen Workflows, in denen die Arbeit ausgef√ºhrt wird), um den Workflow zu starten. <br><br>  5. Innerhalb des Flow-Dienstes: <br><br><ul><li>  Die Pr√ºfer f√ºr die Aufgabe werden zugewiesen (Users-Microservice, der alles √ºber Benutzer wei√ü + Jira-Microservice). </li><li>  √úber den Mikroservice Source (er kennt sich mit Repositorys und Verzweigungen aus, arbeitet aber nicht mit dem Code selbst) sucht er nach Repositorys, in denen sich eine Verzweigung unserer Aufgabe befindet (um die Suche zu vereinfachen, stimmt der Name der Verzweigung mit der Aufgabennummer in Jira √ºberein).  In den meisten F√§llen hat die Aufgabe nur einen Zweig in einem Repository. Dies vereinfacht die Verwaltung der Warteschlange bei der Bereitstellung und verringert die Konnektivit√§t zwischen den Repositorys. </li><li>  F√ºr jeden gefundenen Zweig wird die folgende Abfolge von Aktionen ausgef√ºhrt: <br><br>  i) Betankung des Master-Zweigs (Git-Microservice f√ºr die Arbeit mit Code). <br>  ii) Der Zweig wird vom Entwickler f√ºr √Ñnderungen gesperrt (Bitbucket Microservice). <br>  iii) In diesem Zweig wird eine Pull-Anforderung erstellt (Bitbucket-Microservice). <br>  iv) Eine Nachricht √ºber die neue Pull-Anfrage wird an die Chats des Entwicklers gesendet (Benachrichtigen Sie den Microservice, wenn Sie mit Benachrichtigungen arbeiten). <br>  v) Erstellen, Testen und Bereitstellen von Tasks f√ºr DEV (Jenkins Microservice f√ºr die Arbeit mit Jenkins). <br>  vi) Wenn alle vorhergehenden Abs√§tze erfolgreich abgeschlossen wurden, setzt Integro seine Genehmigung in den Pull-Request (Bitbucket-Microservice). </li><li>  Integro erwartet von den designierten Pr√ºfern eine Pull-Request-Genehmigung. </li><li>  Sobald alle erforderlichen Genehmigungen eingegangen sind (einschlie√ülich der erfolgreich bestandenen automatisierten Tests), √ºbertr√§gt Integro die Aufgabe in den Status Test on Dev (Jira Microservice). </li></ul><br>  6. Tester testen die Aufgabe.  Wenn keine Probleme vorliegen, wird die Aufgabe in den Status Bereit zum Erstellen versetzt. <br><br>  7. Integro "sieht", dass der Task zur Freigabe bereit ist, und startet seine Bereitstellung im kanarischen Modus (Jenkins Microservice).  Die Freigabebereitschaft wird durch ein Regelwerk bestimmt.  Zum Beispiel eine Aufgabe im richtigen Status, es gibt keine Sperren f√ºr andere Aufgaben, jetzt gibt es keine aktiven Berechnungen f√ºr diesen Mikrodienst usw. <br><br>  8. Die Aufgabe wird in den Status von Canary (Jira-microservice) √ºbertragen. <br><br>  9. Jenkins startet √ºber Nomad eine Bereitstellung von Tasks im kanarischen Modus (normalerweise 1-3 Instanzen) und benachrichtigt den Release-√úberwachungsdienst (DeployWatch-Microservice) √ºber die Berechnung. <br><br>  10. DeployWatch-microservice sammelt Hintergrundfehler und reagiert gegebenenfalls darauf.  Wird der Hintergrundfehler √ºberschritten (die Hintergrundrate wird automatisch berechnet), werden die Entwickler √ºber den Microservice Benachrichtigen benachrichtigt.  Wenn der Entwickler nach 5 Minuten nicht geantwortet hat (auf "Zur√ºcksetzen" oder "Bleiben" geklickt), wird das automatische Rollback der kanarischen Instanzen gestartet.  Wenn der Hintergrund nicht √ºberschritten wird, muss der Entwickler die Bereitstellung der Aufgabe in der Produktion manuell starten (durch Dr√ºcken der Schaltfl√§che auf der Benutzeroberfl√§che).  Wenn der Entwickler innerhalb von 60 Minuten keine Bereitstellung in der Produktion gestartet hat, werden die kanarischen Instanzen aus Sicherheitsgr√ºnden ebenfalls abgepumpt. <br><br>  11. Nach dem Start der Bereitstellung in der Produktion: <br><br><ul><li>  Die Aufgabe wird in den Produktionsstatus (Jira Microservice) √ºberf√ºhrt. </li><li>  Jenkins Microservice startet den Bereitstellungsprozess und benachrichtigt die Bereitstellung des DeployWatch-Microservice. </li><li>  DeployWatch-microservice √ºberpr√ºft, ob alle Container in der Produktion aktualisiert wurden (es gab F√§lle, in denen nicht alle aktualisiert wurden). </li><li>  Eine Benachrichtigung √ºber die Ergebnisse der Bereitstellung an die Produktion wird √ºber den Benachrichtigungsmikroservice gesendet. </li></ul><br>  12. Die Entwickler haben 30 Minuten Zeit, um das Rollback des Tasks mit Production zu starten, falls ein fehlerhaftes Verhalten des Microservices festgestellt wird.  Nach dieser Zeit wird die Aufgabe automatisch in den Master (Git-microservice) √ºbernommen. <br><br>  13. Nach einer erfolgreichen Zusammenf√ºhrung im Master wird der Task-Status auf Closed (Jira Microservice) ge√§ndert. <br><br>  Das Schema gibt nicht vor, vollst√§ndig detailliert zu sein (in Wirklichkeit gibt es sogar noch mehr Schritte), aber es erm√∂glicht es, den Grad der Integration in Prozesse zu bewerten.  Wir halten dieses Schema nicht f√ºr ideal und verbessern die Prozesse der automatischen Verfolgung von Releases und der Bereitstellung. <br><br><h2>  Was weiter </h2><br>  Wir haben gro√üe Pl√§ne f√ºr die Entwicklung der Automatisierung, z. B. die Ablehnung manueller Vorg√§nge w√§hrend der Freigabe von Monolithen, die Verbesserung der √úberwachung w√§hrend der automatischen Bereitstellung und die Verbesserung der Interaktion mit Entwicklern. <br><br>  Aber lassen Sie uns jetzt an dieser Stelle anhalten.  Wir haben oberfl√§chlich viele Themen in der √úberpr√ºfung der Automatisierung behandelt, einige haben sie √ºberhaupt nicht angesprochen, daher beantworten wir gerne Fragen.  Wir warten auf Vorschl√§ge, was im Detail zu behandeln ist, schreiben Sie in den Kommentaren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486056/">https://habr.com/ru/post/de486056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486042/index.html">Gesetzgebung f√ºr Boten und Telekommunikation</a></li>
<li><a href="../de486046/index.html">Der Linux-Kernel enthielt WireGuard VPN</a></li>
<li><a href="../de486048/index.html">Was ist das und was frisst es?</a></li>
<li><a href="../de486050/index.html">Webix JavaScript-Bibliothek mit den Augen eines Anf√§ngers. Teil 3. Module, Diagramme, Baumtabellen</a></li>
<li><a href="../de486052/index.html">Verbrannte Erde ist die Mutter aller Spiele. Interview mit dem Sch√∂pfer</a></li>
<li><a href="../de486060/index.html">Finden Sie Ordnung im Chaos der IT: Organisieren Sie Ihre eigene Entwicklung</a></li>
<li><a href="../de486062/index.html">Einfaches Zero-Copy-Rendering hardwarebeschleunigter Videos in QML</a></li>
<li><a href="../de486064/index.html">Erstellen Sie eine animierte Diashow in reinem CSS.</a></li>
<li><a href="../de486066/index.html">Im Zugangsbereich. Finden Sie die Entfernung von einem Punkt zu einem Gebiet und reduzieren Sie Reverse Geocoding-Anforderungen</a></li>
<li><a href="../de486070/index.html">ACL-Schalter im Detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>