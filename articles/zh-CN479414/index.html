<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🔬 🍇 😨 找到目标的方法。 机会的作用 🤳🏾 🧔🏾 🗡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.简介 
 搜索可以是复杂的，也可以是简单的。 当目标本身和实现目标的方式未知（或仅部分未知）时，机会很重要 

 该研究文章的目的是比较发现目标为运动（黄色物体）和静止物体的方法。 

 这些方法： 



- 随机搜索（红色物体） 
- 带内存的随机搜索（蓝色对象） 
- 具有内存和层次结构的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>找到目标的方法。 机会的作用</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479414/"><h4>  1.简介 </h4><br> 搜索可以是复杂的，也可以是简单的。 当目标本身和实现目标的方式未知（或仅部分未知）时，机会很重要 <br><br> 该研究文章的目的是比较发现目标为运动（黄色物体）和静止物体的方法。 <br><br> 这些方法： <br><br><ul><li> 随机搜索（红色物体） </li><li> 带内存的随机搜索（蓝色对象） </li><li> 具有内存和层次结构的随机搜索（绿色对象） </li><li> 搜索第一条路线（紫色对象） </li><li> 搜索一条短途路线（棕色物体） </li></ul><br> 在图1中，显示了这些对象。 完整的程序代码发布在<a href="https://github.com/bulygina07/rp/blob/master/random_path.py">github上</a> <br><br><img src="https://habrastorage.org/webt/qm/73/tj/qm73tjbhq60wc-ohyw8uuoxmli0.jpeg"><br><a name="habracut"></a><br><h4>  2.主要部分 </h4><br>  2.1。  P类-随机搜索 <br><br> 构造函数初始化类的属性和变量：主窗口，颜色，y和x坐标，计数器，已访问字典，目标，层次结构字典，邻居字典。  init_3_dict方法填充三个字典。  show方法将单元格绘制为所需的颜色。  update方法更新对象。  top_show方法创建一个顶层窗口，并显示对目标执行了多少步骤。 <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">P</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">()</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, root, color, node, target, maps, ban)</span></span></span><span class="hljs-function">:</span></span> self.root = root self.color = color self.y = node[<span class="hljs-number"><span class="hljs-number">0</span></span>] self.x = node[<span class="hljs-number"><span class="hljs-number">1</span></span>] P.target = target self.count = <span class="hljs-number"><span class="hljs-number">0</span></span> self.visit = {} P.hierarchy = {} P.neighbor = {} self.init_3_dict(maps, ban)</code> </pre> <br>  is_en函数在init_3_dict方法中声明，该方法检查坐标是否被禁止且是否超出地图范围。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_3_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, maps, ban)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_en</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(yx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> yx[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt; len(maps)<span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> yx[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; len(maps[<span class="hljs-number"><span class="hljs-number">0</span></span>])<span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yx <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ban: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br> 在一个循环中，在使用坐标键访问的字典中，将初始值写入零。 在具有相同键的层次结构字典中，输入此坐标的层次结构名称。 然后，我们通过调用is_en函数来填充邻居字典。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(maps)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(maps[<span class="hljs-number"><span class="hljs-number">0</span></span>])): self.visit[(y,x)] = <span class="hljs-number"><span class="hljs-number">0</span></span> P.hierarchy[(y,x)] = maps[y][x] n = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y<span class="hljs-number"><span class="hljs-number">-1</span></span>,x)): n.append((y<span class="hljs-number"><span class="hljs-number">-1</span></span>,x)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y+<span class="hljs-number"><span class="hljs-number">1</span></span>,x)): n.append((y+<span class="hljs-number"><span class="hljs-number">1</span></span>,x)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y,x<span class="hljs-number"><span class="hljs-number">-1</span></span>)): n.append((y,x<span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_en((y,x+<span class="hljs-number"><span class="hljs-number">1</span></span>)): n.append((y,x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) P.neighbor[(y,x)] = n</code> </pre><br>  show方法使用所需颜色绘制具有y，x坐标的单元格。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, y, x, color)</span></span></span><span class="hljs-function">:</span></span> lb = Label(text=<span class="hljs-string"><span class="hljs-string">" "</span></span>, background = color) lb.configure(text=P.hierarchy[(y,x)] ) lb.grid(row=self.y, column=self.x, ipadx=<span class="hljs-number"><span class="hljs-number">10</span></span>, ipady=<span class="hljs-number"><span class="hljs-number">5</span></span>, padx=<span class="hljs-number"><span class="hljs-number">1</span></span>, pady=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  move方法移动对象。 在变量y，x中，我们写入邻居的坐标，该坐标是从邻居列表中随机选择的。 然后，我们使用新坐标重新绘制。 <br><br> 我们增加柜台。 检查目标是否实现。 如果达到了目标，那么在类J.disable中的变量中我们可以正确编写。 我们调用top_show（）方法。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[(self.y, self.x)]: v.append(i) y,x = random.choice(v) self.show(self.y, self.x, <span class="hljs-string"><span class="hljs-string">'white'</span></span>) self.y = y self.x = x self.show(y, x, self.color) self.count +=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> P.target == P.hierarchy[(self.y, self.x)]: J.disable = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> self.top_show()</code> </pre><br>  update方法调用move并且每半秒更新一次。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.move() self.root.after(<span class="hljs-number"><span class="hljs-number">500</span></span>, self.update)</code> </pre><br>  top_show方法显示结果。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">top_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> top = Toplevel() lbt = Label(top, text=self.color + <span class="hljs-string"><span class="hljs-string">" = "</span></span> + str(self.count)) lbt.pack() top.mainloop()</code> </pre><br>  2.2。  M类-随机存储器搜索 <br><br> 构造函数调用父类的构造函数，并增加我们要去的字段的单元格的值。  move方法移动对象。 选择方法返回带有存储器的随机搜索算法选择的坐标。 <br><br> 在move方法中，调用choice方法。 否则，他的工作类似于父母的方法。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> yx = self.choice((self.y, self.x))</code> </pre><br> 选择方法遍历邻居的坐标并将元组添加到列表v。 元组的第一个元素将是邻居的坐标，第二个是已被访问的次数。 然后我们从小到大排序。 我们对所有元组进行排序，在列表v中，仅保留那些发生在第一个元组中记录的次数的事件。 随机选择其中任何一个。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, yx)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[yx]: v.append((i, self.visit[i])) v.sort(key = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) v = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] == i[<span class="hljs-number"><span class="hljs-number">1</span></span>]] v = random.choice(v) self.visit[v[<span class="hljs-number"><span class="hljs-number">0</span></span>]] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  2.3。  N类-具有内存和层次结构的随机搜索。 <br><br> 选择方法选择与目标的层次结构名称最匹配的那些元组。 如果此匹配相同，则选择访问最少的坐标。 <br><br> 构造函数调用父对象的构造函数，并根据层次结构名称与目标的字符匹配数来初始化符合属性。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, root, color, node, target, maps, ban)</span></span></span><span class="hljs-function">:</span></span> super().__init__(root, color, node, target, maps, ban) self.coincidence = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br> 循环中的选择方法将写入邻居当前坐标的层次结构名称。 变量r存储此变量与目标的匹配数。 如果匹配数r较大，则符合被覆盖。 在这种情况下，来自列表v的元组（坐标，访问次数）被写入列表d。 如果r等于巧合，则在d中从v添加一个元组。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">choice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, yx)</span></span></span><span class="hljs-function">:</span></span> v = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[yx]: v.append((i, self.visit[i])) d = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v: c = P.hierarchy[l[<span class="hljs-number"><span class="hljs-number">0</span></span>]] r = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(P.target)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c[i] == P.target[i]: r +=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r &gt; self.coincidence: self.coincidence = r d = [l] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r == self.coincidence: d.append(l) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d: v = d v.sort(key = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) v = [i <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] == i[<span class="hljs-number"><span class="hljs-number">1</span></span>]] v = random.choice(v) self.visit[v[<span class="hljs-number"><span class="hljs-number">0</span></span>]] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br>  2.4。  K类-搜索路线并搜索最短路线。 <br><br> 构造函数将结束坐标写入结束变量。 如果short参数为False，则称为路线搜索。 否则，我们找到最短的路线。 <br><br>  find_path方法将当前坐标添加到路线。 如果达到目标，则返回路线。 我们对所有邻居进行分类。 如果路径中没有邻居，则递归调用自己。 该方法返回的事实被写入newpath。 找到的第一条路线将是newpath。  find_short_path方法之间的区别在于，如果newpath的长度大于或等于最短的长度，则最短将被覆盖。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, node, end, path=[])</span></span></span><span class="hljs-function">:</span></span> path = path + [node] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == end: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> P.neighbor[node]: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> path: newpath = self.find_path(v, end, path) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> newpath: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newpath</code> </pre><br>  2.5。  J类是移动目标。 <br><br> 类J的对象的移动类似于类P。如果类J.disable的变量为true，则该对象停止。 <br><br>  2.6。 功能主体。 <br><br> 创建主窗口。 在目标变量中，编写目标的层次结构名称。 禁止列表包含禁止的单元格的坐标。 在地图列表中，地图本身。 在循环中，我们绘制了一张地图。 创建类对象。 然后我们调用更新函数，该函数将更新对象。 <br><br><h4>  3.结论 </h4><br> 对移动目标和静止目标都进行了五次实验。 <br><br> 表1显示最佳算法是最短路径。 第二有效的是具有内存和层次结构的随机搜索。 最糟糕的是随机搜索。 <br><br> 表1.固定目标 <br><br><img src="https://habrastorage.org/webt/lv/w3/_7/lvw3_7ehvk3w0oeffgo8nyrq5zk.jpeg" alt="图片"><br><br> 在移动目标的情况下，结果是不同的。 最差的算法是最初计算到达目标路线的算法。 在表2中，破折号表示尚未实现目标。 布朗比紫罗兰还差。 更糟糕的是，因为紫罗兰色的轨迹较长（达到移动目标的机会更大）。 搜索移动目标时，最好的算法是具有内存和层次结构的随机搜索。 其次是带有内存的随机搜索。 <br><br> 表2.移动目标 <br><br><img src="https://habrastorage.org/webt/3r/_d/58/3r_d58csbdvlpe0abgm49s8pp44.jpeg" alt="图片"><br><br> 如果不知道目标是否在移动，则最好使用具有内存和层次结构的随机搜索算法，或者仅使用具有内存的随机搜索算法。 <br><br><h4>  4.结论 </h4><br> 如果寻找目标时面对不确定性，则随机性很重要。 如果数据分层显示，则搜索会减少。 记忆当然也很有价值。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479414/">https://habr.com/ru/post/zh-CN479414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479398/index.html">我们把线性回归方程变成矩阵形式</a></li>
<li><a href="../zh-CN479400/index.html">如何使记者脱离神经网络，或者“秘密地减少哈布雷的文字，一言不发”</a></li>
<li><a href="../zh-CN479402/index.html">如何正式向国外的自由职业者支付费用，缴纳0％税款而不提供付款系统</a></li>
<li><a href="../zh-CN479404/index.html">圣诞老人的工作人员</a></li>
<li><a href="../zh-CN479406/index.html">Kotlin的16个Android开发技巧。 第一部分</a></li>
<li><a href="../zh-CN479416/index.html">查看您要去的地方（周围视觉与认知负荷）</a></li>
<li><a href="../zh-CN479420/index.html">打开麦克风：后端。 来宾注册</a></li>
<li><a href="../zh-CN479422/index.html">[视频动画]有线世界：35年内海底电缆网络如何覆盖全球</a></li>
<li><a href="../zh-CN479426/index.html">安全周50：Confluence和Linux中的中间人攻击</a></li>
<li><a href="../zh-CN479428/index.html">12月9日至15日在莫斯科举行的数字活动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>