<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐃 👨🏿‍🎨 🎽 Comment faire fonctionner vos applications Web hors ligne 🙎🏾 🔮 🤚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La puissance de JavaScript et de l'API du navigateur 

 Le monde devient de plus en plus interconnecté - le nombre de personnes ayant accès à Internet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment faire fonctionner vos applications Web hors ligne</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/474374/">  <i>La puissance de JavaScript et de l'API du navigateur</i> <br><br>  Le monde devient de plus en plus interconnecté - le nombre de personnes ayant accès à Internet est passé à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4,5 milliards</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/c94/c74/a7ac94c74325a245837ec6e11fde02e0.png" alt="image"></div><br>  Mais ces données ne reflètent pas le nombre de personnes qui ont une connexion Internet lente ou interrompue.  Même aux États-Unis, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4,9 millions de foyers</a> ne peuvent pas accéder à Internet câblé à des vitesses supérieures à 3 mégabits par seconde. <br><br>  Le reste du monde - ceux qui ont un accès fiable à Internet - est toujours enclin à perdre la connectivité.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Certains facteurs</a> peuvent affecter la qualité de votre connexion réseau: <br><br><ul><li>  Mauvaise couverture du fournisseur. </li><li>  Conditions météorologiques extrêmes. </li><li>  Coupures de courant. </li><li>  Les utilisateurs qui tombent dans des zones mortes, comme les bâtiments qui bloquent leurs connexions réseau. </li><li>  Voyage en train et voyage en tunnel. </li><li>  Connexions contrôlées par un tiers et limitées dans le temps. </li><li>  Pratiques culturelles qui nécessitent un accès Internet limité ou inexistant à des heures ou des jours spécifiques. </li></ul><br>  Compte tenu de cela, il est clair que nous devons considérer l'expérience autonome lors du développement et de la création d'applications. <br><a name="habracut"></a><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Logiciel EDISON - développement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - développement web"></a> <br clear="right">  Cet article a été traduit avec le soutien d'EDISON Software, une société qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effectue d'excellentes commandes depuis le sud de la Chine</a> , et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développe</a> également <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des applications et des sites Web</a> . </blockquote>  J'ai récemment eu l'opportunité d'ajouter de l'autonomie à une application existante en utilisant des travailleurs de service, le stockage en cache et IndexedDB.  Le travail technique nécessaire pour que l'application fonctionne hors ligne a été réduit à quatre tâches distinctes, dont je parlerai dans cet article. <br><br><h3>  Travailleurs des services </h3><br>  Les applications créées pour une utilisation hors ligne ne doivent pas dépendre fortement du réseau.  Conceptuellement, cela n'est possible que si, en cas de panne, des options de sauvegarde existent. <br><br>  Si l'application Web ne parvient pas à se charger, nous devons prendre les ressources du navigateur quelque part (HTML / CSS / JavaScript).  D'où viennent ces ressources, sinon d'une demande de réseau?  Que diriez-vous d'un cache.  La plupart des gens conviendront qu'il est préférable de fournir une interface utilisateur potentiellement obsolète qu'une page vierge. <br><br>  Le navigateur interroge constamment les données.  Le service de mise en cache des données en tant que solution de rechange nous oblige toujours à intercepter les demandes du navigateur et à écrire des règles de mise en cache.  C'est là que les travailleurs des services entrent en jeu - considérez-les comme un intermédiaire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7a/c94/c74/a7ac94c74325a245837ec6e11fde02e0.png" alt="image"><br><br>  Le service worker est juste un fichier JavaScript dans lequel nous pouvons nous abonner aux événements et écrire nos propres règles pour la mise en cache et la gestion des pannes de réseau. <br>  Commençons. <br><br>  <b>Veuillez noter: notre application de démonstration</b> <br><br>  Tout au long de cet article, nous ajouterons des fonctions autonomes à l'application de démonstration.  L'application de démonstration est une page simple pour prendre / louer des livres dans la bibliothèque.  Les progrès seront présentés sous la forme d'une série de GIF et l'utilisation de simulations Chrome DevTools hors ligne. <br><br>  Voici l'état initial: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/757/978/c5b/757978c5bc485412b8037790878d0e08.gif" alt="image"><br><br><h3>  Tâche 1 - Mise en cache des ressources statiques </h3><br>  Les ressources statiques sont des ressources qui ne changent pas souvent.  HTML, CSS, JavaScript et les images peuvent entrer dans cette catégorie.  Le navigateur essaie de charger des ressources statiques à l'aide de requêtes pouvant être interceptées par le technicien de service. <br><br>  Commençons par inscrire notre technicien. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">'serviceWorker'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> navigator) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ navigator.serviceWorker.register(<span class="hljs-string"><span class="hljs-string">'/sw.js'</span></span>); }); }</code> </pre> <br>  Les employés de service sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des employés Web</a> sous le capot et doivent donc être importés à partir d'un fichier JavaScript distinct.  L'inscription a lieu en utilisant la méthode d' <code>register</code> après le chargement du site. <br>  Maintenant que nous avons chargé un technicien de service, mettons en cache nos ressources statiques. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CACHE_NAME = <span class="hljs-string"><span class="hljs-string">'my-offline-cache'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlsToCache = [ <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/css/main.c9699bb9.css'</span></span>, <span class="hljs-string"><span class="hljs-string">'/static/js/main.99348925.js'</span></span> ]; self.addEventListener(<span class="hljs-string"><span class="hljs-string">'install'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.waitUntil( caches.open(CACHE_NAME) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache.addAll(urlsToCache); }) ); });</code> </pre> <br>  Étant donné que nous contrôlons les URL des ressources statiques, nous pouvons les mettre en cache immédiatement après l'initialisation du technicien de service à l'aide du <code>Cache Storage</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48a/7fb/43b/48a7fb43b94154ceab8353d80fbd4a02.png" alt="image"><br><br>  Maintenant que notre cache est plein des ressources statiques les plus récemment demandées, chargeons ces ressources à partir du cache en cas d'échec d'une demande. <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  L'événement <code>fetch</code> est déclenché chaque fois que le navigateur fait une demande.  Notre nouveau gestionnaire d'événements d' <code>fetch</code> dispose désormais d'une logique supplémentaire pour renvoyer les réponses mises en cache en cas de pannes de réseau. <br><br><h3>  Démo numéro 1 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/a2c/94c/7c3a2c94c111c6ad57dae86cabdd67ae.gif" alt="image"><br><br>  Notre application de démonstration peut désormais servir des ressources statiques hors ligne!  Mais où sont nos données? <br><br><h3>  Tâche 2 - Mise en cache des ressources dynamiques </h3><br>  Les applications monopages (SPA) demandent généralement des données progressivement après le chargement initial de la page, et notre application de démonstration ne fait pas exception - la liste des livres n'est pas chargée immédiatement.  Ces données proviennent généralement de demandes XHR qui renvoient des réponses qui changent fréquemment pour fournir un nouvel état à l'application - elles sont donc dynamiques. <br><br>  La mise en cache des ressources dynamiques est en fait très similaire à la mise en cache des ressources statiques - la principale différence est que nous devons mettre à jour le cache plus souvent.  Il est également assez difficile de générer une liste complète de toutes les demandes XHR dynamiques possibles, nous allons donc les mettre en cache à leur arrivée, et nous n'aurons pas de liste prédéfinie, comme nous l'avons fait pour les ressources statiques. <br><br>  Jetez un œil à notre gestionnaire d' <code>fetch</code> : <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  Nous pouvons personnaliser cette implémentation en ajoutant du code qui met en cache les demandes et réponses réussies.  Cela garantit que nous ajoutons constamment de nouvelles demandes à notre cache et mettons constamment à jour les données mises en cache. <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ event.respondWith( fetch(event.request) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ caches.open(CACHE_NAME).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function">) </span></span>{ cache.put(event.request, response); }); }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; } ); ); });</code> </pre> <br>  Notre <code>Cache Storage</code> actuellement plusieurs entrées. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fae/6b5/8a2/fae6b58a2d7dbcff00c036182d20bb3e.png" alt="image"><br><br><h3>  Démo numéro 2 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c38/9a1/4f6/c389a14f6631a2b359d4bb7e6c2de1f1.gif" alt="image"><br><br>  Notre démo est maintenant la même au démarrage, quel que soit l'état de notre réseau! <br><br>  Super.  Essayons maintenant d'utiliser notre application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/197/3ea/e18/1973eae1897feadc56cf65a86986b3b0.gif" alt="image"><br><br>  Malheureusement, les messages d'erreur sont partout.  Il semble que toutes nos interactions avec l'interface ne fonctionnent pas.  Je ne peux pas choisir ou remettre le livre!  Que faut-il corriger? <br><br><h3>  Tâche 3 - Créer une interface utilisateur optimiste </h3><br>  À l'heure actuelle, le problème de notre application est que notre logique de collecte de données dépend toujours fortement des réponses du réseau.  L'action d'archivage ou d'extraction envoie une demande au serveur et attend une réponse réussie.  C'est idéal pour la cohérence des données, mais mauvais pour notre expérience autonome. <br><br>  Pour que ces interactions fonctionnent hors ligne, nous devons rendre notre application plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optimiste</a> .  Les interactions optimistes ne nécessitent pas de réponse du serveur et affichent volontiers une vue mise à jour des données.  L'opération optimiste habituelle dans la plupart des applications Web est la <code>delete</code> - pourquoi ne pas donner à l'utilisateur une rétroaction instantanée si nous avons déjà toutes les informations nécessaires? <br><br>  Déconnecter notre application du réseau en utilisant une approche optimiste est relativement facile à mettre en œuvre. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_FAILURE; list = [...state.list]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list[i].id === action.payload.id) { list.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>, action.payload); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, };</code> </pre> <br>  La clé est de gérer les actions des utilisateurs de la même manière, que la requête réseau aboutisse ou non.  L'extrait de code ci-dessus est tiré du réducteur redux de notre application, <code>SUCCESS</code> et <code>FAILURE</code> lancés en fonction de la disponibilité du réseau.  Quelle que soit la manière dont la demande de réseau est traitée, nous allons mettre à jour notre liste de livres. <br><br><h3>  Démo numéro 3 </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/815/892/dd9/815892dd9fc0bbcb431c147f187c528e.gif" alt="image"><br><br>  L'interaction des utilisateurs se produit désormais en ligne (pas littéralement).  Les boutons «check-in» et «check-out» mettent à jour l'interface en conséquence, bien que les messages rouges de la console indiquent que les requêtes réseau ne sont pas exécutées. <br><br>  Bon!  Il n'y a qu'un petit problème avec le rendu hors ligne optimiste ... <br><br>  Ne perdons-nous pas notre monnaie!? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/843/120/624/843120624bca4393f215511f3402a767.png" alt="image"><br><br><h3>  Tâche 4 - Mettre en file d'attente les actions des utilisateurs pour la synchronisation </h3><br>  Nous devons suivre les actions effectuées par l'utilisateur lorsqu'il était hors ligne, afin de pouvoir les synchroniser avec notre serveur lorsque l'utilisateur revient sur le réseau.  Il existe plusieurs mécanismes de stockage dans le navigateur qui peuvent agir comme une file d'attente d'actions, et nous allons utiliser IndexedDB.  IndexedDB fournit quelques éléments que vous n'obtiendrez pas de LocalStorage: <br><br><ul><li>  Opérations non bloquantes asynchrones </li><li>  Limites de stockage considérablement plus élevées </li><li>  Gestion des transactions </li></ul><br>  Regardez notre ancien code de réduction: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_SUCCESS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_IN_FAILURE; list = [...state.list]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; list.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list[i].id === action.payload.id) { list.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>, action.payload); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, list, };</code> </pre> <br>  Modifions-le pour stocker les événements d'archivage et d'extraction dans IndexedDB pendant l'événement <code>FAILURE</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CHECK_OUT_FAILURE: list = [...state.list]; list.push(action.payload); addToDB(action); <span class="hljs-comment"><span class="hljs-comment">// QUEUE IT UP return { ...state, list, }; case CHECK_IN_FAILURE; list = [...state.list]; for (let i = 0; i &lt; list.length; i++) { if (list[i].id === action.payload.id) { list.splice(i, 1, action.payload); addToDB(action); // QUEUE IT UP } } return { ...state, list, };</span></span></code> </pre> <br>  Voici l'implémentation de la création d'IndexedDB avec l' <code>addToDB</code> addToDB. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onupgradeneeded = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = event.target.result; db.createObjectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">autoIncrement</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addToDB = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objStore = db .transaction([<span class="hljs-string"><span class="hljs-string">'requests'</span></span>], <span class="hljs-string"><span class="hljs-string">'readwrite'</span></span>) .objectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>); objStore.add(action); }; };</code> </pre> <br>  Maintenant que toutes nos actions utilisateur hors ligne sont stockées dans la mémoire du navigateur, nous pouvons utiliser l'écouteur d'événements du navigateur en <code>online</code> pour synchroniser les données lorsque la connexion est rétablie. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'online'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> db = indexedDB.open(<span class="hljs-string"><span class="hljs-string">'actions'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); db.onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> objStore = db .transaction([<span class="hljs-string"><span class="hljs-string">'requests'</span></span>], <span class="hljs-string"><span class="hljs-string">'readwrite'</span></span>) .objectStore(<span class="hljs-string"><span class="hljs-string">'requests'</span></span>); objStore.getAll().onsuccess = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> requests = event.target.result; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> requests) { send(request); <span class="hljs-comment"><span class="hljs-comment">// sync with the server } }; }; });</span></span></code> </pre> <br>  À ce stade, nous pouvons effacer la file d'attente de toutes les demandes que nous avons envoyées avec succès au serveur. <br><br><h3>  Démo numéro 4 </h3><br>  La démo finale semble un peu plus compliquée.  À droite, dans la fenêtre sombre du terminal, toute l'activité de l'API est enregistrée.  La démo implique de se déconnecter, de sélectionner plusieurs livres et de revenir en ligne. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebc/3a2/29d/ebc3a229d1507a5e59bb35fcca475241.gif" alt="image"><br><br>  Il est clair que les demandes effectuées hors ligne ont été mises en file d'attente et envoyées immédiatement lorsque l'utilisateur revient en ligne. <br><br>  Cette approche de «jeu» est un peu naïve - par exemple, nous n’aurons probablement pas besoin de faire deux demandes si nous prenons et retournons le même livre.  Cela ne fonctionnera pas non plus si plusieurs personnes utilisent la même application. <br><br><h3>  C'est tout </h3><br>  Sortez et mettez vos applications Web hors ligne!  Cet article montre certaines des nombreuses choses que vous pouvez faire pour ajouter des fonctionnalités autonomes à vos applications et n'est certainement pas exhaustif. <br>  Pour en savoir plus, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les principes de base de Google Web</a> .  Pour voir une autre implémentation hors ligne, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette présentation</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img align="right" width="404" height="150" src="https://habrastorage.org/webt/2b/9i/gm/2b9igmgpbxunecpetjj6hhqsa9m.png"></a> <br clear="left"><h4>  Lisez aussi le blog <br>  Société EDISON: </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>20 bibliothèques pour</b></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b><br></b></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b>application iOS spectaculaire</b></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474374/">https://habr.com/ru/post/fr474374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474364/index.html">Développement électronique. Un examen subjectif des capteurs intégrés les plus utiles</a></li>
<li><a href="../fr474366/index.html">Événements numériques à Moscou du 4 au 10 novembre</a></li>
<li><a href="../fr474368/index.html">Synopsis sur l'apprentissage automatique. Théorie des probabilités. Formule Bayes</a></li>
<li><a href="../fr474370/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 387 (28 octobre - 3 novembre 2019)</a></li>
<li><a href="../fr474372/index.html">Balance numérique</a></li>
<li><a href="../fr474378/index.html">Graphiques de dessin et de mise à jour sans bloc avec bokeh</a></li>
<li><a href="../fr474380/index.html">PHP Digest n ° 167 (22 octobre - 4 novembre 2019)</a></li>
<li><a href="../fr474382/index.html">Le film "Project 'Hummingbird'" en termes d'histoire, de technologie et de finance</a></li>
<li><a href="../fr474386/index.html">L'expérience de Microsoft pour réduire la semaine de travail à 4 jours a entraîné une augmentation de 40% de la productivité</a></li>
<li><a href="../fr474388/index.html">Tout le monde brûle avec efficacité</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>