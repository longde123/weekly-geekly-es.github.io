<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦗 🛠️ 🙎🏾 Pelatihan penguatan PyBullet 👩‍✈️ 👨‍❤️‍💋‍👨 🔁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak orang yang mempelajari pembelajaran mesin akrab dengan proyek OpenAI, salah satu pendiri di antaranya adalah Elon Musk, dan menggunakan platfor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelatihan penguatan PyBullet</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420897/"><img src="https://habrastorage.org/webt/0g/x5/ai/0gx5aizowrlyrgkvekcxlxh9pge.png" alt="gambar"><br><br>  Banyak orang yang mempelajari pembelajaran mesin akrab dengan proyek OpenAI, salah satu pendiri di antaranya adalah Elon Musk, dan menggunakan platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenAI Gym</a> sebagai media untuk melatih model jaringan saraf mereka. <br><br>  Gym berisi serangkaian besar lingkungan, beberapa di antaranya adalah berbagai jenis simulasi fisik: gerakan hewan, manusia, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">robot</a> .  Simulasi ini didasarkan pada mesin fisika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MuJoCo</a> , yang gratis untuk tujuan pendidikan dan ilmiah. <br><br>  Pada artikel ini, kita akan membuat simulasi fisik yang sangat sederhana mirip dengan lingkungan OpenAI Gym, tetapi didasarkan pada Bullet engine fisika gratis ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyBullet</a> ).  Dan juga membuat agen untuk bekerja dengan lingkungan ini. <br><a name="habracut"></a><br>  PyBullet adalah modul python untuk menciptakan lingkungan simulasi fisik berdasarkan pada mesin fisika <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fisika Bullet</a> .  Itu, seperti MuJoCo, sering digunakan sebagai stimulasi berbagai robot, yang tertarik pada habr ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> dengan contoh nyata. <br><br>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QuickStartGuide yang</a> cukup bagus untuk PyBullet yang berisi tautan ke contoh di halaman sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  PyBullet memungkinkan Anda memuat model yang sudah dibuat dalam format URDF, SDF atau MJCF.  Dalam sumber ada perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model</a> dalam format ini, serta lingkungan simulator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">robot asli yang</a> benar-benar siap pakai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> <br><br>  Dalam kasus kami, kami sendiri akan menciptakan lingkungan menggunakan PyBullet.  Antarmuka lingkungan akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mirip dengan</a> antarmuka OpenAI Gym.  Dengan cara ini kami dapat melatih agen kami baik di lingkungan kami maupun di lingkungan Gym. <br><br>  Semua kode (iPython), serta pengoperasian program dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google Colaboratory</a> . <br><br><h2>  Lingkungan </h2><br>  Lingkungan kita akan terdiri dari bola yang dapat bergerak di sepanjang sumbu vertikal dalam rentang ketinggian tertentu.  Bola memiliki massa, dan gravitasi bekerja di atasnya, dan agen harus, mengendalikan gaya vertikal yang diterapkan pada bola, membawanya ke target.  Ketinggian target berubah dengan setiap restart pengalaman. <br><br><img src="https://habrastorage.org/webt/w-/wy/jr/w-wyjrj1zphr8aqndhutrnno1po.png" alt="gambar"><br><br>  Simulasi sangat sederhana, dan sebenarnya dapat dianggap sebagai simulasi dari beberapa penggerak dasar. <br><br>  Untuk bekerja dengan lingkungan, 3 metode digunakan: <i><b>reset</b></i> (memulai kembali eksperimen dan membuat semua objek lingkungan), <i><b>langkah</b></i> (menerapkan tindakan yang dipilih dan memperoleh keadaan lingkungan yang dihasilkan), <i><b>render</b></i> (tampilan visual lingkungan). <br><br>  Saat menginisialisasi lingkungan, kita perlu menghubungkan objek kita ke simulasi fisik.  Ada 2 opsi koneksi: dengan antarmuka grafis (GUI) dan tanpa (LANGSUNG) .Dalam kasus kami, itu LANGSUNG. <br><br><pre><code class="python hljs">pb.connect(pb.DIRECT)</code> </pre> <br><h4>  atur ulang </h4><br>  Dengan setiap percobaan baru, kami mereset simulasi <i>pb.resetSimulation ()</i> dan membuat semua objek lingkungan lagi. <br><br>  Dalam PyBullet, objek memiliki 2 bentuk: bentuk tabrakan, dan <i>bentuk visual</i> .  Yang pertama digunakan oleh mesin fisik untuk menghitung tumbukan benda dan, untuk mempercepat perhitungan fisika, biasanya memiliki bentuk yang lebih sederhana daripada benda nyata.  Yang kedua adalah opsional, dan hanya digunakan saat membentuk gambar objek. <br><br>  Bentuk dikumpulkan dalam satu objek (tubuh) - <i>MultiBody</i> .  Tubuh dapat terdiri dari satu bentuk (pasangan <i>CollisionShape / Bentuk Visual</i> ), seperti dalam kasus kami, atau beberapa. <br><br>  Selain bentuk-bentuk yang membentuk tubuh, perlu untuk menentukan massa, posisi dan orientasinya di ruang angkasa. <br><br><div class="spoiler">  <b class="spoiler_title">Beberapa kata tentang badan multi-objek.</b> <div class="spoiler_text">  Sebagai aturan, dalam kasus nyata, untuk mensimulasikan berbagai mekanisme, badan yang terdiri dari banyak bentuk digunakan.  Saat membuat tubuh, selain bentuk dasar tabrakan dan visualisasi, tubuh ditransfer rantai bentuk benda anak ( <i>Tautan</i> ), posisi dan orientasinya relatif terhadap objek sebelumnya, serta jenis koneksi (sambungan) benda di antara mereka sendiri (Sambungan).  Jenis koneksi dapat diperbaiki, prismatik (meluncur pada poros yang sama) atau rotasi (berputar pada satu poros).  2 jenis koneksi terakhir memungkinkan Anda untuk mengatur parameter dari jenis motor yang sesuai ( <i>JointMotor</i> ), seperti gaya akting, kecepatan atau torsi, sehingga mensimulasikan motor dari "sambungan" robot.  Lebih detail dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br></div></div><br>  Kami akan membuat 3 tubuh: Bola, Pesawat (Bumi) dan Pointer Target.  Objek terakhir hanya akan memiliki bentuk visualisasi dan nol massa, karena itu ia tidak akan berpartisipasi dalam interaksi fisik antara tubuh: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  floorColShape = pb.createCollisionShape(pb.GEOM_PLANE) #   (GEOM_PLANE), visualShape -    ,   GEOM_BOX floorVisualShapeId = pb.createVisualShape(pb.GEOM_BOX,halfExtents=[100,100,0.0001], rgbaColor=[1,1,.98,1]) pb_floorId = pb.createMultiBody(0,floorColShape,floorVisualShapeId, [0,0,0], [0,0,0,1]) #  PB_BallRadius = 0.2 PB_BallMass = 1 ballPosition = [0,0,5] ballOrientation=[0,0,0,1] ballColShape = pb.createCollisionShape(pb.GEOM_SPHERE,radius=PB_BallRadius) ballVisualShapeId = pb.createVisualShape(pb.GEOM_SPHERE,radius=PB_BallRadius, rgbaColor=[1,0.27,0,1]) pb_ballId = pb.createMultiBody(PB_BallMass, ballColShape, ballVisualShapeId, ballPosition, ballOrientation) #   TARGET_Z = 8 targetPosition = [0,0,TARGET_Z] targetOrientation=[0,0,0,1] targetVisualShapeId = pb.createVisualShape(pb.GEOM_BOX,halfExtents=[1,0.025,0.025], rgbaColor=[0,0,0,1]) pb_targetId = pb.createMultiBody(0,-1, targetVisualShapeId, targetPosition, targetOrientation)</span></span></code> </pre><br>  Tentukan gravitasi dan waktu langkah simulasi. <br><br><pre> <code class="python hljs">pb.setGravity(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-10</span></span>) pb.setTimeStep(<span class="hljs-number"><span class="hljs-number">1.</span></span>/<span class="hljs-number"><span class="hljs-number">60</span></span>)</code> </pre> <br>  Untuk mencegah bola jatuh segera setelah memulai simulasi, kami menyeimbangkan gravitasi. <br><br><pre> <code class="python hljs">pb_force = <span class="hljs-number"><span class="hljs-number">10</span></span> * PB_BallMass pb.applyExternalForce(pb_ballId, <span class="hljs-number"><span class="hljs-number">-1</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,pb_force], [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], pb.LINK_FRAME)</code> </pre> <br><br><h4>  langkah </h4><br>  Agen memilih tindakan berdasarkan kondisi lingkungan saat ini, setelah itu memanggil metode <i>langkah</i> dan menerima keadaan baru. <br><br>  2 jenis aksi didefinisikan: menambah dan mengurangi gaya yang bekerja pada bola.  Batas kekuatan terbatas. <br><br>  Setelah mengubah gaya yang bekerja pada bola, langkah baru simulasi fisik <i>pb.stepSimulation () diluncurkan</i> , dan parameter berikut dikembalikan ke agen: <br><br>  <i>observasi</i> - pengamatan (keadaan lingkungan) <br>  <i>hadiah</i> - hadiah untuk tindakan sempurna <br>  <i>dilakukan</i> - bendera akhir dari pengalaman <br>  <i>info</i> - informasi tambahan <br><br>  Sebagai keadaan lingkungan, 3 nilai dikembalikan: jarak ke target, gaya saat ini diterapkan pada bola, dan kecepatan bola.  Nilai-nilai dikembalikan normal (0..1), karena parameter lingkungan yang menentukan nilai-nilai ini dapat bervariasi tergantung pada keinginan kita. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     (     Z curPos[2]) curPos, curOrient = pb.getBasePositionAndOrientation(pb_ballId) #     (      Z lin_vel[2]) lin_vel, ang_vel= pb.getBaseVelocity(self.pb_ballId)</span></span></code> </pre> <br>  Hadiah untuk tindakan sempurna adalah 1 jika bola dekat dengan target (tinggi target plus / minus nilai bergulir yang dapat diterima <i>TARGET_DELTA</i> ) dan 0 dalam kasus lain. <br>  Eksperimen selesai jika bola keluar zona (jatuh ke tanah atau terbang tinggi).  Jika bola mencapai tujuan, percobaan juga berakhir, tetapi hanya setelah waktu tertentu ( <i>STEPS_AFTER_TARGET</i> langkah-langkah percobaan).  Dengan demikian, agen kami dilatih tidak hanya untuk bergerak menuju tujuan, tetapi juga untuk berhenti dan dekat dengannya.  Mengingat bahwa hadiah saat Anda hampir mencapai tujuan adalah 1, pengalaman yang sepenuhnya berhasil harus memiliki total hadiah yang setara dengan <i>STEPS_AFTER_TARGET</i> . <br><br>  Sebagai informasi tambahan untuk menampilkan statistik, jumlah langkah yang dilakukan dalam percobaan, serta jumlah langkah yang dilakukan per detik, dikembalikan. <br><br><h4>  membuat </h4><br>  PyBullet memiliki 2 opsi rendering gambar - rendering GPU berbasis OpenGL dan CPU berbasis TinyRenderer.  Dalam kasus kami, hanya implementasi CPU yang dimungkinkan. <br><br>  Untuk mendapatkan kerangka simulasi saat ini, perlu untuk menentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks spesies</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">matriks proyeksi</a> , dan kemudian mendapatkan gambar <i>rgb</i> dari ukuran yang diberikan dari kamera. <br><br><pre> <code class="python hljs">camTargetPos = [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   ()  camDistance = 10 #     yaw = 0 #     pitch = 0 #     roll=0 #      upAxisIndex = 2 #    (z) fov = 60 #    nearPlane = 0.01 #      farPlane = 20 #      pixelWidth = 320 #   pixelHeight = 200 #   aspect = pixelWidth/pixelHeight; #    #   viewMatrix = pb.computeViewMatrixFromYawPitchRoll(camTargetPos, camDistance, yaw, pitch, roll, upAxisIndex) #   projectionMatrix = pb.computeProjectionMatrixFOV(fov, aspect, nearPlane, farPlane); #     img_arr = pb.getCameraImage(pixelWidth, pixelHeight, viewMatrix, projectionMatrix, shadow=0, lightDirection=[0,1,1],renderer=pb.ER_TINY_RENDERER) w=img_arr[0] #width of the image, in pixels h=img_arr[1] #height of the image, in pixels rgb=img_arr[2] #color data RGB dep=img_arr[3] #depth data</span></span></code> </pre> <br>  Di akhir setiap percobaan, video dihasilkan berdasarkan gambar yang dikumpulkan. <br><br><pre> <code class="python hljs">ani = animation.ArtistAnimation(plt.gcf(), render_imgs, interval=<span class="hljs-number"><span class="hljs-number">10</span></span>, blit=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,repeat_delay=<span class="hljs-number"><span class="hljs-number">1000</span></span>) display(HTML(ani.to_html5_video()))</code> </pre><br><h2>  Agen </h2><br>  Kode pengguna <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jaara</a> GitHub diambil sebagai dasar untuk Agen, sebagai contoh sederhana dan dapat dipahami untuk menerapkan pelatihan penguatan untuk lingkungan Gym. <br><br>  Agen berisi 2 objek: <i>Memori</i> - penyimpanan untuk pembentukan contoh pelatihan dan <i>Otak sendiri adalah</i> jaringan saraf yang ia latih. <br><br>  Jaringan saraf terlatih dibuat di TensorFlow menggunakan perpustakaan Keras, yang baru-baru ini sepenuhnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dimasukkan</a> dalam TensorFlow. <br>  Jaringan saraf memiliki struktur sederhana - 3 lapisan, yaitu  Hanya 1 lapisan tersembunyi. <br><br>  Lapisan pertama berisi 512 neuron dan memiliki jumlah input yang sama dengan jumlah parameter keadaan medium (3 parameter: jarak ke target, kekuatan dan kecepatan bola).  Lapisan tersembunyi memiliki dimensi yang sama dengan lapisan pertama - 512 neuron, pada keluaran itu terhubung ke lapisan keluaran.  Jumlah neuron dari lapisan output sesuai dengan jumlah tindakan yang dilakukan oleh Agen (2 tindakan: mengurangi dan meningkatkan kekuatan akting). <br><br>  Dengan demikian, keadaan sistem dipasok ke input jaringan, dan pada output kami memiliki manfaat untuk setiap tindakan. <br><br>  Untuk dua lapisan pertama, <i>ReLU</i> (unit linear yang diperbaiki) digunakan sebagai fungsi aktivasi, untuk yang terakhir - <i>fungsi linier</i> (jumlah nilai input sederhana). <br>  Sebagai fungsi kesalahan, <i>MSE</i> (standard error), sebagai algoritma pengoptimalan - <i>RMSprop</i> (Root Mean Square Propagation). <br><br><pre> <code class="python hljs">model = Sequential() model.add(Dense(units=<span class="hljs-number"><span class="hljs-number">512</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, input_dim=<span class="hljs-number"><span class="hljs-number">3</span></span>)) model.add(Dense(units=<span class="hljs-number"><span class="hljs-number">512</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)) model.add(Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'linear'</span></span>)) opt = RMSprop(lr=<span class="hljs-number"><span class="hljs-number">0.00025</span></span>) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mse'</span></span>, optimizer=opt)</code> </pre><br>  Setelah setiap langkah simulasi, Agen menyimpan hasil langkah ini dalam bentuk daftar <i>(s, a, r, s_)</i> : <br>  <i>s</i> - pengamatan sebelumnya (keadaan lingkungan) <br>  <i>a</i> - tindakan yang selesai <br>  <i>r</i> - hadiah yang diterima untuk tindakan yang dilakukan <br>  <i>s_</i> - pengamatan akhir setelah aksi <br><br>  Setelah itu, Agen menerima dari memori serangkaian contoh acak untuk periode sebelumnya dan membentuk paket pelatihan ( <i>batch</i> ). <br><br>  Keadaan awal <i>s</i> dari langkah-langkah acak yang dipilih dari memori diambil sebagai nilai input ( <i>X</i> ) dari paket. <br><br>  Nilai aktual dari output pembelajaran ( <i>Y '</i> ) dihitung sebagai berikut: Pada output ( <i>Y</i> ) dari jaringan saraf untuk s akan ada nilai-nilai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi-Q</a> untuk setiap tindakan <i>Q (s)</i> .  Dari set ini, agen memilih tindakan dengan nilai <i>Q (s, a) = MAX (Q (s)) tertinggi</i> , menyelesaikannya dan menerima penghargaan <i>r</i> .  Nilai <i>Q</i> baru untuk tindakan yang dipilih <i>a</i> adalah <i>Q (s, a) = Q (s, a) + DF * r</i> , di mana <i>DF</i> adalah faktor diskon.  Nilai output yang tersisa akan tetap sama. <br><br><pre> <code class="python hljs">STATE_CNT = <span class="hljs-number"><span class="hljs-number">3</span></span> ACTION_CNT = <span class="hljs-number"><span class="hljs-number">2</span></span> batchLen = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-comment"><span class="hljs-comment">#     states = numpy.array([ o[0] for o in batch ]) #     states_ = numpy.array([ o[3] for o in batch ]) #     p = agent.brain.predict(states) #     p_ = agent.brain.predict(states_) #     x = numpy.zeros((batchLen, STATE_CNT)) y = numpy.zeros((batchLen, ACTION_CNT)) #   for i in range(batchLen): o = batch[i] s = o[0]; a = o[1]; r = o[2]; s_ = o[3] t = p[i] #      #      ,       t[a] = r + GAMMA * numpy.amax(p_[i]) #            #    batch x[i] = s y[i] = t #      self.brain.train(x, y)</span></span></code> </pre> <br>  Pelatihan jaringan terjadi pada paket yang dibentuk <br><br><pre> <code class="python hljs">self.model.fit(x, y, batch_size=<span class="hljs-number"><span class="hljs-number">32</span></span>, epochs=<span class="hljs-number"><span class="hljs-number">1</span></span>, verbose=<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Setelah percobaan selesai, video dihasilkan <br><br><img src="https://habrastorage.org/webt/om/ox/rk/omoxrkmnrigllf9hu_8x9ofbd7m.gif" alt="gambar"><br><br>  dan statistik ditampilkan <br><br><img src="https://habrastorage.org/webt/0s/ed/p2/0sedp2zvwqmiiku6emmhp2yxf7m.png" alt="gambar"><br><br>  Agen tersebut membutuhkan 1.200 percobaan untuk mencapai hasil sekitar 95 persen (jumlah langkah sukses).  Dan dengan percobaan ke-50, Agen telah belajar untuk memindahkan bola ke target (percobaan yang gagal hilang). <br><br>  Untuk meningkatkan hasil, Anda dapat mencoba mengubah ukuran lapisan jaringan (LAYER_SIZE), parameter faktor diskon (GAMMA) atau tingkat penurunan dalam probabilitas memilih tindakan acak (LAMBDA). <br><br>  Agen kami memiliki arsitektur paling sederhana - DQN (Deep Q-Network).  Pada tugas sederhana seperti itu, cukup untuk mendapatkan hasil yang dapat diterima. <br><br>  Menggunakan, misalnya, arsitektur DDQN (Double DQN) harus memberikan pelatihan yang lebih halus dan lebih akurat.  Dan jaringan RDQN (DQN Berulang) akan dapat melacak pola perubahan lingkungan dari waktu ke waktu, yang akan memungkinkan untuk menyingkirkan parameter kecepatan bola, mengurangi jumlah parameter input jaringan. <br><br>  Anda juga dapat memperluas simulasi kami dengan menambahkan massa bola variabel atau sudut kemiringan gerakannya. <br><br>  Tapi ini waktu berikutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420897/">https://habr.com/ru/post/id420897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420887/index.html">Laporan Hackathon Tele2</a></li>
<li><a href="../id420889/index.html">Teknologi Deteksi Tambang Militer Membantu Robomobiles Menavigasi Semua Jalan</a></li>
<li><a href="../id420891/index.html">Migrasi ke JUnit 5 dalam 10 menit. Mengukur waktu tes dengan Ekstensi</a></li>
<li><a href="../id420893/index.html">Kemasan Waralaba A hingga B</a></li>
<li><a href="../id420895/index.html">Bagaimana saya menghidupkan kembali perangkat (JTAG-emulator BH-USB-560v2) melalui U-Boot</a></li>
<li><a href="../id420901/index.html">Bagaimana saya mempelajari kerangka kerja Spring (bantuan untuk pemula adalah karya pemula sendiri)</a></li>
<li><a href="../id420903/index.html">Implementasi ERP: bagaimana tidak gagal</a></li>
<li><a href="../id420905/index.html">Bagaimana pencahayaan pintar diperkenalkan di Rusia dan berapa lama waktu yang dibutuhkan</a></li>
<li><a href="../id420907/index.html">Dari NOKLA ke Xiaomi: evolusi ponsel Cina</a></li>
<li><a href="../id420909/index.html">Perusahaan TV Rusia menuduh Yandex pembajakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>