<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑ üëú üéß Elixir como objetivo de desarrollo para python async üë©‚ÄçüöÄ ü•° üêï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el libro "Python. A las alturas de la excelencia ‚ÄùLuciano Ramallo describe una historia. En 2000, Luciano tom√≥ cursos, y una vez Guido van Rossum m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elixir como objetivo de desarrollo para python async</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476112/">  En el libro "Python.  A las alturas de la excelencia ‚ÄùLuciano Ramallo describe una historia.  En 2000, Luciano tom√≥ cursos, y una vez Guido van Rossum mir√≥ a la audiencia.  Una vez que tal evento apareci√≥, todos comenzaron a hacerle preguntas.  Cuando se le pregunt√≥ acerca de las funciones que Python tom√≥ prestadas de otros idiomas, Guido respondi√≥: "Todo lo que es bueno en Python es robado de otros idiomas". <br><br>  Realmente lo es  Python ha vivido durante mucho tiempo en el contexto de otros lenguajes de programaci√≥n y absorbe conceptos de su entorno: asyncio es prestado, gracias a las expresiones lambda de Lisp aparecieron, y Tornado fue copiado de libevent.  Pero si alguien toma prestadas ideas, es de Erlang.  Fue creado hace 30 a√±os, y todos los conceptos en Python que se est√°n implementando actualmente o que se acaban de describir han funcionado durante mucho tiempo en Erlang: mensajes de m√∫ltiples n√∫cleos como base de comunicaci√≥n, llamadas a m√©todos e introspecci√≥n dentro de un sistema de producci√≥n en vivo.  Estas ideas, de una forma u otra, encuentran su expresi√≥n en sistemas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Seastar.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/0x/mf/fb0xmfg8afpsrhs7js423v4bvjy.jpeg" width="500"></div><br>  Si no tiene en cuenta Data Science, en el que Python ahora est√° fuera de competencia, entonces todo lo dem√°s ya est√° implementado en Erlang: trabajar con una red, manejar HTTP y sockets web, trabajar con bases de datos.  Por lo tanto, es importante que los desarrolladores de Python entiendan hacia d√≥nde se mover√° el lenguaje: a lo largo de un camino que ya ha pasado hace 30 a√±os. <br><br>  Para comprender la historia del desarrollo de otros lenguajes y comprender d√≥nde progresa el progreso, invitamos a <strong>Maxim Lapshin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">erlyvideo</a> ), el autor del proyecto Erlyvideo.ru, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Moscow Python Conf ++</a> . <br><br>  Debajo del corte est√° la versi√≥n de texto de este informe, a saber: en qu√© direcci√≥n se ve obligado a desarrollarse el sistema, que contin√∫a migrando de un c√≥digo lineal simple a liberante y m√°s all√°, lo cual es com√∫n y cu√°les son las diferencias entre Elixir y Python.  Prestaremos especial atenci√≥n a c√≥mo administrar sockets, hilos y datos en diferentes lenguajes y plataformas de programaci√≥n. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RAZ0sHpPrZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Erlyvideo.ru tiene un sistema de video vigilancia en el que el control de acceso para c√°maras est√° escrito en Python.  Esta es una tarea cl√°sica para este idioma.  Hay usuarios y c√°maras, videos desde los cuales pueden mirar: alguien ve algunas c√°maras, mientras que otros ven un sitio normal. <br><br>  Se eligi√≥ Python porque es conveniente escribir un servicio de este tipo en √©l: despu√©s de todo, hay marcos, ORM, programadores.  El software desarrollado se empaqueta y se vende a los usuarios.  Erlyvideo.ru es una empresa que vende software y no solo brinda servicio. <br><br>  Qu√© problemas con Python quiero resolver. <br><br>  <strong>¬øPor qu√© hay tales problemas con multin√∫cleo?</strong>  Ejecutamos Flussonic en computadoras de estadios incluso antes que Intel.  Pero Python tiene dificultades con esto: ¬øpor qu√© sigue sin utilizar los 80 n√∫cleos de nuestros servidores para trabajar? <br><br>  <strong>¬øC√≥mo no sufrir de enchufes abiertos?</strong>  Monitorear el n√∫mero de tomas abiertas es un gran problema.  Cuando llegue al l√≠mite, cierre y evite las fugas tambi√©n. <br><br>  <strong>¬øLas variables globales olvidadas tienen soluci√≥n?</strong>  La filtraci√≥n de variables globales es un infierno para cualquier lenguaje de recolecci√≥n de basura como Java o C #. <br><br>  <strong>¬øC√≥mo usar el hierro sin desperdiciar recursos?</strong>  ¬øC√≥mo sobrevivir sin ejecutar 40 trabajadores de Jung y 64 GB de RAM si queremos usar servidores de manera eficiente y no arrojar cientos de miles de d√≥lares al mes en hardware innecesario? <br><br><h3>  Por qu√© se necesita multin√∫cleo </h3><br>  <strong>Para que todos los n√∫cleos se utilicen por completo,</strong> se necesitan muchos m√°s trabajadores que n√∫cleos.  Por ejemplo, para 40 n√∫cleos de procesador, se necesitan 100 trabajadores: un trabajador fue a la base de datos, el otro est√° ocupado con otra cosa. <br><br>  <strong>Un trabajador puede consumir 300-400 MB</strong> .  Todav√≠a estamos escribiendo esto en Python, y no en Ruby on Rails, que puede consumir varias veces m√°s y 40 GB de RAM se desperdiciar√°n f√°cil y f√°cilmente.  No es muy caro, pero ¬øpor qu√© comprar memoria donde no se puede comprar? <br><br>  <strong>Multi-core ayuda a buscar datos compartidos y reducir el consumo de memoria</strong> , ejecutar convenientemente y con seguridad muchos procesos independientes.  Es mucho m√°s f√°cil de programar, pero m√°s caro desde la memoria. <br><br><h3>  Gesti√≥n de enchufes </h3><br>  En el socket web, sondeamos los datos de tiempo de ejecuci√≥n de las c√°maras desde el backend.  El software Python se conecta a Flussonic y sondea los datos de estado de las c√°maras: si funcionan o no, ¬øhay alg√∫n evento nuevo? <br><br>  Por otro lado, el cliente se conecta y, a trav√©s del socket web, enviamos estos datos al navegador.  Queremos transferir los datos del cliente en tiempo real: la c√°mara se encendi√≥ y apag√≥, el gato comi√≥, durmi√≥, rompi√≥ un sof√°, presion√≥ el bot√≥n y se llev√≥ al gato. <br><br>  Pero, por ejemplo, se produjo alg√∫n tipo de problema: la base de datos no respondi√≥ a la solicitud, todo el c√≥digo se cay√≥, hab√≠a dos z√≥calos abiertos.  Comenzamos a recargar, hicimos algo, nuevamente este problema: hab√≠a dos enchufes.  El error de la base de datos se proces√≥ incorrectamente y se bloquearon dos conexiones abiertas.  Con el tiempo, esto conduce a fugas en el z√≥calo. <br><br><h3>  Variables globales olvidadas </h3><br>  Hizo un dict global para la lista de navegadores conectados a trav√©s del socket web.  Una persona inicia sesi√≥n en el sitio, abrimos un socket web para √©l.  Luego colocamos el socket web con su identificador en alg√∫n tipo de dict global, y resulta que se produce alg√∫n tipo de error. <br><br>  Por ejemplo, grabaron un enlace de conexi√≥n en dict para enviar datos.  <strong>Una excepci√≥n funcion√≥, olvid√© eliminar el enlace y los datos se colgaron</strong> .  Entonces, despu√©s de alg√∫n tiempo, se comienzan a perder 64 GB, y quiero duplicar la memoria en el servidor.  Esto no es una soluci√≥n, porque los datos se filtrar√°n de todos modos. <br><blockquote>  Siempre cometemos errores: somos personas y no podemos hacer un seguimiento de todo. </blockquote>  La pregunta es que ocurren algunos errores, incluso aquellos que no esper√°bamos ver. <br><br><h2>  Excursi√≥n hist√≥rica </h2><br>  Para llegar al tema principal, profundicemos en la historia.  De todo lo que estamos hablando sobre Python, Go y Erlang ahora, otras personas hicieron todo esto hace unos 30 a√±os.  Nosotros en Python recorremos un largo camino y llenamos los baches que ya se han superado hace d√©cadas.  El camino se repite de una manera asombrosa. <br><br><h3>  Dos </h3><br>  Primero, pasemos a DOS, est√° m√°s cerca.  Antes de √©l hab√≠a cosas completamente diferentes y no todos est√°n vivos y recuerdan las computadoras antes de DOS. <br><br>  <strong>El programa DOS ocupaba la computadora (casi) exclusivamente</strong> .  Mientras un juego, por ejemplo, se est√° ejecutando, no se ejecuta nada m√°s.  No acceder√° a Internet, todav√≠a no est√° all√≠ y ni siquiera llegar√° a ninguna parte.  Fue triste, pero los recuerdos son c√°lidos, porque est√° asociado con la juventud. <br><br><h3>  Multitarea cooperativa </h3><br>  Como fue realmente doloroso con DOS, aparecieron nuevos desaf√≠os, las computadoras se volvieron m√°s poderosas.  <strong>Hace d√©cadas, desarrollaron el concepto de multitarea cooperativa</strong> , incluso antes de Windows 3.11. <br><br>  <strong>Los datos est√°n separados por procesos, y cada proceso se realiza por separado: de</strong> alguna manera est√°n protegidos entre s√≠.  El c√≥digo incorrecto en un proceso no podr√° estropear el c√≥digo en el navegador (entonces los primeros navegadores ya aparecieron). <br><br>  La siguiente pregunta es: ¬øc√≥mo se distribuir√° el tiempo de computaci√≥n entre los diferentes procesos?  Entonces no era que no hubiera m√°s de un n√∫cleo, un sistema de doble procesador era una rareza.  El esquema era este: mientras que un proceso fue, por ejemplo, a un disco para datos, el segundo proceso recibe el control del sistema operativo.  El primero podr√° obtener el control cuando el segundo ceda voluntariamente.  Simplifico enormemente la situaci√≥n, pero el <strong>proceso de alguna manera permiti√≥ voluntariamente eliminarlo del procesador</strong> . <br><br><h3>  Multitarea preventiva </h3><br>  La multitarea cooperativa condujo al siguiente problema: el proceso podr√≠a simplemente bloquearse porque est√° mal escrito.  <strong>Si el procesador tarda mucho tiempo en procesarse, bloquea el resto</strong> .  En este caso, la computadora se bloque√≥ y no se pudo hacer nada con ella, por ejemplo, cambiar la ventana. <br><br>  En respuesta a este problema, se invent√≥ la multitarea preventiva.  El sistema operativo ahora se maneja duro: elimina los procesos de la ejecuci√≥n, separa por completo sus datos, protege la memoria del proceso entre s√≠ y les da a todos una cierta cantidad de tiempo computacional.  <strong>El sistema operativo asigna los mismos intervalos de tiempo a cada proceso</strong> . <br><br>  La cuesti√≥n de la p√©rdida de tiempo a√∫n est√° abierta.  Hoy en d√≠a, los desarrolladores de sistemas operativos todav√≠a est√°n pensando qu√© es lo correcto, en qu√© orden, a qui√©n y cu√°nto tiempo dar para la administraci√≥n.  Hoy vemos el desarrollo de estas ideas. <br><br><h3>  Corrientes </h3><br>  Pero esto no fue suficiente.  Los procesos necesitan intercambiar datos: a trav√©s de la red es costoso, de alguna manera a√∫n complicado.  Por lo tanto, se invent√≥ el <strong>concepto de flujos</strong> . <br><blockquote>  Los subprocesos son procesos ligeros que comparten una memoria com√∫n. <br></blockquote>  Las transmisiones se crearon con la esperanza de que todo sea f√°cil, simple y divertido.  Ahora la programaci√≥n <strong>multiproceso se considera antipatr√≥n</strong> .  Si la l√≥gica de negocios est√° escrita en subprocesos, este c√≥digo probablemente deber√≠a descartarse, ya que probablemente haya errores en √©l.  Si le parece que no hay errores, simplemente no los ha encontrado todav√≠a. <br><br>  La programaci√≥n multiproceso es una cosa extremadamente compleja.  Hay pocas personas que realmente se dedicaron a la capacidad de escribir en hilos y obtienen algo que realmente funciona. <br><br>  Mientras tanto, aparecieron <strong>computadoras multin√∫cleo</strong> .  Trajeron cosas terribles con ellos.  Tom√≥ un enfoque completamente diferente a los datos, surgieron preguntas con la localidad de los datos, ahora debe comprender desde qu√© n√∫cleo va a qu√© datos. <br><br>  Un n√∫cleo necesita poner los datos aqu√≠, el otro all√≠, y en ning√∫n caso confundir estas cosas, porque los grupos realmente aparecieron dentro de la computadora.  Dentro de una computadora moderna, hay un cl√∫ster cuando parte de la memoria se suelda a un n√∫cleo y la otra a otro.  El tiempo de tr√°nsito entre estos datos puede variar seg√∫n el orden de magnitud. <br><br><h2>  Ejemplos de Python </h2><br>  Considere un ejemplo simple de "Servicio para ayudar al cliente".  Selecciona el mejor precio para los productos en varias plataformas: manejamos en nombre de los productos y buscamos pisos comerciales con un precio m√≠nimo. <br><br>  Este es el c√≥digo en el antiguo Django, Python 2. Hoy en d√≠a no es muy popular, pocas personas comienzan proyectos en √©l. <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view(['GET']) def best_price(request): name = request.GET['name'] price1 = http_fetch_price('market.yandex.ru', name) price2 = http_fetch_price('ebay.com', name) price3 = http_fetch_price('taobao.com', name) return Response(min([price1,price2,price3]))</span></span></code> </pre> <br>  Llega una solicitud, vamos a un backend y luego a otro.  En los lugares donde se <code>http_fetch_price</code> , los hilos se bloquean.  En este momento, todo el trabajador se embarca en un viaje a Yandex.Market, luego a eBay, luego hasta un tiempo de espera en Taobao, y al final da una respuesta.  <strong>Todo este tiempo todo el trabajador est√° de pie</strong> . <br><br>  Es muy dif√≠cil sondear m√∫ltiples backends al mismo tiempo.  Esta es una mala situaci√≥n: se consume memoria, se requiere el lanzamiento de una gran cantidad de trabajadores y se debe monitorear todo el servicio.  Es necesario observar cu√°n frecuentes son tales solicitudes, si a√∫n necesita ejecutar trabajadores o si hay alguna otra vez m√°s.  Estos son los problemas de los que habl√©.  <strong>Es necesario interrogar varios backends a su vez</strong> . <br><br>  ¬øQu√© vemos en Python?  <strong>Un proceso por tarea,</strong> en Python todav√≠a no hay multin√∫cleo.  La situaci√≥n es clara: en los idiomas de esta clase es dif√≠cil hacer un multin√∫cleo simple y seguro, ya que <strong>matar√° el rendimiento</strong> . <br><br>  Si va al dict desde diferentes flujos, entonces el acceso a los datos se puede escribir de esta manera: pegue dos instancias de Python en la memoria para que puedan revolver los datos, simplemente los rompen.  Por ejemplo, para ir a dictar y no romper nada, debe poner mutexes delante de √©l.  Si hay un mutex antes de cada dict, entonces el sistema se ralentizar√° aproximadamente 1000 veces, simplemente ser√° un inconveniente.  Es dif√≠cil arrastrarlo a un multin√∫cleo. <br><br>  Tenemos <strong>solo un hilo de ejecuci√≥n</strong> y <strong>solo los procesos pueden escalar</strong> .  De hecho, reinventamos DOS dentro del proceso, el lenguaje de secuencias de comandos de 2010.  Dentro del proceso hay una cosa que se parece a DOS: mientras hacemos algo, todos los dem√°s procesos no funcionan.  A nadie le gust√≥ el enorme exceso de costos y la lenta respuesta. <br><br>  <b>Los reactores de socket</b> aparecieron en Python hace alg√∫n tiempo, aunque el concepto en s√≠ naci√≥ hace mucho tiempo.  Ahora puede esperar la disponibilidad de varios enchufes a la vez. <br><br>  Al principio, el reactor tuvo demanda en servidores como nginx.  Incluso debido al uso correcto de esta tecnolog√≠a, se ha vuelto popular.  Luego, el concepto se arrastr√≥ a lenguajes de script como Python y Ruby. <br><blockquote>  La idea del reactor es que pasamos a la programaci√≥n orientada a eventos. </blockquote><br><h2>  Programaci√≥n Orientada a Eventos </h2><br>  Un contexto de ejecuci√≥n produce una solicitud.  Mientras espera una respuesta, se est√° ejecutando un contexto diferente.  Es de destacar que casi pasamos por la misma etapa de evoluci√≥n que la transici√≥n de DOS a Windows 3.11.  Solo las personas hicieron esto 20 a√±os antes, y en Python y Ruby apareci√≥ hace 10 a√±os. <br><br><h3>  Torcido </h3><br>  Este es un marco de red basado en eventos.  Apareci√≥ en 2002 y est√° escrito en Python.  Tom√© el ejemplo anterior y lo reescrib√≠ en Twisted. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_GET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> price1 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) dl = defer.DeferredList([price1,price2,price3]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prices)</span></span></span><span class="hljs-function">:</span></span> request.write(<span class="hljs-string"><span class="hljs-string">'%d'</span></span>.format(min(prices))) request.finish() dl.addCallback(reply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.NOT_DONE_YET</code> </pre> <br>  Puede haber errores, imprecisiones, y el manejo notorio de errores no es suficiente.  Pero el esquema aproximado es este: no hacemos una solicitud, sino que solicitamos que la solicitemos m√°s tarde, cuando haya tiempo.  En la l√≠nea con <code>defer.DeferredList</code> , queremos recopilar las respuestas de varias consultas. <br><br>  De hecho, el c√≥digo consta de dos partes.  En la primera parte, lo que sucedi√≥ antes de la solicitud, y en la segunda, lo que sucedi√≥ despu√©s. <br><blockquote>  Toda la historia de la programaci√≥n orientada a eventos est√° saturada con el dolor de romper el c√≥digo lineal en "antes de la solicitud" y "despu√©s de la solicitud". </blockquote>  Esto duele porque los fragmentos de c√≥digo est√°n mezclados: las √∫ltimas l√≠neas a√∫n se ejecutan en la solicitud original, y la funci√≥n de <code>reply</code> se llamar√° despu√©s. <br><br>  No es f√°cil tenerlo en cuenta precisamente porque rompimos el c√≥digo lineal, pero ten√≠a que hacerse.  Sin entrar en detalles, el c√≥digo que se ha reescrito de Django a Twisted <strong>producir√° una pseudoaceleraci√≥n completamente incre√≠ble</strong> . <br><br><h3>  Idea retorcida </h3><blockquote>  Se puede activar un objeto cuando el z√≥calo est√° listo. </blockquote>  Tomamos objetos en los que recopilamos los datos necesarios del contexto y vinculamos su activaci√≥n al socket.  La disponibilidad de sockets es ahora uno de los controles m√°s importantes para todo el sistema.  Los objetos ser√°n nuestros contextos. <br><br>  Pero al mismo tiempo, el lenguaje a√∫n separa el concepto mismo del contexto de ejecuci√≥n en el que viven las excepciones.  <strong>El contexto de ejecuci√≥n vive separado de los objetos y est√° conectado libremente con ellos</strong> .  Aqu√≠ el problema surge con el hecho de que estamos tratando de recopilar datos dentro de los objetos: no hay manera sin ellos, pero el lenguaje no lo admite. <br><br>  Todo esto lleva a un cl√°sico infierno de devoluci√≥n de llamada.  Por lo que, por ejemplo, aman Node.js: hasta hace poco, no hab√≠a otros m√©todos, pero a√∫n aparec√≠a en Python.  El problema es que hay <strong>saltos de c√≥digo en los puntos del IO externo</strong> que conducen a la devoluci√≥n de llamada. <br><br>  Hay muchas preguntas  ¬øEs posible "pegar" los bordes del espacio en el c√≥digo?  ¬øEs posible volver al c√≥digo humano normal?  ¬øQu√© hacer si un objeto l√≥gico funciona con dos sockets y uno de ellos est√° cerrado?  ¬øC√≥mo no olvidar cerrar el segundo?  ¬øEs posible usar de alguna manera todos los n√∫cleos? <br><br><h3>  Async io </h3><br>  Una buena respuesta a estas preguntas es Async IO.  Este es un gran paso adelante, aunque no f√°cil.  Async IO es una cosa complicada, bajo la cual hay muchos matices dolorosos. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> name = request.GET[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] price1 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) prices = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([price1,price2,price3]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(prices)</code> </pre> <br>  La brecha de c√≥digo est√° oculta bajo la sintaxis <code>async/await</code> .  Tomamos todo lo que era antes, pero no fuimos a la red en este c√≥digo.  Eliminamos <code>Callback(reply)</code> , que estaba en el ejemplo anterior, y lo escondimos detr√°s de la <code>await</code> : el lugar donde se cortar√° el c√≥digo con unas tijeras.  Se dividir√° en dos partes: la parte que llama y la parte de devoluci√≥n de llamada, que procesa los resultados. <br><br>  Este es un <strong>gran az√∫car sint√°ctico</strong> .  Hay m√©todos para pegar m√∫ltiples expectativas en una sola.  Esto es genial, pero hay un matiz: <strong>todo se puede romper con un z√≥calo "cl√°sico"</strong> .  En Python, todav√≠a hay una gran cantidad de bibliotecas que van al socket sincr√≥nicamente, crean una <code>timer library</code> y arruinan todo por ti.  C√≥mo depurar esto, no lo s√©. <br><br>  Pero <strong>asyncio no ayuda con fugas y multin√∫cleo</strong> .  Por lo tanto, no hay cambios fundamentales, aunque ha mejorado. <br><br>  Todav√≠a tenemos todos los problemas de los que hablamos al principio: <br><br><ul><li>  f√°cil de filtrar con enchufes; </li><li>  enlaces f√°ciles de dejar en variables globales; </li><li>  manejo de errores muy minucioso; </li><li>  Todav√≠a es dif√≠cil hacer multi-core. </li></ul><br><h3>  Que hacer </h3><br>  No s√© si todo esto evolucionar√°, pero mostrar√© la implementaci√≥n en otros idiomas y plataformas. <br><br>  <strong>Contextos de ejecuci√≥n aislados.</strong>  En contextos de ejecuci√≥n, los resultados se acumulan, se mantienen los sockets: objetos l√≥gicos en los que generalmente almacenamos todos los datos sobre devoluciones de llamadas y sockets.  Un concepto: tomar contextos de ejecuci√≥n, pegarlos a hilos de ejecuci√≥n y aislarlos completamente unos de otros. <br><br>  <strong>Cambio de paradigma de objetos.</strong>  Conectemos el contexto al hilo de ejecuci√≥n.  Hay an√°logos, esto no es algo nuevo.  Si alguien intent√≥ editar el c√≥digo fuente de Apache y escribirles m√≥dulos, entonces sabe que hay un grupo de Apache.  <strong>No se permiten enlaces</strong> entre los grupos de Apache.  Los datos de un grupo de Apache: el grupo asociado con las solicitudes, se encuentra dentro de √©l, y no puede obtener nada de √©l. <br><br>  Te√≥ricamente es posible, pero si lo hace, o alguien lo rega√±ar√°, o no aceptar√° el parche, o tendr√° una depuraci√≥n larga y dolorosa en la producci√≥n.  Despu√©s de eso, nadie har√° esto y permitir√° que otros hagan tales cosas.  Simplemente es imposible hacer referencia a datos entre contextos, se necesita un aislamiento total. <br><br>  ¬øC√≥mo intercambiar actividad?  Lo que se necesita no son peque√±as m√≥nadas, que est√°n cerradas dentro de s√≠ mismas y no se comunican entre s√≠.  Los necesitamos para comunicarse.  Un enfoque es la mensajer√≠a.  Este es aproximadamente el camino que Windows ha tomado al intercambiar mensajes entre procesos.  En un sistema operativo normal, no puede proporcionar un enlace a la memoria de otro proceso, pero puede enviar se√±ales a trav√©s de la red, como en UNIX, o mediante mensajes, como en Windows. <br><br>  <strong>Todos los recursos dentro del proceso y el contexto se convierten en un hilo de ejecuci√≥n</strong> .  Pegamos juntos: <br><br><ul><li>  datos de tiempo de ejecuci√≥n en una m√°quina virtual en la que se producen excepciones; </li><li>  el hilo de ejecuci√≥n, como lo que se est√° ejecutando en el procesador; </li><li>  Un objeto en el que todos los datos se recopilan l√≥gicamente. </li></ul><br>  ¬°Felicidades, inventamos UNIX dentro de un lenguaje de programaci√≥n!  Esta idea fue inventada alrededor de 1969.  Hasta ahora, todav√≠a no est√° en Python, pero es probable que Python llegue a esto.  Y tal vez ella no venga, no lo s√©. <br><br><h3>  Que da </h3><br>  En primer lugar, <strong>control autom√°tico sobre los recursos</strong> .  En Moscow Python Conf ++ 2019 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dijeron</a> que puedes escribir un programa en Go y procesar todos los errores.  El programa se mantendr√° como un guante y funcionar√° durante meses.  Esto es cierto, pero no manejamos todos los errores. <br><br>  Somos personas vivas, siempre tenemos plazos, el deseo de hacer algo √∫til y no manejar el error 535 por hoy.  El c√≥digo que est√° repleto de manejo de errores nunca causa sentimientos c√°lidos en nadie. <br><br>  Por lo tanto, todos escribimos "camino feliz", y luego lo resolveremos en producci√≥n.  Seamos honestos: solo cuando necesita procesar algo, entonces comenzamos a procesar.  La programaci√≥n defensiva es un poco diferente, y no es un desarrollo comercial. <br><br>  Por lo tanto, <strong>cuando tenemos autocontrol para errores, esto est√° bien</strong> .  Pero los sistemas operativos surgieron hace 50 a√±os: si alg√∫n proceso muere, entonces todo lo que abre se cerrar√° autom√°ticamente.  Hoy nadie necesita escribir c√≥digo que limpiar√° los archivos detr√°s del proceso finalizado.  Esto no ha existido durante 50 a√±os en ning√∫n sistema operativo, pero en Python a√∫n debe seguir esto cuidadosamente y con cuidado con las manos.  Esto es raro <br><br>  <strong>Puede llevar la inform√°tica pesada a un contexto diferente</strong> , pero ya puede ir a otro n√∫cleo.  Compartimos los datos, ya no necesitamos mutexes.  Puede enviar los datos en un contexto diferente, diga: "Lo har√° en alg√∫n lugar y luego av√≠seme que ha terminado y hecho algo". <br><br>  <strong>Una implementaci√≥n asincio sin las palabras "async / await"</strong> .  Adem√°s, un poco de ayuda de la m√°quina virtual, en tiempo de ejecuci√≥n.  Esto es de lo que hablamos con <code>async/await</code> : tambi√©n puede convertir a mensajes, eliminar <code>async/await</code> y obtenerlo a nivel de m√°quina virtual. <br><br><h2>  Procesos Erlang </h2><br>  Erlang fue inventado hace 30 a√±os.  Los barbudos, que no eran muy barbudos entonces, miraron UNIX y transfirieron todos los conceptos al lenguaje de programaci√≥n.  Decidieron que ahora tendr√≠an lo suyo para dormir por la noche e ir a pescar en silencio sin una computadora.  Entonces todav√≠a no hab√≠a computadoras port√°tiles, pero los tipos con barba ya sab√≠an que esto deber√≠a pensarse de antemano. <br><br>  <strong>Tenemos Erlang (Elixir): contextos activos que se ejecutan solos</strong> .  Adem√°s mi ejemplo sobre Erlang.  En Elixir, se ve casi igual, con algunas variaciones. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Name)</span></span></span><span class="hljs-function"> -&gt;</span></span> Price1 = spawn_price_fetcher('market.yandex.ru', Name), Price2 = spawn_price_fetcher('ebay.com', Name), Price3 = spawn_price_fetcher('taobao.com', Name), lists:min(wait4([Price1,Price2,Price3])).</code> </pre> <br>  Lanzamos varios buscadores: estos son varios contextos nuevos que estamos esperando.  Esperaron, recopilaron los datos y devolvieron el resultado como el precio m√≠nimo.  Todo esto es similar a <code>async/await</code> , pero sin las palabras "async / await". <br><br><h3>  Caracter√≠sticas del elixir </h3><br>  Elixir se encuentra en la base de Erlang, y todos los conceptos de lenguaje se transfieren silenciosamente a Elixir.  ¬øCu√°les son sus caracter√≠sticas? <br><br>  <strong>Prohibici√≥n de enlaces entre procesadores.</strong>  Por proceso me refiero a un proceso ligero dentro de una m√°quina virtual: contexto.  Simplificado, si se transfiere a Python, los enlaces de datos dentro de otro objeto est√°n prohibidos en Erlang.  Puede tener un enlace a todo el objeto como un cuadro cerrado, pero no puede hacer referencia a los datos que contiene.  Ni siquiera puede obtener sint√°cticamente un puntero a los datos que est√°n dentro de otro objeto.  Solo puedes saber sobre el objeto en s√≠. <br><br>  <strong>No hay mutexes dentro de los procesos (objetos).</strong>  Esto es importante: personalmente, nunca quiero en mi vida cruzarme con la historia de la depuraci√≥n de vuelos de m√∫ltiples hilos a la producci√≥n.  No le deseo esto a nadie. <br><br>  <strong>Los procesos pueden moverse por los n√∫cleos, es seguro.</strong>  Ya no necesitamos omitir, como en Java, un mont√≥n de otros <code>pointer</code> y reescribirlos al mover datos de un lugar a otro: no tenemos datos comunes y enlaces internos.  Por ejemplo, ¬øde d√≥nde viene el problema de escasez de cadera?  Debido al hecho de que alguien se refiere a estos datos. <br><br>  Si transferimos los datos dentro del mont√≥n a otra ubicaci√≥n para la compactaci√≥n, debemos revisar todo el sistema.  Puede ocupar decenas de gigabytes y actualizar todos los punteros; esto es una locura. <br><br>  <strong>Seguridad total de subprocesos</strong> , debido a que toda la comunicaci√≥n pasa por mensajes.  A la rendici√≥n de todo esto, nos <strong>despojamos del proceso de desplazamiento</strong> .  Lo consigui√≥ f√°cil y barato. <br><br>  <strong>Los mensajes como base de la comunicaci√≥n.</strong>  Objetos internos, llamadas a funciones ordinarias y entre objetos de mensaje.  La llegada de datos de la red es un mensaje, la respuesta de otro objeto es un mensaje, algo m√°s afuera tambi√©n es un mensaje en una cola entrante.  Esto no est√° en UNIX porque no ha echado ra√≠ces. <br><br>  <strong>M√©todo de llamadas.</strong>  Tenemos objetos que llamamos procesos.  Los m√©todos en los procesos se llaman a trav√©s de mensajes. <br><br>  <strong>Los m√©todos de llamada tambi√©n env√≠an un mensaje.</strong>  Es genial que ahora se pueda hacer con un tiempo de espera.  Si algo nos responde lentamente, llamamos al m√©todo en otro objeto.  Pero al mismo tiempo decimos que estamos listos para esperar no m√°s de 60 s, porque tengo un cliente con un tiempo de espera de 70 s.  Tendr√© que ir y decirle "503" - ven ma√±ana, ahora no te est√°n esperando. <br><br>  Adem√°s, la <strong>respuesta a la llamada puede posponerse</strong> .  Dentro del objeto, puede aceptar la solicitud de llamar al m√©todo y decir: "S√≠, s√≠, lo dejar√© ahora, vuelva en media hora, le responder√©".  No se puede hablar, pero se reserva en silencio.  A veces lo usamos. <br><br><h3>  ¬øC√≥mo trabajar con una red? </h3><br>  Puede escribir c√≥digo lineal, devoluciones de llamada o al estilo de <code>asyncio.gather</code> .  Un ejemplo de c√≥mo se ver√° esto. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ ])</span></span></span><span class="hljs-function"> -&gt;</span></span> [ ]; wait4(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> {reply, Pid, Price} -&gt; [Price] ++ wait4(List -- [Pid]) <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">60000</span></span> -&gt; [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  En la funci√≥n <code>wait4</code> del ejemplo anterior, <code>wait4</code> sobre la lista de aquellos de quienes todav√≠a estamos esperando respuestas.  Si usando el m√©todo de <code>receive</code> recibimos un mensaje de ese proceso, lo escribimos en la lista.  Si la lista ha terminado, devolvemos todo lo que estaba y acumulamos la lista.  Pedimos al mismo tiempo tres objetos para que nos condujeran los datos.  Si no se las arreglaron juntos en 60 segundos, y al menos uno de ellos no respondi√≥ OK, tendremos una lista vac√≠a.  Pero es importante que hagamos un tiempo de espera general para una solicitud de inmediato a un mont√≥n de objetos. <br><br>  Alguien podr√≠a decir: "Piensa, libcurl tiene lo mismo".  Pero aqu√≠ es importante que, por otro lado, pueda haber no solo un viaje HTTP, sino tambi√©n un viaje DB, as√≠ como algunos c√°lculos, por ejemplo, calcular alg√∫n tipo de n√∫mero √≥ptimo para el cliente. <br><br><h3>  Manejo de errores </h3><br>  <strong>Los errores han pasado de la secuencia al objeto, que ahora son uno y el mismo</strong> .  Ahora el error en s√≠ se adjunta no al subproceso, sino al objeto donde se ejecut√≥. <br><br>  Esto es mucho m√°s l√≥gico.  Por lo general, cuando dibujamos todo tipo de peque√±os cuadrados y c√≠rculos en el tablero con la esperanza de que cobren vida y comiencen a darnos resultados y dinero, generalmente dibujamos objetos, no los flujos en los que se ejecutar√°n estos objetos.  Por ejemplo, en el momento de la entrega podemos recibir un <strong>mensaje</strong> autom√°tico <strong>sobre la muerte de otro objeto</strong> . <br><br><h3>  Introspecci√≥n o depuraci√≥n en producci√≥n </h3><br>  Qu√© podr√≠a ser mejor que ir a la producci√≥n y el d√©bito, especialmente si el error ocurre solo bajo carga durante las horas pico.  En hora punta decimos: <br><br>  <em>- ¬°Vamos, reiniciar√© ahora!</em> <br>  <em>- ¬°Sal por la puerta y alguien m√°s se reiniciar√°!</em> <br><br>  Aqu√≠ podemos entrar en un sistema vivo que se est√° ejecutando en este momento y no est√° especialmente preparado para esto.  Para hacer esto, no necesita reiniciarlo con el generador de perfiles, con el depurador, reconstruir. <br><br>  <strong>Sin ninguna p√©rdida de rendimiento en un sistema de producci√≥n en vivo,</strong> podemos ver una lista de procesos: lo que hay dentro de ellos, c√≥mo funciona todo, desecharlos, verificar lo que les sucede.  Todo esto es gratis fuera de la caja. <br><br><h3>  Bonos </h3><br>  <strong>El c√≥digo es s√∫per confiable.</strong>  Por ejemplo, Python tiene fragilidad con el <code>old vs async</code> , y permanecer√° durante cinco a√±os, nada menos.  Teniendo en cuenta la velocidad con la que se implement√≥ Python 3, no debe esperar que sea r√°pido. <br><br>  <strong>Leer y rastrear mensajes es m√°s f√°cil que depurar devoluciones de llamada</strong> .  Esto es importante  Parece que si todav√≠a tenemos devoluciones de llamada para procesar mensajes que podemos ver, ¬øqu√© es mejor?  Por el hecho de que los mensajes son un dato en la memoria.  Puedes mirarlo con ojos y entender lo que ha venido aqu√≠.  Se puede agregar al marcador, obtener una lista de mensajes en un archivo de texto.  Esto es m√°s conveniente que las devoluciones de llamada. <br><br>  <strong>Magn√≠fico multin√∫cleo</strong> , gesti√≥n de memoria e <strong>introspecci√≥n dentro de un sistema de</strong> producci√≥n en <strong>vivo</strong> . <br><br><h3>  Los problemas </h3><br>  Naturalmente, Erlang tambi√©n tiene problemas. <br><br>  <strong>P√©rdida de rendimiento m√°ximo</strong> debido al hecho de que ya no podemos hacer referencia a datos en otro proceso u objeto.  Tenemos que moverlos, pero esto no es gratis. <br><br>  <strong>La sobrecarga de copiar datos entre procesos.</strong>  Podemos escribir un programa en C que se ejecutar√° en los 80 n√∫cleos y procesar√° una matriz de datos, y asumiremos que lo hace correcta y correctamente.  En Erlang, no puede hacer esto: necesita cortar cuidadosamente los datos, distribuirlos en un mont√≥n de procesos, realizar un seguimiento de todo.  Esta comunicaci√≥n cuesta recursos: ciclos de procesador. <br><br>  <strong>¬øQu√© tan r√°pido o lento es?</strong>  Llevamos 10 a√±os escribiendo c√≥digo Erlang.  El √∫nico competidor que ha sobrevivido estos 10 a√±os est√° escrito en Java.  Con √©l, tenemos una paridad de rendimiento casi completa: alguien dice que somos peores, alguien que son.  Pero tienen Java con todos sus problemas, comenzando con JIT. <br><br>  Estamos escribiendo un programa que sirve a decenas de miles de sockets y bombea decenas de GB de datos a trav√©s de s√≠ mismo.  De repente, resulta que en este caso la <strong>correcci√≥n de los algoritmos y la capacidad de depurar todo esto en la producci√≥n es m√°s importante que los posibles bollos de Java</strong> .  Se han invertido miles de millones de d√≥lares en esto, pero esto no le da al Java JIT ninguna ventaja m√°gica. <br><br>  Pero si queremos medir puntos de referencia est√∫pidos y sin sentido, como "calcular los n√∫meros de Fibonacci", entonces Erlang probablemente ser√° a√∫n peor que Python o comparable. <br><br>  <strong>La sobrecarga de la asignaci√≥n de mensajes.</strong>  A veces duele.  Por ejemplo, tenemos algunas piezas en C en el c√≥digo, y en estos lugares no funcion√≥ en absoluto con Erlang.     ,      ,   . <br><br>    Erlang <strong>     </strong> ,   ,     .  ,    ,   <code>receive</code>  <code>send receive</code> .     ‚Äî   ,   .   <strong> ,   ,    </strong> . <br><br><h2>      Python </h2><br> <strong>   </strong> .        .       ,       Python  -     . <br><br> ,  <strong>   </strong> .  -     Python,      ,    20 ,   40. <br><br> , <strong>   </strong>  . - , ,     Elixir,   ,      . <br><br><blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Moscow Python Conf++</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  ,         6      4   .  ,   ,  )     ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>  . Call for Papers   13 ,     27 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/476112/">https://habr.com/ru/post/476112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../476102/index.html">Escriba seguro trabajando con matrices PHP</a></li>
<li><a href="../476104/index.html">No use MTProxy gratis y otros tipos de proxies gratuitos ...</a></li>
<li><a href="../476106/index.html">"Protocolos de criptosistemas": Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../476108/index.html">Cerebro mutable</a></li>
<li><a href="../476110/index.html">¬øPor qu√© necesita una marca personal?</a></li>
<li><a href="../476114/index.html">¬øQu√© pasa si sin Python? Julia para aprendizaje autom√°tico y en general</a></li>
<li><a href="../476118/index.html">Dise√±o de interfaz para el juego, dibuja un anillo Havel de Dark Souls 3</a></li>
<li><a href="../476122/index.html">"Escucha" el cosmos: de la materia oscura al cometa Churyumov - Gerasimenko</a></li>
<li><a href="../476126/index.html">C√≥mo probar el rendimiento del servidor: una selecci√≥n de varios puntos de referencia de c√≥digo abierto</a></li>
<li><a href="../476128/index.html">Ivan Osipov y Yuri Artamonov sobre Kotlin y complementos para IntelliJ IDEA en la reuni√≥n jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>