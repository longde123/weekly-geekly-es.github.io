<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 ✈️ 🤳🏾 如何通过水中的声音查看混响或视频传输-2 🤴🏽 🙆🏿 📒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好，亲爱的！ 

 今天，我们将再次使用超声波通过水传输图像：我们将在字面上看到混响和回声，甚至根据情况如何变化。 我要告诉您的一切都很简单，我自己重复一遍很有趣，几乎任何人都可以做到。 

 如果您的话语在您的灵魂中飞舞，欢迎来到凯特，走进我们池塘的黑暗水域！ 




 “最好的休息就是解释众...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何通过水中的声音查看混响或视频传输-2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453678/"><h3> 你好，亲爱的！ </h3><br><br> 今天，我们将再次使用超声波通过水传输图像：我们将在字面上看到混响和回声，甚至根据情况如何变化。 我要告诉您的一切都很简单，我自己重复一遍很有趣，几乎任何人都可以做到。 <br><br> 如果您的话语在您的灵魂中飞舞，欢迎来到凯特，走进我们池塘的黑暗水域！ <br><br><img src="https://habrastorage.org/webt/e7/dd/ql/e7ddqlsffkcu34ex7scxfsvt4fs.png"><br><a name="habracut"></a><br><br><blockquote>  “最好的休息就是解释众所周知的事实。”  （C）二十二世纪中午，ABS </blockquote><br><br><h3> 前戏 </h3><br> 水声目击者俱乐部的基本规则是，在水体的中部或多或少有效距离（超过几米）使用水声的视频无法传输，并且永远不会传输。 <br> 这有很严重的原因-具有非常低的带宽，低的信号传播速度（在水中仅1,500 m / s）和较高的出错概率的通信信道。 可用频带只有几十千赫兹。 <br> 但这还不是全部-如果相对而言，如果信号在10 kHz左右的频率在水中以大约8-10 km的距离传播，那么在20 kHz的频率下已经是3-5 km，并且频率越高，衰减越强。 例如，我们世界上最小的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">uWAVE</a>调制解调器工作在20-30 kHz频段，并以每1000米78比特/秒的速度传输数据，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RedLINE则</a>在5-15至8000米的频段内传输数据。 商用设备中的记录属于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EvoLogics-</a>每300米68 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kBits</a> 。 <br>  ，无法欺骗物理，不可能对此达成共识-它可以非常缓慢且抗噪音的方式传播，也可以快速传播，但传播距离很短。 <br> 但是，在某些情况下，可以“切掉一些角”，这一次我们要切掉的角较低。 <br><br><h3> 我们今天将要做什么？为此需要什么？ </h3><br> 在之前的文章中，我们已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过声音传输了带有声音的“视频”</a> ，我想提醒您那里的帧是“绘制在频谱上的”，也就是说，频谱，或者说信号的频谱图就是一幅图片。 <br> 后来，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用垃圾</a>制成了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">简单的水</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">声天线，</a>并制造了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最简单的水声调制解调器</a> 。 在那里，我们还为天线做了一个前置放大器（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>仍由LUT-ohm自行生产PCB的设计）。 <br><br> 我们认为您还可以尝试传达图片，以便甚至是<s>幼儿园的</s>学生都可以理解它，而且在我们看来，他们想出了一种比以前更简单的方法。 <br><br> 因此，总而言之，请草拟一份我们需要的清单： <br><br>  -一对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拾音器的声纳天线</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-LUT</a>制造的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前置放大器</a> <br>  -C＃项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> <br>  -一对12伏铅电池 <br>  -TDA上的放大器，我在阿里只花了50卢布 <br><br><h3> 一点理论 </h3><br> 回想一下，我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">声纳调制解调器</a>基于简单的音频检测器，其频率比采样频率低4倍。 简要回顾一下它是如何工作的。 <br><img src="https://habrastorage.org/webt/__/zm/oe/__zmoe1u0jzgjderykrsaogn0k8.png"><br><br> 图片显示了在Pi / 2上两个相对偏移的振荡-即正弦和余弦相位。 而且，如果频率恰好是采样频率的四倍，则该周期只有四个采样。 <br> 细心的habuchitel确实注意到两个信号都转移到Pi / 4上。 经过这样的移位，信号仅取两个值：√2/ 2和-√2/ 2。 <br> 特定的值甚至都不重要，重要的是您只能使用符号“ +”和“-”。 <br><br> 现在我们可以将正弦相位表示为符号“ +”“ +”“-”“-”的序列，并将余弦相位表示为“ +”“-”“-”“ +”。 <br><br><div class="spoiler">  <b class="spoiler_title">在扰流板下，重复检测器：</b> <div class="spoiler_text">假设输入信号在sn缓冲区中，则对于正弦和余弦相位，我们有两个环形平均缓冲区-大小为N的bs和bc。它们具有共同的头和尾指针-bH和bT。 在初始时间，bH = N-1，bT =0。平均周期计数器C = 0。 <br> 我们从输入缓冲区中提取4个样本，然后根据字符序列将其相加。 <br><br> <code>a = sn(i) <br> bs(bH) = a <br> bc(bH) = a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+1) <br> bs(bH) = a <br> bc(bH) = -a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+2) <br> bs(bH) = -a <br> bc(bH) = -a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+3) <br> bs(bH) = -a <br> bc(bH) = a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br></code> <br><br> 在每个处理了四个样本之后，我们检查平均周期的计数器，如果它超过了N，则我们计算载波的振幅cA： <br><br> <code>if ++cycle &gt;= N <br> cA = sqrt(s1 * s1 + s2 * s2) <br> cycle = 0 <br> end <br></code> <br></div></div><br><br> 我们以此方法为基础；它将负责“同步”。 <br> 现在让我们看看图像是如何编码的。 我建议使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">幅度操纵</a> 。 操纵是指将信号划分为相等的片段（称为码片或符号），然后沿着码片的长度存储一些可变参数（在我们的情况下为振幅）。 <br> 例如，如果我们可以在0到32767（16位样本）的范围内改变幅度，并且我们需要传输255个像素亮度值，那么每单位像素亮度变化，芯片的幅度将变为32768/255 = 128。 <br> 另一个重要参数是芯片的长度，我们从一个载波周期开始-在本例中为四个样本。 <br> 因此，图片将逐像素传输，每个像素持续4个样本，此周期的幅度为b [x，y] * 128，其中b [x，y]是图像b中具有x和y坐标的像素的亮度值。 <br><br> 让我们估计一下传输速度。 <br> 在示例中，我使用了120x120像素的帧大小。 这意味着要转移一帧，我们需要 <br><br>  120x120x4 = 57600个样本， <br><br> 如果采样频率为96 kHz，则一帧的传输将花费时间： <br><br>  57600/96000 = 0.6秒 <br><br> 显然，我们需要某种暂停，一定的保护间隔，以便检测器可以确定下一帧的开始。 出于人道的原因，假设对我们来说0.1秒就足够了，在此期间所有回声都消失了（实际上不是）。 然后，最终传输速率将变为： <br><br>  1 /（0.6 + 0.1）= 1.428帧/秒 <br><br> 在此处犯错并尝试计算速度（以位/秒为单位）非常容易。 看看传输速度是多么令人难以置信： <br><br>  120 * 120 * 8 / 1.428 = 80627 bps <br><br> 但是，如果我没有8位像素，而是16位像素，会发生什么情况？ <br><br>  120 * 120 * 16 / 1.428 = 161344 bps <br><br> 这里的问题是，再次，这种传输方法不能称为数字传输，并且比特率的概念对此并不完全有效。 <br> 尝试计算模拟电视信号的比特率。 对于探测器接收器？  :) <br><br> 因此，例如，一条信号看起来像，传输了10个像素的亮度，其值交替变化：1 2 1 2 1 2 1 2 1 2 <br><img src="https://habrastorage.org/webt/ul/kz/st/ulkzsthqa8tt4ykb7stgu7hehqe.png"><br><br> 现在，让我们在示例中看看它是如何工作的。  Encode和Decode方法位于<a href="">Encoder</a>类中，负责调制和解调图像： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interframePauseMs</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span>; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFinished = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pSize; i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= pLimit) { phase -= pLimit; } samples.Add(alpha * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isFinished) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; pxAmplitude = (((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)frame.GetPixel(col, row).R) / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++row &gt;= rows) isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } samples.Add(alpha * pxAmplitude); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interframePauseMs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { samples.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)interframePauseMs) / <span class="hljs-number"><span class="hljs-number">1000.0</span></span>) * (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)sampleRate)]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples.ToArray(); }</code> </pre><br><br> 从代码中可以看出，在调制图像之前，将由纯音组成的同步前缀（pSize样本）添加到输出信号-这是必要的，以便在接收端可以在图像本身之前发生同步， <s>并且通常可能</s>在不利条件下<s>发生</s> 。 <br> 解码方法如下： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; Bitmap result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(cols, rows); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxAmplitude = WaveUtils.GetMaxAmplitude(samples); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMin = maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> smp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = pSize; (i &lt; samples.Length) &amp;&amp; (row &lt; rows); i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; chipAmplitude = (Math.Max(Math.Abs(pxMax), Math.Abs(pxMin)) / maxAmplitude); pxMin = maxAmplitude; pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gs = Convert.ToByte(chipAmplitude * <span class="hljs-number"><span class="hljs-number">255</span></span>); result.SetPixel(col, row, Color.FromArgb(<span class="hljs-number"><span class="hljs-number">255</span></span>, gs, gs, gs)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { col = <span class="hljs-number"><span class="hljs-number">0</span></span>; row++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { smp = samples[i] * alpha; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &gt; pxMax) pxMax = smp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &lt; pxMin) pxMin = smp; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br> 可以看出，这两种方法均不受任何特定频率的限制，可以与其他检测器一起使用。 <br><br> 信号搜索本身（检测，同步）也像我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最简单的水声调制解调器中一样发生</a> ，唯一的区别是我将其放在单独的类<a href="">FsBy4CarrierDetector中</a>进行更改。 <br> 所有简单的魔术都发生在bool ProcessSample方法中（简称a） <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessSample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ring1[ringHead] = a; ring2[ringHead] = a; s1 += a - ring1[ringTail]; s2 += a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ring1[ringHead] = a; ring2[ringHead] = -a; s1 += a - ring1[ringTail]; s2 += - a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">2</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = -a; s1 += -a - ring1[ringTail]; s2 += -a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = a; s1 += -a - ring1[ringTail]; s2 += a - ring2[ringTail]; } ringHead = (ringHead + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; ringTail = (ringTail + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++smpCount &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { smpCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= ringSize) { s = Math.Sqrt(s1 * s1 + s2 * s2) / ringSize; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; result = (s - sPrev) &gt;= Threshold; sPrev = s; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><br> 在每个传入样本上都会调用它，并在检测到载波时返回true。 <br><br> 由于检测器远非完美，并且可以轻松地在行的中间进行同步，因此我添加了一个特殊的滑块，移动该滑块可以实现更准确的同步。 <br><br> 现在，在我们简要研究了所有工作原理之后，让我们继续进行最美味的部分：可以从所有这些中获得什么。 <br><br><h3> 一点练习 </h3><br> 首先，让我们检查一下没有声纳通道的情况下的工作原理-只需将接收天线和发射天线相互连接即可。 <br> 首先，图片较大（240x120），因此至少可以看出： <br><img src="https://habrastorage.org/webt/ev/ys/1t/evys1t89oks6jpvgeyxtgafgbp4.gif"><br><br> 然后快速播放，使<s>生活</s>更像视频： <br><img src="https://habrastorage.org/webt/2j/2t/y_/2j2ty_dym0iowoiq_xgtf_oqdrg.gif"><br><br> 好像还不错吗？ 但不要急于下结论，而去游泳池： <br><img src="https://habrastorage.org/webt/_8/0u/jz/_80ujzh-1afojo46fevq6egccvg.jpeg"><br><br> 正如我在标题中所承诺的，在这里，我们将亲眼看到回声： <br><img src="https://habrastorage.org/webt/lb/aq/xe/lbaqxezsgyzwjik0zxymshqjysi.gif"><br><br>  <s>埃隆·马斯克（Elon Musk），您觉得怎么样？</s> 你喜欢高清吗？ 为什么会这样呢？ <br> 一切都非常简单-回波本质上是原始信号的延迟副本，在接收点会产生干扰，在不同的相位折叠并给出这样的图像。 由于我们传输了图像，最终我们得到了许多幅彼此重叠且幅值不同的图像。 所有这些最终导致模糊和再现。 <br><br> 往回看，让我们检查一下模型大图片上的所有内容。 我随机拍了张照片： <br><img src="https://habrastorage.org/webt/oo/hd/jb/oohdjbgoj4pqq-k8f9st0b9rdre.jpeg"><br><br> 我对其进行了调制，然后添加了回声和一点噪声，然后对其进行解码，是的-结果类似于我们在池中得到的结果： <br><img src="https://habrastorage.org/webt/bk/dp/y_/bkdpy_9ztpti3b91ulbakqzokes.png"><br><br> 原则上，可以进行去<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">卷积</a>并减去反射，但是<s>让我们这个地区的</s>人们离开这一点进行独立工作。 <br><br> 顺便说一下，池中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前一种方法</a>效果更好，但效果也很差-在宽带信号上，多径和混响会导致频率选择性衰落，在图片中（在频谱上读取）看起来像是黑白条纹-信号处于反相状态，以及它的开发阶段（实际上，还有很多中间选项）： <br><img src="https://habrastorage.org/webt/zo/f-/pp/zof-ppqayi-rbz2h9yfgjlvc8da.gif"><br><br>  4月，我们抓住了片刻，带着面包板模型去了池塘，并在那里宠爱自己： <br><img src="https://habrastorage.org/webt/mv/c-/v4/mvc-v4-m9tys6na8hip-8t8kzyc.jpeg"><br><br><img src="https://habrastorage.org/webt/pp/wc/8u/ppwc8uemc0xlmsmt_rz5h24s664.jpeg"><br><br> 结果与池中获得的结果没有太大不同： <br><img src="https://habrastorage.org/webt/1-/8j/et/1-8jetei8ly02aanoubjimfhlty.png"><br><br><img src="https://habrastorage.org/webt/_o/1q/ij/_o1qijulzi1p0pqxmch5dijhrcc.png"><br><br> 立即比较一下以前的方法： <br><img src="https://habrastorage.org/webt/dh/8o/nk/dh8onkjtu5jly6kr7ios0k3td44.png"><br><br> 这是从保存的帧中收集的gif动画，方法1： <br><img src="https://habrastorage.org/webt/b7/bq/nz/b7bqnzrvtoa1jkbc0cj4h0okv-u.gif"><br><br> 在本文中我们将讨论方法2： <br><img src="https://habrastorage.org/webt/of/vg/gb/ofvggbrbktqq30iy0ihoybpx6le.gif"><br><br><h3> 总结 </h3><br> 如所承诺的，我们展示了回声和混响的字面外观，如何度过了有益的时光并用手完成了一些工作。 <br><br> 当然，以这种形式，该方法在实践中不适用，但是对初学者来说，使用它会非常有用。 <br><br> 一般而言，我们在条件很不利的浅水池中进行检查，如果有人在其他水库中重复我们的实验并肯定会告诉他们结果，那将是很酷的。 <br><br> 如果读者只是想尝试（即使是戴着麦克风和扬声器在空中），也可以使用以下链接： <br>  <a href="">方法1</a> <br>  <a href="">方法2（来自本文）</a> <br><br><h3> 聚苯乙烯 </h3> 我们非常希望获得读者的反馈，因为了解您正在徒劳（或徒劳，然后需要立即停止）是非常重要的。 <br><br><h3>  PS / 2 </h3> 我会立即回答一个常见问题：对于这类儿童设施中的鱼类和其他海洋生物而言，这一切都鲜为人知。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453678/">https://habr.com/ru/post/zh-CN453678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453664/index.html">Spring Boot-OAuth2和JWT</a></li>
<li><a href="../zh-CN453666/index.html">我如何乘坐无人出租车</a></li>
<li><a href="../zh-CN453668/index.html">年轻RO的10个错误（第一部分-三个错误）</a></li>
<li><a href="../zh-CN453672/index.html">CardInfo-用于通过卡号确定徽标，银行颜色和其他内容的API</a></li>
<li><a href="../zh-CN453676/index.html">在Linux中通过SSH连接到Windows</a></li>
<li><a href="../zh-CN453682/index.html">为Redd中安装的FPGA开发最简单的“固件”。 第2部分。程序代码</a></li>
<li><a href="../zh-CN453686/index.html">安全周22：威胁统计信息，银行木马和流行漏洞</a></li>
<li><a href="../zh-CN453688/index.html">Java不仅是血腥的企业，而且还是对延迟敏感的快速应用程序</a></li>
<li><a href="../zh-CN453692/index.html">初学者3D游戏着色器：效果</a></li>
<li><a href="../zh-CN453694/index.html">像在Linux中一样通过SSH连接到Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>