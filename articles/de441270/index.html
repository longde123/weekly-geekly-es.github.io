<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåë üë®üèª‚Äçüè´ üë©üèø‚Äçüéì Schauen Sie sich zuerst Apples FoundationDB an üö∏ üçõ üò∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel haben wir die Einschr√§nkungen und Hindernisse untersucht, die auftreten, wenn Sie Daten horizontal skalieren und die ACID-Eigenscha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schauen Sie sich zuerst Apples FoundationDB an</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441270/"> Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir die Einschr√§nkungen und Hindernisse untersucht, die auftreten, wenn Sie Daten horizontal skalieren und die ACID-Eigenschaften von Transaktionen garantieren m√ºssen.  In diesem Artikel sprechen wir √ºber die FoundationDB-Technologie und verstehen, wie diese Einschr√§nkungen bei der Entwicklung gesch√§ftskritischer Anwendungen √ºberwunden werden k√∂nnen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FoundationDB</a> ist eine verteilte NoSQL-Datenbank mit serialisierbaren ACID-Transaktionen, in der sortierte Schl√ºssel-Wert-Speicherpaare gespeichert sind.  Schl√ºssel und Werte k√∂nnen beliebige Folgen von Bytes sein.  Es gibt keinen einzigen Inzidenzpunkt - alle Cluster-Maschinen sind gleich.  Es selbst verteilt die Daten auf die Cluster-Server und skaliert im laufenden Betrieb: Wenn Sie dem Cluster Ressourcen hinzuf√ºgen m√ºssen, f√ºgen Sie einfach die Adresse des neuen Computers auf den Konfigurationsservern hinzu, und die Datenbank nimmt sie selbst auf. <a name="habracut"></a><br><br>  In FoundationDB blockieren sich Transaktionen niemals gegenseitig.  Das Lesen erfolgt √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiversion-Versionskontrolle</a> (MVCC) und das Lesen √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optimistische Parallelit√§tskontrolle</a> (OCC).  Die Entwickler behaupten, dass sich alle Schreibmaschinen im Cluster im selben Rechenzentrum befinden, die Schreiblatenz 2-3 ms und die Leselatenz weniger als eine Millisekunde betr√§gt.  Die Dokumentation enth√§lt Sch√§tzungen von 10-15 ms, was unter realen Bedingungen wahrscheinlich n√§her an den Ergebnissen liegt. <br><br><img src="https://habrastorage.org/webt/ob/9m/jt/ob9mjtfiyqpvxfjpjc1tp48ujho.png">  <font color="#777777">* Unterst√ºtzt keine ACID-Eigenschaften f√ºr mehrere Shards.</font> <br><br>  FoundationDB hat einen einzigartigen Vorteil - das automatische Resharding.  Das DBMS selbst sorgt f√ºr ein gleichm√§√üiges Laden der Computer im Cluster: Wenn ein Server voll ist, werden die Daten im Hintergrund an benachbarte Computer weitergegeben.  Gleichzeitig bleibt die Garantie f√ºr den Serialisierbarkeitsgrad f√ºr alle Transaktionen erhalten, und der einzige Effekt, der f√ºr die Kunden erkennbar ist, ist eine geringf√ºgige Erh√∂hung der Latenz der Antworten.  Die Datenbank stellt sicher, dass sich die Datenmenge auf den am meisten und am wenigsten belasteten Clusterservern um nicht mehr als 5% unterscheidet. <br><br><h2>  Architektur </h2><br>  Ein FoundationDB-Cluster besteht logischerweise aus einer Reihe von Prozessen desselben Typs auf verschiedenen physischen Computern.  Prozesse haben keine eigenen Konfigurationsdateien, daher sind sie austauschbar.  Mehrere feste Prozesse haben eine dedizierte Rolle - Koordinatoren, und jeder Clusterprozess beim Start kennt seine Adressen.  Es ist wichtig, dass die Abst√ºrze der Koordinatoren so unabh√§ngig wie m√∂glich sind. Daher ist es am besten, sie auf verschiedenen physischen Maschinen oder sogar in verschiedenen Rechenzentren zu platzieren. <br><br><img src="https://habrastorage.org/webt/ai/sx/qv/aisxqvwfakb618b27cl_vyjnc5a.png"><br><br>  Die Koordinatoren sind sich √ºber den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos-</a> Konsensalgorithmus einig.  Sie w√§hlen den Cluster-Controller-Prozess aus, der dann den √ºbrigen Cluster-Prozessen Rollen zuweist.  Der Cluster-Controller informiert kontinuierlich alle Koordinatoren dar√ºber, dass er lebt.  Wenn die meisten Koordinatoren glauben, er sei tot, w√§hlen sie einfach einen neuen aus.  Weder Cluster Controller noch Coordinators sind an der Transaktionsverarbeitung beteiligt. Ihre Hauptaufgabe besteht darin, die Situation des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gespaltenen Gehirns</a> zu beseitigen. <br><br>  Wenn ein Client eine Verbindung zur Datenbank herstellen m√∂chte, kontaktiert er sofort alle Koordinatoren, um die Adresse des aktuellen Cluster-Controllers zu erfahren.  Wenn die meisten Antworten √ºbereinstimmen, erh√§lt es vom Cluster Controller die vollst√§ndige aktuelle Clusterkonfiguration (wenn sie nicht √ºbereinstimmen, werden die Koordinatoren erneut aufgerufen). <br><br><img src="https://habrastorage.org/webt/ig/g6/qq/igg6qqffqlxbbrd-cpchddyktbu.png"><br><br>  Cluster Controller kennt die Gesamtzahl der verf√ºgbaren Prozesse und verteilt die Rollen: Diese 5 sind Proxy, diese 2 sind Resolver, dieser ist Master.  Und wenn einer von ihnen stirbt, wird er sofort einen Ersatz f√ºr ihn finden und die notwendige Rolle einem willk√ºrlichen freien Prozess zuweisen.  Dies alles geschieht im Hintergrund, f√ºr den Anwendungsprogrammierer unsichtbar. <br><br>  Der Master-Prozess ist verantwortlich f√ºr die Nummer der aktuellen Version des Datensatzes (sie steigt mit jedem Datensatz in der Datenbank) sowie f√ºr die Verteilung vieler Schl√ºssel an Speicherserver und die Rateneinschr√§nkung (k√ºnstlich geringere Leistung bei hoher Last: Wenn der Cluster wei√ü, dass der Client wird viele kleine Anfragen stellen, er wird warten, sie gruppieren und das ganze Paket auf einmal beantworten). <br><br>  Transaktionsprotokollierung und Speicherung sind zwei unabh√§ngige Speichersubsysteme.  Der erste ist der tempor√§re Speicher zum schnellen Schreiben von Daten auf die Festplatte in der Reihenfolge des Empfangs, der zweite ist der permanente Speicher, bei dem die Daten auf der Festplatte in aufsteigender Reihenfolge der Schl√ºssel sortiert werden.  Bei jedem Transaktions-Commit m√ºssen mindestens drei tLog-Prozesse Daten speichern, bevor der Cluster dem Client den Erfolg meldet.  Parallel dazu werden Daten im Hintergrund von tLog-Servern auf Speicherserver verschoben (Speicher, auf dem auch redundant ist). <br><br><h2>  Anfrage bearbeiten </h2><br>  Alle Clientanforderungen verarbeiten Proxy-Prozesse.  Beim √ñffnen einer Transaktion greift der Client auf einen beliebigen Proxy zu, fragt alle anderen Proxys ab und gibt die aktuelle Versionsnummer der Clusterdaten zur√ºck.  Alle nachfolgenden Ablesungen erfolgen bei dieser Versionsnummer.  Wenn ein anderer Client die Daten nach dem √ñffnen der Transaktion notiert hat, werden die √Ñnderungen einfach nicht angezeigt. <br><br>  Das Aufzeichnen einer Transaktion ist etwas komplizierter, da Sie Konflikte l√∂sen m√ºssen.  Dies schlie√üt den Resolver-Prozess ein, bei dem alle ge√§nderten Schl√ºssel f√ºr einen bestimmten Zeitraum im Speicher gespeichert werden.  Wenn der Client die Festschreibungstransaktion abschlie√üt, pr√ºft der Resolver, ob die gelesenen Daten veraltet sind.  (Das hei√üt, ob die Transaktion, die sp√§ter als meine ge√∂ffnet wurde, abgeschlossen wurde und die von mir gelesenen Schl√ºssel ge√§ndert hat.) In diesem Fall wird die Transaktion zur√ºckgesetzt und die Clientbibliothek selbst (!) F√ºhrt einen zweiten Festschreibungsversuch durch.  Das einzige, woran der Entwickler denken sollte, ist, dass die Transaktionen idempotent sind, dh eine wiederholte Verwendung sollte zu einem identischen Ergebnis f√ºhren.  Eine M√∂glichkeit, dies zu erreichen, besteht darin, einen eindeutigen Wert innerhalb der Transaktion zu speichern und zu Beginn der Transaktion deren Vorhandensein in der Datenbank zu √ºberpr√ºfen. <br><br><img src="https://habrastorage.org/webt/h6/sl/tn/h6sltnc7mmauiguiymix7msytv0.png"><br><br>  Wie in jedem Client-Server-System gibt es Situationen, in denen die Transaktion erfolgreich abgeschlossen wurde, der Client jedoch aufgrund einer Unterbrechung keine Best√§tigung erhalten hat.  Die Client-Bibliothek behandelt sie wie jeden anderen Fehler - sie versucht es einfach erneut.  Dies k√∂nnte m√∂glicherweise zur erneuten Ausf√ºhrung der gesamten Transaktion f√ºhren.  Wenn die Transaktion jedoch idempotent ist, gibt es kein Problem damit - es hat keinen Einfluss auf das Endergebnis. <br><br><h2>  Skalieren </h2><br>  In einem Speichersubsystem k√∂nnen sich Tausende von Servern befinden.  Welche von ihnen sollte ein Kunde kontaktieren, wenn er Daten zu einem bestimmten Schl√ºssel ben√∂tigt?  Vom Cluster Controller kennt der Client die vollst√§ndige Konfiguration des gesamten Clusters und enth√§lt Schl√ºsselbereiche auf jedem Speicherserver.  Daher greift es einfach ohne Zwischenanforderungen direkt auf die gew√ºnschten Speicherserver zu. <br><br>  Wenn der gew√ºnschte Speicherserver nicht verf√ºgbar ist, √ºbernimmt die Clientbibliothek eine neue Konfiguration von Cluster Controller.  Wenn der Cluster infolge eines Serverabsturzes erkennt, dass die Redundanz nicht ausreicht, beginnt er sofort, einen neuen Knoten aus Teilen eines anderen Speichers zu sammeln. <br><br>  Angenommen, Sie speichern ein Gigabyte an Daten in einer Transaktion.  Wie k√∂nnen Sie schnell antworten?  Auf keinen Fall hat FoundationDB die Gr√∂√üe einer Transaktion einfach auf 10 Megabyte begrenzt.  Dar√ºber hinaus ist dies eine Einschr√§nkung f√ºr alle Daten, die die Transaktion <i>betrifft</i> - Lesen oder Schreiben.  Jeder Eintrag in der Datenbank ist ebenfalls begrenzt - der Schl√ºssel darf 10 Kilobyte nicht √ºberschreiten, der Wert betr√§gt 100 Kilobyte.  (F√ºr eine optimale Leistung empfehlen Entwickler Schl√ºssel mit einer L√§nge von 32 Byte und Werte mit einer L√§nge von 10 Kilobyte.) <br><br>  Jede Transaktion kann m√∂glicherweise zu einer Konfliktquelle werden und muss dann zur√ºckgesetzt werden.  Aus Gr√ºnden der Geschwindigkeit ist es daher sinnvoll, die aktuellen √Ñnderungen im RAM und nicht auf der Festplatte beizubehalten, bis der Commit-Befehl eintrifft.  Angenommen, Sie schreiben Daten mit einer Last von 1 GB / Sekunde in eine Datenbank.  Im Extremfall weist Ihr Cluster dann jede Sekunde 3 GB RAM zu (wir schreiben Transaktionen auf 3 Computern).  Wie kann ein solches Lawinenwachstum des verwendeten Speichers begrenzt werden?  Es ist sehr einfach, die maximale Transaktionszeit zu begrenzen.  In FoundationDB kann eine Transaktion nicht l√§nger als 5 Sekunden dauern.  Wenn der Client 5 Sekunden nach dem √ñffnen der Transaktion versucht, auf die Datenbank zuzugreifen, ignoriert der Cluster alle seine Befehle, bis er einen neuen √∂ffnet. <br><br><h2>  Indizes </h2><br>  Angenommen, Sie f√ºhren eine Liste mit Personen, jede Person hat eine eindeutige Kennung, wir verwenden diese als Schl√ºssel und in den Wert schreiben wir alle anderen Attribute - Name, Geschlecht, Alter usw. <br><table><tbody><tr><td>  Schl√ºssel </td><td>  Wert </td></tr><tr><td>  12345 </td><td>  (Ivanov Ivan Ivanovich, M, 35) </td></tr></tbody></table><br>  Wie bekomme ich eine Liste aller Personen, die 30 Jahre alt sind, ohne umfassende Suche?  In der Regel wird hierf√ºr ein Index in der Datenbank erstellt.  Ein Index ist eine weitere Datenansicht, mit der schnell nach zus√§tzlichen Attributen gesucht werden kann.  Wir k√∂nnen einfach Eintr√§ge des Formulars hinzuf√ºgen: <br><table><tbody><tr><td>  Schl√ºssel </td><td>  Wert </td></tr><tr><td>  (35, 12345) </td><td>  '' </td></tr></tbody></table><br>  Um die gew√ºnschte Liste zu erhalten, m√ºssen Sie nur noch den Tastenbereich (30, *) durchsuchen.  Da FoundationDB nach Schl√ºssel sortierte Daten speichert, wird eine solche Abfrage sehr schnell ausgef√ºhrt.  Nat√ºrlich belegt der Index zus√§tzlichen Speicherplatz, aber nur sehr wenig.  Bitte beachten Sie, dass nicht alle Attribute dupliziert werden, sondern nur Alter und Kennung. <br><br>  Es ist wichtig, dass die Vorg√§nge zum Hinzuf√ºgen des Datensatzes selbst und des Index in einer Transaktion ausgef√ºhrt werden. <br><br><h2>  Zuverl√§ssigkeit </h2><br>  FoundationDB ist in C ++ geschrieben.  Die Autoren begannen 2009 damit zu arbeiten, die erste Version wurde 2013 ver√∂ffentlicht und im M√§rz 2015 kaufte Apple sie.  Drei Jahre sp√§ter √∂ffnete Apple unerwartet den Quellcode.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ger√ºchten</a> zufolge verwendet Apple es unter anderem zum Speichern von iCloud-Servicedaten. <br><br>  Erfahrene Entwickler vertrauen neuen L√∂sungen normalerweise nicht sofort.  Es kann Jahre dauern, bis sich die Technologie zuverl√§ssig etabliert und in der Produktion massiv eingesetzt wird.  Um diese Zeit zu verk√ºrzen, haben die Autoren eine interessante Erweiterung der Sprache C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow vorgenommen</a> .  Es erm√∂glicht Ihnen, die Arbeit mit unzuverl√§ssigen externen Komponenten mit der M√∂glichkeit einer vollst√§ndig vorhersehbaren Wiederholung der Programmausf√ºhrung elegant zu emulieren.  Jeder Aufruf eines Netzwerks oder einer Festplatte ist in einen Wrapper (Actor) eingeschlossen, und jeder Actor verf√ºgt √ºber mehrere Implementierungen.  Die Standardimplementierung schreibt Daten wie beabsichtigt auf die Festplatte oder in das Netzwerk.  Und der andere schreibt 999 mal von 1000 auf die Festplatte und verliert 1 mal von 1000.  Eine alternative Netzwerkimplementierung kann beispielsweise Bytes in Netzwerkpaketen austauschen.  Es gibt sogar Schauspieler, die die Arbeit eines unachtsamen Systemadministrators nachahmen.  Dadurch kann der Datenordner gel√∂scht oder zwei Ordner ausgetauscht werden.  Entwickler f√ºhren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tausende von Simulationen durch</a> , ersetzen verschiedene Akteure und verwenden Flow, um eine 100% ige Reproduzierbarkeit zu erreichen: Wenn ein Test fehlschl√§gt, k√∂nnen sie die Simulation neu starten und an derselben Stelle abst√ºrzen.  Insbesondere um die Unsicherheit zu beseitigen, die durch das Wechseln der Threads des OS-Schedulers entsteht, ist jeder FoundationDB-Prozess ausschlie√ülich Single-Threaded. <br><br>  Als ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forscher</a> , der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenverlustszenarien in fast allen g√§ngigen NoSQL-L√∂sungen entdeckte,</a> gebeten wurde, FoundationDB zu testen, lehnte er ab und stellte fest, dass er den Punkt nicht erkannte, da die Autoren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen riesigen Job machten</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie</a> viel tiefer und gr√ºndlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">testeten</a> als seine eigenen. <br><br>  Es ist √ºblich zu glauben, dass Clusterfehler zuf√§llig sind, aber erfahrene Entwickler wissen, dass dies weit davon entfernt ist.  Wenn Sie 10 Tausend Festplatten desselben Herstellers und dieselbe Anzahl anderer Festplatten haben, ist die Ausfallrate unterschiedlich.  In FoundationDB ist eine sogenannte maschinenbewusste Konfiguration m√∂glich, in der Sie dem Cluster mitteilen k√∂nnen, welche Maschinen sich im selben Rechenzentrum und welche Prozesse auf demselben Computer befinden.  Die Datenbank ber√ºcksichtigt dies bei der Verteilung der Last auf die Maschinen.  Und Maschinen in einem Cluster haben normalerweise unterschiedliche Eigenschaften.  FoundationDB ber√ºcksichtigt dies ebenfalls, untersucht die L√§nge der Anforderungswarteschlangen und verteilt die Last auf ausgeglichene Weise: Schw√§chere Computer erhalten weniger Anforderungen. <br><br>  Daher bietet FoundationDB ACID-Transaktionen und die h√∂chste Isolationsstufe Serializable auf einem Cluster von Tausenden von Computern.  Zusammen mit erstaunlicher Flexibilit√§t und hoher Leistung klingt es nach Magie.  Aber Sie m√ºssen f√ºr alles bezahlen, daher gibt es einige technologische Einschr√§nkungen. <br><br><h2>  Einschr√§nkungen </h2><br>  Zus√§tzlich zu den bereits erw√§hnten Beschr√§nkungen f√ºr die Gr√∂√üe und L√§nge der Transaktion ist es wichtig, die folgenden Merkmale zu beachten: <br><br><ul><li>  Die Abfragesprache ist nicht SQL, dh Entwickler mit SQL-Erfahrung m√ºssen neu lernen. <br></li><li>  Die Clientbibliothek unterst√ºtzt nur 5 Hochsprachen (Phyton, Ruby, Java, Golang und C).  Es gibt noch keinen offiziellen Client f√ºr C #.  Da es keine REST-API gibt, besteht die einzige M√∂glichkeit, eine andere Sprache zu unterst√ºtzen, darin, einen Wrapper √ºber die Standard-C-Bibliothek zu schreiben. <br></li><li>  Es gibt keine Freigabemechanismen. Diese Logik sollte von Ihrer Anwendung bereitgestellt werden. <br></li><li>  Das Datenspeicherformat ist nicht dokumentiert (obwohl es normalerweise auch nicht in kommerziellen Datenbanken dokumentiert ist).  Dies ist ein Risiko, denn wenn sich der Cluster pl√∂tzlich nicht mehr zusammensetzt, ist nicht sofort klar, was zu tun ist, und er muss sich mit den Quelldateien befassen. <br></li><li>  Ein streng asynchrones Programmiermodell kann Anf√§ngern kompliziert erscheinen. <br></li><li>  Sie m√ºssen st√§ndig √ºber die Idempotenz von Transaktionen nachdenken. <br></li><li>  Wenn Sie lange Transaktionen in kleine Transaktionen aufteilen m√ºssen, m√ºssen Sie sich selbst um die Integrit√§t auf globaler Ebene k√ºmmern. <br></li></ul><br>  Aus dem Englischen √ºbersetzt bedeutet ‚ÄûFoundation‚Äú ‚ÄûFoundation‚Äú, und die Autoren dieses DBMS sehen seine Rolle folgenderma√üen: Sie bieten ein hohes Ma√ü an Zuverl√§ssigkeit auf der Ebene einfacher Datens√§tze, und jede andere Datenbank kann als Add-On √ºber die Grundfunktionalit√§t implementiert werden.  So k√∂nnen Sie zus√§tzlich zu FoundationDB m√∂glicherweise verschiedene andere Ebenen erstellen - Dokumente, Grafiken usw.  Es bleibt die Frage, wie diese Ebenen skaliert werden, ohne an Leistung zu verlieren.  Zum Beispiel haben die Autoren von CockroachDB diesen Weg bereits eingeschlagen - indem sie eine SQL-Schicht √ºber der RocksDB (lokaler Schl√ºsselwertspeicher) erstellt haben und Leistungsprobleme bei relationalen Verkn√ºpfungen auftreten. <br><br>  Bisher hat Apple zwei Layer √ºber FoundationDB entwickelt und ver√∂ffentlicht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Document Layer</a> (unterst√ºtzt die MongoDB-API) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Record Layer</a> (speichert Datens√§tze als Felds√§tze im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Protokollpufferformat</a> , unterst√ºtzt Indizes und ist nur in Java verf√ºgbar).  Es ist erfreulich und angenehm √ºberraschend, dass das historisch geschlossene Unternehmen von Apple heute in die Fu√üstapfen von Google und Microsoft tritt und den Quellcode der darin verwendeten Technologien ver√∂ffentlicht. <br><br><h2>  Perspektiven </h2><br>  Es gibt einen solchen existenziellen Konflikt in der Softwareentwicklung: Das Unternehmen m√∂chte st√§ndig √Ñnderungen und Verbesserungen am Produkt.  Gleichzeitig will er zuverl√§ssige Software.  Und diese beiden Anforderungen widersprechen sich, denn wenn sich die Software √§ndert, treten Fehler auf und das Unternehmen leidet darunter.  Wenn Sie sich in Ihrem Produkt auf eine zuverl√§ssige, bew√§hrte Technologie verlassen und selbst weniger Code schreiben k√∂nnen, lohnt es sich immer, dies zu tun.  In diesem Sinne ist es trotz bestimmter Einschr√§nkungen cool, keine Kr√ºcken in verschiedene NoSQL-Datenbanken zu formen, sondern eine produktionserprobte L√∂sung mit ACID-Eigenschaften zu verwenden. <br><br>  Vor einem Jahr waren wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optimistisch</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezug</a> auf eine andere Technologie - CockroachDB, aber sie entsprach nicht unseren Leistungserwartungen.  Seitdem haben wir unseren Appetit auf die Idee einer SQL-Schicht √ºber einen verteilten Schl√ºsselwertspeicher verloren und uns daher beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TiDB</a> nicht genau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angesehen</a> .  Wir planen, FoundationDB als sekund√§re Datenbank f√ºr die gr√∂√üten Datens√§tze in unserem Projekt sorgf√§ltig zu testen.  Wenn Sie bereits Erfahrung mit der tats√§chlichen Verwendung von FoundationDB oder TiDB in der Produktion haben, freuen wir uns √ºber Ihre Meinung in den Kommentaren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441270/">https://habr.com/ru/post/de441270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441260/index.html">Wie neuronale Netzwerkgrafiken geholfen haben</a></li>
<li><a href="../de441262/index.html">Einfache und lange Aufgaben beseitigen Kandidaten besser als kurze und komplexe</a></li>
<li><a href="../de441264/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 2</a></li>
<li><a href="../de441266/index.html">Wie das tiOPF-Framework f√ºr Delphi / Lazarus funktioniert. Besuchervorlage</a></li>
<li><a href="../de441268/index.html">Ceedling + Eclipse oder Unit-Tests f√ºr Mikrocontroller</a></li>
<li><a href="../de441274/index.html">Wie man ein Tester wird - die notwendigen Kenntnisse und F√§higkeiten</a></li>
<li><a href="../de441278/index.html">So erstellen Sie eine sch√∂ne Farbpalette</a></li>
<li><a href="../de441280/index.html">GAL-Setup in der Zimbra Collaboration Suite</a></li>
<li><a href="../de441282/index.html">Tolles Interview mit dem Sch√∂pfer von Jenkins, Kohsuke Kawaguchi</a></li>
<li><a href="../de441284/index.html">Laden von Massendaten oder Wie man ein chinesisches Dorf f√ºttert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>