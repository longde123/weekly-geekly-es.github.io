<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌑 👨🏻‍🏫 👩🏿‍🎓 Schauen Sie sich zuerst Apples FoundationDB an 🚸 🍛 😸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel haben wir die Einschränkungen und Hindernisse untersucht, die auftreten, wenn Sie Daten horizontal skalieren und die ACID-Eigenscha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schauen Sie sich zuerst Apples FoundationDB an</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441270/"> Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir die Einschränkungen und Hindernisse untersucht, die auftreten, wenn Sie Daten horizontal skalieren und die ACID-Eigenschaften von Transaktionen garantieren müssen.  In diesem Artikel sprechen wir über die FoundationDB-Technologie und verstehen, wie diese Einschränkungen bei der Entwicklung geschäftskritischer Anwendungen überwunden werden können. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FoundationDB</a> ist eine verteilte NoSQL-Datenbank mit serialisierbaren ACID-Transaktionen, in der sortierte Schlüssel-Wert-Speicherpaare gespeichert sind.  Schlüssel und Werte können beliebige Folgen von Bytes sein.  Es gibt keinen einzigen Inzidenzpunkt - alle Cluster-Maschinen sind gleich.  Es selbst verteilt die Daten auf die Cluster-Server und skaliert im laufenden Betrieb: Wenn Sie dem Cluster Ressourcen hinzufügen müssen, fügen Sie einfach die Adresse des neuen Computers auf den Konfigurationsservern hinzu, und die Datenbank nimmt sie selbst auf. <a name="habracut"></a><br><br>  In FoundationDB blockieren sich Transaktionen niemals gegenseitig.  Das Lesen erfolgt über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multiversion-Versionskontrolle</a> (MVCC) und das Lesen über die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optimistische Parallelitätskontrolle</a> (OCC).  Die Entwickler behaupten, dass sich alle Schreibmaschinen im Cluster im selben Rechenzentrum befinden, die Schreiblatenz 2-3 ms und die Leselatenz weniger als eine Millisekunde beträgt.  Die Dokumentation enthält Schätzungen von 10-15 ms, was unter realen Bedingungen wahrscheinlich näher an den Ergebnissen liegt. <br><br><img src="https://habrastorage.org/webt/ob/9m/jt/ob9mjtfiyqpvxfjpjc1tp48ujho.png">  <font color="#777777">* Unterstützt keine ACID-Eigenschaften für mehrere Shards.</font> <br><br>  FoundationDB hat einen einzigartigen Vorteil - das automatische Resharding.  Das DBMS selbst sorgt für ein gleichmäßiges Laden der Computer im Cluster: Wenn ein Server voll ist, werden die Daten im Hintergrund an benachbarte Computer weitergegeben.  Gleichzeitig bleibt die Garantie für den Serialisierbarkeitsgrad für alle Transaktionen erhalten, und der einzige Effekt, der für die Kunden erkennbar ist, ist eine geringfügige Erhöhung der Latenz der Antworten.  Die Datenbank stellt sicher, dass sich die Datenmenge auf den am meisten und am wenigsten belasteten Clusterservern um nicht mehr als 5% unterscheidet. <br><br><h2>  Architektur </h2><br>  Ein FoundationDB-Cluster besteht logischerweise aus einer Reihe von Prozessen desselben Typs auf verschiedenen physischen Computern.  Prozesse haben keine eigenen Konfigurationsdateien, daher sind sie austauschbar.  Mehrere feste Prozesse haben eine dedizierte Rolle - Koordinatoren, und jeder Clusterprozess beim Start kennt seine Adressen.  Es ist wichtig, dass die Abstürze der Koordinatoren so unabhängig wie möglich sind. Daher ist es am besten, sie auf verschiedenen physischen Maschinen oder sogar in verschiedenen Rechenzentren zu platzieren. <br><br><img src="https://habrastorage.org/webt/ai/sx/qv/aisxqvwfakb618b27cl_vyjnc5a.png"><br><br>  Die Koordinatoren sind sich über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paxos-</a> Konsensalgorithmus einig.  Sie wählen den Cluster-Controller-Prozess aus, der dann den übrigen Cluster-Prozessen Rollen zuweist.  Der Cluster-Controller informiert kontinuierlich alle Koordinatoren darüber, dass er lebt.  Wenn die meisten Koordinatoren glauben, er sei tot, wählen sie einfach einen neuen aus.  Weder Cluster Controller noch Coordinators sind an der Transaktionsverarbeitung beteiligt. Ihre Hauptaufgabe besteht darin, die Situation des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gespaltenen Gehirns</a> zu beseitigen. <br><br>  Wenn ein Client eine Verbindung zur Datenbank herstellen möchte, kontaktiert er sofort alle Koordinatoren, um die Adresse des aktuellen Cluster-Controllers zu erfahren.  Wenn die meisten Antworten übereinstimmen, erhält es vom Cluster Controller die vollständige aktuelle Clusterkonfiguration (wenn sie nicht übereinstimmen, werden die Koordinatoren erneut aufgerufen). <br><br><img src="https://habrastorage.org/webt/ig/g6/qq/igg6qqffqlxbbrd-cpchddyktbu.png"><br><br>  Cluster Controller kennt die Gesamtzahl der verfügbaren Prozesse und verteilt die Rollen: Diese 5 sind Proxy, diese 2 sind Resolver, dieser ist Master.  Und wenn einer von ihnen stirbt, wird er sofort einen Ersatz für ihn finden und die notwendige Rolle einem willkürlichen freien Prozess zuweisen.  Dies alles geschieht im Hintergrund, für den Anwendungsprogrammierer unsichtbar. <br><br>  Der Master-Prozess ist verantwortlich für die Nummer der aktuellen Version des Datensatzes (sie steigt mit jedem Datensatz in der Datenbank) sowie für die Verteilung vieler Schlüssel an Speicherserver und die Rateneinschränkung (künstlich geringere Leistung bei hoher Last: Wenn der Cluster weiß, dass der Client wird viele kleine Anfragen stellen, er wird warten, sie gruppieren und das ganze Paket auf einmal beantworten). <br><br>  Transaktionsprotokollierung und Speicherung sind zwei unabhängige Speichersubsysteme.  Der erste ist der temporäre Speicher zum schnellen Schreiben von Daten auf die Festplatte in der Reihenfolge des Empfangs, der zweite ist der permanente Speicher, bei dem die Daten auf der Festplatte in aufsteigender Reihenfolge der Schlüssel sortiert werden.  Bei jedem Transaktions-Commit müssen mindestens drei tLog-Prozesse Daten speichern, bevor der Cluster dem Client den Erfolg meldet.  Parallel dazu werden Daten im Hintergrund von tLog-Servern auf Speicherserver verschoben (Speicher, auf dem auch redundant ist). <br><br><h2>  Anfrage bearbeiten </h2><br>  Alle Clientanforderungen verarbeiten Proxy-Prozesse.  Beim Öffnen einer Transaktion greift der Client auf einen beliebigen Proxy zu, fragt alle anderen Proxys ab und gibt die aktuelle Versionsnummer der Clusterdaten zurück.  Alle nachfolgenden Ablesungen erfolgen bei dieser Versionsnummer.  Wenn ein anderer Client die Daten nach dem Öffnen der Transaktion notiert hat, werden die Änderungen einfach nicht angezeigt. <br><br>  Das Aufzeichnen einer Transaktion ist etwas komplizierter, da Sie Konflikte lösen müssen.  Dies schließt den Resolver-Prozess ein, bei dem alle geänderten Schlüssel für einen bestimmten Zeitraum im Speicher gespeichert werden.  Wenn der Client die Festschreibungstransaktion abschließt, prüft der Resolver, ob die gelesenen Daten veraltet sind.  (Das heißt, ob die Transaktion, die später als meine geöffnet wurde, abgeschlossen wurde und die von mir gelesenen Schlüssel geändert hat.) In diesem Fall wird die Transaktion zurückgesetzt und die Clientbibliothek selbst (!) Führt einen zweiten Festschreibungsversuch durch.  Das einzige, woran der Entwickler denken sollte, ist, dass die Transaktionen idempotent sind, dh eine wiederholte Verwendung sollte zu einem identischen Ergebnis führen.  Eine Möglichkeit, dies zu erreichen, besteht darin, einen eindeutigen Wert innerhalb der Transaktion zu speichern und zu Beginn der Transaktion deren Vorhandensein in der Datenbank zu überprüfen. <br><br><img src="https://habrastorage.org/webt/h6/sl/tn/h6sltnc7mmauiguiymix7msytv0.png"><br><br>  Wie in jedem Client-Server-System gibt es Situationen, in denen die Transaktion erfolgreich abgeschlossen wurde, der Client jedoch aufgrund einer Unterbrechung keine Bestätigung erhalten hat.  Die Client-Bibliothek behandelt sie wie jeden anderen Fehler - sie versucht es einfach erneut.  Dies könnte möglicherweise zur erneuten Ausführung der gesamten Transaktion führen.  Wenn die Transaktion jedoch idempotent ist, gibt es kein Problem damit - es hat keinen Einfluss auf das Endergebnis. <br><br><h2>  Skalieren </h2><br>  In einem Speichersubsystem können sich Tausende von Servern befinden.  Welche von ihnen sollte ein Kunde kontaktieren, wenn er Daten zu einem bestimmten Schlüssel benötigt?  Vom Cluster Controller kennt der Client die vollständige Konfiguration des gesamten Clusters und enthält Schlüsselbereiche auf jedem Speicherserver.  Daher greift es einfach ohne Zwischenanforderungen direkt auf die gewünschten Speicherserver zu. <br><br>  Wenn der gewünschte Speicherserver nicht verfügbar ist, übernimmt die Clientbibliothek eine neue Konfiguration von Cluster Controller.  Wenn der Cluster infolge eines Serverabsturzes erkennt, dass die Redundanz nicht ausreicht, beginnt er sofort, einen neuen Knoten aus Teilen eines anderen Speichers zu sammeln. <br><br>  Angenommen, Sie speichern ein Gigabyte an Daten in einer Transaktion.  Wie können Sie schnell antworten?  Auf keinen Fall hat FoundationDB die Größe einer Transaktion einfach auf 10 Megabyte begrenzt.  Darüber hinaus ist dies eine Einschränkung für alle Daten, die die Transaktion <i>betrifft</i> - Lesen oder Schreiben.  Jeder Eintrag in der Datenbank ist ebenfalls begrenzt - der Schlüssel darf 10 Kilobyte nicht überschreiten, der Wert beträgt 100 Kilobyte.  (Für eine optimale Leistung empfehlen Entwickler Schlüssel mit einer Länge von 32 Byte und Werte mit einer Länge von 10 Kilobyte.) <br><br>  Jede Transaktion kann möglicherweise zu einer Konfliktquelle werden und muss dann zurückgesetzt werden.  Aus Gründen der Geschwindigkeit ist es daher sinnvoll, die aktuellen Änderungen im RAM und nicht auf der Festplatte beizubehalten, bis der Commit-Befehl eintrifft.  Angenommen, Sie schreiben Daten mit einer Last von 1 GB / Sekunde in eine Datenbank.  Im Extremfall weist Ihr Cluster dann jede Sekunde 3 GB RAM zu (wir schreiben Transaktionen auf 3 Computern).  Wie kann ein solches Lawinenwachstum des verwendeten Speichers begrenzt werden?  Es ist sehr einfach, die maximale Transaktionszeit zu begrenzen.  In FoundationDB kann eine Transaktion nicht länger als 5 Sekunden dauern.  Wenn der Client 5 Sekunden nach dem Öffnen der Transaktion versucht, auf die Datenbank zuzugreifen, ignoriert der Cluster alle seine Befehle, bis er einen neuen öffnet. <br><br><h2>  Indizes </h2><br>  Angenommen, Sie führen eine Liste mit Personen, jede Person hat eine eindeutige Kennung, wir verwenden diese als Schlüssel und in den Wert schreiben wir alle anderen Attribute - Name, Geschlecht, Alter usw. <br><table><tbody><tr><td>  Schlüssel </td><td>  Wert </td></tr><tr><td>  12345 </td><td>  (Ivanov Ivan Ivanovich, M, 35) </td></tr></tbody></table><br>  Wie bekomme ich eine Liste aller Personen, die 30 Jahre alt sind, ohne umfassende Suche?  In der Regel wird hierfür ein Index in der Datenbank erstellt.  Ein Index ist eine weitere Datenansicht, mit der schnell nach zusätzlichen Attributen gesucht werden kann.  Wir können einfach Einträge des Formulars hinzufügen: <br><table><tbody><tr><td>  Schlüssel </td><td>  Wert </td></tr><tr><td>  (35, 12345) </td><td>  '' </td></tr></tbody></table><br>  Um die gewünschte Liste zu erhalten, müssen Sie nur noch den Tastenbereich (30, *) durchsuchen.  Da FoundationDB nach Schlüssel sortierte Daten speichert, wird eine solche Abfrage sehr schnell ausgeführt.  Natürlich belegt der Index zusätzlichen Speicherplatz, aber nur sehr wenig.  Bitte beachten Sie, dass nicht alle Attribute dupliziert werden, sondern nur Alter und Kennung. <br><br>  Es ist wichtig, dass die Vorgänge zum Hinzufügen des Datensatzes selbst und des Index in einer Transaktion ausgeführt werden. <br><br><h2>  Zuverlässigkeit </h2><br>  FoundationDB ist in C ++ geschrieben.  Die Autoren begannen 2009 damit zu arbeiten, die erste Version wurde 2013 veröffentlicht und im März 2015 kaufte Apple sie.  Drei Jahre später öffnete Apple unerwartet den Quellcode.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gerüchten</a> zufolge verwendet Apple es unter anderem zum Speichern von iCloud-Servicedaten. <br><br>  Erfahrene Entwickler vertrauen neuen Lösungen normalerweise nicht sofort.  Es kann Jahre dauern, bis sich die Technologie zuverlässig etabliert und in der Produktion massiv eingesetzt wird.  Um diese Zeit zu verkürzen, haben die Autoren eine interessante Erweiterung der Sprache C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Flow vorgenommen</a> .  Es ermöglicht Ihnen, die Arbeit mit unzuverlässigen externen Komponenten mit der Möglichkeit einer vollständig vorhersehbaren Wiederholung der Programmausführung elegant zu emulieren.  Jeder Aufruf eines Netzwerks oder einer Festplatte ist in einen Wrapper (Actor) eingeschlossen, und jeder Actor verfügt über mehrere Implementierungen.  Die Standardimplementierung schreibt Daten wie beabsichtigt auf die Festplatte oder in das Netzwerk.  Und der andere schreibt 999 mal von 1000 auf die Festplatte und verliert 1 mal von 1000.  Eine alternative Netzwerkimplementierung kann beispielsweise Bytes in Netzwerkpaketen austauschen.  Es gibt sogar Schauspieler, die die Arbeit eines unachtsamen Systemadministrators nachahmen.  Dadurch kann der Datenordner gelöscht oder zwei Ordner ausgetauscht werden.  Entwickler führen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tausende von Simulationen durch</a> , ersetzen verschiedene Akteure und verwenden Flow, um eine 100% ige Reproduzierbarkeit zu erreichen: Wenn ein Test fehlschlägt, können sie die Simulation neu starten und an derselben Stelle abstürzen.  Insbesondere um die Unsicherheit zu beseitigen, die durch das Wechseln der Threads des OS-Schedulers entsteht, ist jeder FoundationDB-Prozess ausschließlich Single-Threaded. <br><br>  Als ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forscher</a> , der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenverlustszenarien in fast allen gängigen NoSQL-Lösungen entdeckte,</a> gebeten wurde, FoundationDB zu testen, lehnte er ab und stellte fest, dass er den Punkt nicht erkannte, da die Autoren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen riesigen Job machten</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sie</a> viel tiefer und gründlicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">testeten</a> als seine eigenen. <br><br>  Es ist üblich zu glauben, dass Clusterfehler zufällig sind, aber erfahrene Entwickler wissen, dass dies weit davon entfernt ist.  Wenn Sie 10 Tausend Festplatten desselben Herstellers und dieselbe Anzahl anderer Festplatten haben, ist die Ausfallrate unterschiedlich.  In FoundationDB ist eine sogenannte maschinenbewusste Konfiguration möglich, in der Sie dem Cluster mitteilen können, welche Maschinen sich im selben Rechenzentrum und welche Prozesse auf demselben Computer befinden.  Die Datenbank berücksichtigt dies bei der Verteilung der Last auf die Maschinen.  Und Maschinen in einem Cluster haben normalerweise unterschiedliche Eigenschaften.  FoundationDB berücksichtigt dies ebenfalls, untersucht die Länge der Anforderungswarteschlangen und verteilt die Last auf ausgeglichene Weise: Schwächere Computer erhalten weniger Anforderungen. <br><br>  Daher bietet FoundationDB ACID-Transaktionen und die höchste Isolationsstufe Serializable auf einem Cluster von Tausenden von Computern.  Zusammen mit erstaunlicher Flexibilität und hoher Leistung klingt es nach Magie.  Aber Sie müssen für alles bezahlen, daher gibt es einige technologische Einschränkungen. <br><br><h2>  Einschränkungen </h2><br>  Zusätzlich zu den bereits erwähnten Beschränkungen für die Größe und Länge der Transaktion ist es wichtig, die folgenden Merkmale zu beachten: <br><br><ul><li>  Die Abfragesprache ist nicht SQL, dh Entwickler mit SQL-Erfahrung müssen neu lernen. <br></li><li>  Die Clientbibliothek unterstützt nur 5 Hochsprachen (Phyton, Ruby, Java, Golang und C).  Es gibt noch keinen offiziellen Client für C #.  Da es keine REST-API gibt, besteht die einzige Möglichkeit, eine andere Sprache zu unterstützen, darin, einen Wrapper über die Standard-C-Bibliothek zu schreiben. <br></li><li>  Es gibt keine Freigabemechanismen. Diese Logik sollte von Ihrer Anwendung bereitgestellt werden. <br></li><li>  Das Datenspeicherformat ist nicht dokumentiert (obwohl es normalerweise auch nicht in kommerziellen Datenbanken dokumentiert ist).  Dies ist ein Risiko, denn wenn sich der Cluster plötzlich nicht mehr zusammensetzt, ist nicht sofort klar, was zu tun ist, und er muss sich mit den Quelldateien befassen. <br></li><li>  Ein streng asynchrones Programmiermodell kann Anfängern kompliziert erscheinen. <br></li><li>  Sie müssen ständig über die Idempotenz von Transaktionen nachdenken. <br></li><li>  Wenn Sie lange Transaktionen in kleine Transaktionen aufteilen müssen, müssen Sie sich selbst um die Integrität auf globaler Ebene kümmern. <br></li></ul><br>  Aus dem Englischen übersetzt bedeutet „Foundation“ „Foundation“, und die Autoren dieses DBMS sehen seine Rolle folgendermaßen: Sie bieten ein hohes Maß an Zuverlässigkeit auf der Ebene einfacher Datensätze, und jede andere Datenbank kann als Add-On über die Grundfunktionalität implementiert werden.  So können Sie zusätzlich zu FoundationDB möglicherweise verschiedene andere Ebenen erstellen - Dokumente, Grafiken usw.  Es bleibt die Frage, wie diese Ebenen skaliert werden, ohne an Leistung zu verlieren.  Zum Beispiel haben die Autoren von CockroachDB diesen Weg bereits eingeschlagen - indem sie eine SQL-Schicht über der RocksDB (lokaler Schlüsselwertspeicher) erstellt haben und Leistungsprobleme bei relationalen Verknüpfungen auftreten. <br><br>  Bisher hat Apple zwei Layer über FoundationDB entwickelt und veröffentlicht: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Document Layer</a> (unterstützt die MongoDB-API) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Record Layer</a> (speichert Datensätze als Feldsätze im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Protokollpufferformat</a> , unterstützt Indizes und ist nur in Java verfügbar).  Es ist erfreulich und angenehm überraschend, dass das historisch geschlossene Unternehmen von Apple heute in die Fußstapfen von Google und Microsoft tritt und den Quellcode der darin verwendeten Technologien veröffentlicht. <br><br><h2>  Perspektiven </h2><br>  Es gibt einen solchen existenziellen Konflikt in der Softwareentwicklung: Das Unternehmen möchte ständig Änderungen und Verbesserungen am Produkt.  Gleichzeitig will er zuverlässige Software.  Und diese beiden Anforderungen widersprechen sich, denn wenn sich die Software ändert, treten Fehler auf und das Unternehmen leidet darunter.  Wenn Sie sich in Ihrem Produkt auf eine zuverlässige, bewährte Technologie verlassen und selbst weniger Code schreiben können, lohnt es sich immer, dies zu tun.  In diesem Sinne ist es trotz bestimmter Einschränkungen cool, keine Krücken in verschiedene NoSQL-Datenbanken zu formen, sondern eine produktionserprobte Lösung mit ACID-Eigenschaften zu verwenden. <br><br>  Vor einem Jahr waren wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optimistisch</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bezug</a> auf eine andere Technologie - CockroachDB, aber sie entsprach nicht unseren Leistungserwartungen.  Seitdem haben wir unseren Appetit auf die Idee einer SQL-Schicht über einen verteilten Schlüsselwertspeicher verloren und uns daher beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TiDB</a> nicht genau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angesehen</a> .  Wir planen, FoundationDB als sekundäre Datenbank für die größten Datensätze in unserem Projekt sorgfältig zu testen.  Wenn Sie bereits Erfahrung mit der tatsächlichen Verwendung von FoundationDB oder TiDB in der Produktion haben, freuen wir uns über Ihre Meinung in den Kommentaren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441270/">https://habr.com/ru/post/de441270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441260/index.html">Wie neuronale Netzwerkgrafiken geholfen haben</a></li>
<li><a href="../de441262/index.html">Einfache und lange Aufgaben beseitigen Kandidaten besser als kurze und komplexe</a></li>
<li><a href="../de441264/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 2</a></li>
<li><a href="../de441266/index.html">Wie das tiOPF-Framework für Delphi / Lazarus funktioniert. Besuchervorlage</a></li>
<li><a href="../de441268/index.html">Ceedling + Eclipse oder Unit-Tests für Mikrocontroller</a></li>
<li><a href="../de441274/index.html">Wie man ein Tester wird - die notwendigen Kenntnisse und Fähigkeiten</a></li>
<li><a href="../de441278/index.html">So erstellen Sie eine schöne Farbpalette</a></li>
<li><a href="../de441280/index.html">GAL-Setup in der Zimbra Collaboration Suite</a></li>
<li><a href="../de441282/index.html">Tolles Interview mit dem Schöpfer von Jenkins, Kohsuke Kawaguchi</a></li>
<li><a href="../de441284/index.html">Laden von Massendaten oder Wie man ein chinesisches Dorf füttert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>