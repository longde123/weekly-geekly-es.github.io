<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🌾 🦇 🌶️ NoVerify: linter untuk PHP dari Tim VKontakte sekarang berada di domain publik 🧛🏼 👞 👨🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya akan memberi tahu Anda bagaimana kami berhasil menulis linter yang ternyata cukup cepat untuk memeriksa perubahan selama setiap push git dan mela...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NoVerify: linter untuk PHP dari Tim VKontakte sekarang berada di domain publik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/442284/"><img src="https://habrastorage.org/webt/zu/fg/gw/zufggwwy-grc8n2umc_p0_ioskw.png"><br><br>  Saya akan memberi tahu Anda bagaimana kami berhasil menulis linter yang ternyata cukup cepat untuk memeriksa perubahan selama setiap push git dan melakukannya dalam 5-10 detik dengan basis kode 5 juta baris dalam PHP.  Kami menyebutnya NoVerify. <br><br>  NoVerify mendukung hal-hal dasar seperti transisi ke definisi dan mencari kegunaan dan mampu bekerja dalam mode <a href="">Server Bahasa</a> .  Pertama-tama, alat kami berfokus pada pencarian kesalahan potensial, tetapi juga dapat memeriksa gaya.  Hari ini, kode sumbernya muncul di open-source di GitHub.  Cari tautannya di akhir artikel. <br><a name="habracut"></a><br><h2>  Mengapa kita membutuhkan linter kita </h2><br>  Pada pertengahan 2018, kami memutuskan sudah waktunya untuk mengimplementasikan linter untuk kode PHP.  Ada dua tujuan: untuk mengurangi jumlah kesalahan yang dilihat pengguna, dan lebih ketat memantau kepatuhan dengan gaya kode.  Penekanan utama adalah pada pencegahan kesalahan khas: keberadaan variabel yang tidak dideklarasikan dan tidak terpakai dalam kode, kode yang tidak terjangkau, dan lainnya.  Saya juga ingin penganalisa statis bekerja secepat mungkin pada basis kode kami (5-6 juta baris kode PHP pada saat penulisan). <br><br>  Seperti yang mungkin Anda ketahui, kode sumber untuk sebagian besar situs ditulis dalam PHP dan dikompilasi menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KPHP</a> , jadi akan logis untuk menambahkan cek ini ke kompiler.  Namun pada kenyataannya, tidak semua kode masuk akal untuk dijalankan melalui KPHP - misalnya, kompiler tidak kompatibel dengan perpustakaan pihak ketiga, jadi untuk beberapa bagian situs PHP biasa masih digunakan.  Mereka juga penting dan harus diperiksa oleh linter, jadi, sayangnya, tidak ada cara untuk mengintegrasikannya ke KPHP. <br><br><h2>  Mengapa NoVerify </h2><br>  Mengingat jumlah kode PHP (saya akan mengingatkan Anda bahwa ini adalah 5-6 juta baris), tidak mungkin untuk "memperbaikinya" segera sehingga melewati pemeriksaan kami di linter.  Namun demikian, saya ingin kode perubahan secara bertahap menjadi lebih bersih dan lebih ketat mengikuti standar pengkodean, dan juga mengandung lebih sedikit kesalahan.  Oleh karena itu, kami memutuskan bahwa linter harus dapat memeriksa perubahan yang akan diluncurkan oleh pengembang, dan tidak bersumpah pada yang lain. <br><br>  Untuk melakukan ini, linter perlu mengindeks seluruh proyek, menganalisis file sepenuhnya sebelum dan setelah perubahan, dan menghitung perbedaan antara peringatan yang dihasilkan.  Peringatan baru ditampilkan kepada pengembang, dan kami meminta mereka untuk memperbaikinya sebelum push dapat dilakukan. <br><br>  Tetapi ada situasi ketika perilaku ini tidak diinginkan, dan kemudian pengembang dapat mendorong tanpa kait lokal - menggunakan <code>git push --no-verify</code> .  Opsi <code>--no-verify</code> dan memberi nama ke linter :) <br><br><h2>  Apa alternatifnya </h2><br>  Basis kode dalam VK menggunakan OOP kecil dan pada dasarnya terdiri dari fungsi dan kelas dengan metode statis.  Jika kelas dalam PHP mendukung pengisian otomatis, maka fungsi tidak.  Oleh karena itu, kami tidak dapat menggunakan analisis statis tanpa modifikasi signifikan, yang mendasarkan pekerjaan mereka pada fakta bahwa pengisian otomatis akan memuat semua kode yang hilang.  Linter seperti itu, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mazmur dari Vimeo</a> . <br><br>  Kami memeriksa alat analisis statis berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHPStan</a> - single-threaded, membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengisian</a> otomatis, analisis basis kode telah mencapai 30% dalam setengah jam; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phan</a> - bahkan dalam mode cepat dengan 20 proses, analisis terhenti sebesar 5% setelah 20 menit; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mazmur</a> - membutuhkan pengisian otomatis, analisis membutuhkan waktu 10 menit (saya masih ingin menjadi lebih cepat); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHPCS</a> - memeriksa gayanya, tetapi bukan logika; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">phpcf</a> - hanya memeriksa untuk pemformatan. </li></ul><br>  Seperti yang dapat Anda tebak dari judul artikel, tidak ada alat ini yang memenuhi persyaratan kami, jadi kami menulis sendiri. <br><br><h2>  Bagaimana prototipe dibuat? </h2><br>  Pertama, kami memutuskan untuk membuat prototipe kecil untuk memahami apakah perlu mencoba membuat linter yang lengkap.  Karena salah satu persyaratan penting untuk linter adalah kecepatannya, bukan PHP yang kami pilih Go.  "Cepat" adalah untuk memberikan umpan balik kepada pengembang secepat mungkin, sebaiknya dalam waktu tidak lebih dari 10-20 detik.  Kalau tidak, siklus "koreksi kode, jalankan linter lagi" mulai secara signifikan memperlambat pengembangan dan merusak suasana hati orang :) <br><br>  Karena Go dipilih untuk prototipe, Anda memerlukan parser PHP.  Ada beberapa di antaranya, tetapi proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">php-parser</a> tampaknya paling matang bagi kami.  Parser ini tidak sempurna dan masih sedang dikembangkan, tetapi untuk tujuan kami cukup cocok. <br><br>  Untuk prototipe, diputuskan untuk mencoba mengimplementasikan salah satu yang paling sederhana, sekilas, inspeksi: akses ke variabel yang tidak ditentukan. <br><br>  Gagasan dasar untuk mengimplementasikan inspeksi semacam itu terlihat sederhana: untuk setiap cabang (misalnya, untuk jika), buat cakupan bersarang terpisah dan gabungkan jenis variabel saat keluar dari sana.  Contoh: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  : { $a: int } } else { $b = "test"; $a = "another_test"; //  : { $b: string, $a: string } } //   : { $b: string?, $a: int|string } echo $a, $b; //       , //   $b   </span></span></code> </pre><br>  Itu terlihat sederhana, bukan?  Dalam kasus pernyataan bersyarat biasa, semuanya bekerja dengan baik.  Tetapi kita harus menangani, misalnya, beralih tanpa putus; <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (rand()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: $a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// { $a: int } case 2: $b = 2; // { $a: int, $b: int } default: $c = 3; // { $a: int, $b: int, $c: int } } // { $a: int?, $b: int?, $c: int }</span></span></code> </pre><br>  Tidak segera jelas dari kode bahwa $ c akan selalu didefinisikan.  Secara khusus, contoh ini fiktif, tetapi menggambarkan dengan baik apa saat-saat sulit bagi orang yang suka (dan untuk orang dalam kasus ini juga). <br><br>  Pertimbangkan contoh yang lebih kompleks: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> exec(<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>, $out, $retval); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $out, $retval; <span class="hljs-comment"><span class="hljs-comment">// { $out: ???, $retval: ??? }</span></span></code> </pre><br>  Tanpa mengetahui tanda tangan dari fungsi exec, tidak dapat dikatakan apakah $ out dan $ retval akan ditentukan.  Tanda tangan dari fungsi-fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> dapat diambil dari repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/JetBrains/phpstorm-stubs</a> .  Tetapi masalah yang sama akan terjadi ketika memanggil fungsi yang ditentukan pengguna, dan tanda tangannya hanya dapat ditemukan dengan mengindeks seluruh proyek.  Fungsi exec mengambil argumen kedua dan ketiga dengan referensi, yang berarti variabel $ out dan $ retval dapat didefinisikan.  Di sini, mengakses variabel-variabel ini tidak selalu merupakan kesalahan, dan linter tidak boleh bersumpah pada kode tersebut. <br><br>  Masalah serupa dengan passing link implisit muncul dengan metode, tetapi pada saat yang sama, kebutuhan untuk menyimpulkan tipe variabel ditambahkan: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rand()) { $a = some_func(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $a = other_func(); } $a-&gt;some_method($b); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $b;</code> </pre><br>  Kita perlu mengetahui tipe apa yang mengembalikan fungsi some_func () dan other_func () untuk kemudian menemukan metode yang disebut some_method di kelas-kelas ini.  Hanya dengan begitu kita dapat mengatakan apakah variabel $ b akan didefinisikan atau tidak.  Situasi ini diperumit oleh fakta bahwa seringkali fungsi dan metode sederhana tidak memiliki anotasi phpdoc, jadi Anda masih harus dapat menghitung jenis fungsi dan metode berdasarkan implementasinya. <br><br>  Ketika mengembangkan prototipe, saya harus menerapkan sekitar setengah dari semua fungsi sehingga pemeriksaan paling sederhana bekerja sebagaimana mestinya. <br><br><h2>  Bekerja sebagai server bahasa </h2><br>  Untuk membuatnya lebih mudah untuk men-debug logika linter dan lebih mudah untuk melihat peringatan yang dikeluarkannya, kami memutuskan untuk menambahkan mode operasi sebagai <a href="">server bahasa untuk PHP</a> .  Dalam mode integrasi dengan Visual Studio Code, tampilannya seperti ini: <br><br><img src="https://habrastorage.org/webt/dr/ig/vj/drigvj1bhifibymyhcl_vzjq7q8.jpeg"><br><br>  Dalam mode ini, akan lebih mudah untuk menguji hipotesis dan menguji kasus yang rumit (setelah itu Anda perlu menulis tes, tentu saja).  Juga bagus untuk menguji kinerja: bahkan pada file besar php-parser on Go menunjukkan kecepatan yang baik. <br><br>  Dukungan server bahasa jauh dari ideal, karena tujuan utamanya adalah untuk men-debug aturan linter.  Namun, dalam mode ini ada beberapa fitur tambahan: <br><br><ol><li>  Kiat untuk nama variabel, konstanta, fungsi, properti, dan metode. </li><li>  Sorot jenis-jenis variabel turunan. </li><li>  Pergi ke definisi. </li><li>  Cari kegunaan. </li></ol><br><h2>  Inferensi tipe "malas" </h2><br>  Dalam mode server bahasa, yang berikut ini diperlukan untuk bekerja: Anda mengubah kode dalam satu file, dan kemudian, ketika Anda beralih ke yang lain, Anda harus bekerja dengan informasi yang sudah diperbarui tentang jenis yang dikembalikan dalam fungsi atau metode.  Bayangkan file yang sedang diedit dalam urutan berikut: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//  A.php,  1 class A { /** @var int */ public $prop; } //  B.php,   class B { public static function something() { $obj = new A; return $obj-&gt;prop; } } //  C.php,   $c = B::something(); // $c   int //  A.php,  2 class A { /** @var string &lt;---   string */ public $prop; } //  C.php,   $c = B::something(); // $c   string,   B.php,  C.php  </span></span></code> </pre><br>  Mengingat bahwa kami tidak memaksa pengembang untuk selalu menulis PHPDoc (terutama dalam kasus sederhana seperti itu), kami memerlukan cara untuk menyimpan informasi tentang apa yang mengembalikan fungsi B :: something ().  Sehingga ketika file A.php berubah, ketikkan informasi dalam file C.php segera. <br><br>  Salah satu solusi yang mungkin adalah dengan menyimpan "tipe malas."  Misalnya, tipe kembalinya dari metode B :: something () sebenarnya adalah tipe ekspresi (new A) -&gt; prop.  Dalam formulir ini, linter menyimpan informasi tentang jenisnya, dan berkat ini, Anda dapat menyimpan semua informasi meta untuk setiap file dan memperbaruinya hanya ketika file ini berubah.  Ini harus dilakukan dengan hati-hati agar informasi yang terlalu spesifik tentang jenis tidak bocor.  Juga perlu untuk mengubah versi cache ketika tipe logika inferensi berubah.  Namun demikian, cache semacam itu mempercepat fase pengindeksan (yang akan saya bahas nanti) 5-10 kali dibandingkan dengan penguraian berulang semua file. <br><br><h2>  Dua fase kerja: pengindeksan dan analisis </h2><br>  Seperti yang kita ingat, bahkan untuk analisis kode paling sederhana, informasi diperlukan setidaknya tentang semua fungsi dan metode dalam proyek.  Ini berarti Anda tidak dapat menganalisis hanya satu file secara terpisah dari proyek.  Namun - bahwa ini tidak dapat dilakukan dalam satu pass: misalnya, PHP memungkinkan Anda untuk mengakses fungsi yang dinyatakan lebih lanjut dalam file. <br><br>  Karena keterbatasan ini, operasi linter terdiri dari dua fase: pengindeksan primer dan analisis selanjutnya dari hanya file yang diperlukan.  Sekarang, lebih lanjut tentang dua fase ini. <br><br><h3>  Fase pengindeksan </h3><br>  Pada fase ini, semua file diurai dan analisis lokal dari kode metode dan fungsi, serta kode di tingkat atas dilakukan (misalnya, untuk menentukan jenis variabel global).  Informasi tentang variabel global yang dinyatakan, konstanta, fungsi, kelas dan metode mereka dikumpulkan dan ditulis ke cache.  Untuk setiap file dalam proyek, cache adalah file terpisah pada disk. <br><br>  Kamus global dari semua meta-informasi tentang proyek, yang tidak berubah di masa depan, * dikompilasi dari setiap bagian. <br><br>  <i>* Selain mode operasi sebagai server bahasa, saat pengindeksan dan analisis file yang diubah dilakukan untuk setiap pengeditan.</i> <br><br><h3>  Fase analisis </h3><br>  Pada fase ini, kita dapat menggunakan meta-informasi (tentang fungsi, kelas ...) dan sudah langsung menganalisis kode.  Berikut adalah daftar yang dapat diperiksa NoVerify secara default: <br><br><ul><li>  kode yang tidak terjangkau; </li><li>  akses ke objek sebagai array; </li><li>  jumlah argumen saat memanggil fungsi tidak cukup; </li><li>  memanggil metode / fungsi yang tidak ditentukan; </li><li>  akses ke properti kelas yang hilang / konstan; </li><li>  kurangnya kelas; </li><li>  PHPDoc tidak valid </li><li>  akses ke variabel yang tidak ditentukan; </li><li>  akses ke variabel yang tidak selalu ditentukan; </li><li>  kurangnya "istirahat;"  setelah kasus dalam switch / konstruksi kasus; </li><li>  kesalahan sintaksis </li><li>  variabel yang tidak digunakan. </li></ul><br>  Daftarnya cukup pendek, tetapi Anda dapat menambahkan cek khusus untuk proyek Anda. <br><br>  Selama operasi linter, ternyata pemeriksaan yang paling berguna hanyalah yang terakhir (variabel yang tidak digunakan).  Ini sering terjadi ketika Anda memperbaiki kode (atau menulis yang baru) dan menyegelnya dalam nama variabel: kode ini valid dari sudut pandang PHP, tetapi salah dalam logika. <br><br><h2>  Kecepatan kerja </h2><br>  Berapa lama perubahan yang ingin kami dorong diperiksa?  Itu semua tergantung pada jumlah file.  Dengan NoVerify, prosesnya bisa memakan waktu hingga satu menit (ini terjadi ketika saya mengubah 1400 file dalam repositori), tetapi jika ada beberapa pengeditan, maka biasanya semua pemeriksaan lulus dalam 4-5 detik.  Selama ini, proyek ini sepenuhnya diindeks, mem-parsing file baru, serta analisisnya.  Kami cukup mampu membuat linter untuk PHP, yang bekerja dengan cepat bahkan dengan basis kode besar kami. <br><br><h2>  Apa hasilnya? </h2><br>  Karena solusinya ditulis dalam Go, maka diperlukan untuk menggunakan repositori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/JetBrains/phpstorm-stubs</a> agar memiliki definisi semua fungsi dan kelas yang dibangun dalam PHP.  Sebagai imbalannya, kami mendapat kecepatan kerja yang tinggi (mengindeks 1 juta garis per detik, analisis 100 ribu garis per detik) dan mampu menambahkan cek dengan linter sebagai salah satu langkah pertama dalam kait kait git. <br><br>  Basis yang nyaman dikembangkan untuk membuat inspeksi baru dan tingkat pemahaman kode yang dekat dengan PHPStorm tercapai.  Karena kenyataan bahwa di luar kotak mode dengan perhitungan berbeda didukung, dimungkinkan untuk secara bertahap meningkatkan kode, menghindari konstruksi baru yang berpotensi bermasalah dalam kode baru. <br><br>  Menghitung diff tidak ideal: misalnya, jika satu file besar dibagi menjadi beberapa yang kecil, maka git, dan karena itu NoVerify, tidak akan dapat menentukan bahwa kode tersebut dipindahkan, dan linter akan perlu memperbaiki semua masalah yang ditemukan.  Dalam hal ini, perhitungan diff mencegah refactoring skala besar, sehingga dalam kasus seperti itu sering dinonaktifkan. <br><br>  Menulis linter on Go memiliki keunggulan lain: tidak hanya AST parser lebih cepat dan mengkonsumsi lebih sedikit memori daripada PHP, tetapi analisis selanjutnya juga sangat cepat dibandingkan dengan apa pun yang dapat dilakukan dalam PHP.  Ini berarti bahwa linter kami dapat melakukan analisis kode yang lebih kompleks dan lebih dalam, sambil mempertahankan kinerja tinggi (misalnya, fitur "tipe malas" memerlukan sejumlah besar perhitungan dalam proses). <br><br><h2>  Sumber terbuka </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NoVerify tersedia di open source di GitHub</a> <br><br>  Nikmati penggunaan Anda dalam proyek Anda! <br><br>  <b>UPD:</b> Saya menyiapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo yang berfungsi melalui WebAssembly</a> .  Satu-satunya batasan demo ini adalah tidak adanya definisi fungsi dari phpstorm-stubs, sehingga linter akan bersumpah pada fungsi bawaan. <br><br>  <i>Yuri Nasretdinov, pengembang departemen infrastruktur VKontakte</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442284/">https://habr.com/ru/post/id442284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442272/index.html">Go + = versi paket</a></li>
<li><a href="../id442274/index.html">Dart 2. Pemrograman Asinkron: Aliran Data</a></li>
<li><a href="../id442278/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 6</a></li>
<li><a href="../id442280/index.html">Pembelajaran Mesin di Dodo. Cara meluncurkan arah baru jika Anda seorang pengembang</a></li>
<li><a href="../id442282/index.html">Dart 2. Pemrograman asinkron: masa depan</a></li>
<li><a href="../id442286/index.html">Dokter mata Rusia berbicara tentang visi bionik. Aplikasi mobile baru menunjukkan karya siber</a></li>
<li><a href="../id442288/index.html">Radiasi: sumber</a></li>
<li><a href="../id442290/index.html">Membuat ST-Link V2.1 dari Bahasa Cina ST-Link V2</a></li>
<li><a href="../id442292/index.html">Magang Sberseason: Python, UX / UI, Data dan banyak lagi untuk siswa</a></li>
<li><a href="../id442294/index.html">Apa Oleg Artamonov sedikit salah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>