<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÇÔ∏è üë©üèª‚Äçüîß üëç BTRFS para o menor üëà üßòüèø üîé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bom dia, Khabravchane. Trabalho na Veeam Software e sou um dos desenvolvedores da nossa solu√ß√£o de backup Linux. Por ocupa√ß√£o, encontrei o BTRFS. Mais...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BTRFS para o menor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/458250/"> Bom dia, Khabravchane.  Trabalho na Veeam Software e sou um dos desenvolvedores da nossa solu√ß√£o de backup Linux.  Por ocupa√ß√£o, encontrei o BTRFS.  Mais recentemente, passou do status de "ainda n√£o adequado" para o status de "est√°vel".  E enquanto seus primeiros usu√°rios da rede discutiam √°reas problem√°ticas e de estabilidade, n√≥s da Veeam cutucamos uma varinha e tentamos fazer backup.  Descobriu-se, para dizer o m√≠nimo, n√£o muito - √© muito diferente, n√£o como os sistemas de arquivos tradicionais.  Eu tive que estudar muitos aspectos e coletar muitos ancinhos antes de aprendermos a trabalhar com ele.  No processo de aprendizado, o BTRFS conseguiu me impressionar, tanto de uma maneira boa como n√£o muito.  Tenho certeza de que ela n√£o deixar√° indiferente nenhum especialista em TI do mundo Linux: alguns cuspir√£o, outros elogiar√£o. <br><br>  Se voc√™ j√° ouviu falar sobre esse sistema de arquivos, mas n√£o sabe por que, est√° interessado nos detalhes ou procura por onde come√ßar a conhec√™-lo, convido voc√™ a conhecer. <br><a name="habracut"></a><br><h1>  1. Introdu√ß√£o </h1><br>  BTRFS (B-Tree Filesystem) - sistema de arquivos para sistemas operacionais do tipo Unix, baseado na t√©cnica Copiar na Grava√ß√£o (CoW), projetada para facilitar o dimensionamento do sistema de arquivos, um alto grau de confiabilidade e seguran√ßa dos dados, flexibilidade de configura√ß√£o e facilidade de administra√ß√£o, mantendo ao mesmo tempo alta velocidade.  Pelo menos √© o que diz a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina principal do wiki</a> . <br><br>  Para cumprir as formalidades, listamos os principais recursos do btrfs: <br><br><ul><li>  Tamanho m√°ximo do arquivo 2 ^ 64 bytes <br></li><li>  Tabela de inodes din√¢micos <br></li><li>  Deduplica√ß√£o de dados <br></li><li>  Armazenamento eficaz de arquivos de tamanhos muito pequenos e muito grandes <br></li><li>  Criando Subwolums e Snapshots <br></li><li>  Quotas de subvolume <br></li><li>  Soma de verifica√ß√£o para dados e metadados <br></li><li>  A capacidade de combinar v√°rias unidades em um √∫nico sistema de arquivos <br></li><li>  Criando uma configura√ß√£o RAID no n√≠vel do sistema de arquivos <br></li><li>  Compress√£o de dados <br></li><li>  Desfragmente dados em tempo real <br></li></ul><br>  Quero avisar imediatamente que o BTRFS est√° desenvolvendo ativamente e alguns pontos podem diferir de vers√£o para vers√£o.  O link - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://btrfs.wiki.kernel.org/index.php/Changelog,</a> voc√™ pode descobrir quando qual funcionalidade foi adicionada, alterada ou corrigida. <br><br>  Sim, o BTRFS √© um sistema de arquivos jovem e moderno que resolve uma grande variedade de tarefas, mas n√£o sem suas desvantagens: <br><br><ul><li>  Seu desenvolvimento ativo leva a uma altera√ß√£o em quaisquer pontos-chave nos quais utilit√°rios de terceiros podem confiar ao trabalhar com ele. <br></li><li>  Apesar das garantias dos desenvolvedores sobre a estabilidade do BTRFS, os usu√°rios encontram regularmente problemas que potencialmente levam √† perda de dados.  Como regra, eles s√£o de natureza "flutuante", como resultado dos quais ainda n√£o foram estudados e corrigidos. <br></li><li>  Alta suscetibilidade √† fragmenta√ß√£o. <br></li><li>  Documenta√ß√£o escassa e √†s vezes desatualizada. <br></li></ul><br>  Uma p√°gina inteira √© dedicada aos problemas do sistema de arquivos em diferentes vers√µes dos kernels - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://btrfs.wiki.kernel.org/index.php/Gotchas</a> .  Eu recomendo fortemente que voc√™ olhe para l√° - acaba sendo muito interessante e n√£o √≥bvio. <br><br><h1>  Estrutura BTRFS </h1><br>  O dispositivo BTRFS simplificado pode ser dividido nos seguintes n√≠veis: <br><br><img src="https://habrastorage.org/webt/zz/n8/zj/zzn8zjyt0dai6ge9rifhgcdwg0q.png"><br><br>  Os dispositivos de bloco est√£o localizados no n√≠vel mais baixo, representando um ou v√°rios espa√ßos de endere√ßo f√≠sico separados (o mesmo "f√≠sico" que os pr√≥prios dispositivos de bloco, mas esses j√° s√£o detalhes).  Por meio de estruturas especiais, os blocos alocados de mem√≥ria f√≠sica s√£o combinados em um √∫nico espa√ßo de endere√ßo virtual. <br><br>  Estruturas e blocos de metadados com dados do usu√°rio (extens√µes) j√° s√£o endere√ßados em n√≠vel l√≥gico.  Como resultado, os dados localizados seq√ºencialmente em um n√≠vel l√≥gico podem residir fisicamente em diferentes dispositivos de bloco. <br><br>  As estruturas de metadados podem ser divididas em n√≠veis.  Obviamente, n√£o os classificarei - existem muitos deles, e esses detalhes de baixo n√≠vel s√£o o t√≥pico de um artigo separado.  √â importante aqui que algumas estruturas na hierarquia acabem sendo de n√≠vel superior ao de outras e, no topo, haver√° uma estrutura que √© um subvolume. <br><br>  Subvolume √© um tipo de ponto de entrada, ou melhor, os elementos raiz do sistema de arquivos.  Eles formam uma camada separada de representa√ß√£o de dados, que encapsula o trabalho das camadas inferiores, apresentando os dados do usu√°rio da forma usual: diret√≥rios e arquivos.  Al√©m disso, os sub-lobos s√£o um elemento-chave do mecanismo CoW no BTRFS.  Os mesmos arquivos em dois subvolumes podem ser os mesmos dados nos n√≠veis mais baixos. <br><br>  A √∫ltima camada √© a camada de dados.  Como o usu√°rio os v√™.  Esses s√£o arquivos e diret√≥rios localizados no subvolume. <br><br>  Mas basta teoria.  √â hora de come√ßar a praticar! <br><br><h1>  Btrfs-progs </h1><br>  Este √© um conjunto padr√£o de utilit√°rios para gerenciar o BTRFS.  Dependendo do pacote de distribui√ß√£o, o pacote com esses utilit√°rios no reposit√≥rio pode ter nomes diferentes: <b>btrfsprogs</b> , <b>btrfs-progs</b> , <b>btrfs-tools</b> , etc.  Se o seu reposit√≥rio n√£o tinha nada parecido, voc√™ sempre pode compil√°-lo manualmente, as fontes n√£o est√£o muito longe - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/kdave/btrfs-progs</a> . <br>  Os utilit√°rios mais importantes deste pacote s√£o <b>btrfs</b> e <b>mkfs.btrfs</b> .  A partir do segundo, eu acho, tudo est√° muito claro - √© necess√°rio criar BTRFS em um dispositivo de bloco.  Primeiro, o <b>btrfs</b> √© o principal utilit√°rio que permite fazer o resto.  Uma esp√©cie de "faca su√≠√ßa". <br><br>  Neste artigo, usei a vers√£o v4.15.1.  O utilit√°rio est√° se desenvolvendo muito ativamente e h√° diferen√ßas vis√≠veis de vers√£o para vers√£o.  Portanto, se voc√™ n√£o possui o comando necess√°rio, verifique a vers√£o do utilit√°rio <b>btrfs</b> , pois ele pode j√° estar desatualizado. <br><br>  Al√©m disso, provavelmente, os utilit√°rios <b>btrfsck</b> e <b>btrfstune</b> s√£o encontrados no pacote. <br><br><ul><li>  O primeiro deles serve para verificar se h√° erros no sistema de arquivos e, se necess√°rio, para as corre√ß√µes subsequentes, ele n√£o √© recomendado - ele est√° em status <i>obsoleto</i> , sua funcionalidade foi movida para o comando <b>btrfs check</b> . </li><li>  O segundo permite executar algumas opera√ß√µes √∫teis no btrfs, por exemplo, alterar o identificador exclusivo do sistema de arquivos (FS UUID) ou ativar determinadas funcionalidades do sistema de arquivos. </li></ul><br>  Al√©m dos utilit√°rios listados acima, existem muitos outros utilit√°rios no pacote, mas s√£o principalmente necess√°rios para depurar btrfs e n√£o ser√£o √∫teis para n√≥s neste artigo. <br><br><h1>  Formatando um disco no BTRFS </h1><br>  Na pr√°tica, tudo √© mais simples.  Vamos come√ßar com uma unidade. <br>  A formata√ß√£o de um √∫nico disco no btrfs ocorre com o comando usual: <br><br><pre><code class="bash hljs">mkfs.btrfs /dev/sdc -L single_drive</code> </pre> <br>  Em resposta, o utilit√°rio emitir√° os par√¢metros do sistema de arquivos criado para o console: <br><br><pre> <code class="bash hljs">btrfs-progs v4.15.1 See http://btrfs.wiki.kernel.org <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. Label:       single_drive UUID:        59307d69-6d2f-4d2e-aae2-a5189ad3c256 Node size:     16384 Sector size:    4096 Filesystem size:  1.00GiB Block group profiles: Data:       single 8.00MiB Metadata:     DUP 51.19MiB System:      DUP 8.00MiB SSD detected:    no Incompat features: extref, skinny-metadata Number of devices: 1 Devices:  ID    SIZE PATH   1   1.00GiB /dev/sdc</code> </pre><br>  Vamos percorrer os par√¢metros apresentados. <br><br><ul><li>  <b>Etiqueta</b> - Um nome de etiqueta ou sistema de arquivos.  √â especificado pela op√ß√£o <code>-L</code> e √© um par√¢metro opcional. </li><li>  <b>UUID</b> √© um identificador exclusivo que faz o kernel btrfs diferenciar inst√¢ncias umas das outras. </li><li>  <b>Tamanho do n√≥</b> - o tamanho dos elementos da √°rvore B nos quais os metadados s√£o armazenados.  Pode ser definido usando o <code>-n | --nodesize</code>  <code>-n | --nodesize</code> , e deve ser um m√∫ltiplo do tamanho do tamanho do <b>setor</b> .  O tamanho pequeno do n√≥ leva a um aumento na altura da √°rvore B (um aumento no n√∫mero de n√≥s) e, como resultado, a uma diminui√ß√£o na competi√ß√£o pelo bloqueio de um n√≥ individual.  Por outro lado, o tamanho pequeno do n√≥ torna a inst√¢ncia do sistema de arquivos mais propensa a fragmenta√ß√£o.  N√≥s grandes, por outro lado, contribuem para um melhor empacotamento de metadados no disco, o que reduz a fragmenta√ß√£o. <br>  A desvantagem √© o aumento do tempo de acesso a dados para atualizar o mesmo n√≥ por v√°rios encadeamentos.  Em kernels anteriores a 3.11, por padr√£o, o tamanho do n√≥ √© 16384 bytes ou o tamanho da p√°gina de mem√≥ria do SO (o maior desses dois valores). </li><li>  <b>Tamanho do setor</b> - a quantidade de espa√ßo que √© m√∫ltiplo, do qual o espa√ßo √© alocado e liberado no n√≠vel f√≠sico.  √â igual ao tamanho da p√°gina da mem√≥ria virtual do sistema operacional, a menos que especificado de outra forma com a <code>-s</code> . </li><li>  <b>Tamanho do sistema de arquivos</b> - a capacidade total do sistema de arquivos (dados mais metadados).  Defina manualmente com a op√ß√£o <code>-b</code> .  Por padr√£o, todo o volume do dispositivo de bloco est√° ocupado. </li><li>  <b>Recursos incompat√≠veis</b> - uma lista de recursos inclu√≠dos nos btrfs criados que quebram a compatibilidade com vers√µes anteriores do kernel.  Se a compatibilidade com vers√µes anteriores for necess√°ria, voc√™ poder√° desativar: <br><br><pre> <code class="bash hljs">--features ^extref,^skinny-metadata.</code> </pre> <br>  A prop√≥sito, voc√™ pode verificar quais recursos o kernel atual suporta com a seguinte chamada: <br><br><pre> <code class="bash hljs">mkfs.btrfs --features list-all</code> </pre> </li><li>  <b>N√∫mero de dispositivos e dispositivos</b> - quantos dispositivos de bloco est√£o envolvidos na inst√¢ncia btrfs criada e uma lista de todos os dispositivos, respectivamente. </li><li>  Tamb√©m devemos falar sobre o par√¢metro <b>Perfis do Grupo de Blocos</b> .  Indica o perfil de registro aplic√°vel para cada um dos tr√™s tipos de dados: Dados, Metadados e Sistema.  Voltando √† estrutura generalizada do btrfs, podemos dizer que: <br><br><ul><li>  Dados s√£o dados do usu√°rio; </li><li>  Metadados √© uma combina√ß√£o de uma camada de subvolume e uma camada de metadados e extens√µes; </li><li>  Sistema s√£o estruturas para mapear o espa√ßo de endere√ßo da mem√≥ria f√≠sica em um espa√ßo cont√≠nuo de endere√ßos l√≥gicos. </li></ul><br>  Um perfil de grava√ß√£o √© uma maneira de armazenar dados no n√≠vel f√≠sico: <br><br><ul><li>  Armazenamento de dados √∫nicos em uma √∫nica c√≥pia; </li><li>  DUP - duplica√ß√£o de dados em um meio; </li><li>  RAIDX √© uma das configura√ß√µes de RAID0, RAID1, RAID10, RAID5 e RAID6. </li></ul><br></li></ul><br>  Ao marcar um dispositivo de bloco, o btrfs aplicar√° duplica√ß√£o aos metadados e dados do sistema por padr√£o, e os dados do usu√°rio permanecer√£o na m√≠dia em uma √∫nica c√≥pia.  A cria√ß√£o de btrfs em v√°rios discos ao mesmo tempo aplicar√° o perfil "RAID0" aos dados do usu√°rio por padr√£o e "RAID1" aos metadados. <br>  Este grupo de par√¢metros √© controlado usando duas chaves: <code>-d</code> para dados e <code>-m</code> para metadados e dados do sistema. <br><br>  Mas h√° uma nuance ... As coisas s√£o diferentes com os SSDs.  O fato √© que, se estiv√©ssemos marcando uma unidade SSD (ou unidade flash), por padr√£o, o sistema de arquivos n√£o duplicaria os metadados.  Os SSDs podem estender a deduplica√ß√£o de dados para prolongar a vida √∫til dos elementos de mem√≥ria.  I.e.  tendo duas c√≥pias l√≥gicas dos dados, na verdade apenas uma ser√° gravada no meio.  Como resultado, quando um segmento de mem√≥ria falha, "ambas as c√≥pias" dos dados ser√£o danificadas.  Al√©m disso, ao escrever dados duas vezes, o recurso SSD √© simplesmente consumido mais rapidamente. <br><br>  Para determinar o tipo de m√≠dia, o btrfs verifica o conte√∫do do arquivo <i>/ sys / block / DEV / fila / rotacional</i> , onde "DEV" √© o nome do dispositivo de bloco que est√° sendo verificado. <br>  Obviamente, mesmo no caso de um SSD, o perfil de armazenamento pode ser for√ßado. <br><br>  Para criar uma inst√¢ncia btrfs em v√°rios dispositivos, especifique-os com um espa√ßo: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -L double_drive</code> </pre> <br>  ou com perfis: <br><br><pre> <code class="bash hljs">sudo mkfs.btrfs /dev/sdc /dev/sdd -d raid1 -m raid1 -L raid1_drive</code> </pre> <br>  Observe que a m√≠dia n√£o precisa ter o mesmo tamanho, mesmo que o espelhamento completo seja usado.  No entanto, assim que n√£o houver espa√ßo suficiente na unidade menor para alocar mem√≥ria, o sistema de arquivos exibir√° uma mensagem indicando que n√£o h√° espa√ßo livre, embora fisicamente ainda possa haver espa√ßo livre em outras m√≠dias. <br><br><h1>  Montagem </h1><br>  A primeira montagem de btrfs criados recentemente n√£o √© diferente de outros sistemas de arquivos: <br><br><pre> <code class="bash hljs">mount /dev/sdc /mnt</code> </pre> <br>  Se o sistema de arquivos estiver localizado em v√°rios discos, para montagem, basta especificar qualquer um deles. <br><br>  Em geral, montar btrfs sempre envolve montar um ou mais de seu subvolume.  Se o comando mount n√£o for especificado, qual subvolume deve ser montado, o btrfs ler√° no registro especial o ID do subvolume, que deve ser montado por padr√£o.  Esta entrada pode ser alterada posteriormente com o <code>btrfs set-default</code> , mas quando voc√™ a monta pela primeira vez no btrfs, existe apenas um subvolume - o raiz.  √â ele especificado por padr√£o para montagem. <br><br>  O submundo raiz no btrfs est√° sempre presente.  Ele aparece junto com o sistema de arquivos e n√£o est√° sujeito a altera√ß√µes no futuro. <br><br>  Existem duas maneiras de montar qualquer subvolume que n√£o seja o padr√£o: <br>  especifique o caminho do subvolume raiz btrfs: <br><br><pre> <code class="bash hljs">mount -o subvol=/path/to/subvol /dev/sdc /mnt</code> </pre> <br>  especifique o ID do subvolume: <br><br><pre> <code class="bash hljs">mount -o subvolid=257 /dev/sdc /mnt</code> </pre> <br>  Como j√° mencionado, um dos subvolumes btrfs √© especificado como montado por padr√£o.  Descubra qual √© poss√≠vel fazendo: <br><br><pre> <code class="bash hljs">btrfs subvolume get-default /path/to/any/subvolume</code> </pre> <br>  Para instalar o submount padr√£o, voc√™ pode usar o comando: <br><br><pre> <code class="bash hljs">btrfs subvolume <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-default 258 /path/to/any/subvolume</code> </pre> <br>  O caminho para o subvolume, neste caso, √© necess√°rio apenas para indicar a inst√¢ncia btrfs espec√≠fica √† qual o comando se aplica.  A prop√≥sito, isso n√£o precisa ser um submundo; o caminho para qualquer diret√≥rio tamb√©m √© adequado. <br><br>  O comando <code>mount</code> aceita um grande n√∫mero de op√ß√µes para gerenciar os recursos do btrfs: desfragmenta√ß√£o, libera√ß√£o de cache, compacta√ß√£o, vaca, registro, equil√≠brio, suporte a ssd e at√© um vag√£o de v√°rias coisas espec√≠ficas do btrfs.  N√£o os considerarei na estrutura deste artigo, porque  eles s√£o necess√°rios para ajustar o sistema de arquivos e, na grande maioria dos casos, voc√™ pode ficar sem eles. <br><br><h1>  Subvolume √© </h1><br>  Um subvolume √© um elemento-chave do btrfs que executa v√°rias fun√ß√µes: <br><br><ul><li>  armazenamento de dados do usu√°rio e outro subvolume, <br></li><li>  fornecer acesso aos dados (montagem), <br></li><li>  Mecanismo CoW <br></li><li>  criando instant√¢neos. <br></li></ul><br>  Numa primeira aproxima√ß√£o, o subvolume √© um diret√≥rio normal.  Voc√™ pode renome√°-los / mov√™-los, visualizar seu conte√∫do, colocar e modificar arquivos dentro deles.  N√£o s√£o necess√°rios utilit√°rios especiais. <br><br>  A cria√ß√£o e a exclus√£o de um subvolume s√£o realizadas nos btrfs montados usando comandos especiais: <br><br><pre> <code class="bash hljs">btrfs subvolume create /mnt/subvolume_name btrfs subvolume delete /mnt/subvolume_name</code> </pre> <br>  Observo que, se voc√™ tentar remover o subvolume usando o gerenciador de arquivos ou o utilit√°rio <b>rm</b> , a opera√ß√£o terminar√° com um erro de <i>opera√ß√£o n√£o permitida</i> (a opera√ß√£o n√£o √© permitida). <br><br>  <b>UPD:</b> A partir da vers√£o 4.18.0 do kernel, √© poss√≠vel excluir sub-voleios usando o utilit√°rio <b>rm</b> ou as ferramentas de gerenciamento de arquivos.  Aparentemente, era um bug, n√£o um recurso.  Agradecimentos a Prototik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">habravchanin</a> pelo esclarecimento. <br><br>  Ap√≥s criar um subvolume, voc√™ pode ver suas propriedades: <br><br><pre> <code class="bash hljs">btrfs subvolume show /mnt/subvolume_name Name:          subx UUID:          09af45e8-d2b2-b342-8a92-fa270ac82d0a Parent UUID:      - Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      268 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Vamos examinar as principais propriedades do subwolume: <br><br><ul><li>  <b>Nome</b> - o nome do subvolume <br></li><li>  <b>O UUID</b> √© um identificador exclusivo universal que serve principalmente para determinar as rela√ß√µes subwoofer-instant√¢neo, <br></li><li>  <b>UUID pai</b> - identificador do ancestral do subvolume do qual o atual √© derivado, <br></li><li>  <b>UUID recebido</b> - identificador do ancestral do subvolume enviado via <i>btrfs send</i> , <br></li><li>  <b>ID do subvolume</b> - um identificador exclusivo para posicionamento na √°rvore B, <br></li><li>  <b>Gera√ß√£o</b> - n√∫mero da transa√ß√£o na √∫ltima atualiza√ß√£o dos metadados do subvolume, <br></li><li>  <b>Gera√ß√£o na cria√ß√£o</b> - n√∫mero da transa√ß√£o no momento em que o subvolume foi criado, <br></li><li>  <b>ID pai</b> - identificador do subvolume no qual o atual est√° incorporado, <br></li><li>  <b>O ID de n√≠vel superior</b> √© exatamente o mesmo que o ID principal, <br></li><li>  <b>Bandeiras</b> - bandeiras (na verdade, apenas 1 bandeira √© <i>somente leitura</i> ), <br></li><li>  <b>Instant√¢neos</b> - uma lista de instant√¢neos obtidos deste subvolume. <br></li></ul><br>  O subvolume possui mais um par√¢metro - esse √© o caminho do elemento raiz btrfs.  O caminho √© exibido ao listar o subvolume: <br><br><pre> <code class="plaintext hljs">btrfs subvolume list /path/to/any/btrfs/mountpoint</code> </pre> <br>  Mas aqui tudo √© simples e claro - nem faz sentido citar a sa√≠da do comando. <br>  Como nos comandos <code>get-default</code> e <code>set-default</code> , aqui voc√™ pode especificar o caminho para qualquer subvolume, o resultado disso n√£o ser√° alterado.  Esse caminho √© usado para encontrar o subbolum raiz btrfs.  Ap√≥s o qual toda a √°rvore subwolum √© lida. <br><br>  Se voc√™ tentar copiar um subvolume, por exemplo, com o utilit√°rio <b>cp</b> , a opera√ß√£o de c√≥pia ser√° bem-sucedida, mas, como resultado, n√£o ser√° criado um subvolume, mas um diret√≥rio regular.  No entanto, o btrfs fornece uma ferramenta muito mais flex√≠vel para criar essas c√≥pias - instant√¢neos. <br><br><h1>  O instant√¢neo √© </h1><br>  O instant√¢neo tamb√©m √© um submundo, apenas com propriedades avan√ßadas. <br><br>  A principal diferen√ßa √© que o instant√¢neo possui registros de qual subwolum foi produzido.  Esses s√£o os campos <b>UUID</b> <b>pai</b> e <b>UUID recebido</b> .  No subwoofer, esses campos tamb√©m est√£o presentes, mas est√£o sempre vazios.  Portanto, de fato, um instant√¢neo e um subvolume s√£o o mesmo. <br>  Ao criar, voc√™ pode bloquear o instant√¢neo para altera√ß√µes usando a op√ß√£o <code>-r</code> . <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot -r /path/to/subvol /path/to/snapshot</code> </pre> <br>  Nesse caso, √© garantido que os arquivos permanecem no estado em que estavam no momento em que o instant√¢neo foi criado. <br><br>  O sinalizador somente leitura tamb√©m pode ser controlado manualmente, isso funciona para qualquer subvolume: <br><br><pre> <code class="plaintext hljs">btrfs property get /path/to/subvol ro btrfs property set /path/to/subvol ro true</code> </pre> <br>  Se observarmos agora as propriedades do instant√¢neo, veremos o campo <b>UUID pai</b> preenchido: <br><br><pre> <code class="plaintext hljs">btrfs subvolume show /path/to/snapshot Name:          subx UUID:          d08612d8-596a-11e9-8647-d663bd873d93 Parent UUID:      09af45e8-d2b2-b342-8a92-fa270ac82d0a Received UUID:     - Creation time:     2019-03-23 17:59:28 +0100 Subvolume ID:      269 Generation:       39 Gen at creation:    35 Parent ID:       260 Top level ID:      260 Flags:         - Snapshot(s):</code> </pre> <br>  Um recurso importante da opera√ß√£o de captura instant√¢nea √© que ela n√£o √© recursiva.  Em vez do subvolume aninhado, diret√≥rios vazios ser√£o criados na captura instant√¢nea. <br><br>  Vamos voltar ao exemplo a seguir. <br><br>  No sistema de arquivos, existe um subwoofer "sub0", dentro do qual existe um subwoofer <i>subA</i> e um diret√≥rio <i>dirB</i> .  Dentro de cada um deles est√£o <i>fileA</i> e <i>fileB,</i> respectivamente. <br><br>  Remova o instant√¢neo: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0 snap0</code> </pre> <br><img src="https://habrastorage.org/webt/cf/or/w-/cforw-vhzoma9iub2hcyejkbh84.png"><br><br>  O instant√¢neo <i>snap0 criado</i> herdar√° todos os arquivos e diret√≥rios de seu pai, no entanto, o <i>subwoofer</i> subA n√£o aparecer√° dentro do instant√¢neo.  Em vez disso, apenas um diret√≥rio vazio aparecer√° no instant√¢neo, ou seja,  o conte√∫do do <i>subvolume</i> subA n√£o ser√° herdado. <br><br>  Por um lado, isso √© bom - removemos o instant√¢neo de um subvolume espec√≠fico, e todos os aninhados n√£o nos interessam.  Por outro lado, se a captura instant√¢nea recursiva for necess√°ria, o btrfs n√£o ter√° uma solu√ß√£o para esse problema.  Teremos que procurar por rodadas de trabalho. <br><br>  A primeira solu√ß√£o alternativa √© baseada no fato de que o instant√¢neo foi removido sem um sinalizador somente leitura, o que permite corrigir a situa√ß√£o de maneira simples: <br><br><ul><li>  remover diret√≥rio extra do instant√¢neo <br><br><pre> <code class="plaintext hljs">rmdir snap0/subA</code> </pre> <br></li><li>  remover captura instant√¢nea de um subvolume aninhado <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snap0/subA</code> </pre> <br></li></ul><br><img src="https://habrastorage.org/webt/ja/u3/fy/jau3fyzmzjxzxweajh-tmjld-iw.png"><br><br>  Se o instant√¢neo foi removido com o sinalizador somente leitura, a op√ß√£o acima n√£o funcionar√°, porque  no <i>snap0,</i> voc√™ n√£o pode excluir o diret√≥rio nem colocar um instant√¢neo.  Existe apenas uma op√ß√£o - coloque instant√¢neos em algum lugar perto do <i>subwoofer</i> snap0: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot sub0/subA snapA</code> </pre> <br>  e, em seguida, monte <i>snapA</i> dentro do instant√¢neo <i>snap0</i> , o diret√≥rio para isso j√° est√° l√°: <br><br><pre> <code class="plaintext hljs">mount -o subvol=snapA snap0/subA</code> </pre> <br><img src="https://habrastorage.org/webt/mu/-w/nn/mu-wnnj0jiyyinnxokz08nuipag.png"><br><br>  De qualquer forma, √© importante entender que os instant√¢neos recursivos ser√£o todos gravados em opera√ß√µes diferentes, em momentos diferentes.  N√£o se pode falar em remo√ß√£o at√¥mica de um instant√¢neo de v√°rios subvolumes. <br><br><h1>  Copiar na grava√ß√£o </h1><br>  Um pouco sobre o subvolume e a abordagem CoW.  Imagine que um subvolume est√° presente no sistema de arquivos e um arquivo est√° localizado nele (tome o caso ideal - o arquivo n√£o est√° fragmentado).  Em seguida, um instant√¢neo √© removido do subwolly. <br><br><img src="https://habrastorage.org/webt/hg/yo/sl/hgyoslduv5eeenpopaqu3dk7qyw.png"><br><br>  Um novo subvolume (captura instant√¢nea) aparecer√° no sistema de arquivos com exatamente o mesmo conte√∫do que o subvolume original.  O processo de cria√ß√£o de um instant√¢neo √© quase instant√¢neo - os dados do pr√≥prio arquivo n√£o s√£o copiados.  Em vez disso, metadados adicionais s√£o criados e um instant√¢neo junto com o subvolume pai se torna o propriet√°rio do arquivo.  De fato, havia apenas um arquivo no disco, mas agora ele pertence ao subvolume e ao instant√¢neo. <br>  Se voc√™ agora alterar o arquivo no subvolume, as altera√ß√µes n√£o afetar√£o o arquivo no instant√¢neo.  Se o sinalizador somente leitura n√£o foi definido ao criar o instant√¢neo, o arquivo no instant√¢neo tamb√©m pode ser modificado. <br><br><img src="https://habrastorage.org/webt/7n/1e/0t/7n1e0tkdlxsuqkpjmtinix0yiys.png"><br><br>  Tecnicamente, quando um arquivo √© alterado, apenas essas altera√ß√µes s√£o registradas.  Portanto, o arquivo de origem ser√° armazenado no disco mais um delta que distingue o arquivo original do modificado.  Se voc√™ excluir um dos subvolumes (no segundo, quero dizer um instant√¢neo), os dados em excesso que n√£o s√£o mais usados ‚Äã‚Äãpor ningu√©m ser√£o apagados do disco e apenas a vers√£o atual do arquivo permanecer√° no disco (do ponto de vista do subvolume restante). <br><br>  <i>Uma breve observa√ß√£o</i> : ap√≥s a remo√ß√£o, o subwoofer desaparecer√° dos olhos do usu√°rio instantaneamente e o utilit√°rio retornar√° o controle ao terminal; no entanto, os dados no disco ser√£o limpos pelo processo em segundo plano por algum tempo.  Ou seja, diferente da remo√ß√£o de um diret√≥rio regular, n√£o h√° necessidade de aguardar a conclus√£o real da opera√ß√£o de exclus√£o.  Se voc√™ precisar sincronizar com esse processo e aguardar a conclus√£o, poder√° especificar a op√ß√£o <code>--commit-after</code> ao chamar <b>delete</b> .  O comando <b>btrfs subvolume list</b> , <b>chamado</b> com a op√ß√£o <code>-d</code> , exibe uma lista de subvolumes que foram exclu√≠dos pelo usu√°rio e est√£o atualmente no processo de serem exclu√≠dos do disco. <br><br>  Al√©m disso, o btrfs permite clonar arquivos no sistema de arquivos sem recorrer a capturas instant√¢neas.  Isso √© feito atrav√©s da c√≥pia regular com a <code>--reflink</code> : <br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always /original/file /copied/file</code> </pre> <br>  A tecla <code>reflink=always</code> indica ao sistema de arquivos que queremos usar o mecanismo CoW ao copiar.  Ap√≥s a c√≥pia, os arquivos podem ser alterados independentemente um do outro, para que tenhamos o mesmo comportamento ap√≥s a cria√ß√£o de um instant√¢neo.  Ent√£o, por que precisamos de subbolums? <br><br>  Os subt√≠tulos no btrfs desempenham o papel de uma ferramenta de controle de alto n√≠vel para conjuntos de dados inteiros: primeiro, √© a remo√ß√£o de instant√¢neos at√¥micos de todos os dados de um subvolume (no caso de --reflink a atomicidade √© apenas no n√≠vel do arquivo) e, em segundo lugar, √© poss√≠vel ver de quem √© herdada. , ou "reverter" rapidamente o conjunto de dados para uma vers√£o anterior etc. <br>  Assim, o btrfs fornece a capacidade de capturar estados de arquivo nos momentos desejados, usando o subvolume como um meio de alto n√≠vel para gerenciar esses estados. <br><br><h1>  Recupera√ß√£o de Subvolume </h1><br>  Nas vastas extens√µes, surge a pergunta: "Eu tenho um subwoofer, tenho um instant√¢neo, como fazer o inverso?"  Essa abordagem n√£o √© aplic√°vel ao btrfs, porque  n√£o h√° oportunidade de "retroceder o subwolly".  Em vez disso, o btrfs oferece uma estrat√©gia para substituir o subwolly por seu instant√¢neo.  De fato, por que reverter algo, se o instant√¢neo em si √© esse objeto que queremos obter com revers√£o. <br><br>  Imagine este cen√°rio: no btrfs, existe um subvolume no qual os arquivos de um banco de dados est√£o localizados (bem ou outros dados importantes).  Os instant√¢neos s√£o removidos periodicamente desse subvolume e, em algum momento, √© necess√°rio reverter os dados.  Nesse caso, simplesmente nos livramos do subwolum e, em vez disso, come√ßamos a usar o instant√¢neo retirado dele, ou - se n√£o queremos estragar esses dados tamb√©m - removemos outro instant√¢neo do instant√¢neo.  Se o submundo original n√£o foi montado e usado como um diret√≥rio normal, ele deve ser exclu√≠do ou movido / renomeado, e um instant√¢neo deve ser colocado em seu lugar. <br><br><img src="https://habrastorage.org/webt/sn/os/od/snosodoezxac3a-2s7xzmpqa-js.png"><br><br>  No console, pode ser algo como isto: <br><br><ul><li>  renomear o subwolly <br><br><pre> <code class="plaintext hljs">mv the_subvolume the_subvol.old</code> </pre> </li><li>  colocar seu instant√¢neo no lugar do subvolume <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot the_snapshot the_subvolume</code> </pre> </li></ul><br>  Se o subvolume foi montado e usado atrav√©s do ponto de montagem, √© suficiente desmontar o subvolume e montar uma captura instant√¢nea em seu lugar. <br><br><img src="https://habrastorage.org/webt/4z/mi/sw/4zmisws4w5keyk7mhsr6eaav-ri.png"><br><br><ul><li>  Desmonte o subwoofer <br><br><pre> <code class="plaintext hljs">umount /mnt/</code> </pre> </li><li>  Voc√™ pode criar um instant√¢neo de um instant√¢neo para n√£o estragar os √∫ltimos dados sobreviventes: <br><br><pre> <code class="plaintext hljs">btrfs subvolume snapshot /path/to/snapshot /path/to/snapshot_copy</code> </pre> </li><li>  montar instant√¢neo: <br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/snapshot_copy /mnt</code> </pre> </li></ul><br>  Para completar, tentarei novamente e um pouco diferente.  O subvolume no qual as altera√ß√µes ocorrem √© o ramo <i>principal</i> . <br><br><img src="https://habrastorage.org/webt/gh/pt/m7/ghptm7ykmordfcur4bdddehng6c.jpeg"><br><br>  Ao criar um instant√¢neo, o estado dos arquivos no disco √© corrigido.  A partir de agora, um instant√¢neo √© um brunch do ramo <i>principal</i> .  Todas as altera√ß√µes adicionais no <i>main</i> n√£o afetar√£o o instant√¢neo de forma alguma.  A revers√£o para a captura instant√¢nea significa interromper o uso da ramifica√ß√£o <i>principal</i> e mudar completamente para o brunch.  O ramo <i>principal</i> pode ser exclu√≠do por desnecess√°rio.  Assim, o btrfs √© praticamente um sistema de controle de vers√£o, mas sem a capacidade de mesclar ramifica√ß√µes. <br><br><h1>  √Årvore do sistema de arquivos </h1><br>  Um dos pontos n√£o √≥bvios associados ao uso de btrfs √© como dividir os dados do sistema em subvolume.  Obviamente, n√£o existe uma abordagem "certa" para esse problema.  Mas existem tr√™s maneiras de organizar a estrutura do subvolume: uma estrutura plana, aninhada e mista. <br><br>  Uma estrutura plana significa que o subvolume √© colocado em uma lista plana no subvolume raiz.  Por exemplo, voc√™ pode selecionar a raiz do sistema de arquivos (vamos cham√°-la de <i>raiz</i> ), o diret√≥rio <i>inicial</i> do usu√°rio, o diret√≥rio com o site <i>/ var / www</i> e o banco de dados localizado, por exemplo, em <i>/ var / database</i> como subvolumes separados. <br><br><img src="https://habrastorage.org/webt/ga/yp/ma/gaypma96_mzvjtlwjyh3atw5qgm.png"><br><br>  Por conveni√™ncia, algum subvolume pode ser colocado em diret√≥rios, como, por exemplo, no caso do subvolume <i>var / www</i> . <br><br>  Com essa abordagem, todo o subvolume deve ser montado.  O sub <i>raiz</i> deve ter um ponto de montagem / e, dentro dele, deve conter os diret√≥rios <i>home</i> e <i>var</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s a montagem da </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raiz</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ home</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve ser instalado sabvolyum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">casa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ var / databas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um e - sabvolyumy </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var / www</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">banco de dados</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , respectivamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, a √°rvore do btrfs-subvolume pode ser exibida arbitrariamente no sistema de arquivos virtual do sistema operacional, e j√° existe o suficiente para isso.</font></font><br><br>  Pr√≥s: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o usu√°rio v√™ apenas o subvolume montado, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© f√°cil substituir o subwoofer (desmonte um, monte o outro), </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√°cil remover o subwoofer. </font></font><br></li></ul><br>  Contras: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© f√°cil ficar confuso sobre onde instal√°-lo, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para cada subvolume deve haver uma entrada no fstab e, se houver ‚Äúrevers√µes‚Äù para capturas instant√¢neas, as entradas correspondentes no fstab tamb√©m dever√£o ser atualizadas. </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura aninhada do subvolume sugere um uso simples do subvolume em vez de alguns diret√≥rios. </font></font><br><br><img src="https://habrastorage.org/webt/v2/41/e5/v241e5bwrguy3_f76frc2k3ygwk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, al√©m do subvolume raiz, nada mais √© necess√°rio para ser montado.</font></font><br><br>  Pr√≥s: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todo subvolume √© vis√≠vel, a estrutura √© f√°cil de perceber, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voc√™ n√£o precisa montar nada novamente, tudo √© como em um sistema de arquivos "regular". </font></font><br></li></ul><br>  Contras: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todos os subvolumes s√£o vis√≠veis, talvez alguns desejem se esconder do usu√°rio, </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© dif√≠cil remover / substituir o subwolum (a raz√£o para isso √© subwolves aninhados). </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, a terceira abordagem √© mista. </font><font style="vertical-align: inherit;">Envolve uma combina√ß√£o dos dois primeiros para maximizar os benef√≠cios de ambos. </font><font style="vertical-align: inherit;">No entanto, √© poss√≠vel que essa abordagem espec√≠fica leve a uma estrutura complexa, dif√≠cil de mudar e confusa, com um grande n√∫mero de entradas no fstab. </font><font style="vertical-align: inherit;">Tudo depende da </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobriedade</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do administrador do sistema.</font></font><br><br><img src="https://habrastorage.org/webt/bv/qw/zv/bvqwzvl0wqspgvlaknnd3l9eyqo.png"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicionar / remover disco, equilibrar </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O btrfs possui excelente funcionalidade - a capacidade de "adicionar dispositivos de bloco quentes" diretamente durante a opera√ß√£o do sistema de arquivos: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device add /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou exclua: </font></font><br><br><pre> <code class="plaintext hljs">btrfs device remove /path/to/device /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A prop√≥sito, em uma chamada de adi√ß√£o / exclus√£o, voc√™ pode especificar v√°rios discos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novamente, o caminho especificado √© o caminho para qualquer subvolume daquele btrfs ao qual o comando ser√° aplicado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos verificar quantos e quais dispositivos de bloco est√£o sob controle do btrfs:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem show /path/to/btrfs Label: none uuid: 52961dda-df84-4e2d-9727-e93e7738df81       Total devices 2 FS bytes used 192.00KiB       devid  1 size 20.00GiB used 132.00MiB path /dev/sdc       devid  2 size 50.00GiB used 0.00B path /dev/sdd</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.00B</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no campo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indica que o disco adicionado est√° vazio. </font><font style="vertical-align: inherit;">Para preench√™-lo com dados de acordo com o perfil de grava√ß√£o, voc√™ deve equilibrar:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O comando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redistribui os dados nos discos de acordo com o perfil de grava√ß√£o selecionado. Por exemplo, no caso do RAID1, o saldo levar√° √† clonagem de dados do dispositivo original, no caso do RAID0, levar√° a uma distribui√ß√£o mais uniforme dos dados entre dois discos, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado da balan√ßa, se antes havia vazios no disco, os dados no disco seriam gravados de maneira mais densa, ou seja, desfragmenta√ß√£o vai acabar. No entanto, √© importante entender que isso n√£o √© exatamente essa desfragmenta√ß√£o. Nesse caso, o comando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o analisa o conte√∫do l√≥gico, mas opera apenas em blocos de dados. Ela n√£o presta aten√ß√£o ao fato de que qualquer arquivo est√° espalhado no disco. Em vez disso, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saldo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transfere os blocos de dados de um lugar para outro.</font></font> I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um arquivo fragmentado para equilibrar permanecer√° fragmentado ap√≥s ele. Mas! A fragmenta√ß√£o no n√≠vel dos blocos de dados ainda diminuir√°, e isso pode ser usado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar confus√£o, digamos o seguinte: a opera√ß√£o de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equil√≠brio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reduz a fragmenta√ß√£o no n√≠vel dos blocos de dados, mas n√£o afeta a fragmenta√ß√£o do arquivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, o comando </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">balance</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fornece a capacidade de alterar o perfil de grava√ß√£o. Por exemplo, o perfil DUP foi usado no disco e, ap√≥s adicionar o disco, eles decidiram criar o RAID1 completo. Para fazer isso, use o filtro </font></font><code>convert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">btrfs balance start -dconvert=raid1 -mconvert=raid1 /path/to/btrfs</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando as op√ß√µes </font></font><code>-dconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, </font></font><code>-mconvert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novos perfis de registro s√£o definidos para dados e metadados, respectivamente. </font><font style="vertical-align: inherit;">H√° tamb√©m a op√ß√£o -sconvert, projetada para alterar o perfil de grava√ß√£o de dados do sistema; no entanto, voc√™ tamb√©m precisar√° adicionar a op√ß√£o -f (--force) com ela para for√ßar a opera√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, o principal objetivo dos filtros √© definir as regras para a opera√ß√£o da balan√ßa: quais blocos processar e quais n√£o tocar. </font><font style="vertical-align: inherit;">Portanto, por exemplo, voc√™ pode afetar apenas os blocos gravados com um perfil de grava√ß√£o espec√≠fico (perfis de filtro) ou os blocos ocupados acima de uma determinada porcentagem (filtro de uso), ou pode afetar apenas grupos de blocos relacionados a um disco espec√≠fico (filtro devid) etc. </font><font style="vertical-align: inherit;">A prop√≥sito, eles ainda podem ser combinados. </font><font style="vertical-align: inherit;">Em geral, as capacidades dos filtros s√£o muito extensas e s√£o principalmente necess√°rias para a realiza√ß√£o de um balan√ßo seletivo de dados.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmenta√ß√£o </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, o btrfs, devido √† sua arquitetura, √© extremamente suscet√≠vel a um fen√¥meno como a fragmenta√ß√£o. </font><font style="vertical-align: inherit;">O fato √© que os dados s√£o sempre gravados em um novo local no disco. </font><font style="vertical-align: inherit;">Mesmo se voc√™ ler o arquivo, n√£o fa√ßa nada com os dados e grave-o novamente no mesmo arquivo, os dados ir√£o para uma nova √°rea no disco. </font><font style="vertical-align: inherit;">O mesmo acontece se voc√™ atualizar os dados no arquivo apenas parcialmente - as altera√ß√µes ser√£o gravadas em uma nova √°rea no disco. </font><font style="vertical-align: inherit;">Assim, as altera√ß√µes frequentes fragmentam os arquivos com muita for√ßa, aumentando a "dispers√£o" dos fragmentos, no caso geral, em v√°rios discos. </font><font style="vertical-align: inherit;">Isso leva a um aumento da carga na CPU e a um consumo desnecess√°rio de mem√≥ria. </font><font style="vertical-align: inherit;">Os mais fragmentados s√£o bancos de dados e imagens de m√°quinas virtuais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode avaliar a fragmenta√ß√£o do arquivo usando o utilit√°rio </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filefrag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (n√£o inclu√≠do no btrfs-progs). </font></font><br><br><pre> <code class="plaintext hljs">filefrag /path/to/your/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele mostra o n√∫mero de extens√µes usadas para armazenar o arquivo. </font><font style="vertical-align: inherit;">Simplificando - quanto menos extens√µes envolvidas, menos fragmentado o arquivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existem dois m√©todos para combater a fragmenta√ß√£o no btrfs: desfragmenta√ß√£o e a flag </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A desfragmenta√ß√£o pode ser aplicada a um √∫nico arquivo ou a um subvolume / diret√≥rio, incluindo recursivamente. </font><font style="vertical-align: inherit;">O comando √© o seguinte:</font></font><br><br><pre> <code class="plaintext hljs">btrfs filesystem defragment /path/to/file/or/dir</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devo dizer que essa equipe nem sempre leva aos resultados esperados. </font><font style="vertical-align: inherit;">Arquivos pequenos e ligeiramente fragmentados (10 a 20 extens√µes) ap√≥s a desfragmenta√ß√£o podem ser divididos em ainda mais partes. </font><font style="vertical-align: inherit;">Al√©m disso, a desfragmenta√ß√£o do btrfs em algumas vers√µes do kernel interrompe a desduplica√ß√£o de arquivos, tornando-as c√≥pias f√≠sicas reais.</font></font> I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os instant√¢neos no n√≠vel f√≠sico se tornar√£o c√≥pias completas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A segunda maneira de combater a fragmenta√ß√£o √© com um atributo de arquivo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">chattr +C /path/to/file</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O atributo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser definido apenas para um arquivo novo ou vazio. </font><font style="vertical-align: inherit;">Desativa a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥pia no</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mecanismo de </font><i><font style="vertical-align: inherit;">grava√ß√£o</font></i><font style="vertical-align: inherit;"> , para que o btrfs sempre trabalhe com uma √°rea de disco fixa ao atualizar o conte√∫do de um arquivo, gravando dados sobre os existentes (no n√≠vel f√≠sico). </font><font style="vertical-align: inherit;">Das desvantagens do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nocow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - tamb√©m desabilita a verifica√ß√£o da soma de verifica√ß√£o para esse arquivo. </font><font style="vertical-align: inherit;">Em outras palavras, sem vaca - sem soma de verifica√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Claro, defina manualmente o atributo</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada arquivo √© uma tarefa ingrata. Se esse sinalizador do diret√≥rio / subvolume estiver definido, todos os novos arquivos criados nele herdar√£o o sinalizador automaticamente. O mesmo se aplica aos diret√≥rios aninhados criados. Se no momento em que o atributo foi ativado, alguns dados j√° estavam no diret√≥rio, isso n√£o os afetar√° de forma alguma - o atributo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser definido apenas como um arquivo novo ou vazio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E outra maneira de definir o sinalizador automaticamente </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© montar o sistema de arquivos com a op√ß√£o </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="plaintext hljs">mount -o subvol=path/to/subvol,nodatacow /dev/sdXX /path/to/mountpoint</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa op√ß√£o far√° com que a op√ß√£o se conecte automaticamente </font></font><code>nodatasum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, de modo que, para arquivos rec√©m-criados, as somas de verifica√ß√£o n√£o sejam calculadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como sempre, h√° uma nuance: voc√™ n√£o pode montar apenas um subwoofer com uma op√ß√£o </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Todo subvolume ter√° uma op√ß√£o </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou nenhuma. Tudo √© decidido pelo primeiro subvolume montado: se tivesse uma op√ß√£o especificada </font></font><code>nodatacow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, todas as montagens subsequentes ir√£o automaticamente com essa op√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um momento n√£o √≥bvio surge se voc√™ colocar um sinalizador em um arquivo </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e remover a captura instant√¢nea do subvolume em que esse arquivo est√° localizado. Nesse caso, o btrfs ignora o sinalizador </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se mais de um subvolume se referir ao bloco de dados atualizado. Portanto, apesar da bandeira</font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(a prop√≥sito, o arquivo tamb√©m o herdar√° no instant√¢neo), as altera√ß√µes em qualquer um dos arquivos ser√£o direcionadas para uma nova √°rea no disco e o arquivo novamente ser√° fragmentado. </font><font style="vertical-align: inherit;">Se o bloco de dados no arquivo for atualizado v√°rias vezes, na primeira vez em que ele cair em uma nova √°rea do disco, e com as entradas subseq√ºentes, ele ser√° atualizado nessa nova √°rea "no local".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Truques e falhas </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao usar o btrfs-progs, voc√™ pode omitir o nome completo do comando: </font></font><br><br><pre> <code class="plaintext hljs">btrfs sub cre = btrfs subvolume create</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basta a coincid√™ncia dos primeiros caracteres, que determinam exclusivamente o comando: </font></font><br><br><pre> <code class="plaintext hljs">su = subvolume, fi = filesystem, ba = balance, de = device;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu acho que o princ√≠pio √© claro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, o btrfs n√£o pode criar uma captura instant√¢nea do diret√≥rio, mas h√° uma solu√ß√£o alternativa:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> criar um subvolume </font></font><br><br><pre> <code class="plaintext hljs">btrfs subvolume create ./subvol</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copie arquivos do diret√≥rio para o subvolume: </font></font><br><br><pre> <code class="plaintext hljs">cp -ax --reflink=always your/dir/. ./subvol</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a chave </font></font><code>reflink=always</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usar√° o mecanismo CoW, ou seja, </font><font style="vertical-align: inherit;">os dados n√£o ser√£o copiados, mas os links para eles ser√£o criados em um n√≠vel baixo de btrfs.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora o sub-mundo cont√©m todos os arquivos que estavam no diret√≥rio e voc√™ pode remover o instant√¢neo dele. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ </font></font><code>nocow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o pode definir o </font><font style="vertical-align: inherit;">atributo para um </font><font style="vertical-align: inherit;">arquivo de dados existente. </font><font style="vertical-align: inherit;">No entanto, voc√™ pode seguir o seguinte caminho:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> criar arquivo vazio </font></font><br><br><pre> <code class="plaintext hljs">touch nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> coloque uma bandeira para ele </font></font><code>nocow</code> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alocar espa√ßo em disco para um novo arquivo </font></font><br><br><pre> <code class="plaintext hljs">fallocate -l10g nocowfile</code> </pre> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> copie o conte√∫do de um arquivo existente para </font></font><br><br><pre> <code class="plaintext hljs">cp -v oldcowfile nocowfile</code> </pre> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o btrfs ficar sem espa√ßo, at√© a exclus√£o de um arquivo poder√° causar o erro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Sem espa√ßo restante no dispositivo"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para a solu√ß√£o, √© recomend√°vel conectar uma unidade tempor√°ria com tamanhos de prefer√™ncia de pelo menos 1 GB aos btrfs. </font><font style="vertical-align: inherit;">Depois limpe os dados. </font><font style="vertical-align: inherit;">Em seguida, remova a unidade tempor√°ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A opera√ß√£o de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equil√≠brio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , chamada sem especificar perfis de grava√ß√£o, os altera implicitamente de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raid1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O que, ali√°s, est√° escrito na p√°gina </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gotchas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Isso acontece depois de adicionar o disco ao btrfs, que usa o perfil de grava√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lembre-se de que a formata√ß√£o de uma √∫nica unidade no btrfs usa o perfil </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dup</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> padr√£o para metadados e dados do sistema.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Talvez o mais importante </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite criar clones de baixo n√≠vel de dispositivos de bloco com btrfs. Sendo um sistema de arquivos ‚Äúinteligente‚Äù, para algumas opera√ß√µes (geralmente na montagem) o btrfs rel√™ os dados do sistema em dispositivos de bloco para encontrar todas as partes do sistema de arquivos. Se dois dispositivos de bloco com os mesmos UUIDs forem encontrados no processo de pesquisa, o btrfs os aceitar√° como parte da mesma inst√¢ncia. Se, ao mesmo tempo, esses dois dispositivos forem o original e seu clone, depois de montar o driver, voc√™ saber√° como o sistema de arquivos funcionar√°, mas √© claro que isso n√£o terminar√° com nada de bom. Na pior das hip√≥teses, isso resultar√° em corrup√ß√£o irrevers√≠vel dos dados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ realmente deseja clonar discos com btrfs de uma maneira de baixo n√≠vel, deve-se tomar muito cuidado. </font><font style="vertical-align: inherit;">Em geral, um clone n√£o deve estar vis√≠vel para o kernel do SO como um dispositivo de bloco enquanto o original estiver presente no sistema e vice-versa. </font><font style="vertical-align: inherit;">Fornecendo essa condi√ß√£o, voc√™ pode alterar o UUID do clone (bem, ou o original, aqui opcional). </font><font style="vertical-align: inherit;">O utilit√°rio </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que acompanha o pacote </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfs-progs ajudar√°</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="plaintext hljs">btrfstune -u /path/to/device</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E novamente: o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btrfstune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sendo um utilit√°rio "inteligente", mudar√° o UUID n√£o apenas no disco, mas em todo o sistema de arquivos. </font><font style="vertical-align: inherit;">Isso significa que, quando chamada, ela ler√° todos os dispositivos de bloco para substituir o UUID em todos os dispositivos relacionados ao sistema de arquivos.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em vez de uma conclus√£o </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se neste momento voc√™ n√£o entende nada - isso √© normal. O Btrfs n√£o √© trivial e pode n√£o sucumbir imediatamente. Toda vez que me parecia que agora eu a entendia, ela jogava uma surpresa e a fazia repensar as coisas existentes. N√£o posso dizer que entendi tudo no momento atual - no processo de escrever encontrei algo novo, embora j√° tenha escrito com base em minha experi√™ncia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu compararia o processo de dominar o btrfs com a transi√ß√£o de um estilo de programa√ß√£o procedural para um estilo orientado a objetos. A primeira impress√£o √© "uau, que incr√≠vel", mas, em seguida, voc√™ continua a escrever c√≥digo processual agrupado em classes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No artigo, tentei n√£o derramar √°gua - para escrever tudo sobre o caso. </font><font style="vertical-align: inherit;">Apesar disso, ficou bastante volumoso. </font><font style="vertical-align: inherit;">Mas longe de tudo era poss√≠vel dizer - voc√™ ainda pode escrever e escrever sobre btrfs. </font><font style="vertical-align: inherit;">Este artigo √© apenas a ponta do iceberg. </font><font style="vertical-align: inherit;">O come√ßo √© entender sua filosofia e come√ßar a us√°-la. </font><font style="vertical-align: inherit;">E agora √© hora de terminar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado por ler at√© o fim. </font><font style="vertical-align: inherit;">Espero que n√£o esteja cansado. </font><font style="vertical-align: inherit;">Escreva nos coment√°rios sobre o que mais voc√™ gostaria de saber. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fa√ßa backups, senhores. </font><font style="vertical-align: inherit;">E nunca deixe que eles sejam √∫teis.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt458250/">https://habr.com/ru/post/pt458250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt458240/index.html">Como intelig√™ncia artificial, drones e c√¢meras garantem a seguran√ßa de estradas e pontes</a></li>
<li><a href="../pt458242/index.html">O novo operador de nave espacial em C ++ 20</a></li>
<li><a href="../pt458244/index.html">Uma lista intermin√°vel e rid√≠cula do que voc√™ precisa saber para usar com seguran√ßa redes Wi-Fi p√∫blicas</a></li>
<li><a href="../pt458246/index.html">Coincid√™ncias aleat√≥rias na vida ou como voc√™ recebeu um bolo em uma f√°brica de tratores</a></li>
<li><a href="../pt458248/index.html">Simplifique seu c√≥digo com a Rocket Science: Operador da nave espacial C ++ 20</a></li>
<li><a href="../pt458252/index.html">Modelo matem√°tico de um radiotelesc√≥pio super longo</a></li>
<li><a href="../pt458256/index.html">N√£o √© hora de fazer lavagem cerebral?</a></li>
<li><a href="../pt458260/index.html">Outra maneira de otimizar imagens do docker para aplicativos Java</a></li>
<li><a href="../pt458262/index.html">Designer on-line da sala de reuni√µes - sele√ß√£o da solu√ß√£o ideal para a videoconfer√™ncia</a></li>
<li><a href="../pt458264/index.html">10 princ√≠pios do c√≥digo de auto-documenta√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>