<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚣🏻 🤱 🌶️ Bagaimana saya membuat filter yang tidak merusak gambar bahkan setelah jutaan berjalan 🧖🏼 👩🏽‍🏫 🙏🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setelah menyelesaikan pembuatan arsitektur web untuk komik web baru kami Meow the Infinite , saya memutuskan sudah waktunya untuk menulis beberapa art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya membuat filter yang tidak merusak gambar bahkan setelah jutaan berjalan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/">  Setelah menyelesaikan pembuatan arsitektur web untuk komik web baru kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meow the Infinite</a> , saya memutuskan sudah waktunya untuk menulis beberapa artikel teknis yang sudah lama tertunda.  Artikel ini akan fokus pada filter yang saya kembangkan beberapa tahun yang lalu.  Ini belum pernah dibahas di bidang kompresi video, meskipun bagi saya itu layak dilakukan. <br><br>  Pada 2011, saya mengembangkan "filter setengah-pel".  Ini adalah jenis filter khusus yang mengambil gambar yang masuk dan paling meyakinkan menampilkan bagaimana gambar akan terlihat ketika bergeser <i>tepat setengah piksel</i> . <br><br>  Anda mungkin bertanya-tanya mengapa filter semacam itu mungkin diperlukan sama sekali.  Bahkan, mereka cukup umum di codec video modern.  Codec video menggunakan filter serupa untuk mengambil fragmen dari frame sebelumnya dan menggunakannya dalam frame berikutnya.  Codec yang lebih lama hanya memindahkan data bingkai satu piksel pada satu waktu, tetapi codec yang baru bergerak lebih jauh dan memungkinkan pergeseran setengah atau bahkan seperempat piksel untuk mentransmisikan gerakan kecil dengan lebih baik. <br><br>  Ketika menganalisis perilaku algoritma kompensasi gerak dalam filter halfpel tradisional, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jeff Roberts</a> menemukan bahwa ketika diterapkan berulang kali pada frame sekuensial, mereka dengan cepat menurunkan, memaksa bagian lain dari kompresor video untuk menggunakan lebih banyak data daripada yang diperlukan untuk memperbaiki artefak.  Jika Anda menonaktifkan koreksi ini dan melihat hasil "mentah" dari filter halfpel, maka ini adalah gambar aslinya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>  berubah menjadi ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  hanya satu detik kemudian videonya.  Seperti seharusnya, itu digeser ke samping, karena setiap frame menggeser gambar dengan setengah piksel.  Tetapi hasilnya tidak terlihat seperti versi yang dipindahkan dari gambar asli, itu benar-benar terdistorsi. <br><a name="habracut"></a><br>  Selama filter "satu video kedua" sebenarnya diterapkan berkali-kali - 60 jika video diputar pada frekuensi 60 frame per detik.  Namun idealnya, kita membutuhkan filter yang tahan terhadap distorsi semacam itu.  Jika kami memilikinya, gulir video dengan lancar tidak akan dikodekan dengan begitu banyak koreksi artefak, yang akan membuatnya lebih sedikit, atau lebih baik, atau keduanya. <br><br>  Jika Anda terbiasa dengan bidang kompresi video, Anda mungkin bertanya-tanya mengapa kita bahkan perlu menggunakan filter halfpel lebih dari sekali.  Pada akhirnya, jika kita menerapkan filter halfpel dua kali, maka kita sudah akan memindahkan satu piksel penuh, jadi mengapa tidak hanya menggunakan data dari <i>dua</i> frame kembali dan hanya mengambilnya? <br><br>  Jawabannya tidak begitu sederhana.  Pertama, semakin banyak data yang kita butuhkan untuk menyandikan data, semakin sedikit kompresi yang kita dapatkan.  Karena itu, jika kita mulai menyandikan tanpa perlu terlalu banyak data seperti "dari frame mana untuk mengambil data", video tidak akan dikompresi dengan baik. <br><br>  Tapi ini bukan yang terpenting.  Masalah utama adalah bahwa jika kita perlu mengambil informasi dari frame sebelumnya, kita <i>harus menyimpannya</i> .  Untuk mempertahankan dua frame sebelumnya, alih-alih satu, Anda harus menebak bahwa Anda memiliki memori dua kali lebih banyak.  Untuk CPU modern, ini bukan masalah khusus, mereka memiliki banyak memori dan hal sepele seperti itu tidak mengganggu mereka.  Tetapi ini adalah <i>masalah</i> bagi Anda jika Anda ingin membuat format video yang cepat, portabel, dan banyak digunakan yang harus bekerja di perangkat dengan sedikit memori (ponsel, elektronik bawaan, dll.). <br><br>  Kami benar-benar tidak ingin menyimpan beberapa frame untuk mengkompensasi pergerakan hanya agar tidak menggunakan filter halfpel.  Oleh karena itu, saya diperintahkan untuk mencari tahu apa sebenarnya yang terjadi di sini dan untuk mencari tahu apakah saya dapat membuat filter yang tidak memiliki masalah seperti itu. <br><br>  Sebelum itu, saya tidak pernah bekerja dengan filter dan tidak tahu bagaimana mereka biasanya dikembangkan.  Anehnya, ternyata menguntungkan saya, karena saya harus melihat masalah ini tanpa prasangka. <br><br><h2>  Dasar-dasarnya </h2><br>  Saya segera menyadari bahwa filter halfpel paling populer memiliki struktur yang serupa: untuk setiap piksel dalam gambar output, 2 hingga 8 piksel dari gambar input diambil, yang disampel dan dicampur dengan koefisien tertentu.  Filter yang berbeda hanya berbeda dalam jumlah piksel sumber sampel (sering kali dalam jargon pengembang filter disebut ketuk) dan faktor pencampuran piksel.  Koefisien ini sering disebut "filter kernel" dan hanya itu yang diperlukan untuk menggambarkan filter sepenuhnya. <br><br>  Jika Anda terbiasa dengan pengambilan sampel atau resampling gambar (misalnya, menskala gambar), maka ini harus jelas bagi Anda.  Pada dasarnya, filter melakukan hal yang sama.  Karena kompresi video adalah area yang luas di mana berbagai studi sedang dilakukan, jelas bahwa ada banyak cara <i>lain</i> untuk mengimbangi gerakan selain penyaringan sederhana.  Tetapi codec umum biasanya menggunakan prosedur kompensasi gerak dengan filter halfpel, yang pada dasarnya identik dengan filter penskalaan gambar: mereka hanya mengambil piksel asli, mengalikannya dengan beberapa bobot, menambahkannya dan mendapatkan piksel keluaran. <br><br><h2>  Kebutuhan akan "ketajaman" </h2><br>  Jadi, kita perlu menggeser gambar hingga setengah piksel.  Jika Anda seorang programmer grafis, tetapi tidak terlalu terbiasa dengan filtering, Anda mungkin berpikir: "Saya juga punya masalah, cukup gunakan filter bilinear."  Ini adalah proses standar dalam bekerja dengan grafik, ketika kita perlu menghitung nilai antara antara dua elemen data yang masuk, seperti yang terjadi di sini. <br><br>  Filter bilinear untuk memindahkan tepat setengah piksel dapat dengan mudah dijelaskan oleh inti filter berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter BilinearKernel[] = {1.0/2.0, 1.0/2.0};</span></span></code> </pre> <br>  Ini akan berhasil, tetapi bukan tanpa masalah.  Jika sasaran Anda adalah gambar berkualitas tinggi, dan dalam hal kompresi video, tujuannya hanya itu, maka filter bilinear bukan solusi terbaik, karena itu menambah lebih banyak blur pada hasil daripada yang diperlukan.  Ini tidak begitu <i>banyak</i> , tetapi <i>lebih</i> dari yang dibuat oleh filter lain. <br><br>  Untuk menunjukkan ini dengan jelas, berikut ini adalah gambar perkiraan mata walrus dari gambar asli setelah satu aplikasi filter yang paling umum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br>  Di sebelah kiri adalah yang asli, di sebelah kanan adalah penyaringan bilinear.  Di antara mereka adalah filter halfpel codec video yang paling banyak digunakan.  Jika Anda melihat lebih dekat, Anda dapat melihat bahwa hampir semua gambar terlihat serupa, <i>kecuali yang</i> bilinear, yang sedikit lebih buram.  Meskipun tidak ada banyak kekaburan, jika tujuan utama Anda adalah kualitas gambar, maka ini sudah cukup untuk memilih filter yang berbeda daripada filter bilinear. <br><br>  Jadi, bagaimana filter lain “mempertahankan” ketajaman dan menghindari pengaburan?  Mari kita ingat seperti apa inti dari bilinear blur: <br><br><pre> <code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>};</code> </pre> <br>  Ini sangat sederhana.  Untuk menggeser gambar setengah piksel, kami mengambil piksel dan mencampurnya 50% dengan tetangganya.  Itu saja.  Orang dapat membayangkan bagaimana ini "mengaburkan" gambar, karena di tempat-tempat di mana piksel putih terang berdekatan dengan hitam gelap, dua piksel ini dirata-rata selama penyaringan bilinear, menciptakan piksel abu-abu yang "melembutkan" perbatasan.  Ini terjadi pada setiap piksel, sehingga secara harfiah setiap area di mana terdapat perbedaan warna atau kecerahan yang jelas.  dihaluskan. <br><br>  Itulah sebabnya dalam codec bilinear filtering berkualitas tinggi tidak digunakan untuk kompensasi gerak (meskipun dapat digunakan dalam kasus lain).  Alih-alih, filter digunakan yang menjaga ketajaman, misalnya, seperti: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs h264Kernel[] = {1.0/32.0, -5.0/32.0, 20.0/32.0, 20.0/32.0, -5.0/32.0, 1.0/32.0}; HEVCKernel[] = {-1.0/64.0, 4.0/64.0, -11.0/64.0, 40.0/64.0, 40/64.0, -11.0/64.0, 4.0/64.0, -1.0/64.0};</span></span></code> </pre> <br>  Seperti yang Anda lihat, di mana penyaringan bilinear hanya memperhitungkan dua piksel, filter ini memperhitungkan enam (h.264) atau bahkan delapan (HEVC) piksel.  Selain itu, mereka tidak hanya menghitung nilai rata-rata tertimbang biasa dari piksel ini, tetapi menggunakan bobot <i>negatif</i> untuk beberapa piksel untuk <i>mengurangi</i> piksel ini dari nilai lain. <br><br>  Mengapa mereka melakukan ini? <br><br>  Sebenarnya tidak sulit untuk memahami ini: menggunakan nilai positif dan negatif, dan juga mempertimbangkan "jendela" yang lebih luas, filter dapat memperhitungkan <i>perbedaan</i> antara piksel yang berdekatan dan mensimulasikan ketajaman dua piksel terdekat relatif terhadap tetangga terjauh mereka.  Ini memungkinkan Anda untuk mempertahankan ketajaman hasil gambar di tempat-tempat di mana piksel berbeda secara signifikan dari tetangga mereka, sementara rata-rata masih digunakan untuk membuat nilai yang dapat dipercaya dari pergeseran "setengah piksel", yang harus mencerminkan kombinasi piksel dari gambar yang masuk. <br><br><h2>  Pemfilteran tidak stabil </h2><br>  Jadi, apakah masalahnya teratasi?  Ya, itu mungkin, tetapi jika Anda hanya perlu melakukan offset satu setengah piksel.  Namun, filter "mengasah" ini (dan saya sengaja menggunakan istilah ini di sini) sebenarnya melakukan sesuatu yang berbahaya, <i>pada dasarnya mirip</i> dengan apa yang dilakukan penyaringan bilinear.  Mereka lebih baik tahu cara menyembunyikannya. <br><br>  Di mana penyaringan bilinear <i>mengurangi</i> ketajaman gambar, filter standar ini <i>meningkatkannya</i> , seperti operasi pertajam di beberapa program grafis.  Jumlah penajaman sangat kecil, jadi jika kita menjalankan filter hanya sekali, kita tidak akan melihat ini.  Tetapi jika penyaringan dilakukan beberapa kali, maka ini bisa menjadi sangat nyata. <br><br>  Dan, sayangnya, karena penajaman ini bersifat prosedural dan tergantung pada perbedaan antara piksel, itu <i>menciptakan loop umpan balik</i> yang akan terus mempertajam perbatasan yang sama lagi dan lagi sampai merusak gambar.  Anda dapat menunjukkan ini dengan contoh spesifik. <br><br>  Di atas - gambar asli, di bawah ini - dengan penyaringan bilinear, menampilkan lebih dari 60 frame: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>  Seperti yang Anda harapkan, kabur hanya terus mengurangi ketajaman gambar hingga menjadi cukup buram.  Sekarang yang asli akan berada di atas, dan filter halfpel codec h.264 yang akan berjalan untuk 60 frame di bagian bawah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  Lihat semua sampah ini?  Filter melakukan hal yang sama sebagai efek "blur" dari penyaringan bilinear, tetapi <i>sebaliknya</i> - itu "meningkatkan ketajaman gambar" sehingga semua bagian di mana detail berubah menjadi pola cahaya / gelap yang sangat terdistorsi. <br><br>  Apakah codec HEVC menggunakan 8 piksel berperilaku lebih baik?  Yah, itu pasti lebih baik daripada h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  tetapi jika kita menambah waktu dari 60 frame (1 detik) menjadi 120 frame (2 detik), kita masih akan melihat bahwa ada umpan balik dan gambar dihancurkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Demi mereka yang menyukai pemrosesan sinyal, saya akan menambahkan filter windowed-sinc (disebut filter Lanczos) untuk referensi: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter LanczosKernel[] = {0.02446, -0.13587, 0.61141, 0.61141, -0.13587, 0.02446};</span></span></code> </pre> <br>  Saya tidak akan menjelaskan dalam artikel ini mengapa seseorang mungkin tertarik pada "windowed sinc", tetapi cukup untuk mengatakan bahwa filter ini populer karena alasan teoretis, jadi lihat tampilannya saat memproses 60 frame (1 detik): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>  dan saat memproses 120 frame (2 detik): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>  Lebih baik daripada h.264, dan hampir sama dengan HEVC. <br><br><h2>  Penyaringan stabil </h2><br>  Bagaimana kita bisa mencapai hasil yang lebih baik daripada h.264, HEVC dan windowed sinc?  Dan seberapa jauh mereka bisa lebih baik? <br><br>  Saya <i>berharap untuk</i> melihat pertanyaan serupa dalam literatur tentang kompresi video dan mereka harus diketahui oleh spesialis kompresi, tetapi pada kenyataannya (setidaknya untuk 2011) saya tidak menemukan siapa pun yang setidaknya menyatakan bahwa ini adalah masalah.  Jadi saya harus mencari solusi sendiri. <br><br>  Untungnya, pernyataan masalahnya sangat sederhana: buat filter yang dapat diterapkan sebanyak mungkin sehingga gambar terlihat hampir sama dengan di awal. <br><br>  Saya menyebut definisi ini "pemfilteran stabil" karena, menurut pendapat saya, ini dapat dianggap sebagai properti filter.  Filter "stabil" jika tidak jatuh ke loop umpan baliknya, yaitu, ia dapat diterapkan berulang kali tanpa membuat artefak.  Filter "tidak stabil" jika membuat artefak yang diperkuat dengan penggunaan berulang dan akhirnya menghancurkan gambar. <br><br>  Saya ulangi, saya tidak mengerti mengapa topik ini tidak dipertimbangkan dalam literatur tentang codec video atau pemrosesan gambar.  Mungkin menggunakan terminologi yang berbeda, tetapi saya belum pernah bertemu.  Konsep "umpan balik" sudah mapan di bidang bekerja dengan suara.  tapi bukan masalah penting dalam pemrosesan gambar.  Mungkin karena biasanya filter harus diterapkan hanya sekali? <br><br>  Jika saya adalah seorang spesialis dalam bidang ini, maka kemungkinan besar saya memiliki pendapat tentang hal ini, dan mungkin saya bahkan akan tahu sudut-sudut literatur khusus di mana sudah ada solusi untuk masalah ini, yang diketahui hanya sedikit.  Tetapi, seperti yang saya katakan di awal artikel, saya tidak pernah bisa membuat filter sebelumnya, jadi saya mencari hanya di artikel terkenal (walaupun perlu dicatat bahwa setidaknya ada satu orang yang terkenal dalam literatur yang juga belum pernah mendengar hal seperti ini) ) <br><br>  Jadi, di pagi hari mereka memberi tahu saya bahwa kami membutuhkan filter ini, dan sepanjang hari saya mencoba membuatnya.  Pendekatan saya sederhana: Saya membuat program yang mengeksekusi filter ratusan kali dan pada akhirnya menghasilkan gambar sehingga saya bisa melihat hasil dari proses yang panjang.  Kemudian saya bereksperimen dengan koefisien filter yang berbeda dan mengamati hasilnya.  Itu benar-benar proses percobaan dan kesalahan terarah. <br><br>  Sekitar satu jam kemudian, saya mengambil koefisien filter terbaik yang cocok untuk tugas ini (tetapi mereka memiliki satu kelemahan, yang akan saya bahas di bagian kedua artikel): <br><br><pre> <code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Inti ini berada di ambang penajaman dan pengaburan.  Karena penajaman selalu mengarah pada umpan balik yang menciptakan artefak yang jelas dan jelas, inti filter ini lebih memilih sedikit blur sehingga gambar hanya terlihat sedikit lebih “membosankan”. <br><br>  Ini adalah tampilannya setelah 60 frame.  Untuk referensi, saya menunjukkan semua filter dalam urutan ini: gambar asli (tanpa filter), filter saya, bilinear, Lanczos, h.264, HEVC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Seperti yang Anda lihat, filter saya memberikan hasil yang sedikit lebih buram daripada mempertajam filter, tetapi tidak memiliki artefak ketajaman yang tidak dapat diterima setelah 60 frame.  Namun, Anda dapat memilih blur artefak untuk mempertajam artefak, sehingga Anda dapat memilih di antara filter penajam terbaik (Lanczos) dan tambang.  Namun, jika kami menambah jumlahnya menjadi 120 bingkai, maka filter saya keluar dari persaingan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Setelah 300 bingkai, semua filter, kecuali milikku, menjadi seperti lelucon buruk: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br>  Setelah 600 frame, lelucon itu menjadi lebih kejam: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br>  Anda bahkan tidak perlu mengatakan apa yang terjadi setelah 900 frame: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br><h2>  Seberapa stabil itu? </h2><br>  Pada tahap ini, secara alami akan bertanya-tanya: apakah filter saya <i>benar-benar</i> stabil, atau itu hanya blur yang sangat lambat, jauh lebih lambat daripada filter bilinear?  Mungkin setelah ribuan pengulangan, filter saya <i>secara bertahap</i> akan mengaburkan gambar? <br><br>  Anehnya, jawabannya tampaknya negatif.  Meskipun sedikit blur ditambahkan selama sekitar seratus overlay pertama, sepertinya filter <i>menyatu</i> dengan representasi gambar yang stabil, yang kemudian <i>tidak pernah mengalami</i> degradasi.  Berikut ini gambar lain yang diperbesar dari mata burung walrus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br>  Dari kiri ke kanan: gambar asli, filter saya diterapkan 60 kali, 120 kali, 300 kali, 600 dan 900 kali.  Seperti yang Anda lihat, keburaman menyatu ke kondisi stabil, yang tidak lagi menurun bahkan setelah ratusan hamparan filter.  Sebagai kontras, bandingkan ini dengan sinkronisasi berjendela untuk jumlah sampel yang sama (ketuk), dan lihat seberapa buruk (dan cepat!) Artefak membentuk umpan balik dan membuat hasil yang tidak berguna: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br>  Filter saya tampaknya sangat stabil, dan dibandingkan dengan semua filter yang saya lihat, ini menciptakan hasil terbaik setelah penggunaan berulang.  Tampaknya ia memiliki properti "asimptotik" tertentu, di mana data dengan cepat menyatu dengan gambar yang dihaluskan (terbatas), dan kemudian gambar yang dihaluskan ini disimpan dan tidak melakukan degradasi tanpa batas untuk menyelesaikan sampah. <br><br>  Saya bahkan mencoba menerapkan filter <i>sejuta</i> kali, dan tampaknya setelah beberapa ratus overlay pertama, itu tidak menurun lebih jauh.  Tanpa analisis matematis yang lebih baik (dan saya belum menemukan solusi matematika yang dapat membuktikannya dengan tepat, tetapi saya tahu pasti bahwa itu ada di suatu tempat), saya tidak dapat mengatakan dengan pasti bahwa di suatu tempat setelah miliaran atau triliunan lapisan yang -itu tidak akan rusak.  Dalam pengujian yang wajar, saya tidak dapat mendeteksi degradasi lebih lanjut. <br><br><h2>  Apakah ini merupakan filter Halfpel stabil terbaik untuk enam ketuk? </h2><br>  Pada tahap ini, masuk akal untuk mengajukan pertanyaan: apakah ini benar-benar yang terbaik yang dapat ditemukan?  Intuition memberi tahu kami bahwa itu bukan, karena saya sama sekali tidak memiliki pengetahuan tentang pengembangan filter dan hampir tidak melihat literatur, saya mengambil filter ini hanya dalam satu jam.  Paling tidak dapat <i>diasumsikan</i> bahwa setelah studi singkat seperti itu, saya tidak akan menemukan filter definitif-best-all-conquering-great. <br><br>  Apakah asumsi ini benar?  Dan jika benar, <i>apa yang</i> akan menjadi filter terbaik akhir?  Saya akan membahas ini secara lebih rinci di bagian kedua artikel ini. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468501/">https://habr.com/ru/post/id468501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468487/index.html">Apa yang bisa terjadi (Vektor serangan tipikal)</a></li>
<li><a href="../id468489/index.html">Penyelundupan Permintaan HTTP - pendekatan baru</a></li>
<li><a href="../id468491/index.html">Kutukan karma Habra</a></li>
<li><a href="../id468493/index.html">Struktur pandangan udara proyek Ilmu Data</a></li>
<li><a href="../id468497/index.html">Timer menyikat waktu 3 menit</a></li>
<li><a href="../id468503/index.html">Mail tidak melangkah lebih jauh 500 mil - FAQ</a></li>
<li><a href="../id468509/index.html">Pengembangan OS seperti Unix - Driver perangkat karakter (8)</a></li>
<li><a href="../id468511/index.html">Menerbitkan server melalui gateway D-Link DFL</a></li>
<li><a href="../id468515/index.html">Kiat berguna untuk integrasi ke dalam proyek baru</a></li>
<li><a href="../id468517/index.html">2. Gambaran Umum tentang Jaringan Ekstrim Beralih Dukungan Teknis dan Garansi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>