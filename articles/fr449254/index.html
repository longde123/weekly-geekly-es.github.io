<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 🚴🏼 🐔 FAQ sur l'architecture et le travail VKontakte 🥥 👩‍👩‍👧‍👧 🏐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'histoire de VKontakte est sur Wikipédia, raconte Pavel lui-même. Il semble que tout le monde la connaisse déjà. Pavel a parlé de l'intérieur, de l'a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FAQ sur l'architecture et le travail VKontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/449254/">  L'histoire de VKontakte est sur Wikipédia, raconte Pavel lui-même.  Il semble que tout le monde la connaisse déjà.  Pavel a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlé</a> de l'intérieur, de l'architecture et de la conception du site sur HighLoad ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en 2010</a> .  Beaucoup de serveurs ont fui depuis lors, nous allons donc mettre à jour les informations: nous disséquons, retirons l'intérieur, pesons - nous considérons le dispositif VK d'un point de vue technique. <br><br><img src="https://habrastorage.org/webt/_x/zc/wp/_xzcwpb5ze_4e-yx_jw_-8nvnei.jpeg"><br><br>  <strong>Alexey Akulovich</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">AterCattus</a> ) est un développeur backend de l'équipe VKontakte.  La transcription de ce rapport est une réponse collective aux questions fréquemment posées sur le fonctionnement de la plateforme, l'infrastructure, les serveurs et l'interaction entre eux, mais pas sur le développement, notamment <strong>sur le matériel</strong> .  Séparément - sur les bases de données et ce que VK a à leur place, sur la collecte des journaux et la surveillance de l'ensemble du projet dans son ensemble.  Détails sous la coupe. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_GqcriadL-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Depuis plus de quatre ans, je fais toutes sortes de tâches liées au backend. <br><br><ul><li>  Téléchargement, stockage, traitement, distribution de médias: vidéo, streaming en direct, audio, photos, documents. </li><li>  Infrastructure, plate-forme, surveillance des développeurs, journaux, caches régionaux, CDN, protocole propriétaire RPC. </li><li>  Intégration avec des services externes: push mailing, analyse de liens externes, flux RSS. </li><li>  Aidez vos collègues sur diverses questions, pour les réponses auxquelles vous devez plonger dans un code inconnu. </li></ul><br>  Pendant ce temps, j'ai participé à de nombreuses composantes du site.  Je veux partager cette expérience. <br><br><h2>  Architecture générale </h2><br>  Tout, comme d'habitude, commence par un serveur ou un groupe de serveurs qui acceptent les requêtes. <br><br><h3>  Serveur frontal </h3><br>  Le serveur frontal accepte les demandes via HTTPS, RTMP et WSS. <br><br>  <strong>Les HTTPS</strong> sont des demandes pour les versions Web principale et mobile du site: vk.com et m.vk.com, et d'autres clients officiels et non officiels de notre API: clients mobiles, messageries instantanées.  Nous avons du trafic <strong>RTMP</strong> pour les diffusions en direct avec des serveurs frontaux séparés et des connexions <strong>WSS</strong> pour l'API Streaming. <br><br>  Pour HTTPS et WSS, <strong>nginx est</strong> installé sur les serveurs.  Pour les émissions RTMP, nous avons récemment opté pour notre propre solution <strong>Kive</strong> , mais cela dépasse le cadre du rapport.  Pour la tolérance aux pannes, ces serveurs annoncent des adresses IP communes et agissent comme des groupes afin qu'en cas de problème sur l'un des serveurs, les requêtes des utilisateurs ne soient pas perdues.  Pour HTTPS et WSS, ces mêmes serveurs chiffrent le trafic pour prendre une partie de la charge CPU sur eux-mêmes. <br><br>  De plus, nous ne parlerons pas de WSS et RTMP, mais seulement des requêtes HTTPS standard, qui sont généralement associées à un projet Web. <br><br><h3>  Backend </h3><br>  Derrière le front se trouvent généralement les serveurs principaux.  Ils gèrent les demandes que le serveur frontal reçoit des clients. <br><br>  Ce sont des <strong>serveurs kPHP</strong> exécutant le démon HTTP car HTTPS est déjà décrypté.  kPHP est un serveur qui fonctionne selon le <strong>modèle prefork</strong> : il démarre le processus maître, un tas de processus enfants, leur transmet des sockets d'écoute et ils traitent leurs requêtes.  Dans le même temps, les processus ne sont pas redémarrés entre chaque demande de l'utilisateur, mais réinitialisent simplement leur état à l'état initial à valeur zéro - demande par demande, au lieu de redémarrer. <br><br><h4>  Partage de charge </h4><br>  Tous nos backends ne sont pas un énorme pool de machines capables de traiter n'importe quelle demande.  Nous les <strong>divisons en groupes distincts</strong> : général, mobile, api, vidéo, mise en scène ... Le problème sur un groupe de machines distinct n'affectera pas tout le monde.  En cas de problèmes avec la vidéo, l'utilisateur qui écoute de la musique ne connaît même pas les problèmes.  Le backend auquel envoyer la requête est résolu par nginx sur le devant de la configuration. <br><br><h4>  Collecte et rééquilibrage des métriques </h4><br>  Pour comprendre le nombre de voitures dont vous avez besoin dans chaque groupe, nous <strong>ne comptons pas sur QPS</strong> .  Les backends sont différents, ils ont des demandes différentes, chaque demande a une complexité de calcul QPS différente.  Par conséquent, nous utilisons le <strong>concept de charge sur le serveur dans son ensemble - sur le CPU et la perf</strong> . <br><br>  Nous avons des milliers de tels serveurs.  Le groupe kPHP s'exécute sur chaque serveur physique pour utiliser tous les noyaux (car kPHP est monothread). <br><br><h3>  Serveur de contenu </h3><br>  <strong>CS ou Content Server est un stockage</strong> .  CS est un serveur qui stocke les fichiers, et traite également les fichiers téléchargés, toutes sortes de tâches d'arrière-plan synchrones que le frontend Web principal lui pose. <br><br>  Nous avons des dizaines de milliers de serveurs physiques qui stockent des fichiers.  Les utilisateurs aiment télécharger des fichiers, et nous aimons les stocker et les partager.  Certains de ces serveurs sont fermés par des serveurs spéciaux pu / pp. <br><br><h3>  pu / pp </h3><br>  Si vous avez ouvert l'onglet réseau dans VK, vous avez vu pu / pp. <br><br><img src="https://habrastorage.org/webt/fd/am/xo/fdamxolkfxlplnc5h5flbihru3g.png"><br><br>  Qu'est-ce que pu / pp?  Si nous fermons un serveur après l'autre, il y a deux options pour télécharger et télécharger un fichier sur un serveur qui a été fermé: <strong>directement</strong> via <code>http://cs100500.userapi.com/path</code> ou <strong>via un serveur intermédiaire</strong> - <code>http://pu.vk.com/c100500/path</code> . <br><br>  <strong>Pu est le nom historique du téléchargement de photos et pp est un proxy de photos</strong> .  Autrement dit, un serveur pour télécharger des photos, et un autre - pour donner.  Désormais, non seulement les photos sont chargées, mais le nom a été conservé. <br><br>  Ces serveurs <strong>mettent fin</strong> aux <strong>sessions HTTPS</strong> pour supprimer la charge du processeur du stockage.  De plus, comme les fichiers utilisateur sont traités sur ces serveurs, moins les informations sensibles sont stockées sur ces machines, mieux c'est.  Par exemple, les clés de chiffrement HTTPS. <br><br>  Étant donné que les machines sont fermées par nos autres machines, nous pouvons nous permettre de ne pas leur donner des adresses IP externes «blanches» et de <strong>donner</strong> des adresses IP <strong>«grises»</strong> .  Nous avons donc économisé sur le pool IP et garanti de protéger les machines contre l'accès de l'extérieur - il n'y a tout simplement pas d'adresse IP pour y accéder. <br><br>  <strong>Tolérance aux pannes via IP partagée</strong> .  En termes de tolérance aux pannes, le schéma fonctionne de la même manière - plusieurs serveurs physiques ont une adresse IP physique commune, et le morceau de fer devant eux choisit où envoyer la demande.  Plus tard, je parlerai d'autres options. <br><br>  Le point controversé est que dans ce cas, le <strong>client détient moins de connexions</strong> .  S'il y a la même IP sur plusieurs machines - avec le même hôte: pu.vk.com ou pp.vk.com, le navigateur client a une limite sur le nombre de demandes simultanées à un hôte.  Mais pendant l'omniprésent HTTP / 2, je pense que ce n'est plus le cas. <br><br>  L'inconvénient évident du schéma est que vous devez <strong>pomper tout le trafic</strong> qui va vers le stockage via un autre serveur.  Étant donné que nous pompons le trafic dans les voitures, nous ne pouvons pas encore pomper le trafic lourd de la même manière, par exemple, la vidéo.  Nous le transférons directement - une connexion directe distincte pour les référentiels individuels spécifiquement pour la vidéo.  Nous transmettons un contenu plus léger via un proxy. <br><br>  Il n'y a pas si longtemps, nous avons une version améliorée du proxy.  Je vais maintenant vous expliquer en quoi ils diffèrent des modèles ordinaires et pourquoi cela est nécessaire. <br><br><h3>  Soleil </h3><br>  En septembre 2017, Oracle, qui avait précédemment acheté Sun, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">licencié un grand nombre d'employés de Sun.</a>  On peut dire qu'à ce moment la société a cessé d'exister.  En choisissant un nom pour le nouveau système, nos administrateurs ont décidé de rendre hommage et de respect à cette société et ont nommé le nouveau système Sun.  Entre nous, nous l'appelons simplement «soleil». <br><br><img src="https://habrastorage.org/webt/d3/6f/0j/d36f0jjqbwlst9mk2-lcncltkq4.png"><br><br>  Pp a eu quelques problèmes.  <strong>Une adresse IP par groupe est un cache inefficace</strong> .  Plusieurs serveurs physiques ont une adresse IP commune, et il n'y a aucun moyen de contrôler le serveur auquel la demande sera adressée.  Par conséquent, si différents utilisateurs viennent pour le même fichier, alors s'il existe un cache sur ces serveurs, le fichier s'installe dans le cache de chaque serveur.  Il s'agit d'un schéma très inefficace, mais rien ne pourrait être fait. <br><br>  Par conséquent, <strong>nous ne pouvons pas partager le contenu</strong> , car nous ne pouvons pas sélectionner un serveur spécifique pour ce groupe - ils ont une IP commune.  De plus, pour certaines raisons internes, nous <strong>n'avons pas eu la possibilité de mettre de tels serveurs dans les régions</strong> .  Ils ne se tenaient qu'à Saint-Pétersbourg. <br><br>  Avec les soleils, nous avons changé le système de sélection.  Nous avons maintenant le <strong>routage anycast</strong> : <strong>routage</strong> dynamique, anycast, démon d'auto-vérification.  Chaque serveur a sa propre IP individuelle, mais en même temps un sous-réseau commun.  Tout est configuré de manière à ce qu'en cas de perte d'un serveur, le trafic soit automatiquement réparti sur les autres serveurs du même groupe.  Il est maintenant possible de sélectionner un serveur spécifique, <strong>il n'y a pas de mise en cache excessive</strong> et la fiabilité n'est pas affectée. <br><br>  <strong>Support de poids</strong> .  Maintenant, nous pouvons nous permettre de mettre des voitures de capacités différentes selon les besoins, et également en cas de problèmes temporaires, de changer les poids des «soleils» de travail pour réduire la charge sur eux afin qu'ils se «reposent» et fonctionnent à nouveau. <br><br>  <strong>Partage par identifiant de contenu</strong> .  Ce qui est amusant avec le sharding, c'est que nous partitionnons généralement le contenu afin que différents utilisateurs suivent le même fichier à travers le même «soleil» afin qu'ils aient un cache commun. <br><br>  Nous avons récemment lancé l'application Clover.  Il s'agit d'un quiz de diffusion en direct en ligne où le présentateur pose des questions et les utilisateurs répondent en temps réel en choisissant des options.  L'application dispose d'un chat où les utilisateurs peuvent inonder.  <strong>Plus de 100 000 personnes</strong> peuvent se connecter simultanément à la diffusion.  Ils écrivent tous des messages qui sont envoyés à tous les participants, avec le message vient un autre avatar.  Si 100 000 personnes viennent pour un avatar dans un «soleil», il peut parfois rouler sur un nuage. <br><br>  Pour résister à des rafales de demandes provenant du même fichier, c'est pour une sorte de contenu que nous incluons un schéma stupide qui répartit les fichiers sur tous les "soleils" disponibles dans la région. <br><br><h4>  Soleil à l'intérieur </h4><br>  Proxy inverse vers nginx, cache en RAM ou disques rapides Optane / NVMe.  Exemple: <code>http://sun4-2.userapi.com/c100500/path</code> - lien vers le "soleil", qui se trouve dans la quatrième région, le deuxième groupe de serveurs.  Il ferme le fichier de chemin, qui se trouve physiquement sur le serveur 100500. <br><br><h3>  Cache </h3><br>  Nous ajoutons un nœud supplémentaire à notre schéma architectural - l'environnement de mise en cache. <br><br><img src="https://habrastorage.org/webt/jp/4p/xv/jp4pxvydhstms-z9bpbmpjy0htk.png"><br><br>  Vous trouverez ci-dessous la disposition des <strong>caches régionaux</strong> , il y en a environ 20.  Ce sont les endroits où se trouvent exactement les caches et les "soleils", qui peuvent mettre en cache le trafic à travers eux-mêmes. <br><br><img src="https://habrastorage.org/webt/yh/9i/qk/yh9iqkv3dyqd3uox9wgd2cmgqba.png"><br><br>  Il s'agit de la mise en cache du contenu multimédia, les données utilisateur ne sont pas stockées ici - juste de la musique, des vidéos, des photos. <br><br>  Pour déterminer la région de l'utilisateur, nous <strong>collectons les préfixes de réseau BGP annoncés dans les régions</strong> .  Dans le cas de repli, nous avons toujours l'analyse de la base geoip, si nous ne pouvions pas trouver IP par préfixes.  <strong>Par IP utilisateur, nous déterminons la région</strong> .  Dans le code, nous pouvons regarder une ou plusieurs régions de l'utilisateur - les points dont il est géographiquement le plus proche. <br><br><h4>  Comment ça marche? </h4><br>  <strong>Nous considérons la popularité des fichiers par région</strong> .  Il y a un numéro de cache régional où se trouve l'utilisateur et un identifiant de fichier - nous prenons cette paire et incrémentons la note pour chaque téléchargement. <br><br>  Dans le même temps, les démons - services dans les régions - viennent de temps en temps à l'API et disent: "J'ai tel ou tel cache, donnez-moi une liste des fichiers les plus populaires de ma région que je n'ai pas encore."  L'API donne un tas de fichiers triés par note, le démon les pompe, les transporte dans les régions et leur donne des fichiers à partir de là.  C'est une différence fondamentale entre pu / pp et Sun des caches: ils transmettent le fichier par eux-mêmes immédiatement, même si le fichier n'existe pas dans le cache, et le cache pompe d'abord le fichier pour lui-même, puis il commence à le révéler. <br><br>  Dans le même temps, nous <strong>rapprochons le contenu des utilisateurs</strong> et réduisons la charge du réseau.  Par exemple, uniquement à partir du cache de Moscou, nous distribuons plus de 1 Tbit / s pendant les heures de pointe. <br><br>  Mais il y a des problèmes - <strong>les serveurs de cache ne sont pas en caoutchouc</strong> .  Pour le contenu super populaire, il n'y a parfois pas assez de réseau sur un serveur séparé.  Nous avons des serveurs de cache de 40 à 50 Gbit / s, mais il y a du contenu qui obstrue complètement un tel canal.  Nous nous efforçons de réaliser le stockage de plus d'une copie de fichiers populaires dans la région.  J'espère que nous le réaliserons d'ici la fin de l'année. <br><br>  Nous avons examiné l'architecture générale. <br><br><ul><li>  Serveurs frontaux qui acceptent les demandes. </li><li>  Backends qui traitent les demandes. </li><li>  Des coffres fermés par deux types de procurations. </li><li>  Caches régionaux. </li></ul><br>  Qu'est-ce qui manque à ce schéma?  Bien sûr, les bases de données dans lesquelles nous stockons les données. <br><br><h2>  Bases de données ou moteurs </h2><br>  Nous ne les appelons pas des bases de données, mais des moteurs moteurs, car dans le sens généralement admis, nous n'avons pratiquement pas de bases de données. <br><br><img src="https://habrastorage.org/webt/n6/zm/lj/n6zmlj5pwxsnqoqp0xgfhxza_ic.png"><br><br>  <strong>C'est une mesure nécessaire</strong> .  Cela est arrivé parce qu'en 2008-2009, lorsque VK a connu une croissance explosive de la popularité, le projet a pleinement fonctionné sur MySQL et Memcache, et il y avait des problèmes.  MySQL aimait tomber et ruiner des fichiers, après quoi il ne montait pas, et Memcache dégradait progressivement ses performances et devait être redémarré. <br><br>  Il s'avère que dans le projet qui gagnait en popularité, il y avait un stockage persistant qui corrompait les données et un cache qui ralentissait.  Dans ces conditions, il est difficile de développer un projet en pleine croissance.  Il a été décidé d'essayer de réécrire les éléments essentiels sur lesquels le projet reposait sur leurs propres vélos. <br><br>  <strong>La solution a réussi</strong> .  La possibilité de le faire était, tout comme un besoin urgent, car il n'existait pas à l'époque d'autres méthodes de mise à l'échelle.  Il n'y avait pas de tas de bases, NoSQL n'existait pas encore, il n'y avait que MySQL, Memcache, PostrgreSQL - et c'est tout. <br><br>  <strong>Fonctionnement universel</strong> .  Le développement a été mené par notre équipe de développeurs C, et tout a été fait de la même manière.  Quel que soit le moteur, partout il y avait à peu près le même format des fichiers écrits sur le disque, les mêmes paramètres de démarrage, les signaux étaient traités de la même manière et se comportaient de la même manière en cas de situations de bord et de problèmes.  Avec la croissance des moteurs, il est pratique pour les administrateurs de faire fonctionner le système - il n'y a pas de zoo à entretenir et d'apprendre à exploiter chaque nouvelle base tierce, ce qui a permis d'augmenter rapidement et facilement leur nombre. <br><br><h3>  Types de moteurs </h3><br>  L'équipe a écrit pas mal de moteurs.  Voici quelques-uns d'entre eux: ami, conseils, image, ipdb, lettres, listes, journaux, memcached, meowdb, actualités, nostradamus, photo, listes de lecture, pmemcached, sandbox, recherche, stockage, likes, tâches, ... <br><br>  Pour chaque tâche nécessitant une structure de données spécifique ou traitant des requêtes atypiques, l'équipe C écrit un nouveau moteur.  Pourquoi pas. <br><br>  Nous avons un moteur <strong>memcached</strong> séparé, qui est similaire à celui habituel, mais avec un tas de petits pains, et qui ne ralentit pas.  Pas ClickHouse, mais fonctionne aussi.  Il y a <strong>pmemcached</strong> séparément - c'est un <strong>memcached persistant</strong> qui peut stocker des données également sur le disque, et plus que ce qu'il entre dans la RAM afin de ne pas perdre de données lors du redémarrage.  Il existe différents moteurs pour des tâches individuelles: files d'attente, listes, ensembles - tout ce qui est requis par notre projet. <br><br><h3>  Clusters </h3><br>  Du point de vue du code, il n'est pas nécessaire d'imaginer des moteurs ou des bases de données comme certains processus, entités ou instances.  Le code fonctionne spécifiquement avec les clusters, avec des groupes de moteurs - <strong>un type par cluster</strong> .  Disons qu'il y a un cluster memcached - c'est juste un groupe de machines. <br><br><blockquote>  Le code n'a pas besoin de connaître l'emplacement physique, la taille et le nombre de serveurs.  Il va au cluster par un identifiant. </blockquote><br>  Pour que cela fonctionne, vous devez ajouter une autre entité, située entre le code et les moteurs - <strong>proxy</strong> . <br><br><h3>  Proxy RPC </h3><br>  Proxy - un <strong>bus de connexion</strong> , qui exécute presque tout le site.  Dans le même temps, nous <strong>n'avons pas de découverte de service</strong> - au lieu de cela, il y a une configuration de ce proxy, qui connaît l'emplacement de tous les clusters et de tous les fragments de ce cluster.  Cela est fait par les administrateurs. <br><br>  Les programmeurs ne se soucient généralement pas de combien, où et ce que cela coûte - ils vont simplement au cluster.  Cela nous permet beaucoup.  Dès réception de la demande, le proxy redirige la demande, sachant où - il le détermine. <br><br><img src="https://habrastorage.org/webt/7k/pf/ia/7kpfiagxzy2a4mrosc_f4otqnw8.png"><br><br>  Dans le même temps, le proxy est un point de protection contre les pannes de service.  Si un moteur ralentit ou tombe en panne, le proxy le comprend et répond en conséquence du côté client.  Cela vous permet de supprimer le délai d'expiration - le code n'attend pas que le moteur réponde, mais comprend qu'il ne fonctionne pas et que vous devez vous comporter différemment.  Le code doit être préparé pour le fait que les bases de données ne fonctionnent pas toujours. <br><br><h4>  Implémentations spécifiques </h4><br>  Parfois, nous voulons toujours vraiment avoir une sorte de solution personnalisée comme moteur.  En même temps, il a été décidé de ne pas utiliser notre proxy rpc prêt à l'emploi, créé spécifiquement pour nos moteurs, mais de créer un proxy séparé pour la tâche. <br><br>  Pour MySQL, que nous avons encore à certains endroits, nous utilisons db-proxy et pour ClickHouse - <strong>Kittenhouse</strong> . <br><br>  Cela fonctionne globalement comme ça.  Il y a un serveur, kPHP, Go, Python fonctionnent dessus - en général, tout code pouvant suivre notre protocole RPC.  Le code va localement à RPC-proxy - sur chaque serveur où il y a du code, son propre proxy local est lancé.  Sur demande, le mandataire sait où aller. <br><br><img src="https://habrastorage.org/webt/f-/dx/ro/f-dxrox3o97ckejzygz8mgf4tcs.png"><br><br>  Si un moteur veut passer à un autre, même s'il s'agit d'un voisin, il passe par un proxy, car le voisin peut se trouver dans un centre de données différent.  Le moteur ne doit pas être lié à la connaissance de l'emplacement d'autre chose que lui-même - nous avons cette solution standard.  Mais bien sûr, il y a des exceptions :) <br><br>  Un exemple de schéma TL selon lequel tous les moteurs fonctionnent. <br><br><pre> <code class="plaintext hljs">memcache.not_found = memcache.Value; memcache.strvalue value:string flags:int = memcache.Value; memcache.addOrIncr key:string flags:int delay:int value:long = memcache.Value; tasks.task fields_mask:# flags:int tag:%(Vector int) data:string id:fields_mask.0?long retries:fields_mask.1?int scheduled_time:fields_mask.2?int deadline:fields_mask.3?int = tasks.Task; tasks.addTask type_name:string queue_id:%(Vector int) task:%tasks.Task = Long;</code> </pre> <br>  Il s'agit d'un protocole binaire, dont l'analogue le plus proche est <strong>protobuf.</strong>  Le schéma décrit à l'avance les champs facultatifs, les types complexes - les extensions de scalaires intégrés et les requêtes.  Tout fonctionne selon ce protocole. <br><br><h4>  RPC sur TL sur TCP / UDP ... UDP? </h4><br>  Nous avons un protocole RPC pour interroger le moteur, qui s'exécute au-dessus du schéma TL.  Tout cela fonctionne en plus de la connexion TCP / UDP.  TCP - il est clair pourquoi nous sommes souvent interrogés sur UDP. <br><br>  UDP permet d' <strong>éviter le problème d'un grand nombre de connexions entre les serveurs</strong> .  S'il y a un proxy RPC sur chaque serveur et en général, il peut aller à n'importe quel moteur, vous obtenez des dizaines de milliers de connexions TCP au serveur.  Il y a une charge, mais elle est inutile.  Dans le cas d'UDP, ce n'est pas un problème. <br><br>  <strong>Aucune poignée de main TCP redondante</strong> .  Il s'agit d'un problème typique: lorsqu'un nouveau moteur ou un nouveau serveur arrive, de nombreuses connexions TCP sont établies en même temps.  Pour les petites demandes légères, par exemple, la charge utile UDP, toutes les communications entre le code et le moteur sont <strong>deux paquets UDP: l'</strong> un vole dans un sens, l'autre vole dans l'autre.  Un aller-retour - et le code a reçu une réponse du moteur sans poignée de main. <br><br>  Oui, tout cela ne fonctionne <strong>qu'avec un très faible pourcentage de perte de paquets</strong> .  Le protocole prend en charge les retransmissions, les délais d'attente, mais si nous perdons beaucoup, nous obtenons pratiquement TCP, ce qui n'est pas rentable.  À travers les océans, ne conduisez pas UDP. <br><br>  Nous avons des milliers de ces serveurs, et le même schéma existe: un pack de moteurs est placé sur chaque serveur physique.  Fondamentalement, ils sont à filetage unique pour fonctionner aussi rapidement que possible sans blocage, et sont déchiquetés en tant que solutions à filetage unique.  Dans le même temps, nous n'avons rien de plus fiable que ces moteurs, et une grande attention est accordée au stockage persistant des données. <br><br><h3>  Stockage de données persistant </h3><br>  <strong>Les moteurs écrivent des binlogs</strong> .  Un binlog est un fichier à la fin duquel un événement est ajouté pour changer un état ou des données.  Dans différentes solutions, il est appelé différemment: log binaire, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WAL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AOF</a> , mais le principe est un. <br><br>  Afin que le moteur ne relise pas l'intégralité du binlog lors d'un redémarrage pendant plusieurs années, les moteurs écrivent des <strong>instantanés - l'état actuel</strong> .  Si nécessaire, ils lisent d'abord celui-ci, puis lisent à partir du binlog.  Tous les binlogs sont écrits dans le même format binaire - selon le schéma TL, afin que les administrateurs puissent les administrer également avec leurs outils.  Il n'y a pas un tel besoin de clichés.  Il y a un titre général qui indique dont l'instantané est l'int, la magie du moteur, et quel corps n'est important pour personne.  C'est le problème du moteur qui a enregistré l'instantané. <br><br>  Je décrirai brièvement le principe du travail.  Il existe un serveur sur lequel le moteur fonctionne.  Il ouvre un nouveau binlog vide pour l'enregistrement, y écrit un événement de modification. <br><br><img src="https://habrastorage.org/webt/dd/w9/9p/ddw99p7g6upg9hci9ou6aln6d_c.png"><br><br>  À un moment donné, il décide soit de prendre un instantané, soit il reçoit un signal.  Le serveur crée un nouveau fichier, y écrit complètement son état, ajoute la taille actuelle du binlog - décalé à la fin du fichier et continue d'écrire davantage.  Un nouveau binlog n'est pas créé. <br><br><img src="https://habrastorage.org/webt/ec/fq/yt/ecfqytibh2tsm5ncd8mfli-b1ta.png"><br><br>  À un certain moment, lorsque le moteur redémarre, il y aura un binlog et un instantané sur le disque.  Le moteur lit en instantané complet, élève son état à un certain point. <br><br><img src="https://habrastorage.org/webt/bg/ph/-u/bgph-uu68nqedhby4a2kf3r9c5u.png"><br><br>  Soustrait la position qui était au moment de la création de l'instantané et la taille du binlog. <br><br><img src="https://habrastorage.org/webt/ar/gs/lq/argslqv8ewosmtic8-zaobq4g5o.png"><br><br>  Lit la fin du binlog pour obtenir l'état actuel et continue d'écrire d'autres événements.  C'est un schéma simple, tous nos moteurs y travaillent. <br><br><h4>  Réplication de données </h4><br>  Par conséquent, la réplication des données est <strong>basée sur des instructions</strong> - nous n'écrivons aucune modification de page dans le binlog, mais plutôt des <strong>demandes de modifications</strong> .  Très similaire à ce qui vient sur le réseau, seulement un peu changé. <br><br>  Le même schéma est utilisé non seulement pour la réplication, mais également <strong>pour la création de sauvegardes</strong> .  Nous avons un moteur - un maître d'écriture qui écrit dans un binlog.  Dans tout autre endroit où les administrateurs s'installent, la copie de ce binlog augmente, et c'est tout - nous avons une sauvegarde. <br><br><img src="https://habrastorage.org/webt/og/al/sz/ogalszm0wfe3f_064sbjnpo4p9c.png"><br><br>  Si vous avez besoin d'une <strong>réplique de lecture</strong> afin de réduire la charge de lecture sur le CPU, le moteur de lecture monte simplement, qui lit la fin du binlog et exécute ces commandes localement. <br><br>  Le décalage ici est très faible et il est possible de découvrir à quel point la réplique se trouve derrière le maître. <br><br><h3>  Partage de données dans le proxy RPC </h3><br>  Comment fonctionne le sharding?  Comment le proxy comprend-il le fragment de cluster auquel envoyer?  Le code ne dit pas: "Envoyer à 15 fragments!"  - non, il fait un proxy. <br><br>  <strong>Le schéma le plus simple est firstint</strong> , le premier numéro de la demande. <br><br> <code>get(photo100_500) =&gt; 100 % N.</code> <br> <br>  Ceci est un exemple pour un protocole de texte memcached simple, mais, bien sûr, les demandes sont complexes, structurées.  L'exemple prend le premier nombre de la requête et le reste de la division par la taille du cluster. <br><br>  Ceci est utile lorsque nous voulons avoir la localité des données d'une entité.  Disons que 100 est un ID d'utilisateur ou de groupe, et nous voulons que toutes les données d'une entité soient sur le même fragment pour les requêtes complexes. <br><br>  Si nous ne nous soucions pas de la façon dont les demandes sont réparties dans le cluster, il existe une autre option: <strong>hacher l'intégralité du fragment</strong> . <br><br> <code>hash(photo100_500) =&gt; 3539886280 % N</code> <br> <br>  Nous obtenons également le hachage, le reste de la division et le numéro du fragment. <br><br>  Ces deux options ne fonctionnent que si nous sommes préparés au fait que lorsque nous augmentons la taille du cluster, nous le divisons ou l'augmentons plusieurs fois.  Par exemple, nous avions 16 fragments, nous manquons, nous en voulons plus - vous pouvez en obtenir 32 en toute sécurité sans interruption.  Si nous voulons construire plusieurs fois, il y aura un temps d'arrêt, car il ne sera pas possible de tout écraser soigneusement sans perte.  Ces options sont utiles, mais pas toujours. <br><br>  Si nous devons ajouter ou supprimer un nombre arbitraire de serveurs, <strong>un hachage cohérent sur l'anneau à la Ketama est utilisé</strong> .  Mais en même temps, nous perdons complètement la localité des données, nous devons faire une demande de fusion au cluster afin que chaque pièce renvoie sa petite réponse, et déjà combiner les réponses au proxy. <br><br>  - .   : RPC-proxy  , ,       .     , ,     ,      .    proxy. <br><br><img src="https://habrastorage.org/webt/jx/6t/f9/jx6tf9jlkkmva1qfifzmwrx58wc.png"><br><br><h2>  </h2><br>     .     — <strong>   memcache</strong> . <br><br> <code>ring-buffer: prefix.idx = line</code> <br> <br>    —  , ,      —  .     0     1.   memcache —       .        . <br><br>    ,   <strong>Multi Get</strong>  ,   ,         .  ,   -      ,   ,         ,      . <br><br>         <strong>logs-engine</strong> .      ,       .       600   . <br><br>   ,  ,    6–7 .    ,    , ,    ClickHouse   . <br><br><h3>    ClickHouse </h3><br>   ,      . <br><br><img src="https://habrastorage.org/webt/jm/-j/s0/jm-js04tjh8lb8pii1_dzl_sfa4.png"><br><br>  ,   RPC    RPC-proxy,   ,    .       ClickHouse,        : <br><br><ul><li>  -   ClickHouse; </li><li>  RPC-proxy,      ClickHouse,  - ,  ,   RPC. </li></ul><br>    —          ClickHouse. <br><br>     ClickHouse,   <strong>KittenHouse</strong> .      KittenHouse  ClickHouse —   .   ,  HTTP-     .   ,    ClickHouse <strong>  reverse proxy</strong> ,   ,     .         . <br><br><img src="https://habrastorage.org/webt/zj/fy/5y/zjfy5yuay9-6wqe3nrgjkeznvny.png"><br><br>      RPC-   , ,  nginx.   KittenHouse      UDP. <br><br><img src="https://habrastorage.org/webt/hq/wl/v_/hqwlv_vnujb-maxakxksbmrf6xo.png"><br><br>         ,    UDP-      .       RPC     ,      UDP.      . <br><br><h2>  Suivi </h2><br>     : ,        ,     .     : <strong>  </strong> . <br><br><h3>   </h3><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Netdata</a> ,        <strong>Graphite Carbon</strong> .      ClickHouse,   Whisper, .       ClickHouse,   <strong>Grafana</strong>  ,   .  ,   Netdata  Grafana  . <br><br><h3>   </h3><br>      . ,    ,    Counts, UniqueCounts   ,   - . <br><br><pre> <code class="plaintext hljs">statlogsCountEvent ( 'stat_name', $key1, $key2, …) statlogsUniqueCount ( 'stat_name', $uid, $key1, $key2, …) statlogsValuetEvent ( 'stat_name', $value, $key1, $key2, …) $stats = statlogsStatData($params)</code> </pre><br>      ,    ,     —  ,  Wathdogs. <br><br>    <strong> ,</strong>    600   1   .       <strong>   </strong> ,     .     —  ,     . ,      . <br><br>    ,     <strong>  memcache</strong> ,    .         <strong>stats-daemon</strong>   .         <strong>logs-collectors</strong> ,       ,      . <br><br><img src="https://habrastorage.org/webt/ih/ab/oy/ihaboy4luh5hriorej9seodbx6u.png"><br><br>        logs-collectors. <br><br><img src="https://habrastorage.org/webt/fq/ta/bj/fqtabjgq556wqfdz5_kfq3mj94c.png"><br><br>          stas-daemom —   ,      collector.  ,    -        memcache stats-daemon,   ,    . <br><br>  logs-collectors    <strong>meowDB</strong> —   ,      . <br><br><img src="https://habrastorage.org/webt/v_/gb/_y/v_gb_ya-9ywkra7xdh5h_qtqsc4.png"><br><br>      «-SQL»  . <br><br><img src="https://habrastorage.org/webt/1q/gw/wp/1qgwwpyj3ewcwuonshvty_zcfhc.png"><br><br><h3>  </h3><br>  2018     ,          -,      ClickHouse.      ClickHouse —    ? <br><br><img src="https://habrastorage.org/webt/wg/mz/kl/wgmzklw41x7ilj0-5hbr_kfdif8.png"><br><br>    ,     KittenHouse. <br><br><img src="https://habrastorage.org/webt/kq/s7/uj/kqs7ujzbhnqzt5f8djepldmwxia.png"><br><br>   <strong>     «*House»</strong> ,        ,       UDP.   *House    inserts,  ,   KittenHouse.        ClickHouse,     . <br><br><img src="https://habrastorage.org/webt/ff/k3/th/ffk3thypln9exuhyuhr-nuj9hr4.png"><br><br>   memcache, stats-daemon  logs-collectors    . <br><br><img src="https://habrastorage.org/webt/r4/g3/e9/r4g3e9yakpzbx5gscmgyl6keqsa.png"><br><br>   memcache, stats-daemon  logs-collectors    . <br><br><ul><li>     ,     StatsHouse. </li><li> StatsHouse   KittenHouse UDP-,    SQL-inserts, . </li><li> KittenHouse    ClickHouse. </li><li>     ,      StatsHouse —   ClickHouse  SQL. </li></ul><br>    <strong></strong> ,   ,  .    , , ,    .     . <br><br>  <strong>  </strong> .   ,    stats-daemons  logs-collectors,  ClickHouse   ,  ,     . <strong>  ,       </strong> . <br><br><h2>  </h2><br>     PHP.    <strong>git</strong> :  <strong>GitLab</strong>  <strong>TeamCity</strong>  .     -,       ,   —  . <br><br>        ,     diff  — : , , .     binlog   copyfast,          .     ,  <strong>gossip replication</strong> ,       ,  —  ,   .            .      ,       <strong>  </strong> .       . <br><br>     kPHP         <strong>git</strong>   .    <strong> HTTP-</strong> ,      diff —     .     —    <strong>binlog copyfast</strong> .     ,      .  <strong>  </strong> .  copyfast' ,   binlog   ,     gossip replication     ,    -,      .   <strong>graceful </strong>   . <br><br>   ,     ,   : <br><br><ul><li> git master branch; </li><li>   <strong>.deb</strong> ; </li><li>    binlog copyfast; </li><li>   ; </li><li>     .dep; </li><li> <strong>dpkg -i</strong> ; </li><li> graceful    . </li></ul><br>   ,        <strong>.deb</strong> ,     <strong>dpkg -i</strong>   .    kPHP  ,   — dpkg?  .  —  . <br><br> <b> :</b> <br><br><ul><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«  Vkontakte. ?»</a>    copyfast  gossip. </li><li>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">« VK    CLickHouse    »</a> . </li><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«     »</a> ,     ,   . </li></ul><br><blockquote>     ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHP Russia</a>  17          PHP-. ,     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> (     PHP!) — ,      PHP,   . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449254/">https://habr.com/ru/post/fr449254/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449236/index.html">Ok Google: Comment puis-je passer par le captcha?</a></li>
<li><a href="../fr449240/index.html">L'histoire d'un jeune service Daida (abonnement art)</a></li>
<li><a href="../fr449246/index.html">AX200 - Intel Wi-Fi 6</a></li>
<li><a href="../fr449248/index.html">IDE moderne. Certainement D, dans une certaine mesure E, et certainement pas moi</a></li>
<li><a href="../fr449252/index.html">Projets Zombie - fusionnez les données des utilisateurs même après sa mort</a></li>
<li><a href="../fr449256/index.html">J'ai lu 80 CV, j'ai des questions</a></li>
<li><a href="../fr449260/index.html">Qu'est-ce que l'apprentissage automatique automatisé (AutoML)</a></li>
<li><a href="../fr449262/index.html">Dernière mise à niveau IRM - Siebel vers IP17 +</a></li>
<li><a href="../fr449264/index.html">Création d'un système de reporting pour 1C: ERP basé sur OLAP et Excel</a></li>
<li><a href="../fr449266/index.html">3 rapports avec RusCrypto: conférences avec expérience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>