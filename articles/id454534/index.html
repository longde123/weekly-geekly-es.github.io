<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚱 🏁 😝 Tidak ilmiah tentang monad 📃 🚵🏼 🈸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya. 

 Setelah empat tahun pemrograman pada Scala, pemahaman saya tentang monad akhirnya berkembang ke titik di mana Anda dapat menjelaskan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tidak ilmiah tentang monad</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454534/"> Halo semuanya. <br><br>  Setelah empat tahun pemrograman pada Scala, pemahaman saya tentang monad akhirnya berkembang ke titik di mana Anda dapat menjelaskannya kepada orang lain tanpa mengacu pada teori kategori dan <i>monad</i> klasik <i>- itu hanya monoid dalam kategori endofunders</i> , yang membuat takut programmer tidak lebih buruk daripada kecoak dichlorvos. <br><br>  Contoh kode akan ditulis di Kotlin, sebagai  itu cukup populer, dan pada saat yang sama cukup fungsional (dalam kedua pengertian kata). <br><a name="habracut"></a><br>  Mari kita mulai dengan konsep <i>functor</i> , ini dia: <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre> <br>  Apa maknanya?  Functor adalah abstraksi dari perhitungan arbitrer yang mengembalikan hasil tipe A. Kita mengabaikan cara membuat functor baru, dan, yang paling penting, bagaimana menghitung nilainya A. Secara khusus, fungsi dapat bersembunyi di balik antarmuka functor dengan sejumlah argumen sewenang-wenang, dan belum tentu fungsi murni. <br><br>  Contoh implementasi functor: <br><br><ul><li>  konstan </li><li>  berfungsi dengan sejumlah argumen arbitrer yang mengembalikan hasil tipe <code>A</code> </li><li>  state pseudo-random generator (Acak) </li><li>  generator nomor acak perangkat keras </li><li>  membaca objek dari disk atau dari jaringan </li><li>  perhitungan asinkron - panggilan balik dilewatkan ke implementasi functor, yang akan dipanggil beberapa waktu kemudian </li></ul><br>  Semua contoh ini, kecuali untuk konstanta, memiliki satu properti penting - mereka malas, mis.  perhitungan itu sendiri tidak terjadi ketika functor dibuat, tetapi ketika dihitung. <br><br>  Antarmuka functor tidak memungkinkan mendapatkan nilai tipe <code>A</code> dari <code>Functor&lt;A&gt;</code> , atau membuat <code>Functor&lt;A&gt;</code> baru <code>Functor&lt;A&gt;</code> dari nilai tipe <code>A</code>  Tetapi bahkan dengan pembatasan seperti itu, functor tidak sia-sia - jika untuk beberapa tipe <code>B</code> kita dapat mengkonversi <code>A</code> ke <code>B</code> (dengan kata lain, ada fungsi <code>(a: A) -&gt; B</code> ), maka kita dapat menulis fungsi <code>(f: Functor&lt;A&gt;) -&gt; Functor&lt;B&gt;</code> dan <code>(f: Functor&lt;A&gt;) -&gt; Functor&lt;B&gt;</code> nama <code>map</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;B&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; B): Functor&lt;B&gt; }</code> </pre><br>  Berbeda dengan functor itu sendiri, metode peta tidak bisa menjadi fungsi arbitrer: <br>  - <code>map((a) -&gt; a)</code> harus mengembalikan functor yang sama <br>  - <code>map((a) -&gt; f(a)).map((b) -&gt; g(b))</code> harus identik dengan <code>map(a -&gt; g(f(a))</code> <br><br>  Sebagai contoh, kami mengimplementasikan functor yang mengembalikan nilai A yang mengandung sejumlah bit acak.  Antarmuka kami di Kotlin tidak dapat digunakan dengan mudah (tetapi Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat</a> , jika diinginkan), jadi kami akan menulis metode ekstensi: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">//  - ,     ,   map data class MyRandom&lt;A&gt;( val get: (bits: Int) -&gt; A ) { companion object { val intRandom: MyRandom&lt;Int&gt; = MyRandom { Random.nextBits(it) } val hexRandom: MyRandom&lt;String&gt; = intRandom.map { it.toString(16) } } } //  map   fun &lt;A, B&gt; MyRandom&lt;A&gt;.map(f: (A) -&gt; B): MyRandom&lt;B&gt; = MyRandom(get = {bits -&gt; f(get(bits)) }) fun main(args: Array&lt;String&gt;) { println("random=" + MyRandom.intRandom.get(12)) //  random=1247 println("hexRandom=" + MyRandom.hexRandom.get(12)) //  hexRandom=c25 }</span></span></code> </pre><br>  Contoh lain dari functors dengan <code>map</code> berguna <br><br><ul><li>  <code>List&lt;A&gt;</code> abadi <code>List&lt;A&gt;</code> </li><li> <code>MyInputStream&lt;A&gt;</code> </li> <li> <code>Optional&lt;A&gt;</code> </li> </ul><br>  Sekarang kamu bisa pergi ke monads. <br><br>  Monad adalah functor dengan dua operasi tambahan.  Pertama-tama, monad, tidak seperti functor, berisi operasi penciptaan dari sebuah konstanta, operasi ini disebut <code>lift</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Monad&lt;A&gt; = TODO()</code> </pre><br>  Operasi kedua disebut <code>flatMap</code> , ini lebih rumit, jadi pertama-tama kami akan memberikan seluruh antarmuka monad kami: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Monad</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,  map     - //    flatMap  lift fun &lt;B&gt; map(f: (A) -&gt; B): Monad&lt;B&gt; = flatMap { a -&gt; lift(f(a)) } fun &lt;B&gt; flatMap(f: (A) -&gt; Monad&lt;B&gt;): Monad&lt;B&gt; } fun &lt;A&gt; lift(value: A): Monad&lt;A&gt; = TODO()</span></span></code> </pre><br>  Perbedaan paling penting antara monad dan functor adalah bahwa monad dapat <i>dikombinasikan</i> satu sama lain, menghasilkan monad baru dan abstrak dari bagaimana monad diimplementasikan - apakah itu membaca dari disk, apakah itu menerima parameter tambahan untuk menghitung nilainya, apakah nilai ini ada .  Poin penting kedua - monad tidak digabungkan secara paralel, tetapi secara berurutan, meninggalkan kemampuan untuk menambahkan logika tergantung pada hasil dari monad pertama. <br><br>  Contoh: <br><br><pre> <code class="kotlin hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     Int //       -      //           val readInt: Monad&lt;Int&gt; = TODO() // ,      -  fun readBytes(len: Int): Monad&lt;ByteArray&gt; = TODO() // ,     ,    val bytes: Monad&lt;ByteArray&gt; = readInt.flatMap {len -&gt; if (len &gt; 0) readBytes(len) //    -   else lift(ByteArray(0)) //  ,    }</span></span></code> </pre><br>  Namun, dalam contoh ini tidak disebutkan jaringan.  Sama baiknya, data dapat dibaca dari file atau dari database.  Mereka dapat dibaca secara sinkron atau asinkron, di sini mungkin ada penanganan kesalahan - semuanya tergantung pada implementasi spesifik dari monad, kode itu sendiri akan tetap tidak berubah. <br><br>  Pada awalnya contohnya lebih sederhana, Opsi monad.  Di kotlin, itu tidak benar-benar dibutuhkan, tetapi di Jawa / Scala sangat berguna: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: A?) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; map(f: (A) -&gt; B): Option&lt;B&gt; = flatMap { a -&gt; lift(f(a)) } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; flatMap(f: (A) -&gt; Option&lt;B&gt;): Option&lt;B&gt; = </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">when</span></span></span><span class="hljs-function">(value) { </span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function"> -&gt; Option(</span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-literal">null</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> -&gt; f(value) } } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;A&gt; lift(value: A?): Option&lt;A&gt; = Option(value) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> mul(a: Option&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">&gt;, b: Option&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">&gt;): Option&lt;</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">Int</span></span></span><span class="hljs-function">&gt; = a.flatMap { a -&gt; b.map { b -&gt; a * b } } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { println(mul(Option(<span class="hljs-number"><span class="hljs-number">4</span></span>), Option(<span class="hljs-number"><span class="hljs-number">5</span></span>)).value) <span class="hljs-comment"><span class="hljs-comment">// 20 println(mul(Option(null), Option(5)).value) // null println(mul(Option(4), Option(null)).value) // null println(mul(Option(null), Option(null)).value) // null }</span></span></code> </pre><br>  Sebagai monad pozakovyristy, mari kita selesaikan pekerjaan basis data dengan monad: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DB</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">&gt;</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: (Connection) -&gt; A) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; map(f: (A) -&gt; B): DB&lt;B&gt; = flatMap { a -&gt; lift(f(a)) } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> &lt;B&gt; flatMap(f: (A) -&gt; DB&lt;B&gt;): DB&lt;B&gt; = DB { conn -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this.f(conn)</span></span></span></span>).f(conn) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;A&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: DB&lt;A&gt; = DB { value } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: DB&lt;String&gt; = DB { conn -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> st = conn.createStatement() <span class="hljs-comment"><span class="hljs-comment">// .... TODO() } fun update(value: String): DB&lt;Unit&gt; = DB { conn -&gt; val st = conn.createStatement() // .... TODO() } fun selectThenUpdate(id: Int): DB&lt;Unit&gt; = select(id).flatMap { value -&gt; update(value) } fun executeTransaction(c: Connection): Unit { //  ,     //          val body: DB&lt;Unit&gt; = selectThenUpdate(42) //  ,   select  update body.f(c) c.commit() }</span></span></code> </pre><br><h3>  Apakah lubang kelinci dalam? </h3><br>  Ada berbagai macam monad, tetapi tujuan utamanya adalah untuk mengabstraksi logika bisnis aplikasi dari beberapa perincian perhitungan yang dilakukan: <br><br><ul><li>  bahwa nilainya mungkin tidak ada: <code>data class Option&lt;A&gt;(value: A?)</code> </li><li>  bahwa perhitungan akan gagal: <code>data class Either&lt;Error, A&gt;(value: Pair&lt;Error?, A?&gt;)</code> </li><li>  bahwa perhitungannya bisa malas: <code>data class Defer&lt;A&gt;(value: () -&gt; A)</code> </li><li>  atau asinkron: <code>java.util.concurrent.CompletableFuture&lt;A&gt;</code> </li><li>  atau memiliki status fungsional: <code>data class State&lt;S, A&gt;(value: (S) -&gt; Pair&lt;S, A&gt;)</code> Status <code>data class State&lt;S, A&gt;(value: (S) -&gt; Pair&lt;S, A&gt;)</code> </li></ul><br>  Daftar pertanyaan yang belum terjawab: <br><br><ul><li>  functors aplikatif - tautan perantara antara functors dan monads </li><li>  koleksi seperti monad </li><li>  komposisi monotipe monad - panah gluesi, transformator monadik </li><li>  urutan / lintasan </li><li>  Monad sebagai efek </li><li>  monad dan rekursi, stack overflow, trampolining </li><li>  Penyandian akhir tanpa tag </li><li>  Io monad </li><li>  dan umumnya seluruh kebun binatang monad standar </li></ul><br><h3>  Apa selanjutnya </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arrow-kt.io</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">typelevel.org/cats/typeclasses.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wiki.haskell.org/All_About_Monads</a> <br><br>  Eksperimen saya adalah aplikasi gaya FP lengkap di Scala: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/scf37/fpscala2</a> <br><br>  PS Saya ingin catatan kecil, ternyata seperti biasa. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454534/">https://habr.com/ru/post/id454534/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454520/index.html">Pedoman untuk menulis kode JavaScript bersih</a></li>
<li><a href="../id454522/index.html">Node.js: mengelola memori yang tersedia untuk aplikasi yang berjalan dalam wadah</a></li>
<li><a href="../id454524/index.html">Perbaikan Ikat Kepala Samsung Level On Pro</a></li>
<li><a href="../id454530/index.html">DJI menciptakan octocopter yang dapat membuat film</a></li>
<li><a href="../id454532/index.html">Saya akan mengatakan sepatah kata pun tentang pendekatan rekayasa</a></li>
<li><a href="../id454536/index.html">Amplifier ke sensor detak jantung klasik</a></li>
<li><a href="../id454538/index.html">Frontend Weekly Digest (27 Mei - 2 Juni 2019)</a></li>
<li><a href="../id454540/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 367 (27 Mei - 2 Juni 2019)</a></li>
<li><a href="../id454542/index.html">Jaringan TV kabel untuk yang terkecil. Bagian 7: Penerima Optik</a></li>
<li><a href="../id454546/index.html">Berapa banyak programmer yang Anda butuhkan untuk minum kopi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>