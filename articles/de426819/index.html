<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêé üíÜüèº üë©üèº‚Äçüåæ Reaktive Anwendung ohne Redux / NgRx ‚ÜñÔ∏è üë©üèª‚Äçüåæ ü§¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir eine reaktive Winkelanwendung ( Github-Repository ) im Detail analysieren, die vollst√§ndig auf der OnPush- Strategie basiert . Eine a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reaktive Anwendung ohne Redux / NgRx</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/426819/"><img src="https://habrastorage.org/webt/d4/ck/od/d4ckodq4-ei9nntgvweinv65mdu.jpeg"><br><br>  Heute werden wir eine reaktive Winkelanwendung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Repository</a> ) im Detail analysieren, die vollst√§ndig auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OnPush-</a> Strategie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basiert</a> .  Eine andere Anwendung verwendet reaktive Formulare, was f√ºr eine Unternehmensanwendung recht typisch ist. <br><br>  Wir werden Flux, Redux, NgRx nicht verwenden und stattdessen die Funktionen nutzen, die bereits in Typescript, Angular und RxJS verf√ºgbar sind.  Tatsache ist, dass diese Tools keine Wunderwaffe sind und selbst einfachen Anwendungen unn√∂tige Komplexit√§t verleihen k√∂nnen.  Wir werden ehrlich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem der Autoren von Flux</a> , dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autor von Redux</a> und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autor von NgRx gewarnt</a> . <br><br>  Diese Tools bieten unseren Anwendungen jedoch sehr sch√∂ne Funktionen: <br><br><ul><li>  Vorhersagbarer Datenfluss; </li><li>  Unterst√ºtzung von OnPush durch Design; </li><li>  Die Unver√§nderlichkeit der Daten, das Fehlen akkumulierter Nebenwirkungen und andere angenehme Dinge. </li></ul><br>  Wir werden versuchen, die gleichen Eigenschaften zu erzielen, ohne jedoch zus√§tzliche Komplexit√§t einzuf√ºhren. <br><br>  Wie Sie am Ende des Artikels sehen werden, ist dies eine ziemlich einfache Aufgabe. Wenn Sie die Details von Angular und OnPush aus dem Artikel entfernen, gibt es nur wenige einfache Ideen. <br><a name="habracut"></a><br>  Der Artikel bietet kein neues universelles Muster, sondern teilt dem Leser nur einige Ideen mit, die bei aller Einfachheit aus irgendeinem Grund nicht sofort in den Sinn kamen.  Die entwickelte L√∂sung widerspricht oder ersetzt auch nicht Flux / Redux / NgRx.  Sie k√∂nnen angeschlossen werden, wenn dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wirklich notwendig ist</a> . <br><br>  <i>F√ºr ein bequemes Lesen des Artikels ist ein Verst√§ndnis der Begriffe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smart, Presentation und Container Components</a> erforderlich.</i> <br><br><h2>  Aktionsplan </h2><br>  Die Logik der Anwendung sowie die Reihenfolge der Pr√§sentation des Materials k√∂nnen in Form der folgenden Schritte beschrieben werden: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Separate Daten zum Lesen (GET) und Schreiben (PUT / POST)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ladezustand als Stream in Containerkomponente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verteilen Sie den Status an eine Hierarchie von OnPush-Komponenten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benachrichtigen Sie Angular √ºber Komponenten√§nderungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingekapselte Datenbearbeitung</a> </li></ol><br>  Um OnPush zu implementieren, m√ºssen alle M√∂glichkeiten zum Ausf√ºhren der √Ñnderungserkennung in Angular analysiert werden.  Es gibt nur vier solcher Methoden, und wir werden sie im gesamten Artikel nacheinander betrachten. <br><br>  Also lass uns gehen. <br><br><a name="backend"></a><h2>  Teilen Sie Daten zum Lesen und Schreiben </h2><br>  In der Regel verwenden Frontend- und Backend-Anwendungen typisierte Vertr√§ge (ansonsten warum √ºberhaupt Typoskript?). <br><br>  Das Demo-Projekt, das wir in Betracht ziehen, hat kein echtes Backend, enth√§lt jedoch eine vorbereitete Beschreibungsdatei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swagger.json</a> .  Darauf basierend werden vom Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sw2dts</a> Typoskriptvertr√§ge generiert. <br><br>  Generierte Vertr√§ge haben zwei wichtige Eigenschaften. <br><br>  Zum einen werden Lesen und Schreiben mit unterschiedlichen Vertr√§gen durchgef√ºhrt.  Wir verwenden eine kleine Konvention und beziehen uns auf Lesevertr√§ge mit dem Suffix ‚ÄûState‚Äú und schreiben Vertr√§ge mit dem Suffix ‚ÄûModel‚Äú. <br><br>  Indem wir die Vertr√§ge auf diese Weise trennen, teilen wir den Datenfluss in der Anwendung.  Von oben nach unten wird ein schreibgesch√ºtzter Zustand durch die Komponentenhierarchie weitergegeben.  Um die Daten zu √§ndern, wird ein Modell erstellt, das anf√§nglich mit Daten aus dem Status gef√ºllt ist, aber als separates Objekt vorhanden ist.  Am Ende der Bearbeitung wird das Modell als Befehl an das Backend gesendet. <br><br>  Der zweite wichtige Punkt ist, dass alle Statusfelder mit einem schreibgesch√ºtzten Modifikator markiert sind.  So erhalten wir Immunit√§tsunterst√ºtzung auf Typoskript-Ebene.  Jetzt k√∂nnen wir den Status im Code nicht versehentlich √§ndern oder mit [(ngModel)] daran binden. Beim Kompilieren der Anwendung im AOT-Modus wird eine Fehlermeldung angezeigt. <br><br><a name="container"></a><h2>  Ladezustand als Stream in Containerkomponente </h2><br>  Zum Laden und Initialisieren des Status verwenden wir normale Winkeldienste.  Sie sind f√ºr die folgenden Szenarien verantwortlich: <br><br><ul><li>  Ein klassisches Beispiel ist das Laden √ºber HttpClient unter Verwendung des ID-Parameters, den die Komponente vom Router erh√§lt. </li><li>  Initialisieren eines leeren Status beim Erstellen einer neuen Entit√§t.  Wenn die Felder beispielsweise Standardwerte haben oder initialisiert werden sollen, m√ºssen Sie zus√§tzliche Daten vom Backend anfordern. </li><li>  Neustart eines bereits geladenen Status, nachdem der Benutzer einen Vorgang ausgef√ºhrt hat, bei dem Daten in das Backend ge√§ndert werden. </li><li>  Neustart des Status durch Push-Benachrichtigung, z. B. beim gemeinsamen Bearbeiten von Daten.  In diesem Fall f√ºhrt der Dienst den lokalen Status und den vom Backend erhaltenen Status zusammen. </li></ul><br>  In der Demo-Anwendung werden die ersten beiden Szenarien als die typischsten betrachtet.  Au√üerdem sind diese Szenarien einfach und erm√∂glichen die Implementierung des Dienstes als einfache zustandslose Objekte und lassen sich nicht von der Komplexit√§t ablenken, die in diesem Artikel nicht behandelt wird. <br><br>  Ein Beispiel f√ºr einen Dienst finden Sie in der Datei <a href="">some-entity.service.ts</a> . <br><br>  Es bleibt, um den Dienst √ºber DI in der Containerkomponente und im Ladezustand zu erhalten.  Dies geschieht normalerweise folgenderma√üen: <br><br><pre><code class="plaintext hljs">route.params .pipe( pluck('id'), filter((id: any) =&gt; { return !!id; }), switchMap((id: string) =&gt; { return myFormService.get(id); }) ) .subscribe(state =&gt; { this.state = state; });</code> </pre> <br>  Bei diesem Ansatz treten jedoch zwei Probleme auf: <br><br><ul><li>  Sie m√ºssen das erstellte Abonnement manuell abbestellen, da sonst ein Speicherverlust auftritt. </li><li>  Wenn Sie die Komponente auf die OnPush-Strategie umstellen, reagiert sie nicht mehr auf das Laden von Daten. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async Rohr</a> kommt zur Rettung.  Er h√∂rt direkt auf das Observable und meldet sich bei Bedarf von ihm ab.  Wenn Sie eine asynchrone Pipe verwenden, l√∂st Angular jedes Mal automatisch eine √Ñnderungserkennung aus, wenn Observable einen neuen Wert ver√∂ffentlicht. <br><br>  Ein Beispiel f√ºr die Verwendung einer asynchronen Pipe finden Sie in der Vorlage f√ºr die <a href="">Komponente some-entity.component</a> . <br><br>  Im Komponentencode haben wir die wiederholte Logik in benutzerdefinierte RxJS-Operatoren entfernt, das Skript zum Erstellen eines leeren Status hinzugef√ºgt, beide Statusquellen mit dem Zusammenf√ºhrungsoperator zu einem Stream zusammengef√ºhrt und ein Formular zum Bearbeiten erstellt, das wir sp√§ter erl√§utern werden: <br><br><pre> <code class="plaintext hljs">this.state$ = merge( route.params.pipe( switchIfNotEmpty("id", (requestId: string) =&gt; requestService.get(requestId) ) ), route.params.pipe( switchIfEmpty("id", () =&gt; requestService.getEmptyState()) ) ).pipe( tap(state =&gt; { this.form = new SomeEntityFormGroup(state); }) );</code> </pre><br>  Dies ist alles, was in der Containerkomponente durchgef√ºhrt werden musste.  Und wir haben im Sparschwein die erste M√∂glichkeit eingerichtet, die √Ñnderungserkennung in der OnPush-Komponente aufzurufen - die asynchrone Pipe.  Es wird uns mehr als einmal n√ºtzlich sein. <br><br><a name="presentation"></a><h2>  Verteilen Sie den Status an eine Hierarchie von OnPush-Komponenten </h2><br>  Wenn Sie einen komplexen Zustand anzeigen m√ºssen, erstellen wir eine Hierarchie kleiner Komponenten - so gehen wir mit Komplexit√§t um. <br><br>  In der Regel werden Komponenten in eine der Datenhierarchie √§hnliche Hierarchie unterteilt, und jede Komponente erh√§lt √ºber die Eingabeparameter ihre eigenen Daten, um sie in der Vorlage anzuzeigen. <br><br>  Da wir alle Komponenten als OnPush implementieren werden, lassen Sie uns einen Moment abschweifen und diskutieren, was es ist und wie Angular mit OnPush-Komponenten funktioniert.  Wenn Sie dieses Material bereits kennen, k√∂nnen Sie zum Ende des Abschnitts scrollen. <br><br>  W√§hrend der Kompilierung der Anwendung generiert Angular f√ºr jede Komponente einen speziellen Klassen√§nderungsdetektor, der sich alle in der Komponentenvorlage verwendeten Bindungen ‚Äûmerkt‚Äú.  Zur Laufzeit beginnt die generierte Klasse, gespeicherte Ausdr√ºcke mit jeder √Ñnderungserkennungsschleife zu √ºberpr√ºfen.  Wenn die √úberpr√ºfung ergab, dass sich das Ergebnis eines Ausdrucks ge√§ndert hat, zeichnet Angular die Komponente neu. <br><br>  Standardm√§√üig wei√ü Angular nichts √ºber unsere Komponenten und kann nicht bestimmen, welche Komponenten davon betroffen sind, z. B. das gerade ausgel√∂ste setTimeout oder eine AJAX-Anforderung, die beendet wurde.  Daher ist er gezwungen, die gesamte Anwendung buchst√§blich auf jedes Ereignis in der Anwendung zu √ºberpr√ºfen - selbst ein einfacher Fensterlauf l√∂st wiederholt die √Ñnderungserkennung f√ºr die gesamte Hierarchie der Anwendungskomponenten aus. <br><br>  Hier liegt eine potenzielle Ursache f√ºr Leistungsprobleme - je komplexer die Komponentenvorlagen sind, desto schwieriger sind die √úberpr√ºfungen des √Ñnderungsdetektors.  Und wenn viele Komponenten vorhanden sind und h√§ufig √úberpr√ºfungen durchgef√ºhrt werden, dauert die √Ñnderungserkennung einige Zeit. <br><br>  Was tun? <br><br>  Wenn die Komponente nicht von globalen Effekten abh√§ngt (es ist √ºbrigens besser, Komponenten auf diese Weise zu entwerfen), wird ihr interner Zustand bestimmt durch: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingabeparameter</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Input</a> ); </li><li>  Ereignisse, die in der Komponente selbst aufgetreten sind ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Output</a> ). </li></ul><br>  Wir werden den zweiten Punkt vorerst verschieben und annehmen, dass der Status unserer Komponente nur von den Eingabeparametern abh√§ngt. <br><br>  Wenn alle Eingabeparameter der Komponente unver√§nderliche Objekte sind, k√∂nnen wir die Komponente als OnPush markieren.  Vor dem Ausf√ºhren der √Ñnderungserkennung pr√ºft Angular, ob sich die Verkn√ºpfungen zu den Eingabeparametern der Komponente seit der vorherigen √úberpr√ºfung ge√§ndert haben.  Wenn sie sich nicht ge√§ndert haben, √ºberspringt Angular die √Ñnderungserkennung f√ºr die Komponente selbst und alle untergeordneten Komponenten. <br><br>  Wenn wir also unsere gesamte Anwendung gem√§√ü der OnPush-Strategie erstellen, werden wir von Anfang an eine ganze Klasse von Leistungsproblemen beseitigen. <br><br>  Da der Status in unserer Anwendung bereits unver√§nderlich ist, werden unver√§nderliche Objekte auch in die Eingabeparameter von untergeordneten Komponenten √ºbertragen.  Das hei√üt, wir sind bereit, OnPush f√ºr untergeordnete Komponenten zu aktivieren, und diese reagieren auf Status√§nderungen. <br>  Dies sind <a href="">beispielsweise die Komponenten</a> <a href="">readonly-info.component</a> und <a href="">nested-items.component</a> <br><br>  Lassen Sie uns nun sehen, wie Sie die √Ñnderung des Status von Komponenten im OnPush-Paradigma implementieren. <br><br><a name="output"></a><h2>  Sprechen Sie mit Angular √ºber Ihren Zustand </h2><br>  Pr√§sentationsstatus - Dies sind die Parameter, die f√ºr das Erscheinungsbild der Komponente verantwortlich sind: Ladeanzeigen, Sichtbarkeitsflags von Elementen oder Zug√§nglichkeit f√ºr den Benutzer der einen oder anderen Aktion, die aus drei Feldern auf eine Zeile geklebt werden, vollst√§ndiger Name des Benutzers usw. <br><br>  Jedes Mal, wenn sich der Pr√§sentationsstatus einer Komponente √§ndert, m√ºssen wir Angular benachrichtigen, damit die √Ñnderungen auf der Benutzeroberfl√§che angezeigt werden k√∂nnen. <br><br>  Abh√§ngig von der Quelle des Status der Komponente gibt es verschiedene M√∂glichkeiten, Angular zu benachrichtigen. <br><br><h4>  Pr√§sentationsstatus, berechnet basierend auf Eingabeparametern </h4><br>  Dies ist die einfachste Option.  Wir setzen die Berechnungslogik f√ºr den Pr√§sentationsstatus in den ngOnChanges-Hook.  Die √Ñnderungserkennung startet von selbst durch √Ñndern der @ Input-Parameter.  In der Demo ist dies <a href="">readonly-info.component</a> . <br><br><pre> <code class="plaintext hljs">export class ReadOnlyInfoComponent implements OnChanges { @Input() public state: Backend.SomeEntityState; public traits: ReadonlyInfoTraits; public ngOnChanges(changes: { state: SimpleChange }): void { this.traits = new ReadonlyInfoTraits(changes.state.currentValue); } }</code> </pre><br>  Alles ist sehr einfach, aber es gibt einen Punkt, der beachtet werden sollte. <br><br>  Wenn der Pr√§sentationsstatus der Komponente komplex ist und insbesondere wenn einige ihrer Felder auf der Grundlage anderer berechnet werden, die auch durch die Eingabeparameter berechnet werden, legen Sie den Status der Komponente in eine separate Klasse, machen Sie sie unver√§nderlich und erstellen Sie ngOnChanges bei jedem Start neu.  Ein Beispiel in einem Demo-Projekt ist die <a href="">ReadonlyInfoComponentTraits-</a> Klasse.  Mit diesem Ansatz sch√ºtzen Sie sich vor der Notwendigkeit, abh√§ngige Daten zu synchronisieren, wenn sie sich √§ndern. <br><br>  Gleichzeitig ist es erw√§genswert: Vielleicht hat die Komponente einen schwierigen Zustand, weil sie zu viel Logik enth√§lt.  Ein typisches Beispiel ist der Versuch in einer Komponente, Darstellungen f√ºr verschiedene Benutzer anzupassen, die sehr unterschiedliche Arbeitsweisen mit dem System haben. <br><br><h4>  Native Komponentenereignisse </h4><br>  F√ºr die Kommunikation zwischen Anwendungskomponenten verwenden wir Ausgabeereignisse.  Dies ist auch die dritte M√∂glichkeit, die √Ñnderungserkennung auszuf√ºhren.  Angular geht vern√ºnftigerweise davon aus, dass sich etwas in seinem Zustand ge√§ndert haben k√∂nnte, wenn eine Komponente ein Ereignis generiert.  Daher wartet Angular auf alle Komponentenausgabeereignisse und l√∂st die √Ñnderungserkennung aus, wenn sie auftreten. <br><br>  Im Demo-Projekt ist es vollst√§ndig synthetisch, aber ein Beispiel ist die Komponente <a href="">submit-button.component</a> , die ein <i>formSaved-</i> Ereignis <i>ausl√∂st</i> .  Die Containerkomponente abonniert dieses Ereignis und zeigt eine Warnung mit einer Benachrichtigung an. <br><br>  Verwenden Sie Ausgabeereignisse f√ºr den beabsichtigten Zweck, dh erstellen Sie sie f√ºr die Kommunikation mit √ºbergeordneten Komponenten und nicht, um die √Ñnderungserkennung auszul√∂sen.  Andernfalls ist es wahrscheinlich, dass Sie sich nach Monaten und Jahren nicht daran erinnern, warum dieses Ereignis f√ºr niemanden hier unn√∂tig ist, und es l√∂schen und alles kaputt machen. <br><br><h4>  √Ñnderungen an intelligenten Komponenten </h4><br>  Manchmal wird der Status einer Komponente durch eine komplexe Logik bestimmt: Asynchrones Aufrufen des Dienstes, Herstellen einer Verbindung zu einem Web-Socket, √úberpr√ºfen der Ausf√ºhrung von setInterval, aber Sie wissen nie, was noch.  Solche Komponenten werden als intelligente Komponenten bezeichnet. <br><br>  Je weniger intelligente Komponenten in der Anwendung keine Containerkomponenten sind, desto einfacher ist es im Allgemeinen, zu leben.  Aber manchmal kann man nicht ohne sie auskommen. <br><br>  Die einfachste M√∂glichkeit, den Status einer intelligenten Komponente mit der √Ñnderungserkennung zu verkn√ºpfen, besteht darin, sie in eine Observable umzuwandeln und die oben bereits beschriebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asynchrone Pipe zu verwenden</a> .  Wenn die Quelle der √Ñnderungen beispielsweise ein Serviceabruf oder ein reaktiver Formularstatus ist, handelt es sich um eine vorgefertigte Observable.  Wenn der Status aus etwas Komplexerem gebildet wird, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fromPromise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Websocket</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timer</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intervall</a> aus der Zusammensetzung von RxJS verwenden.  Oder generieren Sie selbst einen Stream mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subject</a> . <br><br><h4>  Wenn keine der Optionen geeignet ist </h4><br>  In F√§llen, in denen keine der drei bereits untersuchten Methoden geeignet ist, haben wir immer noch eine kugelsichere Option - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChangeDetectorRef</a> direkt verwenden.  Wir sprechen √ºber die DetectChanges- und MarkForCheck-Methoden dieser Klasse. <br><br>  Eine umfassende Dokumentation beantwortet alle Fragen, sodass wir uns nicht mit ihrer Arbeit befassen werden.  Beachten Sie jedoch, dass die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChangeDetectorRef</a> auf F√§lle beschr√§nkt sein sollte, in denen Sie klar verstehen, was Sie tun, da dies immer noch die interne Angular-K√ºche ist. <br><br>  F√ºr die ganze Zeit haben wir nur wenige F√§lle gefunden, in denen diese Methode erforderlich sein k√∂nnte: <br><br><ol><li>  Manuelle Arbeit mit √Ñnderungserkennung - wird bei der Implementierung von Komponenten auf niedriger Ebene verwendet und ist nur der Fall, ‚ÄûSie verstehen klar, was Sie tun‚Äú. </li><li>  Komplexe Beziehungen zwischen Komponenten - zum Beispiel, wenn Sie eine Verkn√ºpfung zu einer Komponente in einer Vorlage erstellen und diese als Parameter an eine andere Komponente √ºbergeben m√ºssen, die sich h√∂her in der Hierarchie oder sogar in einem anderen Zweig der Komponentenhierarchie befindet.  Klingt kompliziert?  So ist es.  Und es ist besser, solchen Code einfach umzugestalten, da dies nicht nur bei der Erkennung von √Ñnderungen zu Schmerzen f√ºhrt. </li><li>  Die Besonderheiten des Verhaltens von Angular selbst - Wenn Sie beispielsweise einen benutzerdefinierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ControlValueAccessor</a> implementieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> kann es vorkommen, dass der Steuerwert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Angular asynchron</a> ge√§ndert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird</a> und die √Ñnderungen nicht auf den gew√ºnschten √Ñnderungserkennungszyklus angewendet werden. </li></ol><br>  Als Beispiele f√ºr die Verwendung in der <a href="">Demoanwendung</a> gibt es die Basisklasse <a href="">OnPushControlValueAccessor</a> , die das im letzten Absatz beschriebene Problem l√∂st.  Ebenfalls im Projekt gibt es einen Erben dieser Klasse - eine benutzerdefinierte <a href="">Optionsfeldkomponente</a> . <br><br>  Jetzt haben wir alle vier M√∂glichkeiten zum Ausf√ºhren von √Ñnderungserkennungs- und OnPush-Implementierungsoptionen f√ºr alle drei Komponententypen erl√§utert: Container, Smart, Pr√§sentationsoptionen.  Wir kommen zum letzten Punkt - der Bearbeitung von Daten mit reaktiven Formularen. <br><br><a name="form"></a><h2>  Eingekapselte Datenbearbeitung </h2><br>  Reaktive Formen haben eine Reihe von Einschr√§nkungen, aber dies ist immer noch eines der besten Dinge, die im Angular-√ñkosystem passiert sind. <br><br>  Zuallererst verk√∂rpern sie die gute Zusammenarbeit mit dem Staat und bieten alle notwendigen Werkzeuge, um reaktiv auf Ver√§nderungen zu reagieren. <br><br>  Tats√§chlich ist das reaktive Formular eine Art Mini-Store, der die Arbeit mit dem Status zusammenfasst: Daten und Status deaktiviert / g√ºltig / ausstehend. <br><br>  Es bleibt uns √ºberlassen, diese Kapselung so weit wie m√∂glich zu unterst√ºtzen und zu vermeiden, dass Pr√§sentationslogik und Logik der Form vermischt werden. <br><br>  In der Demo-Anwendung sehen Sie <a href="">einzelne Formularklassen</a> , die die Besonderheiten ihrer Arbeit zusammenfassen: Validierung, Erstellen untergeordneter Formgruppen, Arbeiten mit dem deaktivierten Status von Eingabefeldern. <br><br>  Wir erstellen das Stammformular in der Containerkomponente zum Zeitpunkt des Ladens des Status und bei jedem Neustart des Status wird das Formular neu erstellt.  Dies ist keine Voraussetzung, aber auf diese Weise k√∂nnen wir sicher sein, dass in der Formularlogik keine akkumulierten Effekte aus dem vorherigen geladenen Zustand √ºbrig bleiben. <br><br>  Innerhalb des Formulars selbst erstellen wir die Steuerelemente und ‚Äûschieben‚Äú die Daten, die von ihnen stammen, und konvertieren sie vom Staatsvertrag in den Modellvertrag.  Die Struktur der Formulare entspricht so weit wie m√∂glich den Vertr√§gen der Modelle.  Infolgedessen bietet uns die value-Eigenschaft des Formulars ein vorgefertigtes Modell zum Senden an das Backend. <br><br>  Wenn sich in Zukunft der Status oder die Modellstruktur √§ndert, wird genau an der Stelle, an der Felder hinzugef√ºgt / entfernt werden m√ºssen, ein Typoskript-Kompilierungsfehler angezeigt, was sehr praktisch ist. <br><br>  Wenn die Status- und Modellobjekte eine absolut identische Struktur haben, entf√§llt durch die in Typoskript verwendete strukturelle Typisierung die Notwendigkeit, eine bedeutungslose Zuordnung voneinander zu erstellen. <br><br>  Insgesamt ist die Formlogik in Komponenten von der Pr√§sentationslogik isoliert und lebt ‚Äûvon selbst‚Äú, ohne die Komplexit√§t des Datenflusses unserer gesamten Anwendung zu erh√∂hen. <br><br>  Das ist fast alles.  Es gibt noch Grenzf√§lle, in denen wir die Formularlogik nicht vom Rest der Anwendung isolieren k√∂nnen: <br><br><ol><li>  Form√§nderungen, die zu einer √Ñnderung des Pr√§sentationsstatus f√ºhren, z. B. die Sichtbarkeit eines Datenblocks in Abh√§ngigkeit vom eingegebenen Wert.  Wir implementieren es in der Komponente, indem wir Formularereignisse abonnieren.  Sie k√∂nnen dies durch die unver√§nderlichen Eigenschaften tun, die zuvor besprochen wurden. </li><li>  Wenn Sie einen asynchronen Validator ben√∂tigen, der das Backend aufruft, erstellen wir AsyncValidatorFn in der Komponente und √ºbergeben es an den Formularkonstruktor, nicht an den Service. </li></ol><br>  Somit bleibt die gesamte ‚ÄûGrenzlogik‚Äú an der prominentesten Stelle - in den Komponenten. <br><br><h2>  Schlussfolgerungen </h2><br>  Lassen Sie uns zusammenfassen, was wir haben und welche anderen Punkte es f√ºr das Studium und die Entwicklung gibt. <br><br>  Zuallererst zwingt uns die Entwicklung der OnPush-Strategie dazu, Datenflussanwendungen sorgf√§ltig zu entwerfen, da wir jetzt Angular und nicht ihm die Spielregeln diktieren. <br><br>  Diese Situation hat zwei Konsequenzen. <br><br>  Erstens bekommen wir ein angenehmes Gef√ºhl der Kontrolle √ºber die Anwendung.  Es gibt keine Magie mehr, die ‚Äûirgendwie funktioniert‚Äú.  Sie wissen genau, was zu einem bestimmten Zeitpunkt in Ihrer Bewerbung passiert.  Die Intuition entwickelt sich allm√§hlich weiter, sodass Sie den Grund f√ºr den gefundenen Fehler verstehen k√∂nnen, noch bevor Sie den Code √∂ffnen. <br><br>  Zweitens m√ºssen wir jetzt mehr Zeit mit dem Entwerfen der Anwendung verbringen, aber das Ergebnis wird immer die ‚Äûdirekteste‚Äú und daher einfachste L√∂sung sein.  Dies verringert die Wahrscheinlichkeit einer Situation, in der die Anwendung mit zunehmender Gr√∂√üe zu einem Monster von enormer Komplexit√§t wird, die Entwickler die Kontrolle √ºber diese Komplexit√§t verloren haben und die Entwicklung nun eher wie mystische Riten aussieht, erheblich auf Null. <br><br>  Kontrollierte Komplexit√§t und das Fehlen von ‚ÄûMagie‚Äú verringern die Wahrscheinlichkeit einer ganzen Klasse von Problemen, die beispielsweise durch zyklische Datenaktualisierungen oder akkumulierte Nebenwirkungen entstehen.  Stattdessen haben wir es mit Problemen zu tun, die bereits w√§hrend der Entwicklung auftreten, wenn die Anwendung einfach nicht funktioniert.  Und zwangsl√§ufig m√ºssen Sie daf√ºr sorgen, dass die Anwendung einfach und klar funktioniert. <br><br>  Wir haben auch gute Auswirkungen auf die Leistung erw√§hnt.  Mit sehr einfachen Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">profiler.timeChangeDetection</a> k√∂nnen wir jetzt jederzeit √ºberpr√ºfen, ob unsere Anwendung noch in gutem Zustand ist. <br><br>  Auch jetzt ist es eine S√ºnde, nicht zu versuchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, NgZone</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deaktivieren</a> .  Erstens k√∂nnen Sie beim Start der Anwendung nicht die gesamte Bibliothek laden.  Zweitens wird eine ganze Menge Magie aus Ihrer Anwendung entfernt. <br><br>  Hier beenden wir unsere Geschichte. <br><br>  Wir bleiben in Kontakt! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426819/">https://habr.com/ru/post/de426819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426809/index.html">Zeev Surasky: Die Zukunft der Zend Engine und des Zend Frameworks</a></li>
<li><a href="../de426811/index.html">Parkour-, Tanz- und Bauarbeiten von Boston Dynamics</a></li>
<li><a href="../de426813/index.html">? Skype ist zu einem langweiligen Anschein geworden ... und zu einem Produkt, mit dem Sie vollen Zugriff auf Ihr System erhalten? Gibt es Hoffnung?</a></li>
<li><a href="../de426815/index.html">Wie bekomme ich ein Projektentwicklungsstipendium, wenn Sie ein armer Student sind? Und ist es das wert?</a></li>
<li><a href="../de426817/index.html">CommuniGate Pro Private Keys und Web-API</a></li>
<li><a href="../de426821/index.html">So organisieren Sie CI / CD in einem Projekt: vom Festlegen von Aufgaben bis zum Einrichten der Bereitstellungspipeline</a></li>
<li><a href="../de426825/index.html">Ein paar Tipps f√ºr Freiberufler</a></li>
<li><a href="../de426831/index.html">Unangenehmes Gespr√§ch, Herpetologe und v√∂llige √úberraschung</a></li>
<li><a href="../de426835/index.html">Vergleichende und detaillierte Analyse von Caching-Plugins f√ºr WordPress</a></li>
<li><a href="../de426837/index.html">Video√ºbertragung auf Ihrer Website, die funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>