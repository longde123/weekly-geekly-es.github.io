<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 💆🏼 👩🏼‍🌾 Reaktive Anwendung ohne Redux / NgRx ↖️ 👩🏻‍🌾 🤴🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir eine reaktive Winkelanwendung ( Github-Repository ) im Detail analysieren, die vollständig auf der OnPush- Strategie basiert . Eine a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reaktive Anwendung ohne Redux / NgRx</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/true_engineering/blog/426819/"><img src="https://habrastorage.org/webt/d4/ck/od/d4ckodq4-ei9nntgvweinv65mdu.jpeg"><br><br>  Heute werden wir eine reaktive Winkelanwendung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Repository</a> ) im Detail analysieren, die vollständig auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OnPush-</a> Strategie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basiert</a> .  Eine andere Anwendung verwendet reaktive Formulare, was für eine Unternehmensanwendung recht typisch ist. <br><br>  Wir werden Flux, Redux, NgRx nicht verwenden und stattdessen die Funktionen nutzen, die bereits in Typescript, Angular und RxJS verfügbar sind.  Tatsache ist, dass diese Tools keine Wunderwaffe sind und selbst einfachen Anwendungen unnötige Komplexität verleihen können.  Wir werden ehrlich von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem der Autoren von Flux</a> , dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autor von Redux</a> und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autor von NgRx gewarnt</a> . <br><br>  Diese Tools bieten unseren Anwendungen jedoch sehr schöne Funktionen: <br><br><ul><li>  Vorhersagbarer Datenfluss; </li><li>  Unterstützung von OnPush durch Design; </li><li>  Die Unveränderlichkeit der Daten, das Fehlen akkumulierter Nebenwirkungen und andere angenehme Dinge. </li></ul><br>  Wir werden versuchen, die gleichen Eigenschaften zu erzielen, ohne jedoch zusätzliche Komplexität einzuführen. <br><br>  Wie Sie am Ende des Artikels sehen werden, ist dies eine ziemlich einfache Aufgabe. Wenn Sie die Details von Angular und OnPush aus dem Artikel entfernen, gibt es nur wenige einfache Ideen. <br><a name="habracut"></a><br>  Der Artikel bietet kein neues universelles Muster, sondern teilt dem Leser nur einige Ideen mit, die bei aller Einfachheit aus irgendeinem Grund nicht sofort in den Sinn kamen.  Die entwickelte Lösung widerspricht oder ersetzt auch nicht Flux / Redux / NgRx.  Sie können angeschlossen werden, wenn dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wirklich notwendig ist</a> . <br><br>  <i>Für ein bequemes Lesen des Artikels ist ein Verständnis der Begriffe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Smart, Presentation und Container Components</a> erforderlich.</i> <br><br><h2>  Aktionsplan </h2><br>  Die Logik der Anwendung sowie die Reihenfolge der Präsentation des Materials können in Form der folgenden Schritte beschrieben werden: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Separate Daten zum Lesen (GET) und Schreiben (PUT / POST)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ladezustand als Stream in Containerkomponente</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verteilen Sie den Status an eine Hierarchie von OnPush-Komponenten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benachrichtigen Sie Angular über Komponentenänderungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingekapselte Datenbearbeitung</a> </li></ol><br>  Um OnPush zu implementieren, müssen alle Möglichkeiten zum Ausführen der Änderungserkennung in Angular analysiert werden.  Es gibt nur vier solcher Methoden, und wir werden sie im gesamten Artikel nacheinander betrachten. <br><br>  Also lass uns gehen. <br><br><a name="backend"></a><h2>  Teilen Sie Daten zum Lesen und Schreiben </h2><br>  In der Regel verwenden Frontend- und Backend-Anwendungen typisierte Verträge (ansonsten warum überhaupt Typoskript?). <br><br>  Das Demo-Projekt, das wir in Betracht ziehen, hat kein echtes Backend, enthält jedoch eine vorbereitete Beschreibungsdatei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">swagger.json</a> .  Darauf basierend werden vom Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sw2dts</a> Typoskriptverträge generiert. <br><br>  Generierte Verträge haben zwei wichtige Eigenschaften. <br><br>  Zum einen werden Lesen und Schreiben mit unterschiedlichen Verträgen durchgeführt.  Wir verwenden eine kleine Konvention und beziehen uns auf Leseverträge mit dem Suffix „State“ und schreiben Verträge mit dem Suffix „Model“. <br><br>  Indem wir die Verträge auf diese Weise trennen, teilen wir den Datenfluss in der Anwendung.  Von oben nach unten wird ein schreibgeschützter Zustand durch die Komponentenhierarchie weitergegeben.  Um die Daten zu ändern, wird ein Modell erstellt, das anfänglich mit Daten aus dem Status gefüllt ist, aber als separates Objekt vorhanden ist.  Am Ende der Bearbeitung wird das Modell als Befehl an das Backend gesendet. <br><br>  Der zweite wichtige Punkt ist, dass alle Statusfelder mit einem schreibgeschützten Modifikator markiert sind.  So erhalten wir Immunitätsunterstützung auf Typoskript-Ebene.  Jetzt können wir den Status im Code nicht versehentlich ändern oder mit [(ngModel)] daran binden. Beim Kompilieren der Anwendung im AOT-Modus wird eine Fehlermeldung angezeigt. <br><br><a name="container"></a><h2>  Ladezustand als Stream in Containerkomponente </h2><br>  Zum Laden und Initialisieren des Status verwenden wir normale Winkeldienste.  Sie sind für die folgenden Szenarien verantwortlich: <br><br><ul><li>  Ein klassisches Beispiel ist das Laden über HttpClient unter Verwendung des ID-Parameters, den die Komponente vom Router erhält. </li><li>  Initialisieren eines leeren Status beim Erstellen einer neuen Entität.  Wenn die Felder beispielsweise Standardwerte haben oder initialisiert werden sollen, müssen Sie zusätzliche Daten vom Backend anfordern. </li><li>  Neustart eines bereits geladenen Status, nachdem der Benutzer einen Vorgang ausgeführt hat, bei dem Daten in das Backend geändert werden. </li><li>  Neustart des Status durch Push-Benachrichtigung, z. B. beim gemeinsamen Bearbeiten von Daten.  In diesem Fall führt der Dienst den lokalen Status und den vom Backend erhaltenen Status zusammen. </li></ul><br>  In der Demo-Anwendung werden die ersten beiden Szenarien als die typischsten betrachtet.  Außerdem sind diese Szenarien einfach und ermöglichen die Implementierung des Dienstes als einfache zustandslose Objekte und lassen sich nicht von der Komplexität ablenken, die in diesem Artikel nicht behandelt wird. <br><br>  Ein Beispiel für einen Dienst finden Sie in der Datei <a href="">some-entity.service.ts</a> . <br><br>  Es bleibt, um den Dienst über DI in der Containerkomponente und im Ladezustand zu erhalten.  Dies geschieht normalerweise folgendermaßen: <br><br><pre><code class="plaintext hljs">route.params .pipe( pluck('id'), filter((id: any) =&gt; { return !!id; }), switchMap((id: string) =&gt; { return myFormService.get(id); }) ) .subscribe(state =&gt; { this.state = state; });</code> </pre> <br>  Bei diesem Ansatz treten jedoch zwei Probleme auf: <br><br><ul><li>  Sie müssen das erstellte Abonnement manuell abbestellen, da sonst ein Speicherverlust auftritt. </li><li>  Wenn Sie die Komponente auf die OnPush-Strategie umstellen, reagiert sie nicht mehr auf das Laden von Daten. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Async Rohr</a> kommt zur Rettung.  Er hört direkt auf das Observable und meldet sich bei Bedarf von ihm ab.  Wenn Sie eine asynchrone Pipe verwenden, löst Angular jedes Mal automatisch eine Änderungserkennung aus, wenn Observable einen neuen Wert veröffentlicht. <br><br>  Ein Beispiel für die Verwendung einer asynchronen Pipe finden Sie in der Vorlage für die <a href="">Komponente some-entity.component</a> . <br><br>  Im Komponentencode haben wir die wiederholte Logik in benutzerdefinierte RxJS-Operatoren entfernt, das Skript zum Erstellen eines leeren Status hinzugefügt, beide Statusquellen mit dem Zusammenführungsoperator zu einem Stream zusammengeführt und ein Formular zum Bearbeiten erstellt, das wir später erläutern werden: <br><br><pre> <code class="plaintext hljs">this.state$ = merge( route.params.pipe( switchIfNotEmpty("id", (requestId: string) =&gt; requestService.get(requestId) ) ), route.params.pipe( switchIfEmpty("id", () =&gt; requestService.getEmptyState()) ) ).pipe( tap(state =&gt; { this.form = new SomeEntityFormGroup(state); }) );</code> </pre><br>  Dies ist alles, was in der Containerkomponente durchgeführt werden musste.  Und wir haben im Sparschwein die erste Möglichkeit eingerichtet, die Änderungserkennung in der OnPush-Komponente aufzurufen - die asynchrone Pipe.  Es wird uns mehr als einmal nützlich sein. <br><br><a name="presentation"></a><h2>  Verteilen Sie den Status an eine Hierarchie von OnPush-Komponenten </h2><br>  Wenn Sie einen komplexen Zustand anzeigen müssen, erstellen wir eine Hierarchie kleiner Komponenten - so gehen wir mit Komplexität um. <br><br>  In der Regel werden Komponenten in eine der Datenhierarchie ähnliche Hierarchie unterteilt, und jede Komponente erhält über die Eingabeparameter ihre eigenen Daten, um sie in der Vorlage anzuzeigen. <br><br>  Da wir alle Komponenten als OnPush implementieren werden, lassen Sie uns einen Moment abschweifen und diskutieren, was es ist und wie Angular mit OnPush-Komponenten funktioniert.  Wenn Sie dieses Material bereits kennen, können Sie zum Ende des Abschnitts scrollen. <br><br>  Während der Kompilierung der Anwendung generiert Angular für jede Komponente einen speziellen Klassenänderungsdetektor, der sich alle in der Komponentenvorlage verwendeten Bindungen „merkt“.  Zur Laufzeit beginnt die generierte Klasse, gespeicherte Ausdrücke mit jeder Änderungserkennungsschleife zu überprüfen.  Wenn die Überprüfung ergab, dass sich das Ergebnis eines Ausdrucks geändert hat, zeichnet Angular die Komponente neu. <br><br>  Standardmäßig weiß Angular nichts über unsere Komponenten und kann nicht bestimmen, welche Komponenten davon betroffen sind, z. B. das gerade ausgelöste setTimeout oder eine AJAX-Anforderung, die beendet wurde.  Daher ist er gezwungen, die gesamte Anwendung buchstäblich auf jedes Ereignis in der Anwendung zu überprüfen - selbst ein einfacher Fensterlauf löst wiederholt die Änderungserkennung für die gesamte Hierarchie der Anwendungskomponenten aus. <br><br>  Hier liegt eine potenzielle Ursache für Leistungsprobleme - je komplexer die Komponentenvorlagen sind, desto schwieriger sind die Überprüfungen des Änderungsdetektors.  Und wenn viele Komponenten vorhanden sind und häufig Überprüfungen durchgeführt werden, dauert die Änderungserkennung einige Zeit. <br><br>  Was tun? <br><br>  Wenn die Komponente nicht von globalen Effekten abhängt (es ist übrigens besser, Komponenten auf diese Weise zu entwerfen), wird ihr interner Zustand bestimmt durch: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eingabeparameter</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Input</a> ); </li><li>  Ereignisse, die in der Komponente selbst aufgetreten sind ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@Output</a> ). </li></ul><br>  Wir werden den zweiten Punkt vorerst verschieben und annehmen, dass der Status unserer Komponente nur von den Eingabeparametern abhängt. <br><br>  Wenn alle Eingabeparameter der Komponente unveränderliche Objekte sind, können wir die Komponente als OnPush markieren.  Vor dem Ausführen der Änderungserkennung prüft Angular, ob sich die Verknüpfungen zu den Eingabeparametern der Komponente seit der vorherigen Überprüfung geändert haben.  Wenn sie sich nicht geändert haben, überspringt Angular die Änderungserkennung für die Komponente selbst und alle untergeordneten Komponenten. <br><br>  Wenn wir also unsere gesamte Anwendung gemäß der OnPush-Strategie erstellen, werden wir von Anfang an eine ganze Klasse von Leistungsproblemen beseitigen. <br><br>  Da der Status in unserer Anwendung bereits unveränderlich ist, werden unveränderliche Objekte auch in die Eingabeparameter von untergeordneten Komponenten übertragen.  Das heißt, wir sind bereit, OnPush für untergeordnete Komponenten zu aktivieren, und diese reagieren auf Statusänderungen. <br>  Dies sind <a href="">beispielsweise die Komponenten</a> <a href="">readonly-info.component</a> und <a href="">nested-items.component</a> <br><br>  Lassen Sie uns nun sehen, wie Sie die Änderung des Status von Komponenten im OnPush-Paradigma implementieren. <br><br><a name="output"></a><h2>  Sprechen Sie mit Angular über Ihren Zustand </h2><br>  Präsentationsstatus - Dies sind die Parameter, die für das Erscheinungsbild der Komponente verantwortlich sind: Ladeanzeigen, Sichtbarkeitsflags von Elementen oder Zugänglichkeit für den Benutzer der einen oder anderen Aktion, die aus drei Feldern auf eine Zeile geklebt werden, vollständiger Name des Benutzers usw. <br><br>  Jedes Mal, wenn sich der Präsentationsstatus einer Komponente ändert, müssen wir Angular benachrichtigen, damit die Änderungen auf der Benutzeroberfläche angezeigt werden können. <br><br>  Abhängig von der Quelle des Status der Komponente gibt es verschiedene Möglichkeiten, Angular zu benachrichtigen. <br><br><h4>  Präsentationsstatus, berechnet basierend auf Eingabeparametern </h4><br>  Dies ist die einfachste Option.  Wir setzen die Berechnungslogik für den Präsentationsstatus in den ngOnChanges-Hook.  Die Änderungserkennung startet von selbst durch Ändern der @ Input-Parameter.  In der Demo ist dies <a href="">readonly-info.component</a> . <br><br><pre> <code class="plaintext hljs">export class ReadOnlyInfoComponent implements OnChanges { @Input() public state: Backend.SomeEntityState; public traits: ReadonlyInfoTraits; public ngOnChanges(changes: { state: SimpleChange }): void { this.traits = new ReadonlyInfoTraits(changes.state.currentValue); } }</code> </pre><br>  Alles ist sehr einfach, aber es gibt einen Punkt, der beachtet werden sollte. <br><br>  Wenn der Präsentationsstatus der Komponente komplex ist und insbesondere wenn einige ihrer Felder auf der Grundlage anderer berechnet werden, die auch durch die Eingabeparameter berechnet werden, legen Sie den Status der Komponente in eine separate Klasse, machen Sie sie unveränderlich und erstellen Sie ngOnChanges bei jedem Start neu.  Ein Beispiel in einem Demo-Projekt ist die <a href="">ReadonlyInfoComponentTraits-</a> Klasse.  Mit diesem Ansatz schützen Sie sich vor der Notwendigkeit, abhängige Daten zu synchronisieren, wenn sie sich ändern. <br><br>  Gleichzeitig ist es erwägenswert: Vielleicht hat die Komponente einen schwierigen Zustand, weil sie zu viel Logik enthält.  Ein typisches Beispiel ist der Versuch in einer Komponente, Darstellungen für verschiedene Benutzer anzupassen, die sehr unterschiedliche Arbeitsweisen mit dem System haben. <br><br><h4>  Native Komponentenereignisse </h4><br>  Für die Kommunikation zwischen Anwendungskomponenten verwenden wir Ausgabeereignisse.  Dies ist auch die dritte Möglichkeit, die Änderungserkennung auszuführen.  Angular geht vernünftigerweise davon aus, dass sich etwas in seinem Zustand geändert haben könnte, wenn eine Komponente ein Ereignis generiert.  Daher wartet Angular auf alle Komponentenausgabeereignisse und löst die Änderungserkennung aus, wenn sie auftreten. <br><br>  Im Demo-Projekt ist es vollständig synthetisch, aber ein Beispiel ist die Komponente <a href="">submit-button.component</a> , die ein <i>formSaved-</i> Ereignis <i>auslöst</i> .  Die Containerkomponente abonniert dieses Ereignis und zeigt eine Warnung mit einer Benachrichtigung an. <br><br>  Verwenden Sie Ausgabeereignisse für den beabsichtigten Zweck, dh erstellen Sie sie für die Kommunikation mit übergeordneten Komponenten und nicht, um die Änderungserkennung auszulösen.  Andernfalls ist es wahrscheinlich, dass Sie sich nach Monaten und Jahren nicht daran erinnern, warum dieses Ereignis für niemanden hier unnötig ist, und es löschen und alles kaputt machen. <br><br><h4>  Änderungen an intelligenten Komponenten </h4><br>  Manchmal wird der Status einer Komponente durch eine komplexe Logik bestimmt: Asynchrones Aufrufen des Dienstes, Herstellen einer Verbindung zu einem Web-Socket, Überprüfen der Ausführung von setInterval, aber Sie wissen nie, was noch.  Solche Komponenten werden als intelligente Komponenten bezeichnet. <br><br>  Je weniger intelligente Komponenten in der Anwendung keine Containerkomponenten sind, desto einfacher ist es im Allgemeinen, zu leben.  Aber manchmal kann man nicht ohne sie auskommen. <br><br>  Die einfachste Möglichkeit, den Status einer intelligenten Komponente mit der Änderungserkennung zu verknüpfen, besteht darin, sie in eine Observable umzuwandeln und die oben bereits beschriebene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">asynchrone Pipe zu verwenden</a> .  Wenn die Quelle der Änderungen beispielsweise ein Serviceabruf oder ein reaktiver Formularstatus ist, handelt es sich um eine vorgefertigte Observable.  Wenn der Status aus etwas Komplexerem gebildet wird, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fromPromise</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Websocket</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Timer</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intervall</a> aus der Zusammensetzung von RxJS verwenden.  Oder generieren Sie selbst einen Stream mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Subject</a> . <br><br><h4>  Wenn keine der Optionen geeignet ist </h4><br>  In Fällen, in denen keine der drei bereits untersuchten Methoden geeignet ist, haben wir immer noch eine kugelsichere Option - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChangeDetectorRef</a> direkt verwenden.  Wir sprechen über die DetectChanges- und MarkForCheck-Methoden dieser Klasse. <br><br>  Eine umfassende Dokumentation beantwortet alle Fragen, sodass wir uns nicht mit ihrer Arbeit befassen werden.  Beachten Sie jedoch, dass die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ChangeDetectorRef</a> auf Fälle beschränkt sein sollte, in denen Sie klar verstehen, was Sie tun, da dies immer noch die interne Angular-Küche ist. <br><br>  Für die ganze Zeit haben wir nur wenige Fälle gefunden, in denen diese Methode erforderlich sein könnte: <br><br><ol><li>  Manuelle Arbeit mit Änderungserkennung - wird bei der Implementierung von Komponenten auf niedriger Ebene verwendet und ist nur der Fall, „Sie verstehen klar, was Sie tun“. </li><li>  Komplexe Beziehungen zwischen Komponenten - zum Beispiel, wenn Sie eine Verknüpfung zu einer Komponente in einer Vorlage erstellen und diese als Parameter an eine andere Komponente übergeben müssen, die sich höher in der Hierarchie oder sogar in einem anderen Zweig der Komponentenhierarchie befindet.  Klingt kompliziert?  So ist es.  Und es ist besser, solchen Code einfach umzugestalten, da dies nicht nur bei der Erkennung von Änderungen zu Schmerzen führt. </li><li>  Die Besonderheiten des Verhaltens von Angular selbst - Wenn Sie beispielsweise einen benutzerdefinierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ControlValueAccessor</a> implementieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> kann es vorkommen, dass der Steuerwert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Angular asynchron</a> geändert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird</a> und die Änderungen nicht auf den gewünschten Änderungserkennungszyklus angewendet werden. </li></ol><br>  Als Beispiele für die Verwendung in der <a href="">Demoanwendung</a> gibt es die Basisklasse <a href="">OnPushControlValueAccessor</a> , die das im letzten Absatz beschriebene Problem löst.  Ebenfalls im Projekt gibt es einen Erben dieser Klasse - eine benutzerdefinierte <a href="">Optionsfeldkomponente</a> . <br><br>  Jetzt haben wir alle vier Möglichkeiten zum Ausführen von Änderungserkennungs- und OnPush-Implementierungsoptionen für alle drei Komponententypen erläutert: Container, Smart, Präsentationsoptionen.  Wir kommen zum letzten Punkt - der Bearbeitung von Daten mit reaktiven Formularen. <br><br><a name="form"></a><h2>  Eingekapselte Datenbearbeitung </h2><br>  Reaktive Formen haben eine Reihe von Einschränkungen, aber dies ist immer noch eines der besten Dinge, die im Angular-Ökosystem passiert sind. <br><br>  Zuallererst verkörpern sie die gute Zusammenarbeit mit dem Staat und bieten alle notwendigen Werkzeuge, um reaktiv auf Veränderungen zu reagieren. <br><br>  Tatsächlich ist das reaktive Formular eine Art Mini-Store, der die Arbeit mit dem Status zusammenfasst: Daten und Status deaktiviert / gültig / ausstehend. <br><br>  Es bleibt uns überlassen, diese Kapselung so weit wie möglich zu unterstützen und zu vermeiden, dass Präsentationslogik und Logik der Form vermischt werden. <br><br>  In der Demo-Anwendung sehen Sie <a href="">einzelne Formularklassen</a> , die die Besonderheiten ihrer Arbeit zusammenfassen: Validierung, Erstellen untergeordneter Formgruppen, Arbeiten mit dem deaktivierten Status von Eingabefeldern. <br><br>  Wir erstellen das Stammformular in der Containerkomponente zum Zeitpunkt des Ladens des Status und bei jedem Neustart des Status wird das Formular neu erstellt.  Dies ist keine Voraussetzung, aber auf diese Weise können wir sicher sein, dass in der Formularlogik keine akkumulierten Effekte aus dem vorherigen geladenen Zustand übrig bleiben. <br><br>  Innerhalb des Formulars selbst erstellen wir die Steuerelemente und „schieben“ die Daten, die von ihnen stammen, und konvertieren sie vom Staatsvertrag in den Modellvertrag.  Die Struktur der Formulare entspricht so weit wie möglich den Verträgen der Modelle.  Infolgedessen bietet uns die value-Eigenschaft des Formulars ein vorgefertigtes Modell zum Senden an das Backend. <br><br>  Wenn sich in Zukunft der Status oder die Modellstruktur ändert, wird genau an der Stelle, an der Felder hinzugefügt / entfernt werden müssen, ein Typoskript-Kompilierungsfehler angezeigt, was sehr praktisch ist. <br><br>  Wenn die Status- und Modellobjekte eine absolut identische Struktur haben, entfällt durch die in Typoskript verwendete strukturelle Typisierung die Notwendigkeit, eine bedeutungslose Zuordnung voneinander zu erstellen. <br><br>  Insgesamt ist die Formlogik in Komponenten von der Präsentationslogik isoliert und lebt „von selbst“, ohne die Komplexität des Datenflusses unserer gesamten Anwendung zu erhöhen. <br><br>  Das ist fast alles.  Es gibt noch Grenzfälle, in denen wir die Formularlogik nicht vom Rest der Anwendung isolieren können: <br><br><ol><li>  Formänderungen, die zu einer Änderung des Präsentationsstatus führen, z. B. die Sichtbarkeit eines Datenblocks in Abhängigkeit vom eingegebenen Wert.  Wir implementieren es in der Komponente, indem wir Formularereignisse abonnieren.  Sie können dies durch die unveränderlichen Eigenschaften tun, die zuvor besprochen wurden. </li><li>  Wenn Sie einen asynchronen Validator benötigen, der das Backend aufruft, erstellen wir AsyncValidatorFn in der Komponente und übergeben es an den Formularkonstruktor, nicht an den Service. </li></ol><br>  Somit bleibt die gesamte „Grenzlogik“ an der prominentesten Stelle - in den Komponenten. <br><br><h2>  Schlussfolgerungen </h2><br>  Lassen Sie uns zusammenfassen, was wir haben und welche anderen Punkte es für das Studium und die Entwicklung gibt. <br><br>  Zuallererst zwingt uns die Entwicklung der OnPush-Strategie dazu, Datenflussanwendungen sorgfältig zu entwerfen, da wir jetzt Angular und nicht ihm die Spielregeln diktieren. <br><br>  Diese Situation hat zwei Konsequenzen. <br><br>  Erstens bekommen wir ein angenehmes Gefühl der Kontrolle über die Anwendung.  Es gibt keine Magie mehr, die „irgendwie funktioniert“.  Sie wissen genau, was zu einem bestimmten Zeitpunkt in Ihrer Bewerbung passiert.  Die Intuition entwickelt sich allmählich weiter, sodass Sie den Grund für den gefundenen Fehler verstehen können, noch bevor Sie den Code öffnen. <br><br>  Zweitens müssen wir jetzt mehr Zeit mit dem Entwerfen der Anwendung verbringen, aber das Ergebnis wird immer die „direkteste“ und daher einfachste Lösung sein.  Dies verringert die Wahrscheinlichkeit einer Situation, in der die Anwendung mit zunehmender Größe zu einem Monster von enormer Komplexität wird, die Entwickler die Kontrolle über diese Komplexität verloren haben und die Entwicklung nun eher wie mystische Riten aussieht, erheblich auf Null. <br><br>  Kontrollierte Komplexität und das Fehlen von „Magie“ verringern die Wahrscheinlichkeit einer ganzen Klasse von Problemen, die beispielsweise durch zyklische Datenaktualisierungen oder akkumulierte Nebenwirkungen entstehen.  Stattdessen haben wir es mit Problemen zu tun, die bereits während der Entwicklung auftreten, wenn die Anwendung einfach nicht funktioniert.  Und zwangsläufig müssen Sie dafür sorgen, dass die Anwendung einfach und klar funktioniert. <br><br>  Wir haben auch gute Auswirkungen auf die Leistung erwähnt.  Mit sehr einfachen Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">profiler.timeChangeDetection</a> können wir jetzt jederzeit überprüfen, ob unsere Anwendung noch in gutem Zustand ist. <br><br>  Auch jetzt ist es eine Sünde, nicht zu versuchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, NgZone</a> zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deaktivieren</a> .  Erstens können Sie beim Start der Anwendung nicht die gesamte Bibliothek laden.  Zweitens wird eine ganze Menge Magie aus Ihrer Anwendung entfernt. <br><br>  Hier beenden wir unsere Geschichte. <br><br>  Wir bleiben in Kontakt! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426819/">https://habr.com/ru/post/de426819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426809/index.html">Zeev Surasky: Die Zukunft der Zend Engine und des Zend Frameworks</a></li>
<li><a href="../de426811/index.html">Parkour-, Tanz- und Bauarbeiten von Boston Dynamics</a></li>
<li><a href="../de426813/index.html">? Skype ist zu einem langweiligen Anschein geworden ... und zu einem Produkt, mit dem Sie vollen Zugriff auf Ihr System erhalten? Gibt es Hoffnung?</a></li>
<li><a href="../de426815/index.html">Wie bekomme ich ein Projektentwicklungsstipendium, wenn Sie ein armer Student sind? Und ist es das wert?</a></li>
<li><a href="../de426817/index.html">CommuniGate Pro Private Keys und Web-API</a></li>
<li><a href="../de426821/index.html">So organisieren Sie CI / CD in einem Projekt: vom Festlegen von Aufgaben bis zum Einrichten der Bereitstellungspipeline</a></li>
<li><a href="../de426825/index.html">Ein paar Tipps für Freiberufler</a></li>
<li><a href="../de426831/index.html">Unangenehmes Gespräch, Herpetologe und völlige Überraschung</a></li>
<li><a href="../de426835/index.html">Vergleichende und detaillierte Analyse von Caching-Plugins für WordPress</a></li>
<li><a href="../de426837/index.html">Videoübertragung auf Ihrer Website, die funktioniert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>