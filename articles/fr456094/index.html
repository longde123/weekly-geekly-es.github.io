<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèΩ üå¶Ô∏è üíÜüèª Nous lisons les fiches techniques 2: SPI sur STM32; Temporisateurs et interruptions PWM sur le STM8 üå± üîé üï¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la premi√®re partie, j'ai essay√© de dire aux amateurs d'√©lectronique qui sont issus du pantalon Arduino comment et pourquoi ils devraient lire les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous lisons les fiches techniques 2: SPI sur STM32; Temporisateurs et interruptions PWM sur le STM8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re partie,</a> j'ai essay√© de dire aux amateurs d'√©lectronique qui sont issus du pantalon Arduino comment et pourquoi ils devraient lire les fiches techniques et autres documents pour les microcontr√¥leurs.  Le texte s'est av√©r√© √™tre volumineux, j'ai donc promis de montrer des exemples pratiques dans un article s√©par√©.  Eh bien, il se faisait appeler une cargaison ... </p><br><p>  Aujourd'hui, je vais montrer comment utiliser des fiches techniques pour r√©soudre des t√¢ches assez simples, mais n√©cessaires pour de nombreux projets, sur les contr√¥leurs STM32 (Blue Pill) et STM8.  Tous les projets de d√©monstration sont d√©di√©s √† mes LED pr√©f√©r√©es, nous les allumerons en grande quantit√©, pour lesquelles nous devrons utiliser toutes sortes de p√©riph√©riques int√©ressants. </p><a name="habracut"></a><br><p>  Le texte s'est de nouveau r√©v√©l√© √©norme, donc pour plus de commodit√©, je fais le contenu: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pilule bleue STM32: 16 LED avec pilote DM634</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">STM8: configuration de six broches PWM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">STM8: 8 LED RGB sur trois broches, interrompt</a> </p><br><p>  <em>Avertissement: je ne suis pas ing√©nieur, je ne pr√©tends pas avoir une connaissance approfondie de l'√©lectronique, l'article est destin√© √† des amoureux comme moi.</em>  <em>En fait, en tant que public cible, je me consid√©rais il y a deux ans.</em>  <em>Si quelqu'un m'avait dit alors que ce n'√©tait pas effrayant de lire des fiches techniques sur une puce inconnue, je n'aurais pas pass√© beaucoup de temps √† chercher des morceaux de code sur Internet et √† inventer des b√©quilles avec des ciseaux et un pansement.</em> </p><br><p>  <em>Au centre de cet article se trouvent des fiches techniques, pas des projets, donc le code peut ne pas √™tre trop peign√© et souvent b√©quill√©.</em>  <em>Les projets eux-m√™mes sont tr√®s simples, bien que adapt√©s √† une premi√®re connaissance de la nouvelle puce.</em> </p><br><p>  <em>J'esp√®re que mon article aidera quelqu'un √† un stade similaire dans une plong√©e de loisir.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LED avec DM634 et SPI </h1><br><p>  Un petit projet utilisant la Blue Pill (STM32F103C8T6) et le pilote LED DM634.  √Ä l'aide de fiches techniques, nous traiterons du pilote, des ports IO STM et configurerons SPI. </p><br><h2 id="dm634">  DM634 </h2><br><p>  Puce ta√Øwanaise avec 16 sorties PWM 16 bits, peut √™tre connect√©e en cha√Æne.  Le plus jeune mod√®le 12 bits est connu pour le projet domestique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lightpack</a> .  √Ä un moment donn√©, en choisissant entre le DM63x et le bien connu TLC5940, je me suis arr√™t√© au DM pour plusieurs raisons: 1) TLC sur Aliexpress est d√©finitivement faux, mais celui-ci ne l'est pas;  2) le DM dispose d'un PWM autonome avec son propre g√©n√©rateur de fr√©quence;  3) il pourrait √™tre achet√© √† bon march√© √† Moscou, et ne pas attendre un colis avec Ali.  Eh bien, bien s√ªr, c'√©tait int√©ressant d'apprendre √† g√©rer la puce vous-m√™me, et de ne pas utiliser une biblioth√®que pr√™te √† l'emploi.  Les puces sont maintenant principalement pr√©sent√©es dans le package SSOP24, elles sont faciles √† souder √† l'adaptateur. </p><br><p>  √âtant donn√© que le fabricant est ta√Øwanais, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fiche technique</a> de la puce est r√©dig√©e en anglais chinois, ce qui signifie que ce sera amusant.  Tout d'abord, regardez la <em>connexion des broches</em> ( <em>Pin Connection</em> ) pour comprendre √† quel pied se connecter et la description des broches ( <em>Pin Description</em> ).  16 conclusions: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Sources de courant continu entrant (drain ouvert)</sup> </p><br><p>  <strong>√âvier</strong> / <strong>Sortie √† drain ouvert</strong> - drain;  source de courant entrant;  sortie active connect√©e √† la masse - les LED sont connect√©es au pilote par des cathodes.  √âlectriquement, ce n'est bien s√ªr pas un ¬´drain ouvert¬ª, mais dans les fiches techniques, cette d√©signation pour les sorties en mode drain est courante. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>R√©sistances externes entre REXT et GND pour r√©gler la valeur du courant de sortie</sup> </p><br><p>  Une r√©sistance de r√©f√©rence est install√©e entre la broche REXT et la masse, qui contr√¥le la r√©sistance interne des sorties, voir le graphique page 9 de la fiche technique.  Dans le DM634, cette r√©sistance peut √©galement √™tre contr√¥l√©e par programmation en d√©finissant la <em>luminosit√© globale</em> ;  Je n'entrerai pas dans les d√©tails dans cet article, je viens de mettre une r√©sistance de 2,2 √† 3 kOhm ici. </p><br><p>  Pour comprendre comment contr√¥ler la puce, consultez la description de l'interface de l'appareil: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  Oui, le voici, l'anglais chinois dans toute sa splendeur.  La traduction est probl√©matique, vous pouvez la comprendre si vous le souhaitez, mais il existe un autre moyen - de voir comment la connexion est d√©crite dans la fiche technique du TLC5940 fonctionnellement ferm√©: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Trois broches seulement sont n√©cessaires pour entrer des donn√©es dans l'appareil.</sub>  <sub>Le bord d'attaque du signal SCLK d√©place les donn√©es de la broche SIN vers le registre interne.</sub>  <sub>Une fois toutes les donn√©es t√©l√©charg√©es, un court signal XLAT √©lev√© capture les donn√©es s√©rie dans des registres internes.</sub>  <sub>Registres internes - Robinets-vannes d√©clench√©s par XLAT.</sub>  <sub>Toutes les donn√©es sont transmises dans le bit le plus significatif vers l'avant.</sub> </p><br><p>  <strong>Loquet</strong> - un loquet / loquet / pince. <br>  <strong>Front montant</strong> - bord d'attaque de l'impulsion <br>  <strong>MSB d'abord</strong> - le <strong>bit</strong> le <strong>plus significatif</strong> (le plus √† gauche) vers l'avant. <br>  <strong>pour synchroniser les donn√©es</strong> - transmettre les donn√©es s√©quentiellement (au niveau du bit). </p><br><p>  Le mot <em>verrou se</em> trouve souvent dans la documentation des puces et est traduit de diff√©rentes mani√®res, je vais donc me permettre de comprendre </p><div class="spoiler">  <b class="spoiler_title">petit programme √©ducatif</b> <div class="spoiler_text">  Le pilote LED est essentiellement un registre √† d√©calage.  ¬´Shift¬ª dans le nom est un mouvement de donn√©es au niveau du bit √† l'int√©rieur de l'appareil: chaque nouveau bit pouss√© vers l'int√©rieur pousse la cha√Æne enti√®re devant lui.  √âtant donn√© que personne ne veut observer le clignotement chaotique des LED pendant le d√©calage, le processus se d√©roule dans des registres tampons s√©par√©s des registres de travail par un <em>verrou</em> - c'est une sorte de salle d'attente o√π les bits sont dispos√©s dans la s√©quence souhait√©e.  Lorsque tout est pr√™t, l'obturateur s'ouvre et les bits sont envoy√©s au travail, rempla√ßant le lot pr√©c√©dent.  Le mot <em>verrou</em> dans la documentation des microcircuits implique presque toujours un tel amortisseur, quelle que soit la combinaison utilis√©e. </div></div><br><p>  Ainsi, le transfert de donn√©es vers le DM634 est le suivant: r√©glez l'entr√©e DAI sur le bit de poids fort de la LED distante, tirez le DCK de haut en bas;  r√©glez l'entr√©e DAI sur le bit suivant, tirez DCK;  et ainsi de suite, jusqu'√† ce que tous les bits soient transmis ( <em>cadenc√©s</em> ), apr√®s quoi nous tirons le LAT.  Cela peut √™tre fait manuellement ( <em>bit-bang</em> ), mais il est pr√©f√©rable d'utiliser l'interface SPI affin√©e sp√©cialement pour cela, car elle est pr√©sent√©e sur notre STM32 en deux exemplaires. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Blue Tablet STM32F103 </h2><br><p>  Introduction: les contr√¥leurs STM32 sont beaucoup plus compliqu√©s qu'Atmega328 qu'ils ne peuvent effrayer.  Dans le m√™me temps, pour des raisons d'√©conomie d'√©nergie, presque tous les p√©riph√©riques sont d√©sactiv√©s au d√©marrage et la fr√©quence d'horloge est de 8 MHz depuis une source interne.  Heureusement, les programmeurs de la STM ont √©crit du code qui a amen√© la puce aux 72 MHz ¬´calcul√©s¬ª, et les auteurs de tous les IDE que je connaissais l'ont inclus dans la proc√©dure d'initialisation, nous n'avons donc pas besoin de synchroniser (mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous pouvez, si vous le voulez vraiment</a> ).  Mais vous devez allumer les p√©riph√©riques. </p><br><p>  Documentation: La populaire puce STM32F103C8T6 est install√©e sur la Blue Pill, il y a deux documents utiles: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fiche technique</a> pour microcontr√¥leurs STM32F103x8 et STM32F103xB; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Manuel de r√©f√©rence</a> pour toute la gamme STM32F103 et au-del√†. </li></ul><br><p>  Dans une fiche technique, nous pouvons √™tre int√©ress√©s par: </p><br><ul><li>  Brochage - brochage des puces - au cas o√π nous d√©ciderions de fabriquer nous-m√™mes des planches; </li><li>  Carte m√©moire - carte m√©moire pour une puce sp√©cifique.  Dans le manuel de r√©f√©rence, il y a une carte pour toute la ligne, elle r√©pertorie les registres qui ne sont pas sur les n√¥tres. </li><li>  D√©finitions des broches du tableau - r√©pertoriant les fonctions principales et alternatives des broches;  pour la ¬´pilule bleue¬ª sur Internet, vous pouvez trouver des images plus pratiques avec une liste de broches et leurs fonctions.  Par cons√©quent, recherchez imm√©diatement le brochage Blue Pill sur Google et gardez cette image √† port√©e de main: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>NB: dans l'image provenant d'Internet, une erreur a √©t√© remarqu√©e dans les commentaires, pour laquelle merci.</em>  <em>L'image a √©t√© remplac√©e, mais c'est une le√ßon - il est pr√©f√©rable de v√©rifier les informations provenant de non-fiches techniques.</em> </p><br><p>  Nous supprimons la fiche technique, ouvrons le Manuel de r√©f√©rence, maintenant nous ne l'utilisons que. <br>  Proc√©dure: nous traitons les entr√©es / sorties standard, configurons SPI, allumons les p√©riph√©riques souhait√©s. </p><br><h3 id="vvod-vyvod">  Entr√©e-sortie </h3><br><p>  Les E / S Atmega328 sont extr√™mement simples, c'est pourquoi l'abondance d'options STM32 peut pr√™ter √† confusion.  Maintenant, nous n'avons besoin que de conclusions, mais m√™me il y a quatre options: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>sortie drain ouvert, sortie push-pull, sortie push-pull alternative, drain ouvert alternative</sub> </p><br><p>  " <em>Push-pull</em> " ( <em>push-pull</em> ) - la conclusion habituelle d'Arduina, la broche peut √™tre soit HAUTE soit BASSE.  Mais avec le "drain ouvert" il y a des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">difficult√©s</a> , bien qu'en fait tout soit simple ici: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Configuration de la sortie / lorsque le port est affect√© √† la sortie: / le tampon de sortie est activ√©: / - mode drain ouvert: "0" active N-MOS dans le registre de sortie, "1" laisse le port en mode Hi-Z dans le registre de sortie (P-MOS n'est pas activ√© ) / - mode ¬´pull-push¬ª: ¬´0¬ª dans le registre de sortie active N-MOS, ¬´1¬ª dans le registre de sortie active P-MOS.</sub> </p><br><p>  Toute la diff√©rence entre le drain ouvert et le <em>push-pull</em> est que dans la premi√®re broche, il ne peut pas accepter l'√©tat HIGH: lors de l'√©criture d'une unit√© dans le registre de sortie, il passe en <em>haute imp√©dance</em> , <em>Hi -Z</em> ).  Lors de l'enregistrement du z√©ro, la broche dans les deux modes se comporte de la m√™me fa√ßon, √† la fois logiquement et √©lectriquement. </p><br><p>  En mode de sortie normal, la broche traduit simplement le contenu du registre de sortie.  Dans l '"alternative", elle est contr√¥l√©e par la p√©riph√©rie correspondante (voir 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>Si le bit de port est configur√© comme sortie de fonction alternative, le registre de sortie est d√©sactiv√© et la broche est connect√©e au signal de sortie p√©riph√©rique</sub> </p><br><p>  Une fonctionnalit√© alternative pour chaque broche est d√©crite dans la fiche technique des <em>d√©finitions de broche</em> et figure sur l'image t√©l√©charg√©e.  Lorsqu'on lui a demand√© quoi faire si la broche a plusieurs fonctions alternatives, la r√©ponse donne une note de bas de page dans la fiche technique: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>Si plusieurs blocs p√©riph√©riques utilisent la m√™me broche, afin d'√©viter un conflit entre des fonctions alternatives, un seul bloc p√©riph√©rique doit √™tre utilis√© en m√™me temps, la commutation utilisant le bit d'activation d'horloge p√©riph√©rique (dans le registre RCC correspondant).</sub> </p><br><p>  Enfin, les broches en mode sortie ont √©galement une vitesse d'horloge.  Ceci est une autre fonction d'√©conomie d'√©nergie, dans notre cas, nous la r√©glons simplement au maximum et l'oublions. </p><br><p>  Donc: nous utilisons SPI, donc deux broches (avec des donn√©es et un signal d'horloge) devraient √™tre une ¬´fonction push-push alternative¬ª, et une autre (LAT) devrait √™tre ¬´pull-push normale¬ª.  Mais avant de les attribuer, nous traiterons avec SPI. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Un autre petit programme √©ducatif</b> <div class="spoiler_text"><p>  SPI ou Serial Peripherial Interface (interface p√©riph√©rique s√©rie) - une interface simple et tr√®s efficace pour la communication MK avec d'autres MK et le monde ext√©rieur en g√©n√©ral.  Le principe de son fonctionnement a d√©j√† √©t√© d√©crit ci-dessus, en ce qui concerne le driver LED chinois (dans le manuel de r√©f√©rence, voir section 25).  SPI peut fonctionner en modes ma√Ætre (¬´ma√Ætre¬ª) et esclave (¬´esclave¬ª).  SPI dispose de quatre canaux de base, dont tous ne sont pas n√©cessairement impliqu√©s: </p><br><ul><li>  MOSI, Master Output / Slave Input: cette broche en mode ma√Ætre envoie, mais en mode esclave, elle re√ßoit des donn√©es; </li><li>  MISO, Master Input / Slave Output: au contraire, dans le ma√Ætre accepte, dans l'esclave - donne; </li><li>  SCK, Serial Clock: d√©finit la fr√©quence du transfert de donn√©es dans le ma√Ætre ou re√ßoit un signal d'horloge dans l'esclave.  Bat essentiellement les bits; </li><li>  SS, Slave Select: via ce canal, l'esclave apprend qu'il en veut quelque chose.  Sur STM32, il est appel√© NSS, o√π N = n√©gatif, c'est-√†-dire  le contr√¥leur devient un esclave s'il y a de la terre dans ce canal.  Se combine bien avec le mode Open Drain Output, mais c'est une autre histoire. </li></ul></div></div><br><p>  Comme tout le reste, le SPI du STM32 est riche en fonctionnalit√©s, ce qui le rend quelque peu difficile √† comprendre.  Par exemple, cela peut fonctionner non seulement avec le SPI, mais aussi avec l'interface I2S, et dans la documentation leurs descriptions sont m√©lang√©es, vous devez couper l'exc√©dent en temps opportun.  Notre t√¢che est extr√™mement simple: il vous suffit d'envoyer des donn√©es en utilisant uniquement MOSI et SCK.  Nous allons √† la section 25.3.4 (communication semi-duplex), o√π nous trouvons <em>1 horloge et 1 fil de donn√©es unidirectionnel</em> (1 signal d'horloge et 1 flux de donn√©es unidirectionnel): </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>Dans ce mode, l'application utilise SPI en mode √©mission uniquement ou en r√©ception uniquement.</sub>  <sub>/ Le mode de transmission uniquement est similaire au mode duplex: les donn√©es sont transmises sur la broche de transmission (MOSI en mode ma√Ætre ou MISO en mode esclave), et la broche de r√©ception (MISO ou MOSI, respectivement) peut √™tre utilis√©e comme une broche d'entr√©e-sortie r√©guli√®re.</sub>  <sub>Dans ce cas, il suffit que l'application ignore le tampon Rx (si vous le lisez, il n'y aura pas de donn√©es transmises).</sub> </p><br><p>  Eh bien, la broche MISO est libre de nous, connectons-y le signal LAT.  Nous traiterons de Slave Select, qui peut √™tre contr√¥l√© par programmation sur le STM32, ce qui est extr√™mement pratique.  Nous lisons le paragraphe du m√™me nom dans la section 25.3.1 de la description g√©n√©rale SPI: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>Contr√¥le de programme NSS (SSM = 1) / Des informations sur la s√©lection de l'esclave sont contenues dans le bit SSI du registre SPI_CR1.</sub>  <sub>La broche NSS externe reste libre pour d'autres besoins d'application.</sub> </p><br><p>  Il est temps d'√©crire dans les registres.  J'ai d√©cid√© d'utiliser SPI2, nous recherchons l'adresse de base dans la fiche technique - dans la section 3.3 Carte m√©moire: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Eh bien, nous commen√ßons: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  Nous ouvrons la section 25.3.3 avec le dicton ¬´Configuration de SPI en mode ma√Ætre¬ª: </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. R√©glez la vitesse d'horloge s√©rie avec les bits BR [2: 0] dans le registre SPI_CR1.</strong> </p><br><p>  Les registres sont collect√©s dans la section du manuel de r√©f√©rence du m√™me nom.  CR1 a un <em>d√©calage d'adresse</em> ( <em>d√©calage d'adresse</em> ) de 0x00, par d√©faut, tous les bits sont r√©initialis√©s ( <em>valeur de r√©initialisation</em> 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  Les bits BR d√©finissent le diviseur de fr√©quence d'horloge du contr√¥leur, d√©terminant ainsi la fr√©quence √† laquelle le SPI fonctionnera.  Nous aurons une fr√©quence de STM32 de 72 MHz, le pilote LED, selon sa fiche technique, fonctionne avec une fr√©quence allant jusqu'√† 25 MHz, il est donc n√©cessaire de diviser par quatre (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. D√©finissez les bits CPOL et CPHA pour d√©terminer la relation entre le transfert de donn√©es et la synchronisation de l'interface s√©rie (voir sch√©ma page 240)</strong> </p><br><p>  √âtant donn√© que nous lisons ici les fiches techniques et que nous ne consid√©rons pas les circuits, √©tudions mieux la description textuelle des bits CPOL et CPHA √† la page 704 (SPI General Description): </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Phase d'horloge et polarit√©</sub> <sub><br></sub>  <sub>En utilisant les bits CPOL et CPHA du registre SPI_CR1, quatre options pour les relations de synchronisation peuvent √™tre s√©lectionn√©es par programme.</sub>  <sub>Le bit CPOL (polarit√© d'horloge) contr√¥le l'√©tat de l'horloge lorsqu'aucune donn√©e n'est transmise.</sub>  <sub>Ce bit contr√¥le les modes ma√Ætre et esclave.</sub>  <sub>Si le CPOL est r√©initialis√©, la broche SCK est faible en mode veille.</sub>  <sub>Si le bit CPOL est d√©fini, la broche SCK est √† un niveau √©lev√© en mode inactif.</sub> <sub><br></sub>  <sub>Si le bit CPHA (phase d'horloge) est d√©fini, le deuxi√®me front du signal SCK agit comme une trappe du bit haut (d√©croissant si CPOL est r√©initialis√©, ou montant si CPOL est d√©fini).</sub>  <sub>Les donn√©es sont captur√©es par le deuxi√®me changement du signal d'horloge.</sub>  <sub>Si le bit CPHA est effac√©, le front avant du signal SCK agit comme une trappe du bit haut (vers le bas si CPOL est d√©fini, ou vers le haut si CPOL est effac√©).</sub>  <sub>Les donn√©es sont captur√©es par le premier changement du signal d'horloge.</sub> </p><br><p>  Apr√®s avoir fum√© cette connaissance, nous concluons que les deux bits doivent rester des z√©ros, car  nous avons besoin que le signal SCK reste faible lorsqu'il n'est pas utilis√© et que les donn√©es soient transmises le long du front d'attaque de l'impulsion (voir <em>Rising Edge</em> dans la fiche technique du DM634). </p><br><p>  Soit dit en passant, nous avons ici rencontr√© pour la premi√®re fois une caract√©ristique du vocabulaire dans les fiches techniques ST: la phrase ¬´r√©initialiser le bit √† z√©ro¬ª est √©crite <em>pour r√©initialiser un bit</em> , et non <em>pour effacer un bit</em> , comme, par exemple, dans Atmega. </p><br><p>  <strong>3. D√©finissez le bit DFF pour d√©finir un format de bloc de donn√©es 8 bits ou 16 bits.</strong> </p><br><p>  J'ai pris sp√©cifiquement le DM634 16 bits, afin de ne pas d√©ranger avec la transmission de donn√©es PWM 12 bits, comme le DM633.  DFF est logique de mettre dans une unit√©: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Configurez le bit LSBFIRST dans le registre SPI_CR1 pour d√©terminer le format de bloc</strong> </p><br><p>  LSBFIRST, comme son nom l'indique, active le bit de poids faible.  Mais le DM634 veut recevoir des donn√©es en commen√ßant par le bit haut.  Par cons√©quent, nous la laissons de c√¥t√©. </p><br><p>  <strong>5. En mode mat√©riel, si une entr√©e de la broche NSS est requise, envoyez un signal haut √† la broche NSS pendant toute la s√©quence de transfert d'octets.</strong>  <strong>En mode programme NSS, d√©finissez les bits SSM et SSI dans le registre SPI_CR1.</strong>  <strong>Si la broche NSS doit fonctionner en sortie, seul le bit SSOE doit √™tre d√©fini.</strong> </p><br><p>  Installez SSM et SSI pour oublier le mode mat√©riel NSS: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. Les bits MSTR et SPE doivent √™tre d√©finis (ils ne le sont que si un signal haut est appliqu√© au NSS)</strong> </p><br><p>  En fait, avec ces bits, nous attribuons notre SPI en tant que ma√Ætre et l'activons: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  SPI est configur√©, √©crivons des fonctions qui envoient imm√©diatement des octets au pilote.  Nous continuons √† lire 25.3.3 "Configuration de SPI en mode ma√Ætre": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Proc√©dure de transfert de donn√©es</sub> <sub><br></sub>  <sub>La transmission commence lorsqu'un octet est √©crit dans le tampon Tx.</sub> <sub><br></sub>  <sub>L'octet de donn√©es est charg√© dans le registre √† d√©calage en mode <strong>parall√®le</strong> (depuis le bus interne) pendant la transmission du premier bit, apr√®s quoi il est transmis en mode <strong>s√©rie</strong> √† la broche MOSI, le premier ou le dernier bit en avant, selon le r√©glage du bit LSBFIRST dans le registre CPI_CR1.</sub>  <sub>L'indicateur TXE est d√©fini apr√®s le transfert <strong>des</strong> donn√©es <strong>du tampon Tx vers le registre √† d√©calage</strong> , et une interruption est √©galement cr√©√©e si le bit TXEIE est d√©fini dans le registre CPI_CR1.</sub> </p><br><p>  J'ai soulign√© quelques mots dans la traduction pour attirer l'attention sur une caract√©ristique de la mise en ≈ìuvre de SPI dans les contr√¥leurs STM.  Sur Atmega, l'indicateur TXE ( <em>Tx Empty</em> , Tx est vide et pr√™t √† recevoir des donn√©es) n'est d√©fini qu'apr√®s que tout l'octet s'est <em>√©teint</em> .  Et ici, ce drapeau est d√©fini apr√®s que l'octet est pouss√© dans le registre √† d√©calage interne.  Puisqu'il y est pouss√© simultan√©ment par tous les bits (en parall√®le), puis que les donn√©es sont transmises s√©quentiellement, TXE est d√©fini avant que l'octet ne soit compl√®tement envoy√©.  Ceci est important car  dans le cas de notre pilote LED, nous devons tirer la broche LAT apr√®s l'envoi de <em>toutes les</em> donn√©es, c'est-√†-dire  Seul le drapeau TXE ne nous suffira pas. </p><br><p>  Et cela signifie que nous avons besoin d'un autre drapeau.  Voyons dans 25.3.7 - ¬´Indicateurs d'√©tat¬ª: </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>Drapeau BUSY</sub> <sub><br></sub>  <sub>Le drapeau BSY est d√©fini et r√©initialis√© par le mat√©riel (l'√©criture n'y affecte rien).</sub>  <sub>L'indicateur BSY indique l'√©tat de la couche de communication SPI.</sub> <sub><br></sub>  <sub>Il est r√©initialis√©:</sub> <sub><br></sub>  <sub>lorsque le transfert est termin√© (sauf pour le mode ma√Ætre, si le transfert est continu)</sub> <sub><br></sub>  <sub>lorsque SPI est d√©sactiv√©</sub> <sub><br></sub>  <sub>lorsqu'une erreur de mode assistant se produit (MODF = 1)</sub> <sub><br></sub>  <sub>Si la transmission n'est pas continue, le drapeau BSY est effac√© entre chaque transmission de donn√©es.</sub> </p><br><p>  D'accord, venez √† port√©e de main.  Nous d√©couvrons o√π se trouve le tampon Tx.  Pour ce faire, lisez le "SPI Data Register": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bits 15: 0 DR [15: 0] Registre de donn√©es</sub> <sub><br></sub>  <sub>Donn√©es re√ßues ou donn√©es √† transmettre.</sub> <sub><br></sub>  <sub>Le registre de donn√©es est divis√© en deux tampons - un pour l'√©criture (tampon de transmission) et le second pour la lecture (tampon de r√©ception).</sub>  <sub>L'√©criture dans le registre de donn√©es √©crit dans le tampon Tx et la lecture dans le registre de donn√©es renvoie la valeur contenue dans le tampon Rx.</sub> </p><br><p>  Eh bien, le registre d'√©tat, o√π il y a des drapeaux TXE et BSY: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  Nous √©crivons: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Eh bien, puisque nous devons transmettre 16 octets deux fois, selon le nombre de sorties du pilote LED, quelque chose comme ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  Mais nous ne savons toujours pas comment tirer la broche LAT, nous allons donc revenir aux E / S. </p><br><h3 id="naznachaem-piny">  Attribuer des broches </h3><br><p>  Dans STM32F1, les registres responsables de l'√©tat des broches sont assez inhabituels.  Il est clair qu'il y en a plus qu'Atmega, mais ils diff√®rent √©galement des autres puces STM.  Section 9.1 Description g√©n√©rale de GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Chacun des ports d'entr√©e / sortie √† usage g√©n√©ral <em>(GPIO)</em> poss√®de deux registres de configuration 32 bits (GPIOx_CRL et GPIOx_CRH), deux registres de donn√©es 32 bits (GPIOx_IDR et GPIOx_ODR), un registre de d√©finition / r√©initialisation 32 bits (GPIOx_BSRR), 16 bits un registre de r√©initialisation (GPIOx_BRR) et un registre de bloc 32 bits (GPIOx_LCKR).</sub> </p><br><p>  Insolites, mais plut√¥t g√™nants, les deux premiers registres sont l√†, car 16 broches de ports sont √©parpill√©es au format ¬´quatre bits par fr√®re¬ª.  C'est-√†-dire  les broches de z√©ro √† septi√®me se trouvent dans la CRL et les autres dans la CRH.  En m√™me temps, le reste des registres s'int√®gre avec succ√®s dans les bits de toutes les broches du port - restant souvent √† moiti√© ¬´r√©serv√©s¬ª. </p><br><p>  Par souci de simplicit√©, commencez √† la fin de la liste. </p><br><p>  Nous n'avons pas besoin d'un registre de bloc. </p><br><p>  Les registres de configuration et de r√©initialisation sont assez dr√¥les en ce qu'ils se dupliquent partiellement: vous pouvez tout √©crire uniquement dans BSRR, o√π les 16 bits les plus √©lev√©s remettront la broche √† z√©ro, et les plus bas - mis √† 1, ou utiliser √©galement BRR, les 16 bits inf√©rieurs qui ne r√©initialisent que la broche .  J'aime la deuxi√®me option.  Ces registres sont importants en ce qu'ils fournissent un acc√®s atomique aux broches: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Installation ou r√©initialisation atomique</sub> <sub><br></sub>  <sub>Vous n'avez pas besoin de d√©sactiver les interruptions lors de la programmation de GPIOx_ODR au niveau des bits: vous pouvez modifier un ou plusieurs bits avec une op√©ration d'√©criture atomique APB2.</sub>  <sub>Ceci est r√©alis√© en √©crivant ¬´1¬ª dans le registre de d√©finition / r√©initialisation (GPIOx_BSRR ou, pour la r√©initialisation uniquement, dans GPIOx_BRR) le bit que vous souhaitez modifier.</sub>  <sub>Les autres bits resteront inchang√©s.</sub> </p><br><p>  Les registres de donn√©es ont des noms assez parlants - IDR = registre de direction d'entr√©e, registre d'entr√©e;  ODR = registre de direction de sortie, registre de sortie.  Dans le projet actuel, nous n'en aurons pas besoin. </p><br><p>  Et enfin, les registres de contr√¥le.  Puisque nous sommes int√©ress√©s par les broches du deuxi√®me SPI, √† savoir PB13, PB14 et PB15, nous examinons imm√©diatement CRH: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  Et nous voyons qu'il faudra √©crire quelque chose en bits du 20 au 31. </p><br><p>  Nous avons d√©j√† compris ce que nous voulons des broches, donc ici je peux me passer d'une capture d'√©cran, dites simplement que MODE d√©finit la direction (entr√©e, si les deux bits sont d√©finis sur 0) et la vitesse des broches (nous avons besoin de 50 MHz, c'est-√†-dire les deux broche en "1"), et CNF d√©finit le mode: normal "push-push" - 00, "alternative" - ‚Äã‚Äã10. Par d√©faut, comme nous le voyons ci-dessus, toutes les broches ont le troisi√®me bit √† partir du bas (CNF0), il les d√©finit sur mode d' <em>entr√©e flottant</em> . </p><br><p>  Puisque je pr√©vois de faire autre chose avec cette puce, pour plus de simplicit√©, j'ai d√©fini toutes les valeurs possibles de MODE et CNF pour les registres de contr√¥le inf√©rieur et sup√©rieur. </p><br><div class="spoiler">  <b class="spoiler_title">Eh bien, quelque chose comme √ßa</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Nos broches sont situ√©es sur le port B (l'adresse de base est 0x40010C00), code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO ‚Äì B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  Et, en cons√©quence, vous pouvez √©crire des d√©finitions pour le LAT, ce qui va contracter les registres BRR et BSRR: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse ‚Äì high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low juste par inertie, en quelque sorte √ßa a toujours √©t√©, laissez-vous rester) </p><br><p>  Maintenant, tout est d√©j√† g√©nial, ne fonctionne tout simplement pas.  Parce que c'est STM32, il √©conomise de l'√©lectricit√©, ce qui signifie que vous devez activer l'horloge pour les p√©riph√©riques n√©cessaires. </p><br><h2 id="vklyuchaem-taktirovanie">  Activer le timing </h2><br><p>  L'horloge est responsable de l'horloge, ils sont √©galement horloge.  Et nous pouvions d√©j√† voir l'abr√©viation RCC.  Nous le recherchons dans la documentation: c'est Reset et Clock Control. </p><br><p>  Comme cela a √©t√© dit ci-dessus, heureusement, les gens de la STM ont fait la partie la plus difficile du th√®me du timing pour nous, merci beaucoup pour eux (je vais vous donner un lien vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de Di Halt</a> pour montrer clairement √† quel point cela est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">confus</a> ).  Nous avons juste besoin des registres charg√©s d'activer les horloges p√©riph√©riques (registres d'activation d'horloge p√©riph√©rique).  Tout d'abord, trouvez l'adresse de base de RCC, elle est au tout d√©but de la "Memory Card": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  Et puis, soit cliquez sur le lien o√π essayer de trouver quelque chose dans la plaque, soit, bien mieux, parcourez les descriptions des registres d'inclusion dans les sections sur <em>les registres d'activation</em> .  O√π nous trouvons RCC_APB1ENR et RCC_APB2ENR: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  Et en eux, respectivement, des bits, y compris l'horloge SPI2, IOPB (I / O Port B) et des fonctions alternatives (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  Le code final peut √™tre trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </p><br><p>  S'il y a une opportunit√© et un d√©sir de tester, alors nous connectons DM634 comme ceci: DAI √† PB15, DCK √† PB13, LAT √† PB14.  Nous alimentons le driver √† partir de 5 volts, n'oubliez pas de combiner la terre. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM sur STM8 </h1><br><p>  Lorsque je planifiais cet article, par exemple, j'ai d√©cid√© d'essayer d'apprendre certaines fonctionnalit√©s d'une puce inconnue avec juste une fiche technique, afin de ne pas avoir un cordonnier sans bottes.  STM8 convenait parfaitement √† ce r√¥le: d'une part, j'avais quelques cartes m√®res chinoises avec STM8S103, et d'autre part, il n'est pas tr√®s populaire, et donc la tentation de lire et de trouver une solution sur Internet repose en l'absence de ces m√™mes solutions. </p><br><p>  La puce a √©galement une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fiche technique</a> et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel de r√©f√©rence RM0016</a> , dans les premi√®res adresses de brochage et d'enregistrement, dans la seconde - tout le reste.  STM8 est programm√© en C dans le laid IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ST Visual Develop</a> . </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Horloge et E / S </h3><br><p>  Par d√©faut, le STM8 fonctionne √† une fr√©quence de 2 MHz, cela doit √™tre corrig√© imm√©diatement. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>Horloge HSI (vitesse interne)</sub> <sub><br></sub>  <sub>L'horloge HSI est obtenue √† partir d'un oscillateur RC interne de 16 MHz avec un diviseur programmable (1 √† 8).</sub>  <sub>Il est plac√© dans le registre du diviseur d'horloge (CLK_CKDIVR).</sub> <sub><br></sub>  <sub>Remarque: au d√©but, l'oscillateur HSI RC avec diviseur 8 est s√©lectionn√© comme source d'horloge principale.</sub> </p><br><p>  Nous trouvons l'adresse du registre dans la fiche technique, la description dans refman et voyons que le registre doit √™tre effac√©: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Puisque nous allons d√©marrer PWM et connecter les LED, nous regardons le brochage: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  La puce est petite, de nombreuses fonctions sont suspendues sur les m√™mes broches.  Le fait que, entre crochets, soit une ¬´fonctionnalit√© alternative¬ª, elle est commut√©e par des ¬´ <em>octets d'options</em> ¬ª - quelque chose comme les fusibles d'Atmega.  Vous pouvez modifier leurs valeurs par programme, mais pas n√©cessaire, car  la nouvelle fonctionnalit√© n'est activ√©e qu'apr√®s un red√©marrage.  Il est plus facile d‚Äôutiliser ST Visual Programmer (t√©l√©chargements avec Visual Develop) qui peut modifier ces octets.  Le brochage montre que les conclusions de CH1 et CH2 du premier temporisateur sont cach√©es entre crochets;  il est n√©cessaire de mettre les bits AFR1 et AFR0 dans STVP, et le second transf√®rera √©galement la sortie de CH1 du deuxi√®me temporisateur de PD4 √† PC5. </p><br><p>  Ainsi, 6 broches contr√¥leront les LED: PC6, PC7 et PC3 pour le premier temporisateur, PC5, PD3 et PA3 pour le second. </p><br><p>  La configuration des broches d'E / S elles-m√™mes sur le STM8 est plus simple et plus logique que sur le STM32: </p><br><ul><li>  familier avec le registre de <em>direction des donn√©es</em> Atmega: 1 = sortie; </li><li>  le premier registre de commande CR1 √† la sortie d√©finit le mode push-pull (1) ou drain ouvert (0);  puisque je connecte les LED √† la puce avec des cathodes, je laisse des z√©ros ici; </li><li>  le deuxi√®me registre de contr√¥le CR2 √† la sortie r√®gle la vitesse d'horloge: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  Configuration PWM </h2><br><p>  D√©finissons d'abord les termes: </p><br><ul><li>  <strong>PWM Frequency</strong> - fr√©quence avec laquelle le chronom√®tre tourne; </li><li>  <strong>Auto-rechargement, AR</strong> - valeur de chargement automatique √† laquelle la minuterie comptera (p√©riode d'impulsion); </li><li>  <strong>√âv√©nement de mise √† jour, UEV</strong> - un √©v√©nement <strong>qui se produit</strong> lorsque le temporisateur a compt√© pour AR; </li><li>  <strong>Cycle d'utilisation</strong> PWM - <strong>Cycle d'utilisation</strong> PWM, souvent appel√© "cycle d'utilisation"; </li><li>  <strong>Capture / Compare Value</strong> - valeur pour la capture / comparaison, apr√®s avoir compt√© jusqu'√† ce que le temporisateur <em>fasse quelque chose</em> (dans le cas de PWM, il inverse le signal de sortie); </li><li>  <strong>Preload Value</strong> - valeur pr√©charg√©e.  <em>La valeur de comparaison ne</em> peut pas changer pendant que la minuterie tourne, sinon le cycle PWM s'arr√™tera.  Par cons√©quent, les nouvelles valeurs transmises sont plac√©es dans le tampon et retir√©es de l√† lorsque le temporisateur atteint la fin du comptage et est r√©initialis√©; </li><li>  <strong>Modes</strong> align√©s sur les bords et align√©s sur le centre - alignement sur la bordure et au centre, le m√™me que le <em>PWM rapide</em> Atmelovskie et le <em>PWM</em> <em>√† correction de phase</em> . </li><li>  <strong>OCiREF, Output Compare Reference Signal</strong> - le signal de sortie de r√©f√©rence, en fait, qui en mode PWM est sur la broche correspondante. </li></ul><br><p>  Comme il ressort d√©j√† du brochage, deux temporisateurs ont les capacit√©s PWM - le premier et le second.  Les deux sont en 16 bits, le premier a beaucoup de fonctionnalit√©s suppl√©mentaires (en particulier, il peut compter √† la fois vers le haut et vers le bas).  Nous avons besoin des deux pour travailler de la m√™me mani√®re, j'ai donc d√©cid√© de commencer par la seconde √©videmment la plus pauvre, afin de ne pas utiliser accidentellement quelque chose qui n'y est pas.  Un probl√®me est que la description de la fonctionnalit√© PWM de tous les temporisateurs dans le manuel de r√©f√©rence se trouve dans le chapitre sur le premier temporisateur (17.5.7 Mode PWM), vous devez donc aller et venir tout au long du document. </p><br><p>  PWM sur STM8 a un avantage important sur PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM avec alignement des bords</sub> <sub><br></sub>  <sub>Configuration du compte de bas en haut</sub> <sub><br></sub>  <sub>Le d√©compte ascendant est actif si le bit DIR du registre TIM_CR1 est effac√©</sub> <sub><br></sub>  <sub>Exemple</sub> <sub><br></sub>  <sub>L'exemple utilise le premier mode PWM.</sub>  <sub>Le signal de r√©f√©rence OCiREF PWM est maintenu haut tandis que TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>Sinon, cela prend un faible niveau.</sub>  <sub>Si la valeur de comparaison dans TIM1_CCRi est sup√©rieure √† la valeur de d√©marrage (registre TIM1_ARR), le signal OCiREF est maintenu √† 1. <strong>Si la valeur de comparaison est 0, OCiREF est maintenu √† z√©ro.</strong></sub>  <sub>...</sub> </p><br><p>  Le temporisateur STM8 pendant l' <em>√©v√©nement de mise √† jour</em> v√©rifie d'abord la <em>valeur de comparaison</em> , puis ne donne qu'un signal de r√©f√©rence.  La minuterie d'Atmega m√©lange d'abord, puis compare, √† la suite de quoi, lorsque la <code>compare value == 0</code> la sortie entra√Æne une aiguille qui doit √™tre combattue d'une mani√®re ou d'une autre (par exemple, en inversant la logique par programme). </p><br><p>  Donc, ce que nous voulons faire: PWM 8 bits ( <code>AR == 255</code> ), nous consid√©rons de bas en haut, l'alignement le long de la fronti√®re.  √âtant donn√© que les ampoules sont connect√©es √† la puce par des cathodes, le PWM doit sortir 0 (la LED est allum√©e) avant de <em>comparer la valeur</em> et 1 apr√®s. </p><br><p>  Nous avons d√©j√† lu quelques informations sur le <em>mode PWM</em> , nous trouvons donc le registre souhait√© du deuxi√®me temporisateur en cherchant dans le manuel de r√©f√©rence cette phrase (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: Premier mode PWM - lors du comptage de bas en haut, le premier canal est actif lorsque TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Sinon, le premier canal est inactif.</sub>  <sub>[plus loin dans le document copier-coller erron√© du temporisateur 1]</sub> <sub><br></sub>  <sub>111: Deuxi√®me mode PWM - lors du comptage de bas en haut, le premier canal est inactif tandis que TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Sinon, le premier canal est actif.</sub> </p><br><p>  Comme les LED sont connect√©es aux cathodes MK, le deuxi√®me mode nous convient (le premier aussi, mais nous ne le savons pas encore). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Activer la pr√©charge de la sortie 1</sub> <sub><br></sub>  <sub>0: registre de pr√©charge √† TIMx_CCR1 d√©sactiv√©.</sub>  <sub>Vous pouvez √©crire √† TIMx_CCR1 √† tout moment.</sub>  <sub>La nouvelle valeur fonctionne imm√©diatement.</sub> <sub><br></sub>  <sub>1: Le registre de pr√©chargement √† TIMx_CCR1 est activ√©.</sub>  <sub>Les op√©rations de lecture / √©criture acc√®dent au registre de pr√©charge.</sub>  <sub>La valeur pr√©charg√©e TIMx_CCR1 est charg√©e dans le registre fant√¥me lors de chaque √©v√©nement de mise √† jour.</sub> <sub><br></sub>  <sub>* Remarque: pour que le mode PWM fonctionne correctement, les registres de pr√©charge doivent √™tre activ√©s.</sub> <sub>      (  TIMx_CR1   OPM).</sub> <br></p><p> ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p> AR     ,   : </p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p>      -,   ,    .   , ,  256.        TIM2_PSCR     : </p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p>       .     <em>Capture/Compare <strong>Enable</strong></em> :  ,      .     ,     , ..       PWM Mode 1. : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   ¬´¬ª   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   ‚Ä¶    .   ? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   ‚Äì  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     ¬´¬ª   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   ¬´¬ª,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  ‚Äì ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     ‚Äì      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X ‚Äì  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> ‚Äì   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  C'est-√†-dire  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     ‚Ññ13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    ‚Ññ13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> ‚Äì     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    ‚Äì <code>sim</code> ‚Äì  .          ¬´¬ª,         . </p><br><p>   ‚Äì <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456094/">https://habr.com/ru/post/fr456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456084/index.html">Kubernetes 1.15: Aper√ßu des faits saillants</a></li>
<li><a href="../fr456086/index.html">Storyboards iOS: analyse des avantages et des inconv√©nients, meilleures pratiques</a></li>
<li><a href="../fr456088/index.html">Probl√®mes d'analyse du Big Data</a></li>
<li><a href="../fr456090/index.html">Introduction aux tests unitaires dans Unity</a></li>
<li><a href="../fr456092/index.html">Sept signes troublants que vous d√©pendez des conditions m√©t√©orologiques, m√™me si vous ne le pensez pas</a></li>
<li><a href="../fr456096/index.html">Ce que fait le lecteur de geektimes moyen en planant dans les nuages</a></li>
<li><a href="../fr456100/index.html">Maintenant dans le nouvel emballage - Kingston A400 au format M.2 se pr√©cipite sur le march√©</a></li>
<li><a href="../fr456102/index.html">Rapports faciles en C / C ++</a></li>
<li><a href="../fr456104/index.html">Ezblock Pi - programmation sans programmation, cette fois pour les fans de Raspberry Pi</a></li>
<li><a href="../fr456108/index.html">Habr Weekly # 5 / Les sujets sombres sont partout, les usines chinoises de la F√©d√©ration de Russie, o√π les banques ont coul√©, Pixel 4, ML pollue l'atmosph√®re</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>