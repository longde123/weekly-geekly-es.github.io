<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐣 🧛 🏭 Funciones para documentar bases de datos PostgreSQL. Primera parte 🎂 👨🏿‍🤝‍👨🏽 🤙🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante el trabajo con PostgreSQL, se han acumulado más de cien funciones para trabajar con directorios del sistema: pg_class, pg_attribute, pg_constr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funciones para documentar bases de datos PostgreSQL. Primera parte</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415575/">  Durante el trabajo con PostgreSQL, se han acumulado más de cien funciones para trabajar con directorios del sistema: pg_class, pg_attribute, pg_constraints, etc. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zc/rx/ta/zcrxta08dnfat5cqpgid4lyq7by.png"></div><br>  ¿Qué hacer con ellos?  Se usan relativamente raramente.  ¿Incluir en algún proyecto?  El cliente de Krasnoyarsk no pagará por tales "tonterías".  Y, sin embargo, ¿qué pasa si son útiles para otra persona que no sea el autor?  Y decidió ponerlos, como leer libros, en un armario público para quienes lo deseen. <br><a name="habracut"></a><br>  Alguien quiere usarlos en su trabajo.  Y alguien interesado en algo más que su experiencia con los catálogos de sistemas. <br><br>  Pero para no convertir la publicación en una enumeración aburrida, no se sabe por qué se crearon las funciones, decidí detenerme en aquellas que pueden unirse por un objetivo común.  Por lo tanto, se seleccionan las funciones que se utilizan para mostrar una lista extendida de características de una tabla de base de datos arbitraria. <br><br>  La función <b>admtf_Table_ComplexFeatures</b> devuelve la lista extendida de características de la tabla de la base de datos, que en este artículo se denominará la función head  Por lo tanto, el artículo se limitará a considerar las funciones que se llaman en el proceso de ejecución de la función head. <br><br>  La primera mitad del artículo proporciona comentarios sobre la implementación de funciones.  El segundo es el código fuente de las funciones.  Para aquellos lectores que solo están interesados ​​en los textos de origen, sugerimos proceder inmediatamente al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Apéndice</a> . <br><p>  <b>Ver también</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones para documentar bases de datos PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte dos</a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones para documentar bases de datos PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte</a></b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones para documentar bases de datos PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El final (parte cuatro)</a> .</b> <br></p><br><br><a name="ExpFeatures"></a><br><h3>  ¿De qué características avanzadas estamos hablando? </h3><br>  Para tener una idea de lo que se entiende por las características extendidas de la tabla de base de datos, comenzamos considerando la siguiente lista de características.  La lista contiene las características de la tabla de la base de datos de Street devuelta por <b>admtf_Table_ComplexFeatures ( <i>'public'</i> , <i>'street'</i> )</b> . <br><p>  La siguiente tabla contiene una lista abreviada de las características de la tabla Street.  Un conjunto completo de características de esta tabla se proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Materiales complementarios del Apéndice 2.</a> <br><br>  <strong>Tabla 1. Características avanzadas de la tabla Street.</strong> <br><img src="https://habrastorage.org/webt/zj/5x/jn/zj5xjnygaeedplccbe_itjr7fpu.png"><br></p><div class="spoiler">  <b class="spoiler_title">La versión de texto de la tabla en la figura.</b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="5">  Categoría </th><th width="5">  No </th><th width="15">  Titulo </th><th width="20">  Comentario </th><th width="20">  tipo </th><th width="20">  Tipo base </th><th width="5">  ?  no NULL </th></tr><tr><td width="5">  tbl </td><td width="5">  0 0 </td><td width="15">  calle </td><td width="20">  Lista de calles en asentamientos </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  att </td><td width="5">  1 </td><td width="15">  wcrccode </td><td width="20">  Código de país </td><td width="20">  wcrccode </td><td width="20">  letra pequeña </td><td width="5">  t </td></tr><tr><td width="5">  att </td><td width="5">  2 </td><td width="15">  localityid </td><td width="20">  ID de comunidad </td><td width="20">  localityid </td><td width="20">  entero </td><td width="5">  t </td></tr><tr><td width="5">  att </td><td width="5">  3 </td><td width="15">  streetid </td><td width="20">  ID calle del pueblo </td><td width="20">  streetid </td><td width="20">  letra pequeña </td><td width="5">  t </td></tr><tr><td width="5">  att </td><td width="5">  4 4 </td><td width="15">  streettypeacrm </td><td width="20">  Siglas de la calle </td><td width="20">  streettypeacrm </td><td width="20">  personaje (8) </td><td width="5">  f </td></tr><tr><td width="5">  att </td><td width="5">  5 5 </td><td width="15">  nombre de calle </td><td width="20">  Nombre de la calle </td><td width="20">  streettypeacrm </td><td width="20">  varchar (150) </td><td width="5">  t </td></tr><tr><td width="5">  pk </td><td width="5">  0 0 </td><td width="15">  xpkstreet </td><td width="20">  Clave principal de la mesa de calle </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  pkatt </td><td width="5">  1 </td><td width="15">  wcrccode </td><td width="20">  Código de país </td><td width="20">  wcrccode </td><td width="20">  letra pequeña </td><td width="5">  t </td></tr><tr><td width="5">  fk01 </td><td width="5">  1 </td><td width="15">  fk_street_locality </td><td width="20">  Clave externa de tabla </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  fk02 </td><td width="5">  2 </td><td width="15">  fk_street_streettype </td><td width="20">  Clave externa de tabla </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx01 </td><td width="5">  1 </td><td width="15">  xie1street </td><td width="20">  Indice por tipo y nombre de calle del asentamiento </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx02 </td><td width="5">  2 </td><td width="15">  xie2street </td><td width="20">  Código postal </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx03 </td><td width="5">  3 </td><td width="15">  xie3street </td><td width="20">  Índice de nombres de calles de todos los asentamientos </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5">  idx04 </td><td width="5">  4 4 </td><td width="15">  xpkstreet </td><td width="20">  El índice único (clave principal) de la tabla de calle </td><td width="20"></td><td width="20"></td><td width="5"></td></tr></tbody></table><br></div></div><br><p>  Enumerando la hostilidad hacia este conjunto de letras y números, puede ver que estamos hablando de las características habituales de una tabla de base de datos: </p><br><ul><li>  Nombres de tablas; </li><li>  La lista de atributos de tabla y sus tipos; </li><li>  La clave primaria y la lista de claves foráneas de la tabla, junto con los atributos de la tabla que las componen; </li><li>  Una lista de índices de tabla. </li></ul><br><p>  La unicidad de cada entrada de la lista de características está garantizada por los valores de los campos de "categoría" y el número de serie ("No.") de la característica. </p><br><br>  <strong>Tabla 2. Categorías de características de la tabla.</strong> <br><img src="https://habrastorage.org/webt/sy/j9/5z/syj95z_zta0nii9_9-n7zaxzq3q.png"><br><div class="spoiler">  <b class="spoiler_title">La versión de texto de la tabla en la figura.</b> <div class="spoiler_text"><table><tbody><tr><th>  Acrónimo </th><th>  Cita </th></tr><tr><td>  tb </td><td>  Características de la mesa </td></tr><tr><td>  att </td><td>  Características del atributo de tabla </td></tr><tr><td>  seq </td><td>  Características de secuencia </td></tr><tr><td>  pk </td><td>  Características principales principales </td></tr><tr><td>  pkAtt </td><td>  Características principales del atributo clave </td></tr><tr><td>  fk99 </td><td>  Características clave extranjeras </td></tr><tr><td>  fk99att </td><td>  Características de atributos de clave externa </td></tr><tr><td>  fk99rtbl </td><td>  Características de la tabla referenciada por la clave externa </td></tr><tr><td>  fk99ratt </td><td>  Características del atributo de la tabla a la que hace referencia la clave externa </td></tr><tr><td>  Idx99 </td><td>  Características del índice </td></tr><tr><td>  Idx99att </td><td>  Características de los atributos del índice </td></tr><tr><td>  Inhtbl99 </td><td>  Características de la tabla generada. </td></tr></tbody></table><br></div></div><br><p>  El valor de la categoría es necesario para distinguir diferentes grupos de características entre sí.  Un número de serie, para distinguir las características dentro del grupo. </p><br><p>  Se pueden declarar varias claves foráneas (CLAVE EXTRANJERA) e índices en la tabla de la base de datos.  Por lo tanto, el valor de categoría para estas características y sus descendientes contiene un número de serie.  Por ejemplo, una entrada con la clave "Categoría" = <strong>idx02att</strong> y "No." = <strong>1</strong> indica el primer atributo del segundo índice. </p><br><p>  En la lista de categorías anterior, la ubicación del número de serie se indica como '99'. </p><br><p>  <strong>Observación 1</strong> </p><br><img src="https://habrastorage.org/webt/xt/ye/1l/xtye1lr36ssftr4kmvnwedjgnew.png"><br><div class="spoiler">  <b class="spoiler_title">El código fuente del operador en la figura</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> admtf_Table_ComplexFeatures(<span class="hljs-string"><span class="hljs-string">'pg_catalog'</span></span>,<span class="hljs-string"><span class="hljs-string">'pg_class'</span></span>);</code> </pre> <br></div></div><br><br><p>  El artículo da ejemplos de las características de las tablas, que se describen brevemente en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un esquema auxiliar</a> creado específicamente para demostrar las capacidades de las funciones.  Pero el lector, después de haber creado esta o aquella función en su base de datos, puede usar los nombres de sus esquemas y tablas como parámetros.  Además, por ejemplo, el directorio <strong>pg_class</strong> se puede usar como parámetro, aunque en este caso se emite un número limitado de características. </p><p></p><p>  <strong>El final del comentario.</strong> </p><br><a name="tfTableCF_def"></a><br><h3>  Estructura de la función de la cabeza </h3><br><img src="https://habrastorage.org/webt/mn/pw/9w/mnpw9welx2ltfhwiqllgqrp6uyc.png"><br>  <strong>Fig.</strong>  <strong>1. Las funciones que causan la función de la cabeza.</strong> <br><br>  <strong>Tabla 3. Asignación de funciones.</strong> <br><img src="https://habrastorage.org/webt/po/yb/et/poybetf0ogfvr0l95pxzdw5m1yq.png"><br><div class="spoiler">  <b class="spoiler_title">La versión de texto de la tabla en la figura.</b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="5">  No </th><th width="10">  Titulo </th><th width="40">  Cita </th></tr><tr><td width="5">  1 </td><td width="10">  admtf_Table_Features </td><td width="40">  La función devuelve una lista de características de la tabla de la base de datos. </td></tr><tr><td width="5">  2 </td><td width="10">  admtf_Table_Attributes </td><td width="40">  La función devuelve una lista de atributos de tabla de base de datos y sus características. </td></tr><tr><td width="5">  3 </td><td width="10">  admtf_Table_Constraintes </td><td width="40">  La función devuelve una lista de restricciones de tabla de base de datos y sus características. </td></tr><tr><td width="5">  4 4 </td><td width="10">  admtf_Table_Indexes </td><td width="40">  La función devuelve una lista de índices de tabla de base de datos y sus características. </td></tr><tr><td width="5">  5 5 </td><td width="10">  admtf_Table_InheritanceChildrens </td><td width="40">  La función devuelve una lista de tablas generadas por (IHERITS) de la tabla de la base de datos de origen. </td></tr><tr><td width="5">  6 6 </td><td width="10">  admtf_Table_Sequences </td><td width="40">  La función devuelve una lista de secuencias (SECUENCIA) de la que depende la tabla. </td></tr><tr><td width="5">  7 7 </td><td width="10">  admtf_PrimaryKey_ComplexFeatures </td><td width="40">  La función devuelve una lista completa (extendida) de características de clave primaria (CLAVE PRIMARIA) de la tabla de la base de datos. </td></tr><tr><td width="5">  8 </td><td width="10">  admtf_ForeignKey_ComplexFeatures </td><td width="40">  La función devuelve una lista completa (extendida) de características de clave externa (CLAVE EXTRANJERA) de la tabla de la base de datos. </td></tr><tr><td width="5">  9 9 </td><td width="10">  admtf_Index_ComplexFeatures </td><td width="40">  La función devuelve una lista completa (extendida) de las características del índice de la tabla de la base de datos. </td></tr><tr><td width="5">  10 </td><td width="10">  admtf_Table_ComplexFeatures </td><td width="40">  La función devuelve una lista completa (extendida) de las características de la tabla de la base de datos. </td></tr></tbody></table><br></div></div><br><p>  <strong>Observación 2.</strong> </p><br><p>  Las descripciones de las funciones se organizarán en el orden que se muestra arriba.  La razón es que el artículo tendrá que dividirse en varias partes.  Y las funciones dispuestas en este orden se pueden usar independientemente del hecho de que algunas de ellas se describirán solo en las siguientes partes de la publicación. </p><br><p>  <strong>El final del comentario.</strong> </p><br><br><h3>  Lista de funciones Admtf_Table_Features de las características de la tabla de base de datos </h3><br><a name="tfTableF_def"></a><br><br><p>  La función admtf_Table_Features devuelve una lista de características de la tabla de la base de datos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El código fuente se puede ver y descargar aquí.</a> </p><br><p>  Como parámetros, la función toma el nombre de la tabla fuente <b>(a_TableName</b> ) y el nombre del esquema dentro del cual se crea la tabla ( <b>a_SchemaName</b> ). </p><br><p>  La función extrae los datos principales de la <b>entrada de</b> catálogo <b>pg_class</b> , que contiene, además de las entradas de la tabla, también registros sobre secuencias, vistas, vistas materializadas y tipos compuestos.  Por lo tanto, para seleccionar tablas, se usa la condición relkind = <b><font color="red">'r'</font></b> . </p><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tbl.relname,dsc.description,tbl.relnatts::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,tbl.relchecks::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, tbl.relhaspkey,tbl.relhasindex,tbl.relhassubclass,tbl.reltuples::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace = nspc.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid=dsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>( nspc.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind=<span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname) =<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName);</code> </pre><br><p>  Además, la función accede a los datos del directorio <b>pg_namespace</b> y <b>pg_description</b> .  El primero contiene los nombres de los esquemas de la base de datos y el segundo contiene comentarios sobre todos los objetos de la base de datos. </p><br><p>  Es importante prestar atención a la condición <b>objsubid = 0</b> .  Define el comentario en la tabla, ya que el valor del campo objoid es el mismo para la tabla y sus atributos.  El comentario sobre el atributo de la tabla está contenido en la entrada en la que <b>objsubid</b> coincide con el número de este atributo. </p><br><br>  <strong>Tabla 4. El resultado de ejecutar la función admtf_Table_Features ('public', 'Street').</strong> <br><br><table width="95" border="1"><tbody><tr><th width="10">  Titulo </th><th width="20">  Comentario </th><th width="5">  Numero de atributos </th><th width="5">  Número de restricciones CHECK </th><th width="5">  ?  hay una clave primaria </th><th width="5">  ?  son índices declarados </th><th width="5">  ?  hay descendientes </th><th width="5">  El número de entradas en la tabla. </th></tr><tr><td width="10">  calle </td><td width="20">  Lista de calles en asentamientos </td><td width="5">  22 </td><td width="5">  0 0 </td><td width="5">  t </td><td width="5">  t </td><td width="5">  f </td><td width="5">  20150 </td></tr></tbody></table><br><p>  <strong>Observación 3</strong> </p><br><p>  Presta atención al número de atributos de la tabla de calle.  Difiere significativamente del número de atributos especificados en el esquema auxiliar. </p><br><p>  Tabla 5. Atributos adicionales de la tabla Street. </p><br><table><tbody><tr><th width="10">  attname </th><th width="5">  atttypid </th><th width="5">  Attnum </th><th width="10">  Nota </th></tr><tr><td width="10">  cmin </td><td width="5">  29 </td><td width="5">  -4 </td><td width="10">  Atributo del sistema </td></tr><tr><td width="10">  xmin </td><td width="5">  28 </td><td width="5">  -3 </td><td width="10">  Atributo del sistema </td></tr><tr><td width="10">  ctid </td><td width="5">  27 </td><td width="5">  -1 </td><td width="5">  Atributo del sistema </td></tr><tr><td width="10">  wcrccode </td><td width="5">  795369 </td><td width="5">  1 </td><td width="5">  Atributo válido </td></tr><tr><td width="10">  localityid </td><td width="5">  795352 </td><td width="5">  2 </td><td width="10">  Atributo válido </td></tr><tr><td width="10">  streetid </td><td width="5">  795364 </td><td width="5">  3 </td><td width="10">  Atributo válido </td></tr><tr><td width="10">  streettypeacrm </td><td width="5">  1919168 </td><td width="5">  4 4 </td><td width="10">  Atributo válido </td></tr><tr><td width="10">  nombre de calle </td><td width="5">  1043 </td><td width="5">  5 5 </td><td width="10">  Atributo válido </td></tr><tr><td width="10">  ........ pg.dropped.6 ........ </td><td width="5">  0 0 </td><td width="5">  6 6 </td><td width="10">  Atributo remoto </td></tr><tr><td width="10">  ........ pg.dropped.7 ........ </td><td width="5">  0 0 </td><td width="5">  7 7 </td><td width="10">  Atributo remoto </td></tr></tbody></table><br><p>  El hecho es que PostgreSQL, además de los atributos principales, también tiene en cuenta varios atributos del sistema e incluso atributos eliminados. </p><br><p>  <strong>Comentario final</strong> </p><br><br><h3>  Función admtf_Table_Attributes lista de atributos de tabla de base de datos y sus características </h3><a name="tfTableA_def"></a><br><p>  La función <b>admtf_Table_Attributes</b> devuelve una lista de atributos de la tabla de la base de datos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El código fuente se puede ver y descargar aquí.</a> </p><br><p>  Como parámetros, la función toma el nombre de la tabla fuente ( <b>a_TableName</b> ) y el nombre del esquema dentro del cual se crea la tabla ( <b>a_SchemaName</b> ). </p><br><p>  La función recupera los datos principales de las <b>entradas de</b> directorio <b>pg_attribute</b> y <b>pg_type</b> .  El primero contiene registros con datos sobre los atributos de tablas, vistas, vistas materializadas, tipos compuestos e incluso funciones.  El segundo trata sobre las características de los tipos de atributos. </p><br><p>  Quizás se requiera alguna aclaración por la forma en que el usuario y los tipos base se definen en la función. </p><br><p>  Un atributo de tabla se declara con un tipo personalizado si el campo <b>typbasetype</b> es <b>mayor</b> que 0 en la <b>entrada de</b> directorio <b>pg_type</b> correspondiente, de lo contrario, el atributo es del tipo base.  Por lo tanto, el directorio <b>pg_type está</b> involucrado dos veces en la cláusula FROM.  En la primera entrada del directorio, se determina la presencia de un tipo de usuario; si no está definido ( <b>typbasetype = 0</b> ), se genera un valor de tipo base a partir de esta entrada.  De lo contrario, el tipo base se determina a partir del registro para el cual btyp.OID = typ.typbasetype. </p><br><p>  Directamente, la línea con el tipo base se forma utilizando la función del catálogo del sistema <b>FORMAT_TYPE (type_oid, typemod)</b> .  El primer parámetro de los cuales es el tipo base de registros OID.  El segundo parámetro es el valor modificador para los tipos que contienen un tamaño.  Por ejemplo, VARCHAR (100) o NUMERIC (4,2), DECIMAL (4,2).  El valor del parámetro <b>typemod</b> se toma de <b>typ.typtypmod</b> si el atributo es de un tipo de usuario, de lo contrario, de <b>attr.atttypmod</b> , es decir  directamente desde un registro de atributos. </p><br><img src="https://habrastorage.org/webt/gv/jx/q0/gvjxq0pb7kjjrv6galmsht5s9do.png"><br><div class="spoiler">  <b class="spoiler_title">El código fuente del operador en la figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attnum, attr.attname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> typ.typname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, FORMAT_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>),typ.oid), <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typtypmod,<span class="hljs-number"><span class="hljs-number">-1</span></span>),attr.atttypmod))::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>), attr.attnotnull, dsc.description <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid = attr.attrelid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace = nspc.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dsc.objoid=attr.attrelid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=attr.attnum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>( nspc.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname) =<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind=<span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tbl.relname,attr.attnum;</code> </pre><br></div></div><br><p>  Además, la función accede a los datos del directorio <b>pg_class</b> , <b>pg_namespace</b> y <b>pg_description</b> .  Los directorios primero y segundo se usan para buscar atributos por los nombres del esquema y la tabla de la base de datos. <br><br>  El tercer directorio se utiliza para recuperar el comentario para el atributo de tabla. </p><br><p>  El comentario sobre el atributo de la tabla está en la entrada en la que <b>dsc.objoid</b> contiene el OID de la tabla de origen, y <b>dsc.objsubid es el</b> número de serie del atributo en la tabla, es decir.  <b>attr.attnum</b> . </p><br><p>  Para evitar que la función devuelva el sistema y los atributos remotos, la cláusula WHERE establece la condición <b>attr.attnum&gt; 0 AND attr.atttypID&gt; 0</b> . </p><br><br>  <strong>Tabla 6. El resultado de ejecutar la función admtf_Table_Attributes ('public', 'Street').</strong> <br><br><table width="95" border="1"><tbody><tr><th width="5">  No </th><th width="10">  Titulo </th><th width="20">  Tipo personalizado </th><th width="20">  Tipo base </th><th width="5">  ?  no NULL </th><th width="25">  Comentario </th></tr><tr><td width="5">  1 </td><td width="10">  wcrccode </td><td width="20">  wcrccode </td><td width="20">  letra pequeña </td><td width="5">  t </td><td width="25">  Código de país </td></tr><tr><td width="5">  2 </td><td width="10">  localityid </td><td width="20">  localityid </td><td width="20">  entero </td><td width="5">  t </td><td width="25">  ID de comunidad </td></tr><tr><td width="5">  3 </td><td width="10">  streetid </td><td width="20">  streetid </td><td width="20">  letra pequeña </td><td width="5">  t </td><td width="25">  ID calle del pueblo </td></tr><tr><td width="5">  4 4 </td><td width="10">  streettypeacrm </td><td width="20">  streettypeacrm </td><td width="20">  personaje (8) </td><td width="5">  f </td><td width="25">  Siglas de la calle </td></tr><tr><td width="5">  5 5 </td><td width="10">  nombre de calle </td><td width="20"></td><td width="20">  varchar (150) </td><td width="5">  t </td><td width="25">  Nombre de la calle del asentamiento. </td></tr></tbody></table><br><h4>  Versión de función utilizando alias regclass para tipo oid </h4><br><p>  Los identificadores de objetos PostgreSQL (OID) son del mismo tipo que OID, que actualmente se implementa como un entero de cuatro bytes sin signo.  Pero debido a la presencia de alias de este tipo, un número entero se puede representar como el nombre de un objeto.  Y viceversa: convierta el nombre del objeto en un entero de tipo OID. </p><br><p>  Como ejemplo, eche un vistazo a la siguiente <b>instrucción SELECT</b> .  Inusualmente recupera los nombres de la tabla de atributos y los nombres de sus tipos; en lugar de acceder a los campos de directorio correspondientes con los nombres de estas características, se utilizan: <br></p><ul><li>  <b>attrelid :: regclass (attrelid :: regclass: NAME)</b> , </li><li>  <b>atttypid :: regtype (atttypid :: regtype: NAME)</b> </li><li>  <b>typbasetype :: regtype (typbasetype :: regtype: NAME)</b> . </li></ul><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attname,attr.attrelid::regclass, attr.atttypid::regtype, typ.typbasetype::regtype,attr.attrelid::regclass::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, attr.atttypid::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,typ.typbasetype::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=(<span class="hljs-string"><span class="hljs-string">'public'</span></span>||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-string"><span class="hljs-string">'Street'</span></span>)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum;</code> </pre><br><p>  El siguiente es el resultado de ejecutar esta consulta. </p><br><img src="https://habrastorage.org/webt/zr/4_/ga/zr4_gal9s-8jnhihyjia7cq0xvs.png"><br><p>  En la lista de valores de salida del operador SELECT antes de la conversión utilizando alias del tipo OID, todos los valores, excepto el nombre del atributo, son numéricos, pero como resultado, se muestran los nombres de tabla y los tipos de atributo.  Los tipos de valores de salida pueden considerarse en la segunda línea del encabezado de la tabla. </p><br><p>  Además, en la cláusula WHERE de la declaración, se encuentra la condición <b>attr.attrelid = ('public' || '.' || 'Street') :: regclass</b> , en el lado izquierdo del cual hay un valor numérico, y a la derecha hay una cadena que se convierte en un valor numérico con usando el alias <b>regclass</b> . </p><br><img src="https://habrastorage.org/webt/7v/tl/nh/7vtlnhnhqmr7idtdcebcsffzjik.png"><br><div class="spoiler">  <b class="spoiler_title">El código fuente del operador en la figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attnum, attr.attname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> typ.typname::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>, FORMAT_TYPE(<span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typbasetype,<span class="hljs-number"><span class="hljs-number">0</span></span>),typ.oid), <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NULLIF</span></span>(typ.typtypmod,<span class="hljs-number"><span class="hljs-number">-1</span></span>),attr.atttypmod))::<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>), attr.attnotnull, dsc.description <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dsc.objoid=attr.attrelid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=attr.attnum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=( a_SchemaName ||<span class="hljs-string"><span class="hljs-string">'.'</span></span>|| a_TableName)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum;</code> </pre><br></div></div><br>  Usando el alias regclass de la declaración principal, puede eliminar la conexión a dos directorios.  Pero tal mejora casi no tuvo efecto en el rendimiento de la función: en ambas versiones, la función se ejecuta en 11 ms.  Quizás debido al hecho de que la tabla de prueba tiene pocos atributos. <br>  <b>Observación 4</b> <br><p>  Un defecto grave en la condición en la forma <b>attr.attrelid = (a_SchemaName || '.' || a_TableName) :: regclass</b> se manifiesta cuando hay un esquema y / o tabla con un nombre inusual en la base de datos.  Por ejemplo, <b>"Mi esquema"</b> y / o <b>"Mi tabla"</b> .  Dichos valores deben transmitirse entre comillas dobles o utilizar la función QUOTE_IDENT; de lo contrario, la función fallará con un error del sistema. </p><br><img src="https://habrastorage.org/webt/jt/ak/nv/jtaknvaqwphry4yla4bnlemrdeq.png"><br><div class="spoiler">  <b class="spoiler_title">El código fuente del operador en la figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">/*       «   »*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attname,attr.attrelid::regclass, attr.atttypid::regtype,typ.typbasetype::regtype, attr.attrelid::regclass::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, attr.atttypid::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,typ.typbasetype::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=(<span class="hljs-string"><span class="hljs-string">' '</span></span>||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-string"><span class="hljs-string">' '</span></span>)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attname,attr.attrelid::regclass, attr.atttypid::regtype,typ.typbasetype::regtype, attr.attrelid::regclass::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, attr.atttypid::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,typ.typbasetype::regtype::<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_type typ <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> attr.atttypid=typ.oid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid=(<span class="hljs-string"><span class="hljs-string">'" "'</span></span>||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-string"><span class="hljs-string">'" "'</span></span>)::regclass <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.atttypID&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> attr.attnum;</code> </pre><br></div></div><br>  Por lo tanto, prefiero usar condiciones en la forma <b>INFERIOR (nspc.nspname) = INFERIOR (a_SchemaName) Y INFERIOR (tbl.relname) = INFERIOR (a_TableName)</b> , lo que no conduce a errores del sistema. <br><br>  <b>Comentario final</b> <br><a name="Script1"></a><br><h2>  APÉNDICE 1. Scripts </h2><a name="tfTableF"></a><br><h3>  Creación de la función admtf_Table_Features </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los comentarios sobre el código fuente de la función se pueden encontrar aquí.</a> <br><div class="spoiler">  <b class="spoiler_title">código fuente de la función</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Features (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     ,   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Features (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (rs_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,rs_TableDescription <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>,rs_NumberOfAttribute <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,rs_NumberOfChecks <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,rs_hasPKey <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_hasIndex <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_hasSubClass <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_NumberOfRow <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'r'</span></span>; v_TableOID OID; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableDescription TEXT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableNumberOfRowCalc INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN SELECT INTO rs_TableName,rs_TableDescription,rs_NumberOfAttribute, rs_NumberOfChecks,rs_hasPKey,rs_hasIndex,rs_hasSubClass, rs_NumberOfRow tbl.relname,dsc.description,tbl.relnatts::INTEGER,tbl.relchecks::INTEGER, tbl.relhaspkey,tbl.relhasindex,tbl.relhassubclass,tbl.reltuples::INTEGER FROM pg_class tbl INNER JOIN pg_namespace nspc ON tbl.relnamespace = nspc.oid LEFT OUTER JOIN pg_Description dsc ON tbl.oid=dsc.objoid AND dsc.objsubid=0 WHERE nspc.nspname=LOWER(a_SchemaName) AND tbl.relkind=c_TableKind AND tbl.relname =LOWER(a_TableName); EXECUTE 'SELECT count(*) FROM ' ||LOWER(a_SchemaName) ||'.'||quote_ident(LOWER(a_TableName)) INTO v_TableNumberOfRowCalc; RETURN QUERY SELECT rs_TableName,rs_TableDescription,rs_NumberOfAttribute, rs_NumberOfChecks,rs_hasPKey,rs_hasIndex, rs_hasSubClass,v_TableNumberOfRowCalc AS rs_NumberOfRow; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Features(a_SchemaName NAME,a_TableName NAME) IS '   ,  '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Features (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)); /********************************************************************************************************/ /*     ,   */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Features (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (rs_TableName VARCHAR(256),rs_TableDescription TEXT,rs_NumberOfAttribute INTEGER,rs_NumberOfChecks INTEGER,rs_hasPKey BOOLEAN,rs_hasIndex BOOLEAN,rs_hasSubClass BOOLEAN,rs_NumberOfRow INTEGER) AS $BODY$ DECLARE c_TableKind CONSTANT CHAR:='r'; v_TableOID OID; /*   */ v_TableName VARCHAR(256); /*   */ v_TableDescription TEXT; /*   */ v_TableNumberOfRowCalc INTEGER; /*     */ --****************************************************************************************************** BEGIN RETURN QUERY SELECT tf.rs_TableName::VARCHAR(256), tf.rs_TableDescription::TEXT, tf.rs_NumberOfAttribute::INTEGER, tf.rs_NumberOfChecks::INTEGER, tf.rs_hasPKey::BOOLEAN, tf.rs_hasIndex::BOOLEAN, tf.rs_hasSubClass::BOOLEAN, tf.rs_NumberOfRow::INTEGER FROM admtf_Table_Features(a_SchemaName::NAME,a_TableName::NAME) tf; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Features(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)) IS '   ,  '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECt * FROM admtf_Table_Features('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECt * FROM admtf_Table_Features('public':: NAME,'Street'::NAME);</span></span></code> </pre><br></div></div><br><a name="tfTableA"></a><br><h3>  Creación de la función admtf_Table_Attributes </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los comentarios sobre el código fuente de la función se pueden encontrar aquí.</a> <br><div class="spoiler">  <b class="spoiler_title">código fuente de la función</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_AttributeNumber <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>,r_AttributeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_UserTypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_TypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isNotNULL <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_Description <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'r'</span></span>; v_Scale INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN RETURN QUERY SELECT attr.attnum AS r_AttributeNumber, attr.attname::NAME AS r_AttributeName, CASE WHEN COALESCE(typ.typbasetype,0)&gt;0 THEN typ.typname::NAME ELSE ''::NAME END AS r_UserTypeName, FORMAT_TYPE(COALESCE(NULLIF(typ.typbasetype,0),typ.oid), COALESCE(NULLIF(typ.typtypmod,-1),attr.atttypmod))::NAME AS r_TypeName, attr.attnotnull AS r_isNotNULL, dsc.description AS r_Description FROM pg_attribute attr INNER JOIN pg_class tbl ON tbl.oid = attr.attrelid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid LEFT OUTER JOIN pg_type typ ON attr.atttypid=typ.oid LEFT OUTER JOIN pg_type btyp ON typ.typbasetype=btyp.oid LEFT OUTER JOIN pg_description dsc ON dsc.objoid=attr.attrelid AND dsc.objsubid=attr.attnum WHERE LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) AND tbl.relkind=c_TableKind AND attr.attnum&gt;0 AND attr.atttypID&gt;0 ORDER BY tbl.relname,attr.attnum; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName NAME,a_TableName NAME) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Attributes (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Attributes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_AttributeNumber SMALLINT,r_AttributeName VARCHAR(256),r_UserTypeName VARCHAR(256),r_TypeName VARCHAR(256),r_isNotNULL BOOLEAN, r_Description Text) AS $BODY$ DECLARE c_TableKind CONSTANT CHAR:='r'; v_Scale INTEGER; /*   */ --****************************************************************************************************** BEGIN RETURN QUERY SELECT ta.r_AttributeNumber::SMALLINT, ta.r_AttributeName::VARCHAR(256), ta.r_UserTypeName::VARCHAR(256), ta.r_TypeName::VARCHAR(256), ta.r_isNotNULL::BOOLEAN, ta.r_Description::TEXT FROM admtf_Table_Attributes(a_SchemaName::NAME,a_TableName::NAME) ta; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Attributes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Attributes('public'::NAME,'Street'::NAME);</span></span></code> </pre><br></div></div><br><h3>  Creación de la función admtf_Table_Attributes con el alias Regclass </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los comentarios sobre el código fuente de la función se pueden encontrar aquí.</a> <br><div class="spoiler">  <b class="spoiler_title">código fuente de la función</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/********************************************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Attributes (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_AttributeNumber <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>,r_AttributeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_UserTypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_TypeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_isNotNULL <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, r_Description <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'r'</span></span>; v_Scale INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN RETURN QUERY SELECT attr.attnum AS r_AttributeNumber, attr.attname::NAME AS r_AttributeName, CASE WHEN COALESCE(typ.typbasetype,0)&gt;0 THEN typ.typname::NAME ELSE ''::NAME END AS r_UserTypeName, FORMAT_TYPE(COALESCE(NULLIF(typ.typbasetype,0),typ.oid), COALESCE(NULLIF(typ.typtypmod,-1),attr.atttypmod))::NAME AS r_TypeName, attr.attnotnull AS r_isNotNULL, dsc.description AS r_Description FROM pg_attribute attr INNER JOIN pg_type typ ON attr.atttypid=typ.oid LEFT OUTER JOIN pg_type btyp ON typ.typbasetype=btyp.oid LEFT OUTER JOIN pg_description dsc ON dsc.objoid=attr.attrelid AND dsc.objsubid=attr.attnum WHERE attr.attrelid=(LOWER(a_SchemaName)||'.'|| LOWER(a_TableName))::regclass AND attr.attnum&gt;0 AND attr.atttypID&gt;0 ORDER BY attr.attnum; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName NAME,a_TableName NAME) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Attributes (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)); /********************************************************************************************************/ /*      */ /********************************************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Attributes (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_AttributeNumber SMALLINT,r_AttributeName VARCHAR(256),r_UserTypeName VARCHAR(256),r_TypeName VARCHAR(256),r_isNotNULL BOOLEAN, r_Description Text) AS $BODY$ DECLARE c_TableKind CONSTANT CHAR:='r'; v_Scale INTEGER; /*   */ --****************************************************************************************************** BEGIN RETURN QUERY SELECT ta.r_AttributeNumber::SMALLINT, ta.r_AttributeName::VARCHAR(256), ta.r_UserTypeName::VARCHAR(256), ta.r_TypeName::VARCHAR(256), ta.r_isNotNULL::BOOLEAN, ta.r_Description::TEXT FROM admtf_Table_Attributes(a_SchemaName::NAME,a_TableName::NAME) ta; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Attributes(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Attributes('public'::VARCHAR(256),'Street'::VARCHAR(256)); SELECT * FROM admtf_Table_Attributes('public'::NAME,'Street'::NAME);</span></span></code> </pre><br></div></div><br><a name="Apendix2"></a><br><h2>  APÉNDICE 2. Materiales adicionales </h2><br><h3>  Esquema de base de datos auxiliar </h3><br><a name="scheme_for_tests"></a><br><img src="https://habrastorage.org/webt/qi/rb/9q/qirb9qyb5nzkn3hef8v7pvgyvvs.png"><br><br><ul><li>  <b>PAÍS</b> - Clasificador de países del mundo - OKSM (Clasificación de países del mundo en toda Rusia); </li><li>  <b>HOUSEADDR</b> - Lista de números de casas en las calles de los asentamientos; </li><li>  <b>LCLTYTYPE</b> - Directorio de tipos de asentamientos; </li><li>  <b>LOCALIDAD</b> - Lista de asentamientos; </li><li> <b>STREET</b> —     ; </li><li> <b>STREETTYPE</b> —   ; </li><li> <b>TERRITORY</b> —   (, , ,   ..); </li><li> <b>TERRITORYTYPE</b> —   . </li></ul><br><br><a name="Street_char"></a><br><h3>    Street () </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">        .</a> <br> <strong> 1.    Street ().</strong> <br><img src="https://habrastorage.org/webt/vw/ze/rp/vwzerpaegckljldqsmbrq22zf_m.png"><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="5">  Categoría </th><th width="5">  No </th><th width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Titulo </font></font></th><th width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comentario </font></font></th><th width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipo </font></font></th><th width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipo base </font></font></th><th width="5">  ?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no NULL </font></font></th></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tbl </font></font></td><td width="5">  0 0 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calle </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lista de calles en asentamientos </font></font></td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> att </font></font></td><td width="5">  1 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wcrccode </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código de país </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wcrccode </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> letra pequeña </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> att </font></font></td><td width="5">  2 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> localityid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID de comunidad </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> localityid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entero </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> att </font></font></td><td width="5">  3 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> streetid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID calle del pueblo </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> streetid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> letra pequeña </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> att </font></font></td><td width="5">  4 4 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> streettypeacrm </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Siglas de la calle </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> streettypeacrm </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> personaje (8) </font></font></td><td width="5">  f </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> att </font></font></td><td width="5">  5 5 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nombre de calle </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nombre de la calle </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> streettypeacrm </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> varchar (150) </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pk </font></font></td><td width="5">  0 0 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> xpkstreet </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clave principal de la mesa de calle </font></font></td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pkatt </font></font></td><td width="5">  1 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wcrccode </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código de país </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wcrccode </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> letra pequeña </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pkatt </font></font></td><td width="5">  2 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> localityid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID de comunidad </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> localityid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entero </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pkatt </font></font></td><td width="5">  3 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> streetid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID calle del pueblo </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> streetid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> letra pequeña </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fk01 </font></font></td><td width="5">  1 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fk_street_locality </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clave externa de tabla </font></font></td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fk01att </font></font></td><td width="5">  1 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wcrccode </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Código de país </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wcrccode </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> letra pequeña </font></font></td><td width="5">  t </td></tr><tr><td width="5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fk01att </font></font></td><td width="5">  2 </td><td width="15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> localityid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ID de comunidad </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> localityid </font></font></td><td width="20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entero </font></font></td><td width="5">  t </td></tr><tr><td width="5"> fk01rtbl </td><td width="5">  0 0 </td><td width="15"> locality </td><td width="20">    </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> fk01ratt </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5">  t </td></tr><tr><td width="5"> fk01ratt </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5">  t </td></tr><tr><td width="5"> fk02 </td><td width="5">  2 </td><td width="15"> fk_street_streettype </td><td width="20">    </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> fk02att </td><td width="5">  1 </td><td width="15"> streettypeacrm </td><td width="20">    </td><td width="20"> streettypeacrm </td><td width="20"> character(8) </td><td width="5">  f </td></tr><tr><td width="5"> fk02rtbl </td><td width="5">  0 0 </td><td width="15"> streettype </td><td width="20">    </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> fk02ratt </td><td width="5">  1 </td><td width="15"> streettypeacrm </td><td width="20">    </td><td width="20"> streettypeacrm </td><td width="20"> character(8) </td><td width="5">  t </td></tr><tr><td width="5"> idx01 </td><td width="5">  1 </td><td width="15"> xie1street </td><td width="20">         </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx01att </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5">  t </td></tr><tr><td width="5"> idx01att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5">  t </td></tr><tr><td width="5"> idx01att </td><td width="5">  3 </td><td width="15"> streettypeacrm </td><td width="20">    </td><td width="20"> streettypeacrm </td><td width="20"> character(8) </td><td width="5">  f </td></tr><tr><td width="5"> idx01att </td><td width="5">  4 4 </td><td width="15"> streetname </td><td width="20">     </td><td width="20"></td><td width="20"> varchar(150) </td><td width="5">  t </td></tr><tr><td width="5"> idx02 </td><td width="5">  2 </td><td width="15"> xie2street </td><td width="20">       </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx02att </td><td width="5">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallin </td><td width="5">  t </td></tr><tr><td width="5"> idx02att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5">  t </td></tr><tr><td width="5"> idx02att </td><td width="5">  3 </td><td width="15"> streetname </td><td width="20">     </td><td width="20"></td><td width="20"> varchar(150) </td><td width="5">  t </td></tr><tr><td width="5"> idx03 </td><td width="5">  3 </td><td width="15"> xie3street </td><td width="20">        </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx03att </td><td width="5">  1 </td><td width="15"> streetname </td><td width="20">     </td><td width="20"></td><td width="20"> varchar(150) </td><td width="5">  t </td></tr><tr><td width="5"> idx04 </td><td width="5">  4 4 </td><td width="15"> xpkstreet </td><td width="20">   ( )  street </td><td width="20"></td><td width="20"></td><td width="5"></td></tr><tr><td width="5"> idx04att </td><td width="15">  1 </td><td width="15"> wcrccode </td><td width="20">   </td><td width="20"> wcrccode </td><td width="20"> smallint </td><td width="5">  t </td></tr><tr><td width="5"> idx04att </td><td width="5">  2 </td><td width="15"> localityid </td><td width="20">    </td><td width="20"> localityid </td><td width="20"> integer </td><td width="5">  t </td></tr><tr><td width="5"> idx04att </td><td width="5">  3 </td><td width="15"> streetid </td><td width="20">     </td><td width="20"> streetid </td><td width="20"> smallint </td><td width="5">  t </td></tr></tbody></table><br></div></div><br><h3>  Ver también </h3><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones para documentar bases de datos PostgreSQL.</a></b> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones para documentar bases de datos PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte</a></b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones para documentar bases de datos PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El final (parte cuatro)</a> .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es415575/">https://habr.com/ru/post/es415575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es415565/index.html">Por qué (hoy) el retorno 444 no siempre es útil</a></li>
<li><a href="../es415567/index.html">Transmita video h264 sin transcodificar desde una cámara Logitech C920</a></li>
<li><a href="../es415569/index.html">CÓMO configurar ubuntu 18.04 sendmail + DKIM + SPF + DMARC o cómo logré ingresar al bastión de Gmail</a></li>
<li><a href="../es415571/index.html">kaggle: identificación del modelo de cámara de IEEE</a></li>
<li><a href="../es415573/index.html">Optimización de un modelo para impresión 3D usando el software Blender como ejemplo</a></li>
<li><a href="../es415577/index.html">Diapositivas del curso "DBMS Technologies and Development"</a></li>
<li><a href="../es415579/index.html">Aprende OpenGL. Lección 5.5 - Mapeo normal</a></li>
<li><a href="../es415581/index.html">International fintech - digest: 12 noticias sobre lo más importante en la industria</a></li>
<li><a href="../es415587/index.html">StereoPi: nuestra pieza de hardware para estudiar visión artificial, drones y robots</a></li>
<li><a href="../es415589/index.html">"Un poco más sobre DP": las compañías de televisión estadounidenses dejarán de vender geodatos de clientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>