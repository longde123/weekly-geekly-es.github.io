<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé® üéØ üê¨ Copier la s√©mantique et la gestion des ressources en C ++ üé™ üë©üèΩ‚Äçüé§ üíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++, le programmeur doit d√©cider comment les ressources utilis√©es seront lib√©r√©es; il n'y a pas d'outils automatiques comme le garbage collector. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Copier la s√©mantique et la gestion des ressources en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>En C ++, le programmeur doit d√©cider comment les ressources utilis√©es seront lib√©r√©es; il n'y a pas d'outils automatiques comme le garbage collector.</i>  <i>L'article discute des solutions possibles √† ce probl√®me, examine en d√©tail les probl√®mes potentiels, ainsi qu'un certain nombre de probl√®mes connexes.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Table des mati√®res </h1><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©sentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Strat√©gies de base de propri√©t√© de copie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Strat√©gie d'interdiction de copie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Strat√©gie de propri√©t√© exclusive</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Strat√©gie de copie approfondie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Strat√©gie de copropri√©t√©</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Strat√©gie Deep Copy - Probl√®mes et solutions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Copie sur dossier</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©finition d'une fonction d'√©change d'√©tat pour une classe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suppression des copies interm√©diaires par le compilateur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation de la s√©mantique du d√©placement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">H√©bergement vs</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">insertion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©sum√©</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Options pour la mise en ≈ìuvre d'une strat√©gie de propri√©t√© partag√©e</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Strat√©gie de propri√©t√© exclusive et s√©mantique du mouvement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Strat√©gie d'interdiction de copie - D√©marrage rapide</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Le cycle de vie de la ressource et de l'objet propri√©taire de la ressource</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Capture des ressources lors de l'initialisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Options avanc√©es de gestion du cycle de vie des ressources</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cycle de vie des ressources √©tendu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Capture d'une ressource unique</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Indirection accrue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Copropri√©t√©</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. R√©sum√©</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les applications</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Annexe A. Liens Rvalue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Annexe B. S√©mantique du d√©placement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les r√©f√©rences</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Pr√©sentation </h1><br><p> La gestion des ressources est quelque chose qu'un programmeur C ++ doit faire tout le temps.  Les ressources incluent les blocs de m√©moire, les objets du noyau du syst√®me d'exploitation, les verrous multithread, les connexions r√©seau, les connexions de base de donn√©es et tout autre objet cr√©√© dans la m√©moire dynamique.  L'acc√®s √† la ressource se fait par un descripteur, le type du descripteur est g√©n√©ralement un pointeur ou l'un de ses alias ( <code>HANDLE</code> , etc.), parfois le tout (descripteurs de fichiers UNIX).  Apr√®s avoir utilis√© la ressource, vous devez la lib√©rer, sinon t√¥t ou tard une application qui ne lib√®re pas de ressources (et √©ventuellement d'autres applications) manquera de ressources.  Ce probl√®me est tr√®s aigu, nous pouvons dire que l'une des principales caract√©ristiques du .NET, de Java et de plusieurs autres plates-formes est un syst√®me de gestion des ressources unifi√© bas√© sur le garbage collection. </p><br><p>  Les fonctionnalit√©s orient√©es objet de C ++ conduisent naturellement √† la solution suivante: la classe qui g√®re la ressource contient le descripteur de ressource en tant que membre, initialise le descripteur lorsque la ressource est captur√©e et lib√®re la ressource dans le destructeur.  Mais apr√®s une certaine r√©flexion (ou exp√©rience) vient la compr√©hension que ce n'est pas si simple.  Et le probl√®me principal est la s√©mantique de la copie.  Si la classe qui g√®re la ressource utilise le constructeur de copie g√©n√©r√© par le compilateur par d√©faut, alors apr√®s avoir copi√© l'objet, nous obtiendrons deux copies du handle de la m√™me ressource.  Si un objet lib√®re une ressource, le second pourra ensuite essayer d'utiliser ou de lib√©rer la ressource d√©j√† lib√©r√©e, ce qui est en tout cas incorrect et peut conduire au comportement dit non d√©fini, c'est-√†-dire que tout peut arriver, par exemple, une interruption anormale du programme. </p><br><p>  Heureusement, en C ++, un programmeur peut contr√¥ler enti√®rement le processus de copie en d√©finissant lui-m√™me un constructeur de copie et un op√©rateur d'affectation de copie, ce qui nous permet de r√©soudre le probl√®me ci-dessus, et g√©n√©ralement de plusieurs mani√®res.  La mise en ≈ìuvre de la copie doit √™tre √©troitement li√©e au m√©canisme de lib√©ration de la ressource, et nous l'appellerons collectivement la strat√©gie de propri√©t√© de la copie.  La soi-disant ¬´r√®gle des trois grands¬ª est bien connue, qui stipule que si un programmeur d√©finit au moins une des trois op√©rations - constructeur de copie, op√©rateur d'affectation de copie ou destructeur - alors il doit d√©finir les trois op√©rations.  Les strat√©gies de propri√©t√© de copie sp√©cifient simplement comment proc√©der.  Il existe quatre strat√©gies de base de propri√©t√© de la copie. </p><br><a name="id-1"></a><br><h1>  1. Strat√©gies de base de propri√©t√© de copie </h1><br><p>  Avant la capture de la ressource ou apr√®s sa lib√©ration, le descripteur doit prendre une valeur sp√©ciale indiquant qu'il n'est pas associ√© √† la ressource.  Il s'agit g√©n√©ralement de z√©ro, parfois -1, converti en un type de descripteur.  Dans tous les cas, un tel descripteur sera appel√© z√©ro.  La classe qui g√®re la ressource doit reconna√Ætre le descripteur nul et ne pas essayer d'utiliser ou de lib√©rer la ressource dans ce cas. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Strat√©gie d'interdiction de copie </h2><br><p>  C'est la strat√©gie la plus simple.  Dans ce cas, il est simplement interdit de copier et d'assigner des instances de classe.  Le destructeur lib√®re la ressource captur√©e.  En C ++, pour interdire la copie n'est pas difficile, la classe doit d√©clarer, mais pas d√©finir, le constructeur de copie ferm√©e et l'op√©rateur d'affectation de copie. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Les tentatives de copie sont contrecarr√©es par le compilateur et l'√©diteur de liens. </p><br><p>  Le standard C ++ 11 propose une syntaxe sp√©ciale pour ce cas: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Cette syntaxe est plus visuelle et donne des messages plus compr√©hensibles au compilateur lors de la tentative de copie. </p><br><p>  Dans la version pr√©c√©dente de la biblioth√®que standard (C ++ 98), les classes de flux d'entr√©e / sortie ( <code>std::fstream</code> , etc.) utilisaient la strat√©gie d'interdiction de copie, et sous Windows, de nombreuses classes de MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.).  Dans la biblioth√®que standard C ++ 11, certaines classes utilisent cette strat√©gie pour prendre en charge la synchronisation multi-thread. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Strat√©gie de propri√©t√© exclusive </h2><br><p>  Dans ce cas, lors de l'impl√©mentation de la copie et de l'affectation, le descripteur de ressource se d√©place de l'objet source vers l'objet cible, c'est-√†-dire qu'il reste dans une seule copie.  Apr√®s la copie ou l'affectation, l'objet source a un descripteur nul et ne peut pas utiliser la ressource.  Le destructeur lib√®re la ressource captur√©e.  Les termes propri√©t√© exclusive ou stricte [Josuttis] sont √©galement utilis√©s pour cette strat√©gie; Andrei Alexandrescu utilise le terme copie destructrice.  En C ++ 11, cela se fait comme suit: la copie r√©guli√®re et l'affectation de copie sont interdites de la mani√®re d√©crite ci-dessus, et la s√©mantique des mouvements est impl√©ment√©e, c'est-√†-dire que le constructeur de d√©placement et l'op√©rateur d'affectation de d√©placement sont d√©finis.  (Plus d'informations sur la s√©mantique du mouvement plus tard.) </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Ainsi, la strat√©gie de propri√©t√© exclusive peut √™tre consid√©r√©e comme une extension de la strat√©gie d'interdiction de copie. </p><br><p>  Dans la biblioth√®que standard C ++ 11, cette strat√©gie utilise le pointeur intelligent <code>std::unique_ptr&lt;&gt;</code> et certaines autres classes, par exemple: <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , ainsi que les classes qui utilisaient auparavant la strat√©gie d'interdiction de copie ( <code>std::fstream</code> , etc.).  Sous Windows, les classes MFC qui utilisaient auparavant la strat√©gie d'interdiction de copie ont √©galement commenc√© √† utiliser la strat√©gie de propri√©t√© exclusive ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Strat√©gie de copie approfondie </h2><br><p>  Dans ce cas, vous pouvez copier et affecter des instances de classe.  Il est n√©cessaire de d√©finir le constructeur de copie et l'op√©rateur d'affectation de copie, de sorte que l'objet cible copie la ressource sur lui-m√™me √† partir de l'objet source.  Apr√®s cela, chaque objet poss√®de sa copie de la ressource, peut ind√©pendamment utiliser, modifier et lib√©rer la ressource.  Le destructeur lib√®re la ressource captur√©e.  Parfois, pour les objets qui utilisent la strat√©gie de copie approfondie, le terme objets de valeur est utilis√©. </p><br><p>  Cette strat√©gie ne s'applique pas √† toutes les ressources.  Il peut √™tre appliqu√© √† des ressources associ√©es √† un tampon de m√©moire, telles que des cha√Ænes, mais il n'est pas tr√®s clair comment l'appliquer √† des objets du noyau du syst√®me d'exploitation tels que des fichiers, des mutex, etc. </p><br><p>  La strat√©gie de copie profonde est utilis√©e dans tous les types de cha√Ænes d'objets, <code>std::vector&lt;&gt;</code> et d'autres conteneurs de la biblioth√®que standard. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Strat√©gie de copropri√©t√© </h2><br><p>  Dans ce cas, vous pouvez copier et affecter des instances de classe.  Vous devez d√©finir le constructeur de copie et l'op√©rateur d'affectation de copie dans lesquels le descripteur de ressource (ainsi que d'autres donn√©es) est copi√©, mais pas la ressource elle-m√™me.  Apr√®s cela, chaque objet a sa propre copie du descripteur, peut utiliser, modifier, mais ne peut pas lib√©rer la ressource, tant qu'il y a au moins un objet suppl√©mentaire qui poss√®de une copie du descripteur.  Une ressource est lib√©r√©e une fois que le dernier objet qui poss√®de une copie du descripteur est hors de port√©e.  Comment cela peut √™tre mis en ≈ìuvre est d√©crit ci-dessous. </p><br><p>  Les strat√©gies de copropri√©t√© sont souvent utilis√©es par les pointeurs intelligents, et il est √©galement naturel de les utiliser pour des ressources immuables.  Le pointeur intelligent <code>std::shared_ptr&lt;&gt;</code> impl√©mente cette strat√©gie dans la biblioth√®que standard C ++ 11. </p><br><a name="id-2"></a><br><h1>  2. Strat√©gie Deep Copy - Probl√®mes et solutions </h1><br><p>  Consid√©rons un mod√®le pour la fonction d'√©change d'√©tats d'objets de type <code>T</code> dans la biblioth√®que standard C ++ 98. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Si le type <code>T</code> poss√®de une ressource et utilise une strat√©gie de copie approfondie, nous avons trois op√©rations pour allouer une nouvelle ressource, trois op√©rations de copie et trois op√©rations pour lib√©rer des ressources.  Alors que dans la plupart des cas, cette op√©ration peut √™tre effectu√©e sans allouer de nouvelles ressources et sans copier du tout, il suffit que les objets √©changent des donn√©es internes, y compris un descripteur de ressource.  Il existe de nombreux exemples similaires lorsque vous devez cr√©er des copies temporaires d'une ressource et les lib√©rer imm√©diatement.  Une telle mise en ≈ìuvre inefficace des op√©rations quotidiennes a stimul√© la recherche de solutions pour leur optimisation.  Examinons les principales options. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Copie sur dossier </h2><br><p>  La copie sur √©criture (COW), √©galement appel√©e copie diff√©r√©e, peut √™tre consid√©r√©e comme une tentative de combiner une strat√©gie de copie approfondie et une strat√©gie de propri√©t√© partag√©e.  Initialement, lors de la copie d'un objet, le descripteur de ressource est copi√© sans la ressource elle-m√™me, et pour les propri√©taires, la ressource devient partag√©e et en lecture seule, mais d√®s qu'un propri√©taire doit modifier la ressource partag√©e, la ressource est copi√©e, puis ce propri√©taire travaille avec son une copie.  L'impl√©mentation de COW r√©sout le probl√®me de l'√©change d'√©tats: il n'y a pas d'allocation suppl√©mentaire de ressources et de copie.  L'utilisation de COW est tr√®s populaire lors de l'impl√©mentation de cha√Ænes; par exemple, <code>CString</code> (MFC, ATL).  Une discussion sur les moyens possibles de mettre en ≈ìuvre la GC et les probl√®mes √©mergents peut √™tre trouv√©e dans [Meyers1], [Sutter].  [Guntheroth] a propos√© une impl√©mentation COW en utilisant <code>std::shared_ptr&lt;&gt;</code> .  Il y a des probl√®mes lors de l'impl√©mentation de COW dans un environnement multi-thread, c'est pourquoi il est interdit d'utiliser COW pour les cha√Ænes dans la biblioth√®que C ++ 11 standard, voir [Josuttis], [Guntheroth]. </p><br><p>  Le d√©veloppement de l'id√©e COW conduit au sch√©ma de gestion des ressources suivant: la ressource est immuable et g√©r√©e par des objets en utilisant la strat√©gie de propri√©t√© partag√©e, si n√©cessaire, pour changer la ressource, une nouvelle ressource modifi√©e de mani√®re appropri√©e est cr√©√©e et un nouvel objet propri√©taire est renvoy√©.  Ce sch√©ma est utilis√© pour les cha√Ænes et autres objets immuables sur les plates-formes .NET et Java.  En programmation fonctionnelle, il est utilis√© pour des structures de donn√©es plus complexes. </p><br><a name="id-2-2"></a><br><h2>  2.2.  D√©finition d'une fonction d'√©change d'√©tat pour une classe </h2><br><p>  Il a √©t√© d√©montr√© ci-dessus √† quel point la fonction d'√©change d'√©tat peut √™tre inefficace, mise en ≈ìuvre de mani√®re simple, par copie et affectation.  Et il est utilis√© assez largement, par exemple, il est utilis√© par de nombreux algorithmes de la biblioth√®que standard.  Pour que les algorithmes n'utilisent pas un autre <code>std::swap()</code> , mais une autre fonction sp√©cifiquement d√©finie pour la classe, deux √©tapes doivent √™tre effectu√©es. </p><br><p>  1. D√©finissez dans la classe une fonction membre <code>Swap()</code> (le nom n'est pas important) qui impl√©mente l'√©change d'√©tats. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Vous devez vous assurer que cette fonction ne <code>noexcept</code> pas d'exceptions; en C ++ 11, ces fonctions doivent √™tre d√©clar√©es comme <code>noexcept</code> . </p><br><p>  2. Dans le m√™me espace de noms que la classe <code>X</code> (g√©n√©ralement dans le m√™me fichier d'en-t√™te), d√©finissez la fonction <code>swap()</code> libre (non membre) comme suit (le nom et la signature sont fondamentaux): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Apr√®s cela, les algorithmes de la biblioth√®que standard l'utiliseront, pas <code>std::swap()</code> .  Cela fournit un m√©canisme appel√© recherche d√©pendante des arguments (ADL).  Pour plus d'informations sur ADL, voir [Dewhurst1]. </p><br><p>  Dans la biblioth√®que standard C ++, tous les conteneurs, pointeurs intelligents et autres classes impl√©mentent la fonction d'√©change d'√©tat comme d√©crit ci-dessus. </p><br><p>  La fonction membre <code>Swap()</code> est g√©n√©ralement facilement d√©finie: il est n√©cessaire d'appliquer s√©quentiellement une op√©ration d'√©change d'√©tat aux bases de donn√©es et aux membres, s'ils le prennent en charge, et <code>std::swap()</code> sinon. </p><br><p>  La description ci-dessus est quelque peu simplifi√©e, une description plus d√©taill√©e peut √™tre trouv√©e dans [Meyers2].  Une discussion des questions li√©es √† la fonction d'√©change d'√âtat peut √©galement √™tre trouv√©e dans [Sutter / Alexandrescu]. </p><br><p>  La fonction d'√©change d'√©tat peut √™tre attribu√©e √† l'une des op√©rations de base de la classe.  En l'utilisant, vous pouvez d√©finir gracieusement d'autres op√©rations.  Par exemple, l'op√©rateur d'affectation de copie est d√©fini via copy et <code>Swap()</code> comme suit: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Ce mod√®le est appel√© l'idiome de copie et d'√©change ou l'idiome Herb Sutter, pour plus de d√©tails, voir [Sutter], [Sutter / Alexandrescu], [Meyers2].  Sa modification peut √™tre appliqu√©e pour impl√©menter la s√©mantique du d√©placement, voir les sections 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Suppression des copies interm√©diaires par le compilateur </h2><br><p>  Consid√©rez la classe </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Et fonction </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Avec une approche simple, le retour de la fonction <code>Foo()</code> est r√©alis√© en copiant l'instance de <code>X</code>  Mais les compilateurs sont capables de supprimer l'op√©ration de copie du code, l'objet est cr√©√© directement au point d'appel.  C'est ce qu'on appelle l'optimisation de la valeur de retour (RVO).  RVO est utilis√© par les d√©veloppeurs de compilateurs depuis un certain temps et est actuellement corrig√© dans la norme C ++ 11.  Bien que la d√©cision sur RVO soit prise par le compilateur, le programmeur peut √©crire du code en fonction de son utilisation.  Pour ce faire, il est souhaitable que la fonction ait un point de retour et que le type de l'expression retourn√©e corresponde au type de la valeur de retour de la fonction.  Dans certains cas, il est conseill√© de d√©finir un constructeur ferm√© sp√©cial appel√© ¬´constructeur de calcul¬ª, pour plus de d√©tails, voir [Dewhurst2].  Le RVO est √©galement discut√© dans [Meyers3] et [Guntheroth]. </p><br><p>  Les compilateurs peuvent supprimer des copies interm√©diaires dans d'autres situations. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Impl√©mentation de la s√©mantique du d√©placement </h2><br><p>  L'impl√©mentation de la s√©mantique de d√©placement consiste √† d√©finir un constructeur de d√©placement qui a un param√®tre de type rvalue-r√©f√©rence √† la source et un op√©rateur d'affectation de d√©placement avec le m√™me param√®tre. </p><br><p>  Dans la biblioth√®que standard C ++ 11, le mod√®le de fonction d'√©change d'√©tat est d√©fini comme suit: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  Conform√©ment aux r√®gles de r√©solution des surcharges de fonctions ayant des param√®tres de type rvalue-reference (voir Annexe A), dans le cas o√π le type <code>T</code> a un constructeur mobile et un op√©rateur d'affectation mobile, ils seront utilis√©s, et il n'y aura pas d'allocation de ressources temporaires et de copie.  Sinon, le constructeur de copie et l'op√©rateur d'affectation de copie seront utilis√©s. </p><br><p>  L'utilisation de la s√©mantique de la d√©localisation √©vite de cr√©er des copies temporaires dans un contexte beaucoup plus large que la fonction d'√©change d'√©tat d√©crite ci-dessus.  La s√©mantique de mouvement s'applique √† toute valeur rvalue, c'est-√†-dire une valeur temporaire sans nom, ainsi qu'√† la valeur de retour d'une fonction si elle a √©t√© cr√©√©e localement (y compris une lvalue), et RVO n'a pas √©t√© appliqu√©.  Dans tous ces cas, il est garanti que l'objet source ne peut en aucun cas √™tre utilis√© apr√®s le d√©placement.  La s√©mantique de d√©placement s'applique √©galement √† la valeur lvalue √† laquelle la transformation <code>std::move()</code> est appliqu√©e.  Mais dans ce cas, le programmeur est responsable de la fa√ßon dont les objets source seront utilis√©s apr√®s le d√©placement (exemple <code>std::swap()</code> ). </p><br><p>  La biblioth√®que standard C ++ 11 a √©t√© repens√©e en tenant compte de la s√©mantique du mouvement.  De nombreuses classes ont ajout√© un constructeur de d√©placement et un op√©rateur d'affectation de d√©placement, ainsi que d'autres fonctions membres, avec des param√®tres de type r√©f√©rence rvalue.  Par exemple, <code>std::vector&lt;T&gt;</code> a une version surcharg√©e de <code>void push_back(T&amp;&amp; src)</code> .  Tout cela permet dans de nombreux cas d'√©viter de cr√©er des copies temporaires. </p><br><p>  L'impl√©mentation de la s√©mantique de d√©placement n'annule pas les d√©finitions de la fonction d'√©change d'√©tat pour une classe.  Une fonction d'√©change d'√©tat sp√©cialement d√©finie peut √™tre plus efficace que la norme <code>std::swap()</code> .  De plus, le constructeur de d√©placement et l'op√©rateur d'affectation de d√©placement sont tr√®s facilement d√©finis √† l'aide de la fonction membre de l'√©change d'√©tats comme suit (variation de l'idiome de copie et d'√©change): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  Le constructeur de d√©placement et l'op√©rateur d'affectation de d√©placement sont les fonctions membres pour lesquelles il est hautement souhaitable de s'assurer qu'ils ne <code>noexcept</code> pas d'exceptions et sont par cons√©quent d√©clar√©s comme <code>noexcept</code> .  Cela vous permet d'optimiser certaines op√©rations des conteneurs de biblioth√®que standard sans violer la stricte garantie de s√©curit√© des exceptions, voir [Meyers3] et [Guntheroth] pour plus de d√©tails.  Le mod√®le propos√© offre une telle garantie, √† condition que le constructeur par d√©faut et la fonction membre de l'√©change d'√©tats ne l√®vent pas d'exceptions. </p><br><p>  La norme C ++ 11 pr√©voit que le compilateur g√©n√®re automatiquement un constructeur mobile et un op√©rateur d'affectation mobile. Pour ce faire, ils doivent √™tre d√©clar√©s √† l'aide de la construction <code>"=default"</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Les op√©rations sont impl√©ment√©es en appliquant s√©quentiellement l'op√©ration de d√©placement aux bases et aux membres de la classe, s'ils prennent en charge le d√©placement, et en copiant les op√©rations dans le cas contraire.  Il est clair que cette option est loin d'√™tre toujours acceptable.  Les descripteurs bruts ne se d√©placent pas, mais vous ne pouvez g√©n√©ralement pas les copier.  Dans certaines conditions, le compilateur peut g√©n√©rer ind√©pendamment un constructeur mobile et un op√©rateur d'affectation mobile similaires, mais il est pr√©f√©rable de ne pas utiliser cette opportunit√©, ces conditions sont plut√¥t d√©routantes et peuvent facilement changer lorsque la classe est affin√©e.  Voir [Meyers3] pour plus de d√©tails. </p><br><p>  En g√©n√©ral, la mise en ≈ìuvre et l'utilisation de la s√©mantique du d√©placement est une ¬´chose subtile¬ª.  Le compilateur peut appliquer la copie l√† o√π le programmeur attend un d√©placement.  Voici quelques r√®gles pour √©liminer ou au moins r√©duire la probabilit√© d'une telle situation. </p><br><ol><li>  Si possible, utilisez l'interdiction de copie. </li><li>  D√©clarez le constructeur de d√©placement et l'op√©rateur d'affectation de d√©placement en tant que <code>noexcept</code> . </li><li>  Impl√©mentez la s√©mantique des mouvements pour les classes de base et les membres. </li><li>  Appliquez la transformation <code>std::move()</code> aux param√®tres des fonctions de type r√©f√©rence rvalue. </li></ol><br><p>  La r√®gle 2 a √©t√© discut√©e ci-dessus.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      ‚Äî   (variadic templates),         .  ,      C++11 ‚Äî     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6.  R√©sum√© </h2><br><p>     ,    ,     .               -  .                   .   ‚Äî     :    ,    .     ,       ,     ,  .      :     ,     ,  ¬´¬ª   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    ‚Äî   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    ‚Äî   .     6. </p><br><p>   ,     -  -,  ¬´  ¬ª,   -     .         -    . ,   ,     ,     ,    -       .      ¬´¬ª. </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2>  6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          ¬´   ¬ª (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      ¬´¬ª RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2>  6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     ¬´  ¬ª,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  ¬´¬ª RAII,   ‚Äî          .      ,     ,    . 3.       .    ¬´¬ª,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        ‚Äî    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Les applications </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- ‚Äî      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         ‚Äî    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Les r√©f√©rences </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  de l'anglais  - M.: LLC ¬´I.D. ¬ª, 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  de l'anglais ‚Äî .:  ¬´-¬ª, 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  de l'anglais  - M.: LLC ¬´I.D. ¬ª, 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  de l'anglais ‚Äî .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  de l'anglais ‚Äî .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  de l'anglais ‚Äî .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  de l'anglais ‚Äî .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  de l'anglais  - M.: LLC ¬´I.D. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  de l'anglais ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  de l'anglais  - M.: LLC ¬´I.D. ¬ª, 2015. </p><br><p> [Schildt] <br> , .    C++.: .  de l'anglais ‚Äî .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  de l'anglais ‚Äî .:  ¬´ ¬´¬ª, 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425837/">https://habr.com/ru/post/fr425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425827/index.html">Le√ßon Google+: les projets doivent s'assurer que les fronti√®res entre les int√©r√™ts des utilisateurs dans la vie r√©elle sont respect√©es en ligne</a></li>
<li><a href="../fr425829/index.html">Comment nous nous sommes battus avec Roskomnadzor et ce qu'il en est advenu</a></li>
<li><a href="../fr425831/index.html">Alerte RKN - Base de donn√©es Roskomnadzor dans votre navigateur</a></li>
<li><a href="../fr425833/index.html">Un outil pour vous aider √† choisir les meilleures id√©es pour votre produit.</a></li>
<li><a href="../fr425835/index.html">¬´Breaking Bugs¬ª dans Sberbank: comment corriger le taux de bogues sur sept jours par jour</a></li>
<li><a href="../fr425839/index.html">Examen de la conf√©rence Atlassian</a></li>
<li><a href="../fr425843/index.html">Python pour l'enfant: choisir un tutoriel</a></li>
<li><a href="../fr425845/index.html">Applications de verrouillage automatique sur Google Play</a></li>
<li><a href="../fr425847/index.html">Un exemple d'utilisation de Microsoft Flow ou Comment donner des fleurs √† votre femme</a></li>
<li><a href="../fr425849/index.html">Amazon a renonc√© et a augment√© les salaires des employ√©s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>