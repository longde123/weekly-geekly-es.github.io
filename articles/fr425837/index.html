<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 🎯 🐬 Copier la sémantique et la gestion des ressources en C ++ 🎪 👩🏽‍🎤 💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En C ++, le programmeur doit décider comment les ressources utilisées seront libérées; il n'y a pas d'outils automatiques comme le garbage collector. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Copier la sémantique et la gestion des ressources en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425837/"><hr><p>  <i>En C ++, le programmeur doit décider comment les ressources utilisées seront libérées; il n'y a pas d'outils automatiques comme le garbage collector.</i>  <i>L'article discute des solutions possibles à ce problème, examine en détail les problèmes potentiels, ainsi qu'un certain nombre de problèmes connexes.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Table des matières </h1><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Présentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. Stratégies de base de propriété de copie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stratégie d'interdiction de copie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stratégie de propriété exclusive</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stratégie de copie approfondie</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stratégie de copropriété</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Stratégie Deep Copy - Problèmes et solutions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Copie sur dossier</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Définition d'une fonction d'échange d'état pour une classe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suppression des copies intermédiaires par le compilateur</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Implémentation de la sémantique du déplacement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hébergement vs</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">insertion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Résumé</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Options pour la mise en œuvre d'une stratégie de propriété partagée</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Stratégie de propriété exclusive et sémantique du mouvement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Stratégie d'interdiction de copie - Démarrage rapide</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Le cycle de vie de la ressource et de l'objet propriétaire de la ressource</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Capture des ressources lors de l'initialisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Options avancées de gestion du cycle de vie des ressources</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cycle de vie des ressources étendu</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Capture d'une ressource unique</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Indirection accrue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Copropriété</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Résumé</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les applications</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Annexe A. Liens Rvalue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Annexe B. Sémantique du déplacement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les références</a> <br></p><br></div></div><br><a name="id-introdaction"></a><br><h1>  Présentation </h1><br><p> La gestion des ressources est quelque chose qu'un programmeur C ++ doit faire tout le temps.  Les ressources incluent les blocs de mémoire, les objets du noyau du système d'exploitation, les verrous multithread, les connexions réseau, les connexions de base de données et tout autre objet créé dans la mémoire dynamique.  L'accès à la ressource se fait par un descripteur, le type du descripteur est généralement un pointeur ou l'un de ses alias ( <code>HANDLE</code> , etc.), parfois le tout (descripteurs de fichiers UNIX).  Après avoir utilisé la ressource, vous devez la libérer, sinon tôt ou tard une application qui ne libère pas de ressources (et éventuellement d'autres applications) manquera de ressources.  Ce problème est très aigu, nous pouvons dire que l'une des principales caractéristiques du .NET, de Java et de plusieurs autres plates-formes est un système de gestion des ressources unifié basé sur le garbage collection. </p><br><p>  Les fonctionnalités orientées objet de C ++ conduisent naturellement à la solution suivante: la classe qui gère la ressource contient le descripteur de ressource en tant que membre, initialise le descripteur lorsque la ressource est capturée et libère la ressource dans le destructeur.  Mais après une certaine réflexion (ou expérience) vient la compréhension que ce n'est pas si simple.  Et le problème principal est la sémantique de la copie.  Si la classe qui gère la ressource utilise le constructeur de copie généré par le compilateur par défaut, alors après avoir copié l'objet, nous obtiendrons deux copies du handle de la même ressource.  Si un objet libère une ressource, le second pourra ensuite essayer d'utiliser ou de libérer la ressource déjà libérée, ce qui est en tout cas incorrect et peut conduire au comportement dit non défini, c'est-à-dire que tout peut arriver, par exemple, une interruption anormale du programme. </p><br><p>  Heureusement, en C ++, un programmeur peut contrôler entièrement le processus de copie en définissant lui-même un constructeur de copie et un opérateur d'affectation de copie, ce qui nous permet de résoudre le problème ci-dessus, et généralement de plusieurs manières.  La mise en œuvre de la copie doit être étroitement liée au mécanisme de libération de la ressource, et nous l'appellerons collectivement la stratégie de propriété de la copie.  La soi-disant «règle des trois grands» est bien connue, qui stipule que si un programmeur définit au moins une des trois opérations - constructeur de copie, opérateur d'affectation de copie ou destructeur - alors il doit définir les trois opérations.  Les stratégies de propriété de copie spécifient simplement comment procéder.  Il existe quatre stratégies de base de propriété de la copie. </p><br><a name="id-1"></a><br><h1>  1. Stratégies de base de propriété de copie </h1><br><p>  Avant la capture de la ressource ou après sa libération, le descripteur doit prendre une valeur spéciale indiquant qu'il n'est pas associé à la ressource.  Il s'agit généralement de zéro, parfois -1, converti en un type de descripteur.  Dans tous les cas, un tel descripteur sera appelé zéro.  La classe qui gère la ressource doit reconnaître le descripteur nul et ne pas essayer d'utiliser ou de libérer la ressource dans ce cas. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Stratégie d'interdiction de copie </h2><br><p>  C'est la stratégie la plus simple.  Dans ce cas, il est simplement interdit de copier et d'assigner des instances de classe.  Le destructeur libère la ressource capturée.  En C ++, pour interdire la copie n'est pas difficile, la classe doit déclarer, mais pas définir, le constructeur de copie fermée et l'opérateur d'affectation de copie. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;);    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Les tentatives de copie sont contrecarrées par le compilateur et l'éditeur de liens. </p><br><p>  Le standard C ++ 11 propose une syntaxe spéciale pour ce cas: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Cette syntaxe est plus visuelle et donne des messages plus compréhensibles au compilateur lors de la tentative de copie. </p><br><p>  Dans la version précédente de la bibliothèque standard (C ++ 98), les classes de flux d'entrée / sortie ( <code>std::fstream</code> , etc.) utilisaient la stratégie d'interdiction de copie, et sous Windows, de nombreuses classes de MFC ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.).  Dans la bibliothèque standard C ++ 11, certaines classes utilisent cette stratégie pour prendre en charge la synchronisation multi-thread. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Stratégie de propriété exclusive </h2><br><p>  Dans ce cas, lors de l'implémentation de la copie et de l'affectation, le descripteur de ressource se déplace de l'objet source vers l'objet cible, c'est-à-dire qu'il reste dans une seule copie.  Après la copie ou l'affectation, l'objet source a un descripteur nul et ne peut pas utiliser la ressource.  Le destructeur libère la ressource capturée.  Les termes propriété exclusive ou stricte [Josuttis] sont également utilisés pour cette stratégie; Andrei Alexandrescu utilise le terme copie destructrice.  En C ++ 11, cela se fait comme suit: la copie régulière et l'affectation de copie sont interdites de la manière décrite ci-dessus, et la sémantique des mouvements est implémentée, c'est-à-dire que le constructeur de déplacement et l'opérateur d'affectation de déplacement sont définis.  (Plus d'informations sur la sémantique du mouvement plus tard.) </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Ainsi, la stratégie de propriété exclusive peut être considérée comme une extension de la stratégie d'interdiction de copie. </p><br><p>  Dans la bibliothèque standard C ++ 11, cette stratégie utilise le pointeur intelligent <code>std::unique_ptr&lt;&gt;</code> et certaines autres classes, par exemple: <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , ainsi que les classes qui utilisaient auparavant la stratégie d'interdiction de copie ( <code>std::fstream</code> , etc.).  Sous Windows, les classes MFC qui utilisaient auparavant la stratégie d'interdiction de copie ont également commencé à utiliser la stratégie de propriété exclusive ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-1-3"></a><br><h2>  1.3.  Stratégie de copie approfondie </h2><br><p>  Dans ce cas, vous pouvez copier et affecter des instances de classe.  Il est nécessaire de définir le constructeur de copie et l'opérateur d'affectation de copie, de sorte que l'objet cible copie la ressource sur lui-même à partir de l'objet source.  Après cela, chaque objet possède sa copie de la ressource, peut indépendamment utiliser, modifier et libérer la ressource.  Le destructeur libère la ressource capturée.  Parfois, pour les objets qui utilisent la stratégie de copie approfondie, le terme objets de valeur est utilisé. </p><br><p>  Cette stratégie ne s'applique pas à toutes les ressources.  Il peut être appliqué à des ressources associées à un tampon de mémoire, telles que des chaînes, mais il n'est pas très clair comment l'appliquer à des objets du noyau du système d'exploitation tels que des fichiers, des mutex, etc. </p><br><p>  La stratégie de copie profonde est utilisée dans tous les types de chaînes d'objets, <code>std::vector&lt;&gt;</code> et d'autres conteneurs de la bibliothèque standard. </p><br><a name="id-1-4"></a><br><h2>  1.4.  Stratégie de copropriété </h2><br><p>  Dans ce cas, vous pouvez copier et affecter des instances de classe.  Vous devez définir le constructeur de copie et l'opérateur d'affectation de copie dans lesquels le descripteur de ressource (ainsi que d'autres données) est copié, mais pas la ressource elle-même.  Après cela, chaque objet a sa propre copie du descripteur, peut utiliser, modifier, mais ne peut pas libérer la ressource, tant qu'il y a au moins un objet supplémentaire qui possède une copie du descripteur.  Une ressource est libérée une fois que le dernier objet qui possède une copie du descripteur est hors de portée.  Comment cela peut être mis en œuvre est décrit ci-dessous. </p><br><p>  Les stratégies de copropriété sont souvent utilisées par les pointeurs intelligents, et il est également naturel de les utiliser pour des ressources immuables.  Le pointeur intelligent <code>std::shared_ptr&lt;&gt;</code> implémente cette stratégie dans la bibliothèque standard C ++ 11. </p><br><a name="id-2"></a><br><h1>  2. Stratégie Deep Copy - Problèmes et solutions </h1><br><p>  Considérons un modèle pour la fonction d'échange d'états d'objets de type <code>T</code> dans la bibliothèque standard C ++ 98. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span>;    a = b;    b = tmp; }</code> </pre> <br><p>  Si le type <code>T</code> possède une ressource et utilise une stratégie de copie approfondie, nous avons trois opérations pour allouer une nouvelle ressource, trois opérations de copie et trois opérations pour libérer des ressources.  Alors que dans la plupart des cas, cette opération peut être effectuée sans allouer de nouvelles ressources et sans copier du tout, il suffit que les objets échangent des données internes, y compris un descripteur de ressource.  Il existe de nombreux exemples similaires lorsque vous devez créer des copies temporaires d'une ressource et les libérer immédiatement.  Une telle mise en œuvre inefficace des opérations quotidiennes a stimulé la recherche de solutions pour leur optimisation.  Examinons les principales options. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Copie sur dossier </h2><br><p>  La copie sur écriture (COW), également appelée copie différée, peut être considérée comme une tentative de combiner une stratégie de copie approfondie et une stratégie de propriété partagée.  Initialement, lors de la copie d'un objet, le descripteur de ressource est copié sans la ressource elle-même, et pour les propriétaires, la ressource devient partagée et en lecture seule, mais dès qu'un propriétaire doit modifier la ressource partagée, la ressource est copiée, puis ce propriétaire travaille avec son une copie.  L'implémentation de COW résout le problème de l'échange d'états: il n'y a pas d'allocation supplémentaire de ressources et de copie.  L'utilisation de COW est très populaire lors de l'implémentation de chaînes; par exemple, <code>CString</code> (MFC, ATL).  Une discussion sur les moyens possibles de mettre en œuvre la GC et les problèmes émergents peut être trouvée dans [Meyers1], [Sutter].  [Guntheroth] a proposé une implémentation COW en utilisant <code>std::shared_ptr&lt;&gt;</code> .  Il y a des problèmes lors de l'implémentation de COW dans un environnement multi-thread, c'est pourquoi il est interdit d'utiliser COW pour les chaînes dans la bibliothèque C ++ 11 standard, voir [Josuttis], [Guntheroth]. </p><br><p>  Le développement de l'idée COW conduit au schéma de gestion des ressources suivant: la ressource est immuable et gérée par des objets en utilisant la stratégie de propriété partagée, si nécessaire, pour changer la ressource, une nouvelle ressource modifiée de manière appropriée est créée et un nouvel objet propriétaire est renvoyé.  Ce schéma est utilisé pour les chaînes et autres objets immuables sur les plates-formes .NET et Java.  En programmation fonctionnelle, il est utilisé pour des structures de données plus complexes. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Définition d'une fonction d'échange d'état pour une classe </h2><br><p>  Il a été démontré ci-dessus à quel point la fonction d'échange d'état peut être inefficace, mise en œuvre de manière simple, par copie et affectation.  Et il est utilisé assez largement, par exemple, il est utilisé par de nombreux algorithmes de la bibliothèque standard.  Pour que les algorithmes n'utilisent pas un autre <code>std::swap()</code> , mais une autre fonction spécifiquement définie pour la classe, deux étapes doivent être effectuées. </p><br><p>  1. Définissez dans la classe une fonction membre <code>Swap()</code> (le nom n'est pas important) qui implémente l'échange d'états. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Vous devez vous assurer que cette fonction ne <code>noexcept</code> pas d'exceptions; en C ++ 11, ces fonctions doivent être déclarées comme <code>noexcept</code> . </p><br><p>  2. Dans le même espace de noms que la classe <code>X</code> (généralement dans le même fichier d'en-tête), définissez la fonction <code>swap()</code> libre (non membre) comme suit (le nom et la signature sont fondamentaux): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; a, X&amp; b)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ a.Swap(b); }</code> </pre> <br><p>  Après cela, les algorithmes de la bibliothèque standard l'utiliseront, pas <code>std::swap()</code> .  Cela fournit un mécanisme appelé recherche dépendante des arguments (ADL).  Pour plus d'informations sur ADL, voir [Dewhurst1]. </p><br><p>  Dans la bibliothèque standard C ++, tous les conteneurs, pointeurs intelligents et autres classes implémentent la fonction d'échange d'état comme décrit ci-dessus. </p><br><p>  La fonction membre <code>Swap()</code> est généralement facilement définie: il est nécessaire d'appliquer séquentiellement une opération d'échange d'état aux bases de données et aux membres, s'ils le prennent en charge, et <code>std::swap()</code> sinon. </p><br><p>  La description ci-dessus est quelque peu simplifiée, une description plus détaillée peut être trouvée dans [Meyers2].  Une discussion des questions liées à la fonction d'échange d'État peut également être trouvée dans [Sutter / Alexandrescu]. </p><br><p>  La fonction d'échange d'état peut être attribuée à l'une des opérations de base de la classe.  En l'utilisant, vous pouvez définir gracieusement d'autres opérations.  Par exemple, l'opérateur d'affectation de copie est défini via copy et <code>Swap()</code> comme suit: </p><br><pre> <code class="cpp hljs">X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> X&amp; src) {    X tmp(src);    Swap(tmp);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Ce modèle est appelé l'idiome de copie et d'échange ou l'idiome Herb Sutter, pour plus de détails, voir [Sutter], [Sutter / Alexandrescu], [Meyers2].  Sa modification peut être appliquée pour implémenter la sémantique du déplacement, voir les sections 2.4, 2.6.1. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Suppression des copies intermédiaires par le compilateur </h2><br><p>  Considérez la classe </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Et fonction </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...    return X(/*  */); }</span></span></code> </pre> <br><p>  Avec une approche simple, le retour de la fonction <code>Foo()</code> est réalisé en copiant l'instance de <code>X</code>  Mais les compilateurs sont capables de supprimer l'opération de copie du code, l'objet est créé directement au point d'appel.  C'est ce qu'on appelle l'optimisation de la valeur de retour (RVO).  RVO est utilisé par les développeurs de compilateurs depuis un certain temps et est actuellement corrigé dans la norme C ++ 11.  Bien que la décision sur RVO soit prise par le compilateur, le programmeur peut écrire du code en fonction de son utilisation.  Pour ce faire, il est souhaitable que la fonction ait un point de retour et que le type de l'expression retournée corresponde au type de la valeur de retour de la fonction.  Dans certains cas, il est conseillé de définir un constructeur fermé spécial appelé «constructeur de calcul», pour plus de détails, voir [Dewhurst2].  Le RVO est également discuté dans [Meyers3] et [Guntheroth]. </p><br><p>  Les compilateurs peuvent supprimer des copies intermédiaires dans d'autres situations. </p><br><a name="id-2-4"></a><br><h2>  2.4.  Implémentation de la sémantique du déplacement </h2><br><p>  L'implémentation de la sémantique de déplacement consiste à définir un constructeur de déplacement qui a un paramètre de type rvalue-référence à la source et un opérateur d'affectation de déplacement avec le même paramètre. </p><br><p>  Dans la bibliothèque standard C ++ 11, le modèle de fonction d'échange d'état est défini comme suit: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; a, T&amp; b)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::move(a))</span></span></span></span>;    a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b);    b = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(tmp); }</code> </pre> <br><p>  Conformément aux règles de résolution des surcharges de fonctions ayant des paramètres de type rvalue-reference (voir Annexe A), dans le cas où le type <code>T</code> a un constructeur mobile et un opérateur d'affectation mobile, ils seront utilisés, et il n'y aura pas d'allocation de ressources temporaires et de copie.  Sinon, le constructeur de copie et l'opérateur d'affectation de copie seront utilisés. </p><br><p>  L'utilisation de la sémantique de la délocalisation évite de créer des copies temporaires dans un contexte beaucoup plus large que la fonction d'échange d'état décrite ci-dessus.  La sémantique de mouvement s'applique à toute valeur rvalue, c'est-à-dire une valeur temporaire sans nom, ainsi qu'à la valeur de retour d'une fonction si elle a été créée localement (y compris une lvalue), et RVO n'a pas été appliqué.  Dans tous ces cas, il est garanti que l'objet source ne peut en aucun cas être utilisé après le déplacement.  La sémantique de déplacement s'applique également à la valeur lvalue à laquelle la transformation <code>std::move()</code> est appliquée.  Mais dans ce cas, le programmeur est responsable de la façon dont les objets source seront utilisés après le déplacement (exemple <code>std::swap()</code> ). </p><br><p>  La bibliothèque standard C ++ 11 a été repensée en tenant compte de la sémantique du mouvement.  De nombreuses classes ont ajouté un constructeur de déplacement et un opérateur d'affectation de déplacement, ainsi que d'autres fonctions membres, avec des paramètres de type référence rvalue.  Par exemple, <code>std::vector&lt;T&gt;</code> a une version surchargée de <code>void push_back(T&amp;&amp; src)</code> .  Tout cela permet dans de nombreux cas d'éviter de créer des copies temporaires. </p><br><p>  L'implémentation de la sémantique de déplacement n'annule pas les définitions de la fonction d'échange d'état pour une classe.  Une fonction d'échange d'état spécialement définie peut être plus efficace que la norme <code>std::swap()</code> .  De plus, le constructeur de déplacement et l'opérateur d'affectation de déplacement sont très facilement définis à l'aide de la fonction membre de l'échange d'états comme suit (variation de l'idiome de copie et d'échange): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X&amp; other)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>}    X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X()    {        Swap(src);    }    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>    {        X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//         Swap(tmp);        return *this;    } // ... };</span></span></code> </pre> <br><p>  Le constructeur de déplacement et l'opérateur d'affectation de déplacement sont les fonctions membres pour lesquelles il est hautement souhaitable de s'assurer qu'ils ne <code>noexcept</code> pas d'exceptions et sont par conséquent déclarés comme <code>noexcept</code> .  Cela vous permet d'optimiser certaines opérations des conteneurs de bibliothèque standard sans violer la stricte garantie de sécurité des exceptions, voir [Meyers3] et [Guntheroth] pour plus de détails.  Le modèle proposé offre une telle garantie, à condition que le constructeur par défaut et la fonction membre de l'échange d'états ne lèvent pas d'exceptions. </p><br><p>  La norme C ++ 11 prévoit que le compilateur génère automatiquement un constructeur mobile et un opérateur d'affectation mobile. Pour ce faire, ils doivent être déclarés à l'aide de la construction <code>"=default"</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    X&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  Les opérations sont implémentées en appliquant séquentiellement l'opération de déplacement aux bases et aux membres de la classe, s'ils prennent en charge le déplacement, et en copiant les opérations dans le cas contraire.  Il est clair que cette option est loin d'être toujours acceptable.  Les descripteurs bruts ne se déplacent pas, mais vous ne pouvez généralement pas les copier.  Dans certaines conditions, le compilateur peut générer indépendamment un constructeur mobile et un opérateur d'affectation mobile similaires, mais il est préférable de ne pas utiliser cette opportunité, ces conditions sont plutôt déroutantes et peuvent facilement changer lorsque la classe est affinée.  Voir [Meyers3] pour plus de détails. </p><br><p>  En général, la mise en œuvre et l'utilisation de la sémantique du déplacement est une «chose subtile».  Le compilateur peut appliquer la copie là où le programmeur attend un déplacement.  Voici quelques règles pour éliminer ou au moins réduire la probabilité d'une telle situation. </p><br><ol><li>  Si possible, utilisez l'interdiction de copie. </li><li>  Déclarez le constructeur de déplacement et l'opérateur d'affectation de déplacement en tant que <code>noexcept</code> . </li><li>  Implémentez la sémantique des mouvements pour les classes de base et les membres. </li><li>  Appliquez la transformation <code>std::move()</code> aux paramètres des fonctions de type référence rvalue. </li></ol><br><p>  La règle 2 a été discutée ci-dessus.  4   ,   rvalue-  lvalue (.   ).        . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    B(B&amp;&amp; src) noexcept; }; class D : public B { // ...    D(D&amp;&amp; src) noexcept; }; D::D(D&amp;&amp; src) noexcept    : B(std::move(src)) //  {/* ... */}</span></span></code> </pre> <br><p>      ,     .        6.2.1. </p><br><a name="id-2-5"></a><br><h2>  2.5.  vs.  </h2><br><p>     ,    RVO (.  2.3),        ,    .          ( ),       ,     .        ,    .    C++11  - <code>emplace()</code> , <code>emplace_front()</code> , <code>emplace_back()</code> ,   . ,    -      —   (variadic templates),         .  ,      C++11 —     . </p><br><p>    : </p><br><ol><li>  ,   ,   . </li><li>  ,  ,     . </li></ol><br><p>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vs; vs.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  vs.emplace_back(3, '7');           // </span></span></code> </pre> <br><p>       <code>std::string</code> ,           .        .     ,  ,  .      ,       [Meyers3]. </p><br><a name="id-2-6"></a><br><h2>  2.6.  Résumé </h2><br><p>     ,    ,     .               -  .                   .   —     :    ,    .     ,       ,     ,  .      :     ,     ,  «»   . </p><br><p>      :       ,        ,       .NET  Java.             ,      <code>Clone()</code>  <code>Duplicate()</code> . </p><br><p>  -   -       ,         : </p><br><ol><li>    . </li><li>       . </li><li>   -       rvalue-. </li></ol><br><p>   .NET  Java   -    ,         ,   .NET      <code>IClonable</code> .    ,      . </p><br><a name="id-3"></a><br><h1> 3.       </h1><br><p>        ,    .      -    ,    .     ,    .        Windows:   ,   <code>HANDLE</code> ,  COM-.          <code>DuplicateHandle()</code> ,      <code>CloseHandle()</code> .  COM-  - <code>IUnknown::AddRef()</code>  <code>IUnknown::Release()</code> .   ATL    <code>ComPtr&lt;&gt;</code> ,  COM-  .    UNIX,       C,     <code>_dup()</code> ,      . </p><br><p>    C++11   <code>std::shared_ptr&lt;&gt;</code>    .  ,    ,      ,     ,   ,    . ,      .   <code>std::shared_ptr&lt;&gt;</code>    [Josuttis], [Meyers3]. </p><br><p>      :  -       ,          (  ).          (   )      ,              .   <code>std::shared_ptr&lt;&gt;</code>         <code>std::weak_ptr&lt;&gt;</code> .  . [Josuttis], [Meyers3]. </p><br><p>            - [Alexandrescu].    (   ) ,         [Schildt].          ,   . </p><br><p>        ( )    [Alger]. </p><br><p>            -.     [Josuttis]  [Alexandrescu]. </p><br><p>       -   .NET  Java.   ,    ,   ,         . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><p>          ,  C++   rvalue-   .    C++98    <code>std::auto_ptr&lt;&gt;</code> ,     ,     ,        .   ,       ,       (  ).  C++11   rvalue- ,         ,    .     C++11 <code>std::auto_ptr&gt;&lt;&gt;</code>        <code>std::unique_ptr&lt;&gt;</code> .           ,     [Josuttis], [Meyers3]. </p><br><p>        :   - ( <code>std::fstream</code> , etc.),       ( <code>std::thread</code> , <code>std::unique_lock&lt;&gt;</code> , etc.).  MFC     ,      ( <code>CFile</code> , <code>CEvent</code> , <code>CMutex</code> , etc.). </p><br><a name="id-5"></a><br><h1> 5.    —   </h1><br><p>         .    ,        . ,   ,  ,          .     ,     ,    ,     (    )    .   , ,     ,   .            ( )  ,    .           ,       .    —   .     6. </p><br><p>   ,     -  -,  «  »,   -     .         -    . ,   ,     ,     ,    -       .      «». </p><br><a name="id-6"></a><br><h1> 6.     -  </h1><br><p>     ,       - . ,       -.   . </p><br><a name="id-6-1"></a><br><h2>  6.1.     </h2><br><p>        -  .    ,  ,  : </p><br><ol><li>       .     ,    . </li><li>      . </li><li>    . </li></ol><br><p>      ,     , ,    .    C++11         . </p><br><p>          «   » (resource acquisition is initialization, RAII).  RAII         (          ), .,  [Dewhurst1].      «» RAII.         , , ,     (immutable) RAII. </p><br><a name="id-6-2"></a><br><h2>  6.2.       </h2><br><p> ,      RAII,    ,  ,    .              - ,    ,    -      .  ,       ,       ,        .      . </p><br><a name="id-6-2-1"></a><br><h3> 6.2.1.     </h3><br><p>  ,  ,  ,     ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>       . </li><li>    . </li></ol><br><p>    C++11      , ,  ,     .     ,  - <code>clear()</code> ,     ,    ,      .         . ,   <code>shrink_to_fit()</code> ,    ,     (. ). </p><br><p> ,      RAII,     , ,        .        ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// RAII    X(const X&amp;) = delete;            //      X&amp; operator=(const X&amp;) = delete; //      X(/*  */);              //      ~X();                            //   //     X() noexcept;                    //       X(X&amp;&amp; src) noexcept              //      X&amp; operator=(X&amp;&amp; src) noexcept;  //    // ... };</span></span></code> </pre> <br><p>         . </p><br><pre> <code class="cpp hljs">X x;                    <span class="hljs-comment"><span class="hljs-comment">//  ""  x = X(/*  */); //   x = X(/*  */); //   ,   x = X();                //  </span></span></code> </pre> <br><p>     <code>std::thread</code> . </p><br><p>      2.4,           -  .  , -        -    .    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// RAII // ... public: // ,         X() noexcept;    X(X&amp;&amp; src) noexcept;    X&amp; operator=(X&amp;&amp; src) noexcept;    void Swap(X&amp; other) noexcept; //      void Create(/*  */); //      void Close() noexcept;        //   // ... }; X::X() noexcept {/*    */}</span></span></code> </pre> <br><p>       : </p><br><pre> <code class="cpp hljs">X::X(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : X() {    Swap(src); } X&amp; X::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(X&amp;&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> {    X tmp(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(src)); <span class="hljs-comment"><span class="hljs-comment">//     Swap(tmp);    return *this; }</span></span></code> </pre> <br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> X::Create(<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>) {    <span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*  */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//      Swap(tmp); } void X::Close() noexcept {    X tmp;    Swap(tmp); }</span></span></code> </pre> <br><p>   ,          ,    , -      .           ,  ,       ,   .               ,         . </p><br><p>          -     «  »,        ,   .         :      ,       ,      ( ).         :    ,   .        ,  :      ,          ,     .  ,            .       [Sutter], [Sutter/Alexandrescu], [Meyers2]. </p><br><p> ,   RAII                 . </p><br><a name="id-6-2-2"></a><br><h3> 6.2.2.    </h3><br><p>        RAII     .  ,  ,  ,    ,      : </p><br><ol><li>    ,   . </li><li>       . </li><li>    .    ,  . </li><li>      . </li><li>  . </li></ol><br><p>  «» RAII,   —          .      ,     ,    . 3.       .    «»,    . </p><br><a name="id-6-2-3"></a><br><h3> 6.2.3.    </h3><br><p>        —    .      RAII   ,       .         ,     .   ,   ,              (   -).  -       ( -).        6.2.1,         . </p><br><a name="id-6-3"></a><br><h2> 6.3.   </h2><br><p>     , -          RAII,     :            .      ,     ,   . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p> ,  ,     ,     ,    .  -        -. </p><br><p>  4   -: </p><br><ol><li>   . </li><li>   . </li><li>   . </li><li>   . </li></ol><br><p>         .      ,      - :   ,      , -    . </p><br><p>            ,    .  ,    ,     -,        ,     . </p><br><p>   -      .     .            ,                  (.  6.2.3).     ,      (.  6.2.1).         ,           .    ,       ,      .        ,       <code>std::shared_ptr&lt;&gt;</code> . </p><br><a name="id-apps"></a><br><h1>  Les applications </h1><br><a name="id-app-1"></a><br><h2>  . Rvalue- </h2><br><p> Rvalue-    C++ ,          ,    rvalue-.  rvalue-   <code>T</code>   <code>T&amp;&amp;</code> . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Int(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_Value(val) {}    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Value; }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ m_Value = val; } };</code> </pre> <br><p>    , rvalue-  . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r0; <span class="hljs-comment"><span class="hljs-comment">// error C2530: 'r0' : references must be initialized</span></span></code> </pre> <br><p>   rvalue-   ++    ,       lvalue.  Un exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Int&amp;&amp; r1 = i; <span class="hljs-comment"><span class="hljs-comment">// error C2440: 'initializing' : cannot convert from 'Int' to 'Int &amp;&amp;'</span></span></code> </pre> <br><p>      rvalue: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r2 = Int(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment">// OK Int&amp;&amp; r3 = 5;       // OK</span></span></code> </pre> <br><p>  lvalue       rvalue-: </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r4 = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Int&amp;&amp;&gt;(i); <span class="hljs-comment"><span class="hljs-comment">// OK</span></span></code> </pre> <br><p>      rvalue-    (  ) <code>std::move()</code> ,     (  <code>&lt;utility&gt;</code> ). </p><br><p> Rvalue      rvalue  ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp;&amp; r5 = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK int&amp; r6 = 2 * 2;  // error</span></span></code> </pre> <br><p>   rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r.Get() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// : 7 r.Set(19); std::cout &lt;&lt; r.Get() &lt;&lt; '\n'; // : 19</span></span></code> </pre> <br><p> Rvalue-     . </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">5</span></span>; Int&amp; x = r;           <span class="hljs-comment"><span class="hljs-comment">// OK const Int&amp; cx = r;    // OK</span></span></code> </pre> <br><p> Rvalue-     ,      .     ,      rvalue-,       rvalue . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// error, lvalue  Foo(std::move(i)); // OK Foo(Int(4));       // OK Foo(5);            // OK</span></span></code> </pre> <br><p>     ,      rvalue      rvalue-              ,       .        rvalue-. </p><br><p>   ,   ,   ,    rvalue-,   (ambiguous)  rvalue . </p><br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int&amp;&amp;)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Int&amp;)</span></span></span></span>;</code> </pre> <br><p>      </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Int </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Foo(i);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(i)); // Foo(Int&amp;&amp;) Foo(Int(6));       // Foo(Int&amp;&amp;) Foo(9);            // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>       :  rvalue-     lvalue. </p><br><pre> <code class="cpp hljs">Int&amp;&amp; r = <span class="hljs-number"><span class="hljs-number">7</span></span>; Foo(r);            <span class="hljs-comment"><span class="hljs-comment">// Foo(const Int&amp;) Foo(std::move(r)); // Foo(Int&amp;&amp;)</span></span></code> </pre> <br><p>      ,    rvalue-,    lvalue     <code>std::move()</code> . .          2.4. </p><br><p>    ++11,   rvalue- —      -.      (lvalue/rvalue)   <code>this</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X();    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoIt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> &amp;</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// this   lvalue    void DoIt() &amp;&amp;; // this   rvalue // ... }; X x; x.DoIt();   // DoIt() &amp; X().DoIt(); // DoIt() &amp;&amp;</span></span></code> </pre> <br><a name="id-app-2"></a><br><h2>  .   </h2><br><p>  ,            ( <code>std::string</code> , <code>std::vector&lt;&gt;</code> , etc.)       .         —    .     ,    rvalue-          .    ,   ,   -   ,    - ,    .       ,  ,       ,         rvalue,       lvalue.      ,        rvalue.    .         ,   (    lvalue),       RVO. </p><br><a name="id-refs"></a><br><h1>  Les références </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Alexandrescu] <br> , .    C++.: .  de l'anglais  - M.: LLC «I.D. », 2002. </p><br><p> [Guntheroth] <br> , .    C++.     .: .  de l'anglais — .:  «-», 2017. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  de l'anglais  - M.: LLC «I.D. », 2014. </p><br><p> [Dewhurst1] <br> ,  . C++.  , 2- .: .  de l'anglais — .: -, 2013. </p><br><p> [Dewhurst2] <br> ,  .   C++.         .: .  de l'anglais — .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  de l'anglais — .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  de l'anglais — .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C ++14.: .  de l'anglais  - M.: LLC «I.D. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  de l'anglais — :  «.. », 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  de l'anglais  - M.: LLC «I.D. », 2015. </p><br><p> [Schildt] <br> , .    C++.: .  de l'anglais — .: -, 2005. </p><br><p> [Alger] <br> , . C++:  .: .  de l'anglais — .:  « «», 1999. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425837/">https://habr.com/ru/post/fr425837/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425827/index.html">Leçon Google+: les projets doivent s'assurer que les frontières entre les intérêts des utilisateurs dans la vie réelle sont respectées en ligne</a></li>
<li><a href="../fr425829/index.html">Comment nous nous sommes battus avec Roskomnadzor et ce qu'il en est advenu</a></li>
<li><a href="../fr425831/index.html">Alerte RKN - Base de données Roskomnadzor dans votre navigateur</a></li>
<li><a href="../fr425833/index.html">Un outil pour vous aider à choisir les meilleures idées pour votre produit.</a></li>
<li><a href="../fr425835/index.html">«Breaking Bugs» dans Sberbank: comment corriger le taux de bogues sur sept jours par jour</a></li>
<li><a href="../fr425839/index.html">Examen de la conférence Atlassian</a></li>
<li><a href="../fr425843/index.html">Python pour l'enfant: choisir un tutoriel</a></li>
<li><a href="../fr425845/index.html">Applications de verrouillage automatique sur Google Play</a></li>
<li><a href="../fr425847/index.html">Un exemple d'utilisation de Microsoft Flow ou Comment donner des fleurs à votre femme</a></li>
<li><a href="../fr425849/index.html">Amazon a renoncé et a augmenté les salaires des employés</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>