<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏿 💼 🤱🏻 Cara menulis kode yang akan digunakan kembali 🔽 👏🏻 ⭕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gagasan bahwa kode yang dirancang untuk digunakan kembali dapat menjadi obat mujarab untuk semua masalah pemrograman adalah mitos yang berbahaya. Seka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menulis kode yang akan digunakan kembali</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/digital-ecosystems/blog/481296/"><img src="https://habrastorage.org/webt/se/lt/br/seltbrqaxyps7qngjccratyuwu0.jpeg"><br><br>  Gagasan bahwa kode yang dirancang untuk digunakan kembali dapat menjadi obat mujarab untuk semua masalah pemrograman adalah mitos yang berbahaya.  Sekarang saya akan menjelaskan alasannya. <br><br>  Mari kita bayangkan bahwa Anda sedang menulis perpustakaan dan tiba-tiba menangkap ide cemerlang, dari mana solusi umum dapat diperoleh, dapat diterapkan dalam berbagai kasus.  Anda sangat meresepkan API yang akan mengalahkan fungsi apa pun dan beradaptasi dengan skenario apa pun.  Anda menambahkan semua skrip yang hanya muncul di pikiran Anda.  Kode membengkak dan membengkak, tetapi, pada akhirnya, itu benar-benar menjadi digeneralisasi dalam arti kata sepenuhnya.  Dia seperti kue panas, dan kamu bahagia. <br><br>  Tapi suatu hari, API baru muncul di cakrawala.  Ini lebih ringkas dan cocok untuk sejumlah besar skenario, dan terlebih lagi, ia menang dalam kecepatan dan kesederhanaan.  API Anda terlupakan - semua orang segera beralih ke hal baru yang menggoda.  Namun, setelah beberapa waktu, cerita yang sama berulang dengan itu: API menjadi lebih dan lebih berat karena penambahan kode yang konstan, dirancang untuk kondisi baru, sampai pada akhirnya ada sesuatu yang lain untuk menggantikannya.  Demikian seterusnya ad infinitum. <br><br>  Kenapa begitu? <br><a name="habracut"></a><br>  Akar semua masalah dalam hal ini adalah keinginan untuk menulis solusi umum.  Jika kode yang dapat direproduksi menggunakan case standar sebagai standar, kode itu menjadi kembung, tidak nyaman digunakan, dan secara bertahap berubah menjadi sakit kepala murni. <br><br>  Beberapa tingkat generalisasi merupakan prasyarat untuk penggunaan berulang kode apa pun.  Tetapi jika Anda melangkah terlalu jauh dengan ini, utilitarianisme mulai menderita.  Oleh karena itu, jika saya mengungkapkan pemikiran saya secara singkat, menulis kode yang dapat digunakan kembali tidak turun untuk menjadikannya selengkap mungkin.  Semuanya jauh lebih rumit. <br>  Untuk membuat kode yang dapat direproduksi secara praktis, Anda perlu memastikan bahwa itu tidak digunakan secara teratur, tetapi secara spontan, ketika diperlukan.  Katakanlah, ketika mengerjakan suatu produk, Anda tiba-tiba menemukan kode yang dapat digunakan untuk kebutuhannya.  Anda mengambil cuplikan ini, memodifikasinya sedikit dan menerapkannya dalam aplikasi.  Dengan demikian, Anda membayar hanya untuk apa yang benar-benar bermanfaat, dan tepat ketika itu diperlukan. <br><br>  Kemudian, Anda menemukan bahwa versi revisi ini mungkin berguna di aplikasi lain.  Anda lagi mengambil fragmen ini, sedikit memodifikasinya dan menggunakannya di lingkaran ketiga.  Jadi, berangsur-angsur meningkatkan reproduktifitas, Anda tidak hanya mendapatkan manfaat maksimal dari fragmen ini, tetapi juga melindungi produk Anda dari kode yang tidak melakukan apa pun untuknya dan umumnya tidak diperlukan di dalamnya. <br><br>  Hal utama di sini adalah tidak pernah mencoba untuk memprediksi masa depan.  Reproduksibilitas harus dibatasi pada batas visibilitas saat ini;  di masa depan, Anda akan memperbaiki kode tersebut setiap kali ada peluang baru untuk penerapannya.  Ini tidak hanya akan menghemat waktu dan tenaga Anda, tetapi juga menulis kode yang lebih ekonomis, keren dan modern, dipertajam untuk digunakan kembali. <br><br>  Berikut adalah beberapa saran praktis tentang cara membuat kode dapat digunakan kembali. <br><br><h4>  Hindari duplikasi </h4><br>  Seperti yang dikatakan Lemony Sinquet dengan benar: “Jangan ulangi.  Pertama, Anda ulangi lagi, kedua, Anda mengatakan hal yang sama, dan ketiga, semua orang sudah mendengarnya. ” <br><br>  Ingat, kita berbicara tentang penggunaan kembali yang terjadi secara spontan?  Inilah yang (dan hanya ini) yang harus dibatasi untuk tujuan kode ergonomis.  Jadi, tulis kode yang Anda butuhkan saat ini, dan lanjutkan dengan semangat yang sama sampai Anda menyadari bahwa Anda harus menyelesaikan masalah yang sama berulang kali.  Kemudian lakukan refactoring, letakkan kode di beberapa lokasi yang dapat diakses dan lihat sesuai kebutuhan.  Bertindak dengan cara ini, Anda tidak akan mendapatkan kode umum yang boros, tetapi kode yang tidak memiliki duplikasi. <br><br>  Bahkan, prinsip yang sama didalilkan oleh prinsip KERING (Jangan ulangi sendiri), yang menyatakan bahwa logika yang sama tidak boleh ditulis berulang kali dalam kode - ini menimbulkan tugas teknis.  Pengulangan yang tidak berarti menyumbat sistem, mengurangi kualitas basis kode dan, juga, mengubahnya menjadi mimpi buruk bagi mereka yang memiliki tanggung jawab untuk mempertahankan kode produk.  Penting untuk diingat: prinsip KERING adalah sejenis filosofi yang menyerukan untuk meninggalkan ambisi pemrograman pribadi dan melakukan apa yang terbaik untuk proyek.  Jika seseorang telah melakukan sesuatu, gunakan itu.  Tidak perlu menemukan kembali roda. <br><br><h4>  Pastikan kelas / metode / fungsi bertanggung jawab untuk satu hal. </h4><br>  Pada kesempatan ini, kita dapat mengingat pernyataan indah Louis Sullivan: "Bentuk berasal dari tujuan."  Dalam terjemahan, ini berarti yang berikut: jika suatu fungsi, kelas atau metode melakukan satu-satunya hal, maka Anda akan mengubahnya hanya karena satu alasan.  Ya, dengan pendekatan ini Anda sering harus membuat metode yang akan menggunakan metode lain, tetapi mereka akan tetap sederhana dan tidak terlalu koheren. <br><br>  Setiap sistem dibangun dengan menggunakan bahasa yang berorientasi pada subjek, yang diciptakan oleh programmer dengan tujuan untuk menggambarkan sistem tersebut dengan benar.  Fungsi memenuhi peran kata kerja dalam bahasa-bahasa ini, dan kelas memainkan peran kata benda.  Bersama-sama mereka, sebagai suatu peraturan, membentuk tingkat dasar organisasi bahasa apa pun;  karenanya, jika Anda meresepkannya dengan cara yang berkualitas, maka kode Anda akan berkualitas tinggi. <br><br>  Ada dua aturan emas untuk membuat fungsi dan kelas yang dapat diterapkan beberapa kali, hanya dua: <br><br><ul><li>  Mereka harus kecil </li><li>  Mereka harus melakukan satu hal, dan dengan baik </li></ul><br>  Ini mengasumsikan bahwa fungsi seharusnya tidak tumbuh cukup untuk mengandung struktur bersarang.  Oleh karena itu, level sarang tidak boleh melebihi satu atau dua.  Berkat teknik ini, kode menjadi lebih mudah dibaca, diurai dan berasimilasi. <br><br>  Selain itu, perlu untuk memastikan bahwa semua operator dalam satu fungsi tetap pada tingkat abstraksi yang sama.  Tingkat pencampuran selalu membingungkan dan cepat atau lambat akan menyebabkan kerja keras dengan kode.  Programmer pro melihat kode yang dapat direproduksi sebagai semacam narasi, bukan hanya sepotong teks.  Mereka menggunakan kemampuan bahasa pemrograman yang dipilih untuk membuat blok yang lebih ekspresif, bermakna, dan rapi yang dengan sempurna membangun narasi. <br><br><h4>  Jangan menyalahgunakan warisan </h4><br>  Terkadang kita, para pengembang, mencoba untuk melihat ke masa depan proyek yang jauh dan mulai melemparkan fungsi tambahan dengan pemikiran "bagaimana jika Anda membutuhkannya" dan "suatu hari nanti berguna".  Jangan lakukan itu.  Sampai sekarang, ini belum berguna bagi Anda, sekarang Anda tidak membutuhkannya dan dalam kebanyakan kasus ... Anda tidak akan membutuhkannya (untuk memparafrasekan prinsip YAGNI yang terkenal - You Ain't Gonna Need It).  Prinsip ini berlaku untuk warisan.  Jangan masukkan jika Anda tidak memiliki keyakinan penuh bahwa implementasi akan diulang beberapa kali. <br><br>  Dengan semua ini, faktor keturunan adalah cara terbaik untuk menambahkan fungsionalitas ke kelas.  Tetapi programmer cenderung mengambil alih tepi, membangun hierarki kelas di enam level atau lebih.  "Geng Empat" dalam bukunya "Pola Desain" dengan ringkas menggambarkan risiko warisan yang berlebihan: <br><br><blockquote>  "Karena subclass memiliki akses ke detail implementasi kelas induk, sering dikatakan bahwa pewarisan melanggar enkapsulasi." </blockquote><br>  Keturunan menyebabkan kohesi yang kuat dari komponen, karena superclass membuka bagian dalamnya ke subclass, dan mereka, pada gilirannya, sepenuhnya bergantung pada superclass dalam segala hal yang berkaitan dengan operasi yang benar.  Dalam situasi ini, superclass kehilangan fleksibilitasnya - menjadi sulit untuk mengubah apa pun dalam fungsinya.  Karena alasan inilah, faktor keturunan adalah cara yang buruk untuk mencapai penggunaan kembali kode. <br><br>  Pendekatan yang lebih masuk akal adalah berpikir dalam paradigma struktur objek, daripada keturunan.  Ini akan memungkinkan orang menggunakan kode Anda untuk lebih mudah mengambil fungsionalitas yang mereka butuhkan dan membuat objek sendiri berdasarkan pembatasan yang relevan bagi mereka.  Anda bahkan harus mempertimbangkan membuat antarmuka prosedural yang dapat diimplementasikan oleh masing-masing kelas dengan caranya sendiri.  Antarmuka seringkali lebih mudah dipahami dan diimplementasikan daripada kelas dengan pewarisan multi-layer. <br><br>  Untuk meringkas, seseorang harus menggunakan hereditas hanya jika satu kelas merupakan kelanjutan logis dari yang lain dan sebagian besar kode dari kelas pewarisan menggunakan kode dari superclass.  Dalam kasus lain, Anda cukup menandatangani hukuman mati untuk diri sendiri dan kemungkinan kode penggunaan kembali. <br><br><h4>  Kesimpulannya </h4><br>  Secara umum, menulis kode untuk digunakan kembali tidak berarti membuat blok monolitik besar yang digeneralisasi.  Kunci untuk menulis kode yang dapat direproduksi adalah dalam elemen-elemen yang ditujukan pada tugas tertentu, yang mudah dirakit, disolder dengan baik dan tidak terlalu saling terhubung dengan kuat. <br><br>  Dan akhirnya, jangan mengakhiri dengan sendirinya dari penggunaan berulang - itu tidak layak.  Lebih baik menetapkan tujuan untuk menghindari duplikasi, bukan untuk menulis fragmen kosong yang tidak perlu, untuk memastikan bahwa kode mudah dibaca dan dipelihara.  Ketika Anda mengembangkan pandangan yang benar tentang berbagai hal, reproduktifitas akan datang dengan sendirinya. <br><br>  Selalu ingat: penggunaan kembali dimulai dengan fakta bahwa Anda telah menemukan solusi yang berhasil untuk tugas tertentu.  Segala sesuatu yang lain harus mengalir dari premis ini, dan Anda memiliki hak untuk memilih metode yang paling tepat untuk membawa potongan kode tertentu ke tingkat yang baru.  Seperti yang dikatakan Ralph Johnson dengan benar: "Sebelum Anda berpikir tentang menggunakan kembali kode, Anda perlu memastikan bahwa Anda dapat menggunakannya sama sekali." </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481296/">https://habr.com/ru/post/id481296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481282/index.html">Nilai ide itu dan bagaimana mengubahnya menjadi sebuah konsep: alat perancang permainan</a></li>
<li><a href="../id481286/index.html">Dapatkan di atas meja! Kantor hal-hal kecil yang bukan hal kecil sama sekali</a></li>
<li><a href="../id481288/index.html">Redux Toolkit sebagai Alat untuk Pengembangan Redux yang Efektif</a></li>
<li><a href="../id481290/index.html">Pengaturan CARA-ke / Jaringan dan VLAN pada server Hetzner dan Mikrotik khusus</a></li>
<li><a href="../id481294/index.html">10 alat otomatisasi pengujian perangkat lunak terbaik</a></li>
<li><a href="../id481302/index.html">"Tentang, ya, bukan cluster" atau karena kami mengimpor DBMS</a></li>
<li><a href="../id481304/index.html">Sortir Bendera Amerika</a></li>
<li><a href="../id481306/index.html">Memperkenalkan werf 1.0 stable: apa yang harus dilakukan GitOps dengan status, dan rencana</a></li>
<li><a href="../id481312/index.html">Santa's Lost Gifts: Pengumuman Quest TI untuk 6 Januari</a></li>
<li><a href="../id481314/index.html">Platform DIY Crawler untuk robot dan hiburan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>