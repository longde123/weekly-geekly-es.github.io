<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏿 👒 ⏪ Node.js: mengelola memori yang tersedia untuk aplikasi yang berjalan dalam wadah 🍷 👩🏿‍🎓 🈹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat menjalankan aplikasi Node.js dalam wadah Docker, pengaturan memori tradisional tidak selalu berfungsi seperti yang diharapkan. Bahannya, terjemah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js: mengelola memori yang tersedia untuk aplikasi yang berjalan dalam wadah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454522/">  Saat menjalankan aplikasi Node.js dalam wadah Docker, pengaturan memori tradisional tidak selalu berfungsi seperti yang diharapkan.  Bahannya, terjemahan yang kami terbitkan hari ini, didedikasikan untuk menemukan jawaban atas pertanyaan mengapa demikian.  Ini juga akan memberikan rekomendasi praktis untuk mengelola memori yang tersedia untuk aplikasi Node.js yang berjalan dalam wadah. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/9_/rp/-s/9_rp-s7libv7ncp6mubs2h_qjzu.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ulasan rekomendasi</font> </h2><br>  Misalkan aplikasi Node.js berjalan dalam wadah dengan batas memori yang ditetapkan.  Jika kita berbicara tentang Docker, maka opsi <code>--memory</code> dapat digunakan untuk mengatur batas ini.  Hal serupa mungkin terjadi ketika bekerja dengan sistem orkestrasi wadah.  Dalam hal ini, disarankan bahwa ketika memulai aplikasi Node.js, gunakan opsi <code>--max-old-space-size</code> .  Ini memungkinkan Anda untuk menginformasikan platform tentang berapa banyak memori yang tersedia untuk itu, dan juga mempertimbangkan fakta bahwa jumlah ini harus kurang dari batas yang ditetapkan pada tingkat wadah. <br><br>  Ketika aplikasi Node.js berjalan di dalam wadah, atur kapasitas memori yang tersedia untuknya sesuai dengan nilai puncak penggunaan memori aktif oleh aplikasi.  Ini dilakukan jika batas memori kontainer dapat dikonfigurasi. <br><br>  Sekarang mari kita bicara tentang masalah menggunakan memori dalam wadah secara lebih rinci. <br><br><h2>  <font color="#3AC1EF">Batas Memori Docker</font> </h2><br>  Secara default, wadah tidak memiliki batasan sumber daya dan dapat menggunakan sebanyak mungkin memori yang diizinkan oleh sistem operasi.  Perintah <code>docker run</code> memiliki opsi baris perintah yang memungkinkan Anda menetapkan batas terkait penggunaan memori atau sumber daya prosesor. <br><br>  Perintah peluncuran kontainer mungkin terlihat seperti ini: <br><br><pre> <code class="javascript hljs">docker run --memory &lt;x&gt;&lt;y&gt; --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Harap perhatikan hal berikut: <br><br><ul><li>  <code>x</code> adalah batas jumlah memori yang tersedia untuk wadah, dinyatakan dalam satuan <code>y</code> . </li><li>  <code>y</code> dapat mengambil nilai <code>b</code> (byte), <code>k</code> (kilobyte), <code>m</code> (megabita), <code>g</code> (gigabita). </li></ul><br>  Berikut adalah contoh perintah peluncuran kontainer: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1000000</span></span>b --interactive --tty &lt;imagename&gt; bash</code> </pre> <br>  Di sini, batas memori diatur ke <code>1000000</code> byte. <br><br>  Untuk memeriksa batas memori yang ditetapkan pada level wadah, Anda dapat, dalam wadah, jalankan perintah berikut: <br><br><pre> <code class="javascript hljs">cat /sys/fs/cgroup/memory/memory.limit_in_bytes</code> </pre> <br>  Mari kita bicara tentang perilaku sistem ketika menentukan batas memori aplikasi Node.js menggunakan kunci <code>--max-old-space-size</code> .  Dalam hal ini, batas memori ini akan sesuai dengan batas yang ditetapkan pada level wadah. <br><br>  Apa yang disebut "ruang lama" dalam nama kuncinya adalah salah satu fragmen tumpukan yang dikendalikan oleh V8 (tempat di mana objek JavaScript "lama" ditempatkan).  Kunci ini, jika Anda tidak masuk ke detail yang kami sentuh di bawah ini, mengontrol ukuran tumpukan maksimum.  Rincian tentang sakelar baris perintah Node.js dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Secara umum, ketika suatu aplikasi mencoba menggunakan lebih banyak memori daripada yang tersedia dalam wadah, operasinya dihentikan. <br><br>  Dalam contoh berikut (file aplikasi disebut <code>test-fatal-error.js</code> ), objek <code>MyRecord</code> ditempatkan ke dalam array <code>list</code> , dengan interval 10 milidetik.  Hal ini menyebabkan pertumbuhan tumpukan yang tidak terkendali, mensimulasikan kebocoran memori. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = []; setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyRecord(); list.push(record); },<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyRecord</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x=<span class="hljs-string"><span class="hljs-string">'hii'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.account = x.repeat(<span class="hljs-number"><span class="hljs-number">10000000</span></span>); } setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(process.memoryUsage()) },<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre> <br>  Harap perhatikan bahwa semua contoh program yang akan kami diskusikan di sini ditempatkan di gambar Docker, yang dapat diunduh dari Docker Hub: <br><br><pre> <code class="javascript hljs">docker pull ravali1906/dockermemory</code> </pre> <br>  Anda dapat menggunakan gambar ini untuk percobaan independen. <br><br>  Selain itu, Anda dapat mengemas aplikasi dalam wadah Docker, mengumpulkan gambar dan menjalankannya dengan batas memori: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">512</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Di sini <code>ravali1906/dockermemory</code> adalah nama dari gambar tersebut. <br><br>  Sekarang Anda dapat memulai aplikasi dengan menentukan batas memori untuk itu yang melebihi batas wadah: <br><br><pre> <code class="javascript hljs">$ node --max_old_space_size=<span class="hljs-number"><span class="hljs-number">1024</span></span> test-fatal-error.js { <span class="hljs-attr"><span class="hljs-attr">rss</span></span>: <span class="hljs-number"><span class="hljs-number">550498304</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapTotal</span></span>: <span class="hljs-number"><span class="hljs-number">1090719744</span></span>, <span class="hljs-attr"><span class="hljs-attr">heapUsed</span></span>: <span class="hljs-number"><span class="hljs-number">1030627104</span></span>, <span class="hljs-attr"><span class="hljs-attr">external</span></span>: <span class="hljs-number"><span class="hljs-number">8272</span></span> } Killed</code> </pre> <br>  Di sini, <code>--max_old_space_size</code> mewakili batas memori yang ditunjukkan dalam megabita.  Metode <code>process.memoryUsage()</code> memberikan informasi tentang penggunaan memori.  Nilai dinyatakan dalam byte. <br><br>  Aplikasi pada suatu saat dihentikan secara paksa.  Ini terjadi ketika jumlah memori yang digunakan melintasi batas tertentu.  Apa perbatasan ini?  Apa batasan jumlah memori yang bisa kita bicarakan? <br><br><h2>  <font color="#3AC1EF">Perilaku yang diharapkan dari aplikasi yang berjalan dengan kuncinya adalah - max-old-space-size</font> </h2><br>  Secara default, ukuran heap maksimum di Node.js (hingga versi 11.x) adalah 700 MB pada platform 32-bit, dan 1400 MB pada platform 64-bit.  Anda dapat membaca tentang pengaturan nilai-nilai ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Secara teori, jika Anda menggunakan kunci <code>--max-old-space-size</code> untuk <code>--max-old-space-size</code> batas memori yang melebihi batas memori kontainer, Anda dapat mengharapkan aplikasi dihentikan oleh mekanisme keamanan kernel Linux OOM Killer. <br><br>  Pada kenyataannya, ini mungkin tidak terjadi. <br><br><h2>  <font color="#3AC1EF">Perilaku sebenarnya dari aplikasi yang berjalan dengan kunci adalah ukuran max-old-space-size</font> </h2><br>  Aplikasi, segera setelah peluncuran, tidak mengalokasikan semua memori yang batasnya ditentukan menggunakan <code>--max-old-space-size</code> .  Ukuran tumpukan JavaScript tergantung pada kebutuhan aplikasi.  Anda bisa menilai berapa banyak memori yang digunakan aplikasi berdasarkan nilai bidang <code>heapUsed</code> dari objek yang dikembalikan oleh metode <code>process.memoryUsage()</code> .  Bahkan, kita berbicara tentang memori yang dialokasikan di heap untuk objek. <br><br>  Sebagai hasilnya, kami menyimpulkan bahwa aplikasi akan dihentikan secara paksa jika ukuran tumpukan lebih besar dari batas yang ditetapkan oleh kunci - <code>--memory</code> ketika wadah mulai. <br><br>  Tetapi dalam kenyataannya ini mungkin juga tidak terjadi. <br><br>  Saat membuat profil aplikasi Node.js yang intensif sumber daya yang berjalan dalam wadah dengan batas memori yang diberikan, pola berikut dapat diamati: <br><br><ol><li>  OOM Killer dipicu jauh lebih lambat daripada saat ketika nilai <code>heapTotal</code> dan <code>heapUsed</code> secara signifikan lebih tinggi dari batas memori. </li><li>  OOM Killer tidak merespons melebihi batas. </li></ol><br><h2>  <font color="#3AC1EF">Penjelasan tentang perilaku aplikasi Node.js dalam wadah</font> </h2><br>  Sebuah wadah mengawasi satu indikator penting dari aplikasi yang berjalan di atasnya.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RSS</a> (ukuran yang ditetapkan penduduk).  Indikator ini mewakili bagian tertentu dari memori virtual aplikasi. <br><br>  Selain itu, itu adalah bagian dari memori yang dialokasikan untuk aplikasi. <br><br>  Tapi itu belum semuanya.  RSS adalah bagian dari memori aktif yang dialokasikan untuk aplikasi. <br><br>  Tidak semua memori yang dialokasikan untuk aplikasi mungkin aktif.  Faktanya adalah bahwa "memori yang dialokasikan" tidak perlu dialokasikan secara fisik sampai proses mulai benar-benar menggunakannya.  Selain itu, sebagai tanggapan atas permintaan alokasi memori dari proses lain, sistem operasi dapat membuang bagian tidak aktif dari memori aplikasi ke file halaman dan mentransfer ruang kosong ke proses lain.  Dan ketika aplikasi lagi membutuhkan potongan memori ini, mereka akan diambil dari file swap dan dikembalikan ke memori fisik. <br><br>  Metrik RSS menunjukkan jumlah memori yang aktif dan tersedia untuk aplikasi di ruang alamatnya.  Dialah yang mempengaruhi keputusan penutupan paksa aplikasi. <br><br><h2>  <font color="#3AC1EF">Bukti</font> </h2><br><h3>  <font color="#3AC1EF">▍ Contoh No. 1.</font>  <font color="#3AC1EF">Aplikasi yang mengalokasikan memori untuk buffer</font> </h3><br>  Contoh berikut, <code>buffer_example.js</code> , memperlihatkan program yang mengalokasikan memori untuk buffer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Agar jumlah memori yang dialokasikan oleh program melebihi batas yang ditetapkan saat wadah diluncurkan, pertama jalankan wadah dengan perintah berikut: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Setelah itu, jalankan program: <br><br><pre> <code class="javascript hljs">$ node buffer_example <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  Seperti yang Anda lihat, sistem tidak menyelesaikan program, meskipun memori yang dialokasikan oleh program melebihi batas kontainer.  Ini terjadi karena fakta bahwa program tidak bekerja dengan semua memori yang dialokasikan.  RSS sangat kecil, tidak melebihi batas memori kontainer. <br><br><h3>  <font color="#3AC1EF">▍ Contoh No. 2.</font>  <font color="#3AC1EF">Aplikasi mengisi buffer dengan data</font> </h3><br>  Dalam contoh berikut, <code>buffer_example_fill.js</code> , memori tidak hanya dialokasikan, tetapi juga diisi dengan data: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Jalankan wadah: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Setelah itu, jalankan aplikasi: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-number"><span class="hljs-number">984</span></span></code> </pre> <br>  Ternyata, bahkan sekarang aplikasi tidak berakhir!  Mengapa  Faktanya adalah bahwa ketika jumlah memori aktif mencapai batas yang ditetapkan ketika wadah dimulai, dan ada ruang dalam file halaman, beberapa halaman lama dalam memori proses dipindahkan ke file halaman.  Memori yang dirilis tersedia untuk proses yang sama.  Secara default, Docker mengalokasikan ruang untuk file swap yang sama dengan batas memori yang ditetapkan menggunakan flag <code>--memory</code> .  Dengan ini, kita dapat mengatakan bahwa proses memiliki 2 GB memori - 1 GB dalam memori aktif, dan 1 GB dalam file halaman.  Yaitu, karena kenyataan bahwa aplikasi dapat menggunakan memori sendiri, isi yang sementara dipindahkan ke file halaman, ukuran indeks RSS berada dalam batas kontainer.  Hasilnya, aplikasi terus bekerja. <br><br><h3>  <font color="#3AC1EF">▍ Contoh No. 3.</font>  <font color="#3AC1EF">Aplikasi yang mengisi buffer dengan data yang berjalan dalam wadah yang tidak menggunakan file halaman</font> </h3><br>  Berikut adalah kode yang akan kami coba di sini (ini adalah file <code>buffer_example_fill.js</code> sama): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.alloc(+process.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] * <span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(buf.length / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>))) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(process.memoryUsage().rss / (<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>)))</code> </pre> <br>  Kali ini, jalankan wadah, secara eksplisit mengatur fitur bekerja dengan file swap: <br><br><pre> <code class="javascript hljs">docker run --memory <span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swap=<span class="hljs-number"><span class="hljs-number">1024</span></span>m --memory-swappiness=<span class="hljs-number"><span class="hljs-number">0</span></span> --interactive --tty ravali1906/dockermemory bash</code> </pre> <br>  Luncurkan aplikasi: <br><br><pre> <code class="javascript hljs">$ node buffer_example_fill.js <span class="hljs-number"><span class="hljs-number">2000</span></span> Killed</code> </pre> <br>  Lihat pesan <code>Killed</code> ?  Ketika nilai kunci <code>--memory-swap</code> sama dengan nilai kunci <code>--memory</code> , ini memberitahu wadah bahwa itu tidak boleh menggunakan file <code>--memory</code> .  Selain itu, secara default, kernel sistem operasi tempat wadah itu sendiri beroperasi dapat membuang sejumlah halaman memori anonim yang digunakan oleh wadah tersebut ke file halaman.  <code>--memory-swappiness</code> ke <code>0</code> , kami menonaktifkan fitur ini.  Akibatnya, ternyata file paging tidak digunakan di dalam wadah.  Proses berakhir ketika metrik RSS melebihi batas memori wadah. <br><br><h2>  <font color="#3AC1EF">Rekomendasi umum</font> </h2><br>  Ketika aplikasi Node.js diluncurkan dengan kunci <code>--max-old-space-size</code> , nilainya melebihi batas memori yang ditetapkan ketika wadah diluncurkan, mungkin tampak bahwa Node.js "tidak memperhatikan" batas kontainer.  Tetapi, seperti dapat dilihat dari contoh sebelumnya, alasan yang jelas untuk perilaku ini adalah kenyataan bahwa aplikasi tidak menggunakan seluruh volume tumpukan yang ditentukan dengan <code>--max-old-space-size</code> flag. <br><br>  Ingatlah bahwa aplikasi tidak akan selalu berperilaku sama jika menggunakan lebih banyak memori daripada yang tersedia dalam wadah.  Mengapa  Faktanya adalah bahwa memori aktif proses (RSS) dipengaruhi oleh banyak faktor eksternal yang tidak dapat dipengaruhi oleh aplikasi itu sendiri.  Mereka bergantung pada beban pada sistem dan pada karakteristik lingkungan.  Misalnya, ini adalah fitur aplikasi itu sendiri, tingkat paralelisme dalam sistem, fitur penjadwal sistem operasi, fitur pengumpul sampah, dan sebagainya.  Selain itu, faktor-faktor ini, dari peluncuran ke peluncuran, dapat berubah. <br><br><h2>  <font color="#3AC1EF">Rekomendasi tentang pengaturan ukuran tumpukan Node.js untuk kasus-kasus ketika Anda dapat mengontrol opsi ini, tetapi tidak dengan pembatasan memori tingkat kontainer</font> </h2><br><ul><li>  Jalankan aplikasi Node.js minimum dalam wadah dan ukur ukuran RSS statis (dalam kasus saya, untuk Node.js 10.x, ini sekitar 20 Mb). </li><li>  Tumpukan Node.js tidak hanya berisi old_space, tetapi juga yang lain (seperti new_space, code_space, dan sebagainya).  Oleh karena itu, jika Anda mempertimbangkan konfigurasi standar platform, Anda harus mengandalkan fakta bahwa program tersebut akan membutuhkan sekitar 20 MB lebih banyak memori.  Jika pengaturan standar telah berubah, perubahan ini juga harus diperhitungkan. </li><li>  Sekarang kita perlu mengurangi nilai yang diperoleh (misalkan akan menjadi 40 MB) dari jumlah memori yang tersedia dalam wadah.  Apa yang tersisa adalah nilai yang, tanpa takut <code>--max-old-space-size</code> program kehabisan memori, dapat ditentukan sebagai nilai kunci - <code>--max-old-space-size</code> . </li></ul><br><h2>  <font color="#3AC1EF">Rekomendasi untuk mengatur batas memori kontainer untuk kasus-kasus di mana parameter ini dapat dikontrol, tetapi parameter aplikasi Node.js tidak</font> </h2><br><ul><li>  Jalankan aplikasi dalam mode yang memungkinkan Anda untuk mengetahui nilai puncak dari memori yang dikonsumsi. </li><li>  Analisis skor RSS.  Khususnya, di sini, bersama dengan metode <code>process.memoryUsage()</code> , perintah <code>top</code> Linux mungkin berguna. </li><li>  Asalkan dalam wadah di mana ia direncanakan untuk menjalankan aplikasi, tidak ada tetapi tidak akan dieksekusi, nilai yang diperoleh dapat digunakan sebagai batas memori kontainer.  Agar aman, disarankan untuk menambah setidaknya 10%. </li></ul><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Dalam Node.js 12.x, beberapa masalah yang dibahas di sini diselesaikan dengan menyesuaikan ukuran tumpukan secara adaptif, yang dilakukan sesuai dengan jumlah RAM yang tersedia.  Mekanisme ini juga berfungsi saat menjalankan aplikasi Node.js dalam wadah.  Tetapi pengaturan mungkin berbeda dari pengaturan standar.  Ini, misalnya, terjadi ketika kunci <code>--max_old_space_size</code> digunakan ketika memulai aplikasi.  Untuk kasus seperti itu, semua hal di atas tetap relevan.  Ini menunjukkan bahwa siapa pun yang menjalankan aplikasi Node.js dalam wadah harus berhati-hati dan bertanggung jawab tentang pengaturan memori.  Selain itu, pengetahuan tentang batas standar pada penggunaan memori, yang agak konservatif, dapat meningkatkan kinerja aplikasi dengan sengaja mengubah batas-batas ini. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda kehabisan masalah memori saat menjalankan aplikasi Node.js dalam wadah Docker? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454522/">https://habr.com/ru/post/id454522/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454512/index.html">Sarapan laporan dengan Charles Weatherly, penulis buku kultus Etudes for Programmer</a></li>
<li><a href="../id454514/index.html">Pengembangan synthesizer musik sederhana di ATMEGA8</a></li>
<li><a href="../id454516/index.html">Cara mendapatkan teks yang bagus untuk 200 rubel</a></li>
<li><a href="../id454518/index.html">Wasmer: perpustakaan Go tercepat untuk mengeksekusi kode WebAssembly</a></li>
<li><a href="../id454520/index.html">Pedoman untuk menulis kode JavaScript bersih</a></li>
<li><a href="../id454524/index.html">Perbaikan Ikat Kepala Samsung Level On Pro</a></li>
<li><a href="../id454530/index.html">DJI menciptakan octocopter yang dapat membuat film</a></li>
<li><a href="../id454532/index.html">Saya akan mengatakan sepatah kata pun tentang pendekatan rekayasa</a></li>
<li><a href="../id454534/index.html">Tidak ilmiah tentang monad</a></li>
<li><a href="../id454536/index.html">Amplifier ke sensor detak jantung klasik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>