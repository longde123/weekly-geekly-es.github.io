<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¢ üñïüèΩ ü§© √çndices no PostgreSQL - 5 (GiST) üç≥ üå† üë©üèº‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos artigos anteriores, discutimos o mecanismo de indexa√ß√£o do PostgreSQL, a interface dos m√©todos de acesso e dois m√©todos de acesso: √≠ndice de hash ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices no PostgreSQL - 5 (GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444742/">  Nos artigos anteriores, discutimos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de indexa√ß√£o do</a> PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a interface dos m√©todos de acesso</a> e dois m√©todos de acesso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndice de hash</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvore B.</a>  Neste artigo, descreveremos os √≠ndices GiST. <br><br><h1>  Gist </h1><br>  GiST √© uma abrevia√ß√£o de "√°rvore de pesquisa generalizada".  Esta √© uma √°rvore de pesquisa equilibrada, assim como "b-tree" discutido anteriormente. <br><br>  Qual a diferen√ßa?  O √≠ndice "Btree" est√° estritamente conectado √† sem√¢ntica da compara√ß√£o: suporte de operadores "maiores", "menos" e "iguais" √© tudo o que √© capaz (mas muito capaz!). No entanto, os bancos de dados modernos armazenam tipos de dados para os quais esses operadores simplesmente n√£o faz sentido: dados geogr√°ficos, documentos de texto, imagens, ... <br><br>  O m√©todo de √≠ndice GiST vem em nosso aux√≠lio para esses tipos de dados.  Permite definir uma regra para distribuir dados de um tipo arbitr√°rio por uma √°rvore balanceada e um m√©todo para usar essa representa√ß√£o para acesso de algum operador.  Por exemplo, o √≠ndice GiST pode "acomodar" a √°rvore R para dados espaciais com suporte de operadores de posi√ß√£o relativa (localizado √† esquerda, √† direita, cont√©m etc.) ou a √°rvore RD para conjuntos com suporte para operadores de interse√ß√£o ou inclus√£o. <br><br>  Gra√ßas √† extensibilidade, um m√©todo totalmente novo pode ser criado do zero no PostgreSQL: para esse fim, uma interface com o mecanismo de indexa√ß√£o deve ser implementada.  Mas isso requer premedita√ß√£o n√£o apenas da l√≥gica de indexa√ß√£o, mas tamb√©m do mapeamento de estruturas de dados para p√°ginas, implementa√ß√£o eficiente de bloqueios e suporte a um log write-ahead.  Tudo isso pressup√µe altas habilidades de desenvolvedor e um grande esfor√ßo humano.  O GiST simplifica a tarefa assumindo problemas de baixo n√≠vel e oferecendo sua pr√≥pria interface: v√°rias fun√ß√µes pertencentes n√£o √†s t√©cnicas, mas ao dom√≠nio do aplicativo.  Nesse sentido, podemos considerar o GiST como uma estrutura para a constru√ß√£o de novos m√©todos de acesso. <br><a name="habracut"></a><br><h2>  Estrutura </h2><br>  O GiST √© uma √°rvore com altura equilibrada que consiste em p√°ginas de n√≥s.  Os n√≥s consistem em linhas de √≠ndice. <br><br>  Cada linha de um n√≥ folha (linha folha), em geral, cont√©m algum <em>predicado</em> (express√£o booleana) e uma refer√™ncia a uma linha da tabela (TID).  Os dados indexados (chave) devem atender a esse predicado. <br><br>  Cada linha de um n√≥ interno (linha interna) tamb√©m cont√©m um <em>predicado</em> e uma refer√™ncia a um n√≥ filho, e todos os dados indexados da sub√°rvore filho devem atender a esse predicado.  Em outras palavras, o predicado de uma linha interna <em>inclui</em> os predicados de todas as linhas filhas.  Essa caracter√≠stica importante do √≠ndice GiST substitui a ordena√ß√£o simples da √°rvore B. <br><br>  A pesquisa na √°rvore do GiST usa uma <em>fun√ß√£o de consist√™ncia</em> especializada ("consistente") - uma das fun√ß√µes definidas pela interface e implementadas de maneira pr√≥pria para cada fam√≠lia de operadores suportada. <br><br>  A fun√ß√£o de consist√™ncia √© chamada para uma linha de √≠ndice e determina se o predicado dessa linha √© consistente com o predicado de pesquisa (especificado como " <em>express√£o do operador de campo indexado</em> ").  Para uma linha interna, essa fun√ß√£o realmente determina se √© necess√°rio descer para a sub√°rvore correspondente e, para uma linha folha, a fun√ß√£o determina se os dados indexados atendem ao predicado. <br><br>  A pesquisa come√ßa com um n√≥ raiz, como uma pesquisa em √°rvore normal.  A fun√ß√£o de consist√™ncia permite descobrir em quais n√≥s filhos faz sentido inserir (pode haver v√°rios deles) e quais n√£o.  O algoritmo √© ent√£o repetido para cada n√≥ filho encontrado.  E se o n√≥ for folha, a linha selecionada pela fun√ß√£o de consist√™ncia ser√° retornada como um dos resultados. <br><br>  A pesquisa √© aprofundada: o algoritmo primeiro tenta alcan√ßar um n√≥ folha.  Isso permite retornar os primeiros resultados em breve, sempre que poss√≠vel (o que pode ser importante se o usu√°rio estiver interessado apenas em v√°rios resultados e n√£o em todos). <br><br>  Vamos observar novamente que a fun√ß√£o de consist√™ncia n√£o precisa ter nada a ver com operadores "maiores", "menos" ou "iguais".  A sem√¢ntica da fun√ß√£o consistency pode ser bem diferente e, portanto, n√£o se sup√µe que o √≠ndice retorne valores em uma determinada ordem. <br><br>  N√£o discutiremos algoritmos de inser√ß√£o e exclus√£o de valores no GiST: mais algumas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fun√ß√µes de interface</a> executam essas opera√ß√µes.  H√° um ponto importante no entanto.  Quando um novo valor √© inserido no √≠ndice, a posi√ß√£o para esse valor na √°rvore √© selecionada para que os predicados de suas linhas pai sejam estendidos o m√≠nimo poss√≠vel (idealmente, n√£o estendidos).  Mas quando um valor √© exclu√≠do, o predicado da linha pai n√£o √© mais reduzido.  Isso acontece apenas em casos como estes: uma p√°gina √© dividida em duas (quando a p√°gina n√£o possui espa√ßo suficiente para inser√ß√£o de uma nova linha de √≠ndice) ou o √≠ndice √© recriado do zero (com o comando REINDEX ou VACUUM FULL).  Portanto, a efici√™ncia do √≠ndice GiST para alterar frequentemente os dados pode diminuir com o tempo. <br><br>  Al√©m disso, consideraremos alguns exemplos de √≠ndices para v√°rios tipos de dados e propriedades √∫teis do GiST: <br><br><ul><li>  Pontos (e outras entidades geom√©tricas) e busca dos vizinhos mais pr√≥ximos. </li><li>  Intervalos e restri√ß√µes de exclus√£o. </li><li>  Pesquisa de texto completo. </li></ul><br><h2>  √Årvore R para pontos </h2><br>  Ilustraremos o acima por exemplo de um √≠ndice de pontos em um plano (tamb√©m podemos construir √≠ndices semelhantes para outras entidades geom√©tricas).  Uma √°rvore B regular n√£o se adequa a esse tipo de dado, pois n√£o h√° operadores de compara√ß√£o definidos para pontos. <br><br>  A id√©ia da √°rvore R √© dividir o plano em ret√¢ngulos que, no total, cobrem todos os pontos indexados.  Uma linha de √≠ndice armazena um ret√¢ngulo, e o predicado pode ser definido assim: "o ponto procurado est√° dentro do ret√¢ngulo especificado". <br><br>  A raiz da √°rvore R conter√° v√°rios ret√¢ngulos maiores (possivelmente se cruzam).  Os n√≥s filhos conter√£o ret√¢ngulos de tamanho menor que s√£o incorporados no pai e no total cobrem todos os pontos subjacentes. <br><br>  Em teoria, os n√≥s folha devem conter pontos sendo indexados, mas o tipo de dados deve ser o mesmo em todas as linhas do √≠ndice e, portanto, novamente os ret√¢ngulos s√£o armazenados, mas "recolhidos" em pontos. <br><br>  Para visualizar essa estrutura, fornecemos imagens para tr√™s n√≠veis da √°rvore R.  Os pontos s√£o coordenadas de aeroportos (semelhantes √†s da tabela "aeroportos" do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">banco de dados demo</a> , mas s√£o fornecidos mais dados do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">openflights.org</a> ). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>N√≠vel um: dois ret√¢ngulos grandes que se cruzam s√£o vis√≠veis.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>N√≠vel dois: ret√¢ngulos grandes s√£o divididos em √°reas menores.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>N√≠vel tr√™s: cada ret√¢ngulo cont√©m quantos pontos cabem em uma p√°gina de √≠ndice.</em> <br><br>  Agora vamos considerar um exemplo muito simples de "n√≠vel √∫nico": <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(p);</code> </pre> <br>  Com essa divis√£o, a estrutura do √≠ndice ter√° a seguinte apar√™ncia: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  O √≠ndice criado pode ser usado para acelerar a seguinte consulta, por exemplo: "encontre todos os pontos contidos no ret√¢ngulo especificado".  Essa condi√ß√£o pode ser formalizada da seguinte maneira: <code>p &lt;@ box '(2,1),(6,3)'</code> (operador <code>&lt;@</code> da fam√≠lia "points_ops" significa "contido em"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using points_p_idx on points Index Cond: (p &lt;@ '(7,4),(2,1)'::box) (2 rows)</code> </pre><br>  A fun√ß√£o de consist√™ncia do operador (" <em>campo indexado</em> &lt;@ <em>express√£o</em> ", em que o <em>campo indexado</em> √© um ponto e a <em>express√£o</em> √© um ret√¢ngulo) √© definida da seguinte maneira.  Para uma linha interna, ele retorna "yes" se seu ret√¢ngulo cruzar com o ret√¢ngulo definido pela <em>express√£o</em> .  Para uma linha folha, a fun√ß√£o retornar√° "yes" se seu ponto (ret√¢ngulo "recolhido") estiver contido no ret√¢ngulo definido pela express√£o. <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  A pesquisa come√ßa com o n√≥ raiz.  O ret√¢ngulo (2,1) - (7,4) cruza com (1,1) - (6,3), mas n√£o cruza com (5,5) - (8,8), portanto, n√£o h√° necessidade para descer para a segunda sub√°rvore. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  Ao atingir um n√≥ folha, passamos pelos tr√™s pontos contidos nele e retornamos dois deles como resultado: (3.2) e (6.3). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (3,2) (6,3) (2 rows)</code> </pre><br><h3>  Internals </h3><br>  Infelizmente, o "pageinspect" habitual n√£o permite olhar para o √≠ndice GiST.  Mas outra maneira est√° dispon√≠vel: extens√£o "gevel".  N√£o est√° inclu√≠do na entrega padr√£o, portanto, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">as instru√ß√µes de instala√ß√£o</a> . <br><br>  Se tudo estiver certo, tr√™s fun√ß√µes estar√£o dispon√≠veis para voc√™.  Primeiro, podemos obter algumas estat√≠sticas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_stat(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_stat ------------------------------------------ Number of levels: 4 + Number of pages: 690 + Number of leaf pages: 625 + Number of tuples: 7873 + Number of invalid tuples: 0 + Number of leaf tuples: 7184 + Total size of tuples: 354692 bytes + Total size of leaf tuples: 323596 bytes + Total size of index: 5652480 bytes+ (1 row)</code> </pre><br>  √â claro que o tamanho do √≠ndice nas coordenadas do aeroporto √© de 690 p√°ginas e que o √≠ndice consiste em quatro n√≠veis: a raiz e dois n√≠veis internos foram mostrados nas figuras acima, e o quarto n√≠vel √© folha. <br><br>  Na verdade, o √≠ndice de oito mil pontos ser√° significativamente menor: aqui foi criado com um fator de preenchimento de 10% para maior clareza. <br><br>  Segundo, podemos gerar a √°rvore de √≠ndice: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_tree(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_tree ----------------------------------------------------------------------------------------- 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK) + 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK) + 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK) + 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK) + 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK) + 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK) + ...</code> </pre><br>  E terceiro, podemos gerar os dados armazenados nas linhas de √≠ndice.  Observe a seguinte nuance: o resultado da fun√ß√£o deve ser convertido no tipo de dados necess√°rio.  Na nossa situa√ß√£o, esse tipo √© "caixa" (um ret√¢ngulo delimitador).  Por exemplo, observe cinco linhas no n√≠vel superior: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------------------------------- 1 | (47.663586,80.803207),(-39.2938003540039,-90) 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) (5 rows)</code> </pre><br>  Na verdade, os n√∫meros fornecidos acima foram criados apenas a partir desses dados. <br><br><h2>  Operadores para pesquisa e pedidos </h2><br>  Os operadores discutidos at√© o momento (como <code>&lt;@</code> no predicado <code>p &lt;@ box '(2,1),(7,4)'</code> ) podem ser chamados de operadores de pesquisa, pois especificam condi√ß√µes de pesquisa em uma consulta. <br><br>  H√° tamb√©m outro tipo de operador: solicitar operadores.  Eles s√£o usados ‚Äã‚Äãpara especifica√ß√µes da ordem de classifica√ß√£o na cl√°usula ORDER BY, em vez de especifica√ß√µes convencionais de nomes de colunas.  A seguir, √© apresentado um exemplo dessa consulta: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (5,5) (7,8) (2 rows)</code> </pre><br>  <code>p &lt;-&gt; point '(4,7)'</code> aqui √© uma express√£o que usa um operador de pedidos <code>&lt;-&gt;</code> , que indica a dist√¢ncia de um argumento para o outro.  O significado da consulta √© retornar dois pontos mais pr√≥ximos ao ponto (4.7).  Uma pesquisa como essa √© conhecida como k-NN - pesquisa do vizinho mais pr√≥ximo. <br><br>  Para suportar consultas desse tipo, um m√©todo de acesso deve definir uma <em>fun√ß√£o de dist√¢ncia</em> adicional e o operador de pedidos deve ser inclu√≠do na classe de operadores apropriada (por exemplo, classe "points_ops" para pontos).  A consulta abaixo mostra os operadores, juntamente com seus tipos ("s" - pesquisa e "o" - ordena√ß√£o): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------+-------------+-------------- &lt;&lt;(point,point) | s | 1 strictly left &gt;&gt;(point,point) | s | 5 strictly right ~=(point,point) | s | 6 coincides &lt;^(point,point) | s | 10 strictly below &gt;^(point,point) | s | 11 strictly above &lt;-&gt;(point,point) | o | 15 distance &lt;@(point,box) | s | 28 contained in rectangle &lt;@(point,polygon) | s | 48 contained in polygon &lt;@(point,circle) | s | 68 contained in circle (9 rows)</code> </pre><br>  Os n√∫meros de estrat√©gias tamb√©m s√£o mostrados, com seus significados explicados.  √â claro que existem muito mais estrat√©gias do que para "btree", apenas algumas delas s√£o suportadas por pontos.  Diferentes estrat√©gias podem ser definidas para outros tipos de dados. <br><br>  A fun√ß√£o distance √© chamada para um elemento de √≠ndice e deve calcular a dist√¢ncia (levando em considera√ß√£o a sem√¢ntica do operador) do valor definido pela express√£o (" <em>express√£o de operador de ordena√ß√£o de campo indexado</em> ") para o elemento fornecido.  Para um elemento folha, essa √© apenas a dist√¢ncia do valor indexado.  Para um elemento interno, a fun√ß√£o deve retornar o m√≠nimo das dist√¢ncias para os elementos da folha filho.  Como percorrer todas as linhas filhas seria muito caro, √© permitido que a fun√ß√£o subestime otimisticamente a dist√¢ncia, mas √† custa de reduzir a efici√™ncia da pesquisa.  No entanto, a fun√ß√£o nunca pode superestimar a dist√¢ncia, pois isso interromper√° o trabalho do √≠ndice. <br><br>  A fun√ß√£o distance pode retornar valores de qualquer tipo classific√°vel (para ordenar valores, o PostgreSQL utilizar√° sem√¢ntica de compara√ß√£o da fam√≠lia de operadores apropriada do m√©todo de acesso "btree", conforme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descrito anteriormente</a> ). <br><br>  Para pontos em um plano, a dist√¢ncia √© interpretada em um sentido muito usual: o valor de <code>(x1,y1) &lt;-&gt; (x2,y2)</code> √© igual √† raiz quadrada da soma dos quadrados das diferen√ßas das abscissas e ordenadas.  A dist√¢ncia de um ponto a um ret√¢ngulo delimitador √© considerada a dist√¢ncia m√≠nima do ponto at√© esse ret√¢ngulo ou zero se o ponto estiver dentro do ret√¢ngulo.  √â f√°cil calcular esse valor sem percorrer os pontos filhos, e o valor certamente n√£o √© maior que a dist√¢ncia de qualquer ponto filho. <br><br>  Vamos considerar o algoritmo de pesquisa para a consulta acima. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  A pesquisa come√ßa com o n√≥ raiz.  O n√≥ cont√©m dois ret√¢ngulos delimitadores.  A dist√¢ncia de (1,1) - (6,3) √© 4,0 e de (5,5) - (8,8) √© 1,0. <br><br>  N√≥s filhos s√£o percorridos na ordem de aumentar a dist√¢ncia.  Dessa forma, primeiro descemos para o n√≥ filho mais pr√≥ximo e calculamos as dist√¢ncias para os pontos (mostraremos os n√∫meros na figura para visibilidade): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  Esta informa√ß√£o √© suficiente para retornar os dois primeiros pontos, (5,5) e (7,8).  Como sabemos que a dist√¢ncia para os pontos que est√£o dentro do ret√¢ngulo (1,1) - (6,3) √© de 4,0 ou superior, n√£o precisamos descer para o primeiro n√≥ filho. <br><br>  Mas e se precis√°ssemos encontrar os <em>tr√™s</em> primeiros pontos? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="pgsql hljs"> p <span class="hljs-comment"><span class="hljs-comment">------- (5,5) (7,8) (8,6) (3 rows)</span></span></code> </pre><br>  Embora o segundo n√≥ filho contenha todos esses pontos, n√£o podemos retornar (8,6) sem examinar o primeiro n√≥ filho, pois esse n√≥ pode conter pontos mais pr√≥ximos (desde 4,0 &lt;4,1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  Para linhas internas, este exemplo esclarece os requisitos para a fun√ß√£o de dist√¢ncia.  Ao selecionar uma dist√¢ncia menor (4,0 em vez de 4,5 reais) para a segunda linha, reduzimos a efici√™ncia (o algoritmo come√ßou desnecessariamente a examinar um n√≥ extra), mas n√£o quebramos a corre√ß√£o do algoritmo. <br><br>  At√© recentemente, o GiST era o √∫nico m√©todo de acesso capaz de lidar com operadores de pedidos.  Mas a situa√ß√£o mudou: o m√©todo de acesso ao RUM (a ser discutido mais adiante) j√° se juntou a esse grupo de m√©todos, e n√£o √© improv√°vel que a boa e velha √°rvore B se junte a eles: um patch desenvolvido por Nikita Glukhov, nossa colega, est√° sendo discutido pela comunidade. <br><blockquote>  A partir de mar√ßo de 2019, o suporte ao k-NN ser√° adicionado ao SP-GiST no pr√≥ximo PostgreSQL 12 (tamb√©m de autoria da Nikita).  O patch para a √°rvore B ainda est√° em andamento. <br></blockquote><br><h2>  √Årvore R para intervalos </h2><br>  Outro exemplo do uso do m√©todo de acesso GiST √© a indexa√ß√£o de intervalos, por exemplo, intervalos de tempo (tipo "tsrange").  Toda a diferen√ßa √© que os n√≥s internos conter√£o intervalos delimitadores, em vez de ret√¢ngulos delimitadores. <br><br>  Vamos considerar um exemplo simples.  Vamos alugar uma casa de campo e armazenar intervalos de reserva em uma tabela: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations(during <span class="hljs-type"><span class="hljs-type">tsrange</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2016-12-30, 2017-01-09)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-02-23, 2017-02-27)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-04-29, 2017-05-02)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during);</code> </pre><br>  O √≠ndice pode ser usado para acelerar a seguinte consulta, por exemplo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> during ----------------------------------------------- ["2016-12-30 00:00:00","2017-01-08 00:00:00") ["2017-02-23 00:00:00","2017-02-26 00:00:00") (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Index Only Scan using reservations_during_idx on reservations Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) (2 rows)</code> </pre><br>  <code>&amp;&amp;</code> operador <code>&amp;&amp;</code> para intervalos indica interse√ß√£o;  portanto, a consulta deve retornar todos os intervalos que se cruzam com o determinado.  Para esse operador, a fun√ß√£o de consist√™ncia determina se o intervalo especificado cruza com um valor em uma linha interna ou folha. <br><br>  Observe que n√£o se trata de obter intervalos em uma determinada ordem, embora os operadores de compara√ß√£o estejam definidos para intervalos.  Podemos usar o √≠ndice "btree" para intervalos, mas, neste caso, teremos que ficar sem o suporte de opera√ß√µes como estas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'range_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------------+-------------+-------------- @&gt;(anyrange,anyelement) | s | 16 contains element &lt;&lt;(anyrange,anyrange) | s | 1 strictly left &amp;&lt;(anyrange,anyrange) | s | 2 not beyond right boundary &amp;&amp;(anyrange,anyrange) | s | 3 intersects &amp;&gt;(anyrange,anyrange) | s | 4 not beyond left boundary &gt;&gt;(anyrange,anyrange) | s | 5 strictly right -|-(anyrange,anyrange) | s | 6 adjacent @&gt;(anyrange,anyrange) | s | 7 contains interval &lt;@(anyrange,anyrange) | s | 8 contained in interval =(anyrange,anyrange) | s | 18 equals (10 rows)</code> </pre><br>  (Exceto a igualdade, que est√° contida na classe do operador para o m√©todo de acesso "btree"). <br><br><h3>  Internals </h3><br>  Podemos olhar para dentro usando a mesma extens√£o "gevel".  S√≥ precisamos lembrar de alterar o tipo de dados na chamada para gist_print: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'reservations_during_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">tsrange</span></span>);</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------- 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") (3 rows)</code> </pre><br><h2>  Restri√ß√£o de exclus√£o </h2><br>  O √≠ndice GiST pode ser usado para suportar restri√ß√µes de exclus√£o (EXCLUDE). <br><br>  A restri√ß√£o de exclus√£o garante que determinados campos de duas linhas da tabela n√£o "correspondam" entre si em termos de alguns operadores.  Se o operador "igual" for escolhido, obteremos exatamente a restri√ß√£o exclusiva: os campos de duas linhas n√£o s√£o iguais. <br><br>  A restri√ß√£o de exclus√£o √© suportada pelo √≠ndice, bem como a restri√ß√£o exclusiva.  Podemos escolher qualquer operador para que: <br><br><ol><li>  √â suportado pelo m√©todo de √≠ndice - propriedade "can_exclude" (por exemplo, "btree", GiST ou SP-GiST, mas n√£o GIN). </li><li>  √â comutativo, ou seja, a condi√ß√£o √© atendida: a operador b = b operador a. </li></ol><br>  Esta √© uma lista de estrat√©gias e exemplos adequados de operadores (os operadores, como lembramos, podem ter nomes diferentes e estar dispon√≠veis para todos os tipos de dados): <br><br><ul><li>  Para "btree": <br><ul><li>  "Igual" <code>=</code> </li></ul></li><li>  Para GiST e SP-GiST: <br><ul><li>  "Interse√ß√£o" <code>&amp;&amp;</code> </li><li>  "Coincid√™ncia" <code>~=</code> </li><li>  Adjac√™ncia <code>-|-</code> </li></ul></li></ul><br>  Observe que podemos usar o operador de igualdade em uma restri√ß√£o de exclus√£o, mas √© impratic√°vel: uma restri√ß√£o exclusiva ser√° mais eficiente.  √â exatamente por isso que n√£o abordamos as restri√ß√µes de exclus√£o quando discutimos as √°rvores-B. <br><br>  Vamos dar um exemplo do uso de uma restri√ß√£o de exclus√£o.  √â razo√°vel n√£o permitir reservas para intervalos de interse√ß√£o. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;);</code> </pre><br>  Depois de criar a restri√ß√£o de exclus√£o, podemos adicionar linhas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-06-10, 2017-06-13)'</span></span>);</code> </pre><br>  Mas uma tentativa de inserir um intervalo de interse√ß√£o na tabela resultar√° em um erro: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")).</code> </pre><br><h3>  Extens√£o "Btree_gist" </h3><br>  Vamos complicar o problema.  Expandimos nossos humildes neg√≥cios e vamos alugar v√°rios chal√©s: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> house_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Precisamos alterar a restri√ß√£o de exclus√£o para que os n√∫meros das casas sejam levados em considera√ß√£o.  O GiST, no entanto, n√£o suporta a opera√ß√£o de igualdade para n√∫meros inteiros: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> reservations_during_excl; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type integer has no default operator class for access method "gist" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Nesse caso, a extens√£o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">btree_gist</a> " ajudar√°, o que adiciona o suporte do GiST √†s opera√ß√µes inerentes √†s √°rvores B.  O GiST, eventualmente, pode oferecer suporte a qualquer operador, ent√£o por que n√£o devemos ensin√°-lo a oferecer suporte a operadores "maiores", "menos" e "iguais"? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gist; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><br>  Agora ainda n√£o podemos reservar o primeiro chal√© para as mesmas datas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl"</code> </pre><br>  No entanto, podemos reservar o segundo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Mas esteja ciente de que, embora o GiST possa de alguma forma oferecer suporte a operadores "maiores", "menos" e "iguais", a B-tree ainda faz isso melhor.  Portanto, vale a pena usar essa t√©cnica apenas se o √≠ndice GiST for essencialmente necess√°rio, como em nosso exemplo. <br><br><h2>  √Årvore RD para pesquisa de texto completo </h2><br><h3>  Sobre a pesquisa de texto completo </h3><br>  Vamos come√ßar com uma introdu√ß√£o minimalista √† pesquisa de texto completo do PostgreSQL (se voc√™ souber, pode pular esta se√ß√£o). <br><br>  A tarefa da pesquisa de texto completo √© selecionar no conjunto de documentos os documentos que <em>correspondem</em> √† consulta de pesquisa.  (Se houver muitos documentos correspondentes, √© importante encontrar <em>a melhor correspond√™ncia</em> , mas n√£o falaremos sobre isso neste momento.) <br><br>  Para fins de pesquisa, um documento √© convertido em um tipo especializado "tsvector", que cont√©m <em>lexemes</em> e suas posi√ß√µes no documento.  Lexemes s√£o palavras convertidas para o formato adequado para pesquisa.  Por exemplo, as palavras s√£o normalmente convertidas em min√∫sculas e as termina√ß√µes vari√°veis ‚Äã‚Äãs√£o cortadas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector ----------------------------------------- 'crook':4,10 'man':5 'mile':11 'walk':8 (1 row)</code> </pre><br>  Tamb√©m podemos ver que algumas palavras (chamadas de <em>palavras de parada</em> ) s√£o totalmente descartadas ("l√°", "era", "a", "e", "ele"), pois presumivelmente ocorrem com muita frequ√™ncia para que as pesquisas fa√ßam sentido.  Todas essas convers√µes certamente podem ser configuradas, mas isso √© outra hist√≥ria. <br><br>  Uma consulta de pesquisa √© representada com outro tipo: "tsquery".  Grosso modo, uma consulta consiste em um ou v√°rios lexemas articulados por conectivos: "e" &amp; "ou" |, "not"! .. Tamb√©m podemos usar par√™nteses para esclarecer a preced√™ncia da opera√ß√£o. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsquery ---------------------------- 'man' &amp; ( 'walk' | 'run' ) (1 row)</code> </pre><br>  Apenas um operador de correspond√™ncia <code>@@</code> √© usado para pesquisa de texto completo. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (going | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- f (1 row)</code> </pre><br>  Esta informa√ß√£o √© suficiente por enquanto.  Vamos nos aprofundar um pouco mais na pesquisa de texto completo em um pr√≥ximo artigo que apresenta o √≠ndice GIN. <br><br><h3>  √Årvores RD </h3><br>  Para uma pesquisa r√°pida de texto completo, primeiro, a tabela precisa armazenar uma coluna do tipo "tsvector" (para evitar a realiza√ß√£o de uma convers√£o dispendiosa sempre que pesquisar) e, em segundo lugar, um √≠ndice deve ser criado nessa coluna.  Um dos m√©todos de acesso poss√≠veis para isso √© o GiST. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(doc_tsv); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc);</code> </pre><br>  Certamente, √© conveniente confiar um gatilho na √∫ltima etapa (convers√£o do documento em "tsvector"). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------------------------------------------------- doc | Can a sheet slitter slit sheets? doc_tsv | 'sheet':3,6 'slit':5 'slitter':4 -[ RECORD 2 ]---------------------------------------------------- doc | How many sheets could a sheet slitter slit? doc_tsv | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 -[ RECORD 3 ]---------------------------------------------------- doc | I slit a sheet, a sheet I slit. doc_tsv | 'sheet':4,6 'slit':2,8 -[ RECORD 4 ]---------------------------------------------------- doc | Upon a slitted sheet I sit. doc_tsv | 'sheet':4 'sit':6 'slit':3 'upon':1 -[ RECORD 5 ]---------------------------------------------------- doc | Whoever slit the sheets is a good sheet slitter. doc_tsv | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 -[ RECORD 6 ]---------------------------------------------------- doc | I am a sheet slitter. doc_tsv | 'sheet':4 'slitter':5 -[ RECORD 7 ]---------------------------------------------------- doc | I slit sheets. doc_tsv | 'sheet':3 'slit':2 -[ RECORD 8 ]---------------------------------------------------- doc | I am the sleekest sheet slitter that ever slit sheets. doc_tsv | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 -[ RECORD 9 ]---------------------------------------------------- doc | She slits the sheet she sits on. doc_tsv | 'sheet':4 'sit':6 'slit':2</code> </pre><br>  Como o √≠ndice deve ser estruturado?  O uso da √°rvore R diretamente n√£o √© uma op√ß√£o, pois n√£o est√° claro como definir um "ret√¢ngulo delimitador" para documentos.  Mas podemos aplicar alguma modifica√ß√£o dessa abordagem para conjuntos, uma √°rvore chamada RD (RD significa "Russian Doll").  Um conjunto √© entendido como um conjunto de lexemas nesse caso, mas, em geral, um conjunto pode ser qualquer um. <br><br>  Uma id√©ia das √°rvores RD √© substituir um ret√¢ngulo delimitador por um conjunto delimitador, ou seja, um conjunto que contenha todos os elementos dos conjuntos filhos. <br><br>  Uma quest√£o importante surge como representar conjuntos nas linhas de √≠ndice.  A maneira mais direta √© apenas enumerar todos os elementos do conjunto.  Isso pode parecer da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/cp/ul/cx/cpulcxgydwxo8fl0ul0bdlsn3ws.png"><br><br>  Ent√£o, por exemplo, para acessar pela condi√ß√£o <code>doc_tsv @@ to_tsquery('sit')</code> , poder√≠amos descer apenas para os n√≥s que cont√™m o <code>doc_tsv @@ to_tsquery('sit')</code> ‚Äúsit‚Äù: <br><br><img src="https://habrastorage.org/webt/h9/2g/4j/h92g4jpzw_7wj-x3katxlwrw3ac.png"><br><br>  Essa representa√ß√£o tem quest√µes evidentes.  O n√∫mero de lexemes em um documento pode ser bastante grande, portanto, as linhas de √≠ndice ter√£o um tamanho grande e entrar√£o no TOAST, tornando o √≠ndice muito menos eficiente.  Mesmo que cada documento tenha poucos lexemes exclusivos, a uni√£o de conjuntos ainda pode ser muito grande: quanto maior a raiz, maiores as linhas de √≠ndice. <br><br>  √Äs vezes, uma representa√ß√£o como essa √© usada, mas para outros tipos de dados.  E a pesquisa de texto completo usa outra solu√ß√£o mais compacta - a chamada <em>√°rvore de assinaturas</em> .  Sua id√©ia √© bastante familiar para todos os que lidaram com o filtro Bloom. <br><br>  Cada l√©xico pode ser representado com sua <em>assinatura</em> : uma sequ√™ncia de bits de um determinado comprimento em que todos os bits, exceto um, s√£o zero.  A posi√ß√£o desse bit √© determinada pelo valor da fun√ß√£o hash do l√©xico (discutimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriormente as</a> fun√ß√µes hash <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriormente</a> ). <br><br>  A assinatura do documento √© o OR bit a bit das assinaturas de todos os lexemes do documento. <br><br>  Vamos assumir as seguintes assinaturas de lexemes: <br><br><pre> poderia 1.000.000
 ever 0001000
 good 0000010
 mani 0000100
 folha 0000100
 0100000
 sit 0010000
 fenda 0001000
 talhadeira 0000001
 upon 0000010
 quem quer que seja 0010000
</pre><br>  Em seguida, as assinaturas dos documentos s√£o assim: <br><br><pre> Uma folha pode cortar folhas de fenda?  0001101
 Quantas folhas uma talhadeira poderia cortar?  1001101
 Eu corto uma folha, uma folha eu corto.  0001100
 Sobre um len√ßol cortado, eu sento.  0011110
 Quem corta os len√ß√≥is √© um bom cortador de folhas.  0011111
 Eu sou um cortador de folhas.  0000101
 Eu corto len√ß√≥is.  0001100
 Eu sou o cortador de folhas mais elegante que j√° cortou folhas.  0101101
 Ela corta o len√ßol em que se senta.  0011100
</pre><br>  A √°rvore de √≠ndice pode ser representada da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/ou/f9/gz/ouf9gz7l7wgmgmgzi5gik7nrg50.png"><br><br>  As vantagens dessa abordagem s√£o evidentes: as linhas de √≠ndice t√™m tamanhos pequenos iguais e esse √≠ndice √© compacto.  Mas uma desvantagem tamb√©m √© clara: a precis√£o √© sacrificada √† compacidade. <br><br>  Vamos considerar a mesma condi√ß√£o <code>doc_tsv @@ to_tsquery('sit')</code> .  E vamos calcular a assinatura da consulta de pesquisa da mesma maneira que no documento: 0010000, neste caso.  A fun√ß√£o de consist√™ncia deve retornar todos os n√≥s filhos cujas assinaturas cont√™m pelo menos um bit da assinatura da consulta: <br><br><img src="https://habrastorage.org/webt/qi/qm/l4/qiqml4l5yu8_qiyvidk-3j8iqhs.png"><br><br>  Compare com a figura acima: podemos ver que a √°rvore ficou amarela, o que significa que falsos positivos ocorrem e n√≥s excessivos s√£o percorridos durante a pesquisa.  Aqui n√≥s escolhemos "quem quer que seja" lexeme, cuja assinatura infelizmente era a mesma que a assinatura de "sit" lexeme.  √â importante que nenhum falso negativo possa ocorrer no padr√£o, ou seja, temos certeza de que n√£o perderemos os valores necess√°rios. <br><br>  Al√©m disso, pode acontecer que documentos diferentes tamb√©m obtenham as mesmas assinaturas: em nosso exemplo, documentos azarados s√£o "Eu corto uma folha, uma folha eu corto" e "Eu corto folhas" (ambos t√™m a assinatura 0001100).  E se uma linha de √≠ndice folha n√£o armazena o valor de "tsvector", o pr√≥prio √≠ndice fornecer√° falsos positivos.  Obviamente, nesse caso, o m√©todo solicitar√° que o mecanismo de indexa√ß√£o verifique novamente o resultado com a tabela, para que o usu√°rio n√£o veja esses falsos positivos.  Mas a efici√™ncia da pesquisa pode ficar comprometida. <br><br>  Na verdade, uma assinatura tem 124 bytes de largura na implementa√ß√£o atual, em vez de 7 bits nas figuras, portanto, os problemas acima t√™m muito menos probabilidade de ocorrer do que no exemplo.  Mas, na realidade, muito mais documentos s√£o indexados tamb√©m.  Para reduzir de alguma forma o n√∫mero de falsos positivos do m√©todo index, a implementa√ß√£o fica um pouco complicada: o "tsvector" indexado √© armazenado em uma linha de √≠ndice folha, mas apenas se seu tamanho n√£o for grande (um pouco menos de 1/16 de uma p√°gina, com cerca de meio kilobyte para p√°ginas de 8 KB). <br><br><h3>  Exemplo </h3><br>  Para ver como a indexa√ß√£o funciona com dados reais, vamos usar o arquivo do email "pgsql-hackers".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A vers√£o usada no exemplo</a> cont√©m 356125 mensagens com a data de envio, assunto, autor e texto: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------------------------------------------------------------ id | 1572389 parent_id | 1562808 sent | 1997-06-24 11:31:09 subject | Re: [HACKERS] Array bug is still there.... author | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; body_plain | Andrew Martin wrote: + | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + | &gt; is still there. The regression test passes because the expected output+ | &gt; has been fixed to the *wrong* output. + | + | OK, I think I understand the current array behavior, which is apparently+ | different than the behavior for v1.0x. + ...</code> </pre><br>  Adicionando e preenchendo a coluna do tipo "tsvector" e construindo o √≠ndice.  Aqui, juntaremos tr√™s valores em um vetor (assunto, autor e texto da mensagem) para mostrar que o documento n√£o precisa ser um campo, mas pode consistir em partes arbitr√°rias totalmente diferentes. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(subject||<span class="hljs-string"><span class="hljs-string">' '</span></span>||author||<span class="hljs-string"><span class="hljs-string">' '</span></span>||body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Como podemos ver, um certo n√∫mero de palavras foi descartado devido ao tamanho muito grande.  Mas o √≠ndice acabou sendo criado e pode suportar consultas de pesquisa: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'magic &amp; value'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------- Index Scan using mail_messages_tsv_idx on mail_messages (actual time=0.998..416.335 rows=898 loops=1) Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) Rows Removed by Index Recheck: 7859 Planning time: 0.203 ms Execution time: 416.492 ms (5 rows)</code> </pre><br>  Podemos ver que, juntamente com 898 linhas correspondentes √† condi√ß√£o, o m√©todo de acesso retornou 7859 linhas a mais que foram filtradas ao verificar novamente a tabela.  Isso demonstra um impacto negativo da perda de precis√£o na efici√™ncia. <br><br><h3>  Internals </h3><br>  Para analisar o conte√∫do do √≠ndice, usaremos novamente a extens√£o "gevel": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a gtsvector) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+------------------------------- 1 | 992 true bits, 0 false bits 2 | 988 true bits, 4 false bits 3 | 573 true bits, 419 false bits 4 | 65 unique words 4 | 107 unique words 4 | 64 unique words 4 | 42 unique words ...</code> </pre><br>  Valores do tipo especializado "gtsvector" que s√£o armazenados nas linhas de √≠ndice s√£o na verdade a assinatura mais, talvez, a fonte "tsvector".  Se o vetor estiver dispon√≠vel, a sa√≠da conter√° o n√∫mero de lexemas (palavras exclusivas), caso contr√°rio, o n√∫mero de bits verdadeiros e falsos na assinatura. <br><br>  √â claro que, no n√≥ raiz, a assinatura degenerou para "todos", ou seja, um n√≠vel de √≠ndice tornou-se absolutamente in√∫til (e mais um tornou-se quase in√∫til, com apenas quatro bits falsos). <br><br><h2>  Propriedades </h2><br>  Vejamos as propriedades do m√©todo de acesso do GiST (as consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">foram fornecidas anteriormente</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gist | can_order | f gist | can_unique | f gist | can_multi_col | t gist | can_exclude | t</code> </pre><br>  A classifica√ß√£o de valores e a restri√ß√£o exclusiva n√£o s√£o suportadas.  Como vimos, o √≠ndice pode ser constru√≠do em v√°rias colunas e usado em restri√ß√µes de exclus√£o. <br><br>  As seguintes propriedades da camada de √≠ndice est√£o dispon√≠veis: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  E as propriedades mais interessantes s√£o as da camada da coluna.  Algumas das propriedades s√£o independentes das classes de operadores: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f search_array | f search_nulls | t</code> </pre><br>  (A classifica√ß√£o n√£o √© suportada; o √≠ndice n√£o pode ser usado para pesquisar uma matriz; NULLs s√£o suportados.) <br><br>  Mas as duas propriedades restantes, "distance_orderable" e "returnable", depender√£o da classe de operador usada.  Por exemplo, para pontos, obteremos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | t returnable | t</code> </pre><br>  A primeira propriedade informa que o operador de dist√¢ncia est√° dispon√≠vel para busca dos vizinhos mais pr√≥ximos.  E o segundo diz que o √≠ndice pode ser usado para verifica√ß√£o apenas de √≠ndice.  Embora as linhas de √≠ndice folha armazenem ret√¢ngulos em vez de pontos, o m√©todo de acesso pode retornar o que √© necess√°rio. <br><br>  A seguir est√£o as propriedades para intervalos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | t</code> </pre><br>  Para intervalos, a fun√ß√£o de dist√¢ncia n√£o √© definida e, portanto, a pesquisa dos vizinhos mais pr√≥ximos n√£o √© poss√≠vel. <br><br>  E para a pesquisa de texto completo, obtemos: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | f</code> </pre><br>  O suporte √† varredura apenas de √≠ndice foi perdido, pois as linhas folha podem conter apenas a assinatura sem os pr√≥prios dados.  No entanto, essa √© uma pequena perda, pois ningu√©m est√° interessado no valor do tipo "tsvector" de qualquer maneira: esse valor √© usado para selecionar linhas, enquanto √© o texto de origem que precisa ser mostrado, mas est√° ausente no √≠ndice. <br><br><h2>  Outros tipos de dados </h2><br>  Por fim, mencionaremos mais alguns tipos atualmente suportados pelo m√©todo de acesso GiST, al√©m dos tipos geom√©tricos j√° discutidos (por exemplo de pontos), intervalos e tipos de pesquisa de texto completo. <br><br>  Dos tipos padr√£o, este √© o tipo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inet</a> " para endere√ßos IP.  Todo o resto √© adicionado atrav√©s de extens√µes: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cubo</a> fornece o tipo de dados "cubo" para cubos multidimensionais.  Para este tipo, assim como para os tipos geom√©tricos em um plano, a classe de operador GiST √© definida: R-tree, suportando a pesquisa dos vizinhos mais pr√≥ximos. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seg</a> fornece o tipo de dados "seg" para intervalos com limites especificados com uma certa precis√£o e adiciona suporte ao √≠ndice GiST para esse tipo de dados (√°rvore R). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O intarray</a> estende a funcionalidade de matrizes inteiras e adiciona suporte ao GiST para elas.  Duas classes de operadores s√£o implementadas: "gist__int_ops" (√°rvore RD com uma representa√ß√£o completa das chaves nas linhas de √≠ndice) e "gist__bigint_ops" (√°rvore RD assinatura).  A primeira classe pode ser usada para matrizes pequenas e a segunda - para tamanhos maiores. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O ltree</a> adiciona o tipo de dados "ltree" para estruturas semelhantes a √°rvores e o suporte do GiST para esse tipo de dados (RD-tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O pg_trgm</a> adiciona uma classe de operador especializada "gist_trgm_ops" para o uso de trigramas na pesquisa de texto completo.  Mas isso deve ser discutido mais adiante, junto com o √≠ndice GIN. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444742/">https://habr.com/ru/post/pt444742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt444728/index.html">Como escrevi e publiquei um livro sobre a Universidade Estatal de Moscou, ou 12 erros cr√≠ticos</a></li>
<li><a href="../pt444730/index.html">Por que a tecnologia sem servidor √© uma revolu√ß√£o no gerenciamento de produtos</a></li>
<li><a href="../pt444732/index.html">Otimiza√ß√£o de desempenho apache2</a></li>
<li><a href="../pt444734/index.html">Habraseminar: hist√≥rias reais sobre marketing de conte√∫do</a></li>
<li><a href="../pt444738/index.html">Pixel art: do rascunho ao material do jogo</a></li>
<li><a href="../pt444744/index.html">Enviando email usando PHP</a></li>
<li><a href="../pt444746/index.html">Convidamos voc√™ para o MskDotNet Meetup # 34 em Raiffeisenbank upd Broadcast</a></li>
<li><a href="../pt444748/index.html">3 qualidades-chave de um gerente de produto de sucesso: Yuri Golikov, vice-presidente de engenharia Wrike</a></li>
<li><a href="../pt444752/index.html">A hist√≥ria do SXSW: como tudo come√ßou</a></li>
<li><a href="../pt444756/index.html">DARPA desenvolver√° um motor nuclear de foguete</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>