<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌑 📁 📙 Wir pumpen React Hooks mit FRP 👃🏿 👩🏽‍🚒 👨🏽‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele React-Entwickler haben die Hooks gemeistert und Euphorie erlebt. Schließlich haben sie ein einfaches und praktisches Toolkit erhalten, mit dem S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir pumpen React Hooks mit FRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445214/"><p>  Viele React-Entwickler haben die Hooks gemeistert und Euphorie erlebt. Schließlich haben sie ein einfaches und praktisches Toolkit erhalten, mit dem Sie Aufgaben mit deutlich weniger Code implementieren können.  Aber bedeutet dies, dass die standardmäßig angebotenen Hooks useState und useReducer alles sind, was wir zur Verwaltung des Status benötigen? </p><br><p>  Meiner Meinung nach ist ihre Verwendung in ihrer Rohform nicht sehr bequem, sie können eher als Grundlage für den Aufbau wirklich praktischer Haken für das Staatsmanagement angesehen werden.  Reagieren Entwickler selbst stark auf die Entwicklung von benutzerdefinierten Hooks. Warum also nicht?  Unter dem Schnitt werden wir uns ein sehr einfaches und verständliches Beispiel ansehen, was mit gewöhnlichen Haken nicht stimmt und wie sie verbessert werden können, so dass sie sich völlig weigern, sie in ihrer reinen Form zu verwenden. </p><a name="habracut"></a><br><p>  Es gibt ein bestimmtes Feld für die Eingabe, bedingt einen Namen.  Und es gibt eine Schaltfläche durch Klicken, auf die wir eine Anfrage an den Server mit dem eingegebenen Namen stellen sollen (eine bestimmte Suche).  Es scheint, dass das einfacher sein könnte?  Die Lösung ist jedoch alles andere als offensichtlich.  Die erste naive Implementierung: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  Was ist hier falsch?  Wenn der Benutzer, der etwas in das Feld eingibt, das Formular zweimal sendet, funktioniert nur die erste Anfrage für uns, weil  Beim zweiten Klick ändert sich die Anforderung nicht und useEffect funktioniert nicht.  Wenn Sie sich vorstellen, dass es sich bei unserer Anwendung um einen Ticketsuchdienst handelt und der Benutzer das Formular möglicherweise in bestimmten Abständen immer wieder sendet, ohne Änderungen vorzunehmen, funktioniert eine solche Implementierung bei uns nicht!  Die Verwendung des Namens als Abhängigkeit für useEffect ist ebenfalls nicht akzeptabel. Andernfalls wird das Formular sofort gesendet, wenn sich der Text ändert.  Nun, man muss Einfallsreichtum zeigen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Jetzt ändern wir mit jedem Klick die Bedeutung der Anfrage in das Gegenteil, wodurch das gewünschte Verhalten erreicht wird.  Dies ist eine sehr kleine und unschuldige Krücke, aber es macht den Code etwas verwirrend zu verstehen.  Vielleicht scheint es Ihnen jetzt, dass ich das Problem aus meinem Finger sauge und seine Skala aufblase.  Um zu beantworten, ob es wahr ist oder nicht, müssen Sie diesen Code mit anderen Implementierungen vergleichen, die einen aussagekräftigeren Ansatz bieten. </p><br><p>  Schauen wir uns dieses Beispiel auf theoretischer Ebene unter Verwendung der Thread-Abstraktion an.  Es ist sehr praktisch, um den Status von Benutzeroberflächen zu beschreiben.  Wir haben also zwei Streams: Daten, die in das Textfeld eingegeben wurden (Name $), und einen Stream von Klicks auf die Schaltfläche zum Senden des Formulars (klicken Sie auf $).  Aus ihnen müssen wir einen dritten, kombinierten Strom von Anfragen an den Server erstellen. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Hier ist das Verhalten, das wir erreichen müssen.  Jeder Stream hat zwei Aspekte: den Wert, den er hat, und den Zeitpunkt, zu dem Werte durch ihn fließen.  In verschiedenen Situationen benötigen wir möglicherweise den einen oder anderen Aspekt oder beides.  Sie können dies mit dem Rhythmus und der Harmonie in der Musik vergleichen.  Streams, für die nur die Antwortzeit wesentlich ist, werden auch als Signale bezeichnet. </p><br><p>  In unserem Fall ist click $ ein reines Signal: Es spielt keine Rolle, welcher Wert durch das Signal fließt (undefiniert / true / Event / was auch immer), es ist nur dann wichtig, wenn dies geschieht.  Fallname $ <br>  das Gegenteil: Seine Änderungen haben in keiner Weise Änderungen im System zur Folge, aber wir brauchen möglicherweise irgendwann seine Bedeutung.  Und aus diesen beiden Strömen müssen wir den dritten machen, indem wir vom ersten zum zweiten Wert nehmen. </p><br><p>  Im Fall von Rxjs haben wir dafür einen fast vorgefertigten Operator: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  Die praktische Verwendung von Rx in React kann jedoch recht unpraktisch sein.  Eine geeignetere Option ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mrr-</a> Bibliothek, die auf den gleichen funktional-reaktiven Prinzipien wie Rx basiert, jedoch speziell für die Verwendung mit React nach dem Prinzip der "Gesamtreaktivität" angepasst und als Haken verbunden ist. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Die useMrr-Schnittstelle ähnelt useState oder useReducer: Sie gibt ein Statusobjekt (Werte aller Threads) und einen Setter zurück, um Werte in Threads einzufügen.  Aber im Inneren ist alles etwas anders: Jedes Statusfeld (= Stream), mit Ausnahme derjenigen, in die wir Werte direkt aus den DOM-Ereignissen eingeben, wird durch eine Funktion und eine Liste übergeordneter Threads beschrieben, deren Änderung dazu führt, dass das untergeordnete Element neu berechnet wird.  In diesem Fall werden die Werte der übergeordneten Threads in die Funktion eingesetzt.  Wenn wir nur den Wert des Streams abrufen möchten, aber nicht auf seine Änderung reagieren möchten, schreiben wir wie im Fall des Namens ein "Minus" vor den Namen. </p><br><p>  Wir haben das gewünschte Verhalten im Wesentlichen in einer Zeile.  Dies ist jedoch nicht nur Kürze.  Vergleichen wir die erhaltenen Ergebnisse detaillierter und zunächst in Bezug auf einen Parameter wie Lesbarkeit und Klarheit des resultierenden Codes. </p><br><p>  In mrr können Sie die "Logik" vollständig von der "Vorlage" trennen: Sie müssen keine komplexen imperativen Handler in JSX schreiben.  Alles ist äußerst deklarativ: Wir ordnen das DOM-Ereignis einfach praktisch ohne Konvertierung dem entsprechenden Stream zu (für Eingabefelder wird der Wert e.target.value automatisch extrahiert, sofern Sie nichts anderes angeben), und bereits in der useMrr-Struktur beschreiben wir, wie die Basisflüsse gebildet werden Tochterunternehmen.  Somit können wir sowohl bei synchronen als auch bei asynchronen Datentransformationen immer leicht verfolgen, wie unser Wert gebildet wird. </p><br><p>  Vergleich mit Px: Wir mussten nicht einmal zusätzliche Operatoren verwenden: Wenn die mrr-Funktionen als Ergebnis ein Versprechen erhalten, warten sie automatisch, bis sie aufgelöst werden, und fügen die empfangenen Daten in den Stream ein.  Außerdem haben wir anstelle von withLatestFrom verwendet <br>  passives Hören (Minuszeichen), was bequemer ist.  Stellen Sie sich vor, wir müssen neben dem Namen auch andere Felder senden.  Dann werden wir in mrr einen weiteren passiv hörenden Stream hinzufügen: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  Und in Rx müssen Sie mit LatestFrom eine weitere mit einer Karte formen oder zuerst Vor- und Nachnamen in einem Stream kombinieren. </p><br><p>  Aber zurück zu Hooks und Mr.  Eine besser lesbare Aufzeichnung von Abhängigkeiten, die immer zeigt, wie Daten gebildet werden, ist möglicherweise einer der Hauptvorteile.  Die aktuelle useEffect-Schnittstelle erlaubt es grundsätzlich nicht, auf Signalströme zu reagieren, weshalb <br>  Ich muss mir verschiedene Wendungen einfallen lassen. </p><br><p>  Ein weiterer Punkt ist, dass die Option gewöhnlicher Hooks zusätzliche Renderings enthält.  Wenn der Benutzer nur auf die Schaltfläche geklickt hat, sind noch keine Änderungen an der Benutzeroberfläche erforderlich, die die Reaktion zeichnen muss.  Es wird jedoch ein Render aufgerufen.  In der Variante mit mrr wird der zurückgegebene Status nur aktualisiert, wenn bereits eine Antwort vom Server eingetroffen ist.  Sie sparen Streichhölzer, sagen Sie?  Na ja, vielleicht.  Aber für mich persönlich führt das Prinzip, "sich in einer unverständlichen Situation neu zu rendern", das die Grundlage für grundlegende Haken darstellt, zur Ablehnung. </p><br><p>  Zusätzliche Renderings bedeuten eine neue Formation von Event-Handlern.  Übrigens sind hier gewöhnliche Haken alle schlecht.  Handler sind nicht nur unerlässlich, sie müssen auch bei jedem Rendern neu generiert werden.  Und es wird hier nicht möglich sein, das Caching vollständig zu nutzen, weil  Viele Handler müssen an interne Komponentenvariablen gebunden sein.  Die mrr-Handler sind deklarativer, und das Caching ist bereits in mrr integriert: set ('name') wird nur einmal generiert und für nachfolgende Renderings aus dem Cache ersetzt. </p><br><p>  Mit einer Erhöhung der Codebasis können imperative Handler noch umständlicher werden.  Angenommen, wir müssen auch die Anzahl der vom Benutzer vorgenommenen Formularübermittlungen anzeigen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  Nicht sehr gut aussehend.  Sie können den Handler natürlich als separate Funktion innerhalb der Komponente rendern.  Die Lesbarkeit wird erhöht, aber das Problem der Neuerstellung der Funktion mit jedem Rendering sowie das Problem der Imperativität bleiben bestehen.  Im Wesentlichen handelt es sich hierbei um einen regulären Verfahrenscode, obwohl allgemein angenommen wird, dass sich die React-API allmählich in Richtung eines funktionalen Ansatzes ändert. </p><br><p>  Für diejenigen, denen das Ausmaß des Problems übertrieben erscheint, kann ich antworten, dass beispielsweise die Entwickler des React selbst sich des Problems der übermäßigen Generierung von Handlern bewusst sind und uns sofort eine Krücke in Form von useCallback anbieten. </p><br><p>  Auf mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  Eine bequemere Alternative ist useReducer, mit der Sie den Imperativ der Handler aufgeben können.  Andere wichtige Probleme bleiben jedoch bestehen: mangelnde Arbeit mit Signalen (da derselbe useEffect für Nebenwirkungen verantwortlich ist) sowie die schlechteste Lesbarkeit bei asynchronen Konvertierungen (mit anderen Worten, es ist aufgrund des gleichen useEffect schwieriger, die Beziehung zwischen den Feldern des Geschäfts zu verfolgen )  Wenn in mrr das Abhängigkeitsdiagramm zwischen Statusfeldern (Threads) sofort deutlich sichtbar ist, müssen Sie in Hooks Ihre Augen ein wenig auf und ab bewegen. </p><br><p>  Außerdem ist es nicht sehr praktisch, useState und useReducer in derselben Komponente freizugeben (auch hier gibt es komplexe Imperative-Handler, die etwas in useState ändern <br>  und Versandaktion), weshalb Sie höchstwahrscheinlich vor der Entwicklung der Komponente die eine oder andere Option akzeptieren müssen. </p><br><p>  Natürlich kann die Berücksichtigung aller Aspekte weiterhin fortgesetzt werden.  Um den Rahmen des Artikels nicht zu überschreiten, werde ich einige weniger wichtige Punkte vollständig ansprechen. </p><br><p>  Zentralisierte Protokollierung, Debugging.  Da in mrr alle Streams in einem Hub enthalten sind, reicht es zum Debuggen aus, ein Flag hinzuzufügen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  Danach werden alle Änderungen an den Streams in der Konsole angezeigt.  Um auf den gesamten Status (d. H. Die aktuellen Werte aller Threads) zuzugreifen, gibt es einen Pseudo-Stream-Status $: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Wenn Sie den redaktionellen Stil benötigen oder sehr daran gewöhnt sind, können Sie in mrr im Editorstil schreiben und einen neuen Feldwert zurückgeben, der auf dem Ereignis und dem gesamten vorherigen Status basiert.  Das Gegenteil (Schreiben auf useReducer oder einem Editor im mrr-Stil) funktioniert jedoch nicht, da diese nicht reaktiv sind. </p><br><p>  Arbeite mit der Zeit.  Erinnern Sie sich an zwei Aspekte von Flüssen: Bedeutung und Reaktionszeit, Harmonie und Rhythmus?  Das Arbeiten mit dem ersten in gewöhnlichen Haken ist also recht einfach und bequem, aber mit dem zweiten - nein.  Mit Arbeiten im Laufe der Zeit meine ich die Bildung von Kinderströmen, deren "Rhythmus" sich vom des Elternteils unterscheidet.  Dies sind in erster Linie alle Arten von Filtern, Debowns, Trab usw.  All dies müssen Sie höchstwahrscheinlich selbst implementieren.  In mrr können Sie sofort vorgefertigte Anweisungen verwenden.  Das Gentleman-Set mrr ist der Vielzahl der Operatoren Rx unterlegen, hat jedoch eine intuitivere Benennung. </p><br><p>  Intercomponent Interaktion.  Ich erinnere mich, dass es im Editor als gute Praxis angesehen wurde, nur eine Geschichte zu erstellen.  Wenn wir useReducer in vielen Komponenten verwenden, <br>  Möglicherweise liegt ein Problem bei der Organisation der Interaktion zwischen den Parteien vor.  Auf mrr können Flüsse frei von einer Komponente zur anderen "nach oben oder unten" in der Hierarchie "fließen", was jedoch aufgrund des deklarativen Ansatzes keine Probleme verursacht.  Ausführlicher <br>  Dieses Thema sowie weitere Funktionen der mrr-API werden im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Actors + FRP in React beschrieben</a> </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>  Die neuen Reaktionshaken sind großartig und vereinfachen unser Leben, aber sie haben einige Mängel, die ein übergeordneter Universalhaken (State Management) beheben kann.  UseMrr aus der funktional-reaktiven mrr-Bibliothek wurde vorgeschlagen und als solche betrachtet. </p><br><p>  Probleme und ihre Lösungen: </p><br><ul><li>  unnötige Nachzählungen von Daten bei jedem Rendering (in mrr fehlen aufgrund der Push-basierten Reaktivität) </li><li>  Zusätzliche Renderings, wenn eine Änderung des Status keine Änderung der Benutzeroberfläche zur Folge hat </li><li>  schlechte Code-Lesbarkeit bei asynchronen Konvertierungen (im Vergleich zu synchronen).  In mrr ist asynchroner Code in seiner Lesbarkeit und Ausdruckskraft dem synchronen nicht unterlegen.  Die meisten Probleme, die in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kürzlich erschienenen Artikel über useEffect</a> auf mrr behandelt wurden, sind grundsätzlich unmöglich </li><li>  Imperative Handler, die nicht immer zwischengespeichert werden können (in mrr werden sie automatisch zwischengespeichert, können fast immer zwischengespeichert werden, deklarativ) </li><li>  Wenn Sie useState und useReducer gleichzeitig verwenden, kann dies zu unangenehmem Code führen </li><li>  Mangel an Werkzeugen zur Umwandlung von Flüssen im Laufe der Zeit (Entprellen, Drosseln, Rennbedingung) </li></ul><br><p>  In vielen Punkten kann man argumentieren, dass sie durch benutzerdefinierte Haken gelöst werden können.  Genau dies wird vorgeschlagen, aber anstelle unterschiedlicher Implementierungen wird für jede einzelne Aufgabe eine ganzheitliche, konsistente Lösung vorgeschlagen. </p><br><p>  Viele Probleme sind zu vertraut geworden, als dass wir sie klar erkennen könnten.  Beispielsweise sahen asynchrone Konvertierungen immer komplizierter und verwirrender aus als synchrone, und Hooks in diesem Sinne sind nicht schlechter als frühere Ansätze (Eds usw.).  Um dies als Problem zu erkennen, müssen Sie zuerst andere Ansätze sehen, die eine bessere Lösung bieten. </p><br><p>  Dieser Artikel soll keine spezifischen Ansichten auferlegen, sondern auf das Problem aufmerksam machen.  Ich bin sicher, dass es andere Lösungen gibt oder gibt, die eine würdige Alternative darstellen können, aber noch nicht allgemein bekannt sind.  Die bevorstehende React Cache API kann ebenfalls einen großen Unterschied machen.  Ich werde mich über Kritik und Diskussion in den Kommentaren freuen. </p><br><p>  Interessenten können sich am 28. März auch eine Präsentation zu diesem Thema auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kyivjs</a> ansehen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445214/">https://habr.com/ru/post/de445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445204/index.html">Stream-Konvertierung von Firebird 2.5-Datenbanken in das ODS12-Format (Firebird 3.0)</a></li>
<li><a href="../de445206/index.html">Reduzieren Sie Ausfallzeiten beim Upgrade von Zimbra</a></li>
<li><a href="../de445208/index.html">Reifegrad der Unternehmens-IT</a></li>
<li><a href="../de445210/index.html">Kryptowährungskolonie</a></li>
<li><a href="../de445212/index.html">NetBIOS in den Händen eines Hackers</a></li>
<li><a href="../de445220/index.html">AMD Radeon VII: High-End-Chip (Teil 3)</a></li>
<li><a href="../de445222/index.html">Erhalten Sie innerhalb eines Tages ein Angebot an das Backend-Team am Cosmonautics Day</a></li>
<li><a href="../de445226/index.html">Die Entwicklung einer Rakete, die den Mond erreichen kann, wird Russland 740 Milliarden Rubel kosten</a></li>
<li><a href="../de445228/index.html">Kryptographie in Java. Mac-Klasse</a></li>
<li><a href="../de445230/index.html">Die Registrierung für die II IT-Konferenz für Anfänger SMARTRHINO-2019 begann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>