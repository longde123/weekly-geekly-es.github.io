<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåë üìÅ üìô Wir pumpen React Hooks mit FRP üëÉüèø üë©üèΩ‚Äçüöí üë®üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele React-Entwickler haben die Hooks gemeistert und Euphorie erlebt. Schlie√ülich haben sie ein einfaches und praktisches Toolkit erhalten, mit dem S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir pumpen React Hooks mit FRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445214/"><p>  Viele React-Entwickler haben die Hooks gemeistert und Euphorie erlebt. Schlie√ülich haben sie ein einfaches und praktisches Toolkit erhalten, mit dem Sie Aufgaben mit deutlich weniger Code implementieren k√∂nnen.  Aber bedeutet dies, dass die standardm√§√üig angebotenen Hooks useState und useReducer alles sind, was wir zur Verwaltung des Status ben√∂tigen? </p><br><p>  Meiner Meinung nach ist ihre Verwendung in ihrer Rohform nicht sehr bequem, sie k√∂nnen eher als Grundlage f√ºr den Aufbau wirklich praktischer Haken f√ºr das Staatsmanagement angesehen werden.  Reagieren Entwickler selbst stark auf die Entwicklung von benutzerdefinierten Hooks. Warum also nicht?  Unter dem Schnitt werden wir uns ein sehr einfaches und verst√§ndliches Beispiel ansehen, was mit gew√∂hnlichen Haken nicht stimmt und wie sie verbessert werden k√∂nnen, so dass sie sich v√∂llig weigern, sie in ihrer reinen Form zu verwenden. </p><a name="habracut"></a><br><p>  Es gibt ein bestimmtes Feld f√ºr die Eingabe, bedingt einen Namen.  Und es gibt eine Schaltfl√§che durch Klicken, auf die wir eine Anfrage an den Server mit dem eingegebenen Namen stellen sollen (eine bestimmte Suche).  Es scheint, dass das einfacher sein k√∂nnte?  Die L√∂sung ist jedoch alles andere als offensichtlich.  Die erste naive Implementierung: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  Was ist hier falsch?  Wenn der Benutzer, der etwas in das Feld eingibt, das Formular zweimal sendet, funktioniert nur die erste Anfrage f√ºr uns, weil  Beim zweiten Klick √§ndert sich die Anforderung nicht und useEffect funktioniert nicht.  Wenn Sie sich vorstellen, dass es sich bei unserer Anwendung um einen Ticketsuchdienst handelt und der Benutzer das Formular m√∂glicherweise in bestimmten Abst√§nden immer wieder sendet, ohne √Ñnderungen vorzunehmen, funktioniert eine solche Implementierung bei uns nicht!  Die Verwendung des Namens als Abh√§ngigkeit f√ºr useEffect ist ebenfalls nicht akzeptabel. Andernfalls wird das Formular sofort gesendet, wenn sich der Text √§ndert.  Nun, man muss Einfallsreichtum zeigen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Jetzt √§ndern wir mit jedem Klick die Bedeutung der Anfrage in das Gegenteil, wodurch das gew√ºnschte Verhalten erreicht wird.  Dies ist eine sehr kleine und unschuldige Kr√ºcke, aber es macht den Code etwas verwirrend zu verstehen.  Vielleicht scheint es Ihnen jetzt, dass ich das Problem aus meinem Finger sauge und seine Skala aufblase.  Um zu beantworten, ob es wahr ist oder nicht, m√ºssen Sie diesen Code mit anderen Implementierungen vergleichen, die einen aussagekr√§ftigeren Ansatz bieten. </p><br><p>  Schauen wir uns dieses Beispiel auf theoretischer Ebene unter Verwendung der Thread-Abstraktion an.  Es ist sehr praktisch, um den Status von Benutzeroberfl√§chen zu beschreiben.  Wir haben also zwei Streams: Daten, die in das Textfeld eingegeben wurden (Name $), und einen Stream von Klicks auf die Schaltfl√§che zum Senden des Formulars (klicken Sie auf $).  Aus ihnen m√ºssen wir einen dritten, kombinierten Strom von Anfragen an den Server erstellen. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Hier ist das Verhalten, das wir erreichen m√ºssen.  Jeder Stream hat zwei Aspekte: den Wert, den er hat, und den Zeitpunkt, zu dem Werte durch ihn flie√üen.  In verschiedenen Situationen ben√∂tigen wir m√∂glicherweise den einen oder anderen Aspekt oder beides.  Sie k√∂nnen dies mit dem Rhythmus und der Harmonie in der Musik vergleichen.  Streams, f√ºr die nur die Antwortzeit wesentlich ist, werden auch als Signale bezeichnet. </p><br><p>  In unserem Fall ist click $ ein reines Signal: Es spielt keine Rolle, welcher Wert durch das Signal flie√üt (undefiniert / true / Event / was auch immer), es ist nur dann wichtig, wenn dies geschieht.  Fallname $ <br>  das Gegenteil: Seine √Ñnderungen haben in keiner Weise √Ñnderungen im System zur Folge, aber wir brauchen m√∂glicherweise irgendwann seine Bedeutung.  Und aus diesen beiden Str√∂men m√ºssen wir den dritten machen, indem wir vom ersten zum zweiten Wert nehmen. </p><br><p>  Im Fall von Rxjs haben wir daf√ºr einen fast vorgefertigten Operator: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  Die praktische Verwendung von Rx in React kann jedoch recht unpraktisch sein.  Eine geeignetere Option ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mrr-</a> Bibliothek, die auf den gleichen funktional-reaktiven Prinzipien wie Rx basiert, jedoch speziell f√ºr die Verwendung mit React nach dem Prinzip der "Gesamtreaktivit√§t" angepasst und als Haken verbunden ist. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Die useMrr-Schnittstelle √§hnelt useState oder useReducer: Sie gibt ein Statusobjekt (Werte aller Threads) und einen Setter zur√ºck, um Werte in Threads einzuf√ºgen.  Aber im Inneren ist alles etwas anders: Jedes Statusfeld (= Stream), mit Ausnahme derjenigen, in die wir Werte direkt aus den DOM-Ereignissen eingeben, wird durch eine Funktion und eine Liste √ºbergeordneter Threads beschrieben, deren √Ñnderung dazu f√ºhrt, dass das untergeordnete Element neu berechnet wird.  In diesem Fall werden die Werte der √ºbergeordneten Threads in die Funktion eingesetzt.  Wenn wir nur den Wert des Streams abrufen m√∂chten, aber nicht auf seine √Ñnderung reagieren m√∂chten, schreiben wir wie im Fall des Namens ein "Minus" vor den Namen. </p><br><p>  Wir haben das gew√ºnschte Verhalten im Wesentlichen in einer Zeile.  Dies ist jedoch nicht nur K√ºrze.  Vergleichen wir die erhaltenen Ergebnisse detaillierter und zun√§chst in Bezug auf einen Parameter wie Lesbarkeit und Klarheit des resultierenden Codes. </p><br><p>  In mrr k√∂nnen Sie die "Logik" vollst√§ndig von der "Vorlage" trennen: Sie m√ºssen keine komplexen imperativen Handler in JSX schreiben.  Alles ist √§u√üerst deklarativ: Wir ordnen das DOM-Ereignis einfach praktisch ohne Konvertierung dem entsprechenden Stream zu (f√ºr Eingabefelder wird der Wert e.target.value automatisch extrahiert, sofern Sie nichts anderes angeben), und bereits in der useMrr-Struktur beschreiben wir, wie die Basisfl√ºsse gebildet werden Tochterunternehmen.  Somit k√∂nnen wir sowohl bei synchronen als auch bei asynchronen Datentransformationen immer leicht verfolgen, wie unser Wert gebildet wird. </p><br><p>  Vergleich mit Px: Wir mussten nicht einmal zus√§tzliche Operatoren verwenden: Wenn die mrr-Funktionen als Ergebnis ein Versprechen erhalten, warten sie automatisch, bis sie aufgel√∂st werden, und f√ºgen die empfangenen Daten in den Stream ein.  Au√üerdem haben wir anstelle von withLatestFrom verwendet <br>  passives H√∂ren (Minuszeichen), was bequemer ist.  Stellen Sie sich vor, wir m√ºssen neben dem Namen auch andere Felder senden.  Dann werden wir in mrr einen weiteren passiv h√∂renden Stream hinzuf√ºgen: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  Und in Rx m√ºssen Sie mit LatestFrom eine weitere mit einer Karte formen oder zuerst Vor- und Nachnamen in einem Stream kombinieren. </p><br><p>  Aber zur√ºck zu Hooks und Mr.  Eine besser lesbare Aufzeichnung von Abh√§ngigkeiten, die immer zeigt, wie Daten gebildet werden, ist m√∂glicherweise einer der Hauptvorteile.  Die aktuelle useEffect-Schnittstelle erlaubt es grunds√§tzlich nicht, auf Signalstr√∂me zu reagieren, weshalb <br>  Ich muss mir verschiedene Wendungen einfallen lassen. </p><br><p>  Ein weiterer Punkt ist, dass die Option gew√∂hnlicher Hooks zus√§tzliche Renderings enth√§lt.  Wenn der Benutzer nur auf die Schaltfl√§che geklickt hat, sind noch keine √Ñnderungen an der Benutzeroberfl√§che erforderlich, die die Reaktion zeichnen muss.  Es wird jedoch ein Render aufgerufen.  In der Variante mit mrr wird der zur√ºckgegebene Status nur aktualisiert, wenn bereits eine Antwort vom Server eingetroffen ist.  Sie sparen Streichh√∂lzer, sagen Sie?  Na ja, vielleicht.  Aber f√ºr mich pers√∂nlich f√ºhrt das Prinzip, "sich in einer unverst√§ndlichen Situation neu zu rendern", das die Grundlage f√ºr grundlegende Haken darstellt, zur Ablehnung. </p><br><p>  Zus√§tzliche Renderings bedeuten eine neue Formation von Event-Handlern.  √úbrigens sind hier gew√∂hnliche Haken alle schlecht.  Handler sind nicht nur unerl√§sslich, sie m√ºssen auch bei jedem Rendern neu generiert werden.  Und es wird hier nicht m√∂glich sein, das Caching vollst√§ndig zu nutzen, weil  Viele Handler m√ºssen an interne Komponentenvariablen gebunden sein.  Die mrr-Handler sind deklarativer, und das Caching ist bereits in mrr integriert: set ('name') wird nur einmal generiert und f√ºr nachfolgende Renderings aus dem Cache ersetzt. </p><br><p>  Mit einer Erh√∂hung der Codebasis k√∂nnen imperative Handler noch umst√§ndlicher werden.  Angenommen, wir m√ºssen auch die Anzahl der vom Benutzer vorgenommenen Formular√ºbermittlungen anzeigen. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  Nicht sehr gut aussehend.  Sie k√∂nnen den Handler nat√ºrlich als separate Funktion innerhalb der Komponente rendern.  Die Lesbarkeit wird erh√∂ht, aber das Problem der Neuerstellung der Funktion mit jedem Rendering sowie das Problem der Imperativit√§t bleiben bestehen.  Im Wesentlichen handelt es sich hierbei um einen regul√§ren Verfahrenscode, obwohl allgemein angenommen wird, dass sich die React-API allm√§hlich in Richtung eines funktionalen Ansatzes √§ndert. </p><br><p>  F√ºr diejenigen, denen das Ausma√ü des Problems √ºbertrieben erscheint, kann ich antworten, dass beispielsweise die Entwickler des React selbst sich des Problems der √ºberm√§√üigen Generierung von Handlern bewusst sind und uns sofort eine Kr√ºcke in Form von useCallback anbieten. </p><br><p>  Auf mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  Eine bequemere Alternative ist useReducer, mit der Sie den Imperativ der Handler aufgeben k√∂nnen.  Andere wichtige Probleme bleiben jedoch bestehen: mangelnde Arbeit mit Signalen (da derselbe useEffect f√ºr Nebenwirkungen verantwortlich ist) sowie die schlechteste Lesbarkeit bei asynchronen Konvertierungen (mit anderen Worten, es ist aufgrund des gleichen useEffect schwieriger, die Beziehung zwischen den Feldern des Gesch√§fts zu verfolgen )  Wenn in mrr das Abh√§ngigkeitsdiagramm zwischen Statusfeldern (Threads) sofort deutlich sichtbar ist, m√ºssen Sie in Hooks Ihre Augen ein wenig auf und ab bewegen. </p><br><p>  Au√üerdem ist es nicht sehr praktisch, useState und useReducer in derselben Komponente freizugeben (auch hier gibt es komplexe Imperative-Handler, die etwas in useState √§ndern <br>  und Versandaktion), weshalb Sie h√∂chstwahrscheinlich vor der Entwicklung der Komponente die eine oder andere Option akzeptieren m√ºssen. </p><br><p>  Nat√ºrlich kann die Ber√ºcksichtigung aller Aspekte weiterhin fortgesetzt werden.  Um den Rahmen des Artikels nicht zu √ºberschreiten, werde ich einige weniger wichtige Punkte vollst√§ndig ansprechen. </p><br><p>  Zentralisierte Protokollierung, Debugging.  Da in mrr alle Streams in einem Hub enthalten sind, reicht es zum Debuggen aus, ein Flag hinzuzuf√ºgen: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  Danach werden alle √Ñnderungen an den Streams in der Konsole angezeigt.  Um auf den gesamten Status (d. H. Die aktuellen Werte aller Threads) zuzugreifen, gibt es einen Pseudo-Stream-Status $: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Wenn Sie den redaktionellen Stil ben√∂tigen oder sehr daran gew√∂hnt sind, k√∂nnen Sie in mrr im Editorstil schreiben und einen neuen Feldwert zur√ºckgeben, der auf dem Ereignis und dem gesamten vorherigen Status basiert.  Das Gegenteil (Schreiben auf useReducer oder einem Editor im mrr-Stil) funktioniert jedoch nicht, da diese nicht reaktiv sind. </p><br><p>  Arbeite mit der Zeit.  Erinnern Sie sich an zwei Aspekte von Fl√ºssen: Bedeutung und Reaktionszeit, Harmonie und Rhythmus?  Das Arbeiten mit dem ersten in gew√∂hnlichen Haken ist also recht einfach und bequem, aber mit dem zweiten - nein.  Mit Arbeiten im Laufe der Zeit meine ich die Bildung von Kinderstr√∂men, deren "Rhythmus" sich vom des Elternteils unterscheidet.  Dies sind in erster Linie alle Arten von Filtern, Debowns, Trab usw.  All dies m√ºssen Sie h√∂chstwahrscheinlich selbst implementieren.  In mrr k√∂nnen Sie sofort vorgefertigte Anweisungen verwenden.  Das Gentleman-Set mrr ist der Vielzahl der Operatoren Rx unterlegen, hat jedoch eine intuitivere Benennung. </p><br><p>  Intercomponent Interaktion.  Ich erinnere mich, dass es im Editor als gute Praxis angesehen wurde, nur eine Geschichte zu erstellen.  Wenn wir useReducer in vielen Komponenten verwenden, <br>  M√∂glicherweise liegt ein Problem bei der Organisation der Interaktion zwischen den Parteien vor.  Auf mrr k√∂nnen Fl√ºsse frei von einer Komponente zur anderen "nach oben oder unten" in der Hierarchie "flie√üen", was jedoch aufgrund des deklarativen Ansatzes keine Probleme verursacht.  Ausf√ºhrlicher <br>  Dieses Thema sowie weitere Funktionen der mrr-API werden im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Actors + FRP in React beschrieben</a> </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>  Die neuen Reaktionshaken sind gro√üartig und vereinfachen unser Leben, aber sie haben einige M√§ngel, die ein √ºbergeordneter Universalhaken (State Management) beheben kann.  UseMrr aus der funktional-reaktiven mrr-Bibliothek wurde vorgeschlagen und als solche betrachtet. </p><br><p>  Probleme und ihre L√∂sungen: </p><br><ul><li>  unn√∂tige Nachz√§hlungen von Daten bei jedem Rendering (in mrr fehlen aufgrund der Push-basierten Reaktivit√§t) </li><li>  Zus√§tzliche Renderings, wenn eine √Ñnderung des Status keine √Ñnderung der Benutzeroberfl√§che zur Folge hat </li><li>  schlechte Code-Lesbarkeit bei asynchronen Konvertierungen (im Vergleich zu synchronen).  In mrr ist asynchroner Code in seiner Lesbarkeit und Ausdruckskraft dem synchronen nicht unterlegen.  Die meisten Probleme, die in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√ºrzlich erschienenen Artikel √ºber useEffect</a> auf mrr behandelt wurden, sind grunds√§tzlich unm√∂glich </li><li>  Imperative Handler, die nicht immer zwischengespeichert werden k√∂nnen (in mrr werden sie automatisch zwischengespeichert, k√∂nnen fast immer zwischengespeichert werden, deklarativ) </li><li>  Wenn Sie useState und useReducer gleichzeitig verwenden, kann dies zu unangenehmem Code f√ºhren </li><li>  Mangel an Werkzeugen zur Umwandlung von Fl√ºssen im Laufe der Zeit (Entprellen, Drosseln, Rennbedingung) </li></ul><br><p>  In vielen Punkten kann man argumentieren, dass sie durch benutzerdefinierte Haken gel√∂st werden k√∂nnen.  Genau dies wird vorgeschlagen, aber anstelle unterschiedlicher Implementierungen wird f√ºr jede einzelne Aufgabe eine ganzheitliche, konsistente L√∂sung vorgeschlagen. </p><br><p>  Viele Probleme sind zu vertraut geworden, als dass wir sie klar erkennen k√∂nnten.  Beispielsweise sahen asynchrone Konvertierungen immer komplizierter und verwirrender aus als synchrone, und Hooks in diesem Sinne sind nicht schlechter als fr√ºhere Ans√§tze (Eds usw.).  Um dies als Problem zu erkennen, m√ºssen Sie zuerst andere Ans√§tze sehen, die eine bessere L√∂sung bieten. </p><br><p>  Dieser Artikel soll keine spezifischen Ansichten auferlegen, sondern auf das Problem aufmerksam machen.  Ich bin sicher, dass es andere L√∂sungen gibt oder gibt, die eine w√ºrdige Alternative darstellen k√∂nnen, aber noch nicht allgemein bekannt sind.  Die bevorstehende React Cache API kann ebenfalls einen gro√üen Unterschied machen.  Ich werde mich √ºber Kritik und Diskussion in den Kommentaren freuen. </p><br><p>  Interessenten k√∂nnen sich am 28. M√§rz auch eine Pr√§sentation zu diesem Thema auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kyivjs</a> ansehen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445214/">https://habr.com/ru/post/de445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445204/index.html">Stream-Konvertierung von Firebird 2.5-Datenbanken in das ODS12-Format (Firebird 3.0)</a></li>
<li><a href="../de445206/index.html">Reduzieren Sie Ausfallzeiten beim Upgrade von Zimbra</a></li>
<li><a href="../de445208/index.html">Reifegrad der Unternehmens-IT</a></li>
<li><a href="../de445210/index.html">Kryptow√§hrungskolonie</a></li>
<li><a href="../de445212/index.html">NetBIOS in den H√§nden eines Hackers</a></li>
<li><a href="../de445220/index.html">AMD Radeon VII: High-End-Chip (Teil 3)</a></li>
<li><a href="../de445222/index.html">Erhalten Sie innerhalb eines Tages ein Angebot an das Backend-Team am Cosmonautics Day</a></li>
<li><a href="../de445226/index.html">Die Entwicklung einer Rakete, die den Mond erreichen kann, wird Russland 740 Milliarden Rubel kosten</a></li>
<li><a href="../de445228/index.html">Kryptographie in Java. Mac-Klasse</a></li>
<li><a href="../de445230/index.html">Die Registrierung f√ºr die II IT-Konferenz f√ºr Anf√§nger SMARTRHINO-2019 begann</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>