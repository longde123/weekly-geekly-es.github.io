<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤°ğŸ¼ ğŸ§™ğŸ½ âŒ Inside Playbook. Fitur jaringan di Ansible Engine 2.9 yang baru ğŸ”¼ ğŸš± â™€ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rilis Red Hat Ansible Engine 2.9 yang akan datang menunggu Anda dengan peningkatan yang mengesankan, beberapa di antaranya dijelaskan dalam artikel in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inside Playbook. Fitur jaringan di Ansible Engine 2.9 yang baru</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/471896/"><p><img src="https://habrastorage.org/webt/db/2m/xd/db2mxdllzxasqtz4syfggtayzw4.jpeg"></p><br><p>  Rilis Red Hat Ansible Engine 2.9 yang akan datang menunggu Anda dengan peningkatan yang mengesankan, beberapa di antaranya dijelaskan dalam artikel ini.  Seperti biasa, kami mengembangkan peningkatan Ansible Network secara terbuka, dengan dukungan komunitas.  Bergabunglah - Lihatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">papan tugas di GitHub</a> dan pelajari rencana pengembangan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rilis Red Hat Ansible Engine 2.9</a> di halaman wiki untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ansible Network</a> . </p><br><p>  Seperti yang baru-baru ini kami umumkan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Platform Red Hat Ansible Automation</a> sekarang mencakup Ansible Tower, Ansible Engine, dan semua konten Jaringan Ansible.  Sekarang, sebagian besar platform jaringan populer diimplementasikan melalui modul Ansible.  Sebagai contoh: </p><br><ul><li>  Arista eos </li><li>  Cisco IOS </li><li>  Cisco IOS XR </li><li>  Cisco NX-OS </li><li>  Juniper Junos </li><li>  Vyos </li></ul><br><p>  Daftar lengkap platform yang didukung penuh oleh Red Hat melalui Ansible Automation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di sini</a> . </p><a name="habracut"></a><br><h2 id="chemu-my-nauchilis">  Apa yang telah kita pelajari </h2><br><p> Selama empat tahun terakhir, kami telah belajar banyak tentang pengembangan platform untuk otomatisasi jaringan.  Kami juga belajar bagaimana pengguna akhir memainkan artefak platform di buku pedoman dan peran yang dimungkinkan.  Dan inilah yang kami temukan: </p><br><ul><li>  Organisasi mengotomatiskan perangkat tidak hanya satu, tetapi banyak vendor. </li><li>  Otomasi bukan hanya fenomena teknis, tetapi juga fenomena budaya. </li><li>  Otomatisasi jaringan berskala besar lebih rumit daripada yang terlihat, karena prinsip arsitektur mendasar dari desain otomasi. </li></ul><br><p>  Ketika kami mendiskusikan rencana pengembangan jangka panjang kami lebih dari setahun yang lalu, klien korporat kami meminta yang berikut: </p><br><ul><li>  Pengumpulan fakta perlu distandarisasi dan diselaraskan dengan alur kerja otomatisasi untuk perangkat apa pun. </li><li>  Memperbarui konfigurasi pada perangkat juga perlu distandarisasi dan diselaraskan sehingga modul yang mungkin memproses paruh kedua siklus setelah mengumpulkan fakta. </li><li>  Kami membutuhkan metode yang ketat dan didukung untuk mengubah konfigurasi perangkat menjadi data terstruktur.  Atas dasar ini, sumber kebenaran dapat dipindahkan dari perangkat jaringan. </li></ul><br><h2 id="uluchsheniya-faktov">  Peningkatan fakta </h2><br><p>  Mengumpulkan fakta dari perangkat jaringan menggunakan Ansible seringkali dilakukan secara acak.  Platform jaringan dilengkapi dengan tingkat yang berbeda-beda dengan kemampuan untuk mengumpulkan fakta, tetapi mereka hampir tidak memiliki - atau bahkan tidak ada sama sekali - fungsi untuk mem-parsing dan menstandarkan presentasi data dalam pasangan kunci-nilai.  Baca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> Ken Celenza tentang betapa sulit dan menyakitkannya menganalisis dan membakukan data faktual. </p><br><p>  Anda mungkin telah memperhatikan bagaimana kami bekerja pada peran Ansible Network Engine.  Secara alami, 24.000 unduhan kemudian, peran Network Engine dengan cepat menjadi salah satu peran Ansible yang paling populer di Ansible Galaxy untuk skenario otomatisasi jaringan.  Sebelum kita memindahkan sebagian besar dari ini ke Ansible 2.8, untuk mempersiapkan apa yang diperlukan Ansible 2.9, peran Ansible ini menyediakan seperangkat alat pertama untuk membantu dalam penguraian perintah, manajemen perintah, dan pengumpulan data untuk perangkat jaringan. </p><br><p>  Jika Anda pandai menggunakan Network Engine, ini adalah cara yang sangat efisien untuk mengumpulkan, mengurai, dan membakukan data fakta untuk digunakan dengan Ansible.  Kerugian dari peran ini adalah Anda perlu membuat sejumlah parser untuk setiap platform dan untuk semua aktivitas jaringan.  Untuk memahami betapa sulitnya membuat, mengirim, dan memelihara parser, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1200+ parser</a> dari orang-orang di Cisco. </p><br><p>  Singkatnya, untuk otomatisasi skala besar, sangat penting untuk menerima fakta dari perangkat dan menormalkannya menjadi pasangan nilai kunci, tetapi ini sulit dicapai ketika Anda memiliki banyak vendor dan platform jaringan. </p><br><p>  Setiap modul fakta jaringan di Ansible 2.9 sekarang dapat menganalisis konfigurasi perangkat jaringan dan mengembalikan data terstruktur - tanpa pustaka tambahan, peran yang mungkin atau parser khusus. </p><br><p>  Dimulai dengan Ansible 2.9, dengan setiap rilis modul jaringan yang diperbarui, modul fakta ditingkatkan untuk memberikan informasi tentang bagian konfigurasi ini.  Artinya, pengembangan fakta dan modul sekarang terjadi pada kecepatan yang sama, dan mereka akan selalu memiliki struktur data yang sama. </p><br><p> Konfigurasi sumber daya pada perangkat jaringan dapat diekstraksi dan dikonversi menjadi data terstruktur dengan dua cara.  Dengan kedua cara ini, Anda dapat mengkompilasi dan mengonversi daftar sumber daya tertentu menggunakan <code>gather_network_resources</code> baru.  Nama sumber daya sesuai dengan nama modul, dan ini sangat nyaman. </p><br><h3 id="vo-vremya-sbora-faktov">  Pada saat mengumpulkan fakta: </h3><br><p>  Menggunakan <code>gather_facts</code> Anda dapat mengekstrak konfigurasi perangkat saat ini di awal playbook, dan kemudian menggunakannya di seluruh playbook.  Tentukan sumber daya individual yang akan diambil dari perangkat. </p><br><pre> <code class="plaintext hljs">- hosts: arista module_defaults: eos_facts: gather_subset: min gather_network_resources: - interfaces gather_facts: True</code> </pre> <br><p>  Anda mungkin melihat sesuatu yang baru dalam contoh ini, yaitu <code>gather_facts: true</code> sekarang tersedia untuk pencarian fakta asli untuk perangkat jaringan. </p><br><h3 id="ispolzovanie-modulya-setevyh-faktov-napryamuyu">  Menggunakan modul fakta jaringan secara langsung: </h3><br><pre> <code class="plaintext hljs">- name: collect interface configuration facts eos_facts: gather_subset: min gather_network_resources: - interfaces</code> </pre> <br><h3 id="pleybuk-vozvraschaet-sleduyuschie-fakty-ob-interfeyse">  Playbook mengembalikan fakta berikut tentang antarmuka: </h3><br><pre> <code class="plaintext hljs">ansible_facts: ansible_network_resources: interfaces: - enabled: true name: Ethernet1 mtu: '1476' - enabled: true name: Loopback0 - enabled: true name: Loopback1 - enabled: true mtu: '1476' name: Tunnel0 - enabled: true name: Ethernet1 - enabled: true name: Tunnel1 - enabled: true name: Ethernet1</code> </pre> <br><p>  Perhatikan bagaimana Ansible mengambil konfigurasi asli dari perangkat Arista dan mengubahnya menjadi data terstruktur untuk digunakan sebagai pasangan nilai kunci standar untuk tugas dan operasi selanjutnya. </p><br><p>  Fakta antarmuka dapat ditambahkan ke variabel tersimpan yang mungkin dan digunakan segera atau lambat sebagai input ke <code>eos_interfaces</code> sumber daya <code>eos_interfaces</code> tanpa pemrosesan atau konversi tambahan. </p><br><h3 id="moduli-resursov">  Modul sumber daya </h3><br><p>  Jadi, kami mengekstraksi fakta, menormalkan data, menuliskannya dalam skema internal standar dari struktur data dan mendapatkan sumber kebenaran yang sudah jadi.  Hore!  Ini, tentu saja, sangat bagus, tetapi kita masih perlu mengubah pasangan nilai kunci kembali ke konfigurasi spesifik yang diharapkan oleh platform perangkat tertentu.  Sekarang kita membutuhkan modul untuk platform spesifik untuk memenuhi persyaratan pengumpulan dan normalisasi fakta baru ini. </p><br><p>  Apa itu modul sumber daya?  Bagian konfigurasi perangkat dapat dianggap sebagai sumber daya yang disediakan oleh perangkat ini.  Modul sumber daya jaringan sengaja terbatas pada satu sumber daya, dan dapat ditumpuk seperti batu bata untuk mengkonfigurasi layanan jaringan yang kompleks.  Akibatnya, persyaratan dan spesifikasi untuk modul sumber daya secara alami disederhanakan, karena modul sumber daya dapat membaca <em>dan</em> mengonfigurasi layanan jaringan tertentu pada perangkat jaringan. </p><br><p>  Untuk menjelaskan apa yang dilakukan modul sumber daya, mari kita lihat contoh buku pedoman yang memperlihatkan operasi idempoent menggunakan fakta baru dari sumber daya jaringan dan modul <code>eos_l3_interface</code> . </p><br><pre> <code class="plaintext hljs">- name: example of facts being pushed right back to device. hosts: arista gather_facts: false tasks: - name: grab arista eos facts eos_facts: gather_subset: min gather_network_resources: l3_interfaces - name: ensure that the IP address information is accurate eos_l3_interfaces: config: "{{ ansible_network_resources['l3_interfaces'] }}" register: result - name: ensure config did not change assert: that: not result.changed</code> </pre> <br><p>  Seperti yang Anda lihat, data yang dikumpulkan dari perangkat ditransfer langsung ke modul sumber daya yang sesuai tanpa konversi.  Saat startup, playbook mengambil nilai dari perangkat dan membandingkannya dengan yang diharapkan.  Dalam contoh ini, nilai yang diperoleh sesuai dengan yang diharapkan (yaitu, penyimpangan konfigurasi diperiksa) dan pesan ditampilkan jika konfigurasi telah berubah. </p><br><p>  Cara ideal untuk mendeteksi penyimpangan konfigurasi adalah dengan menyimpan fakta-fakta dalam variabel tersimpan yang mungkin dan menggunakannya secara berkala dengan modul sumber daya dalam mode cek.  Ini adalah metode sederhana untuk melihat apakah seseorang telah mengubah nilai secara manual.  Dalam kebanyakan kasus, organisasi mengizinkan perubahan dan konfigurasi manual, walaupun banyak operasi dilakukan melalui Otomatisasi yang Mungkin. </p><br><h2 id="chem-novye-moduli-resursa-otlichayutsya-ot-predyduschih">  Bagaimana modul sumber daya baru berbeda dari yang sebelumnya? </h2><br><p>  Untuk seorang insinyur jaringan otomatisasi, ada 3 perbedaan utama antara modul sumber daya di Ansible 2.9 dari versi sebelumnya. </p><br><p>  1) Untuk sumber daya jaringan tertentu (yang juga dapat dianggap sebagai bagian konfigurasi), modul dan fakta akan berkembang di semua sistem operasi jaringan yang didukung secara bersamaan.  Kami berpikir bahwa jika Ansible mendukung konfigurasi sumber daya pada platform jaringan tunggal, kami harus mendukungnya di mana saja.  Ini menyederhanakan penggunaan modul sumber daya, karena insinyur otomatisasi jaringan sekarang dapat mengkonfigurasi sumber daya (misalnya, LLDP) di semua sistem operasi jaringan dengan modul asli dan yang didukung. </p><br><p>  2) Modul sumber daya sekarang termasuk nilai status. </p><br><ul><li>  <code>merged</code> : konfigurasi digabungkan dengan konfigurasi yang disediakan (default); </li><li>  <code>replaced</code> : konfigurasi sumber daya akan diganti dengan konfigurasi yang disediakan; </li><li>  <code>overridden</code> : konfigurasi sumber daya akan diganti dengan konfigurasi yang disediakan;  contoh sumber daya berlebih akan dihapus; </li><li>  <code>deleted</code> : konfigurasi sumber daya akan dihapus / dikembalikan secara default. </li></ul><br><p><img src="https://habrastorage.org/webt/yg/0m/_c/yg0m_c1thcp9wm30_de2tqjs810.jpeg"></p><br><p>  3) Modul sumber daya sekarang termasuk nilai pengembalian stabil.  Ketika modul sumber daya jaringan telah membuat (atau menyarankan) perubahan yang diperlukan untuk perangkat jaringan, itu mengembalikan pasangan nilai kunci yang sama ke buku pedoman. </p><br><ul><li>  <code>before</code> : konfigurasi pada perangkat dalam bentuk data terstruktur sebelum tugas; </li><li>  <code>after</code> : jika perangkat telah berubah (atau dapat berubah jika mode verifikasi digunakan), konfigurasi yang dihasilkan akan dikembalikan dalam bentuk data terstruktur; </li><li>  <code>commands</code> : <code>commands</code> konfigurasi apa pun yang berjalan pada perangkat untuk membawanya ke keadaan yang diinginkan. </li></ul><br><p><img src="https://habrastorage.org/webt/si/jq/r2/sijqr2ujxrhob-6mvsg2wjcmhrw.jpeg"></p><br><p><img src="https://habrastorage.org/webt/tn/1s/cq/tn1scqim6qomensla3ksk3bn8s4.jpeg"></p><br><h2 id="chto-vse-eto-znachit-pochemu-eto-vazhno">  Apa artinya semua ini?  Mengapa ini penting? </h2><br><p>  Posting ini menjelaskan banyak konsep kompleks, tetapi kami berharap bahwa pada akhirnya Anda akan lebih memahami bahwa klien korporat meminta fakta, normalisasi data dan konfigurasi loop untuk platform otomatisasi.  Tetapi mengapa mereka membutuhkan perbaikan ini?  Banyak organisasi sekarang terlibat dalam transformasi digital untuk membuat lingkungan TI mereka lebih fleksibel dan kompetitif.  Baik atau buruk, banyak insinyur jaringan menjadi pengembang jaringan, baik karena minat mereka sendiri atau atas perintah manajer. </p><br><p>  Organisasi memahami bahwa mengotomatiskan templat jaringan individual tidak menyelesaikan masalah fragmentasi dan hanya meningkatkan efisiensi hingga batas tertentu.  Platform Red Hat Ansible Automation menyediakan model data sumber daya yang ketat dan normatif untuk secara terprogram mengelola data yang mendasarinya pada perangkat jaringan.  Artinya, pengguna secara bertahap meninggalkan metode konfigurasi individual demi metode yang lebih modern dengan penekanan pada teknologi (misalnya, alamat IP, VLAN, LLDP, dll.), Dan bukan pada implementasi vendor tertentu. </p><br><p>  Apakah ini berarti bahwa hari-hari modul perintah dan konfigurasi yang dapat diandalkan dan terbukti sudah dinomori?  Tidak mungkin.  Modul sumber daya jaringan yang diharapkan tidak akan berlaku dalam semua kasus dan tidak untuk masing-masing vendor, sehingga insinyur jaringan masih membutuhkan modul perintah dan konfigurasi untuk implementasi tertentu.  Tujuan dari modul sumber daya adalah untuk menyederhanakan template Jinja yang besar dan menormalkan konfigurasi perangkat yang tidak terstruktur menjadi format JSON terstruktur.  Dengan modul sumber daya, akan lebih mudah bagi jaringan yang ada untuk mengubah konfigurasi mereka menjadi pasangan nilai kunci terstruktur yang akan menjadi sumber kebenaran yang mudah dibaca.  Jika Anda menggunakan pasangan nilai kunci terstruktur, Anda dapat beralih dari menjalankan konfigurasi pada setiap perangkat untuk bekerja dengan data terstruktur independen dan membawa jaringan ke garis depan dengan pendekatan "infrastruktur sebagai kode". </p><br><h2 id="kakie-moduli-resursov-poyavyatsya-v-ansible-engine-29">  Modul sumber daya apa yang akan muncul di Ansible Engine 2.9? </h2><br><p>  Sebelum menceritakan secara terperinci apa yang akan terjadi di Ansible 2.9, mari kita ingat bagaimana kita membagi seluruh jumlah pekerjaan. </p><br><p>  Kami mengidentifikasi 7 kategori dan masing-masing ditugaskan sumber daya jaringan tertentu: </p><br><p><img src="https://habrastorage.org/webt/qs/io/au/qsioaupl7rqnsvfnmiyzygd9zqs.png"></p><br><p>  Catatan: sumber daya yang berani telah direncanakan dan diimplementasikan dalam Ansible 2.9. <br>  Berdasarkan umpan balik dari klien korporat dan komunitas, adalah logis untuk pertama-tama berurusan dengan modul-modul yang terkait dengan protokol topologi jaringan, virtualisasi, dan antarmuka. <br>  Modul sumber daya berikut dikembangkan oleh tim Ansible Network dan sesuai dengan platform yang didukung Red Hat: </p><br><p><img src="https://habrastorage.org/webt/um/n8/lr/umn8lrzquzbuxlxbb10vaebxavw.png"></p><br><p>  Modul-modul berikut dikembangkan oleh komunitas Ansible: </p><br><ul><li>  <code>exos_lldp_global</code> - dari Extreme Networks. </li><li>  <code>nxos_bfd_interfaces</code> - dari Cisco </li><li>  <code>nxos_telemetry</code> - dari Cisco </li></ul><br><p>  Seperti yang Anda lihat, konsep modul sumber daya cocok dengan strategi orientasi platform kami.  Artinya, kami menyertakan kapabilitas dan fungsi yang diperlukan dalam Ansible itu sendiri, untuk mendukung standardisasi dalam pengembangan modul jaringan, serta untuk menyederhanakan pekerjaan pengguna di level peran dan buku pedoman yang dimungkinkan.  Untuk memperluas pengembangan modul sumber daya, tim Ansible merilis alat Pembuat Modul. </p><br><h2 id="plany-na-ansible-210-i-dalshe">  Berencana untuk Ansible 2.10 dan seterusnya </h2><br><p>  Setelah rilis Ansible 2.9, kita akan berurusan dengan set modul sumber daya berikut untuk Ansible 2.10, yang dapat digunakan untuk mengkonfigurasi lebih lanjut topologi dan kebijakan jaringan, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACL, OSPF, dan BGP</a> .  Paket pengembangan masih dapat disesuaikan, jadi jika Anda memiliki komentar, laporkan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas Ansible Network</a> . </p><br><h2 id="resursy-i-nachalo-raboty">  Sumber daya dan memulai </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Siaran Pers Platform Otomatisasi yang Mungkin</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog Platform Otomatisasi yang Mungkin</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masa depan pengiriman konten di Ansible</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Refleksi tentang Mengubah Struktur Proyek yang Mungkin</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471896/">https://habr.com/ru/post/id471896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471882/index.html">Daftar terbuka acara PHP, pembicara dan penyelenggara di GitHub</a></li>
<li><a href="../id471884/index.html">10 utilitas ApexSQL gratis untuk mengelola database Microsoft SQL Server</a></li>
<li><a href="../id471886/index.html">VMmanager 6: memperkenalkan kotak dan membandingkan dengan generasi sebelumnya</a></li>
<li><a href="../id471890/index.html">Inferensi Variasi - apa itu dan apa yang dimakannya?</a></li>
<li><a href="../id471892/index.html">6 kisah praktis dari hari kerja SRE kami</a></li>
<li><a href="../id471904/index.html">Resource Planner di HPE InfoSight</a></li>
<li><a href="../id471906/index.html">Bahaya optimasi yang tidak tepat</a></li>
<li><a href="../id471908/index.html">Keindahan nomor prima yang tak terduga</a></li>
<li><a href="../id471912/index.html">Belajar Bahasa Inggris: 7 cara praktis untuk memperluas kosakata Anda</a></li>
<li><a href="../id471914/index.html">Bagaimana Sistem Grafik Sega Mega Drive bekerja: Video Display Processor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>