<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏸️ 🛏️ ⏳ Bagaimana kami membuat PHP 7 dua kali lebih cepat dari PHP 5. Bagian 1: mengoptimalkan struktur data 🐛 👩🏾‍🏫 🤗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada Desember 2015 , PHP 7.0 dirilis. Perusahaan yang beralih ke "tujuh" mencatat bahwa produktivitas telah meningkat, dan beban di server telah menur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami membuat PHP 7 dua kali lebih cepat dari PHP 5. Bagian 1: mengoptimalkan struktur data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/444508/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pada Desember 2015</a> , PHP 7.0 dirilis.  Perusahaan yang beralih ke "tujuh" mencatat bahwa produktivitas telah meningkat, dan beban di server telah menurun.  Yang pertama pindah ke tujuh adalah Vebia dan Etsy, dan kami memiliki Badoo, Avito dan OLX.  Untuk Badoo, beralih ke tujuh menghemat $ 1 juta dalam penghematan server.  Berkat PHP 7 di OLX, beban server rata-rata berkurang 3 kali lipat, peningkatan efisiensi dan penghematan sumber daya. <br><br>  <strong>Dmitry Stogov</strong> dari Zend Technologies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> , yang meningkatkan produktivitas.  Dalam decoding: tentang struktur internal PHP, tentang ide-ide di jantung versi 7.0, tentang perubahan struktur data dasar dan algoritma yang menentukan keberhasilan. <br><br>  <em>Penafian: Per Maret 2019,</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>80% situs</em></a> <em>berjalan dengan PHP, dan</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>70% di antaranya</em></a> <em>berjalan di</em> <em>PHP 5, meskipun</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>versi ini belum didukung</em></a> <em>sejak 1 Januari 2019</em> <em>.</em>  <em>Laporan Dmitry tahun 2016 tentang prinsip-prinsip yang menyebabkan lompatan ganda dalam produktivitas antara PHP 5 dan 7 juga relevan pada bulan Maret 2019. Tentu saja untuk separuh situs.</em> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/tHapNKpacSQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>Tentang pembicara: Dmitry Stogov</strong> mulai memprogram kembali di tahun 80-an: "Electronics B3-34", Basic, assembler.  Pada tahun 2002 Dmitry berkenalan dengan PHP dan segera mulai bekerja untuk memperbaikinya: ia mengembangkan Turck MMCache untuk PHP, memimpin proyek PHPNG dan memainkan peran penting dalam mengerjakan JIT untuk PHP.  14 tahun terakhir dari Principal Engineer di Zend Technologies. <br><br>  Zend Technologies sedang mengembangkan solusi PHP dan komersial berdasarkan itu.  Pada tahun 1999, ia didirikan oleh programmer Israel Andy Gutmans dan Zeev Suraski, yang dua tahun lalu menciptakan PHP 3. Orang-orang ini berada di garis depan pengembangan PHP dan sangat menentukan tampilan bahasa saat ini dan keberhasilan teknologi. <br><br>  Zend Technologies sedang mengembangkan inti PHP dan aplikasi untuknya, dan selama bekerja saya harus menulis ekstensi, masuk ke semua subsistem dan bahkan terlibat dalam proyek komersial, kadang-kadang sama sekali tidak terhubung dengan PHP.  Tapi topik yang paling menarik bagi saya adalah <strong>kinerja</strong> . <br><br>  Saya mulai mencari cara untuk mempercepat PHP bahkan sebelum bergabung dengan Zend, mengerjakan proyek saya sendiri yang bersaing dengan perusahaan.  Selama mengerjakan proyek, saya benar-benar memahami bahasa dan menyadari bahwa bekerja dengan proyek utama, Anda hanya dapat mempengaruhi aspek-aspek tertentu dari eksekusi skrip, dan semua yang paling menarik dan efektif hanya dapat dibuat <strong>di kernel</strong> .  Pemahaman dan kebetulan ini membawa saya ke Zend. <br><br><h2>  Penyimpangan kecil ke dalam sejarah PHP </h2><br>  PHP bukan hanya dan <strong>bukan hanya bahasa pemrograman</strong> .  PHP adalah singkatan dari Personal Home Page - alat untuk membuat halaman web pribadi dan situs web dinamis.  Bahasa hanyalah salah satu bagian utamanya.  PHP adalah pustaka fungsi yang sangat besar, banyak ekstensi untuk bekerja dengan pustaka pihak ketiga lainnya, misalnya, untuk akses ke database atau parser XML, serta satu set modul untuk berkomunikasi dengan berbagai server web. <br><br>  Programmer Denmark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rasmus Lerdorf</a> memperkenalkan PHP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada Juni 1995</a> .  Pada saat itu, itu hanya <strong>kumpulan skrip CGI yang ditulis dalam Perl</strong> .  Pada bulan April 96, Rasmus memperkenalkan PHP / FI, dan pada bulan Juni PHP / FI 2.0 dirilis.  Selanjutnya, versi ini secara substansial dikerjakan ulang oleh Andy Gutmans dan Zeev Surasky, dan pada 98 dirilis PHP 3.0.  Pada tahun 2000, bahasa tersebut menjadi sesuatu yang biasa kita lihat hari ini baik dari segi bahasa dan arsitektur internal - PHP 4, berdasarkan Zend Engine. <br><br>  Sejak versi 4, PHP telah berevolusi.  Titik baliknya adalah rilis PHP 5 pada tahun 2004, ketika <strong>model objek sepenuhnya diperbarui</strong> .  Dialah yang membuka era kerangka PHP dan mengangkat pertanyaan kinerja ke tingkat yang baru.  Mengantisipasi ini, segera setelah rilis 5.0, kami di Zend berpikir tentang mempercepat PHP dan mulai bekerja untuk meningkatkan produktivitas. <br><br>  Versi 7.1, yang dirilis pada November 2016 pada tes sintetis, <strong>25 kali lebih cepat daripada versi 2002</strong> .  Menurut grafik perubahan kinerja di cabang yang berbeda, terobosan utama terlihat di 5.1 dan 7.0. <br><br><img src="https://habrastorage.org/webt/ao/_s/mp/ao_smpopukfzjmclxqqu83xefvo.png"><br><br>  Dalam versi 5.1, kami baru saja mulai mengerjakan kinerja, dan semua yang kami ambil - ternyata, tetapi setelah 5.3 kami menabrak tembok, semua upaya untuk meningkatkan penerjemah tidak membuahkan hasil. <br><br>  Namun demikian, kami menemukan tempat untuk menggali, dan mendapatkan lebih dari yang diharapkan - akselerasi 2,5 kali lipat dibandingkan dengan versi sebelumnya pada tes.  Tetapi hal yang paling menarik adalah kita mendapatkan akselerasi 2,5 kali lipat yang sama pada aplikasi nyata yang tidak berubah.  Ini adalah fenomena, karena kami mengembangkan faktor 2 sebelumnya sepanjang kehidupan lima dalam 10 tahun. <br><br><img src="https://habrastorage.org/webt/ge/9j/n_/ge9jn_isn9hxm-gbrk0ahaexfms.png"><br><br>  Lompatan besar pada 5.1 pada tes sintetis tidak terlihat pada aplikasi nyata.  Alasannya adalah bahwa dengan penggunaan yang berbeda, kinerja PHP bersandar pada rem yang terkait dengan berbagai subsistem. <br><br>  <strong>Sejarah PHP 7 dimulai dengan stagnasi tiga tahun</strong> yang dimulai pada 2012 dan berakhir pada 2015 dengan dirilisnya versi ketujuh.  Kemudian kami menyadari bahwa kami tidak dapat lagi meningkatkan produktivitas dengan sedikit peningkatan juru bahasa kami dan beralih ke sisi JIT. <br><br><h2>  Berkeliaran di sekitar JIT </h2><br>  Hampir dua tahun kami habiskan untuk prototipe JIT untuk PHP-5.5.  Pada awalnya, kami menghasilkan kode yang sangat sederhana - urutan panggilan untuk penangan standar, sesuatu seperti kode Fort yang dijahit.  Kemudian mereka menulis <strong>Runtime Assembler</strong> mereka sendiri, sebaris kode terpisah untuk pemecahan masalah, tetapi menyadari bahwa <strong>optimasi tingkat rendah</strong> seperti <strong>itu tidak memberikan</strong> efek <strong>praktis</strong> bahkan pada tes. <br><br>  Kemudian kami berpikir tentang menurunkan tipe variabel menggunakan metode analisis statis.  Setelah menyadari kesimpulannya, kami segera menerima <strong>akselerasi 2 kali lipat dalam tes.</strong>  Karena terdorong, mereka mencoba menulis pengalokasi daftar global, tetapi gagal.  Kami menggunakan representasi level yang cukup tinggi, dan hampir tidak mungkin menggunakannya untuk alokasi register. <br><br>  Untuk menghindari masalah tingkat rendah, kami memutuskan untuk mencoba LLVM, dan setahun kemudian kami mendapat <strong>akselerasi 10x untuk bench.php</strong> , tetapi tidak ada pada aplikasi nyata.  Selain itu, mengkompilasi aplikasi nyata sekarang membutuhkan beberapa menit, misalnya, <strong>permintaan</strong> pertama <strong>ke Wordpress membutuhkan waktu 2 menit dan tidak memberikan akselerasi.</strong>  Tentu saja, ini sama sekali tidak cocok untuk latihan nyata. <br><br><blockquote>  Kode yang baik dimungkinkan dengan prediksi tipe yang tepat, yang bekerja buruk di aplikasi nyata, dan menggunakan struktur data PHP membuat kode yang dihasilkan tidak efisien. </blockquote><br><h3>  Apa yang melambat? </h3><br>  Kami memikirkan kembali alasan kegagalan tersebut dan memutuskan sekali lagi untuk melihat mengapa PHP lambat.  Gambar menunjukkan hasil profiling beberapa permintaan ke halaman beranda Wordpress. <br><br><img src="https://habrastorage.org/webt/3w/dh/7v/3wdh7vd40xumtwtyqgshsdan-a8.png"><br><br>  Kurang dari 30% dihabiskan untuk menafsirkan bytecode, 20% adalah overhead dari manajer memori, 13% bekerja dengan tabel hash, dan 5% bekerja dengan ekspresi reguler. <br><br>  Bekerja di JIT, kami hanya menyingkirkan 30% pertama, dan semua yang lainnya terbebani.  Hampir di mana-mana, kami dipaksa untuk menggunakan struktur data PHP standar, yang mencakup overhead: alokasi memori, penghitungan referensi, dll.  Pemahaman ini mengarah pada kesimpulan bahwa perlu untuk mengganti struktur data utama dalam PHP.  Dengan <strong>penggantian yayasan ini</strong> , proyek <strong>PHPNG dimulai.</strong> <br><br><h2>  Phpng  Generasi baru </h2><br>  Proyek ini dikembangkan setelah upaya yang gagal untuk membuat JIT untuk PHP.  Tujuan utamanya adalah <strong>untuk mencapai tingkat produktivitas baru dan meletakkan dasar bagi peningkatan di masa depan</strong> . <br><br>  Kami berjanji pada diri sendiri untuk beberapa waktu untuk tidak lagi menggunakan tes sintetis untuk mengukur kinerja - ini biasanya adalah program komputasi kecil yang menggunakan jumlah data terbatas yang sepenuhnya cocok dengan cache prosesor.  Aplikasi nyata, sebaliknya, tunduk pada rem yang terkait dengan memori subsistem, dan satu pembacaan dari memori dapat menelan biaya 100 instruksi komputasi.  <strong>Proyek PHPNG adalah refactoring struktur data PHP utama untuk mengoptimalkan akses memori</strong> .  Tidak ada inovasi, 100% PHP 5 kompatibel. <br><br>  Cara mengubah struktur ini jelas.  Tetapi volume perubahan dependen sangat besar, karena <strong>inti dari PHP</strong> itu sendiri <strong>adalah 150.000 baris</strong> , dan hampir setiap sepertiga perlu diubah.  Tambahkan seratus ekstensi lagi yang termasuk dalam distribusi dasar, selusin modul untuk server web yang berbeda, dan Anda akan menyadari kemegahan proyek. <br><br>  Kami bahkan tidak yakin bahwa kami akan menyelesaikan proyek.  Karena itu, mereka meluncurkan proyek secara rahasia dan membukanya hanya ketika hasil optimis pertama muncul.  Butuh dua minggu untuk <strong>mengkompilasi kernel</strong> .  Dua minggu kemudian, bench.php diterima.  Kami menghabiskan satu setengah bulan untuk memastikan pekerjaan Wordpress.  Sebulan kemudian, kami membuka proyek - itu Mei 2014.  Saat itu, kami memiliki <strong>akselerasi 30% di Wordpress</strong> .  Itu sudah tampak seperti acara akbar. <br><br>  PHPNG segera membangkitkan gelombang ketertarikan, dan pada Agustus 2014 ini <strong>diadopsi sebagai dasar untuk masa depan PHP 7</strong> .  Itu sudah merupakan proyek lain, dengan serangkaian tujuan yang berbeda, di mana produktivitas hanyalah salah satunya. <br><br><h2>  PHP 7.0 </h2><br>  Versi nomor 7 sendiri diragukan.  Versi sebelumnya adalah yang kelima.  Dan yang keenam dikembangkan beberapa tahun yang lalu dan sepenuhnya dikhususkan untuk dukungan <strong>Unicode</strong> asli, tetapi keputusan yang gagal dibuat pada tahap awal pengembangan menyebabkan kompleksitas yang berlebihan dari kode kernel dan setiap ekstensi.  Pada akhirnya, diputuskan untuk membekukan proyek. <br><br>  Pada saat ini, banyak materi yang dikhususkan untuk PHP 6 telah terakumulasi: pidato di konferensi, buku yang diterbitkan.  Agar tidak membingungkan siapa pun, kami menyebut proyek PHP 7, melewatkan PHP 6. Versi ini jauh lebih beruntung - PHP 7 dirilis pada Desember 2015, hampir sesuai rencana. <br><br>  Selain kinerja, beberapa inovasi yang lama dicari muncul di PHP 7: <br><br><ul><li>  Kemampuan untuk menentukan jenis parameter skalar dan mengembalikan nilai. </li><li>  Pengecualian alih-alih kesalahan - sekarang kita dapat menangkap dan memprosesnya. </li><li> <code>Zero-cost assert()</code> , kelas anonim, inkonsistensi pembersihan, operator dan fungsi baru (&lt;=&gt;, ??) muncul. </li></ul><br>  Inovasi itu baik, tetapi kembali ke perubahan internal.  Mari kita bicara tentang jalur yang diikuti PHP 7 dan di mana jalur ini dapat membawa kita. <br><br><h2>  zval </h2><br>  Ini adalah struktur data PHP dasar.  Ini digunakan untuk <strong>mewakili nilai apa pun dalam PHP</strong> .  Karena bahasa kita diketik secara dinamis dan jenis variabel dapat berubah selama eksekusi program, kita perlu menyimpan bidang tipe (tipe zend_uchar), yang dapat mengambil nilai IS_NULL, IS_BOOL, IS_LONG, IS_DOUBLE, IS_ARRAY, IS_OBJECT, dll., Dan sebenarnya nilai yang diwakili oleh gabungan (nilai), tempat bilangan bulat, bilangan real, string, array, atau objek dapat disimpan. <br><br><h3>  zval di PHP 5 </h3><br>  Memori untuk setiap struktur tersebut dialokasikan secara terpisah di Heap.  Selain jenis dan nilai, counter referensi ke struktur juga disimpan di dalamnya.  Jadi strukturnya membutuhkan 24 byte, tidak termasuk overhead dari manajer memori dan pointer ke sana. <br><br>  Gambar di kanan atas menunjukkan struktur data yang dibuat dalam memori PHP 5 untuk skrip sederhana. <br><br><img src="https://habrastorage.org/webt/m8/km/ix/m8kmixgehjrhtxthe-gefmmi86i.png"><br><br>  Pada stack, memori dialokasikan untuk 4 variabel yang diwakili oleh pointer.  Nilai-nilai itu sendiri (zval) ada di heap.  Dalam kasus kami, ini hanya dua zval, yang masing-masing direferensikan oleh dua variabel, dan karenanya penghitung referensi mereka diatur ke 2. <br><br>  Untuk mengakses jenis atau nilai skalar, Anda memerlukan setidaknya dua bacaan: pertama baca nilai pointer, dan kemudian nilai struktur.  Jika Anda perlu membaca bukan nilai skalar, tetapi, misalnya, bagian dari string atau array, maka Anda akan memerlukan setidaknya satu bacaan lagi. <br><br><h3>  zval di PHP 7 </h3><br>  Di mana kami menggunakan pointer sebelumnya, di tujuh kami mulai menanamkan zval.  Kami telah beralih dari penghitungan referensi untuk jenis skalar.  Jenis dan nilai bidang tetap tanpa perubahan signifikan, tetapi beberapa bendera lagi dan tempat yang dipesan ditambahkan, yang akan saya bicarakan nanti. <br><br><img src="https://habrastorage.org/webt/tz/we/yn/tzweyn8n32_rntdwwjxhz-fbwc4.png"><br><br>  Di sebelah kiri terlihat seperti apa di PHP 5, dan di sebelah kanan, di PHP 7. <br><br><img src="https://habrastorage.org/webt/5n/wl/4h/5nwl4hrqaqr2kb4pmenzvbtrnh4.png"><br><br>  Sekarang zval sendiri ada di tumpukan.  Untuk membaca jenis dan nilai skalar, cukup satu instruksi mesin saja.  Semua nilai dikelompokkan dalam satu area memori, yang berarti bahwa ketika bekerja dengan variabel lokal, kita praktis tidak akan mengalami kerugian karena kehilangan cache prosesor.  Tetapi kekuatan sebenarnya dari kinerja baru termasuk ketika menyalin diperlukan. <br><br><h3>  Salin Rekam </h3><br>  Di baris teratas skrip, tugas lain ditambahkan. <br><br><img src="https://habrastorage.org/webt/kb/yr/ww/kbyrwwvzaeuqpt8quf1lyujztjo.png"><br><br>  Dalam PHP5, kami mengalokasikan memori dari heap untuk zval baru, menginisialisasi intnya (2), mengubah nilai pointer ke variabel b, dan menurunkan penghitung referensi dari nilai yang disebutkan b sebelumnya. <br><br>  Di PHP 7, kami cukup <strong>menginisialisasi variabel b langsung di tempat dengan beberapa instruksi</strong> , sedangkan di PHP 5 diperlukan ratusan instruksi.  Jadi zval terlihat sekarang di memori. <br><br><img src="https://habrastorage.org/webt/ax/ab/sa/axabsadvso8c49azoqvvks5jsfc.png"><br><br>  Ini adalah dua kata 64-bit.  Kata pertama <strong>artinya:</strong> integer, real atau pointer.  Pada kata kedua, <strong>tipe</strong> (dikatakan bagaimana mengartikan makna), bendera, dan tempat yang dipesan yang masih akan ditambahkan saat menyelaraskan.  Tapi itu tidak hilang, tetapi digunakan oleh berbagai subsistem untuk menyimpan nilai yang terkait secara tidak langsung. <br><br>  <strong>Bendera adalah seperangkat bit di</strong> mana setiap bit menunjukkan apakah zval mendukung protokol.  Misalnya, jika <code>IS_TYPE_REFCOUNTED</code> , maka ketika bekerja dengan zval ini, mesin harus menjaga nilai penghitung referensi.  Ketika menetapkan, meningkat, ketika meninggalkan ruang lingkup, kurangi, jika penghitung referensi mencapai nol, hancurkan struktur dependen. <br><br>  Dari jenis tersebut, dibandingkan dengan PHP 5, beberapa yang baru muncul. <br><br><ul><li>  <code>IS_UNDEF</code> - penanda variabel tidak diinisialisasi. </li><li>  <code>IS_BOOL</code> tunggal digantikan oleh <code>IS_FALSE</code> dan <code>IS_FALSE</code> terpisah. </li><li>  Menambahkan tipe terpisah untuk tautan dan beberapa jenis sihir lainnya. </li></ul><br>  Jenis dari <code>IS_UNDEF</code> ke <code>IS_DOUBLE</code> adalah skalar, dan tidak memerlukan memori tambahan.  Untuk menyalinnya, cukup menyalin mesin 64-bit kata pertama dengan nilai dan setengah detik dengan jenis dan bendera. <br><br><h3>  Dihitung ulang </h3><br>  Dengan tipe lain lebih sulit.  Mereka semua diwakili oleh struktur bawahan, dan zval hanya menyimpan referensi ke struktur ini.  Untuk setiap jenis, struktur ini berbeda, tetapi dalam hal OOP, mereka semua memiliki leluhur abstrak yang sama atau struktur zend_refcounted.  Ini menentukan format kata <strong>64-bit</strong> pertama, tempat penghitungan referensi dan informasi lain untuk pengumpul sampah disimpan. <br><br><img src="https://habrastorage.org/webt/vn/zm/yy/vnzmyywum831lpzipgxtenm_98s.png"><br><br>  Kata ini dapat dianggap hanya sebagai informasi untuk pengumpul sampah, dan struktur untuk tipe tertentu menambahkan bidang mereka setelah kata pertama ini. <br><br><h3>  Garis </h3><br>  Dalam tujuh untuk string, kami menyimpan nilai yang dihitung dari fungsi hash, panjangnya dan karakter itu sendiri.  Ukuran struktur seperti itu adalah variabel dan tergantung pada panjang tali.  Fungsi hash dihitung untuk string sekali, bila perlu.  Di PHP 5, itu dihitung ulang di setiap kebutuhan. <br><br><img src="https://habrastorage.org/webt/em/2t/ax/em2tax1wdnckpbzqxjh1tlqn37o.png"><br><br>  Sekarang string telah menjadi referensi yang dapat dihitung, dan jika dalam PHP 5 kita menyalin karakter itu sendiri, sekarang cukup untuk meningkatkan jumlah referensi untuk struktur ini. <br><br>  Seperti dalam PHP 5, kami masih memiliki konsep <strong>string yang tidak dapat diubah atau diinternir</strong> .  Mereka biasanya ada dalam satu contoh, hidup sampai akhir permintaan, dan dapat berperilaku seperti nilai skalar.  Kita tidak perlu mengurus konter referensi kepada mereka, dan untuk menyalinnya cukup menyalin hanya zval itu sendiri dengan bantuan empat instruksi mesin. <br><br><h3>  Array </h3><br>  Array diwakili oleh tabel hash bawaan dan tidak jauh berbeda dari PHP 5. Tabel hash itu sendiri telah berubah, tetapi lebih pada itu secara terpisah. <br><br><img src="https://habrastorage.org/webt/_u/kn/ls/_uknlsdbw247d7whq_-euez8zuw.png"><br><br>  Array sekarang merupakan <strong>struktur adaptif</strong> yang sedikit mengubah struktur internal dan perilakunya tergantung pada data yang disimpan.  Jika kita menyimpan hanya elemen dengan kunci numerik dekat, maka kita mendapatkan akses ke elemen secara langsung dengan indeks dengan kecepatan yang sebanding dengan kecepatan array di C. Tetapi jika Anda menambahkan elemen dengan kunci string ke array yang sama, itu berubah menjadi hash nyata dengan resolusi tabrakan. <br><br>  Ini adalah bagaimana tabel hash terlihat seperti di PHP 5. <br><br><img src="https://habrastorage.org/webt/d6/c-/6r/d6c-6rvue6zlsyyhnscfyjtnjj4.png"><br><br>  Ini adalah implementasi tabel hash klasik dengan resolusi tabrakan menggunakan daftar linear (ditunjukkan di sudut kanan atas).  Setiap item diwakili oleh ember.  Semua Bucket ditautkan oleh daftar yang ditautkan ganda untuk menyelesaikan tabrakan, dan ditautkan oleh daftar lain yang ditautkan dua kali untuk berurutan.  Nilai untuk setiap zval dialokasikan secara terpisah - di Bucket kami hanya menyimpan tautan ke sana.  Juga, kunci string dapat dialokasikan secara terpisah. <br><br>  Jadi, untuk setiap tabel hash, Anda perlu mengalokasikan banyak blok kecil memori, dan untuk menemukan sesuatu nanti, Anda harus menjalankan sepanjang pointer.  Setiap transisi tersebut dapat menyebabkan cahce miss dan penundaan ~ 10-100 siklus prosesor. <br><br>  Inilah yang terjadi di PHP 7. <br><br><img src="https://habrastorage.org/webt/g_/mk/ax/g_mkaxt7a0ua8shao-rzketmjag.png"><br><br>  Struktur logis tetap tidak berubah, hanya yang fisik yang berubah.  Sekarang, di bawah tabel hash, memori dialokasikan dengan satu operasi. <br><br>  Dalam gambar, di bagian bawah penunjuk dasar, ada elemen, dan di bagian atas adalah array hash yang ditangani oleh fungsi hash.  Untuk array datar atau penuh, ketika kami menyimpan hanya elemen dengan indeks numerik, bagian atas tidak dialokasikan sama sekali, dan kami menangani Bucket langsung dengan nomor. <br><br>  Untuk memotong elemen, kami mengurutkannya secara berurutan dari atas ke bawah atau dari bawah ke atas, yang dilakukan oleh prosesor modern dengan sempurna.  Nilai-nilai dibangun ke dalam Bucket, tetapi ruang yang disediakan di dalamnya hanya digunakan untuk menyelesaikan tabrakan.  Ini menyimpan indeks Bucket lain dengan nilai fungsi hash yang sama atau akhir penanda daftar. <br><br>  Memori untuk nilai string kunci dialokasikan secara terpisah, tetapi masih zend_string yang sama.  Saat menempelkan ke dalam array, cukup menambah counter referensi string, meskipun sebelumnya kita harus menyalin karakter secara langsung, dan saat mencari, kita sekarang tidak dapat membandingkan karakter, tetapi pointer ke string sendiri. <br><br><h3>  Array yang Tidak Berubah </h3><br>  Sebelumnya, kami memiliki string yang tidak dapat diubah, tetapi sekarang array yang tidak berubah juga telah muncul.  Seperti string, mereka tidak menggunakan jumlah referensi dan tidak dihancurkan sampai akhir permintaan.  Ini adalah skrip sederhana yang membuat array dari sejuta elemen, dan setiap elemen adalah array yang sama dengan satu elemen "halo". <br><br><img src="https://habrastorage.org/webt/uv/sm/lu/uvsmluqtfldezjnbbfdqvd83sr8.png"><br><br>  Dalam PHP 5, pada setiap iterasi loop, array kosong baru dibuat, "halo" ditulis untuk itu, dan semua ini ditambahkan ke array yang dihasilkan.  Dalam PHP 7, pada tahap kompilasi, kami <strong>membuat hanya satu array</strong> yang <strong>tidak berubah</strong> yang berperilaku seperti skalar, dan menambahkannya ke yang dihasilkan.  Dalam contoh yang disajikan, ini memungkinkan kita untuk mencapai pengurangan konsumsi memori lebih dari 10 kali lipat dan akselerasi hampir 10 kali lipat. <br><br>  Array konstan jutaan elemen dalam aplikasi nyata, tentu saja, tidak sering ditemukan, tetapi yang kecil cukup umum.  Pada masing-masing dari mereka Anda akan mendapatkan yang kecil, tetapi menang. <br><br><h3>  Benda-benda </h3><br>  Tautan ke semua objek di PHP 5 terletak di repositori terpisah, dan di zval hanya ada handle - ID objek unik. <br><br><img src="https://habrastorage.org/webt/in/lo/dq/inlodqhjne7lo12nslgcuqrckvy.png"><br><br>  Untuk sampai ke objek, kami membuat setidaknya 3 pembacaan.  Selain itu, memori untuk nilai setiap properti objek dialokasikan secara terpisah, dan kami membutuhkan setidaknya 2 bacaan lagi untuk membacanya. <br><br>  Di PHP 7, kami dapat beralih ke pengalamatan langsung. <br><br><img src="https://habrastorage.org/webt/zm/vp/vv/zmvpvvqlmybttr3zvze6gzglin4.png"><br><br>  Alamat <code>zend_object</code> dapat diakses dengan instruksi mesin tunggal.  Dan Properti built-in dan untuk membacanya Anda hanya perlu satu bacaan tambahan.  Mereka juga dikelompokkan bersama, yang <strong>meningkatkan lokalitas data</strong> dan membantu prosesor modern tidak tersandung. <br><br>  Selain properti yang telah ditentukan, tautan ke kelas objek ini juga disimpan di sini, beberapa penangan - analog dengan tabel metode virtual, dan tabel hash untuk properti yang belum ditentukan.  Di PHP, Anda bisa menambahkan properti ke objek apa pun yang awalnya tidak ditentukan, dan jika beberapa instruksi mesin cukup untuk mengakses properti yang telah ditentukan, maka untuk properti non-standar Anda harus menggunakan tabel hash, yang akan membutuhkan banyak instruksi mesin.  Tentu saja, ini jauh lebih mahal. <br><br><h3>  Referensi </h3><br>  Akhirnya, kami harus memperkenalkan <strong>tipe terpisah</strong> untuk mewakili tautan PHP. <br><br><img src="https://habrastorage.org/webt/yk/jj/ng/ykjjngfnlq8sefuvmwzjfxwjz7g.png"><br><br>  Ini adalah tipe yang sepenuhnya transparan.  Itu tidak terlihat oleh skrip PHP.  Script melihat zval lain yang dibangun ke dalam struktur zend_reference.  Dapat dipahami bahwa kita merujuk ke satu struktur seperti itu dari setidaknya dua tempat, dan penghitung referensi dari struktur ini selalu lebih besar dari 1. Begitu penghitung turun ke 1, tautan berubah menjadi nilai skalar biasa.  Zval yang tertanam dalam tautan disalin ke zval terakhir yang merujuknya, dan strukturnya sendiri dihapus. <br><br>  Tampaknya bekerja dengan referensi sekarang jauh lebih rumit daripada dengan jenis lain (dan ini benar), tetapi pada kenyataannya dalam PHP 5 kami harus melakukan pekerjaan dengan kompleksitas yang sebanding ketika mengakses nilai apa pun (bahkan bilangan bulat utama).  Sekarang kami menerapkan protokol yang lebih kompleks hanya untuk satu jenis dan dengan demikian mempercepat pekerjaan dengan yang lainnya, terutama dengan nilai skalar. <br><br><h3>  IS_FALSE dan IS_TRUE </h3><br>  Saya sudah mengatakan bahwa tipe tunggal IS_BOOL dibagi menjadi IS_FALSE dan IS_TRUE terpisah.  Gagasan ini dimata-matai dalam implementasi LuaJIT, dan dibuat untuk mempercepat salah satu operasi yang paling umum - transisi bersyarat. <br><br><img src="https://habrastorage.org/webt/fv/5j/-z/fv5j-zx0u_2kfmtmxjwce4uzetk.png"><br><br>  Jika dalam PHP 5 ia harus membaca jenisnya, memeriksa boolean, membaca nilainya, mencari tahu apakah itu benar atau salah dan melakukan transisi berdasarkan ini, sekarang cukup untuk cukup memeriksa jenisnya dan membandingkannya dengan benar: <br><br><ul><li>  jika itu benar, maka kita pergi bersama satu cabang; </li><li>  jika itu kurang dari benar, pergi ke cabang lain; </li><li>  jika lebih dari benar, buka apa yang disebut jalur lambat (jalur lambat) dan di sana kita periksa jenis asalnya dan apa yang harus dilakukan dengannya: jika itu bilangan bulat, maka kita harus membandingkan nilainya dengan 0, jika mengambang - lagi dengan 0 ( tapi nyata), dll. </li></ul><br><h2>  Konvensi panggilan </h2><br>  Perubahan dalam Konvensi Panggilan atau konvensi panggilan fungsi merupakan optimasi penting yang memengaruhi tidak hanya struktur data, tetapi juga algoritma yang mendasarinya.  Pada gambar di sebelah kiri adalah skrip kecil yang terdiri dari fungsi foo () dan panggilannya.  Di bawah ini adalah bytecode di mana skrip ini dikompilasi oleh PHP 5. <br><br><img src="https://habrastorage.org/webt/bn/fw/a4/bnfwa4e5ifjqs6rd6cp66uctega.png"><br><br>  Pertama, saya akan memberi tahu Anda cara kerjanya di PHP 5. <br><br><h3>  Konvensi Panggilan di PHP 5 </h3><br>  Pernyataan <code>SEND_VAL</code> pertama adalah mengirim nilai "3" ke fungsi foo.  Untuk melakukan ini, dia terpaksa mengalokasikan zval baru di heap, salin nilai (3) di sana dan tulis nilai pointer ke struktur ini ke stack. <br><br><img src="https://habrastorage.org/webt/mt/vu/d3/mtvud3tb2ljaijnwecbmvnqepjs.png"><br><br>  Begitu pula dengan instruksi kedua.  Selanjutnya <code>DO_FCALL</code> menginisialisasi <code>CALL FRAME</code> , memesan tempat untuk variabel lokal dan sementara, dan mentransfer kontrol ke fungsi yang dipanggil. <br><br><img src="https://habrastorage.org/webt/rx/rw/qo/rxrwqogtbhgd0q9tsd7wnw2r4og.png"><br><br>  <code>RECV</code> pertama memeriksa argumen pertama dan menginisialisasi slot pada stack dengan variabel lokal yang sesuai ($ a).  Di sini kami melakukannya tanpa menyalin dan hanya meningkatkan penghitung referensi dari parameter yang sesuai (zval dengan nilai 3).  Demikian pula, <code>RECV</code> kedua membuat koneksi antara variabel $ b dan parameter 5. <br><br><img src="https://habrastorage.org/webt/lw/c1/zw/lwc1zw26uby_oj54yjzu7yz-vus.png"><br><br>  Fungsi tubuh selanjutnya.  3 + 5 penambahan terjadi - ternyata 8. Ini adalah variabel sementara dan nilainya disimpan langsung di tumpukan. <br><br><img src="https://habrastorage.org/webt/d0/xj/s5/d0xjs5j2c0i6qgioybezypay9k4.png"><br><br>  KEMBALI dan kita kembali dari fungsi. <br><br><img src="https://habrastorage.org/webt/zd/cc/nb/zdccnbal1xuynwdcymbrwcf2fmq.png"><br><br>  Saat kembali, kami merilis semua variabel dan argumen yang di luar cakupan.  Untuk melakukan ini, kita melalui semua zval yang direferensikan oleh slot dari frame yang dibebaskan, dan untuk masing-masing kita mengurangi jumlah referensi.  Jika mencapai 0, maka hancurkan struktur yang sesuai. <br><br>  Seperti yang Anda lihat, bahkan operasi sederhana seperti mengirim konstanta ke suatu fungsi membutuhkan mengalokasikan memori baru, menyalin dan meningkatkan penghitung referensi, dan kemudian juga mengurangi dan menghapus dua kali lipat. <br><br><h3>  Konvensi Panggilan di PHP 7 </h3><br>  Di PHP 7, masalah ini telah diperbaiki - sekarang di stack kami menyimpan bukan zval pointer, tetapi zval itu sendiri. <br><br><img src="https://habrastorage.org/webt/xc/ek/ls/xceklspoxwmga__zvpeat1a4plw.png"><br><br>  Kami juga memperkenalkan instruksi baru, <code>INIT_FCALL</code> , yang sekarang bertanggung jawab untuk menginisialisasi dan mengalokasikan memori di bawah <code>CALL FRAME</code> , dan menyediakan ruang untuk argumen dan variabel sementara. <br><br><img src="https://habrastorage.org/webt/yi/gd/a5/yigda5wg7xswdcyadip7euboboa.png"><br><br>  <code>SEND_VAL 3</code> sekarang hanya menyalin argumen ke slot pertama setelah <code>CALL FRAME</code> .  Selanjutnya <code>SEND_VAL 5</code> ke slot kedua. <br><br><img src="https://habrastorage.org/webt/-0/es/8_/-0es8_skigjtyvja3vzzegwo-su.png"><br><br>  Maka yang paling menarik.  Tampaknya <code>DO_FCALL</code> harus memberikan kontrol ke instruksi pertama dari fungsi yang dipanggil.  Tetapi argumen sudah mengenai slot yang dicadangkan untuk parameter variabel $ a dan $ b, dan instruksi <code>RECV</code> tidak melakukan apa-apa.  Karena itu, Anda dapat melewati mereka.  Kami mengirim dua parameter, jadi kami lewati dua instruksi.  Jika mereka mengirim tiga, mereka akan melewatkan tiga. <br><br><img src="https://habrastorage.org/webt/4z/vm/gj/4zvmgjldpmtfpgprtvqoks__-km.png"><br><br>  Jadi kita langsung ke fungsi tubuh, membuat penambahan dan kembali. <br><br><img src="https://habrastorage.org/webt/zh/j1/yf/zhj1yfwxp5kf1s4xxlyoasy170i.png"><br><br>  Ketika kembali, kami menghapus semua variabel lokal, tetapi sekarang hanya untuk dua slot, dan karena kami memiliki skalar di sana, kami kembali tidak perlu melakukan apa pun. <br><br><img src="https://habrastorage.org/webt/wy/dh/2p/wydh2pvz_hpawjivtoxx3hmxoqa.png"><br><br>  Cerita saya sedikit disederhanakan, tidak memperhitungkan fungsi akun dengan sejumlah variabel argumen dan kebutuhan untuk pengecekan tipe dan beberapa poin lainnya. <br><br>  <strong>Konvensi Panggilan yang baru telah sedikit merusak kompatibilitas</strong> .  PHP memiliki fungsi seperti <code>func_get_arg</code> dan <code>func_get_args</code> .  Jika sebelumnya mereka mengembalikan nilai asli dari parameter yang dikirim, sekarang mereka mengembalikan nilai saat ini dari variabel lokal yang sesuai, karena kami tidak menyimpan nilai aslinya.  Seperti halnya C. debuggers <br><br><img src="https://habrastorage.org/webt/5r/n2/6j/5rn26j24gjyfolmeu07qgv1wmxu.png"><br><br>  Selain itu, fungsi tidak lagi dapat memiliki beberapa parameter dengan nama yang sama.  Tidak ada gunanya dalam hal ini sebelumnya, tetapi saya bertemu dengan kode PHP <code>foo($_, $_)</code> .  Seperti apa bentuknya?  (Saya mengenali Prolog) <br><br><h2>  Manajer memori baru </h2><br>  Setelah selesai dengan optimalisasi struktur data dan algoritma dasar, kami sekali lagi menarik perhatian ke semua subsistem pengereman.  Manajer memori di PHP 5 memakan waktu <strong>hampir 20% dari waktu prosesor</strong> di Wordpress. <br><br>  Setelah kami menyingkirkan banyak alokasi, biaya overhead-nya menjadi lebih sedikit, tetapi masih signifikan - dan bukan karena ia melakukan pekerjaan yang signifikan, tetapi karena ia tersandung pada cache.  Ini terjadi karena fakta bahwa kami menggunakan algoritma malloc klasik Doug Lea, yang melibatkan menemukan lokasi memori bebas yang cocok dengan melakukan perjalanan melalui tautan dan pohon, dan semua perjalanan ini pasti menyebabkan kesalahan cache. <br><br>  Saat ini, ada algoritma manajemen memori baru yang mempertimbangkan fitur prosesor modern.  Misalnya: <strong>jemalloc</strong> dan <strong>ptmalloc dari Google</strong> .  Pada awalnya, kami mencoba menggunakannya tidak berubah, tetapi tidak mendapatkan kemenangan, karena kurangnya fungsionalitas khusus PHP membuatnya lebih mahal untuk benar-benar membebaskan memori pada akhir permintaan.  Akibatnya, kami meninggalkan dlmalloc dan menulis sesuatu dari kami sendiri, menggabungkan ide-ide dari manajer memori lama dan jemalloc. <br><br>  Kami telah <strong>mengurangi overhead Memory Manager hingga 5%</strong> , mengurangi overhead memori untuk informasi layanan dan meningkatkan penggunaan cache CPU.  Blok memori yang sesuai sekarang dicari oleh bitmap, memori untuk blok kecil dialokasikan dari halaman individual dan di-cache saat dirilis, fungsi-fungsi khusus untuk ukuran blok yang sering digunakan ditambahkan. <br><br><h2>  Banyak perbaikan kecil </h2><br>  Saya hanya berbicara tentang perbaikan yang paling penting, tetapi ada jauh lebih kecil.  Saya dapat menyebutkan beberapa dari mereka. <br><br><ul><li>  API cepat untuk mem-parsing parameter fungsi internal dan API baru untuk iterasi di atas HashTable. </li><li>  Instruksi VM baru: penggabungan string, spesialisasi, instruksi super. </li><li>  Beberapa fungsi internal telah diubah menjadi instruksi VM: strlen, is_int. </li><li>  Menggunakan register CPU untuk register VM: IP dan FP. </li><li>  Optimalisasi duplikasi dan penghapusan array. </li><li>  Menggunakan jumlah tautan alih-alih menyalin di mana pun Anda bisa. </li><li>  PCRE JIT. </li><li>  Optimalisasi fungsi internal dan serialisasi (). </li><li>  Mengurangi ukuran kode dan memproses data. </li></ul><br>  Beberapa sangat sederhana, misalnya, hanya membutuhkan tiga baris kode untuk mengaktifkan JIT dalam ekspresi Perl reguler, dan ini segera membawa akselerasi yang terlihat (2-3%) ke hampir semua aplikasi.  Optimalisasi lainnya menyentuh beberapa aspek sempit dari fungsi PHP tertentu, dan tidak terlalu menarik, meskipun kontribusi total dari semua perbaikan kecil ini cukup signifikan. <br><br><h2>  Kamu datang ke apa </h2><br>  Ini adalah kontribusi berbagai subsistem pada WordPress / PHP 7.0. <br><br><img src="https://habrastorage.org/webt/7q/r4/d0/7qr4d08m8yhid4rngwh9-gffxbu.png"><br><br>  Kontribusi mesin virtual meningkat hingga 50%. Memory Manager    5% —         Memory Manager,        .         130 . ,    10 .  ,           Memory Manager           ,         . <br><br><img src="https://habrastorage.org/webt/kk/nq/5p/kknq5ppnd1ihr8wjw9xfv38boyy.png"><br>   : <br><br><ul><li>      2 . </li><li>   MM   17 . </li><li> -     4 . </li><li>    WordPress   3,5 . </li></ul><br>       2,5-  ,    .  ?   ,         ,        CPU time,   —  ,    .  PHP     ,        . <br><br><h3>  PHP 7 </h3><br> WordPress 3.6      —         .  - ,   PHP 7   mysql,     ,     . <br><br><img src="https://habrastorage.org/webt/bs/x9/pa/bsx9pa3fc3ccedmnajaj1h5dm0q.png"><br><br>   ,          PHPNG.     2/3 .     ,    . <br><br> ,       WordPress,      ,      —  1,5  2- . <br><br><h3> PHP 7  HHVM </h3><br>              HHVM. <br><br><img src="https://habrastorage.org/webt/fs/vg/ot/fsvgotogozunvqed7dwflmmef1u.png"><br><br>      —  .     .   Facebook   .   HHVM   . ,      ,     ,    ,      . <br><br><img src="https://habrastorage.org/webt/c_/pg/jv/c_pgjvoejr-q3o5sgvgtplxkbm0.png"><br><br>  PHP 7 —    .    Vebia,  Etsy  Badoo. Highload-    ,       . <br><br>   PHP 7.0  Etsy  Badoo       -. Badoo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    . <br><br><img src="https://habrastorage.org/webt/pn/rv/rj/pnrvrjrzp9re46lbmngnyddzu44.png"><br><br>  ,          2 ,    —   7 . <br><br>         PHP 7.0.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,  PHP 7.1,        . <br><br><blockquote>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP Russia</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>        <b>PHP 8</b> .         PHP,  ,    ,      — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>  1 .  , ,    —   ,    ,     ,  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444508/">https://habr.com/ru/post/id444508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444494/index.html">La Moto Volante (Lazareth LMV 496) - motor transformator terbang</a></li>
<li><a href="../id444496/index.html">Alat baru untuk mendeteksi intersepsi HTTPS</a></li>
<li><a href="../id444500/index.html">29 Maret, Moskow - Backend Stories 3.0</a></li>
<li><a href="../id444502/index.html">Apakah kriptografi kuantum benar-benar dapat diandalkan?</a></li>
<li><a href="../id444504/index.html">Menggunakan direktori paket lokal di Python sekarang</a></li>
<li><a href="../id444512/index.html">Membuat aplikasi grafis untuk menyelesaikan masalah jalannya kuda</a></li>
<li><a href="../id444514/index.html">Webinar "Keamanan Pembelajaran Mesin: Masalah Alami Kecerdasan Buatan"</a></li>
<li><a href="../id444516/index.html">Wolfenstein 3D: ray tracing dengan WebGL1</a></li>
<li><a href="../id444518/index.html">Menuju teori kesadaran mendasar</a></li>
<li><a href="../id444520/index.html">2. Periksa Titik Memulai R80.20. Arsitektur Solusi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>