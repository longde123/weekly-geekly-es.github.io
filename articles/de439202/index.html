<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐢 🕓 💅🏾 Web Attack Detection mit Seq2Seq Auto Encoder 👩🏾‍🔬 🐺 👓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Erkennen von Angriffen ist seit Jahrzehnten eine wichtige Aufgabe in der Informationssicherheit. Die ersten bekannten Beispiele für die Implementi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Web Attack Detection mit Seq2Seq Auto Encoder</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/439202/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="Bild"></a> <br><br>  Das Erkennen von Angriffen ist seit Jahrzehnten eine wichtige Aufgabe in der Informationssicherheit.  Die ersten bekannten Beispiele für die Implementierung von IDS stammen aus den frühen 1980er Jahren. <br><br>  Nach mehreren Jahrzehnten bildete sich eine ganze Branche von Angriffserkennungswerkzeugen.  Derzeit gibt es verschiedene Arten von Produkten wie IDS, IPS, WAF und Firewalls, von denen die meisten eine regelbasierte Angriffserkennung bieten.  Die Idee, Anomalieerkennungstechniken zu verwenden, um Angriffe basierend auf Produktionsstatistiken zu erkennen, scheint nicht so realistisch wie in der Vergangenheit.  Oder egal? .. <a name="habracut"></a><br><br><h2>  Anomalieerkennung in Webanwendungen </h2><br>  Die ersten Firewalls, die speziell zur Erkennung von Angriffen auf Webanwendungen entwickelt wurden, wurden Anfang der neunziger Jahre auf den Markt gebracht.  Seitdem haben sich sowohl die Angriffsmethoden als auch die Abwehrmechanismen erheblich geändert, und Angreifer können jederzeit einen Schritt voraus sein. <br><br>  Derzeit versuchen die meisten WAFs, Angriffe wie folgt zu erkennen: Es gibt einige regelbasierte Mechanismen, die in den Reverse-Proxy-Server integriert sind.  Das auffälligste Beispiel ist mod_security, das WAF-Modul für den Apache-Webserver, das 2002 entwickelt wurde.  Das Identifizieren von Angriffen anhand von Regeln hat mehrere Nachteile.  Beispielsweise können die Regeln keine Zero-Day-Angriffe erkennen, während dieselben Angriffe von einem Experten leicht erkannt werden können. Dies ist nicht überraschend, da das menschliche Gehirn nicht wie eine Reihe regulärer Ausdrücke funktioniert. <br><br>  Aus Sicht von WAF können Angriffe in solche unterteilt werden, die wir anhand der Reihenfolge der Anforderungen erkennen können, und solche, bei denen eine HTTP-Anforderung (Antwort) ausreicht, um sie zu lösen.  Unsere Forschung konzentriert sich auf die Erkennung der letzteren Arten von Angriffen - SQL-Injection, Cross Site Scripting, Injection von externen XML-Entitäten, Pfadüberquerung, Betriebssystembefehle, Objektinjektion usw. <br><br>  Aber zuerst testen wir uns. <br><br><h2>  Was wird der Experte denken, wenn er die folgenden Fragen sieht? </h2><br>  Sehen Sie sich eine Beispiel-HTTP-Anfrage an Anwendungen an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="Bild"><br><br>  Wenn Sie die Aufgabe erhalten haben, böswillige Anforderungen an eine Anwendung zu erkennen, möchten Sie höchstwahrscheinlich das übliche Benutzerverhalten für einige Zeit beobachten.  Wenn Sie die Abfragen auf mehrere Endpunkte der Anwendung untersuchen, erhalten Sie einen allgemeinen Überblick über die Struktur und Funktionen ungefährlicher Abfragen. <br><br>  Jetzt erhalten Sie die folgende Abfrage zur Analyse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="Bild"><br><br>  Es ist sofort ersichtlich, dass hier etwas nicht stimmt.  Es wird einige Zeit dauern, um zu verstehen, wie es hier wirklich ist, und sobald Sie den Teil der Anfrage identifiziert haben, der abnormal erscheint, können Sie darüber nachdenken, um welche Art von Angriff es sich handelt.  Im Wesentlichen ist es unser Ziel, dass unsere „künstliche Intelligenz zur Erkennung von Angriffen“ auf die gleiche Weise funktioniert - ähnlich wie menschliches Denken. <br><br>  Die offensichtliche Sache ist, dass ein Teil des Datenverkehrs, der auf den ersten Blick böswillig erscheint, für eine bestimmte Website normal sein kann. <br><br>  Betrachten wir zum Beispiel die folgenden Abfragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="Bild"><br><br>  Ist diese Abfrage abnormal? <br><br>  Tatsächlich handelt es sich bei dieser Anforderung um eine Veröffentlichung eines Fehlers im Jira-Tracker, der für diesen Dienst typisch ist. Dies bedeutet, dass die Anforderung erwartet und normal ist. <br><br>  Betrachten Sie nun das folgende Beispiel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="Bild"><br><br>  Auf den ersten Blick sieht die Anfrage wie eine normale Benutzerregistrierung auf einer auf Joomla CMS basierenden Website aus.  Die angeforderte Operation ist jedoch user.register anstelle der üblichen register.register.  Die erste Option ist veraltet und enthält eine Sicherheitsanfälligkeit, mit der sich jeder als Administrator registrieren kann.  Ein Exploit für diese Sicherheitsanfälligkeit wird als Joomla &lt;3.6.4 Kontoerstellung / Eskalation von Berechtigungen (CVE-2016-8869, CVE-2016-8870) bezeichnet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="Bild"><br><br><h2>  Wo haben wir angefangen? </h2><br>  Natürlich haben wir zuerst die vorhandenen Lösungen für das Problem untersucht.  Seit Jahrzehnten werden verschiedene Versuche unternommen, Angriffserkennungsalgorithmen auf der Grundlage von Statistiken oder maschinellem Lernen zu erstellen.  Einer der beliebtesten Ansätze ist die Lösung des Klassifizierungsproblems, wenn es sich bei Klassen um „erwartete Abfragen“, „SQL-Injektionen“, XSS, CSRF usw. handelt. Auf diese Weise können Sie mit dem Klassifizierer eine gute Genauigkeit für den Datensatz erzielen Dieser Ansatz löst jedoch aus unserer Sicht keine sehr wichtigen Probleme: <br><br><ol><li>  <b>Die Klassenauswahl ist begrenzt und vorbestimmt</b> .  Was ist, wenn Ihr Modell im Lernprozess durch drei Klassen dargestellt wird, z. B. "normale Abfragen", SQLi und XSS, und während des Systembetriebs auf eine CSRF oder einen Zero-Day-Angriff stößt? </li><li>  <b>Die Bedeutung dieser Klassen</b> .  Angenommen, Sie müssen zehn Clients schützen, auf denen jeweils völlig unterschiedliche Webanwendungen ausgeführt werden.  Für die meisten von ihnen haben Sie keine Ahnung, wie die SQL-Injection für ihre Anwendung tatsächlich aussieht.  Dies bedeutet, dass Sie Trainingsdatensätze irgendwie künstlich erstellen müssen.  Dieser Ansatz ist nicht optimal, da Sie letztendlich aus Daten lernen, die sich in der Verteilung von realen Daten unterscheiden. </li><li>  <b>Interpretierbarkeit der Modellergebnisse</b> .  Nun, das Modell hat das SQL Injection-Ergebnis erzeugt, und was nun?  Sie und, was noch wichtiger ist, Ihr Kunde, der als erster eine Warnung sieht und normalerweise kein Experte für Webangriffe ist, müssen raten, welchen Teil der Anfrage Ihr Modell als bösartig ansieht. </li></ol><br>  Angesichts all dieser Probleme haben wir uns entschlossen, das Klassifikatormodell trotzdem zu trainieren. <br><br>  Da das HTTP-Protokoll ein Textprotokoll ist, war es offensichtlich, dass wir uns moderne Textklassifizierer ansehen mussten.  Ein bekanntes Beispiel ist die Stimmungsanalyse in einem IMDB-Filmkritik-Datensatz.  Einige Lösungen verwenden RNN, um Bewertungen zu klassifizieren.  Wir haben uns entschlossen, ein ähnliches Modell mit RNN-Architektur mit einigen geringfügigen Unterschieden auszuprobieren.  Beispielsweise verwendet die RNN-Architektur in natürlicher Sprache eine Vektordarstellung von Wörtern, es ist jedoch nicht klar, welche Wörter in einer unnatürlichen Sprache wie HTTP gefunden werden.  Aus diesem Grund haben wir uns für die Vektordarstellung von Symbolen für unsere Aufgabe entschieden. <br><br>  Vorgefertigte Darstellungen lösen unser Problem nicht. Daher haben wir einfache Zuordnungen von Zeichen zu numerischen Codes mit mehreren internen Markierungen wie <code>GO</code> und <code>EOS</code> . <br><br>  Nachdem die Entwicklung und das Testen des Modells abgeschlossen waren, wurden alle zuvor vorhergesagten Probleme offensichtlich, aber zumindest unser Team wechselte von nutzlosen Annahmen zu einem Ergebnis. <br><br><h2>  Was weiter? </h2><br>  Als nächstes beschlossen wir, einige Schritte zur Interpretierbarkeit der Modellergebnisse zu unternehmen.  Irgendwann stießen wir auf den Aufmerksamkeitsmechanismus „Aufmerksamkeit“ und begannen, ihn in unser Modell zu implementieren.  Und es gab vielversprechende Ergebnisse.  Jetzt zeigte unser Modell nicht nur Klassenbezeichnungen an, sondern auch Aufmerksamkeitsfaktoren für jedes Zeichen, das wir an das Modell weitergaben. <br><br>  Jetzt konnten wir den genauen Ort, an dem der SQL-Injection-Angriff erkannt wurde, visualisieren und in der Weboberfläche anzeigen.  Dies war ein gutes Ergebnis, aber andere Probleme aus der Liste waren noch ungelöst. <br><br>  Es war offensichtlich, dass wir uns weiterhin darauf konzentrieren sollten, vom Aufmerksamkeitsmechanismus zu profitieren und uns von der Aufgabe der Klassifizierung zu entfernen.  Nachdem wir eine große Anzahl verwandter Studien zu Sequenzmodellen (zu Aufmerksamkeitsmechanismen [2], [3], [4], zur Vektordarstellung, zur Architektur von Auto-Encodern) gelesen und mit unseren Daten experimentiert hatten, konnten wir ein Anomalie-Erkennungsmodell erstellen, das letztendlich würde mehr oder weniger so funktionieren wie ein Experte. <br><br><h2>  Auto Encoder </h2><br>  Irgendwann wurde klar, dass die Architektur von Seq2Seq [5] für unsere Aufgabe am besten geeignet ist. <br><br>  Das Seq2Seq-Modell [7] besteht aus zwei mehrschichtigen LSTMs - einem Encoder und einem Decoder.  Der Codierer ordnet die Eingabesequenz einem Vektor fester Länge zu.  Der Decodierer decodiert den Zielvektor unter Verwendung des Codiererausgangs.  Im Training ist ein Auto-Encoder ein Modell, bei dem die Zielwerte auf die gleichen Werte wie die Eingabewerte eingestellt werden. <br><br>  Die Idee ist, dem Netzwerk beizubringen, die Dinge zu dekodieren, die es gesehen hat, oder mit anderen Worten, die Identität näher zu bringen.  Wenn einem trainierten Autoencoder ein abnormales Muster zugewiesen wird, wird es wahrscheinlich mit einem hohen Fehlergrad neu erstellt, einfach weil es nie gesehen wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="Bild"><br><br><h2>  Lösung </h2><br>  Unsere Lösung besteht aus mehreren Teilen: Modellinitialisierung, Schulung, Prognose und Verifizierung.  Wir hoffen, dass der größte Teil des im Repository befindlichen Codes keiner Erklärung bedarf, sodass wir uns nur auf die wichtigen Teile konzentrieren werden. <br><br>  Das Modell wird als Instanz der Seq2Seq-Klasse erstellt, die die folgenden Konstruktorargumente enthält: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="Bild"><br><br>  Als nächstes werden Auto-Encoder-Ebenen initialisiert.  Erster Encoder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="Bild"><br><br>  Dann der Decoder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="Bild"><br><br>  Da das Problem, das wir lösen, darin besteht, Anomalien zu erkennen, sind die Zielwerte und die Eingabe gleich.  Unser feed_dict sieht also so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="Bild"><br><br>  Nach jeder Ära wird das beste Modell als Referenzpunkt gespeichert, der dann heruntergeladen werden kann.  Zu Testzwecken wurde eine Webanwendung erstellt, die wir mit einem Modell verteidigten, um zu überprüfen, ob echte Angriffe erfolgreich waren. <br><br>  Inspiriert vom Aufmerksamkeitsmechanismus haben wir versucht, ihn auf das Auto-Encoder-Modell anzuwenden, um die abnormalen Teile dieser Abfrage zu markieren. Dabei haben wir jedoch festgestellt, dass die aus der letzten Schicht abgeleiteten Wahrscheinlichkeiten besser funktionieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="Bild"><br><br>  In der Testphase unserer verzögerten Probe haben wir sehr gute Ergebnisse erzielt: Präzision und Rückruf liegen nahe bei 0,99.  Und die ROC-Kurve tendiert zu 1. Es sieht toll aus, nicht wahr? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="Bild"><br><br><h2>  Ergebnisse </h2><br>  Das vorgeschlagene Modell des Seq2Seq-Auto-Encoders konnte Anomalien in HTTP-Anforderungen mit sehr hoher Genauigkeit erkennen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="Bild"><br><br>  Dieses Modell verhält sich wie eine Person: Es untersucht nur die „normalen“ Benutzeranforderungen für eine Webanwendung.  Und wenn es Anomalien in Anforderungen erkennt, wählt es den genauen Ort der Anforderung aus, den es als anomal betrachtet. <br><br>  Wir haben dieses Modell bei einigen Angriffen auf eine Testanwendung getestet und die Ergebnisse waren vielversprechend.  Das obige Bild zeigt beispielsweise, wie unser Modell eine SQL-Injektion erkannt hat, die in einem Webformular in zwei Parameter unterteilt ist.  Solche SQL-Injections werden als fragmentiert bezeichnet: Teile der Angriffsnutzlast werden in mehreren HTTP-Parametern bereitgestellt, was die Erkennung für regelbasierte WAFs erschwert, da sie normalerweise jeden Parameter einzeln testen. <br><br>  Der Modellcode sowie die Trainings- und Testdaten werden als Jupyter-Laptop veröffentlicht, damit jeder unsere Ergebnisse reproduzieren und Verbesserungen vorschlagen kann. <br><br><h2>  Abschließend </h2><br>  Wir glauben, dass unsere Aufgabe eher nicht trivial war.  Wir möchten mit minimalem Aufwand (vor allem, um Fehler aufgrund der Komplexität der Lösung zu vermeiden) einen Weg finden, um Angriffe zu erkennen, die wie durch Zauberei gelernt haben, zu entscheiden, was gut und was schlecht ist.  Zweitens wollte ich Probleme mit dem menschlichen Faktor vermeiden, wenn genau ein Experte entscheidet, was ein Zeichen für einen Angriff ist und was nicht.  Zusammenfassend möchte ich feststellen, dass der Auto-Encoder mit der Seq2Seq-Architektur für das Problem der Suche nach Anomalien unserer Meinung nach und für unser Problem hervorragende Arbeit geleistet hat. <br><br>  Wir wollten das Problem auch mit der Interpretierbarkeit von Daten lösen.  Die Verwendung komplexer neuronaler Netzwerkarchitekturen ist normalerweise sehr schwierig.  In einer Reihe von Transformationen ist es bereits schwierig, am Ende zu sagen, welcher Teil der Daten die Entscheidung am meisten beeinflusst hat.  Nachdem wir den Ansatz zur Dateninterpretation durch das Modell überdacht hatten, stellte sich heraus, dass es für uns ausreichend war, die Wahrscheinlichkeiten für jedes Symbol aus der letzten Schicht zu erhalten. <br><br>  Es ist zu beachten, dass dies keine Produktionsversion ist.  Wir können die Details der Implementierung dieses Ansatzes in einem realen Produkt nicht offenlegen, und wir möchten warnen, dass das einfache Nehmen und Einbetten dieser Lösung in ein Produkt nicht funktioniert. <br><br>  GitHub-Repository: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">goo.gl/aNwq9U</a> <br><br>  <b>Autoren</b> : Alexandra Murzina ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ), Fedor Sacharow ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ), Arseniy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Reutov</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Raz0r</a> ) <br><br><h3>  Referenzen: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu LSTM-Netzwerken</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufmerksamkeit und erweiterte wiederkehrende neuronale Netze</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufmerksamkeit ist alles was Sie brauchen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufmerksamkeit ist alles was Sie brauchen (kommentiert)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial für neuronale maschinelle Übersetzung (seq2seq)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autoencoder</a> </li><li>  <a href="">Sequenz-zu-Sequenz-Lernen mit neuronalen Netzen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen von Autoencodern in Keras</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439202/">https://habr.com/ru/post/de439202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439192/index.html">PC-Lautsprecher bis elf</a></li>
<li><a href="../de439194/index.html">Charakterverwaltung mit SharedEvents</a></li>
<li><a href="../de439196/index.html">JPMorgan-Analysten: Apple sollte Blizzard, Netflix oder Sonos kaufen, um die Anleger zu beruhigen</a></li>
<li><a href="../de439198/index.html">Barrier Island Generation</a></li>
<li><a href="../de439200/index.html">Komponist für die Kleinen</a></li>
<li><a href="../de439204/index.html">Verbesserung der Effizienz der Photosynthese durch genetische Veränderung von Pflanzen</a></li>
<li><a href="../de439206/index.html">Wie haben wir das Problem der Fortsetzung der Wiedergabelisten bei RecSys Challenge gelöst und den 3. Platz belegt?</a></li>
<li><a href="../de439208/index.html">Oh, mein Code: Wie MAPS.ME funktioniert</a></li>
<li><a href="../de439210/index.html">Java nach Vulkanausbruch</a></li>
<li><a href="../de439216/index.html">Pudge 500 Zeilen einbettbare Datenbank auf Golang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>