<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¢ üïì üíÖüèæ Web Attack Detection mit Seq2Seq Auto Encoder üë©üèæ‚Äçüî¨ üê∫ üëì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Erkennen von Angriffen ist seit Jahrzehnten eine wichtige Aufgabe in der Informationssicherheit. Die ersten bekannten Beispiele f√ºr die Implementi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Web Attack Detection mit Seq2Seq Auto Encoder</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/439202/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="Bild"></a> <br><br>  Das Erkennen von Angriffen ist seit Jahrzehnten eine wichtige Aufgabe in der Informationssicherheit.  Die ersten bekannten Beispiele f√ºr die Implementierung von IDS stammen aus den fr√ºhen 1980er Jahren. <br><br>  Nach mehreren Jahrzehnten bildete sich eine ganze Branche von Angriffserkennungswerkzeugen.  Derzeit gibt es verschiedene Arten von Produkten wie IDS, IPS, WAF und Firewalls, von denen die meisten eine regelbasierte Angriffserkennung bieten.  Die Idee, Anomalieerkennungstechniken zu verwenden, um Angriffe basierend auf Produktionsstatistiken zu erkennen, scheint nicht so realistisch wie in der Vergangenheit.  Oder egal? .. <a name="habracut"></a><br><br><h2>  Anomalieerkennung in Webanwendungen </h2><br>  Die ersten Firewalls, die speziell zur Erkennung von Angriffen auf Webanwendungen entwickelt wurden, wurden Anfang der neunziger Jahre auf den Markt gebracht.  Seitdem haben sich sowohl die Angriffsmethoden als auch die Abwehrmechanismen erheblich ge√§ndert, und Angreifer k√∂nnen jederzeit einen Schritt voraus sein. <br><br>  Derzeit versuchen die meisten WAFs, Angriffe wie folgt zu erkennen: Es gibt einige regelbasierte Mechanismen, die in den Reverse-Proxy-Server integriert sind.  Das auff√§lligste Beispiel ist mod_security, das WAF-Modul f√ºr den Apache-Webserver, das 2002 entwickelt wurde.  Das Identifizieren von Angriffen anhand von Regeln hat mehrere Nachteile.  Beispielsweise k√∂nnen die Regeln keine Zero-Day-Angriffe erkennen, w√§hrend dieselben Angriffe von einem Experten leicht erkannt werden k√∂nnen. Dies ist nicht √ºberraschend, da das menschliche Gehirn nicht wie eine Reihe regul√§rer Ausdr√ºcke funktioniert. <br><br>  Aus Sicht von WAF k√∂nnen Angriffe in solche unterteilt werden, die wir anhand der Reihenfolge der Anforderungen erkennen k√∂nnen, und solche, bei denen eine HTTP-Anforderung (Antwort) ausreicht, um sie zu l√∂sen.  Unsere Forschung konzentriert sich auf die Erkennung der letzteren Arten von Angriffen - SQL-Injection, Cross Site Scripting, Injection von externen XML-Entit√§ten, Pfad√ºberquerung, Betriebssystembefehle, Objektinjektion usw. <br><br>  Aber zuerst testen wir uns. <br><br><h2>  Was wird der Experte denken, wenn er die folgenden Fragen sieht? </h2><br>  Sehen Sie sich eine Beispiel-HTTP-Anfrage an Anwendungen an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/aa6/d1d/112aa6d1d1cc3798f89a7b39fd0aad4c.png" alt="Bild"><br><br>  Wenn Sie die Aufgabe erhalten haben, b√∂swillige Anforderungen an eine Anwendung zu erkennen, m√∂chten Sie h√∂chstwahrscheinlich das √ºbliche Benutzerverhalten f√ºr einige Zeit beobachten.  Wenn Sie die Abfragen auf mehrere Endpunkte der Anwendung untersuchen, erhalten Sie einen allgemeinen √úberblick √ºber die Struktur und Funktionen ungef√§hrlicher Abfragen. <br><br>  Jetzt erhalten Sie die folgende Abfrage zur Analyse: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28b/be1/487/28bbe1487cb08fc21fee85bdc1f259b5.png" alt="Bild"><br><br>  Es ist sofort ersichtlich, dass hier etwas nicht stimmt.  Es wird einige Zeit dauern, um zu verstehen, wie es hier wirklich ist, und sobald Sie den Teil der Anfrage identifiziert haben, der abnormal erscheint, k√∂nnen Sie dar√ºber nachdenken, um welche Art von Angriff es sich handelt.  Im Wesentlichen ist es unser Ziel, dass unsere ‚Äûk√ºnstliche Intelligenz zur Erkennung von Angriffen‚Äú auf die gleiche Weise funktioniert - √§hnlich wie menschliches Denken. <br><br>  Die offensichtliche Sache ist, dass ein Teil des Datenverkehrs, der auf den ersten Blick b√∂swillig erscheint, f√ºr eine bestimmte Website normal sein kann. <br><br>  Betrachten wir zum Beispiel die folgenden Abfragen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/11e/a25/7c311ea25d363c43c6559429f1bf8991.png" alt="Bild"><br><br>  Ist diese Abfrage abnormal? <br><br>  Tats√§chlich handelt es sich bei dieser Anforderung um eine Ver√∂ffentlichung eines Fehlers im Jira-Tracker, der f√ºr diesen Dienst typisch ist. Dies bedeutet, dass die Anforderung erwartet und normal ist. <br><br>  Betrachten Sie nun das folgende Beispiel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/57c/884/b0357c884e2b3c3dd19a8733da973a62.png" alt="Bild"><br><br>  Auf den ersten Blick sieht die Anfrage wie eine normale Benutzerregistrierung auf einer auf Joomla CMS basierenden Website aus.  Die angeforderte Operation ist jedoch user.register anstelle der √ºblichen register.register.  Die erste Option ist veraltet und enth√§lt eine Sicherheitsanf√§lligkeit, mit der sich jeder als Administrator registrieren kann.  Ein Exploit f√ºr diese Sicherheitsanf√§lligkeit wird als Joomla &lt;3.6.4 Kontoerstellung / Eskalation von Berechtigungen (CVE-2016-8869, CVE-2016-8870) bezeichnet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a08/994/45ba089942a993c3e4d32fd5f8f744a6.png" alt="Bild"><br><br><h2>  Wo haben wir angefangen? </h2><br>  Nat√ºrlich haben wir zuerst die vorhandenen L√∂sungen f√ºr das Problem untersucht.  Seit Jahrzehnten werden verschiedene Versuche unternommen, Angriffserkennungsalgorithmen auf der Grundlage von Statistiken oder maschinellem Lernen zu erstellen.  Einer der beliebtesten Ans√§tze ist die L√∂sung des Klassifizierungsproblems, wenn es sich bei Klassen um ‚Äûerwartete Abfragen‚Äú, ‚ÄûSQL-Injektionen‚Äú, XSS, CSRF usw. handelt. Auf diese Weise k√∂nnen Sie mit dem Klassifizierer eine gute Genauigkeit f√ºr den Datensatz erzielen Dieser Ansatz l√∂st jedoch aus unserer Sicht keine sehr wichtigen Probleme: <br><br><ol><li>  <b>Die Klassenauswahl ist begrenzt und vorbestimmt</b> .  Was ist, wenn Ihr Modell im Lernprozess durch drei Klassen dargestellt wird, z. B. "normale Abfragen", SQLi und XSS, und w√§hrend des Systembetriebs auf eine CSRF oder einen Zero-Day-Angriff st√∂√üt? </li><li>  <b>Die Bedeutung dieser Klassen</b> .  Angenommen, Sie m√ºssen zehn Clients sch√ºtzen, auf denen jeweils v√∂llig unterschiedliche Webanwendungen ausgef√ºhrt werden.  F√ºr die meisten von ihnen haben Sie keine Ahnung, wie die SQL-Injection f√ºr ihre Anwendung tats√§chlich aussieht.  Dies bedeutet, dass Sie Trainingsdatens√§tze irgendwie k√ºnstlich erstellen m√ºssen.  Dieser Ansatz ist nicht optimal, da Sie letztendlich aus Daten lernen, die sich in der Verteilung von realen Daten unterscheiden. </li><li>  <b>Interpretierbarkeit der Modellergebnisse</b> .  Nun, das Modell hat das SQL Injection-Ergebnis erzeugt, und was nun?  Sie und, was noch wichtiger ist, Ihr Kunde, der als erster eine Warnung sieht und normalerweise kein Experte f√ºr Webangriffe ist, m√ºssen raten, welchen Teil der Anfrage Ihr Modell als b√∂sartig ansieht. </li></ol><br>  Angesichts all dieser Probleme haben wir uns entschlossen, das Klassifikatormodell trotzdem zu trainieren. <br><br>  Da das HTTP-Protokoll ein Textprotokoll ist, war es offensichtlich, dass wir uns moderne Textklassifizierer ansehen mussten.  Ein bekanntes Beispiel ist die Stimmungsanalyse in einem IMDB-Filmkritik-Datensatz.  Einige L√∂sungen verwenden RNN, um Bewertungen zu klassifizieren.  Wir haben uns entschlossen, ein √§hnliches Modell mit RNN-Architektur mit einigen geringf√ºgigen Unterschieden auszuprobieren.  Beispielsweise verwendet die RNN-Architektur in nat√ºrlicher Sprache eine Vektordarstellung von W√∂rtern, es ist jedoch nicht klar, welche W√∂rter in einer unnat√ºrlichen Sprache wie HTTP gefunden werden.  Aus diesem Grund haben wir uns f√ºr die Vektordarstellung von Symbolen f√ºr unsere Aufgabe entschieden. <br><br>  Vorgefertigte Darstellungen l√∂sen unser Problem nicht. Daher haben wir einfache Zuordnungen von Zeichen zu numerischen Codes mit mehreren internen Markierungen wie <code>GO</code> und <code>EOS</code> . <br><br>  Nachdem die Entwicklung und das Testen des Modells abgeschlossen waren, wurden alle zuvor vorhergesagten Probleme offensichtlich, aber zumindest unser Team wechselte von nutzlosen Annahmen zu einem Ergebnis. <br><br><h2>  Was weiter? </h2><br>  Als n√§chstes beschlossen wir, einige Schritte zur Interpretierbarkeit der Modellergebnisse zu unternehmen.  Irgendwann stie√üen wir auf den Aufmerksamkeitsmechanismus ‚ÄûAufmerksamkeit‚Äú und begannen, ihn in unser Modell zu implementieren.  Und es gab vielversprechende Ergebnisse.  Jetzt zeigte unser Modell nicht nur Klassenbezeichnungen an, sondern auch Aufmerksamkeitsfaktoren f√ºr jedes Zeichen, das wir an das Modell weitergaben. <br><br>  Jetzt konnten wir den genauen Ort, an dem der SQL-Injection-Angriff erkannt wurde, visualisieren und in der Weboberfl√§che anzeigen.  Dies war ein gutes Ergebnis, aber andere Probleme aus der Liste waren noch ungel√∂st. <br><br>  Es war offensichtlich, dass wir uns weiterhin darauf konzentrieren sollten, vom Aufmerksamkeitsmechanismus zu profitieren und uns von der Aufgabe der Klassifizierung zu entfernen.  Nachdem wir eine gro√üe Anzahl verwandter Studien zu Sequenzmodellen (zu Aufmerksamkeitsmechanismen [2], [3], [4], zur Vektordarstellung, zur Architektur von Auto-Encodern) gelesen und mit unseren Daten experimentiert hatten, konnten wir ein Anomalie-Erkennungsmodell erstellen, das letztendlich w√ºrde mehr oder weniger so funktionieren wie ein Experte. <br><br><h2>  Auto Encoder </h2><br>  Irgendwann wurde klar, dass die Architektur von Seq2Seq [5] f√ºr unsere Aufgabe am besten geeignet ist. <br><br>  Das Seq2Seq-Modell [7] besteht aus zwei mehrschichtigen LSTMs - einem Encoder und einem Decoder.  Der Codierer ordnet die Eingabesequenz einem Vektor fester L√§nge zu.  Der Decodierer decodiert den Zielvektor unter Verwendung des Codiererausgangs.  Im Training ist ein Auto-Encoder ein Modell, bei dem die Zielwerte auf die gleichen Werte wie die Eingabewerte eingestellt werden. <br><br>  Die Idee ist, dem Netzwerk beizubringen, die Dinge zu dekodieren, die es gesehen hat, oder mit anderen Worten, die Identit√§t n√§her zu bringen.  Wenn einem trainierten Autoencoder ein abnormales Muster zugewiesen wird, wird es wahrscheinlich mit einem hohen Fehlergrad neu erstellt, einfach weil es nie gesehen wurde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2b/d99/fb1/b2bd99fb15aff53c214892c8d8a36642.png" alt="Bild"><br><br><h2>  L√∂sung </h2><br>  Unsere L√∂sung besteht aus mehreren Teilen: Modellinitialisierung, Schulung, Prognose und Verifizierung.  Wir hoffen, dass der gr√∂√üte Teil des im Repository befindlichen Codes keiner Erkl√§rung bedarf, sodass wir uns nur auf die wichtigen Teile konzentrieren werden. <br><br>  Das Modell wird als Instanz der Seq2Seq-Klasse erstellt, die die folgenden Konstruktorargumente enth√§lt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b5/183/1f3/0b51831f349befe5753636bda5da404c.png" alt="Bild"><br><br>  Als n√§chstes werden Auto-Encoder-Ebenen initialisiert.  Erster Encoder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ba/0e0/f7e/5ba0e0f7e354312048f8c3945436af16.png" alt="Bild"><br><br>  Dann der Decoder: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd4/c9c/d5e/fd4c9cd5ef2e4fca445e18dc9d25ff29.png" alt="Bild"><br><br>  Da das Problem, das wir l√∂sen, darin besteht, Anomalien zu erkennen, sind die Zielwerte und die Eingabe gleich.  Unser feed_dict sieht also so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e6/7e3/04a/6e67e304a01caa06d4f366327a1d5ef3.png" alt="Bild"><br><br>  Nach jeder √Ñra wird das beste Modell als Referenzpunkt gespeichert, der dann heruntergeladen werden kann.  Zu Testzwecken wurde eine Webanwendung erstellt, die wir mit einem Modell verteidigten, um zu √ºberpr√ºfen, ob echte Angriffe erfolgreich waren. <br><br>  Inspiriert vom Aufmerksamkeitsmechanismus haben wir versucht, ihn auf das Auto-Encoder-Modell anzuwenden, um die abnormalen Teile dieser Abfrage zu markieren. Dabei haben wir jedoch festgestellt, dass die aus der letzten Schicht abgeleiteten Wahrscheinlichkeiten besser funktionieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56d/748/22e/56d74822e5ee1a376db9d8c79b71769b.png" alt="Bild"><br><br>  In der Testphase unserer verz√∂gerten Probe haben wir sehr gute Ergebnisse erzielt: Pr√§zision und R√ºckruf liegen nahe bei 0,99.  Und die ROC-Kurve tendiert zu 1. Es sieht toll aus, nicht wahr? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be8/eb4/21f/be8eb421f44d245b553dd71846157aff.png" alt="Bild"><br><br><h2>  Ergebnisse </h2><br>  Das vorgeschlagene Modell des Seq2Seq-Auto-Encoders konnte Anomalien in HTTP-Anforderungen mit sehr hoher Genauigkeit erkennen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/baf/742/5adbaf742fa07b485b70886943da8036.png" alt="Bild"><br><br>  Dieses Modell verh√§lt sich wie eine Person: Es untersucht nur die ‚Äûnormalen‚Äú Benutzeranforderungen f√ºr eine Webanwendung.  Und wenn es Anomalien in Anforderungen erkennt, w√§hlt es den genauen Ort der Anforderung aus, den es als anomal betrachtet. <br><br>  Wir haben dieses Modell bei einigen Angriffen auf eine Testanwendung getestet und die Ergebnisse waren vielversprechend.  Das obige Bild zeigt beispielsweise, wie unser Modell eine SQL-Injektion erkannt hat, die in einem Webformular in zwei Parameter unterteilt ist.  Solche SQL-Injections werden als fragmentiert bezeichnet: Teile der Angriffsnutzlast werden in mehreren HTTP-Parametern bereitgestellt, was die Erkennung f√ºr regelbasierte WAFs erschwert, da sie normalerweise jeden Parameter einzeln testen. <br><br>  Der Modellcode sowie die Trainings- und Testdaten werden als Jupyter-Laptop ver√∂ffentlicht, damit jeder unsere Ergebnisse reproduzieren und Verbesserungen vorschlagen kann. <br><br><h2>  Abschlie√üend </h2><br>  Wir glauben, dass unsere Aufgabe eher nicht trivial war.  Wir m√∂chten mit minimalem Aufwand (vor allem, um Fehler aufgrund der Komplexit√§t der L√∂sung zu vermeiden) einen Weg finden, um Angriffe zu erkennen, die wie durch Zauberei gelernt haben, zu entscheiden, was gut und was schlecht ist.  Zweitens wollte ich Probleme mit dem menschlichen Faktor vermeiden, wenn genau ein Experte entscheidet, was ein Zeichen f√ºr einen Angriff ist und was nicht.  Zusammenfassend m√∂chte ich feststellen, dass der Auto-Encoder mit der Seq2Seq-Architektur f√ºr das Problem der Suche nach Anomalien unserer Meinung nach und f√ºr unser Problem hervorragende Arbeit geleistet hat. <br><br>  Wir wollten das Problem auch mit der Interpretierbarkeit von Daten l√∂sen.  Die Verwendung komplexer neuronaler Netzwerkarchitekturen ist normalerweise sehr schwierig.  In einer Reihe von Transformationen ist es bereits schwierig, am Ende zu sagen, welcher Teil der Daten die Entscheidung am meisten beeinflusst hat.  Nachdem wir den Ansatz zur Dateninterpretation durch das Modell √ºberdacht hatten, stellte sich heraus, dass es f√ºr uns ausreichend war, die Wahrscheinlichkeiten f√ºr jedes Symbol aus der letzten Schicht zu erhalten. <br><br>  Es ist zu beachten, dass dies keine Produktionsversion ist.  Wir k√∂nnen die Details der Implementierung dieses Ansatzes in einem realen Produkt nicht offenlegen, und wir m√∂chten warnen, dass das einfache Nehmen und Einbetten dieser L√∂sung in ein Produkt nicht funktioniert. <br><br>  GitHub-Repository: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">goo.gl/aNwq9U</a> <br><br>  <b>Autoren</b> : Alexandra Murzina ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">murzina_a</a> ), Irina Stepanyuk ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ), Fedor Sacharow ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> ), Arseniy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Reutov</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Raz0r</a> ) <br><br><h3>  Referenzen: </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu LSTM-Netzwerken</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufmerksamkeit und erweiterte wiederkehrende neuronale Netze</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufmerksamkeit ist alles was Sie brauchen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufmerksamkeit ist alles was Sie brauchen (kommentiert)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tutorial f√ºr neuronale maschinelle √úbersetzung (seq2seq)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autoencoder</a> </li><li>  <a href="">Sequenz-zu-Sequenz-Lernen mit neuronalen Netzen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen von Autoencodern in Keras</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439202/">https://habr.com/ru/post/de439202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439192/index.html">PC-Lautsprecher bis elf</a></li>
<li><a href="../de439194/index.html">Charakterverwaltung mit SharedEvents</a></li>
<li><a href="../de439196/index.html">JPMorgan-Analysten: Apple sollte Blizzard, Netflix oder Sonos kaufen, um die Anleger zu beruhigen</a></li>
<li><a href="../de439198/index.html">Barrier Island Generation</a></li>
<li><a href="../de439200/index.html">Komponist f√ºr die Kleinen</a></li>
<li><a href="../de439204/index.html">Verbesserung der Effizienz der Photosynthese durch genetische Ver√§nderung von Pflanzen</a></li>
<li><a href="../de439206/index.html">Wie haben wir das Problem der Fortsetzung der Wiedergabelisten bei RecSys Challenge gel√∂st und den 3. Platz belegt?</a></li>
<li><a href="../de439208/index.html">Oh, mein Code: Wie MAPS.ME funktioniert</a></li>
<li><a href="../de439210/index.html">Java nach Vulkanausbruch</a></li>
<li><a href="../de439216/index.html">Pudge 500 Zeilen einbettbare Datenbank auf Golang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>