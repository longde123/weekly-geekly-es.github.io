<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏈 🍩 🤾 Bus numérique «Musique» avec interface UART 🧔🏼 👆🏽 🧖🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut les Geektimes! Vous êtes-vous déjà demandé comment un «signal électrique» retentit le long des pistes des circuits imprimés entre les microcircu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bus numérique «Musique» avec interface UART</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408485/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/tj/x4/hwtjx4znykkrp5_poz3bx1xfpae.jpeg" alt="image"></div><br>  Salut les Geektimes!  Vous êtes-vous déjà demandé comment un «signal électrique» retentit le long des pistes des circuits imprimés entre les microcircuits, les transistors, les diodes, les résistances et les condensateurs?  Une des variantes d'un tel signal dans l'électronique moderne est un bus numérique, et l'une des interfaces populaires pour l'échange de données via le bus est UART.  Il est souvent utilisé dans les microcontrôleurs pour communiquer avec un ordinateur ou une sorte de périphérie.  Pour obtenir du son sur le bus, il n'est pas du tout nécessaire de connecter un haut-parleur avec un amplificateur à un vrai bus avec <i>UART</i> ohm, car il peut être simulé dans le programme.  Êtes-vous intéressé par les sons que vous avez obtenus ou avez-vous besoin d'un programme pour vous expérimenter?  Ensuite, je demande un chat. <br><a name="habracut"></a><br><h3>  <b>Nous écoutons des fichiers sur le bus avec UART</b> </h3><br>  Quel son résultera si vous transférez des fichiers via <i>UART</i> ?  Voici quelques exemples obtenus avec les paramètres <i>UART</i> suivants: <br><br><ul><li>  115200 bauds </li><li>  Bit 8 bits </li><li>  Bit de parité: aucun </li><li>  Longueur du bit d'arrêt: 1 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Son du jeu Stalker Shadow of Chernobyl</a> (fichier XR_3DA.exe, tout en fin de piste, à partir de 2:36, il y a une mélodie). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le son du texte et du code de l'article sur le synthétiseur vocal</a> (l'article lui-même est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ). <br><br>  À quoi ressemble la photo de Lena? <br><br><img src="https://habrastorage.org/storage2/d1e/664/833/d1e6648335210462583267c43d4d3941.png" alt="image"><br><br>  Le résultat était juste du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bruit</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le son du livre "Entropie et prévision des séries temporelles dans la théorie des systèmes dynamiques" au format pdf.</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le son du firmware du microcontrôleur de la série Atmega pour un lecteur wav.</a> <br><br><h3>  <b>À quoi peut-il servir?</b> </h3><br>  Théoriquement, il peut y avoir de telles informations sous forme de texte, ou d'image, ou de vidéo, ou sous la forme d'un programme qui aura non seulement une signification fonctionnelle ou une signification esthétique, mais aussi le «beau» son d'un bus numérique, puis il se révèle être une sorte de poésie «numérique» .  <s>Vous pouvez également diversifier les échantillons pour le dubstep.</s> En général, à mon avis, écouter les sons d'un bus numérique est à peu près aussi intéressant que d'écouter le bruit des ondes radio en ondes courtes, en général, pour un amateur. <br><br><h3>  <b>Comment ça marche ou un peu sur UART</b> </h3><br>  Ce qui est <i>UART</i> peut être lu sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia</a> .  <i>UART est</i> très facile à simuler dans un programme.  En fait, il vous suffit de pouvoir créer une chute de signal de 0 à 1 et inversement (dans le cas d'un fichier <i>WAV</i> d'une capacité en bits de 16 bits, ce sont des valeurs de - <i>A</i> à + <i>A</i> , où <i>A</i> est l'amplitude du signal) et de l'enregistrer dans un fichier audio.  L'interface <i>UART</i> fonctionne comme ceci: après le bit de départ, qui est «zéro» logique, vous devez définir le niveau en fonction des données fournies, du bas au haut.  Vient ensuite un bit de parité que vous ne pouvez pas utiliser.  À la fin du message se trouve un bit d'arrêt («unité» logique), dont la longueur peut être différente.  Un exemple de code peut être trouvé dans le code source, qui se trouve à la fin de l'article.  Plus d'informations sur UART peuvent être trouvées sur le réseau, beaucoup de matériel.  L'UART peut être utilisé à d'autres fins, par exemple comme PWM, mais dans notre cas, cela signifie que théoriquement, vous pouvez même transférer un signal sonore à part entière directement vers le haut-parleur, comme cela se fait dans les lecteurs wav sur le microcontrôleur.  Cependant, je préférerais plutôt l'utiliser comme générateur de méandre.  La fréquence de tonalité et la phase du signal peuvent être fournies sous forme de bits de données, par exemple, <i>00001111</i> créera un méandre dont la période sera égale à 10 temps de transmission d'un bit (car dans ce cas il y a aussi un bit de départ égal à 0 et un bit d'arrêt égal à 1).  En raison des bits de démarrage et d'arrêt, toutes les périodes de méandre ne peuvent pas être transmises, par exemple, dans ce cas <i>01100110</i> , car nous écouterons essentiellement une telle séquence sur le bus <i>0011001101</i> .  Si vous utilisez un taux de transfert de données élevé, par exemple 115200 bauds, il est judicieux de créer des fréquences sonores audibles en étirant les périodes des meadras de plusieurs octets. <br><br><h3>  <b>...</b> </h3><br>  En utilisant ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien,</a> vous pouvez télécharger le programme pour convertir le fichier au son du bus <i>UART</i> .  Il existe également une version utilisant OpenAL pour jouer du son pendant le fonctionnement du programme, voici le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> . <br><br>  Le code source du programme est fourni ci-dessous: <br><br><div class="spoiler">  <b class="spoiler_title">Fichier d'en-tête SoundsDigitalBus.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SOUNDS_DIGITAL_BUS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOUNDS_DIGITAL_BUS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_WAV_FILE_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sdb_output.wav"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BIT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_PARITY 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_STOP_BIT 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BAUDRATE 9600 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BAUDRATE_MAX 921600 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///   ()   #define SDB_MAX_DATA 30000 ///    #define SDB_CANNEL 1 /// -  ()  #define SDB_BIT 16 ///    #define SDB_FREQUENCY 96000 ///     OpenAL #define OPENAL_NUM_OF_DYNBUF 32 ///  OpenAL #define SDB_OPENAL_BIT SDB_BIT #define SDB_OPENAL_CANNEL SDB_CANNEL #define SDB_OPENAL_FREQUENCY SDB_FREQUENCY #define SDB_OPENAL_FORMAT AL_FORMAT_MONO16 ///     #define SDB_BUFFER_MAX 4800 ///  OpenAL    ( ,   1) #define SDB_WITH_OPENAL 1 ///   ( ,   1) #define SDB_WITH_DEBUG_MODE 0 #if SDB_WITH_OPENAL == 1 //   OpenAL    #include &lt;openal/al.h&gt; #include &lt;openal/alc.h&gt; #endif #if SDB_WITH_DEBUG_MODE == 1 //    #include &lt;stdio.h&gt; #include &lt;locale.h&gt; #endif //    #include &lt;stdio.h&gt; //    #include &lt;string.h&gt; class sdb { private: #if SDB_WITH_OPENAL == 1 //   openAl    //   speesy ALCdevice* openAlDevice; ALCcontext* openAlContext; ALuint openAlSource; signed char openAlnBuf; //  #endif // ---------------------------------------- //    WAV  FILE *fpSave; unsigned short wavBlockAlign; unsigned long wavSubchunk2Size; unsigned long wavChunkSize; unsigned char wavLenDataType; // ---------------------------------------- //      double dTime; //    ,  . double allTime; //    short busState; //   ( ) short busDataOne[SDB_BUFFER_MAX]; // ,   wav short busDataTwo[SDB_BUFFER_MAX]; unsigned char switchBuffer; //    unsigned int posBufferOne, posBufferTwo; //    unsigned int posAllBuffer; //   char wavFileName[512]; //  wav  char isCreateWavFileFlag; // ,  wav    char isBufferOneFlag; // ,     char isBufferTwoFlag; unsigned int uartBaudrate; //  UART   unsigned int uartT; unsigned char uartBit; //   unsigned char uartStopBit; //    unsigned char uartParityBit; unsigned char isAudioOutput; unsigned char isWavFileOutput; #if SDB_WITH_OPENAL == 1 ALboolean CheckALCError(void); ALboolean CheckALError(void); char initOpenAL(void); void destroyOpenAL(void); void playOpenAlSound(void); void stopOpenAlSound(void); void closeOpenAlSound(void); int getBufferStatusOpenAl(void); void setBufferOpenAl(signed short *buf,unsigned long siz); char updateOpenAl(void); #endif char createWavFile(char * filename,unsigned long sampleRate,unsigned short bitsPerSample, unsigned short numChannels); void writeSampleWavFile(void *data); void writeDataBlockWavFile(void *data,unsigned long len); void closeWavFile(void); void busDelay(unsigned short us); public: sdb(void); ~sdb(void); /** @brief       1-wire @param[in] data     1-wire */ void oneWireSendByte(unsigned char data); /** @brief     1-wire */ void oneWireReset(void); /** @brief    1- wire */ void oneWireStop(void); /** @brief      UART @param[in] data    UART */ void uartSendByte(unsigned char data); /** @brief     UART @param[in] data    UART */ void uartSend(unsigned long data); /** @brief   UART @param[in] baudrate   UART */ void uartSetBaudrate(unsigned long baudrate); /** @brief     @param[in] bit  ,   UART    */ void uartSetBit(unsigned char bit); /** @brief          .     1. @param[in] bit    */ void uartSetStopBit(unsigned char bit); /** @brief          UART  .   1,     ,   0,     UART     . @param[in] state ,   . */ void uartSetParityBit(unsigned char state); /** @brief    UART     UART,     .         . */ void uartStop(void); /** @brief    wav  @param[in] filename  wav  */ void setWavFileName(char* filename); /** @brief     OpenAL */ void playAudioOn(void); /** @brief     OpenAL */ void playAudioOff(void); /** @brief     wav  */ void recordOn(void); /** @brief     wav  */ void recordOff(void); }; #endif // MUSICDIGITALBUS_H_INCLUDED</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Code source du fichier SoundsDigitalBus.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SoundsDigitalBus.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SDB_WITH_OPENAL == 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   ALboolean sdb::CheckALCError(void) { ALenum ErrCode; ErrCode = alcGetError(openAlDevice); if (ErrCode != ALC_NO_ERROR) { return AL_FALSE; } return AL_TRUE; } ALboolean sdb::CheckALError(void) { ALenum ErrCode; if ((ErrCode = alGetError()) != AL_NO_ERROR) { return AL_FALSE; } return AL_TRUE; } //  OpenAL char sdb::initOpenAL(void) { ALfloat SourcePos[] = {0.0, 0.0, 0.0}; ALfloat SourceVel[] = {0.0, 0.0, 0.0}; //  . ALfloat ListenerPos[] = { 0.0, 0.0, 0.0 }; //  . ALfloat ListenerVel[] = { 0.0, 0.0, 0.0 }; //  . ( 3  –  «»,  3 – «») ALfloat ListenerOri[] = { 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 }; #if SDB_WITH_DEBUG_MODE == 1 printf("alcOpenDevice\n"); #endif openAlDevice = alcOpenDevice(0); // open default device if (openAlDevice != 0) { openAlContext = alcCreateContext(openAlDevice,0); // create context if (openAlContext != 0) { #if SDB_WITH_DEBUG_MODE == 1 printf("alcMakeContextCurrent\n"); #endif alcMakeContextCurrent(openAlContext); // set active context } else { #if SDB_WITH_DEBUG_MODE == 1 printf("Error context\n"); #endif return 0; } } else { #if SDB_WITH_DEBUG_MODE == 1 printf("Error Open Device\n"); #endif return 0; } //  alListenerfv(AL_POSITION, ListenerPos); //  alListenerfv(AL_VELOCITY, ListenerVel); //  alListenerfv(AL_ORIENTATION, ListenerOri); alGenSources(1, &amp;openAlSource); if (!CheckALError()) return false; alSourcef (openAlSource, AL_PITCH, 1.0f); alSourcef (openAlSource, AL_GAIN, 1.0f); alSourcefv(openAlSource, AL_POSITION, SourcePos); alSourcefv(openAlSource, AL_VELOCITY, SourceVel); alSourcei (openAlSource, AL_LOOPING, AL_FALSE); alSourcei(openAlSource, AL_LOOPING, AL_FALSE); openAlnBuf = 0; return 1; } void sdb::destroyOpenAL(void) { alSourceStop(openAlSource); //    alcMakeContextCurrent(0); //   alcDestroyContext(openAlContext); //    alcCloseDevice(openAlDevice); } void sdb::playOpenAlSound(void) { alSourcePlay(openAlSource); } void sdb::stopOpenAlSound(void) { alSourceStop(openAlSource); } void sdb::closeOpenAlSound(void) { alSourceStop(openAlSource); if (alIsSource(openAlSource)) alDeleteSources(1, &amp;openAlSource); } int sdb::getBufferStatusOpenAl(void) { int processed = 0; if (openAlnBuf == 0) return 1; alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); CheckALError(); #if SDB_WITH_DEBUG_MODE == 1 printf("getBufferStatus: %d\n",processed); #endif if (processed != 0) { return processed; } return 0; } void sdb::setBufferOpenAl(signed short* buf, unsigned long siz) { int processed = 0; ALuint BufID = 0; #if _OPENAL_FORMAT == AL_FORMAT_MONO16 siz = siz*2; #endif // _OPENAL_FORMAT #if _OPENAL_FORMAT == AL_FORMAT_STEREO16 siz = siz*4; #endif // _OPENAL_FORMAT #if _OPENAL_FORMAT == AL_FORMAT_STEREO8 siz = siz*2; #endif // _OPENAL_FORMAT //     alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); CheckALError(); //   ,          if ((processed == 0) &amp;&amp; (openAlnBuf &lt; OPENAL_NUM_OF_DYNBUF)) { openAlnBuf++; //   alGenBuffers(1, &amp;BufID); //   alBufferData(BufID,SDB_OPENAL_FORMAT,buf,siz,SDB_OPENAL_FREQUENCY); //     alSourceQueueBuffers(openAlSource, 1, &amp;BufID); //    if (openAlnBuf == 1) alSourcePlay(openAlSource); } else { #if SDB_WITH_DEBUG_MODE == 1 printf("processed: %d openAlnBuf: %d\n",processed,openAlnBuf); #endif // ,        while (getBufferStatusOpenAl() == 0); //     alSourceUnqueueBuffers(openAlSource, 1, &amp;BufID); CheckALError(); //    alBufferData(BufID,SDB_OPENAL_FORMAT,buf,siz,SDB_OPENAL_FREQUENCY); CheckALError(); alSourceQueueBuffers(openAlSource, 1, &amp;BufID); CheckALError(); } } //        ,    //  1       char sdb::updateOpenAl(void) { int processed = 0; ALuint BufID; //     alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); #if SDB_WITH_DEBUG_MODE == 1 printf("updateOpenAl: %d\n",processed); #endif //     if (openAlnBuf == processed) { //     while (processed--) { //     alSourceUnqueueBuffers(openAlSource, 1, &amp;BufID); if (!CheckALError()) return 0; alDeleteBuffers(1, &amp;BufID); openAlnBuf--; } alSourceStop(openAlSource); #if SDB_WITH_DEBUG_MODE == 1 printf("alSourceStop: %d\n",openAlnBuf); #endif return 0; } return 1; } #endif //    .    void sdb::busDelay(unsigned short us) { double Time = (double)us/1000000.0; double locTime = allTime; char isFlag = 0; //  wav ,       if (isCreateWavFileFlag == 0) { if (isWavFileOutput == 1) { isFlag = createWavFile(wavFileName,SDB_FREQUENCY,SDB_BIT,SDB_CANNEL); //     ,    if (isFlag == 1) isCreateWavFileFlag = 1; } if (isAudioOutput == 1) { initOpenAL(); if (isWavFileOutput == 0) isCreateWavFileFlag = 1; } } allTime = allTime + Time; //     if (isCreateWavFileFlag == 1) //     while(locTime &lt; allTime) { if (switchBuffer == 0) { if (posBufferOne &gt;= SDB_BUFFER_MAX) { posBufferOne = 0; posBufferTwo = 0; busDataTwo[posBufferTwo++] = busState; isBufferOneFlag = 1; switchBuffer = 1; if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,SDB_BUFFER_MAX); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,SDB_BUFFER_MAX); #endif } else { busDataOne[posBufferOne++] = busState; } } else if (switchBuffer == 1) { if (posBufferTwo &gt;= SDB_BUFFER_MAX) { posBufferOne = 0; posBufferTwo = 0; busDataOne[posBufferOne++] = busState; isBufferTwoFlag = 1; switchBuffer = 0; if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,SDB_BUFFER_MAX); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,SDB_BUFFER_MAX); #endif } else { busDataTwo[posBufferTwo++] = busState; } } posAllBuffer++; locTime = locTime + dTime; } } char sdb::createWavFile(char * filename,unsigned long sampleRate,unsigned short bitsPerSample, unsigned short numChannels) { char type[4]; const unsigned long subchunk1Size = 16; unsigned long byteRate; const unsigned short audioFormat = 1; unsigned short len_str = 0; char str_filename[512] = {0}; unsigned short i; //        wavLenDataType = bitsPerSample/8; wavSubchunk2Size = 0; wavChunkSize = wavSubchunk2Size + 44 - 8; //      wavBlockAlign = bitsPerSample / (8 * numChannels); // ,    . byteRate = sampleRate * wavBlockAlign; strcpy(str_filename,filename); len_str = strlen(str_filename); if (len_str &lt; 4) return 0; //       .wav i = 0; while(i &lt; len_str) { if (filename[i] == '.' &amp;&amp; (i + 3) &lt; len_str) { if (((filename[i + 1] == 'w') &amp;&amp; (filename[i + 2] == 'a') &amp;&amp; (filename[i + 3] == 'v')) || ((filename[i + 1] == 'W') &amp;&amp; (filename[i + 2] == 'A') &amp;&amp; (filename[i + 3] == 'V'))) { //     wav break; } else { if ((i + 3) &gt;= 512) return 0; filename[i + 1] = 'w'; filename[i + 2] = 'a'; filename[i + 3] = 'v'; len_str = i + 4; break; } } else if ((i + 1) == len_str) { if ((i + 3) &gt;= 512) return 0; filename[i + 1] = '.'; filename[i + 2] = 'w'; filename[i + 3] = 'a'; filename[i + 4] = 'v'; len_str = i + 5; break; } i++; } type[0] = filename[len_str - 4]; type[1] = filename[len_str - 3]; type[2] = filename[len_str - 2]; type[3] = filename[len_str - 1]; if (type[0]!='.'||type[1]!='w'||type[2]!='a'||type[3]!='v') { if (type[0]!='.'||type[1]!='W'||type[2]!='A'||type[3]!='V') { return 0; } } fpSave=fopen(str_filename,"wb"); type[0]='R'; type[1]='I'; type[2]='F'; type[3]='F'; fwrite(&amp;type,sizeof(char),4,fpSave); fwrite(&amp;wavChunkSize,sizeof(unsigned long),1,fpSave); type[0]='W'; type[1]='A'; type[2]='V'; type[3]='E'; fwrite(&amp;type,sizeof(char),4,fpSave); type[0]='f'; type[1]='m'; type[2]='t'; type[3]=' '; fwrite(&amp;type,sizeof(char),4,fpSave); fwrite(&amp;subchunk1Size,sizeof(unsigned long),1,fpSave); fwrite(&amp;audioFormat,sizeof(unsigned short),1,fpSave); fwrite(&amp;numChannels,sizeof(unsigned short),1,fpSave); fwrite(&amp;sampleRate,sizeof(unsigned long),1,fpSave); fwrite(&amp;byteRate,sizeof(unsigned long),1,fpSave); fwrite(&amp;wavBlockAlign,sizeof(unsigned short),1,fpSave); //    .   “”   . 8 , 16   .. fwrite(&amp;bitsPerSample,sizeof(unsigned short),1,fpSave); type[0]='d'; type[1]='a'; type[2]='t'; type[3]='a'; // subchunk2Id //   “data” (0x64617461  big-endian ) fwrite(&amp;type, sizeof(char), 4,fpSave); wavSubchunk2Size = 0; //    . fwrite(&amp;wavSubchunk2Size, sizeof(unsigned long), 1,fpSave); return 1; } void sdb::writeSampleWavFile(void* data) { fwrite(data, wavLenDataType, wavBlockAlign, fpSave); wavSubchunk2Size = wavSubchunk2Size + wavLenDataType*wavBlockAlign; } void sdb::writeDataBlockWavFile(void* data, unsigned long len) { fwrite(data, wavLenDataType, len, fpSave); wavSubchunk2Size = wavSubchunk2Size + len*wavLenDataType; } //         . void sdb::closeWavFile(void) { wavChunkSize = wavSubchunk2Size + 44 - 8; fseek(fpSave,4,SEEK_SET); fwrite(&amp;wavChunkSize,4,1,fpSave); fseek(fpSave,40,SEEK_SET); fwrite(&amp;wavSubchunk2Size,4,1,fpSave); fclose(fpSave); } //  sdb::sdb(void) { openAlnBuf = 0; wavBlockAlign = 0; wavSubchunk2Size = 0; wavChunkSize = 0; wavLenDataType = 0; fpSave = NULL; strcat(wavFileName,SDB_WAV_FILE_NAME); dTime = 1.0/(double)SDB_OPENAL_FREQUENCY; allTime = 0.0; //      switchBuffer = 0; //    () posAllBuffer = 0; //     posBufferOne = 0; posBufferTwo = 0; isBufferOneFlag = 0; isBufferTwoFlag = 0; isCreateWavFileFlag = 0; busState = SDB_MAX_DATA; uartSetBaudrate(SDB_UART_BAUDRATE); uartSetBit(SDB_UART_BIT); uartSetStopBit(SDB_UART_STOP_BIT); uartSetParityBit(SDB_UART_PARITY); recordOn(); playAudioOn(); } //  sdb::~sdb() { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferTwo); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) { while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); } #endif } } //      one wire void sdb::oneWireSendByte(unsigned char data) { for (register unsigned char i = 0; i &lt; 8; i++) { if((data &amp; (1 &lt;&lt; i)) == 1 &lt;&lt; i) { busState = 0; busDelay(12); busState = SDB_MAX_DATA; busDelay(65); } else { busState = 0; busDelay(65); busState = SDB_MAX_DATA; busDelay(12); } } busState = SDB_MAX_DATA; } //       uart void sdb::uartSendByte(unsigned char data) { unsigned short pBit = 0; //     //   busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; //  for (register unsigned char i = 0; i &lt; 8; i++) { if((data &amp; (1&lt;&lt;i)) == 1&lt;&lt;i) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; pBit++; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   if (uartParityBit != 0) { if ((pBit &amp; 0x0001) == 0) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   busState = -SDB_MAX_DATA; for (register unsigned char i = 0; i &lt; uartStopBit; i++) busDelay(uartT); busState = -SDB_MAX_DATA; } //      uart void sdb::uartSend(unsigned long data) { unsigned short pBit = 0; //     //   busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; //  for (register unsigned char i = 0; i &lt; uartBit; i++) { if((data &amp; (1&lt;&lt;i)) == 1&lt;&lt;i) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   if (uartParityBit != 0) { if ((pBit &amp; 0x0001) == 0) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   busState = -SDB_MAX_DATA; for (register unsigned char i = 0; i &lt; uartStopBit; i++) busDelay(uartT); busState = -SDB_MAX_DATA; } //    UART void sdb::uartSetBaudrate(unsigned long baudrate) { if (baudrate &gt; SDB_UART_BAUDRATE_MAX) baudrate = SDB_UART_BAUDRATE_MAX; uartBaudrate = baudrate; uartT = 1000000 / baudrate; } void sdb::uartSetBit(unsigned char bit) { if (bit &gt; 32) bit = 32; if (bit == 0) bit = 1; if (bit &lt; 8) bit = 8; uartBit = bit; } void sdb::uartSetStopBit(unsigned char bit) { if (bit == 0) bit = 1; uartStopBit = bit; } void sdb::uartSetParityBit(unsigned char state) { if (state &gt; 1) state = 1; uartParityBit = state; } //       void sdb::oneWireReset(void) { busState = SDB_MAX_DATA; busDelay(100); busState = 0;// "0" busDelay(485);//  480 busState = SDB_MAX_DATA; busDelay(65);//  60      busState = 0;// "0" busDelay(400); busState = SDB_MAX_DATA; busDelay(100); } //    1-wire void sdb::oneWireStop(void) { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferOne); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } #if SDB_WITH_OPENAL == 1 while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); #endif if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; } } void sdb::uartStop(void) { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferOne); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) { while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); } #endif if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; } } void sdb::setWavFileName(char* filename) { strcat(wavFileName,filename); } void sdb::playAudioOn(void) { if (isCreateWavFileFlag == 0) isAudioOutput = 1; } void sdb::playAudioOff(void) { if (isCreateWavFileFlag == 0) isAudioOutput = 0; } void sdb::recordOn(void) { if (isCreateWavFileFlag == 0) isWavFileOutput = 1; } void sdb::recordOff(void) { if (isCreateWavFileFlag == 0) { if (isAudioOutput == 1) isWavFileOutput = 0; else isWavFileOutput = 1; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fichier main.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LINUX 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WINDOWS 0x01 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RU 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EN 0x01 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///    #define TYPE_OS WINDOWS ///   #define LANGUAGE_PROGRAM RU #define UART_BUS 0x01 #define ONE_WIRE_BUS 0x02 #include &lt;iostream&gt; #include "SoundsDigitalBus.h" #include "stdlib.h" #include &lt;stdio.h&gt; #endif // MAIN_H_INCLUDED</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fichier main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> sdb soundsDigitalBus; int main() { static FILE *fp = NULL; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    char strData[512]; //    char strChar = 0; //  unsigned char busType; //    int strPos = 0; //    int uartBaudrate = 0; //  UART int uartBit = 8; int uartStopBit = 0; //int uartParityBit = 0; #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU setlocale(LC_ALL, "Russian"); printf("  UART  ,   0,   1-wire.\n"); #else printf("Enter the UART baud rate, or specify 0 if you want 1-wire.\n"); #endif printf("UART Baudrate: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartBaudrate = atoi(strData); if (uartBaudrate == 0) { busType = ONE_WIRE_BUS; } else { busType = UART_BUS; soundsDigitalBus.uartSetBaudrate(uartBaudrate); } printf("\n"); if (busType == UART_BUS) { #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("   UART\n"); #else printf("Enter the number of bits UART.\n"); #endif printf("UART bit: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartBit = atoi(strData); soundsDigitalBus.uartSetBit(uartBit); printf("\n"); #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("    UART\n"); #else printf("Enter the number of stop bits UART.\n"); #endif printf("UART stop bit: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartStopBit = atoi(strData); soundsDigitalBus.uartSetStopBit(uartStopBit); printf("\n"); #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("    UART? (Y/n)\n"); #else printf("Use the parity bit in the UART? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.uartSetParityBit(0); printf("not used\n"); } else { soundsDigitalBus.uartSetParityBit(1); printf("Yes, use\n"); } getchar(); printf("\n"); } FILE_M: printf("\n"); #if TYPE_OS==WINDOWS printf("        .\n"); printf(": D: \\ Games \\ SR2 \\ Rangers.txt\n"); printf(": "); #else printf("Specify the file to convert it to record digital bus.\n"); printf("For example: D: \\ Games \\ SR2 \\ Rangers.txt\n"); printf("File: "); #endif memset(strData,0,512); strPos = 0; while(1) { strChar = getchar(); if (strChar != '\n') { strData[strPos++] = strChar; } else break; } fp = fopen(strData,"rb"); if (fp == NULL) { printf("\n"); #if TYPE_OS==WINDOWS printf("!  %s  !\n",strData); printf("     .\n"); printf("...\n"); #else printf("Error! File %s not found!\n",strData); printf("Try to correctly specify the path to the file.\n"); printf("...\n"); #endif getchar(); goto FILE_M; } //soundsDigitalBus.setWavFileName(strData); printf("\n"); #if SDB_WITH_OPENAL == 1 #if TYPE_OS==WINDOWS printf("      ? (Y/n)\n"); #else printf("Play audio while working digital bus? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.playAudioOff(); printf("not used\n"); } else { soundsDigitalBus.playAudioOn(); printf("Yes, use\n"); } getchar(); printf("\n"); #if TYPE_OS==WINDOWS printf("      ? (Y/n)\n"); #else printf("Record audio while working digital bus? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.recordOff(); printf("not used\n"); } else { soundsDigitalBus.recordOn(); printf("Yes, use\n"); } getchar(); #else soundsDigitalBus.recordOn(); #endif printf("\n"); #if TYPE_OS==WINDOWS printf(" .\n"); #else printf("The transformation started.\n"); #endif unsigned char uartData[8]; if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireReset(); } while(1) { if (fread(uartData,sizeof(unsigned char),1,fp) &gt; 0) { if (busType == UART_BUS) { if (uartBit == 8) { soundsDigitalBus.uartSendByte(uartData[0]); } else { soundsDigitalBus.uartSend(uartData[0]); } } else if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireSendByte(uartData[0]); } } else break; } fclose(fp); if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireStop(); } else if (busType == UART_BUS) { soundsDigitalBus.uartStop(); } #if TYPE_OS==WINDOWS printf(" .\n"); #else printf("Conversion completed.\n"); #endif return 0; //soundsDigitalBus.oneWireReset(); soundsDigitalBus.uartSetBaudrate(1200); for (int i = 0; i &lt; 256; i ++) { for (int len = 0; len &lt; 8; len++) { soundsDigitalBus.uartSendByte(i); } printf("%d\n",i); } soundsDigitalBus.oneWireStop(); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  <b>PS</b> J'ai remarqué une erreur selon laquelle dans le code source, le bit de démarrage est logique 1, pas 0, et le bit d'arrêt est 0, pas 1. Qui a besoin d'une correspondance de base du signal sonore réel peut corriger l'erreur elle-même. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr408485/">https://habr.com/ru/post/fr408485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr408475/index.html">Comment je suis arrivé au monocycle</a></li>
<li><a href="../fr408477/index.html">"Merde, un bug géant m'a survolé": sortie du SDK pour le son surround</a></li>
<li><a href="../fr408479/index.html">Scientifiques: en raison de Pokemon Go dans un accident de la circulation a tué des milliers de personnes dans le monde</a></li>
<li><a href="../fr408481/index.html">Théories et aspirateurs</a></li>
<li><a href="../fr408483/index.html">Nous apprenons l'anglais à partir de jeux informatiques</a></li>
<li><a href="../fr408487/index.html">Il n'y aura pas de scellés sans nouveaux gadgets: YouTube cessera de fonctionner sur les anciens appareils-2</a></li>
<li><a href="../fr408489/index.html">Un jouet ou pas. Et le cinéma interactif?</a></li>
<li><a href="../fr408491/index.html">Lancement d'ICO Descrow aujourd'hui</a></li>
<li><a href="../fr408493/index.html">Les pays les plus «bitcoins» du monde</a></li>
<li><a href="../fr408495/index.html">L'engagement et son évolution en un engagement décentralisé</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>