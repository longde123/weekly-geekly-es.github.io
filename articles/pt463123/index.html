<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏿 🤰🏻 🤶🏻 Biblioteca de gerador de código Assembler para microcontroladores AVR. Parte 3 🤒 🧗🏻 ➖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="← Parte 2. Introdução 
 Parte 4. Programação de dispositivos periféricos e manipulação de interrupções → 
 Biblioteca do gerador de código do assemble...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Biblioteca de gerador de código Assembler para microcontroladores AVR. Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463123/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">← Parte 2. Introdução</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 4. Programação de dispositivos periféricos e manipulação de interrupções →</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Biblioteca do gerador de código do assembler para microcontroladores AVR </h2><br><h3 id="chast-3-kosvennaya-adresaciya-i-upravlenie-potokom-ispolneniya">  Parte 3. Endereçamento indireto e controle de fluxo </h3><br><p>  Na parte anterior, detalhamos bastante o trabalho com variáveis ​​de registro de 8 bits.  Se você perdeu o post anterior, aconselho a lê-lo.  Nele, você pode encontrar um link para a biblioteca para experimentar os exemplos no artigo.  Para quem baixou a biblioteca anteriormente, recomendo baixar a versão mais recente, pois a biblioteca é atualizada constantemente e alguns exemplos podem não funcionar na versão antiga da biblioteca. </p><a name="habracut"></a><br><p>  Infelizmente, as profundidades de bits das variáveis ​​de registro consideradas anteriormente claramente não são suficientes para serem usadas como ponteiros de memória.  Portanto, antes de prosseguir diretamente para a discussão de ponteiros, consideramos outra classe de descrição de dados.  A maioria dos comandos na arquitetura AVR Mega é projetada para funcionar apenas com operandos de registro, ou seja, ambos os operandos e o resultado têm tamanho de 8 bits.  No entanto, existem várias operações em que dois registros RON localizados consecutivamente são considerados como um único registro de 16 bits.  Existem poucas operações desse tipo, e elas estão focadas principalmente no trabalho com ponteiros. </p><br><p>  Do ponto de vista da sintaxe da biblioteca, trabalhar com um par de registradores é quase o mesmo que trabalhar com uma variável de registrador.  Considere um pequeno exemplo em que tentamos trabalhar com um par de registradores.  Para economizar espaço aqui e abaixo, forneceremos o resultado da execução somente onde for necessário explicar certos recursos da geração de código. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dr1 = m.DREG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dr2 = m.DREG(); dr1.Load(<span class="hljs-number"><span class="hljs-number">0xAA55</span></span>); dr2.Load(<span class="hljs-number"><span class="hljs-number">0x55AA</span></span>); dr1++; dr1--; dr1 += <span class="hljs-number"><span class="hljs-number">0x100</span></span>; dr1 += dr2; dr2 *= dr1; dr2 /= dr1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = AVRASM.Text(m);</code> </pre> <br><p>  Neste exemplo, declaramos duas variáveis ​​de 2 bytes localizadas em pares de registradores usando o comando DREG ().  Com os seguintes comandos, atribuímos a eles o valor inicial e executamos uma série de operações aritméticas.  Como você pode ver no exemplo, a sintaxe para trabalhar com um par de registradores é basicamente a mesma que trabalhar com um registrador regular.  Um par de registradores também pode ser considerado como uma variável composta por dois registradores independentes.  O registro é acessado como um conjunto de dois registros de 8 bits através da propriedade <em>High</em> para acessar os 8 bits superiores como um registro de 8 bits, e a propriedade <em>Low</em> para acessar os 8 bits inferiores.  O código ficará assim </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dr1 = m.DREG(); dr1.Load(<span class="hljs-number"><span class="hljs-number">0xAA55</span></span>); dr1.Low--; dr1.High += dr1.Low; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = AVRASM.Text(m);</code> </pre> <br><p>  Como você pode ver no exemplo, podemos trabalhar com <em>High</em> e <em>Low</em> como variáveis ​​de registro independentes, incluindo a execução de várias operações aritméticas e lógicas entre elas. </p><br><p>  Agora que descobrimos variáveis ​​de tamanho duplo, podemos começar a descrever como trabalhar com variáveis ​​na memória.  A biblioteca permite que você trabalhe com variáveis ​​de 8, 16 bits e matrizes de bytes de comprimento arbitrário.  Considere um exemplo de alocação de espaço para variáveis ​​na RAM. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bt = m.BYTE(); <span class="hljs-comment"><span class="hljs-comment">//8-    var wd = m.WORD(); //16-    var arr = m.ARRAY(16); //  16  var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Vamos ver o que aconteceu. </p><br><pre> <code class="dos hljs"><span class="hljs-function"><span class="hljs-function">RESET: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">high</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RAMEND</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPH</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">low</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RAMEND</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPL</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSEG</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0002</span></span></span><span class="hljs-function">: .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BYTE</span></span></span><span class="hljs-function"> 16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0001</span></span></span><span class="hljs-function">: .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BYTE</span></span></span><span class="hljs-function"> 2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0000</span></span></span><span class="hljs-function">: .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BYTE</span></span></span><span class="hljs-function"> 1</span></span></code> </pre> <br><p>  Na seção de definição de dados, temos uma alocação de memória.  Observe que a ordem de alocação é diferente da declaração de variáveis.  Isso não é coincidência.  A alocação de memória para variáveis ​​ocorre após a classificação em ordem decrescente, de acordo com os seguintes critérios (em ordem decrescente de importância) O múltiplo máximo de divisor de grau 2 → O tamanho da memória alocada.  Isso significa que, se quisermos alocar 4 matrizes de tamanho de 64, 48,40 e 16 bytes, a ordem de alocação, independentemente da ordem da declaração, terá a seguinte aparência: </p><br><p>  Comprimento 64 - Múltiplos divisores máximos de grau 2 = 64 <br>  Comprimento 48 - Múltiplos divisores máximos de grau 2 = 16 <br>  Comprimento 16 - Múltiplo máximo de divisor de grau 2 = 16 <br>  Comprimento 40 - Múltiplos divisores máximos de grau 2 = 8 <br>  Isso é feito para simplificar o controle dos limites da matriz. <br>  e reduza o tamanho do código nas operações com ponteiros.  Não podemos executar diretamente nenhuma operação com variáveis ​​na memória; portanto, tudo o que está disponível para nós é a leitura / gravação para registrar variáveis.  A maneira mais simples de trabalhar com variáveis ​​na memória é o endereçamento direto. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bt = m.BYTE(); <span class="hljs-comment"><span class="hljs-comment">// 8-    var rr = m.REG(); //    rr.Load(0xAA); //  rr   0xAA rr.Mstore(bt); //     rr.Clear(); //  rr.Mload(bt); //    var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Neste exemplo, declaramos uma variável na memória e uma variável de registro.  Depois disso, atribuímos à variável o valor 0x55 e escrevemos na variável na memória.  Depois apagado e restaurado de volta. </p><br><p>  Para trabalhar com elementos de matriz, usamos a seguinte sintaxe </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr = m.REG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = m.ARRAY(<span class="hljs-number"><span class="hljs-number">10</span></span>); rr.MLoad(arr[<span class="hljs-number"><span class="hljs-number">5</span></span>]);</code> </pre> <br><p>  A numeração dos elementos na matriz começa com 0. Portanto, no exemplo acima, o valor 6 do elemento da matriz é gravado na célula rr. </p><br><p>  Agora você pode ir para o endereçamento indireto.  A biblioteca possui seu próprio tipo de dados para um ponteiro para o espaço de memória RAM - <em>MEMPtr</em> .  Vamos ver como podemos usá-lo.  Modificamos nosso exemplo anterior para que o trabalho com a variável na memória seja realizado através do ponteiro. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bt1 = m.BYTE(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bt2 = m.BYTE(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr = m.REG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = m.MEMPTR(); <span class="hljs-comment"><span class="hljs-comment">//  ptr ptr.Load(bt1); //ptr   bt1 rr.Load(0xAA); // rr - 0xAA ptr.MStore(rr); //  bt1 0xAA rr.Load(0x55); // rr - 0x55 ptr.Load(bt2); //ptr   bt2 ptr.MStore(rr); //  bt2 0x55 ptr.Load(bt1); //ptr   bt1 ptr.MLoad(rr); //  rr  0xAA var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Pode ser visto no texto que declaramos primeiro o <em>ponteiro ptr</em> e, em seguida, executamos operações de gravação e leitura com ele.  Além da capacidade de alterar o endereço de leitura / gravação no comando durante a execução, o uso do ponteiro simplifica o trabalho com matrizes, combinando a operação de leitura / gravação com o incremento / decremento do ponteiro.  Vejamos um programa que pode preencher uma matriz com um valor específico. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bt1 = m.ARRAY(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   4  var rr = m.REG(); var ptr = m.MEMPTR(); ptr.Load(bt1.Label); //ptr   bt1 rr.Load(0xAA); // rr - 0xAA ptr.MStoreInc(rr); //  bt1 0xAA ptr.MStoreInc(rr); //  bt1+1 0xAA ptr.MStoreInc(rr); //  bt1+2 0xAA ptr.MStoreInc(rr); //  bt1+3 0xAA rr.Clear(); rr.MLoad(bt1[2]); //  rr 3-   var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Neste exemplo, aproveitamos a capacidade de incrementar um ponteiro ao gravar na memória. <br>  Em seguida, passamos à capacidade da biblioteca de controlar o fluxo de comandos.  Se for mais fácil, como programar saltos e loops condicionais e incondicionais usando a biblioteca.  A maneira mais fácil de gerenciar isso é usar comandos de navegação de etiqueta.  Os rótulos de um programa são declarados de duas maneiras diferentes.  A primeira é que, com a equipe <em>AVRASM.Label</em> , criamos um rótulo para uso futuro, mas não o inserimos no código do programa.  Este método é usado para criar saltos para frente, ou seja, nos casos em que o comando de salto deve preceder o rótulo.  Para definir o rótulo no local necessário do código do assembler, você deve executar o comando <em>AVRASM.newLabel ([variável do rótulo criado anteriormente])</em> .  Para voltar, você pode usar uma sintaxe mais simples, definindo um rótulo e atribuindo seu valor a uma variável com um comando <em>AVRASM.newLabel ()</em> sem parâmetros. </p><br><p>  O tipo mais simples de transição é uma transição incondicional.  Para chamá-lo, usamos o <em>comando GO ([jump_mark]]</em> .  Vamos ver como fica com um exemplo. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = m.REG(); <span class="hljs-comment"><span class="hljs-comment">//  var lbl1 = AVRASM.Label;//        m.GO(lbl1); r++; //    r++; AVRASM.NewLabel(lbl1);//  //  var lbl2 = AVRASM.NewLabel();//    r--; //    r--; m.GO(lbl2); var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Transições condicionais têm mais controle sobre o fluxo de execução.  Seu comportamento depende do estado dos sinalizadores de operação e isso possibilita o controle do fluxo de operações, dependendo do resultado de sua execução.  A biblioteca usa a função <em>SE</em> para descrever um bloco de comandos que devem ser executados somente sob determinadas condições.  Vejamos um exemplo. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr1 = m.REG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr2 = m.REG(); rr1.Load(<span class="hljs-number"><span class="hljs-number">0x22</span></span>); rr2.Load(<span class="hljs-number"><span class="hljs-number">0x33</span></span>); m.IF(rr1 == rr2, () =&gt; { AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">" - ,  "</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = AVRASM.Text(m);</code> </pre> <br><p>  Como a sintaxe do comando <em>IF</em> não é muito familiar, considere-a em mais detalhes.  O primeiro argumento aqui é a condição de transição.  A seguir está o método no qual o bloco de código é colocado, que deve ser executado se a condição for atendida.  Uma variante da função é a capacidade de descrever uma ramificação alternativa, ou seja, um bloco de código que deve ser executado se a condição não for atendida.  Além disso, você pode prestar atenção à função <em>AVRASM.Comment ()</em> , com a qual podemos adicionar comentários ao assembler de saída. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr1 = m.REG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr2 = m.REG(); rr1.Load(<span class="hljs-number"><span class="hljs-number">0x22</span></span>); rr2.Load(<span class="hljs-number"><span class="hljs-number">0x33</span></span>); m.IF(rr1 == rr2, () =&gt; { AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">" - ,  "</span></span>); },()=&gt; { AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">" - ,   "</span></span>); }); AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = AVRASM.Text(m);</code> </pre> <br><p>  O resultado neste caso terá a seguinte aparência </p><br><pre> <code class="dos hljs"><span class="hljs-function"><span class="hljs-function">RESET: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">high</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RAMEND</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPH</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">low</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RAMEND</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPL</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DEF</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0000</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r20</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DEF</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0001</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r21</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0000</span></span></span><span class="hljs-function">,34 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0001</span></span></span><span class="hljs-function">,51 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0000</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0001</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brne</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0002</span></span></span><span class="hljs-function"> ;---  - ,   --- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xjmp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0004</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0002</span></span></span><span class="hljs-function">: ;---  - ,    --- </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0004</span></span></span><span class="hljs-function">: ;---   --- .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSEG</span></span></span></span></code> </pre> <br><p>  Os exemplos anteriores mostram uma opção de ramificação condicional na qual um comando de comparação é usado para determinar as condições de ramificação.  Em alguns casos, isso não é necessário, pois as condições de transição devem ser determinadas pelo estado dos sinalizadores após a última operação executada.  A sintaxe a seguir é fornecida para esses casos. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr1 = m.REG(); rr1.Load(<span class="hljs-number"><span class="hljs-number">0x22</span></span>); rr1--; m.IFEMPTY(() =&gt;AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">",    0"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = AVRASM.Text(m);</code> </pre> <br><p>  Neste exemplo, a função <em>IFEMPTY</em> verifica o status do sinalizador Z após um incremento e executa o código do bloco condicional quando atinge 0. <br>  A mais flexível em termos de uso pode ser considerada a função <em>LOOP</em> .  Destina-se a uma descrição conveniente dos ciclos do programa.  Considere a assinatura dela </p><br><pre> <code class="cs hljs">LOOP(Register iter, Action&lt;Register, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Condition, Action&lt;Register, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; body)</code> </pre> <br><p>  O parâmetro <em>iter</em> atribui uma variável de registro que pode ser usada como um iterador em um loop.  O segundo parâmetro contém um bloco de código que descreve as condições para sair do loop.  O iterador atribuído e o rótulo inicial do loop a serem retornados são passados ​​para este bloco de código.  O último parâmetro é usado para descrever o bloco de código do corpo principal do loop.  O exemplo mais simples de uso da função <em>LOOP</em> é um loop de stub, ou seja, um loop infinito para pular para a mesma linha.  A sintaxe nesse caso será a seguinte </p><br><pre> <code class="cs hljs">m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r,l) =&gt; { });</code> </pre> <br><p>  O resultado da compilação é dado abaixo. </p><br><pre> <code class="dos hljs"><span class="hljs-function"><span class="hljs-function">L0002: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xjmp</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0002</span></span></span></span></code> </pre> <br><p>  Vamos voltar ao nosso exemplo de preenchimento de uma matriz com um determinado valor e alterá-lo para que o preenchimento seja realizado em um loop </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr1 = m.REG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rr2 = m.REG(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = m.ARRAY(<span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = m.MEMPTR(); ptr.Load(arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//     rr2.Load(16); //    rr1.Load(0xAA); //   m.LOOP(rr2, (r, l) =&gt; //rr2     . { r--; //   m.IFNOTEMPTY(l); // ,   }, (r,l) =&gt; ptr.MStoreInc(rr1)); //   var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  O código de saída, neste caso, terá a seguinte aparência </p><br><pre> <code class="dos hljs"><span class="hljs-function"><span class="hljs-function">RESET: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">high</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RAMEND</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPH</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">low</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RAMEND</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SPL</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r16</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DEF</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0000</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r20</span></span></span><span class="hljs-function"> .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DEF</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0001</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r21</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YL</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LOW</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0002</span></span></span><span class="hljs-function">+0) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">YH</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HIGH</span></span></span><span class="hljs-function">(</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0002</span></span></span><span class="hljs-function">+0) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0001</span></span></span><span class="hljs-function">,16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ldi</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0000</span></span></span><span class="hljs-function">,170 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0003</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">st</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Y</span></span></span><span class="hljs-function">+,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0000</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dec</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">R0001</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brne</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0003</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0004</span></span></span><span class="hljs-function">: .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DSEG</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">L0002</span></span></span><span class="hljs-function">: .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BYTE</span></span></span><span class="hljs-function"> 16</span></span></code> </pre> <br><p>  Outra maneira de organizar transições é através de transições endereçadas indiretamente.  O analógico mais próximo em idiomas de alto nível para eles é um ponteiro para uma função.  O ponteiro nesse caso não apontará para o espaço da RAM, mas para o código do programa.  Como o AVR possui uma arquitetura de Harvard e usa seu próprio conjunto específico de instruções para acessar a memória do programa, o ROMPtr, em vez do MEMPtr descrito acima, é usado como ponteiro.  O caso de uso para transições endereçadas indiretamente pode ser ilustrado pelo exemplo a seguir. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block1 = AVRASM.Label; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block2 = AVRASM.Label; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block3 = AVRASM.Label; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = m.ROMPTR(); ptr.Load(block1); <span class="hljs-comment"><span class="hljs-comment">//     var loop = AVRASM.NewLabel(); AVRASM.Comment("   "); m.GOIndirect(ptr); //   ,     AVRASM.NewLabel(block1); AVRASM.Comment("  1"); ptr.Load(block2); m.GO(loop); AVRASM.NewLabel(block2); AVRASM.Comment("  2"); ptr.Load(block3); m.GO(loop); AVRASM.NewLabel(block3); AVRASM.Comment("  3"); ptr.Load(block1); m.GO(loop); var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Neste exemplo, temos 3 blocos de comandos.  Após a conclusão de cada bloco, o controle é transferido de volta ao comando de filial endereçado indiretamente.  Como no final do bloco de comando, definimos o vetor de transição para um novo bloco a cada vez, a execução será semelhante ao Bloco1 → Bloco2 → Bloco3 → Bloco1 ... e assim por diante em um círculo.  Esse comando, junto com os comandos de ramificação condicional, permite meios simples e convenientes da linguagem para descrever algoritmos tão complexos como uma máquina de estado. </p><br><p>  Uma versão mais sofisticada de uma ramificação endereçada indiretamente é o comando <em>SWITCH</em> .  Ele não usa um ponteiro para um rótulo de transição para a transição, mas um ponteiro para uma variável na memória na qual o endereço do rótulo de transição está armazenado. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block1 = AVRASM.Label; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block2 = AVRASM.Label; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> block3 = AVRASM.Label; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = m.ARRAY(<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = m.MEMPTR(); <span class="hljs-comment"><span class="hljs-comment">//    m.Temp.Load(block1); m.Temp.Store(arr[0]); m.Temp.Load(block2); m.Temp.Store(arr[2]); m.Temp.Load(block3); m.Temp.Store(arr[4]); ptr.Load(arr[0]); //     var loop = AVRASM.NewLabel(); m.SWITCH(ptr); //   ,     AVRASM.NewLabel(block1); AVRASM.Comment("  1"); ptr.Load(arr[2]); //       m.GO(loop); AVRASM.NewLabel(block2); AVRASM.Comment("  2"); m.Temp.Load(block3); ptr.MStore(m.Temp); //       m.GO(loop); AVRASM.NewLabel(block3); AVRASM.Comment("  3"); ptr.Load(arr[0]); //       m.GO(loop);</span></span></code> </pre> <br><p>  Neste exemplo, a sequência de transição será a seguinte: Bloco1 → Bloco2 → Bloco3 → Bloco1 → Bloco3 → Bloco1 → Bloco3 → Bloco1 ... Conseguimos implementar um algoritmo no qual os comandos do Bloco2 são executados apenas no primeiro ciclo. </p><br><p>  Na próxima parte da postagem, consideraremos trabalhar com dispositivos periféricos, implementar interrupções, rotinas e muito mais. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463123/">https://habr.com/ru/post/pt463123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463107/index.html">ShIoTiny: pequena automação, a Internet das coisas ou "seis meses antes das férias"</a></li>
<li><a href="../pt463113/index.html">Controle de versão de dados e modelos no encontro do Computer Vision</a></li>
<li><a href="../pt463115/index.html">A questão das portas no design dos atiradores</a></li>
<li><a href="../pt463117/index.html">Pré-carregando no PHP 7.4</a></li>
<li><a href="../pt463121/index.html">Nós comemos o elefante em partes. Exemplo de estratégia de monitoramento de integridade de aplicativos</a></li>
<li><a href="../pt463125/index.html">OOP em imagens</a></li>
<li><a href="../pt463127/index.html">Monitoramento de UPS. Parte dois - Automatize o Analytics</a></li>
<li><a href="../pt463135/index.html">Em quais países é rentável registrar empresas de TI em 2019?</a></li>
<li><a href="../pt463137/index.html">Mesmo se você quer ser um designer de jogos, ninguém vai te ensinar como</a></li>
<li><a href="../pt463141/index.html">Habr Weekly # 13 / Sob ameaça de 1,5 milhão de usuários de um serviço de encontros, investigação Medusa, decano dos russos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>