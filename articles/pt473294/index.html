<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèΩ ‚ñ∂Ô∏è üí≤ Gerenciamento de mem√≥ria ou menos frequentemente atire no seu p√© üèÇüèø üèÇüèº üçä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Neste artigo, tentarei dizer o que √© gerenciamento de mem√≥ria em programas / aplicativos do ponto de vista de um programador de aplicativos....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gerenciamento de mem√≥ria ou menos frequentemente atire no seu p√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473294/"><p>  Ol√° Habr!  Neste artigo, tentarei dizer o que √© gerenciamento de mem√≥ria em programas / aplicativos do ponto de vista de um programador de aplicativos.  Este n√£o √© um guia ou manual exaustivo, mas simplesmente uma vis√£o geral dos problemas existentes e algumas abordagens para resolv√™-los. </p><br><p>  Por que isso √© necess√°rio?  Um programa √© uma sequ√™ncia de instru√ß√µes de processamento de dados (no caso mais geral).  Esses dados devem ser <strong>armazenados</strong> , <strong>carregados</strong> , <strong>transferidos</strong> etc. de alguma forma.  Todas essas opera√ß√µes n√£o ocorrem instantaneamente, portanto, elas afetam diretamente a velocidade da sua aplica√ß√£o final.  A capacidade de gerenciar dados de maneira otimizada no processo de trabalho permitir√° criar programas n√£o triviais e que exigem muitos recursos. </p><br><p>  Nota: a maior parte do material √© apresentada com exemplos de jogos / mecanismos de jogos (j√° que este t√≥pico √© mais interessante para mim), no entanto, a maior parte do material pode ser aplicada a servidores de grava√ß√£o, aplicativos de usu√°rio, pacotes gr√°ficos etc. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f13/ef3/482/f13ef3482dfe066b41b53e44179a0242.jpg"></p><br><p>  <em>√â imposs√≠vel manter tudo em mente.</em>  <em>Mas se voc√™ n√£o conseguiu carreg√°-lo, receber√° sab√£o</em> </p><a name="habracut"></a><br><h1 id="s-mesta-v-karer">  Logo de cara </h1><br><p>  Aconteceu na ind√∫stria que grandes projetos de jogos AAA s√£o desenvolvidos principalmente em mecanismos escritos usando C ++.  Um dos recursos desse idioma √© a necessidade de gerenciamento manual de mem√≥ria.  Java / C # etc.  Eles possuem coleta de lixo (GarbageCollection / GC) - a capacidade de criar objetos e ainda n√£o liberar a mem√≥ria usada manualmente.  Esse processo simplifica e acelera o desenvolvimento, mas tamb√©m pode causar alguns problemas: um coletor de lixo acionado periodicamente pode matar todo o tempo em tempo real e adicionar congelamentos desagrad√°veis ‚Äã‚Äãao jogo. </p><br><p>  Sim, em projetos como "Minecraft" o GC pode n√£o ser percept√≠vel, pois  eles geralmente n√£o exigem os recursos do computador; no entanto, jogos como "Red Dead Redemption 2", "God of War", "Last of Us" trabalham "quase" no pico do desempenho do sistema e, portanto, precisam n√£o apenas de grandes dimens√µes. quantidade de recursos, mas tamb√©m em sua distribui√ß√£o competente. </p><br><p>  Al√©m disso, trabalhando em um ambiente com aloca√ß√£o autom√°tica de mem√≥ria e coleta de lixo, voc√™ pode encontrar uma falta de flexibilidade no gerenciamento de recursos.  N√£o √© segredo que o Java oculta todos os detalhes e aspectos de implementa√ß√£o de seu trabalho, portanto, na sa√≠da, voc√™ tem apenas a interface instalada para interagir com os recursos do sistema, mas pode n√£o ser suficiente para solucionar alguns problemas.  Por exemplo, iniciar um algoritmo com um n√∫mero n√£o constante de aloca√ß√µes de mem√≥ria em cada quadro (isso pode ser uma busca de caminhos para IA, verifica√ß√£o de visibilidade, anima√ß√£o etc.) inevitavelmente leva a uma queda catastr√≥fica no desempenho. </p><br><h1 id="kak-vyglyadyat-allokacii-v-kode">  Como s√£o as aloca√ß√µes no c√≥digo </h1><br><p>  Antes de continuar a discuss√£o, gostaria de mostrar como o trabalho com mem√≥ria em C / C ++ acontece diretamente com alguns exemplos.  Em geral, a interface padr√£o e mais simples para alocar mem√≥ria do processo √© representada pelas seguintes opera√ß√µes: </p><br><pre><code class="plaintext hljs">//        size  void* malloc(size_t size); //      p void free(void* p);</code> </pre> <br><p>  Aqui voc√™ pode adicionar fun√ß√µes adicionais que permitem alocar um peda√ßo de mem√≥ria alinhado: </p><br><pre> <code class="plaintext hljs">// C11  -     , * alignment void* aligned_alloc(size_t size, size_t alignment); // Posix  -       //        address (*address = allocated_mem_p) int posix_memalign(void** address, size_t alignment, size_t size);</code> </pre> <br><p>  Observe que plataformas diferentes podem oferecer suporte a diferentes padr√µes de fun√ß√µes, dispon√≠veis, por exemplo, no macOS e n√£o dispon√≠veis no win. </p><br><p>  No futuro, √°reas de mem√≥ria <strong>especialmente</strong> alinhadas podem ser necess√°rias para voc√™ atingir a linha de cache do processador e fazer c√°lculos usando um conjunto extenso de registros ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SSE</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MMX</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AVX</a> etc.). </p><br><p>  Um exemplo de um programa de brinquedo que aloca mem√≥ria e imprime valores de buffer, interpretando-os como n√∫meros inteiros assinados: </p><br><pre> <code class="plaintext hljs">/* main.cpp */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; int main(int argc, char** argv) { const int N = 10; int* buffer = (int*) malloc(sizeof(int) * N); for(int i = 0; i &lt; N; i++) { printf("%i ", buffer[i]); } free(buffer); return 0; }</code> </pre> <br><p>  No macOS 10.14, este programa pode ser criado e executado com o seguinte conjunto de comandos: </p><br><pre> <code class="plaintext hljs">$ clang++ main.cpp -o main $ ./main</code> </pre> <br><p>  Nota: daqui em diante, n√£o quero realmente abranger opera√ß√µes C ++ como new / delete, pois √© mais prov√°vel que sejam usadas para construir / destruir objetos diretamente, mas elas usam as opera√ß√µes usuais com mem√≥ria como malloc / free. </p><br><h1 id="problemy-s-pamyatyu">  Problemas de mem√≥ria </h1><br><p>  Existem v√°rios problemas que surgem ao trabalhar com a RAM do computador.  Todos eles, de uma maneira ou de outra, s√£o causados ‚Äã‚Äãn√£o apenas pelos recursos do sistema operacional e do software, mas tamb√©m pela arquitetura do ferro no qual todas essas coisas funcionam. </p><br><h3 id="1-kolichestvo-pamyati">  1. Quantidade de mem√≥ria </h3><br><p>  Infelizmente, a mem√≥ria √© fisicamente limitada.  No PlayStation 4, s√£o 8 GiB GDDR5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3,5 GiB, dos quais o sistema operacional reserva para suas necessidades</a> .  A mem√≥ria virtual e a troca de p√°ginas n√£o ajudar√£o muito, pois a troca de p√°ginas para o disco √© uma opera√ß√£o muito lenta (dentro de N quadros por segundo fixos, se falamos de jogos). </p><br><p>  Tamb√©m vale a pena notar o " <em>or√ßamento</em> " limitado - alguma limita√ß√£o artificial na quantidade de mem√≥ria usada, criada para executar o aplicativo em v√°rias plataformas.  Se voc√™ est√° criando um jogo para uma plataforma m√≥vel e deseja oferecer suporte n√£o apenas a um, mas a toda uma linha de dispositivos, ter√° que limitar seu apetite para fornecer um mercado de vendas mais amplo.  Isso pode ser alcan√ßado simplesmente limitando o consumo de RAM e pela capacidade de configurar essa restri√ß√£o, dependendo do gadget no qual o jogo realmente inicia. </p><br><h3 id="2-fragmentaciya">  2. Fragmenta√ß√£o </h3><br><p>  Um efeito desagrad√°vel que aparece durante o processo de v√°rias aloca√ß√µes de peda√ßos de mem√≥ria de v√°rios tamanhos.  Como resultado, voc√™ obt√©m um espa√ßo de endere√ßo fragmentado em v√°rias partes separadas.  Combinar essas partes em blocos √∫nicos de tamanho maior n√£o funcionar√°, pois parte da mem√≥ria est√° ocupada e n√£o podemos mov√™-la livremente. </p><br><p><img src="https://habrastorage.org/webt/8f/un/ie/8funiekbmroqz6xqhdpsyrpovcs.png"><br>  Fragmenta√ß√£o pelo exemplo de aloca√ß√µes sequenciais e libera√ß√µes de blocos de mem√≥ria </p><br><p>  Como resultado: podemos ter mem√≥ria livre suficiente quantitativamente, mas n√£o qualitativamente.  E a pr√≥xima solicita√ß√£o, digamos, "alocar espa√ßo para a faixa de √°udio", o alocador n√£o poder√° satisfazer, porque simplesmente n√£o h√° uma √∫nica pe√ßa de mem√≥ria desse tamanho. </p><br><h3 id="3-kesh-processora">  3. cache da CPU </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9d/592/5e5/e9d5925e5a0fc9629656ead20ce91b36.png"><br>  Hierarquia de mem√≥ria do computador </p><br><p>  O cache de um processador moderno √© um link intermedi√°rio que conecta a mem√≥ria principal (RAM) e o processador √© registrado diretamente.  Aconteceu que o acesso de leitura / grava√ß√£o √† mem√≥ria √© uma opera√ß√£o muito lenta (se falarmos sobre o n√∫mero de ciclos de clock da CPU necess√°rios para executar).  Portanto, existe alguma hierarquia de cache (L1, L2, L3 etc.), que permite, por assim dizer, "de acordo com algumas previs√µes" carregar dados da RAM ou empurr√°-los lentamente para uma mem√≥ria mais lenta. </p><br><p>  A coloca√ß√£o de objetos do mesmo tipo em uma linha na mem√≥ria permite acelerar "significativamente" o processo de processamento (se o processamento ocorrer sequencialmente), pois nesse caso √© mais f√°cil prever quais dados ser√£o necess√°rios em seguida.  E "significante" significa ganhos de produtividade √†s vezes.  Os desenvolvedores do mecanismo Unity falaram repetidamente sobre isso em seus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rios no GDC</a> . </p><br><h3 id="4-multi-threading">  4. Multi-rosqueamento </h3><br><p>  <strong>Garantir o acesso seguro √† mem√≥ria compartilhada em um ambiente com v√°rios threads</strong> √© um dos principais problemas que voc√™ ter√° que resolver ao criar seu pr√≥prio mecanismo de jogo / jogo / qualquer outro aplicativo que use v√°rios threads para obter melhor desempenho.  Os computadores modernos s√£o organizados de uma maneira n√£o trivial.  Temos uma estrutura de cache complexa e v√°rios n√∫cleos de calculadora.  Tudo isso, se usado incorretamente, pode levar a situa√ß√µes em que os dados compartilhados do seu processo ser√£o danificados como resultado de v√°rios encadeamentos (se eles tentarem trabalhar simultaneamente com esses dados sem controle de acesso).  No caso mais simples, ficar√° assim: <br><img src="https://habrastorage.org/webt/sl/dm/2y/sldm2ybotnk9ncozwf5rkgozifw.png"><br>  N√£o quero me aprofundar no t√≥pico da programa√ß√£o multithread, pois muitos de seus aspectos v√£o muito al√©m do escopo do artigo ou mesmo do livro inteiro. </p><br><h3 id="5-mallocfree">  5. Malloc / gr√°tis </h3><br><p>  As opera√ß√µes de aloca√ß√£o / libera√ß√£o n√£o ocorrem instantaneamente.  Nos sistemas operacionais modernos, se falamos de Windows / Linux / MacOS, eles s√£o bem implementados e funcionam <em>rapidamente na maioria das situa√ß√µes</em> .  Mas, potencialmente, esta √© uma opera√ß√£o que consome muito tempo.  N√£o √© apenas uma chamada do sistema, mas, dependendo da implementa√ß√£o, pode demorar um pouco para encontrar um peda√ßo de mem√≥ria adequado (primeiro ajuste, melhor ajuste etc.) ou para encontrar um local para inserir e / ou mesclar a √°rea liberada. </p><br><p>  Al√©m disso, a mem√≥ria rec√©m-alocada pode n√£o ser realmente mapeada para p√°ginas f√≠sicas reais, o que tamb√©m pode levar algum tempo no primeiro acesso. </p><br><p>  Esses s√£o detalhes da implementa√ß√£o, mas e a aplicabilidade?  Malloc / new n√£o tem id√©ia de onde, como ou por que voc√™ os chamou.  Eles alocam mem√≥ria (no pior caso) de 1 KiB e 100 MiB igualmente ... igualmente ruins.  Diretamente, a estrat√©gia de uso √© deixada para o programador ou para quem implementou o tempo de execu√ß√£o do seu programa. </p><br><h3 id="6-memory-corruption">  6. corrup√ß√£o de mem√≥ria </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como diz o wiki</a> , este √© um dos erros mais imprevis√≠veis que aparece apenas durante o curso do programa, e geralmente √© causado diretamente por erros na cria√ß√£o deste programa.  Mas qual √© esse problema?  Felizmente (ou infelizmente), isso n√£o est√° relacionado √† corrup√ß√£o do seu computador.  Em vez disso, exibe uma situa√ß√£o em que voc√™ est√° tentando trabalhar com mem√≥ria que <em>n√£o lhe pertence</em> .  Vou explicar agora: </p><br><ol><li>  Isso pode ser uma tentativa de leitura / grava√ß√£o em uma √°rea de mem√≥ria n√£o alocada. </li><li>  Indo al√©m dos limites do bloco de mem√≥ria fornecido a voc√™.  Esse problema √© um tipo especial de problema (1), mas √© pior porque o sistema avisa que voc√™ ultrapassou os limites somente quando voc√™ deixou a p√°gina exibida para voc√™.  Ou seja, potencialmente, esse problema √© muito dif√≠cil de resolver, porque o sistema operacional pode responder apenas se voc√™ deixar os limites das p√°ginas virtuais exibidas para voc√™.  Voc√™ pode estragar a mem√≥ria do processo e obter um erro muito estranho no local em que n√£o era esperado. </li><li>  Liberar uma mem√≥ria j√° liberada (soa estranha) ou ainda n√£o alocada </li><li>  etc. </li></ol><br><p>  Em C / C ++, onde h√° aritm√©tica de ponteiro, voc√™ encontrar√° essa uma ou duas vezes.  No entanto, no Java Runtime, voc√™ precisa suar bastante para obter esse tipo de erro (eu ainda n√£o tentei, mas acho que isso √© poss√≠vel, caso contr√°rio, a vida seria muito simples). </p><br><h3 id="7-utechki-pamyati">  7. vazamentos de mem√≥ria </h3><br><p>  √â um caso especial de um problema mais geral que ocorre em muitas linguagens de programa√ß√£o.  A biblioteca C / C ++ padr√£o fornece acesso aos recursos do SO.  Pode ser arquivos, soquetes, mem√≥ria, etc.  Ap√≥s o uso, o recurso deve ser corretamente fechado e <br>  a mem√≥ria ocupada por ele deve ser liberada.  E falar especificamente sobre a libera√ß√£o da mem√≥ria - vazamentos acumulados como resultado do programa podem levar a um erro de "falta de mem√≥ria", quando o sistema operacional n√£o poder√° atender √† pr√≥xima solicita√ß√£o de aloca√ß√£o.  Freq√ºentemente, o desenvolvedor simplesmente esquece de liberar a mem√≥ria usada por um motivo ou outro. </p><br><p>  Aqui vale a pena adicionar sobre o fechamento e a libera√ß√£o corretos de recursos na GPU, porque os primeiros drivers n√£o permitiram continuar o trabalho com a placa de v√≠deo se a sess√£o anterior n√£o foi conclu√≠da corretamente.  Somente a reinicializa√ß√£o do sistema poderia resolver esse problema, o que √© muito duvidoso - para for√ßar o usu√°rio a reiniciar o sistema ap√≥s executar o aplicativo. </p><br><h3 id="8-dangling-pointer">  8. Ponteiro oscilante </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Um ponteiro pendente</strong></a> √© um jarg√£o que descreve uma situa√ß√£o em que um ponteiro se refere a um valor inv√°lido.  Uma situa√ß√£o semelhante pode surgir facilmente ao usar ponteiros de estilo C cl√°ssicos em um programa C / C ++.  Suponha que voc√™ alocou mem√≥ria, salvou o endere√ßo no ponteiro p e liberou a mem√≥ria (veja o exemplo de c√≥digo): </p><br><pre> <code class="plaintext hljs">//   void* p = malloc(size); // ...  -    //   free(p); //    p? // *p == ?</code> </pre> <br><p>  O ponteiro armazena algum valor, que podemos interpretar como o endere√ßo do bloco de mem√≥ria.  Aconteceu que n√£o podemos dizer se esse bloco de mem√≥ria √© v√°lido ou n√£o.  Somente um programador, com base em determinados contratos, pode operar com um ponteiro.  A partir do C ++ 11, v√°rios ponteiros ‚Äúponteiros inteligentes‚Äù adicionais foram introduzidos na biblioteca padr√£o, o que permite, de alguma forma, enfraquecer o controle de recursos pelo programador usando meta-informa√ß√µes adicionais dentro de si (mais sobre isso posteriormente). </p><br><p>  Como solu√ß√£o parcial, voc√™ pode usar o <em>valor especial do</em> ponteiro, que nos indicar√° que n√£o h√° nada neste endere√ßo.  Em C, a macro NULL √© usada como o valor desse valor e, em C ++, a palavra-chave da linguagem nullptr.  A solu√ß√£o √© parcial, porque: </p><br><ol><li>  O valor do ponteiro deve ser definido manualmente, para que o programador possa simplesmente esquecer de faz√™-lo. </li><li>  nullptr ou apenas 0x0 s√£o inclu√≠dos no conjunto de valores aceitos pelo ponteiro, o que n√£o √© bom quando o estado especial de um objeto √© expresso por meio do estado usual.  Isso √© algum tipo de legado e, por acordo, o sistema operacional n√£o alocar√° para voc√™ um peda√ßo de mem√≥ria cujo endere√ßo come√ßa com 0x0. </li></ol><br><p>  C√≥digo de amostra com nulo: </p><br><pre> <code class="plaintext hljs">//  -  p free(p); p = nullptr; //   p == nullptr   ,       </code> </pre> <br><p>  Voc√™ pode automatizar esse processo at√© certo ponto: </p><br><pre> <code class="plaintext hljs">void _free(void* &amp;p) { free(p); p = nullptr; } //  -  p _free(p); //   p == nullptr,     //   </code> </pre> <br><h3 id="9-tip-pamyati">  9. Tipo de mem√≥ria </h3><br><p>  <strong>A RAM</strong> √© uma mem√≥ria de acesso aleat√≥rio de uso geral comum, cujo acesso atrav√©s do barramento central possui todos os n√∫cleos do seu processador e dispositivos perif√©ricos.  Seu volume varia, mas na maioria das vezes estamos falando de N gigabytes, onde N √© 1,2,4,8,16 e assim por diante.  As chamadas malloc / free procuram colocar o bloco de mem√≥ria que voc√™ deseja diretamente na RAM do computador. </p><br><p>  <strong>VRAM</strong> (mem√≥ria de v√≠deo) - mem√≥ria de v√≠deo, fornecida com a placa de v√≠deo / acelerador de v√≠deo do seu PC.  Por regra, √© menor que a RAM (cerca de 1.2.4 GiB), mas possui alta velocidade.  A distribui√ß√£o desse tipo de mem√≥ria √© gerenciada pelo driver da placa de v√≠deo e, na maioria das vezes, voc√™ n√£o tem acesso direto a ela. </p><br><p>  N√£o existe essa separa√ß√£o no PlayStation 4, e toda a RAM √© representada por um √∫nico 8 gigabytes no GDDR5.  Portanto, todos os dados do processador e do acelerador de v√≠deo est√£o pr√≥ximos. </p><br><p>  Um bom gerenciamento de recursos no mecanismo de jogo inclui aloca√ß√£o de mem√≥ria competente tanto na RAM principal quanto no lado da VRAM.  Aqui voc√™ pode encontrar <strong>duplica√ß√£o</strong> quando os mesmos dados estiverem l√° e ali, ou com <strong>transfer√™ncia excessiva de</strong> dados da RAM para VRAM e vice-versa. </p><br><p>  <strong>Como uma ilustra√ß√£o de todos os problemas mencionados</strong> : voc√™ pode ver os aspectos dos computadores dos dispositivos no exemplo da arquitetura do PlayStation 4 (Fig.).  Aqui est√° o processador central, 8 n√∫cleos, caches de n√≠vel L1 e L2, barramentos de dados, RAM, acelerador de gr√°ficos, etc.  Para uma descri√ß√£o completa e detalhada, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Game Engine Architecture" de</a> Jason Gregory. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c50/7ba/756/c507ba75624a3c9be702f85ddfa50e11.png"><br>  Arquitetura PlayStation 4 </p><br><h1 id="obschie-podhody-k-resheniyu">  Abordagens gerais </h1><br><p>  N√£o h√° solu√ß√£o universal.  Mas h√° um conjunto de alguns pontos nos quais voc√™ deve se concentrar para implementar a aloca√ß√£o manual e o gerenciamento de mem√≥ria em seu aplicativo.  Isso inclui cont√™ineres e alocadores especializados, estrat√©gias de aloca√ß√£o de mem√≥ria, design de sistema / jogo, gerenciadores de recursos e muito mais. </p><br><h2 id="tipy-allokatorov">  Tipos de alocadores </h2><br><p>  O uso de alocadores de mem√≥ria especiais baseia-se na seguinte id√©ia: voc√™ sabe qual o tamanho, em quais momentos do trabalho e em que local precisar√° de pe√ßas de mem√≥ria.  Portanto, voc√™ pode alocar a mem√≥ria necess√°ria, estrutur√°-la de alguma forma e us√°-la / reutiliz√°-la.  Essa √© a id√©ia / conceito geral de usar alocadores especiais.  O que s√£o (√© claro, nem todos) pode ser visto mais adiante: </p><br><ol><li><p>  <strong>Alocador linear</strong> <br>  Representa um buffer de espa√ßo de endere√ßo cont√≠guo.  No decorrer do trabalho, ele permite alocar √°reas de mem√≥ria de tamanho arbitr√°rio (para que elas se ajustem a um buffer).  Mas voc√™ pode liberar toda a mem√≥ria alocada apenas 1 vez.  Ou seja, uma parte arbitr√°ria da mem√≥ria n√£o pode ser liberada - ela permanecer√° como se estivesse <em>ocupada</em> at√© que todo o buffer seja marcado como limpo.  Esse design fornece a aloca√ß√£o e libera√ß√£o de O (1), o que garante uma velocidade em qualquer condi√ß√£o. <br><img src="https://habrastorage.org/webt/eb/tp/vm/ebtpvmrs616uwpgdfpd1nujw69s.png"><br>  Caso de uso t√≠pico: no processo de atualiza√ß√£o do estado do processo (todos os quadros do jogo), voc√™ pode usar o LinearAllocator para alocar buffers tmp para qualquer necessidade t√©cnica: processamento de entrada, trabalho com strings, an√°lise de comandos do ConsoleManager no modo de depura√ß√£o, etc. </p><br></li><li><p>  <strong>Alocador de pilha</strong> <br>  Modifica√ß√£o de um alocador linear.  Permite liberar mem√≥ria na ordem inversa de aloca√ß√£o, ou seja, se comporta como uma pilha regular de acordo com o princ√≠pio LIFO.  Pode ser muito √∫til para executar c√°lculos matem√°ticos carregados (hierarquia de transforma√ß√µes), para implementar o trabalho do subsistema de script, para quaisquer c√°lculos em que o procedimento indicado para liberar mem√≥ria seja conhecido antecipadamente. <br><img src="https://habrastorage.org/webt/hu/7j/fm/hu7jfm6iqhxz0uk5xwo_ayzwyfo.png"><br>  A simplicidade do design fornece aloca√ß√£o de mem√≥ria O (1) e velocidade de libera√ß√£o. </p><br></li><li><p>  <strong>Alocador de pool</strong> <br>  Permite alocar blocos de mem√≥ria do mesmo tamanho.  Pode ser implementado como um buffer de espa√ßo de endere√ßo cont√≠nuo, dividido em blocos de tamanho predeterminado.  Esses blocos podem formar uma lista vinculada.  E sempre sabemos qual bloco ceder na pr√≥xima aloca√ß√£o.  Essa metainforma√ß√£o pode ser armazenada nos pr√≥prios blocos, o que imp√µe uma restri√ß√£o ao tamanho m√≠nimo do bloco (sizeof (void *)).  Na realidade, isso n√£o √© cr√≠tico. <br><img src="https://habrastorage.org/webt/cv/sl/qz/cvslqzmqj1nsp-gtqccoyx6hwy4.png"><br>  Como todos os blocos s√£o do mesmo tamanho, n√£o importa para n√≥s qual bloco retornar e, portanto, todas as opera√ß√µes de aloca√ß√£o / desaloca√ß√£o podem ser executadas em O (1). </p><br></li><li><p>  <strong>Alocador de quadros</strong> <br>  Alocador linear, mas apenas com refer√™ncia ao quadro atual - permite fazer a aloca√ß√£o de mem√≥ria tmp e liberar automaticamente tudo ao alterar o quadro.  Ele deve ser destacado separadamente, j√° que essa √© uma entidade global e √∫nica dentro da estrutura do jogo em tempo de execu√ß√£o e, portanto, pode ser feita de um tamanho impressionante, digamos algumas d√∫zias de MiB, o que ser√° muito √∫til ao carregar recursos e process√°-los. </p><br></li><li><p>  <strong>Alocador de quadro duplo</strong> <br>  √â um alocador de quadro duplo, mas com alguns recursos.  Permite alocar mem√≥ria no quadro atual e us√°-lo no quadro atual e no pr√≥ximo.  Ou seja, a mem√≥ria que voc√™ alocou no quadro N ser√° liberada somente ap√≥s o quadro N + 1.  Isso √© realizado alternando o quadro ativo para real√ßar no final de cada quadro. <br><img src="https://habrastorage.org/webt/ug/cc/zh/ugcczhvv6ibzbarvb0plwhvgbuu.png"><br>  Mas esse tipo de alocador, como o anterior, imp√µe v√°rias restri√ß√µes √† vida √∫til dos objetos criados na mem√≥ria alocada a ele.  Portanto, voc√™ deve estar ciente de que, no final do quadro, os dados simplesmente se tornam inv√°lidos e o acesso repetido a eles pode causar s√©rios problemas. </p><br></li><li><p>  <strong>Alocador est√°tico</strong> <br>  Esse tipo de alocador aloca mem√≥ria de um buffer obtido, por exemplo, no est√°gio de inicializa√ß√£o do programa ou capturado na pilha em um quadro de fun√ß√£o.  Por tipo, pode ser absolutamente qualquer alocador: linear, pool, pilha.  Por que √© chamado <em>est√°tico</em> ?  O tamanho do buffer de mem√≥ria capturado deve ser conhecido <strong>no est√°gio de compila√ß√£o do</strong> programa.  Isso imp√µe uma limita√ß√£o significativa: a quantidade de mem√≥ria dispon√≠vel para este alocador n√£o pode ser alterada durante a opera√ß√£o.  Mas quais s√£o os benef√≠cios?  O buffer usado ser√° capturado automaticamente e liberado (ap√≥s a conclus√£o do trabalho ou ap√≥s a sa√≠da da fun√ß√£o).  Isso n√£o carrega a pilha, evita a fragmenta√ß√£o, permite alocar rapidamente a mem√≥ria no local. <br>  Voc√™ pode ver o exemplo de c√≥digo usando esse alocador, se precisar quebrar a cadeia de caracteres em substrings e fazer algo com eles: <br><img src="https://habrastorage.org/webt/3s/xk/t5/3sxkt5_00ztji1gesnh0cd1edno.png"><br>  Tamb√©m se pode notar que o uso de mem√≥ria da pilha em teoria √© muito mais eficiente, porque  empilhar o quadro da fun√ß√£o atual com uma alta probabilidade j√° estar√° no cache do processador. </p><br></li></ol><br><p>  Todos esses alocadores, de alguma forma, resolvem os problemas com fragmenta√ß√£o, com falta de mem√≥ria, com a velocidade de recebimento e libera√ß√£o de blocos do tamanho necess√°rio, com a vida √∫til dos objetos e a mem√≥ria que eles ocupam. </p><br><p>  Tamb√©m deve ser observado que a abordagem correta para o design de interface permitir√° criar um tipo de <em>hierarquia de</em> alocadores quando, por exemplo: o pool aloca mem√≥ria a partir da aloca√ß√£o de quadros, e o aloca√ß√£o de quadros, por sua vez, aloca a mem√≥ria a partir da aloca√ß√£o linear.  Uma estrutura semelhante pode ser continuada ainda mais, adaptando-se √†s suas tarefas e necessidades. </p><br><p><img src="https://habrastorage.org/webt/rf/l8/4a/rfl84aakccaw2qfdw6hxlqiygos.png"></p><br><p>  Vejo uma interface semelhante para criar hierarquias da seguinte maneira: </p><br><pre> <code class="plaintext hljs">class IAllocator { public: virtual void* alloc(size_t size) = 0; virtual void* alloc(size_t size, size_t alignment) = 0; virtual void free (void* &amp;p) = 0; }</code> </pre> <br><p>          malloc/free ,     .  ,        ,            .           /    ,       . </p><br><h2 id="umnye-ukazateli">   </h2><br><p> Smart pointer ‚Äî        C++   ++11 (   boost,    ).   -,     ,        -  ,        .                . </p><br><p>       ?     : </p><br><ol><li>       </li><li>   (/) </li><li>    </li></ol><br><p>         : </p><br><ol><li><p> <strong>Unique pointer</strong> <br>      1    ( ). <br>   unique pointer ,          .        , ..    1   / . <br>        uniquePtr1  uniquePtr2,    uniquePtr1 , .   1  . <br><img src="https://habrastorage.org/webt/xl/qd/x2/xlqdx2thnzcg7rvvv0va70zpzl4.png"></p><br></li><li><p> <strong>Shared pointer</strong> <br>        (reference counting).       ,    ,      .    , ,      ,    . <br><img src="https://habrastorage.org/webt/jb/y6/wi/jby6wipfn5sv2ghabpuzzresgsk.png"><br>       . -,       ,      .        . -,  -                . </p><br></li><li><p> <strong>Weak pointer</strong> <br>    .       ,    .  O que isso significa?           shared pointer.   ,   shared pointer  ,     . ,     shared pointer weak pointer.  ,   (shared)    ,   weak pointer    shared pointer.    ‚Äî  weak pointer ,     ,  ,       . <br><img src="https://habrastorage.org/webt/nr/bt/bq/nrbtbqg6rukrcdgmij-v08bpim4.png"><br>   shared,   weak pointer     meta-data   .    -   ,     ..   ,  O(N) overhead  ,  N ‚Äî -  .      , .               ,        .         . </p><br></li></ol><br><p>     :         . ,  shared pointer,     ,    (      )  <em>- - -</em> .           .            meta-info   ,  ,           .  Um exemplo: </p><br><pre> <code class="plaintext hljs">/*     */ /*   ,  shared pointer */ Array&lt;TSharedPtr&lt;Object&gt;&gt; objects; objects.add(newShared&lt;Object&gt;(...)); ... objects.add(newShared&lt;Object&gt;(...));</code> </pre> <br><pre> <code class="plaintext hljs">/*      (   meta-info    ) */ Array&lt;Object&gt; objects; objects.emplace(...); ... objects.emplace(...);</code> </pre> <br><p>   .            .  Sobre isso mais. </p><br><h2 id="unique-id"> Unique id </h2><br><p>      ,    .     (id/identificator),   , ,   -.    : </p><br><ol><li> <strong> </strong> <br>     ,   id.    ,   <strong>  </strong> ,  ,          id. </li><li> <strong>  </strong> <br>      ,          (  ,     ) </li><li> <strong>    </strong> <br>    id  ,      ,        id. </li><li> <strong>    </strong> <br>                 . ,   id,     . </li></ol><br><p>     :    id,   ,      id,         . </p><br><p>  id     ,  (Vulkan, OpenGL),   (Godot, CryEngine).  EntityID   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     CryEngine</a> . </p><br><p>   ,  id   :   .     ,     (   ),     ,      . </p><br><pre> <code class="plaintext hljs">/*    */ class ID { uint32 index; uint32 generation; }</code> </pre> <br><pre> <code class="plaintext hljs">/*  - /  */ class ObjectManager { public: ID create(...); void destroy(ID); void update(ID id, ...); private: Array&lt;uint32&gt; generations; Array&lt;Objects&gt; objects; }</code> </pre> <br><p>   ID        ,     ID .     : </p><br><pre> <code class="plaintext hljs">generation = generations[id.index]; if (generation == id.generation) then /*    */ else /*  ,     */</code> </pre> <br><p>      id      generation  1   id   ids. </p><br><h2 id="konteynery">  </h2><br><p>     C++   ,         .      std,     <strong></strong>   ,   <strong></strong>    .        : </p><br><ul><li> Linked list ‚Äî   </li><li> Array ‚Äî /  </li><li> Queue ‚Äî  </li><li> Stack ‚Äî  </li><li> Map ‚Äî   </li><li> Set ‚Äî  </li></ul><br><p>         ?             memory corruption.        / ,    ,   ,    ,     . </p><br><h1 id="obschie-idei">   </h1><br><p>           ,     ,       .  , ,    /         . </p><br><h2 id="pod-konkretnye-zadachi">    </h2><br><p>   ,      ,       .              ,   (  )   .    ,   malloc/free  ,       ,            . </p><br><p>     ?   ,     (/ ),     ,     ,   .    ,     ,    ,           . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/778/95b/55477895bb7e2fcf71d44ad06ceb8ce3.jpg"><br> ryEngine Sandbox:       </p><br><p>   ,   Unreal, Unity, CryEngine  .,     ,    . ,       , ,     ‚Äî       ,                 . </p><br><h2 id="pre-allocating"> Pre-allocating </h2><br><p>        ,      /          . </p><br><p>    :   malloc/free      .     ,      "run out of memory", .        .         ,       (,   ,     .). </p><br><p>       .          .  ,         -  .           ,           malloc/free,    : ,  ,  . </p><br><h2 id="ne-nado-boyatsya-dinamicheskoy-pamyati">      </h2><br><p>            .   :     ,       , ,   ..             . </p><br><p>    :   ,      ,       ,    .  open-source ,      ,     .   ,  ,   ‚Äî     malloc/free. </p><br><h2 id="dizayn-iz-ogranicheniy">    </h2><br><p>  GDC  CD Project Red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> ,     ,       "The Witcher: Blood and Wine"    ()        .     ,     ,    ,         ,         . <br><img src="https://habrastorage.org/getpro/habr/post_images/80b/c6c/fb0/80bc6cfb08009ba02caee322cb092110.png"></p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a>    Naughty Dog  ,      "Uncharted 4: A Thief's End"     ,         (,    )       . <br><img src="https://habrastorage.org/getpro/habr/post_images/7c4/2c8/469/7c42c84690c9374423bba12dea6126ff.jpg"></p><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>     ,    ,     ,          .       ,         .     / ,     ,   -   ..       ,        (,    ). </p><br><h1 id="literatura-i-poleznye-ssylki">     </h1><br><ul><li>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Game Engine Architecture"</a> .           ,  , , ,   ..  ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Custom memory allocators</a> ‚Äî        ,     C++  .     ,         . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Smart pointers</a> ‚Äî     ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Start Pre-allocating And Stop Worrying</a> ‚Äî        </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt473294/">https://habr.com/ru/post/pt473294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt473284/index.html">Senior, TechLead, Architect - o que vem a seguir? Como lidar com uma rotina de trabalho e para onde seguir em frente?</a></li>
<li><a href="../pt473286/index.html">Escrevemos prote√ß√£o contra ataques DDoS no XDP. Parte nuclear</a></li>
<li><a href="../pt473288/index.html">Crie seu c√≥digo do zero, ele ir√° bombear seu n√≠vel</a></li>
<li><a href="../pt473290/index.html">Julia. Por onde come√ßar o projeto? ...</a></li>
<li><a href="../pt473292/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel n¬∫ 319 (de 21 a 27 de outubro)</a></li>
<li><a href="../pt473296/index.html">Inicializa√ß√£o sem dinheiro. Experi√™ncia pessoal</a></li>
<li><a href="../pt473298/index.html">Como criar processos e parar de zombar de uma equipe</a></li>
<li><a href="../pt473300/index.html">RP na era digital, programas modernos de fidelidade e marketing de festivais</a></li>
<li><a href="../pt473302/index.html">Adeus HTML, Ol√° QML</a></li>
<li><a href="../pt473306/index.html">Conceito de √≥culos de realidade aumentada. Meu fone de ouvido AR perfeito, que √© poss√≠vel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>